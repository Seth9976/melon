/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_BC28();
void sub_BC38();
void sub_BC40();
__int64 (*__fastcall sub_BC48(__int64 (*result)(void)))(void);
__int64 __fastcall sub_BC5C(void *obj); // idb
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMVersion(__int64 a1);
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMIsEmbeddedDRM();
bool Java_DigiCAP_SKT_DRM_DRMInterface_DRMIsExpandedFilePath();
bool hasLibraryFile_MVersionCk();
bool hasLibraryFile_SKT_MusicDRM();
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMInit();
void Java_DigiCAP_SKT_DRM_DRMInterface_DRMDestroy();
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPath(__int64 a1, __int64 a2, __int64 a3, int a4, __int16 a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPfd(__int64 a1, __int64 a2, int a3, int a4, __int16 a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMClose(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMRead(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMSeek(__int64 a1, __int64 a2, unsigned int a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetOriginalFileSize(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetFileSize(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetErrorCode(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentID(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentIDPfd(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentIDPath(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetValidPeriod(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentDescription(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetUnsupportedValue(__int64 *a1, __int64 a2, unsigned __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetUnsupportedValueUTF8(__int64 *a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetMetaDataCharacterSet(__int64 a1, __int64 a2, __int16 a3);
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetMIN();
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetClientID(__int64 a1);
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMSetClientID(__int64 a1, __int64 a2, __int64 a3);
void printLogV();
void printLogI();
void printLogW();
void printLogF();
void printLogS();
void printLogE();
void printLogD();
void printLogUNK();
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3);
__int64 DRM_Check_Extend_FilePath();
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
__int64 DRM_Init();
void DRM_Destroy();
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall sub_E758(__int64 a1);
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3);
__int64 __fastcall DRM_Close(unsigned __int16 a1);
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, int a3);
__int64 __fastcall sub_F154(__int16 a1, int **a2);
__int64 __fastcall sub_F710(__int64 result);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2);
__int64 __fastcall sub_101A4(unsigned __int16 a1);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, int *a3, __int64 a4);
void __fastcall sub_10398(_QWORD *a1);
__int64 __fastcall DRM_GetUnsupportedValue(__int64 a1, _BYTE *a2, _BYTE *a3, int a4);
void *__fastcall DRM_GetFilePath(unsigned __int16 a1);
__int64 __fastcall DRM_GetFileSize(unsigned __int16 a1);
__int64 DRM_SetClientID();
__int64 __fastcall DRM_GetOriginalFileSize(unsigned __int16 a1);
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_1078C(__int16 a1);
void __fastcall sub_10908(void **a1);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
void __fastcall sub_1233C(__int64 a1);
__int64 __fastcall sub_12478(__int64 a1, __int64 *a2);
void __fastcall ClientIDDestroy(_QWORD *a1);
__int64 __fastcall sub_125C0(__int64 a1, unsigned int a2, __int64 **a3);
void __fastcall DomainListDestroy(__int64 a1);
__int64 __fastcall sub_126E8(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6);
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, char *a6, __int16 a7, __int64 a8);
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5, __int64 a6);
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5, __int64 a6);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
char *__fastcall sub_1635C(char *result, __int64 a2, int *a3, int *a4);
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5);
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
void *__fastcall DHmalloc(int a1);
void __fastcall DHfree(void *a1);
FILE *__fastcall DHfsOpen(char *filename, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 DHfsClose(void); // weak
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3);
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3);
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3);
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
__int64 __fastcall DHfsMetaTell(__int64 a1);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
__int64 DHfsTell(void); // weak
__int64 __fastcall DHfsMetaSize(const char *a1);
__int64 __fastcall DHfsSize(const char *a1);
void *__fastcall DHmemset(void *a1, int a2, int a3);
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3);
void *__fastcall DHmemchr(const void *a1, int a2, int a3);
void DHmemcount();
size_t __fastcall DHstrlen(const char *a1);
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 DHstrcmp(void); // weak
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 DHstrcat(void); // weak
char *__fastcall DHstrncat(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
__int64 DHatoi(void); // weak
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
__int64 DHstrstr(void); // weak
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
const char *__fastcall DHstristr(const char *a1, const char *a2);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
_BYTE *__fastcall DHstrupr(_BYTE *result);
__int64 DHvsnprintf(char *a1, int a2, char *s, ...);
__int64 DHsprintf(char *a1, const char *a2, ...);
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
__int64 __fastcall DHGetStateInfo(void *a1);
__int64 DHcurrentTime_ByLib();
__int64 DHcurrentTime();
__int64 DHAuthTime_ByLib();
__int64 DHAuthTime_ByFile();
__int64 DHAuthTime();
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
void __fastcall DHFreeClientID(void *a1);
__int64 DHGetClientID_ByLib();
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3);
__int64 DHGetDeviceID_ByLib();
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
__int64 __fastcall sub_18B4C(_DWORD *a1, __int64 a2, unsigned int a3);
int32x4_t __fastcall sub_18C28(_DWORD *a1, unsigned int *a2);
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3);
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5);
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4);
__int64 DA_DRA_SetClientID(void); // weak
__int64 __fastcall StrErrorReturn(int a1);
__int64 __fastcall StrErrorReturn_uch(int a1);
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
const char *AES_options();
__int64 AES_set_decrypt_key(void); // weak
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
void sub_1B830();
// int __cxa_finalize(void *);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// size_t __strlen_chk(const char *, size_t);
// void *memcpy(void *dest, const void *src, size_t n);
void printLogD();
// int stat(const char *file, struct stat *buf);
__int64 DRM_Init();
void DRM_Destroy();
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPath(__int64 a1, __int64 a2, __int64 a3, int a4, __int16 a5);
// void *memset(void *s, int c, size_t n);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3);
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall DRM_Close(unsigned __int16 a1);
// void *malloc(size_t size);
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, int a3);
// void free(void *ptr);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 __fastcall DRM_GetOriginalFileSize(unsigned __int16 a1);
__int64 __fastcall DRM_GetFileSize(unsigned __int16 a1);
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2);
// int dup(int fd);
// FILE *fdopen(int fd, const char *modes);
// void rewind(FILE *stream);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fclose(FILE *stream);
// FILE *fopen(const char *filename, const char *modes);
// size_t strlen(const char *s);
__int64 __fastcall DRM_GetUnsupportedValue(__int64 a1, _BYTE *a2, _BYTE *a3, int a4);
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
// __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3);
__int64 __fastcall StrErrorReturn(int a1);
__int64 DRM_SetClientID();
size_t __fastcall DHstrlen(const char *a1);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// char *strstr(const char *haystack, const char *needle);
// int strcmp(const char *s1, const char *s2);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
void *__fastcall DHmemset(void *a1, int a2, int a3);
void __fastcall DHfree(void *a1);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
void __fastcall DHFreeClientID(void *a1);
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2);
void *__fastcall DHmalloc(int a1);
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
__int64 DHfsTell();
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3);
void __fastcall ClientIDDestroy(_QWORD *a1);
void __fastcall DomainListDestroy(__int64 a1);
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
__int64 AES_set_decrypt_key();
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, int *a3, __int64 a4);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5, __int64 a6);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, char *a6, __int16 a7, __int64 a8);
const char *__fastcall DHstristr(const char *a1, const char *a2);
__int64 DHatoi();
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
__int64 DHAuthTime();
__int64 DHcurrentTime();
__int64 DHstrcmp();
__int64 DA_DRA_SetClientID();
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5, __int64 a6);
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
__int64 DHstrcat();
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
__int64 DHstrstr();
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
FILE *__fastcall DHfsOpen(char *filename, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 DHfsClose();
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// void *memchr(const void *s, int c, size_t n);
// char *strcpy(char *dest, const char *src);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// int atoi(const char *nptr);
// char *strchr(const char *s, int c);
// char *strerror(int errnum);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// time_t mktime(struct tm *tp);
__int64 __fastcall DHGetStateInfo(void *a1);
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
// time_t time(time_t *timer);
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
// __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_4DED; // weak
_UNKNOWN unk_5808; // weak
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
_UNKNOWN unk_732D; // weak
_UNKNOWN unk_732E; // weak
_UNKNOWN unk_7330; // weak
_UNKNOWN unk_7334; // weak
__int128 xmmword_733C = 0LL; // weak
__int128 xmmword_7380 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
__int128 xmmword_7390 = 0x2065756C61562065646F436874754165LL; // weak
__int128 xmmword_73F0 = 0xFFFFFFF8FFFFFFF0FFFFFFE8LL; // weak
char a0123456789abcd[77] = "0123456789abcdefl Base Key Gener10574021eneratioue Generen GenerGeneratirati"; // weak
_UNKNOWN unk_7470; // weak
_DWORD dword_7480[3] = { 1, 2, 0 }; // weak
_UNKNOWN unk_748C; // weak
unsigned __int8 byte_7490[1024] =
{
  99u,
  198u,
  165u,
  99u,
  124u,
  248u,
  132u,
  124u,
  119u,
  238u,
  153u,
  119u,
  123u,
  246u,
  141u,
  123u,
  242u,
  255u,
  13u,
  242u,
  107u,
  214u,
  189u,
  107u,
  111u,
  222u,
  177u,
  111u,
  197u,
  145u,
  84u,
  197u,
  48u,
  96u,
  80u,
  48u,
  1u,
  2u,
  3u,
  1u,
  103u,
  206u,
  169u,
  103u,
  43u,
  86u,
  125u,
  43u,
  254u,
  231u,
  25u,
  254u,
  215u,
  181u,
  98u,
  215u,
  171u,
  77u,
  230u,
  171u,
  118u,
  236u,
  154u,
  118u,
  202u,
  143u,
  69u,
  202u,
  130u,
  31u,
  157u,
  130u,
  201u,
  137u,
  64u,
  201u,
  125u,
  250u,
  135u,
  125u,
  250u,
  239u,
  21u,
  250u,
  89u,
  178u,
  235u,
  89u,
  71u,
  142u,
  201u,
  71u,
  240u,
  251u,
  11u,
  240u,
  173u,
  65u,
  236u,
  173u,
  212u,
  179u,
  103u,
  212u,
  162u,
  95u,
  253u,
  162u,
  175u,
  69u,
  234u,
  175u,
  156u,
  35u,
  191u,
  156u,
  164u,
  83u,
  247u,
  164u,
  114u,
  228u,
  150u,
  114u,
  192u,
  155u,
  91u,
  192u,
  183u,
  117u,
  194u,
  183u,
  253u,
  225u,
  28u,
  253u,
  147u,
  61u,
  174u,
  147u,
  38u,
  76u,
  106u,
  38u,
  54u,
  108u,
  90u,
  54u,
  63u,
  126u,
  65u,
  63u,
  247u,
  245u,
  2u,
  247u,
  204u,
  131u,
  79u,
  204u,
  52u,
  104u,
  92u,
  52u,
  165u,
  81u,
  244u,
  165u,
  229u,
  209u,
  52u,
  229u,
  241u,
  249u,
  8u,
  241u,
  113u,
  226u,
  147u,
  113u,
  216u,
  171u,
  115u,
  216u,
  49u,
  98u,
  83u,
  49u,
  21u,
  42u,
  63u,
  21u,
  4u,
  8u,
  12u,
  4u,
  199u,
  149u,
  82u,
  199u,
  35u,
  70u,
  101u,
  35u,
  195u,
  157u,
  94u,
  195u,
  24u,
  48u,
  40u,
  24u,
  150u,
  55u,
  161u,
  150u,
  5u,
  10u,
  15u,
  5u,
  154u,
  47u,
  181u,
  154u,
  7u,
  14u,
  9u,
  7u,
  18u,
  36u,
  54u,
  18u,
  128u,
  27u,
  155u,
  128u,
  226u,
  223u,
  61u,
  226u,
  235u,
  205u,
  38u,
  235u,
  39u,
  78u,
  105u,
  39u,
  178u,
  127u,
  205u,
  178u,
  117u,
  234u,
  159u,
  117u,
  9u,
  18u,
  27u,
  9u,
  131u,
  29u,
  158u,
  131u,
  44u,
  88u,
  116u,
  44u,
  26u,
  52u,
  46u,
  26u,
  27u,
  54u,
  45u,
  27u,
  110u,
  220u,
  178u,
  110u,
  90u,
  180u,
  238u,
  90u,
  160u,
  91u,
  251u,
  160u,
  82u,
  164u,
  246u,
  82u,
  59u,
  118u,
  77u,
  59u,
  214u,
  183u,
  97u,
  214u,
  179u,
  125u,
  206u,
  179u,
  41u,
  82u,
  123u,
  41u,
  227u,
  221u,
  62u,
  227u,
  47u,
  94u,
  113u,
  47u,
  132u,
  19u,
  151u,
  132u,
  83u,
  166u,
  245u,
  83u,
  209u,
  185u,
  104u,
  209u,
  0u,
  0u,
  0u,
  0u,
  237u,
  193u,
  44u,
  237u,
  32u,
  64u,
  96u,
  32u,
  252u,
  227u,
  31u,
  252u,
  177u,
  121u,
  200u,
  177u,
  91u,
  182u,
  237u,
  91u,
  106u,
  212u,
  190u,
  106u,
  203u,
  141u,
  70u,
  203u,
  190u,
  103u,
  217u,
  190u,
  57u,
  114u,
  75u,
  57u,
  74u,
  148u,
  222u,
  74u,
  76u,
  152u,
  212u,
  76u,
  88u,
  176u,
  232u,
  88u,
  207u,
  133u,
  74u,
  207u,
  208u,
  187u,
  107u,
  208u,
  239u,
  197u,
  42u,
  239u,
  170u,
  79u,
  229u,
  170u,
  251u,
  237u,
  22u,
  251u,
  67u,
  134u,
  197u,
  67u,
  77u,
  154u,
  215u,
  77u,
  51u,
  102u,
  85u,
  51u,
  133u,
  17u,
  148u,
  133u,
  69u,
  138u,
  207u,
  69u,
  249u,
  233u,
  16u,
  249u,
  2u,
  4u,
  6u,
  2u,
  127u,
  254u,
  129u,
  127u,
  80u,
  160u,
  240u,
  80u,
  60u,
  120u,
  68u,
  60u,
  159u,
  37u,
  186u,
  159u,
  168u,
  75u,
  227u,
  168u,
  81u,
  162u,
  243u,
  81u,
  163u,
  93u,
  254u,
  163u,
  64u,
  128u,
  192u,
  64u,
  143u,
  5u,
  138u,
  143u,
  146u,
  63u,
  173u,
  146u,
  157u,
  33u,
  188u,
  157u,
  56u,
  112u,
  72u,
  56u,
  245u,
  241u,
  4u,
  245u,
  188u,
  99u,
  223u,
  188u,
  182u,
  119u,
  193u,
  182u,
  218u,
  175u,
  117u,
  218u,
  33u,
  66u,
  99u,
  33u,
  16u,
  32u,
  48u,
  16u,
  255u,
  229u,
  26u,
  255u,
  243u,
  253u,
  14u,
  243u,
  210u,
  191u,
  109u,
  210u,
  205u,
  129u,
  76u,
  205u,
  12u,
  24u,
  20u,
  12u,
  19u,
  38u,
  53u,
  19u,
  236u,
  195u,
  47u,
  236u,
  95u,
  190u,
  225u,
  95u,
  151u,
  53u,
  162u,
  151u,
  68u,
  136u,
  204u,
  68u,
  23u,
  46u,
  57u,
  23u,
  196u,
  147u,
  87u,
  196u,
  167u,
  85u,
  242u,
  167u,
  126u,
  252u,
  130u,
  126u,
  61u,
  122u,
  71u,
  61u,
  100u,
  200u,
  172u,
  100u,
  93u,
  186u,
  231u,
  93u,
  25u,
  50u,
  43u,
  25u,
  115u,
  230u,
  149u,
  115u,
  96u,
  192u,
  160u,
  96u,
  129u,
  25u,
  152u,
  129u,
  79u,
  158u,
  209u,
  79u,
  220u,
  163u,
  127u,
  220u,
  34u,
  68u,
  102u,
  34u,
  42u,
  84u,
  126u,
  42u,
  144u,
  59u,
  171u,
  144u,
  136u,
  11u,
  131u,
  136u,
  70u,
  140u,
  202u,
  70u,
  238u,
  199u,
  41u,
  238u,
  184u,
  107u,
  211u,
  184u,
  20u,
  40u,
  60u,
  20u,
  222u,
  167u,
  121u,
  222u,
  94u,
  188u,
  226u,
  94u,
  11u,
  22u,
  29u,
  11u,
  219u,
  173u,
  118u,
  219u,
  224u,
  219u,
  59u,
  224u,
  50u,
  100u,
  86u,
  50u,
  58u,
  116u,
  78u,
  58u,
  10u,
  20u,
  30u,
  10u,
  73u,
  146u,
  219u,
  73u,
  6u,
  12u,
  10u,
  6u,
  36u,
  72u,
  108u,
  36u,
  92u,
  184u,
  228u,
  92u,
  194u,
  159u,
  93u,
  194u,
  211u,
  189u,
  110u,
  211u,
  172u,
  67u,
  239u,
  172u,
  98u,
  196u,
  166u,
  98u,
  145u,
  57u,
  168u,
  145u,
  149u,
  49u,
  164u,
  149u,
  228u,
  211u,
  55u,
  228u,
  121u,
  242u,
  139u,
  121u,
  231u,
  213u,
  50u,
  231u,
  200u,
  139u,
  67u,
  200u,
  55u,
  110u,
  89u,
  55u,
  109u,
  218u,
  183u,
  109u,
  141u,
  1u,
  140u,
  141u,
  213u,
  177u,
  100u,
  213u,
  78u,
  156u,
  210u,
  78u,
  169u,
  73u,
  224u,
  169u,
  108u,
  216u,
  180u,
  108u,
  86u,
  172u,
  250u,
  86u,
  244u,
  243u,
  7u,
  244u,
  234u,
  207u,
  37u,
  234u,
  101u,
  202u,
  175u,
  101u,
  122u,
  244u,
  142u,
  122u,
  174u,
  71u,
  233u,
  174u,
  8u,
  16u,
  24u,
  8u,
  186u,
  111u,
  213u,
  186u,
  120u,
  240u,
  136u,
  120u,
  37u,
  74u,
  111u,
  37u,
  46u,
  92u,
  114u,
  46u,
  28u,
  56u,
  36u,
  28u,
  166u,
  87u,
  241u,
  166u,
  180u,
  115u,
  199u,
  180u,
  198u,
  151u,
  81u,
  198u,
  232u,
  203u,
  35u,
  232u,
  221u,
  161u,
  124u,
  221u,
  116u,
  232u,
  156u,
  116u,
  31u,
  62u,
  33u,
  31u,
  75u,
  150u,
  221u,
  75u,
  189u,
  97u,
  220u,
  189u,
  139u,
  13u,
  134u,
  139u,
  138u,
  15u,
  133u,
  138u,
  112u,
  224u,
  144u,
  112u,
  62u,
  124u,
  66u,
  62u,
  181u,
  113u,
  196u,
  181u,
  102u,
  204u,
  170u,
  102u,
  72u,
  144u,
  216u,
  72u,
  3u,
  6u,
  5u,
  3u,
  246u,
  247u,
  1u,
  246u,
  14u,
  28u,
  18u,
  14u,
  97u,
  194u,
  163u,
  97u,
  53u,
  106u,
  95u,
  53u,
  87u,
  174u,
  249u,
  87u,
  185u,
  105u,
  208u,
  185u,
  134u,
  23u,
  145u,
  134u,
  193u,
  153u,
  88u,
  193u,
  29u,
  58u,
  39u,
  29u,
  158u,
  39u,
  185u,
  158u,
  225u,
  217u,
  56u,
  225u,
  248u,
  235u,
  19u,
  248u,
  152u,
  43u,
  179u,
  152u,
  17u,
  34u,
  51u,
  17u,
  105u,
  210u,
  187u,
  105u,
  217u,
  169u,
  112u,
  217u,
  142u,
  7u,
  137u,
  142u,
  148u,
  51u,
  167u,
  148u,
  155u,
  45u,
  182u,
  155u,
  30u,
  60u,
  34u,
  30u,
  135u,
  21u,
  146u,
  135u,
  233u,
  201u,
  32u,
  233u,
  206u,
  135u,
  73u,
  206u,
  85u,
  170u,
  255u,
  85u,
  40u,
  80u,
  120u,
  40u,
  223u,
  165u,
  122u,
  223u,
  140u,
  3u,
  143u,
  140u,
  161u,
  89u,
  248u,
  161u,
  137u,
  9u,
  128u,
  137u,
  13u,
  26u,
  23u,
  13u,
  191u,
  101u,
  218u,
  191u,
  230u,
  215u,
  49u,
  230u,
  66u,
  132u,
  198u,
  66u,
  104u,
  208u,
  184u,
  104u,
  65u,
  130u,
  195u,
  65u,
  153u,
  41u,
  176u,
  153u,
  45u,
  90u,
  119u,
  45u,
  15u,
  30u,
  17u,
  15u,
  176u,
  123u,
  203u,
  176u,
  84u,
  168u,
  252u,
  84u,
  187u,
  109u,
  214u,
  187u,
  22u,
  44u,
  58u,
  22u
}; // weak
unsigned __int8 byte_7890[1024] =
{
  198u,
  165u,
  99u,
  99u,
  248u,
  132u,
  124u,
  124u,
  238u,
  153u,
  119u,
  119u,
  246u,
  141u,
  123u,
  123u,
  255u,
  13u,
  242u,
  242u,
  214u,
  189u,
  107u,
  107u,
  222u,
  177u,
  111u,
  111u,
  145u,
  84u,
  197u,
  197u,
  96u,
  80u,
  48u,
  48u,
  2u,
  3u,
  1u,
  1u,
  206u,
  169u,
  103u,
  103u,
  86u,
  125u,
  43u,
  43u,
  231u,
  25u,
  254u,
  254u,
  181u,
  98u,
  215u,
  215u,
  77u,
  230u,
  171u,
  171u,
  236u,
  154u,
  118u,
  118u,
  143u,
  69u,
  202u,
  202u,
  31u,
  157u,
  130u,
  130u,
  137u,
  64u,
  201u,
  201u,
  250u,
  135u,
  125u,
  125u,
  239u,
  21u,
  250u,
  250u,
  178u,
  235u,
  89u,
  89u,
  142u,
  201u,
  71u,
  71u,
  251u,
  11u,
  240u,
  240u,
  65u,
  236u,
  173u,
  173u,
  179u,
  103u,
  212u,
  212u,
  95u,
  253u,
  162u,
  162u,
  69u,
  234u,
  175u,
  175u,
  35u,
  191u,
  156u,
  156u,
  83u,
  247u,
  164u,
  164u,
  228u,
  150u,
  114u,
  114u,
  155u,
  91u,
  192u,
  192u,
  117u,
  194u,
  183u,
  183u,
  225u,
  28u,
  253u,
  253u,
  61u,
  174u,
  147u,
  147u,
  76u,
  106u,
  38u,
  38u,
  108u,
  90u,
  54u,
  54u,
  126u,
  65u,
  63u,
  63u,
  245u,
  2u,
  247u,
  247u,
  131u,
  79u,
  204u,
  204u,
  104u,
  92u,
  52u,
  52u,
  81u,
  244u,
  165u,
  165u,
  209u,
  52u,
  229u,
  229u,
  249u,
  8u,
  241u,
  241u,
  226u,
  147u,
  113u,
  113u,
  171u,
  115u,
  216u,
  216u,
  98u,
  83u,
  49u,
  49u,
  42u,
  63u,
  21u,
  21u,
  8u,
  12u,
  4u,
  4u,
  149u,
  82u,
  199u,
  199u,
  70u,
  101u,
  35u,
  35u,
  157u,
  94u,
  195u,
  195u,
  48u,
  40u,
  24u,
  24u,
  55u,
  161u,
  150u,
  150u,
  10u,
  15u,
  5u,
  5u,
  47u,
  181u,
  154u,
  154u,
  14u,
  9u,
  7u,
  7u,
  36u,
  54u,
  18u,
  18u,
  27u,
  155u,
  128u,
  128u,
  223u,
  61u,
  226u,
  226u,
  205u,
  38u,
  235u,
  235u,
  78u,
  105u,
  39u,
  39u,
  127u,
  205u,
  178u,
  178u,
  234u,
  159u,
  117u,
  117u,
  18u,
  27u,
  9u,
  9u,
  29u,
  158u,
  131u,
  131u,
  88u,
  116u,
  44u,
  44u,
  52u,
  46u,
  26u,
  26u,
  54u,
  45u,
  27u,
  27u,
  220u,
  178u,
  110u,
  110u,
  180u,
  238u,
  90u,
  90u,
  91u,
  251u,
  160u,
  160u,
  164u,
  246u,
  82u,
  82u,
  118u,
  77u,
  59u,
  59u,
  183u,
  97u,
  214u,
  214u,
  125u,
  206u,
  179u,
  179u,
  82u,
  123u,
  41u,
  41u,
  221u,
  62u,
  227u,
  227u,
  94u,
  113u,
  47u,
  47u,
  19u,
  151u,
  132u,
  132u,
  166u,
  245u,
  83u,
  83u,
  185u,
  104u,
  209u,
  209u,
  0u,
  0u,
  0u,
  0u,
  193u,
  44u,
  237u,
  237u,
  64u,
  96u,
  32u,
  32u,
  227u,
  31u,
  252u,
  252u,
  121u,
  200u,
  177u,
  177u,
  182u,
  237u,
  91u,
  91u,
  212u,
  190u,
  106u,
  106u,
  141u,
  70u,
  203u,
  203u,
  103u,
  217u,
  190u,
  190u,
  114u,
  75u,
  57u,
  57u,
  148u,
  222u,
  74u,
  74u,
  152u,
  212u,
  76u,
  76u,
  176u,
  232u,
  88u,
  88u,
  133u,
  74u,
  207u,
  207u,
  187u,
  107u,
  208u,
  208u,
  197u,
  42u,
  239u,
  239u,
  79u,
  229u,
  170u,
  170u,
  237u,
  22u,
  251u,
  251u,
  134u,
  197u,
  67u,
  67u,
  154u,
  215u,
  77u,
  77u,
  102u,
  85u,
  51u,
  51u,
  17u,
  148u,
  133u,
  133u,
  138u,
  207u,
  69u,
  69u,
  233u,
  16u,
  249u,
  249u,
  4u,
  6u,
  2u,
  2u,
  254u,
  129u,
  127u,
  127u,
  160u,
  240u,
  80u,
  80u,
  120u,
  68u,
  60u,
  60u,
  37u,
  186u,
  159u,
  159u,
  75u,
  227u,
  168u,
  168u,
  162u,
  243u,
  81u,
  81u,
  93u,
  254u,
  163u,
  163u,
  128u,
  192u,
  64u,
  64u,
  5u,
  138u,
  143u,
  143u,
  63u,
  173u,
  146u,
  146u,
  33u,
  188u,
  157u,
  157u,
  112u,
  72u,
  56u,
  56u,
  241u,
  4u,
  245u,
  245u,
  99u,
  223u,
  188u,
  188u,
  119u,
  193u,
  182u,
  182u,
  175u,
  117u,
  218u,
  218u,
  66u,
  99u,
  33u,
  33u,
  32u,
  48u,
  16u,
  16u,
  229u,
  26u,
  255u,
  255u,
  253u,
  14u,
  243u,
  243u,
  191u,
  109u,
  210u,
  210u,
  129u,
  76u,
  205u,
  205u,
  24u,
  20u,
  12u,
  12u,
  38u,
  53u,
  19u,
  19u,
  195u,
  47u,
  236u,
  236u,
  190u,
  225u,
  95u,
  95u,
  53u,
  162u,
  151u,
  151u,
  136u,
  204u,
  68u,
  68u,
  46u,
  57u,
  23u,
  23u,
  147u,
  87u,
  196u,
  196u,
  85u,
  242u,
  167u,
  167u,
  252u,
  130u,
  126u,
  126u,
  122u,
  71u,
  61u,
  61u,
  200u,
  172u,
  100u,
  100u,
  186u,
  231u,
  93u,
  93u,
  50u,
  43u,
  25u,
  25u,
  230u,
  149u,
  115u,
  115u,
  192u,
  160u,
  96u,
  96u,
  25u,
  152u,
  129u,
  129u,
  158u,
  209u,
  79u,
  79u,
  163u,
  127u,
  220u,
  220u,
  68u,
  102u,
  34u,
  34u,
  84u,
  126u,
  42u,
  42u,
  59u,
  171u,
  144u,
  144u,
  11u,
  131u,
  136u,
  136u,
  140u,
  202u,
  70u,
  70u,
  199u,
  41u,
  238u,
  238u,
  107u,
  211u,
  184u,
  184u,
  40u,
  60u,
  20u,
  20u,
  167u,
  121u,
  222u,
  222u,
  188u,
  226u,
  94u,
  94u,
  22u,
  29u,
  11u,
  11u,
  173u,
  118u,
  219u,
  219u,
  219u,
  59u,
  224u,
  224u,
  100u,
  86u,
  50u,
  50u,
  116u,
  78u,
  58u,
  58u,
  20u,
  30u,
  10u,
  10u,
  146u,
  219u,
  73u,
  73u,
  12u,
  10u,
  6u,
  6u,
  72u,
  108u,
  36u,
  36u,
  184u,
  228u,
  92u,
  92u,
  159u,
  93u,
  194u,
  194u,
  189u,
  110u,
  211u,
  211u,
  67u,
  239u,
  172u,
  172u,
  196u,
  166u,
  98u,
  98u,
  57u,
  168u,
  145u,
  145u,
  49u,
  164u,
  149u,
  149u,
  211u,
  55u,
  228u,
  228u,
  242u,
  139u,
  121u,
  121u,
  213u,
  50u,
  231u,
  231u,
  139u,
  67u,
  200u,
  200u,
  110u,
  89u,
  55u,
  55u,
  218u,
  183u,
  109u,
  109u,
  1u,
  140u,
  141u,
  141u,
  177u,
  100u,
  213u,
  213u,
  156u,
  210u,
  78u,
  78u,
  73u,
  224u,
  169u,
  169u,
  216u,
  180u,
  108u,
  108u,
  172u,
  250u,
  86u,
  86u,
  243u,
  7u,
  244u,
  244u,
  207u,
  37u,
  234u,
  234u,
  202u,
  175u,
  101u,
  101u,
  244u,
  142u,
  122u,
  122u,
  71u,
  233u,
  174u,
  174u,
  16u,
  24u,
  8u,
  8u,
  111u,
  213u,
  186u,
  186u,
  240u,
  136u,
  120u,
  120u,
  74u,
  111u,
  37u,
  37u,
  92u,
  114u,
  46u,
  46u,
  56u,
  36u,
  28u,
  28u,
  87u,
  241u,
  166u,
  166u,
  115u,
  199u,
  180u,
  180u,
  151u,
  81u,
  198u,
  198u,
  203u,
  35u,
  232u,
  232u,
  161u,
  124u,
  221u,
  221u,
  232u,
  156u,
  116u,
  116u,
  62u,
  33u,
  31u,
  31u,
  150u,
  221u,
  75u,
  75u,
  97u,
  220u,
  189u,
  189u,
  13u,
  134u,
  139u,
  139u,
  15u,
  133u,
  138u,
  138u,
  224u,
  144u,
  112u,
  112u,
  124u,
  66u,
  62u,
  62u,
  113u,
  196u,
  181u,
  181u,
  204u,
  170u,
  102u,
  102u,
  144u,
  216u,
  72u,
  72u,
  6u,
  5u,
  3u,
  3u,
  247u,
  1u,
  246u,
  246u,
  28u,
  18u,
  14u,
  14u,
  194u,
  163u,
  97u,
  97u,
  106u,
  95u,
  53u,
  53u,
  174u,
  249u,
  87u,
  87u,
  105u,
  208u,
  185u,
  185u,
  23u,
  145u,
  134u,
  134u,
  153u,
  88u,
  193u,
  193u,
  58u,
  39u,
  29u,
  29u,
  39u,
  185u,
  158u,
  158u,
  217u,
  56u,
  225u,
  225u,
  235u,
  19u,
  248u,
  248u,
  43u,
  179u,
  152u,
  152u,
  34u,
  51u,
  17u,
  17u,
  210u,
  187u,
  105u,
  105u,
  169u,
  112u,
  217u,
  217u,
  7u,
  137u,
  142u,
  142u,
  51u,
  167u,
  148u,
  148u,
  45u,
  182u,
  155u,
  155u,
  60u,
  34u,
  30u,
  30u,
  21u,
  146u,
  135u,
  135u,
  201u,
  32u,
  233u,
  233u,
  135u,
  73u,
  206u,
  206u,
  170u,
  255u,
  85u,
  85u,
  80u,
  120u,
  40u,
  40u,
  165u,
  122u,
  223u,
  223u,
  3u,
  143u,
  140u,
  140u,
  89u,
  248u,
  161u,
  161u,
  9u,
  128u,
  137u,
  137u,
  26u,
  23u,
  13u,
  13u,
  101u,
  218u,
  191u,
  191u,
  215u,
  49u,
  230u,
  230u,
  132u,
  198u,
  66u,
  66u,
  208u,
  184u,
  104u,
  104u,
  130u,
  195u,
  65u,
  65u,
  41u,
  176u,
  153u,
  153u,
  90u,
  119u,
  45u,
  45u,
  30u,
  17u,
  15u,
  15u,
  123u,
  203u,
  176u,
  176u,
  168u,
  252u,
  84u,
  84u,
  109u,
  214u,
  187u,
  187u,
  44u,
  58u,
  22u,
  22u
}; // weak
unsigned __int8 byte_7C90[1024] =
{
  165u,
  99u,
  99u,
  198u,
  132u,
  124u,
  124u,
  248u,
  153u,
  119u,
  119u,
  238u,
  141u,
  123u,
  123u,
  246u,
  13u,
  242u,
  242u,
  255u,
  189u,
  107u,
  107u,
  214u,
  177u,
  111u,
  111u,
  222u,
  84u,
  197u,
  197u,
  145u,
  80u,
  48u,
  48u,
  96u,
  3u,
  1u,
  1u,
  2u,
  169u,
  103u,
  103u,
  206u,
  125u,
  43u,
  43u,
  86u,
  25u,
  254u,
  254u,
  231u,
  98u,
  215u,
  215u,
  181u,
  230u,
  171u,
  171u,
  77u,
  154u,
  118u,
  118u,
  236u,
  69u,
  202u,
  202u,
  143u,
  157u,
  130u,
  130u,
  31u,
  64u,
  201u,
  201u,
  137u,
  135u,
  125u,
  125u,
  250u,
  21u,
  250u,
  250u,
  239u,
  235u,
  89u,
  89u,
  178u,
  201u,
  71u,
  71u,
  142u,
  11u,
  240u,
  240u,
  251u,
  236u,
  173u,
  173u,
  65u,
  103u,
  212u,
  212u,
  179u,
  253u,
  162u,
  162u,
  95u,
  234u,
  175u,
  175u,
  69u,
  191u,
  156u,
  156u,
  35u,
  247u,
  164u,
  164u,
  83u,
  150u,
  114u,
  114u,
  228u,
  91u,
  192u,
  192u,
  155u,
  194u,
  183u,
  183u,
  117u,
  28u,
  253u,
  253u,
  225u,
  174u,
  147u,
  147u,
  61u,
  106u,
  38u,
  38u,
  76u,
  90u,
  54u,
  54u,
  108u,
  65u,
  63u,
  63u,
  126u,
  2u,
  247u,
  247u,
  245u,
  79u,
  204u,
  204u,
  131u,
  92u,
  52u,
  52u,
  104u,
  244u,
  165u,
  165u,
  81u,
  52u,
  229u,
  229u,
  209u,
  8u,
  241u,
  241u,
  249u,
  147u,
  113u,
  113u,
  226u,
  115u,
  216u,
  216u,
  171u,
  83u,
  49u,
  49u,
  98u,
  63u,
  21u,
  21u,
  42u,
  12u,
  4u,
  4u,
  8u,
  82u,
  199u,
  199u,
  149u,
  101u,
  35u,
  35u,
  70u,
  94u,
  195u,
  195u,
  157u,
  40u,
  24u,
  24u,
  48u,
  161u,
  150u,
  150u,
  55u,
  15u,
  5u,
  5u,
  10u,
  181u,
  154u,
  154u,
  47u,
  9u,
  7u,
  7u,
  14u,
  54u,
  18u,
  18u,
  36u,
  155u,
  128u,
  128u,
  27u,
  61u,
  226u,
  226u,
  223u,
  38u,
  235u,
  235u,
  205u,
  105u,
  39u,
  39u,
  78u,
  205u,
  178u,
  178u,
  127u,
  159u,
  117u,
  117u,
  234u,
  27u,
  9u,
  9u,
  18u,
  158u,
  131u,
  131u,
  29u,
  116u,
  44u,
  44u,
  88u,
  46u,
  26u,
  26u,
  52u,
  45u,
  27u,
  27u,
  54u,
  178u,
  110u,
  110u,
  220u,
  238u,
  90u,
  90u,
  180u,
  251u,
  160u,
  160u,
  91u,
  246u,
  82u,
  82u,
  164u,
  77u,
  59u,
  59u,
  118u,
  97u,
  214u,
  214u,
  183u,
  206u,
  179u,
  179u,
  125u,
  123u,
  41u,
  41u,
  82u,
  62u,
  227u,
  227u,
  221u,
  113u,
  47u,
  47u,
  94u,
  151u,
  132u,
  132u,
  19u,
  245u,
  83u,
  83u,
  166u,
  104u,
  209u,
  209u,
  185u,
  0u,
  0u,
  0u,
  0u,
  44u,
  237u,
  237u,
  193u,
  96u,
  32u,
  32u,
  64u,
  31u,
  252u,
  252u,
  227u,
  200u,
  177u,
  177u,
  121u,
  237u,
  91u,
  91u,
  182u,
  190u,
  106u,
  106u,
  212u,
  70u,
  203u,
  203u,
  141u,
  217u,
  190u,
  190u,
  103u,
  75u,
  57u,
  57u,
  114u,
  222u,
  74u,
  74u,
  148u,
  212u,
  76u,
  76u,
  152u,
  232u,
  88u,
  88u,
  176u,
  74u,
  207u,
  207u,
  133u,
  107u,
  208u,
  208u,
  187u,
  42u,
  239u,
  239u,
  197u,
  229u,
  170u,
  170u,
  79u,
  22u,
  251u,
  251u,
  237u,
  197u,
  67u,
  67u,
  134u,
  215u,
  77u,
  77u,
  154u,
  85u,
  51u,
  51u,
  102u,
  148u,
  133u,
  133u,
  17u,
  207u,
  69u,
  69u,
  138u,
  16u,
  249u,
  249u,
  233u,
  6u,
  2u,
  2u,
  4u,
  129u,
  127u,
  127u,
  254u,
  240u,
  80u,
  80u,
  160u,
  68u,
  60u,
  60u,
  120u,
  186u,
  159u,
  159u,
  37u,
  227u,
  168u,
  168u,
  75u,
  243u,
  81u,
  81u,
  162u,
  254u,
  163u,
  163u,
  93u,
  192u,
  64u,
  64u,
  128u,
  138u,
  143u,
  143u,
  5u,
  173u,
  146u,
  146u,
  63u,
  188u,
  157u,
  157u,
  33u,
  72u,
  56u,
  56u,
  112u,
  4u,
  245u,
  245u,
  241u,
  223u,
  188u,
  188u,
  99u,
  193u,
  182u,
  182u,
  119u,
  117u,
  218u,
  218u,
  175u,
  99u,
  33u,
  33u,
  66u,
  48u,
  16u,
  16u,
  32u,
  26u,
  255u,
  255u,
  229u,
  14u,
  243u,
  243u,
  253u,
  109u,
  210u,
  210u,
  191u,
  76u,
  205u,
  205u,
  129u,
  20u,
  12u,
  12u,
  24u,
  53u,
  19u,
  19u,
  38u,
  47u,
  236u,
  236u,
  195u,
  225u,
  95u,
  95u,
  190u,
  162u,
  151u,
  151u,
  53u,
  204u,
  68u,
  68u,
  136u,
  57u,
  23u,
  23u,
  46u,
  87u,
  196u,
  196u,
  147u,
  242u,
  167u,
  167u,
  85u,
  130u,
  126u,
  126u,
  252u,
  71u,
  61u,
  61u,
  122u,
  172u,
  100u,
  100u,
  200u,
  231u,
  93u,
  93u,
  186u,
  43u,
  25u,
  25u,
  50u,
  149u,
  115u,
  115u,
  230u,
  160u,
  96u,
  96u,
  192u,
  152u,
  129u,
  129u,
  25u,
  209u,
  79u,
  79u,
  158u,
  127u,
  220u,
  220u,
  163u,
  102u,
  34u,
  34u,
  68u,
  126u,
  42u,
  42u,
  84u,
  171u,
  144u,
  144u,
  59u,
  131u,
  136u,
  136u,
  11u,
  202u,
  70u,
  70u,
  140u,
  41u,
  238u,
  238u,
  199u,
  211u,
  184u,
  184u,
  107u,
  60u,
  20u,
  20u,
  40u,
  121u,
  222u,
  222u,
  167u,
  226u,
  94u,
  94u,
  188u,
  29u,
  11u,
  11u,
  22u,
  118u,
  219u,
  219u,
  173u,
  59u,
  224u,
  224u,
  219u,
  86u,
  50u,
  50u,
  100u,
  78u,
  58u,
  58u,
  116u,
  30u,
  10u,
  10u,
  20u,
  219u,
  73u,
  73u,
  146u,
  10u,
  6u,
  6u,
  12u,
  108u,
  36u,
  36u,
  72u,
  228u,
  92u,
  92u,
  184u,
  93u,
  194u,
  194u,
  159u,
  110u,
  211u,
  211u,
  189u,
  239u,
  172u,
  172u,
  67u,
  166u,
  98u,
  98u,
  196u,
  168u,
  145u,
  145u,
  57u,
  164u,
  149u,
  149u,
  49u,
  55u,
  228u,
  228u,
  211u,
  139u,
  121u,
  121u,
  242u,
  50u,
  231u,
  231u,
  213u,
  67u,
  200u,
  200u,
  139u,
  89u,
  55u,
  55u,
  110u,
  183u,
  109u,
  109u,
  218u,
  140u,
  141u,
  141u,
  1u,
  100u,
  213u,
  213u,
  177u,
  210u,
  78u,
  78u,
  156u,
  224u,
  169u,
  169u,
  73u,
  180u,
  108u,
  108u,
  216u,
  250u,
  86u,
  86u,
  172u,
  7u,
  244u,
  244u,
  243u,
  37u,
  234u,
  234u,
  207u,
  175u,
  101u,
  101u,
  202u,
  142u,
  122u,
  122u,
  244u,
  233u,
  174u,
  174u,
  71u,
  24u,
  8u,
  8u,
  16u,
  213u,
  186u,
  186u,
  111u,
  136u,
  120u,
  120u,
  240u,
  111u,
  37u,
  37u,
  74u,
  114u,
  46u,
  46u,
  92u,
  36u,
  28u,
  28u,
  56u,
  241u,
  166u,
  166u,
  87u,
  199u,
  180u,
  180u,
  115u,
  81u,
  198u,
  198u,
  151u,
  35u,
  232u,
  232u,
  203u,
  124u,
  221u,
  221u,
  161u,
  156u,
  116u,
  116u,
  232u,
  33u,
  31u,
  31u,
  62u,
  221u,
  75u,
  75u,
  150u,
  220u,
  189u,
  189u,
  97u,
  134u,
  139u,
  139u,
  13u,
  133u,
  138u,
  138u,
  15u,
  144u,
  112u,
  112u,
  224u,
  66u,
  62u,
  62u,
  124u,
  196u,
  181u,
  181u,
  113u,
  170u,
  102u,
  102u,
  204u,
  216u,
  72u,
  72u,
  144u,
  5u,
  3u,
  3u,
  6u,
  1u,
  246u,
  246u,
  247u,
  18u,
  14u,
  14u,
  28u,
  163u,
  97u,
  97u,
  194u,
  95u,
  53u,
  53u,
  106u,
  249u,
  87u,
  87u,
  174u,
  208u,
  185u,
  185u,
  105u,
  145u,
  134u,
  134u,
  23u,
  88u,
  193u,
  193u,
  153u,
  39u,
  29u,
  29u,
  58u,
  185u,
  158u,
  158u,
  39u,
  56u,
  225u,
  225u,
  217u,
  19u,
  248u,
  248u,
  235u,
  179u,
  152u,
  152u,
  43u,
  51u,
  17u,
  17u,
  34u,
  187u,
  105u,
  105u,
  210u,
  112u,
  217u,
  217u,
  169u,
  137u,
  142u,
  142u,
  7u,
  167u,
  148u,
  148u,
  51u,
  182u,
  155u,
  155u,
  45u,
  34u,
  30u,
  30u,
  60u,
  146u,
  135u,
  135u,
  21u,
  32u,
  233u,
  233u,
  201u,
  73u,
  206u,
  206u,
  135u,
  255u,
  85u,
  85u,
  170u,
  120u,
  40u,
  40u,
  80u,
  122u,
  223u,
  223u,
  165u,
  143u,
  140u,
  140u,
  3u,
  248u,
  161u,
  161u,
  89u,
  128u,
  137u,
  137u,
  9u,
  23u,
  13u,
  13u,
  26u,
  218u,
  191u,
  191u,
  101u,
  49u,
  230u,
  230u,
  215u,
  198u,
  66u,
  66u,
  132u,
  184u,
  104u,
  104u,
  208u,
  195u,
  65u,
  65u,
  130u,
  176u,
  153u,
  153u,
  41u,
  119u,
  45u,
  45u,
  90u,
  17u,
  15u,
  15u,
  30u,
  203u,
  176u,
  176u,
  123u,
  252u,
  84u,
  84u,
  168u,
  214u,
  187u,
  187u,
  109u,
  58u,
  22u,
  22u,
  44u
}; // weak
unsigned __int8 byte_8090[1024] =
{
  99u,
  99u,
  198u,
  165u,
  124u,
  124u,
  248u,
  132u,
  119u,
  119u,
  238u,
  153u,
  123u,
  123u,
  246u,
  141u,
  242u,
  242u,
  255u,
  13u,
  107u,
  107u,
  214u,
  189u,
  111u,
  111u,
  222u,
  177u,
  197u,
  197u,
  145u,
  84u,
  48u,
  48u,
  96u,
  80u,
  1u,
  1u,
  2u,
  3u,
  103u,
  103u,
  206u,
  169u,
  43u,
  43u,
  86u,
  125u,
  254u,
  254u,
  231u,
  25u,
  215u,
  215u,
  181u,
  98u,
  171u,
  171u,
  77u,
  230u,
  118u,
  118u,
  236u,
  154u,
  202u,
  202u,
  143u,
  69u,
  130u,
  130u,
  31u,
  157u,
  201u,
  201u,
  137u,
  64u,
  125u,
  125u,
  250u,
  135u,
  250u,
  250u,
  239u,
  21u,
  89u,
  89u,
  178u,
  235u,
  71u,
  71u,
  142u,
  201u,
  240u,
  240u,
  251u,
  11u,
  173u,
  173u,
  65u,
  236u,
  212u,
  212u,
  179u,
  103u,
  162u,
  162u,
  95u,
  253u,
  175u,
  175u,
  69u,
  234u,
  156u,
  156u,
  35u,
  191u,
  164u,
  164u,
  83u,
  247u,
  114u,
  114u,
  228u,
  150u,
  192u,
  192u,
  155u,
  91u,
  183u,
  183u,
  117u,
  194u,
  253u,
  253u,
  225u,
  28u,
  147u,
  147u,
  61u,
  174u,
  38u,
  38u,
  76u,
  106u,
  54u,
  54u,
  108u,
  90u,
  63u,
  63u,
  126u,
  65u,
  247u,
  247u,
  245u,
  2u,
  204u,
  204u,
  131u,
  79u,
  52u,
  52u,
  104u,
  92u,
  165u,
  165u,
  81u,
  244u,
  229u,
  229u,
  209u,
  52u,
  241u,
  241u,
  249u,
  8u,
  113u,
  113u,
  226u,
  147u,
  216u,
  216u,
  171u,
  115u,
  49u,
  49u,
  98u,
  83u,
  21u,
  21u,
  42u,
  63u,
  4u,
  4u,
  8u,
  12u,
  199u,
  199u,
  149u,
  82u,
  35u,
  35u,
  70u,
  101u,
  195u,
  195u,
  157u,
  94u,
  24u,
  24u,
  48u,
  40u,
  150u,
  150u,
  55u,
  161u,
  5u,
  5u,
  10u,
  15u,
  154u,
  154u,
  47u,
  181u,
  7u,
  7u,
  14u,
  9u,
  18u,
  18u,
  36u,
  54u,
  128u,
  128u,
  27u,
  155u,
  226u,
  226u,
  223u,
  61u,
  235u,
  235u,
  205u,
  38u,
  39u,
  39u,
  78u,
  105u,
  178u,
  178u,
  127u,
  205u,
  117u,
  117u,
  234u,
  159u,
  9u,
  9u,
  18u,
  27u,
  131u,
  131u,
  29u,
  158u,
  44u,
  44u,
  88u,
  116u,
  26u,
  26u,
  52u,
  46u,
  27u,
  27u,
  54u,
  45u,
  110u,
  110u,
  220u,
  178u,
  90u,
  90u,
  180u,
  238u,
  160u,
  160u,
  91u,
  251u,
  82u,
  82u,
  164u,
  246u,
  59u,
  59u,
  118u,
  77u,
  214u,
  214u,
  183u,
  97u,
  179u,
  179u,
  125u,
  206u,
  41u,
  41u,
  82u,
  123u,
  227u,
  227u,
  221u,
  62u,
  47u,
  47u,
  94u,
  113u,
  132u,
  132u,
  19u,
  151u,
  83u,
  83u,
  166u,
  245u,
  209u,
  209u,
  185u,
  104u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  193u,
  44u,
  32u,
  32u,
  64u,
  96u,
  252u,
  252u,
  227u,
  31u,
  177u,
  177u,
  121u,
  200u,
  91u,
  91u,
  182u,
  237u,
  106u,
  106u,
  212u,
  190u,
  203u,
  203u,
  141u,
  70u,
  190u,
  190u,
  103u,
  217u,
  57u,
  57u,
  114u,
  75u,
  74u,
  74u,
  148u,
  222u,
  76u,
  76u,
  152u,
  212u,
  88u,
  88u,
  176u,
  232u,
  207u,
  207u,
  133u,
  74u,
  208u,
  208u,
  187u,
  107u,
  239u,
  239u,
  197u,
  42u,
  170u,
  170u,
  79u,
  229u,
  251u,
  251u,
  237u,
  22u,
  67u,
  67u,
  134u,
  197u,
  77u,
  77u,
  154u,
  215u,
  51u,
  51u,
  102u,
  85u,
  133u,
  133u,
  17u,
  148u,
  69u,
  69u,
  138u,
  207u,
  249u,
  249u,
  233u,
  16u,
  2u,
  2u,
  4u,
  6u,
  127u,
  127u,
  254u,
  129u,
  80u,
  80u,
  160u,
  240u,
  60u,
  60u,
  120u,
  68u,
  159u,
  159u,
  37u,
  186u,
  168u,
  168u,
  75u,
  227u,
  81u,
  81u,
  162u,
  243u,
  163u,
  163u,
  93u,
  254u,
  64u,
  64u,
  128u,
  192u,
  143u,
  143u,
  5u,
  138u,
  146u,
  146u,
  63u,
  173u,
  157u,
  157u,
  33u,
  188u,
  56u,
  56u,
  112u,
  72u,
  245u,
  245u,
  241u,
  4u,
  188u,
  188u,
  99u,
  223u,
  182u,
  182u,
  119u,
  193u,
  218u,
  218u,
  175u,
  117u,
  33u,
  33u,
  66u,
  99u,
  16u,
  16u,
  32u,
  48u,
  255u,
  255u,
  229u,
  26u,
  243u,
  243u,
  253u,
  14u,
  210u,
  210u,
  191u,
  109u,
  205u,
  205u,
  129u,
  76u,
  12u,
  12u,
  24u,
  20u,
  19u,
  19u,
  38u,
  53u,
  236u,
  236u,
  195u,
  47u,
  95u,
  95u,
  190u,
  225u,
  151u,
  151u,
  53u,
  162u,
  68u,
  68u,
  136u,
  204u,
  23u,
  23u,
  46u,
  57u,
  196u,
  196u,
  147u,
  87u,
  167u,
  167u,
  85u,
  242u,
  126u,
  126u,
  252u,
  130u,
  61u,
  61u,
  122u,
  71u,
  100u,
  100u,
  200u,
  172u,
  93u,
  93u,
  186u,
  231u,
  25u,
  25u,
  50u,
  43u,
  115u,
  115u,
  230u,
  149u,
  96u,
  96u,
  192u,
  160u,
  129u,
  129u,
  25u,
  152u,
  79u,
  79u,
  158u,
  209u,
  220u,
  220u,
  163u,
  127u,
  34u,
  34u,
  68u,
  102u,
  42u,
  42u,
  84u,
  126u,
  144u,
  144u,
  59u,
  171u,
  136u,
  136u,
  11u,
  131u,
  70u,
  70u,
  140u,
  202u,
  238u,
  238u,
  199u,
  41u,
  184u,
  184u,
  107u,
  211u,
  20u,
  20u,
  40u,
  60u,
  222u,
  222u,
  167u,
  121u,
  94u,
  94u,
  188u,
  226u,
  11u,
  11u,
  22u,
  29u,
  219u,
  219u,
  173u,
  118u,
  224u,
  224u,
  219u,
  59u,
  50u,
  50u,
  100u,
  86u,
  58u,
  58u,
  116u,
  78u,
  10u,
  10u,
  20u,
  30u,
  73u,
  73u,
  146u,
  219u,
  6u,
  6u,
  12u,
  10u,
  36u,
  36u,
  72u,
  108u,
  92u,
  92u,
  184u,
  228u,
  194u,
  194u,
  159u,
  93u,
  211u,
  211u,
  189u,
  110u,
  172u,
  172u,
  67u,
  239u,
  98u,
  98u,
  196u,
  166u,
  145u,
  145u,
  57u,
  168u,
  149u,
  149u,
  49u,
  164u,
  228u,
  228u,
  211u,
  55u,
  121u,
  121u,
  242u,
  139u,
  231u,
  231u,
  213u,
  50u,
  200u,
  200u,
  139u,
  67u,
  55u,
  55u,
  110u,
  89u,
  109u,
  109u,
  218u,
  183u,
  141u,
  141u,
  1u,
  140u,
  213u,
  213u,
  177u,
  100u,
  78u,
  78u,
  156u,
  210u,
  169u,
  169u,
  73u,
  224u,
  108u,
  108u,
  216u,
  180u,
  86u,
  86u,
  172u,
  250u,
  244u,
  244u,
  243u,
  7u,
  234u,
  234u,
  207u,
  37u,
  101u,
  101u,
  202u,
  175u,
  122u,
  122u,
  244u,
  142u,
  174u,
  174u,
  71u,
  233u,
  8u,
  8u,
  16u,
  24u,
  186u,
  186u,
  111u,
  213u,
  120u,
  120u,
  240u,
  136u,
  37u,
  37u,
  74u,
  111u,
  46u,
  46u,
  92u,
  114u,
  28u,
  28u,
  56u,
  36u,
  166u,
  166u,
  87u,
  241u,
  180u,
  180u,
  115u,
  199u,
  198u,
  198u,
  151u,
  81u,
  232u,
  232u,
  203u,
  35u,
  221u,
  221u,
  161u,
  124u,
  116u,
  116u,
  232u,
  156u,
  31u,
  31u,
  62u,
  33u,
  75u,
  75u,
  150u,
  221u,
  189u,
  189u,
  97u,
  220u,
  139u,
  139u,
  13u,
  134u,
  138u,
  138u,
  15u,
  133u,
  112u,
  112u,
  224u,
  144u,
  62u,
  62u,
  124u,
  66u,
  181u,
  181u,
  113u,
  196u,
  102u,
  102u,
  204u,
  170u,
  72u,
  72u,
  144u,
  216u,
  3u,
  3u,
  6u,
  5u,
  246u,
  246u,
  247u,
  1u,
  14u,
  14u,
  28u,
  18u,
  97u,
  97u,
  194u,
  163u,
  53u,
  53u,
  106u,
  95u,
  87u,
  87u,
  174u,
  249u,
  185u,
  185u,
  105u,
  208u,
  134u,
  134u,
  23u,
  145u,
  193u,
  193u,
  153u,
  88u,
  29u,
  29u,
  58u,
  39u,
  158u,
  158u,
  39u,
  185u,
  225u,
  225u,
  217u,
  56u,
  248u,
  248u,
  235u,
  19u,
  152u,
  152u,
  43u,
  179u,
  17u,
  17u,
  34u,
  51u,
  105u,
  105u,
  210u,
  187u,
  217u,
  217u,
  169u,
  112u,
  142u,
  142u,
  7u,
  137u,
  148u,
  148u,
  51u,
  167u,
  155u,
  155u,
  45u,
  182u,
  30u,
  30u,
  60u,
  34u,
  135u,
  135u,
  21u,
  146u,
  233u,
  233u,
  201u,
  32u,
  206u,
  206u,
  135u,
  73u,
  85u,
  85u,
  170u,
  255u,
  40u,
  40u,
  80u,
  120u,
  223u,
  223u,
  165u,
  122u,
  140u,
  140u,
  3u,
  143u,
  161u,
  161u,
  89u,
  248u,
  137u,
  137u,
  9u,
  128u,
  13u,
  13u,
  26u,
  23u,
  191u,
  191u,
  101u,
  218u,
  230u,
  230u,
  215u,
  49u,
  66u,
  66u,
  132u,
  198u,
  104u,
  104u,
  208u,
  184u,
  65u,
  65u,
  130u,
  195u,
  153u,
  153u,
  41u,
  176u,
  45u,
  45u,
  90u,
  119u,
  15u,
  15u,
  30u,
  17u,
  176u,
  176u,
  123u,
  203u,
  84u,
  84u,
  168u,
  252u,
  187u,
  187u,
  109u,
  214u,
  22u,
  22u,
  44u,
  58u
}; // weak
_UNKNOWN unk_8490; // weak
_DWORD dword_84B8[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
_DWORD dword_88B8[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
_DWORD dword_8CB8[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
_DWORD dword_90B8[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
unsigned __int8 byte_94B8[256] =
{
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u
}; // weak
_UNKNOWN *off_20060 = &off_20060; // weak
char *off_20068[4] = { "w+b", "r+b", "rb", "ab" }; // weak
__int64 qword_24680; // weak
__int64 qword_24688; // weak
__int64 qword_24690; // weak
__int16 word_24698; // weak
__int16 word_2469C; // weak
int dword_246A0; // weak
__int64 qword_246A8; // weak
pthread_mutex_t stru_246B0; // weak
__int16 word_246D8[8]; // weak
__int128 xmmword_246E8; // weak
__int128 xmmword_246F8; // weak
__int128 xmmword_24708; // weak
__int128 xmmword_24718; // weak
__int128 xmmword_24728; // weak
__int128 xmmword_24738; // weak
__int128 xmmword_24748; // weak
__int128 xmmword_24758; // weak
__int128 xmmword_24768; // weak
__int128 xmmword_24778; // weak
__int128 xmmword_24788; // weak
__int128 xmmword_24798; // weak
__int128 xmmword_247A8; // weak
__int128 xmmword_247B8; // weak
__int128 xmmword_247C8; // weak
__int128 xmmword_247D8; // weak
__int128 xmmword_247E8; // weak
__int128 xmmword_247F8; // weak
__int128 xmmword_24808; // weak
__int128 xmmword_24818; // weak
__int128 xmmword_24828; // weak
__int128 xmmword_24838; // weak
__int128 xmmword_24848; // weak
__int128 xmmword_24858; // weak
__int64 qword_24868; // weak
__int128 xmmword_24872; // weak
__int128 xmmword_24882; // weak
__int128 xmmword_24892; // weak
__int128 xmmword_248A2; // weak
__int128 xmmword_248B2; // weak
__int128 xmmword_248C2; // weak
__int16 word_248D2; // weak
__int128 xmmword_24910; // weak
__int128 xmmword_24920; // weak
__int128 xmmword_24930; // weak
__int128 xmmword_24940; // weak
__int128 xmmword_24950; // weak
__int128 xmmword_24960; // weak
__int128 xmmword_24970; // weak
__int128 xmmword_24980; // weak
__int128 xmmword_24990; // weak
__int128 xmmword_249A0; // weak
__int128 xmmword_249B0; // weak
__int128 xmmword_249C0; // weak
__int128 xmmword_249D0; // weak
__int128 xmmword_249E0; // weak
__int128 xmmword_249F0; // weak
__int128 xmmword_24A00; // weak
__int128 xmmword_24A10; // weak
__int128 xmmword_24A20; // weak
__int128 xmmword_24A30; // weak
__int128 xmmword_24A40; // weak
__int128 xmmword_24A50; // weak
__int128 xmmword_24A60; // weak
__int128 xmmword_24A70; // weak
__int128 xmmword_24A80; // weak
__int64 qword_24A90; // weak
__int64 qword_24A98; // weak
__int64 qword_24AA0; // weak


//----- (000000000000BC28) ----------------------------------------------------
__int64 sub_BC28()
{
  return __cxa_finalize(&off_20060);
}
// 20060: using guessed type _UNKNOWN *off_20060;

//----- (000000000000BC38) ----------------------------------------------------
void sub_BC38()
{
  ;
}

//----- (000000000000BC40) ----------------------------------------------------
void sub_BC40()
{
  sub_BC38();
}

//----- (000000000000BC48) ----------------------------------------------------
__int64 (*__fastcall sub_BC48(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (000000000000BC5C) ----------------------------------------------------
__int64 __fastcall sub_BC5C(void *obj)
{
  return __cxa_atexit((void (*)(void *))sub_BC48, obj, &off_20060);
}
// 20060: using guessed type _UNKNOWN *off_20060;

//----- (000000000000BC78) ----------------------------------------------------
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x23
  __int64 v9; // x0
  __int64 v11; // x0
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64, __int64); // [xsp+8h] [xbp-8h]

  v5 = qword_24680;
  if ( !qword_24680 )
  {
    v7 = qword_24688;
    if ( !qword_24688 )
    {
      v11 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v11 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v11);
      qword_24688 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "<init>",
           "([BLjava/lang/String;)V");
    qword_24680 = v5;
    if ( !v5 )
      return 0;
  }
  v8 = qword_24688;
  v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 224LL);
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v12(a1, v8, v5, a2, v9);
}
// 24680: using guessed type __int64 qword_24680;
// 24688: using guessed type __int64 qword_24688;

//----- (000000000000BD88) ----------------------------------------------------
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x0
  __int64 v10; // x0
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64); // [xsp+18h] [xbp+18h]

  v5 = qword_24690;
  if ( !qword_24690 )
  {
    v7 = qword_24688;
    if ( !qword_24688 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v10 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v10);
      qword_24688 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "getBytes",
           "(Ljava/lang/String;)[B");
    qword_24690 = v5;
    if ( !v5 )
      return 0;
  }
  v11 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v11(a1, a2, v5, v8);
}
// 24688: using guessed type __int64 qword_24688;
// 24690: using guessed type __int64 qword_24690;

//----- (000000000000BE84) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMVersion(__int64 a1)
{
  int v2; // w0
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x10
  char *v6; // x0
  __int64 v7; // x22
  int v8; // w0
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x10
  char *v12; // x0
  __int64 v13; // x22
  int v14; // w0
  __int64 v15; // x8
  __int64 v16; // x9
  __int64 v17; // x10
  char *v18; // x0
  __int64 v19; // x22
  char v21[33]; // [xsp+0h] [xbp-50h] BYREF
  char v22; // [xsp+21h] [xbp-2Fh]
  __int16 v23; // [xsp+22h] [xbp-2Eh]
  int v24; // [xsp+24h] [xbp-2Ch]
  __int64 v25; // [xsp+28h] [xbp-28h]
  __int128 v26; // [xsp+30h] [xbp-20h]
  __int64 v27; // [xsp+48h] [xbp-8h]

  v27 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  strcpy(v21, "Interface_DRMVersion()::Build = ");
  v22 = unk_732D;
  v23 = unk_732E;
  v24 = unk_7330;
  v25 = unk_7334;
  v26 = xmmword_733C;
  if ( (int)__strlen_chk(v21, 0x40u) >= 1 )
  {
    v2 = __strlen_chk(v21, 0x40u);
    v3 = v2;
    v4 = v2 + 10;
    v5 = v2 + 1LL;
    v6 = &v21[v2];
    if ( v5 > v4 )
      v7 = v3 + 1;
    else
      v7 = v4;
    memcpy(v6, "2016.05.18", v7 - v3);
    v21[(int)v7] = 0;
  }
  if ( (int)__strlen_chk(v21, 0x40u) >= 1 )
  {
    v8 = __strlen_chk(v21, 0x40u);
    v9 = v8;
    v10 = v8 + 12;
    v11 = v8 + 1LL;
    v12 = &v21[v8];
    if ( v11 > v10 )
      v13 = v9 + 1;
    else
      v13 = v10;
    memcpy(v12, ", Version = ", v13 - v9);
    v21[(int)v13] = 0;
  }
  if ( (int)__strlen_chk(v21, 0x40u) >= 1 )
  {
    v14 = __strlen_chk(v21, 0x40u);
    v15 = v14;
    v16 = v14 + 6;
    v17 = v14 + 1LL;
    v18 = &v21[v14];
    if ( v17 > v16 )
      v19 = v15 + 1;
    else
      v19 = v16;
    memcpy(v18, "15.0.3", v19 - v15);
    v21[(int)v19] = 0;
  }
  printLogD();
  return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v21);
}
// 733C: using guessed type __int128 xmmword_733C;

//----- (000000000000C010) ----------------------------------------------------
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMIsEmbeddedDRM()
{
  unsigned int v1; // w19

  if ( word_24698 == 1 && word_2469C == 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = 2;
    if ( word_24698 || word_2469C != 1 )
    {
      if ( word_2469C == 1 || word_24698 == 1 )
        v1 = 2;
      else
        v1 = 0;
    }
  }
  printLogD();
  return v1;
}
// 24698: using guessed type __int16 word_24698;
// 2469C: using guessed type __int16 word_2469C;

//----- (000000000000C084) ----------------------------------------------------
bool Java_DigiCAP_SKT_DRM_DRMInterface_DRMIsExpandedFilePath()
{
  printLogD();
  return word_2469C == 1 || word_24698 == 1;
}
// 24698: using guessed type __int16 word_24698;
// 2469C: using guessed type __int16 word_2469C;

//----- (000000000000C0E0) ----------------------------------------------------
bool hasLibraryFile_MVersionCk()
{
  _BYTE v1[128]; // [xsp+8h] [xbp-88h] BYREF
  __int64 v2; // [xsp+88h] [xbp-8h]

  v2 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  return !stat("/system/lib64/libMVersionCk.so", (struct stat *)v1)
      || !stat("/system/lib/libMVersionCk.so", (struct stat *)v1)
      || !stat("/system/vendor/lib64/libMVersionCk.so", (struct stat *)v1)
      || !stat("/system/vendor/lib/libMVersionCk.so", (struct stat *)v1);
}

//----- (000000000000C17C) ----------------------------------------------------
bool hasLibraryFile_SKT_MusicDRM()
{
  _BYTE v1[128]; // [xsp+8h] [xbp-88h] BYREF
  __int64 v2; // [xsp+88h] [xbp-8h]

  v2 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  return !stat("/system/lib64/libSKT_MusicDRM.so", (struct stat *)v1)
      || !stat("/system/lib/libSKT_MusicDRM.so", (struct stat *)v1)
      || !stat("/system/vendor/lib64/libSKT_MusicDRM.so", (struct stat *)v1)
      || !stat("/system/vendor/lib/libSKT_MusicDRM.so", (struct stat *)v1);
}

//----- (000000000000C218) ----------------------------------------------------
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMInit()
{
  unsigned int v0; // w19
  __int16 v1; // w8
  __int16 v2; // w8
  _BYTE v4[128]; // [xsp+8h] [xbp-88h] BYREF
  __int64 v5; // [xsp+88h] [xbp-8h]

  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  v0 = DRM_Init();
  printLogD();
  if ( !word_2469C )
  {
    v1 = !stat("/system/lib64/libMVersionCk.so", (struct stat *)v4)
      || !stat("/system/lib/libMVersionCk.so", (struct stat *)v4)
      || !stat("/system/vendor/lib64/libMVersionCk.so", (struct stat *)v4)
      || !stat("/system/vendor/lib/libMVersionCk.so", (struct stat *)v4);
    word_2469C = v1;
  }
  if ( !word_24698 )
  {
    v2 = !stat("/system/lib64/libSKT_MusicDRM.so", (struct stat *)v4)
      || !stat("/system/lib/libSKT_MusicDRM.so", (struct stat *)v4)
      || !stat("/system/vendor/lib64/libSKT_MusicDRM.so", (struct stat *)v4)
      || !stat("/system/vendor/lib/libSKT_MusicDRM.so", (struct stat *)v4);
    word_24698 = v2;
  }
  return v0;
}
// 24698: using guessed type __int16 word_24698;
// 2469C: using guessed type __int16 word_2469C;

//----- (000000000000C370) ----------------------------------------------------
void Java_DigiCAP_SKT_DRM_DRMInterface_DRMDestroy()
{
  printLogD();
  DRM_Destroy();
  word_2469C = 0;
  word_24698 = 0;
  printLogD();
  printLogD();
}
// 24698: using guessed type __int16 word_24698;
// 2469C: using guessed type __int16 word_2469C;

//----- (000000000000C3D0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPath(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        __int16 a5)
{
  __int64 v9; // x23
  __int64 v10; // x24
  unsigned int v11; // w21
  char v13; // [xsp+6h] [xbp-100Ah] BYREF
  char s[4097]; // [xsp+7h] [xbp-1009h] BYREF
  __int64 v15; // [xsp+1008h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  if ( a3 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1472LL))(a1, a3, &v13);
    v10 = (*(int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
    __memcpy_chk(s, v9, v10, 4097);
    s[v10] = 0;
    __strlen_chk(s, 0x1001u);
    printLogD();
    (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v9, 0);
    printLogD();
    v11 = -9876;
    if ( (unsigned int)(a4 - 1) <= 3 && a5 == 1 )
    {
      printLogD();
      v11 = (__int16)DRM_Open_Path(s, a4, 1);
    }
  }
  else
  {
    v11 = -9976;
  }
  printLogD();
  return v11;
}
// 1B900: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000C578) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPfd(__int64 a1, __int64 a2, int a3, int a4, __int16 a5)
{
  unsigned int v5; // w19

  if ( a3 < 1 )
  {
    v5 = -9976;
  }
  else
  {
    v5 = -9876;
    if ( (unsigned int)(a4 - 1) <= 3 && a5 == 1 )
    {
      printLogD();
      v5 = (__int16)DRM_Open_Pfd(a3, a4, 1);
    }
  }
  printLogD();
  return v5;
}

//----- (000000000000C610) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMClose(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  printLogD();
  return DRM_Close(a3);
}

//----- (000000000000C648) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMRead(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        int a5)
{
  char *v9; // x20
  int v10; // w19
  __int64 v11; // x23
  __int64 v12; // x0
  __int64 v13; // x0

  printLogD();
  v9 = (char *)malloc(a5);
  v10 = DRM_Read(a3, v9, a5);
  if ( v10 >= 1 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(a1, (unsigned int)v10);
    (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, char *))(*(_QWORD *)a1 + 1664LL))(
      a1,
      v11,
      0,
      (unsigned int)v10,
      v9);
    v12 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 248LL))(a1, a4);
    v13 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
            a1,
            v12,
            "put",
            "([B)Ljava/nio/ByteBuffer;");
    if ( v13 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, a4, v13, v11);
      if ( !v11 )
        goto LABEL_5;
      goto LABEL_4;
    }
    v10 = -12;
    if ( v11 )
LABEL_4:
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v11);
  }
LABEL_5:
  if ( v9 )
    free(v9);
  printLogD();
  return v10;
}

//----- (000000000000C7A0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMSeek(__int64 a1, __int64 a2, unsigned int a3, int a4, int a5)
{
  int v8; // w2
  int v9; // w19

  printLogD();
  if ( (unsigned int)(a5 - 1) >= 3 )
    v8 = 0;
  else
    v8 = a5;
  v9 = DRM_Seek(a3, a4, v8);
  printLogD();
  return v9;
}

//----- (000000000000C820) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetOriginalFileSize(
        __int64 a1,
        __int64 a2,
        unsigned __int16 a3)
{
  __int64 OriginalFileSize; // x19

  printLogD();
  OriginalFileSize = (int)DRM_GetOriginalFileSize(a3);
  printLogD();
  return OriginalFileSize;
}

//----- (000000000000C88C) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetFileSize(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int64 FileSize; // x19

  printLogD();
  FileSize = (int)DRM_GetFileSize(a3);
  printLogD();
  return FileSize;
}

//----- (000000000000C8F8) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetErrorCode(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int16 ContentInfo; // w0
  __int16 v5; // w9
  __int64 v6; // x20
  int *v8[2]; // [xsp+0h] [xbp-10h] BYREF

  v8[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  ContentInfo = DRM_GetContentInfo(a3, v8);
  if ( ContentInfo < 0 )
  {
    v5 = ContentInfo;
  }
  else
  {
    printLogD();
    v5 = *((_WORD *)v8[0] + 30);
  }
  v6 = v5;
  printLogD();
  printLogD();
  return v6;
}

//----- (000000000000C9D4) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentID(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int16 ContentInfo; // w20
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x11
  __int128 *v9; // x12
  _OWORD *v10; // x13
  __int64 v11; // x14
  __int128 v12; // q0
  __int128 v13; // q1
  __int64 v14; // x14
  __int64 *v15; // x12
  _QWORD *v16; // x13
  __int64 v17; // x14
  __int64 v18; // t1
  __int64 v19; // x9
  char *v20; // x10
  char *v21; // x8
  char v22; // t1
  int *v23; // [xsp+8h] [xbp-78h] BYREF
  __int128 v24; // [xsp+10h] [xbp-70h] BYREF
  _OWORD v25[5]; // [xsp+20h] [xbp-60h] BYREF
  __int64 v26; // [xsp+78h] [xbp-8h]

  v26 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v24 = 0u;
  memset(v25, 0, sizeof(v25));
  ContentInfo = DRM_GetContentInfo(a3, &v23);
  printLogD();
  if ( ContentInfo < 0 )
    return 0;
  printLogD();
  v5 = *((_QWORD *)v23 + 5);
  if ( v5 )
  {
    v6 = (unsigned int)v23[3];
    if ( (unsigned int)(v6 - 1) <= 0xFFFFFFFD )
    {
      v7 = 0;
      if ( (unsigned int)v6 >= 8 && (unsigned __int64)&v25[-1] - v5 >= 0x20 )
      {
        if ( (unsigned int)v6 < 0x20 )
        {
          v7 = 0;
          goto LABEL_13;
        }
        v7 = (unsigned int)v6 & 0xFFFFFFE0;
        v9 = (__int128 *)(v5 + 16);
        v10 = v25;
        v11 = v7;
        do
        {
          v12 = *(v9 - 1);
          v13 = *v9;
          v11 -= 32;
          v9 += 2;
          *(v10 - 1) = v12;
          *v10 = v13;
          v10 += 2;
        }
        while ( v11 );
        if ( v7 == v6 )
          return (*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)a1 + 1336LL))(a1, &v24);
        if ( (v6 & 0x18) != 0 )
        {
LABEL_13:
          v14 = v7;
          v7 = (unsigned int)v6 & 0xFFFFFFF8;
          v15 = (__int64 *)(v5 + v14);
          v16 = (_QWORD *)((char *)&v25[-1] + v14);
          v17 = v14 - v7;
          do
          {
            v18 = *v15++;
            v17 += 8;
            *v16++ = v18;
          }
          while ( v17 );
          if ( v7 == v6 )
            return (*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)a1 + 1336LL))(a1, &v24);
        }
      }
      v19 = v6 - v7;
      v20 = (char *)&v25[-1] + v7;
      v21 = (char *)(v5 + v7);
      do
      {
        v22 = *v21++;
        --v19;
        *v20++ = v22;
      }
      while ( v19 );
    }
  }
  return (*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)a1 + 1336LL))(a1, &v24);
}

//----- (000000000000CB80) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentIDPfd(__int64 a1, __int64 a2, __int16 a3)
{
  int v4; // w0
  FILE *v5; // x21
  _BYTE *v6; // x1
  const void *v7; // x1
  int v8; // t1
  _OWORD v10[6]; // [xsp+0h] [xbp-F0h] BYREF
  _BYTE ptr[2]; // [xsp+68h] [xbp-88h] BYREF
  unsigned __int8 v12; // [xsp+6Ah] [xbp-86h]
  __int64 v13; // [xsp+E8h] [xbp-8h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v10, 0, sizeof(v10));
  v4 = dup(a3);
  v5 = fdopen(v4, "r");
  printLogD();
  if ( v5 )
  {
    rewind(v5);
    fread(ptr, 1u, 0x80u, v5);
    fclose(v5);
    v6 = &ptr[ptr[1]];
    v8 = *(_DWORD *)(v6 + 3);
    v7 = v6 + 3;
    if ( v8 == 979659107 )
    {
      if ( v12 <= 0x5FuLL )
        memcpy(v10, v7, v12 + 1LL);
      printLogD();
      printLogD();
      return (*(__int64 (__fastcall **)(__int64, _OWORD *))(*(_QWORD *)a1 + 1336LL))(a1, v10);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    printLogD();
    return 0;
  }
}

//----- (000000000000CCEC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentIDPath(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x21
  __int64 v6; // x20
  FILE *v7; // x0
  FILE *v8; // x20
  _BYTE *v9; // x1
  const void *v10; // x1
  int v11; // t1
  char s[4097]; // [xsp+Fh] [xbp-10F1h] BYREF
  _BYTE dest[104]; // [xsp+1010h] [xbp-F0h] BYREF
  _BYTE ptr[2]; // [xsp+1078h] [xbp-88h] BYREF
  unsigned __int8 v16; // [xsp+107Ah] [xbp-86h]
  __int64 v17; // [xsp+10F8h] [xbp-8h]

  v17 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(dest, 0, 96);
  memset(s, 0, sizeof(s));
  v5 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  v6 = (*(int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3);
  __memcpy_chk(s, v5, v6, 4097);
  s[v6] = 0;
  printLogD();
  v7 = fopen(s, "r");
  if ( v7 )
  {
    v8 = v7;
    fread(ptr, 1u, 0x80u, v7);
    fclose(v8);
    v9 = &ptr[ptr[1]];
    v11 = *(_DWORD *)(v9 + 3);
    v10 = v9 + 3;
    if ( v11 == 979659107 )
    {
      if ( (unsigned int)v16 - 1 <= 0x5F )
        memcpy(dest, v10, v16);
      printLogD();
      printLogD();
      return (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 1336LL))(a1, dest);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    printLogD();
    return 0;
  }
}
// 1B900: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000CEBC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetValidPeriod(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int16 ContentInfo; // w20
  const char *v6; // x20
  size_t v7; // x0
  size_t v8; // x9
  size_t v9; // x12
  __int64 *v10; // x10
  _QWORD *v11; // x11
  size_t v12; // x12
  __int64 v13; // t1
  size_t v15; // x10
  char *v16; // x8
  char *v17; // x9
  char v18; // t1
  int *v19; // [xsp+8h] [xbp-58h] BYREF
  __int128 v20; // [xsp+10h] [xbp-50h] BYREF
  __int128 v21; // [xsp+20h] [xbp-40h]
  char v22[4]; // [xsp+38h] [xbp-28h] BYREF
  char v23; // [xsp+3Ch] [xbp-24h]
  __int16 v24; // [xsp+3Dh] [xbp-23h]
  char v25; // [xsp+3Fh] [xbp-21h]
  __int16 v26; // [xsp+40h] [xbp-20h]
  char v27; // [xsp+42h] [xbp-1Eh]
  __int16 v28; // [xsp+43h] [xbp-1Dh]
  char v29; // [xsp+45h] [xbp-1Bh]
  __int16 v30; // [xsp+46h] [xbp-1Ah]
  char v31; // [xsp+48h] [xbp-18h]
  __int16 v32; // [xsp+49h] [xbp-17h]
  _BYTE v33[13]; // [xsp+4Bh] [xbp-15h] BYREF
  __int64 v34; // [xsp+58h] [xbp-8h]

  v34 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v33, 0, sizeof(v33));
  v20 = 0u;
  v21 = 0u;
  printLogD();
  ContentInfo = DRM_GetContentInfo(a3, &v19);
  printLogD();
  if ( ContentInfo < 0 )
    return 0;
  v6 = (const char *)*((_QWORD *)v19 + 17);
  v7 = strlen(v6);
  if ( v6 && v7 - 1 <= 0x1F )
  {
    v8 = 0;
    if ( v7 >= 8 && (unsigned __int64)((char *)&v20 - v6) >= 0x10 )
    {
      if ( v7 < 0x10 )
      {
        v8 = 0;
        goto LABEL_8;
      }
      v8 = v7 & 0x30;
      v20 = *(_OWORD *)v6;
      if ( v8 != 16 )
        v21 = *((_OWORD *)v6 + 1);
      if ( v7 == v8 )
        goto LABEL_19;
      if ( (v7 & 8) != 0 )
      {
LABEL_8:
        v9 = v8;
        v8 = v7 & 0x38;
        v10 = (__int64 *)&v6[v9];
        v11 = (_QWORD *)((char *)&v20 + v9);
        v12 = v9 - v8;
        do
        {
          v13 = *v10++;
          v12 += 8LL;
          *v11++ = v13;
        }
        while ( v12 );
        if ( v7 == v8 )
          goto LABEL_19;
      }
    }
    v15 = v7 - v8;
    v16 = (char *)&v20 + v8;
    v17 = (char *)&v6[v8];
    do
    {
      v18 = *v17++;
      --v15;
      *v16++ = v18;
    }
    while ( v15 );
  }
LABEL_19:
  printLogD();
  printLogD();
  v24 = WORD2(v20);
  *(_DWORD *)v22 = v20;
  v26 = WORD3(v20);
  v23 = 45;
  v28 = WORD4(v20);
  v25 = 45;
  v30 = WORD5(v20);
  v27 = 32;
  v29 = 58;
  v31 = 58;
  v32 = WORD6(v20);
  __strlen_chk(v22, 0x20u);
  printLogD();
  printLogD();
  return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v22);
}

//----- (000000000000D114) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetContentDescription(
        __int64 a1,
        __int64 a2,
        unsigned __int16 a3)
{
  __int16 ContentInfo; // w20
  __int64 v6; // x9
  __int64 v7; // x8
  int v8; // w10
  unsigned __int64 v9; // x2
  __int64 v10; // x11
  __int128 *v12; // x12
  _OWORD *v13; // x13
  unsigned __int64 v14; // x14
  __int128 v15; // q0
  __int128 v16; // q1
  __int64 *v17; // x12
  _QWORD *v18; // x13
  unsigned __int64 v19; // x14
  __int64 v20; // t1
  int *v21; // [xsp+8h] [xbp-118h] BYREF
  __int128 v22; // [xsp+10h] [xbp-110h] BYREF
  _OWORD v23[15]; // [xsp+20h] [xbp-100h] BYREF
  __int64 v24; // [xsp+118h] [xbp-8h]

  v24 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  printLogD();
  ContentInfo = DRM_GetContentInfo(a3, &v21);
  printLogD();
  if ( ContentInfo < 0 )
    return 0;
  v6 = 0;
  v7 = *((_QWORD *)v21 + 11);
  do
    v8 = *(unsigned __int8 *)(v7 + v6++);
  while ( (unsigned int)(v8 - 48) < 0xA );
  v9 = v6 - 1;
  if ( (unsigned int)(v6 - 2) <= 0xFF )
  {
    v10 = 0;
    if ( v9 < 8 || (unsigned __int64)&v23[-1] - v7 < 0x20 )
      goto LABEL_17;
    if ( v9 < 0x20 )
    {
      v10 = 0;
      goto LABEL_14;
    }
    v10 = v9 & 0x7FFFFFFFFFFFFFE0LL;
    v12 = (__int128 *)(v7 + 16);
    v13 = v23;
    v14 = v9 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v15 = *(v12 - 1);
      v16 = *v12;
      v14 -= 32LL;
      v12 += 2;
      *(v13 - 1) = v15;
      *v13 = v16;
      v13 += 2;
    }
    while ( v14 );
    if ( v9 != v10 )
    {
      if ( (v9 & 0x18) == 0 )
        goto LABEL_17;
LABEL_14:
      v17 = (__int64 *)(v7 + v10);
      v18 = (_QWORD *)((char *)&v23[-1] + v10);
      v19 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
      v10 = v9 & 0x7FFFFFFFFFFFFFF8LL;
      do
      {
        v20 = *v17++;
        v19 += 8LL;
        *v18++ = v20;
      }
      while ( v19 );
      while ( v9 != v10 )
      {
LABEL_17:
        *((_BYTE *)&v23[-1] + v10) = *(_BYTE *)(v7 + v10);
        ++v10;
      }
    }
  }
  *((_BYTE *)&v23[-1] + v6 - 1) = 0;
  printLogD();
  printLogD();
  return (*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)a1 + 1336LL))(a1, &v22);
}

//----- (000000000000D31C) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetUnsupportedValue(
        __int64 *a1,
        __int64 a2,
        unsigned __int16 a3,
        __int64 a4)
{
  int v6; // w22
  __int64 v8; // x22
  unsigned int v9; // w0
  __int64 v10; // x9
  __int64 v11; // x8
  __int128 *v13; // x11
  __int128 *v14; // x12
  __int64 v15; // x13
  __int128 v16; // q0
  __int128 v17; // q1
  __int64 v18; // x13
  __int64 *v19; // x11
  _QWORD *v20; // x12
  __int64 v21; // x13
  __int64 v22; // t1
  __int64 v23; // x11
  char *v24; // x10
  char *v25; // x9
  char v26; // t1
  __int64 v27; // x10
  signed __int64 v28; // x0
  unsigned __int64 v29; // x21
  int DCFMetaDataEncodingType; // w8
  __int64 v31; // x20
  __int64 v32; // x0
  __int64 v33; // x2
  __int64 v34; // x9
  __int64 v35; // x8
  __int64 v36; // x20
  __int64 v37; // x21
  __int64 v38; // x1
  __int64 (__fastcall *v39)(__int64 *, __int64, __int64, __int64); // x22
  __int64 v40; // x0
  _OWORD *v41; // x11
  __int64 v42; // x12
  __int128 *v43; // x10
  __int128 v44; // q0
  __int128 v45; // q1
  __int64 v46; // x12
  _QWORD *v47; // x11
  __int64 *v48; // x10
  unsigned __int64 v49; // x12
  __int64 v50; // t1
  _BYTE *v51; // x10
  char *v52; // x8
  unsigned __int64 v53; // x9
  char v54; // t1
  __int64 v55; // x0
  int *v56; // [xsp+8h] [xbp-2038h] BYREF
  _BYTE s[4096]; // [xsp+10h] [xbp-2030h] BYREF
  unsigned __int16 v58; // [xsp+1010h] [xbp-1030h] BYREF
  unsigned __int8 v59; // [xsp+1012h] [xbp-102Eh]
  __int64 v60; // [xsp+1020h] [xbp-1020h] BYREF
  __int128 v61; // [xsp+2010h] [xbp-30h] BYREF
  __int128 v62; // [xsp+2020h] [xbp-20h] BYREF
  __int64 v63; // [xsp+2038h] [xbp-8h]

  v6 = a3;
  v63 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v62 = 0u;
  v61 = 0u;
  memset(&v58, 0, 0x1000u);
  printLogD();
  if ( !v6
    || (v8 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1352))(a1, a4, 0),
        v9 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4),
        !v8) )
  {
    printLogD();
    return 0;
  }
  if ( (int)v9 >= 1 )
  {
    v10 = 0;
    v11 = v9;
    if ( v9 >= 8 && (unsigned __int64)&v61 - v8 >= 0x20 )
    {
      if ( v9 < 0x20 )
      {
        v10 = 0;
        goto LABEL_15;
      }
      v10 = v9 & 0x7FFFFFE0;
      v13 = (__int128 *)(v8 + 16);
      v14 = &v62;
      v15 = v10;
      do
      {
        v16 = *(v13 - 1);
        v17 = *v13;
        v15 -= 32;
        v13 += 2;
        *(v14 - 1) = v16;
        *v14 = v17;
        v14 += 2;
      }
      while ( v15 );
      if ( v10 == v9 )
        goto LABEL_20;
      if ( (v9 & 0x18) != 0 )
      {
LABEL_15:
        v18 = v10;
        v10 = v9 & 0x7FFFFFF8;
        v19 = (__int64 *)(v8 + v18);
        v20 = (_QWORD *)((char *)&v61 + v18);
        v21 = v18 - v10;
        do
        {
          v22 = *v19++;
          v21 += 8;
          *v20++ = v22;
        }
        while ( v21 );
        if ( v10 == v9 )
          goto LABEL_20;
      }
    }
    v23 = v9 - v10;
    v24 = (char *)&v61 + v10;
    v25 = (char *)(v8 + v10);
    do
    {
      v26 = *v25++;
      --v23;
      *v24++ = v26;
    }
    while ( v23 );
    goto LABEL_20;
  }
  v11 = 0;
LABEL_20:
  v27 = *a1;
  *((_BYTE *)&v61 + v11) = 0;
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(v27 + 1360))(a1, a4, v8);
  DRM_GetContentInfo(a3, &v56);
  printLogD();
  if ( (DRM_GetUnsupportedValue((__int64)v56, &v61, &v58, 4096) & 0x8000) != 0 )
    goto LABEL_28;
  v28 = __strlen_chk((const char *)&v58, 0x1000u);
  if ( v28 <= 0 )
    goto LABEL_28;
  v29 = v28;
  DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
  if ( DCFMetaDataEncodingType == 3 )
  {
    memset(s, 0, sizeof(s));
    v35 = 3;
    if ( v58 ^ 0xBBEF | v59 ^ 0xBF )
      v35 = 0;
    __strcpy_chk(s, (char *)&v58 + v35, 4096);
    v36 = (*(__int64 (__fastcall **)(__int64 *, _BYTE *))(*a1 + 1336))(a1, s);
    v37 = qword_24690;
    if ( qword_24690
      || ((v38 = qword_24688) != 0
       || (v55 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "java/lang/String")) != 0
       && (v38 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, v55), (qword_24688 = v38) != 0))
      && (v37 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
                  a1,
                  v38,
                  "getBytes",
                  "(Ljava/lang/String;)[B"),
          (qword_24690 = v37) != 0) )
    {
      v39 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 272);
      v40 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 1336))(a1, "ksc-5601");
      v31 = v39(a1, v36, v37, v40);
    }
    else
    {
      v31 = 0;
    }
    v33 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v31, 0);
    goto LABEL_47;
  }
  if ( DCFMetaDataEncodingType )
  {
LABEL_28:
    printLogD();
    return 0;
  }
  v31 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v29);
  v32 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 1472))(a1);
  v33 = v32;
  v34 = 0;
  if ( v29 >= 8 && (unsigned __int64)(v32 - (_QWORD)&v58) >= 0x20 )
  {
    if ( v29 < 0x20 )
    {
      v34 = 0;
      goto LABEL_42;
    }
    v34 = v29 & 0x7FFFFFFFFFFFFFE0LL;
    v41 = (_OWORD *)(v32 + 16);
    v42 = v29 & 0x7FFFFFFFFFFFFFE0LL;
    v43 = (__int128 *)&v60;
    do
    {
      v44 = *(v43 - 1);
      v45 = *v43;
      v42 -= 32;
      v43 += 2;
      *(v41 - 1) = v44;
      *v41 = v45;
      v41 += 2;
    }
    while ( v42 );
    if ( v29 == v34 )
      goto LABEL_47;
    if ( (v29 & 0x18) != 0 )
    {
LABEL_42:
      v46 = v34;
      v34 = v29 & 0x7FFFFFFFFFFFFFF8LL;
      v47 = (_QWORD *)(v32 + v46);
      v48 = (__int64 *)((char *)&v58 + v46);
      v49 = v46 - (v29 & 0x7FFFFFFFFFFFFFF8LL);
      do
      {
        v50 = *v48++;
        v49 += 8LL;
        *v47++ = v50;
      }
      while ( v49 );
      if ( v29 == v34 )
        goto LABEL_47;
    }
  }
  v51 = (_BYTE *)(v32 + v34);
  v52 = (char *)&v58 + v34;
  v53 = v29 - v34;
  do
  {
    v54 = *v52++;
    --v53;
    *v51++ = v54;
  }
  while ( v53 );
LABEL_47:
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v31, v33, 0);
  return v31;
}
// 1BA40: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 24688: using guessed type __int64 qword_24688;
// 24690: using guessed type __int64 qword_24690;

//----- (000000000000D854) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetUnsupportedValueUTF8(
        __int64 *a1,
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v7; // x22
  signed int v8; // w0
  __int64 result; // x0
  __int64 v10; // x8
  char *v11; // x1
  int DCFMetaDataEncodingType; // w8
  size_t v13; // x21
  __int64 v14; // x20
  __int64 v15; // x0
  __int64 v16; // x2
  __int64 v17; // x8
  _OWORD *v18; // x10
  __int128 *v19; // x9
  __int64 v20; // x11
  __int128 v21; // q0
  __int128 v22; // q1
  __int64 v23; // x11
  char *v24; // x9
  _QWORD *v25; // x10
  size_t v26; // x11
  __int64 v27; // t1
  _BYTE *v28; // x9
  char *v29; // x10
  size_t v30; // x8
  char v31; // t1
  __int64 v32; // x21
  __int64 v33; // x1
  __int64 v34; // x22
  __int64 (__fastcall *v35)(__int64 *, __int64, __int64, __int64, __int64); // x24
  __int64 v36; // x0
  __int64 v37; // x21
  int *v38; // [xsp+8h] [xbp-138h] BYREF
  char v39[16]; // [xsp+10h] [xbp-130h] BYREF
  _OWORD v40[15]; // [xsp+20h] [xbp-120h] BYREF
  _BYTE v41[40]; // [xsp+110h] [xbp-30h] BYREF
  __int64 v42; // [xsp+138h] [xbp-8h]

  v42 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v41, 0, 32);
  *(_OWORD *)v39 = 0u;
  memset(v40, 0, sizeof(v40));
  printLogD();
  v7 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1352))(a1, a4, 0);
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  if ( v8 <= 0 || (unsigned int)v8 >= 0x21 )
  {
    printLogD();
    return (*(__int64 (__fastcall **)(__int64 *, void *))(*a1 + 1336))(a1, &unk_4DED);
  }
  if ( (unsigned int)DHstrncpy_s((__int64)v41, 32, v7, v8) )
  {
    printLogD();
LABEL_6:
    v10 = *a1;
    v11 = (char *)&unk_4DED;
    return (*(__int64 (__fastcall **)(__int64 *, char *))(v10 + 1336))(a1, v11);
  }
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1360))(a1, a4, v7);
  printLogD();
  DRM_GetContentInfo(a3, &v38);
  printLogD();
  if ( (DRM_GetUnsupportedValue((__int64)v38, v41, v39, 256) & 0x8000) != 0 )
    goto LABEL_17;
  DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
  if ( DCFMetaDataEncodingType == 3 )
  {
    v10 = *a1;
    v11 = v39;
    return (*(__int64 (__fastcall **)(__int64 *, char *))(v10 + 1336))(a1, v11);
  }
  if ( DCFMetaDataEncodingType )
  {
LABEL_17:
    printLogD();
    goto LABEL_6;
  }
  v13 = __strlen_chk(v39, 0x100u);
  v14 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v13);
  v15 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v14, 0);
  v16 = v15;
  if ( (__int64)v13 >= 1 )
  {
    v17 = 0;
    if ( v13 >= 8 && (unsigned __int64)(v15 - (_QWORD)v39) >= 0x20 )
    {
      if ( v13 < 0x20 )
      {
        v17 = 0;
        goto LABEL_24;
      }
      v17 = v13 & 0x7FFFFFFFFFFFFFE0LL;
      v18 = (_OWORD *)(v15 + 16);
      v19 = v40;
      v20 = v13 & 0x7FFFFFFFFFFFFFE0LL;
      do
      {
        v21 = *(v19 - 1);
        v22 = *v19;
        v20 -= 32;
        v19 += 2;
        *(v18 - 1) = v21;
        *v18 = v22;
        v18 += 2;
      }
      while ( v20 );
      if ( v13 == v17 )
        goto LABEL_29;
      if ( (v13 & 0x18) != 0 )
      {
LABEL_24:
        v23 = v17;
        v17 = v13 & 0x7FFFFFFFFFFFFFF8LL;
        v24 = &v39[v23];
        v25 = (_QWORD *)(v15 + v23);
        v26 = v23 - (v13 & 0x7FFFFFFFFFFFFFF8LL);
        do
        {
          v27 = *(_QWORD *)v24;
          v24 += 8;
          v26 += 8LL;
          *v25++ = v27;
        }
        while ( v26 );
        if ( v13 == v17 )
          goto LABEL_29;
      }
    }
    v28 = (_BYTE *)(v15 + v17);
    v29 = &v39[v17];
    v30 = v13 - v17;
    do
    {
      v31 = *v29++;
      --v30;
      *v28++ = v31;
    }
    while ( v30 );
  }
LABEL_29:
  if ( v14 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v14, v15, 0);
  v32 = qword_24680;
  if ( qword_24680 )
    goto LABEL_34;
  v33 = qword_24688;
  if ( qword_24688
    || (result = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 48))(a1, "java/lang/String", v16)) != 0
    && (result = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, result),
        v33 = result,
        (qword_24688 = result) != 0) )
  {
    result = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
               a1,
               v33,
               "<init>",
               "([BLjava/lang/String;)V");
    v32 = result;
    qword_24680 = result;
    if ( result )
    {
LABEL_34:
      v34 = qword_24688;
      v35 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64, __int64))(*a1 + 224);
      v36 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 1336))(a1, "ksc-5601", v16);
      result = v35(a1, v34, v32, v14, v36);
    }
  }
  if ( v14 )
  {
    v37 = result;
    (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 184))(a1, v14);
    return v37;
  }
  return result;
}
// DC48: variable 'v16' is possibly undefined
// 24680: using guessed type __int64 qword_24680;
// 24688: using guessed type __int64 qword_24688;

//----- (000000000000DCCC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetMetaDataCharacterSet(__int64 a1, __int64 a2, __int16 a3)
{
  return (unsigned int)(__int16)DRM_GetDCFMetaDataEncodingType(a3);
}

//----- (000000000000DCE8) ----------------------------------------------------
__int64 Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetMIN()
{
  return 0;
}

//----- (000000000000DCF0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMGetClientID(__int64 a1)
{
  unsigned int v3; // [xsp+4h] [xbp-1Ch] BYREF
  _QWORD v4[3]; // [xsp+8h] [xbp-18h] BYREF

  v4[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v4, 0, 11);
  v3 = 10;
  DRM_GetClientID("min", &v3, (__int64)v4);
  printLogD();
  printLogD();
  return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)a1 + 1336LL))(a1, v4);
}

//----- (000000000000DDA0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMSetClientID(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v5; // w20
  __int64 v6; // x0
  __int64 v7; // x19
  __int64 v8; // x22
  int v9; // w0
  int v10; // w23
  int v11; // w0
  __int64 v13; // [xsp+8h] [xbp-18h] BYREF
  int v14; // [xsp+10h] [xbp-10h]
  __int64 v15; // [xsp+18h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v14 = 0;
  v13 = 0;
  if ( a3 )
  {
    v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3);
    printLogD();
    v6 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
    if ( v5 - 12 >= 0xFFFFFFFE )
    {
      v8 = v6;
      v9 = DHstrncpy_s((__int64)&v13, 12, v6, v5);
      if ( v9 )
      {
        v10 = v9;
        printLogD();
        v11 = StrErrorReturn(v10);
      }
      else
      {
        (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, a3, v8);
        printLogD();
        v11 = DRM_SetClientID();
      }
      v7 = v11;
    }
    else
    {
      v7 = -35;
    }
  }
  else
  {
    v7 = -36;
  }
  printLogD();
  return v7;
}

//----- (000000000000DF04) ----------------------------------------------------
void printLogV()
{
  ;
}

//----- (000000000000DF30) ----------------------------------------------------
void printLogI()
{
  ;
}

//----- (000000000000DF5C) ----------------------------------------------------
void printLogW()
{
  ;
}

//----- (000000000000DF88) ----------------------------------------------------
void printLogF()
{
  ;
}

//----- (000000000000DFB4) ----------------------------------------------------
void printLogS()
{
  ;
}

//----- (000000000000DFE0) ----------------------------------------------------
void printLogE()
{
  ;
}

//----- (000000000000E00C) ----------------------------------------------------
void printLogD()
{
  ;
}

//----- (000000000000E038) ----------------------------------------------------
void printLogUNK()
{
  ;
}

//----- (000000000000E064) ----------------------------------------------------
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3)
{
  FILE *result; // x0
  FILE *v7; // x19
  int v8; // w0
  int v9; // w0
  int v10; // w0
  int v11; // w0
  int v12; // w0
  int v13; // w0

  result = fopen("/drmInterface.log", "a");
  if ( result )
  {
    v7 = result;
    v8 = DHstrlen(a1);
    fwrite(a1, 1u, v8, v7);
    v9 = DHstrlen("\t");
    fwrite("\t", 1u, v9, v7);
    v10 = DHstrlen(a2);
    fwrite(a2, 1u, v10, v7);
    v11 = DHstrlen("\t");
    fwrite("\t", 1u, v11, v7);
    v12 = DHstrlen(a3);
    fwrite(a3, 1u, v12, v7);
    v13 = DHstrlen("\n");
    fwrite("\n", 1u, v13, v7);
    return (FILE *)fclose(v7);
  }
  return result;
}

//----- (000000000000E178) ----------------------------------------------------
__int64 DRM_Check_Extend_FilePath()
{
  return 1;
}

//----- (000000000000E180) ----------------------------------------------------
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  __int64 v2; // x8
  const char *v3; // x19
  unsigned int v4; // w19

  pthread_mutex_lock((pthread_mutex_t *)&unk_246B0);
  v2 = *(_QWORD *)(*((_QWORD *)&unk_246B0 + a1 + 75) + 528LL);
  v3 = *(const char **)(v2 + 224);
  if ( v3 )
  {
    if ( strstr(*(const char **)(v2 + 224), "KS_C_5601") )
    {
      v4 = 0;
    }
    else if ( !strcmp(v3, "UTF-8") )
    {
      v4 = 3;
    }
    else
    {
      v4 = -36;
    }
    pthread_mutex_unlock((pthread_mutex_t *)&unk_246B0);
  }
  else
  {
    return 65500;
  }
  return v4;
}

//----- (000000000000E214) ----------------------------------------------------
__int64 DRM_Init()
{
  __int64 result; // x0
  __int128 v1; // q0
  __int128 v2; // q1

  if ( dword_246A0 < 1 )
  {
    dword_246A0 = 1;
    pthread_mutex_init(&stru_246B0, 0);
    pthread_mutex_lock(&stru_246B0);
    DHmemset(&word_246D8, 0, 560);
    *(_QWORD *)&v1 = -1;
    *((_QWORD *)&v1 + 1) = -1;
    *(_QWORD *)&v2 = 0x1000100010001LL;
    *((_QWORD *)&v2 + 1) = 0x1000100010001LL;
    word_246D8 = 0;
    word_248D2 = 1;
    qword_24A90 = 0;
    xmmword_246F8 = v1;
    xmmword_24708 = v1;
    xmmword_24718 = v1;
    xmmword_24728 = v1;
    xmmword_24738 = v1;
    xmmword_24748 = v1;
    xmmword_24758 = v1;
    xmmword_24768 = v1;
    xmmword_24778 = v1;
    xmmword_24788 = v1;
    xmmword_24798 = v1;
    xmmword_247A8 = v1;
    xmmword_247B8 = v1;
    xmmword_247C8 = v1;
    xmmword_247D8 = v1;
    xmmword_246E8 = v1;
    xmmword_247E8 = v1;
    xmmword_247F8 = v1;
    xmmword_24808 = v1;
    xmmword_24818 = v1;
    xmmword_24828 = v1;
    xmmword_24838 = v1;
    xmmword_24848 = v1;
    xmmword_24858 = v1;
    qword_24868 = -1;
    xmmword_24872 = v2;
    xmmword_24882 = v2;
    xmmword_24910 = 0u;
    xmmword_24920 = 0u;
    xmmword_24930 = 0u;
    xmmword_24940 = 0u;
    xmmword_24950 = 0u;
    xmmword_24960 = 0u;
    xmmword_24970 = 0u;
    xmmword_24980 = 0u;
    xmmword_24892 = v2;
    xmmword_248A2 = v2;
    xmmword_24990 = 0u;
    xmmword_249A0 = 0u;
    xmmword_249B0 = 0u;
    xmmword_249C0 = 0u;
    xmmword_249D0 = 0u;
    xmmword_249E0 = 0u;
    xmmword_249F0 = 0u;
    xmmword_24A00 = 0u;
    xmmword_248B2 = v2;
    xmmword_248C2 = v2;
    xmmword_24A10 = 0u;
    xmmword_24A20 = 0u;
    xmmword_24A30 = 0u;
    xmmword_24A40 = 0u;
    xmmword_24A50 = 0u;
    xmmword_24A60 = 0u;
    xmmword_24A70 = 0u;
    xmmword_24A80 = 0u;
    pthread_mutex_unlock(&stru_246B0);
    return 0;
  }
  else
  {
    result = 0;
    ++dword_246A0;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 20: using guessed type __int64;
// 30: using guessed type int;
// 40: using guessed type int dword_40;
// 50: using guessed type int *[4];
// 220: using guessed type __int64;
// 2F8: using guessed type Elf64_Sym;
// 310: using guessed type Elf64_Sym;
// 358: using guessed type Elf64_Sym;
// 370: using guessed type Elf64_Sym;
// 3B8: using guessed type Elf64_Sym;
// 3D0: using guessed type Elf64_Sym;
// 246A0: using guessed type int dword_246A0;
// 246B0: using guessed type pthread_mutex_t stru_246B0;
// 246D8: using guessed type __int16 word_246D8;
// 246E8: using guessed type __int128 xmmword_246E8;
// 246F8: using guessed type __int128 xmmword_246F8;
// 24708: using guessed type __int128 xmmword_24708;
// 24718: using guessed type __int128 xmmword_24718;
// 24728: using guessed type __int128 xmmword_24728;
// 24738: using guessed type __int128 xmmword_24738;
// 24748: using guessed type __int128 xmmword_24748;
// 24758: using guessed type __int128 xmmword_24758;
// 24768: using guessed type __int128 xmmword_24768;
// 24778: using guessed type __int128 xmmword_24778;
// 24788: using guessed type __int128 xmmword_24788;
// 24798: using guessed type __int128 xmmword_24798;
// 247A8: using guessed type __int128 xmmword_247A8;
// 247B8: using guessed type __int128 xmmword_247B8;
// 247C8: using guessed type __int128 xmmword_247C8;
// 247D8: using guessed type __int128 xmmword_247D8;
// 247E8: using guessed type __int128 xmmword_247E8;
// 247F8: using guessed type __int128 xmmword_247F8;
// 24808: using guessed type __int128 xmmword_24808;
// 24818: using guessed type __int128 xmmword_24818;
// 24828: using guessed type __int128 xmmword_24828;
// 24838: using guessed type __int128 xmmword_24838;
// 24848: using guessed type __int128 xmmword_24848;
// 24858: using guessed type __int128 xmmword_24858;
// 24868: using guessed type __int64 qword_24868;
// 24872: using guessed type __int128 xmmword_24872;
// 24882: using guessed type __int128 xmmword_24882;
// 24892: using guessed type __int128 xmmword_24892;
// 248A2: using guessed type __int128 xmmword_248A2;
// 248B2: using guessed type __int128 xmmword_248B2;
// 248C2: using guessed type __int128 xmmword_248C2;
// 248D2: using guessed type __int16 word_248D2;
// 24910: using guessed type __int128 xmmword_24910;
// 24920: using guessed type __int128 xmmword_24920;
// 24930: using guessed type __int128 xmmword_24930;
// 24940: using guessed type __int128 xmmword_24940;
// 24950: using guessed type __int128 xmmword_24950;
// 24960: using guessed type __int128 xmmword_24960;
// 24970: using guessed type __int128 xmmword_24970;
// 24980: using guessed type __int128 xmmword_24980;
// 24990: using guessed type __int128 xmmword_24990;
// 249A0: using guessed type __int128 xmmword_249A0;
// 249B0: using guessed type __int128 xmmword_249B0;
// 249C0: using guessed type __int128 xmmword_249C0;
// 249D0: using guessed type __int128 xmmword_249D0;
// 249E0: using guessed type __int128 xmmword_249E0;
// 249F0: using guessed type __int128 xmmword_249F0;
// 24A00: using guessed type __int128 xmmword_24A00;
// 24A10: using guessed type __int128 xmmword_24A10;
// 24A20: using guessed type __int128 xmmword_24A20;
// 24A30: using guessed type __int128 xmmword_24A30;
// 24A40: using guessed type __int128 xmmword_24A40;
// 24A50: using guessed type __int128 xmmword_24A50;
// 24A60: using guessed type __int128 xmmword_24A60;
// 24A70: using guessed type __int128 xmmword_24A70;
// 24A80: using guessed type __int128 xmmword_24A80;
// 24A90: using guessed type __int64 qword_24A90;

//----- (000000000000E354) ----------------------------------------------------
void DRM_Destroy()
{
  __int64 v0; // x20
  char *v1; // x23
  void **v2; // x0

  if ( !--dword_246A0 )
  {
    pthread_mutex_lock(&stru_246B0);
    v0 = 0;
    word_246D8 = 0;
    dword_246A0 = -1;
    do
    {
      v1 = (char *)&xmmword_24872 + 8 * v0;
      *((_WORD *)&xmmword_24872 + v0) = 32;
      v2 = *(void ***)(v1 + 158);
      *(_QWORD *)(v1 - 394) = -1;
      if ( v2 )
      {
        if ( v2[66] )
        {
          DHfree(v2[66]);
          *(_QWORD *)(*(_QWORD *)(v1 + 158) + 528LL) = 0;
          v2 = *(void ***)(v1 + 158);
        }
        DHfree(v2);
        *(_QWORD *)(v1 + 158) = 0;
      }
      ++v0;
    }
    while ( v0 != 49 );
    pthread_mutex_unlock(&stru_246B0);
    pthread_mutex_destroy(&stru_246B0);
    DHFreeClientID((void *)qword_246A8);
    qword_246A8 = 0;
  }
}
// 246A0: using guessed type int dword_246A0;
// 246A8: using guessed type __int64 qword_246A8;
// 246B0: using guessed type pthread_mutex_t stru_246B0;
// 246D8: using guessed type __int16 word_246D8;
// 24872: using guessed type __int128 xmmword_24872;

//----- (000000000000E438) ----------------------------------------------------
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  unsigned int v6; // w20
  unsigned int v7; // w0
  char *v8; // x26
  int v9; // w22
  void *v10; // x0
  __int64 v11; // x21
  char *v12; // x27
  int v13; // w9
  void *v14; // x0
  __int16 v15; // w0
  _BYTE *v16; // x0
  __int16 v17; // w0
  __int16 v18; // w0
  int v19; // w0
  __int64 v20; // x8
  int v21; // w10
  int v22; // w11
  int v23; // w9
  int v24; // w10
  int v25; // w2
  const void *v26; // x1
  __int16 v27; // w8
  int v29; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v30; // [xsp+8h] [xbp-8h]

  v30 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  pthread_mutex_lock(&stru_246B0);
  if ( word_246D8 == 50 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65510;
  }
  if ( a1 <= 0 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65523;
  }
  v7 = DA_DRA_FilePfdOpen(a1, a2, (__int64)&word_246D8);
  if ( !(v7 << 16) )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 0xFFFF;
  }
  v8 = (char *)&stru_246B0 + 2 * (__int16)v7;
  v9 = (__int16)v7;
  v6 = v7;
  if ( (*((_WORD *)v8 + 224) & 1) == 0 )
  {
    DA_DRA_FileClose((__int16)v7, (__int64)&word_246D8);
    pthread_mutex_unlock(&stru_246B0);
    return 65511;
  }
  v10 = DHmalloc(880);
  if ( !v10 )
  {
LABEL_24:
    DA_DRA_FileClose(v9, (__int64)&word_246D8);
    pthread_mutex_unlock(&stru_246B0);
    return 65514;
  }
  v11 = (__int64)v10;
  DHmemset(v10, 0, 880);
  v12 = (char *)&stru_246B0 + 8 * (__int16)v6;
  *(_QWORD *)v11 = *((_QWORD *)v12 + 6);
  DHmemset((void *)(v11 + 8), 0, 512);
  v13 = *(_DWORD *)(v11 + 524);
  *(_DWORD *)(v11 + 520) = a2;
  *(_DWORD *)(v11 + 588) = 0;
  *(_DWORD *)(v11 + 524) = v13 | a3;
  *(_QWORD *)(v11 + 592) = 0;
  *(_QWORD *)(v11 + 664) = 0;
  *(_DWORD *)(v11 + 672) = 0;
  v14 = DHmalloc(256);
  *(_QWORD *)(v11 + 528) = v14;
  if ( !v14 )
  {
    DHfree((void *)v11);
    goto LABEL_24;
  }
  DHmemset(v14, 0, 256);
  DHmemset((void *)(v11 + 808), 0, 16);
  v15 = DA_DRA_DCFParser(*(FILE **)v11, *(_QWORD *)(v11 + 528), &v29);
  if ( v15 < 0 )
  {
    v6 = v15;
    DA_DRA_DCFDestroy(*(_QWORD **)(v11 + 528));
    DHfree((void *)v11);
    DA_DRA_FileClose(v9, (__int64)&word_246D8);
  }
  else
  {
    v16 = *(_BYTE **)(*(_QWORD *)(v11 + 528) + 128LL);
    *(_DWORD *)(v11 + 832) = 0;
    *(_QWORD *)(v11 + 860) = 0;
    if ( !(unsigned int)DHstrnicmp(v16, "GID", 4) || !*(_QWORD *)(*(_QWORD *)(v11 + 528) + 40LL) )
    {
      v17 = sub_E758(v11);
      if ( v17 )
        *(_DWORD *)(v11 + 864) = v17;
    }
    if ( *(_DWORD *)(v11 + 860) != 1 )
    {
      v18 = ClusterAuthentication(
              *(_BYTE **)(*(_QWORD *)(v11 + 528) + 40LL),
              (__int64 *)(v11 + 824),
              (__int64 *)(v11 + 840),
              (__int64 **)(v11 + 848),
              (_DWORD *)(v11 + 856),
              (void **)&qword_246A8);
      if ( v18 )
        *(_DWORD *)(v11 + 864) = v18;
    }
    v19 = DHfsTell();
    v20 = *(_QWORD *)(v11 + 528);
    *(_DWORD *)(v11 + 600) = v19;
    v21 = *(_DWORD *)(v20 + 80);
    v22 = *(_DWORD *)(v20 + 36);
    *(_QWORD *)(v11 + 628) = 0;
    *(_DWORD *)(v11 + 604) = 0;
    *(_QWORD *)(v11 + 608) = 0;
    if ( v21 )
      v23 = v21;
    else
      v23 = v22;
    *(_DWORD *)(v11 + 616) = v22;
    v24 = v29;
    *(_DWORD *)(v11 + 624) = v23;
    *(_DWORD *)(v11 + 620) = v23;
    v25 = *(_DWORD *)(v20 + 8);
    v26 = *(const void **)(v20 + 24);
    *(_DWORD *)(v11 + 676) = v24;
    *(_DWORD *)(v11 + 636) = v25;
    DHmemcpy((void *)(v11 + 640), v26, v25);
    v27 = word_246D8;
    *((_QWORD *)v12 + 75) = v11;
    *(_QWORD *)(v11 + 872) = 0;
    *(_DWORD *)(v11 + 868) = -1;
    word_246D8 = v27 + 1;
    *((_WORD *)v8 + 224) |= 3u;
  }
  pthread_mutex_unlock(&stru_246B0);
  return v6;
}
// 246A8: using guessed type __int64 qword_246A8;
// 246B0: using guessed type pthread_mutex_t stru_246B0;
// 246D8: using guessed type __int16 word_246D8;

//----- (000000000000E758) ----------------------------------------------------
__int64 __fastcall sub_E758(__int64 a1)
{
  unsigned int v2; // w3
  __int64 result; // x0
  unsigned int v4; // [xsp+Ch] [xbp-44h] BYREF
  _BYTE v5[51]; // [xsp+10h] [xbp-40h] BYREF
  __int64 v6; // [xsp+48h] [xbp-8h]

  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  *(_DWORD *)(a1 + 860) = 1;
  v4 = 50;
  memset(v5, 0, sizeof(v5));
  if ( !qword_246A8 )
    qword_246A8 = (__int64)DHmalloc(14);
  if ( (int)DHGetClientID_BySetVal(
              *(const char **)(*(_QWORD *)(a1 + 528) + 128LL),
              &v4,
              (__int64)v5,
              (__int16 **)&qword_246A8) <= 0 )
  {
    DHFreeClientID((void *)qword_246A8);
    qword_246A8 = 0;
    return 65436;
  }
  else
  {
    v2 = v4;
    *(_DWORD *)(a1 + 832) = 1;
    DHstrncpy_s(a1 + 536, 51, (__int64)v5, v2);
    result = 0;
    *(_DWORD *)(a1 + 636) = v4;
  }
  return result;
}
// 246A8: using guessed type __int64 qword_246A8;

//----- (000000000000E83C) ----------------------------------------------------
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3)
{
  unsigned int v6; // w20
  unsigned int v7; // w0
  char *v8; // x27
  int v9; // w22
  void *v10; // x0
  __int64 v11; // x21
  char *v12; // x28
  int v13; // w0
  int v14; // w9
  void *v15; // x0
  __int16 v16; // w0
  _BYTE *v17; // x0
  __int16 v18; // w0
  __int16 v19; // w0
  int v20; // w0
  __int64 v21; // x8
  int v22; // w10
  int v23; // w11
  int v24; // w9
  int v25; // w10
  int v26; // w2
  const void *v27; // x1
  __int16 v28; // w8
  int v30; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v31; // [xsp+8h] [xbp-8h]

  v31 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  pthread_mutex_lock(&stru_246B0);
  if ( word_246D8[0] == 50 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65510;
  }
  if ( !a1 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65523;
  }
  DHstrlen(a1);
  v7 = DA_DRA_FileOpen(a1, a2, (__int64)word_246D8);
  if ( !(v7 << 16) )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 0xFFFF;
  }
  v8 = (char *)&stru_246B0 + 2 * (__int16)v7;
  v9 = (__int16)v7;
  v6 = v7;
  if ( (*((_WORD *)v8 + 224) & 1) == 0 )
  {
    DA_DRA_FileClose((__int16)v7, (__int64)word_246D8);
    pthread_mutex_unlock(&stru_246B0);
    return 65511;
  }
  v10 = DHmalloc(880);
  if ( !v10 )
  {
LABEL_24:
    DA_DRA_FileClose(v9, (__int64)word_246D8);
    pthread_mutex_unlock(&stru_246B0);
    return 65514;
  }
  v11 = (__int64)v10;
  DHmemset(v10, 0, 880);
  v12 = (char *)&stru_246B0 + 8 * (__int16)v6;
  *(_QWORD *)v11 = *((_QWORD *)v12 + 6);
  DHmemset((void *)(v11 + 8), 0, 512);
  v13 = DHstrlen(a1);
  DHmemcpy((void *)(v11 + 8), a1, v13);
  v14 = *(_DWORD *)(v11 + 524);
  *(_DWORD *)(v11 + 520) = a2;
  *(_DWORD *)(v11 + 588) = 0;
  *(_DWORD *)(v11 + 524) = v14 | a3;
  *(_QWORD *)(v11 + 592) = 0;
  *(_QWORD *)(v11 + 664) = 0;
  *(_DWORD *)(v11 + 672) = 0;
  v15 = DHmalloc(256);
  *(_QWORD *)(v11 + 528) = v15;
  if ( !v15 )
  {
    DHfree((void *)v11);
    goto LABEL_24;
  }
  DHmemset(v15, 0, 256);
  DHmemset((void *)(v11 + 808), 0, 16);
  v16 = DA_DRA_DCFParser(*(FILE **)v11, *(_QWORD *)(v11 + 528), &v30);
  if ( v16 < 0 )
  {
    v6 = v16;
    DA_DRA_DCFDestroy(*(_QWORD **)(v11 + 528));
    DHfree((void *)v11);
    DA_DRA_FileClose(v9, (__int64)word_246D8);
  }
  else
  {
    v17 = *(_BYTE **)(*(_QWORD *)(v11 + 528) + 128LL);
    *(_DWORD *)(v11 + 832) = 0;
    *(_QWORD *)(v11 + 860) = 0;
    if ( !(unsigned int)DHstrnicmp(v17, "GID", 4) || !*(_QWORD *)(*(_QWORD *)(v11 + 528) + 40LL) )
    {
      v18 = sub_E758(v11);
      if ( v18 )
        *(_DWORD *)(v11 + 864) = v18;
    }
    if ( *(_DWORD *)(v11 + 860) != 1 )
    {
      v19 = ClusterAuthentication(
              *(_BYTE **)(*(_QWORD *)(v11 + 528) + 40LL),
              (__int64 *)(v11 + 824),
              (__int64 *)(v11 + 840),
              (__int64 **)(v11 + 848),
              (_DWORD *)(v11 + 856),
              (void **)&qword_246A8);
      if ( v19 )
        *(_DWORD *)(v11 + 864) = v19;
    }
    v20 = DHfsTell();
    v21 = *(_QWORD *)(v11 + 528);
    *(_DWORD *)(v11 + 600) = v20;
    v22 = *(_DWORD *)(v21 + 80);
    v23 = *(_DWORD *)(v21 + 36);
    *(_QWORD *)(v11 + 628) = 0;
    *(_DWORD *)(v11 + 604) = 0;
    *(_QWORD *)(v11 + 608) = 0;
    if ( v22 )
      v24 = v22;
    else
      v24 = v23;
    *(_DWORD *)(v11 + 616) = v23;
    v25 = v30;
    *(_DWORD *)(v11 + 624) = v24;
    *(_DWORD *)(v11 + 620) = v24;
    v26 = *(_DWORD *)(v21 + 8);
    v27 = *(const void **)(v21 + 24);
    *(_DWORD *)(v11 + 676) = v25;
    *(_DWORD *)(v11 + 636) = v26;
    DHmemcpy((void *)(v11 + 640), v27, v26);
    v28 = word_246D8[0];
    *((_QWORD *)v12 + 75) = v11;
    *(_QWORD *)(v11 + 872) = 0;
    *(_DWORD *)(v11 + 868) = -1;
    word_246D8[0] = v28 + 1;
    *((_WORD *)v8 + 224) |= 3u;
  }
  pthread_mutex_unlock(&stru_246B0);
  return v6;
}
// 246A8: using guessed type __int64 qword_246A8;
// 246B0: using guessed type pthread_mutex_t stru_246B0;
// 246D8: using guessed type __int16 word_246D8[8];

//----- (000000000000EB78) ----------------------------------------------------
__int64 __fastcall DRM_Close(unsigned __int16 a1)
{
  int v2; // w21
  char *v3; // x22
  _QWORD *v4; // x22
  __int64 v5; // t1
  char *v6; // x21
  __int64 v7; // x19
  void *v8; // x0
  void *v9; // x0
  __int64 v10; // x0
  _QWORD *v11; // x21
  unsigned int v12; // w19
  __int16 v13; // w8

  v2 = a1;
  pthread_mutex_lock(&stru_246B0);
  if ( v2 && (v3 = (char *)&stru_246B0 + 8 * (__int16)a1, v5 = *((_QWORD *)v3 + 6), v4 = v3 + 48, v5 >= 1) )
  {
    v6 = (char *)&stru_246B0 + 8 * (__int16)a1;
    v7 = *((_QWORD *)v6 + 75);
    DA_DRA_DCFDestroy(*(_QWORD **)(v7 + 528));
    v8 = *(void **)(v7 + 872);
    if ( v8 )
      DHfree(v8);
    ClientIDDestroy(*(_QWORD **)(v7 + 824));
    v9 = *(void **)(v7 + 840);
    if ( v9 )
      DHfree(v9);
    v10 = *(_QWORD *)(v7 + 848);
    v11 = v6 + 600;
    if ( v10 )
      DomainListDestroy(v10);
    DHfree((void *)v7);
    *v11 = 0;
    DA_DRA_FileClose((__int16)a1, (__int64)word_246D8);
    v12 = 0;
    v13 = word_246D8[0] - 1;
    *v4 = -1;
    word_246D8[0] = v13;
    word_246D8[(__int16)a1 + 204] = word_246D8[(__int16)a1 + 204] & 0xFFED | 0x10;
  }
  else
  {
    v12 = 65533;
  }
  pthread_mutex_unlock(&stru_246B0);
  return v12;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;
// 246D8: using guessed type __int16 word_246D8[8];

//----- (000000000000EC78) ----------------------------------------------------
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, int a3)
{
  int v4; // w23
  char *v7; // x27
  __int64 v8; // x8
  char *v9; // x25
  int v10; // w9
  __int64 v11; // x21
  int v12; // w8
  FILE **v13; // x27
  int v14; // w22
  int v15; // w23
  __int64 v16; // x24
  int v17; // w0
  int v18; // w11
  int v19; // w25
  int v20; // w12
  int v21; // w28
  int v22; // w8
  int v23; // w2
  int v24; // w21
  int v25; // w0
  signed int v26; // w8
  int v27; // w10
  __int64 v28; // x11
  _BYTE *v29; // x12
  int v30; // w9
  _BYTE *v32; // x14
  char v33; // w13
  unsigned int v34; // w14
  __int16 v35; // w0
  __int64 v36; // x8
  unsigned int v37; // w19
  FILE **v38; // x27
  int v39; // w0
  int v40; // w8
  int v41; // w21
  int v42; // w28
  int v43; // w23
  int8x16_t *v44; // x0
  int8x16_t *v45; // x22
  int v46; // w0
  int v47; // w21
  int v48; // w9
  int v49; // w20
  char *v50; // x19
  int v51; // w10
  int v52; // w11
  int v53; // w2
  int v54; // w0
  signed int v55; // w9
  int v56; // w11
  int v57; // w8
  __int64 v58; // x12
  int v59; // w0
  int v60; // w10
  _BYTE *v61; // x14
  char v62; // w13
  unsigned int v63; // w14
  int v64; // w24
  int v65; // w8
  int v66; // w28
  __int64 v67; // x8
  int8x16_t *v68; // x25
  int v69; // w8
  int v70; // w8
  int v71; // [xsp+8h] [xbp-138h]
  int v72; // [xsp+8h] [xbp-138h]
  int v73; // [xsp+Ch] [xbp-134h]
  int v74; // [xsp+Ch] [xbp-134h]
  unsigned int v75; // [xsp+Ch] [xbp-134h]
  int *v76; // [xsp+10h] [xbp-130h] BYREF
  char v77[16]; // [xsp+18h] [xbp-128h] BYREF
  _DWORD v78[61]; // [xsp+28h] [xbp-118h] BYREF
  __int128 v79; // [xsp+11Fh] [xbp-21h] BYREF
  char v80; // [xsp+12Fh] [xbp-11h]
  __int64 v81; // [xsp+130h] [xbp-10h]

  v4 = (unsigned __int16)a1;
  v81 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v76 = 0;
  pthread_mutex_lock(&stru_246B0);
  if ( !v4 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 4294967293LL;
  }
  if ( (~*((unsigned __int16 *)&stru_246B0 + (__int16)a1 + 224) & 3) != 0 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 4294967271LL;
  }
  v7 = (char *)&stru_246B0 + 8 * (__int16)a1;
  v8 = *((_QWORD *)v7 + 75);
  v9 = v7 + 600;
  v10 = *(_DWORD *)(v8 + 868);
  if ( v10 == -1 )
  {
    v35 = sub_F154(a1, &v76);
    v36 = *(_QWORD *)v9;
    if ( v35 )
    {
      *(_QWORD *)(v36 + 872) = 0;
      v37 = v35;
      *(_DWORD *)(*(_QWORD *)v9 + 868LL) = 0;
      pthread_mutex_unlock(&stru_246B0);
      return v37;
    }
    *(_QWORD *)(v36 + 872) = v76;
    *(_DWORD *)(*(_QWORD *)v9 + 868LL) = 1;
    sub_F710(a1);
    v8 = *(_QWORD *)v9;
    if ( *(_DWORD *)(*(_QWORD *)v9 + 868LL) != 1 )
      goto LABEL_30;
  }
  else if ( v10 != 1 )
  {
    goto LABEL_30;
  }
  v11 = *(_QWORD *)(v8 + 872);
  v12 = *(unsigned __int16 *)(v11 + 16);
  if ( (unsigned int)(v12 - 4096) >= 2 )
  {
    if ( v12 == 1 )
    {
      v38 = (FILE **)(v7 + 48);
      v39 = DHfsTell();
      v40 = *(_DWORD *)(v11 + 4);
      v41 = v39;
      v42 = (v41 - v40 - 16) & ~((v41 - v40 - 16) >> 31);
      if ( (DHfsSeek(*v38, (v42 & 0x7FFFFFF0u) + v40, 3) & 0x80000000) != 0
        || (v43 = a3 + 49, (v44 = (int8x16_t *)DHmalloc(a3 + 49)) == 0) )
      {
        a3 = -1;
      }
      else
      {
        v45 = v44;
        v46 = DHfsRead(*v38, v44, v43);
        if ( v46 > 15 )
        {
          v64 = v46;
          v65 = v42 & 0xF;
          if ( v46 >= v43 )
            v66 = v46 - 1;
          else
            v66 = v46;
          v72 = v46 - 1;
          v75 = v65;
          DHmemcpy(&v79, v45, 16);
          v67 = *(_QWORD *)v9;
          v80 = 0;
          v68 = v45 + 1;
          DHmemcpy(v77, (const void *)(v67 + 680), 16);
          AES_set_decrypt_key();
          AES_cbc_encrypt((int8x16_t *)v45[1].n128_u64, v45 + 1, v66 - 16, (__int64)v78, &v79, 0);
          v69 = v72;
          if ( v64 < v43 )
            v69 = v64 - *((unsigned __int8 *)&v68[-1] + (unsigned int)v64 - 1);
          v70 = v69 - v75 - 16;
          if ( v70 < a3 )
            a3 = v70;
          DHmemcpy(a2, (char *)v68 + v75, a3);
          DHfree(v45);
          DHfsSeek(*v38, a3 + v41, 3);
        }
        else
        {
          DHfree(v45);
          a3 = -1;
        }
      }
      goto LABEL_47;
    }
LABEL_30:
    pthread_mutex_unlock(&stru_246B0);
    return 4294967288LL;
  }
  v13 = (FILE **)(v7 + 48);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_DWORD *)(v11 + 32);
  v16 = *(_QWORD *)(v11 + 48);
  v17 = DHfsTell();
  v18 = *(_DWORD *)(v11 + 8);
  v19 = *(_DWORD *)(v11 + 24);
  v20 = *(unsigned __int8 *)(v11 + 28);
  v21 = v17 - *(_DWORD *)(v11 + 4);
  if ( *(_WORD *)(v11 + 16) == 4097 )
  {
    v22 = 0;
    if ( *(_WORD *)(v11 + 18) == 1 && v19 - v20 > v21 )
    {
      if ( v19 - v20 - v21 >= a3 )
        v23 = a3;
      else
        v23 = v19 - v20 - v21;
      v71 = *(_DWORD *)(v11 + 8);
      v73 = v19 - v20;
      v24 = *(unsigned __int8 *)(v11 + 28);
      v25 = DHfsRead(*v13, a2, v23);
      v26 = v21 / v15;
      v78[0] = bswap32(v21 / v15);
      if ( v25 >= 1 )
      {
        v27 = v21 % v15;
        v28 = (unsigned int)v25;
        v29 = a2;
        v30 = v26 % v14;
        do
        {
          v32 = (_BYTE *)((unsigned __int64)v78 | v27 & 3);
          v33 = *(_BYTE *)(v16 + v30 + v27++);
          *v29 ^= v33 ^ *v32;
          if ( v27 >= v15 )
          {
            ++v26;
            v27 = 0;
            v34 = bswap32(v26);
            if ( v30 + 1 < v14 )
              ++v30;
            else
              v30 = 0;
            v78[0] = v34;
          }
          --v28;
          ++v29;
        }
        while ( v28 );
        v21 += v25;
      }
      if ( v21 < v73 )
        goto LABEL_46;
      v74 = v25;
      if ( (DHfsSeek(*v13, v24, 1) & 0x80000000) != 0 )
      {
        a3 = v74;
        goto LABEL_47;
      }
      v18 = v71;
      v22 = v74;
      v21 += v24;
      v20 = v24;
    }
  }
  else
  {
    v22 = 0;
  }
  v47 = v21 - v19;
  v48 = a3 - v22;
  v49 = v22;
  v50 = &a2[v22];
  v51 = v20 - v19 + v18;
  v52 = v20 + v18 - v21;
  if ( v21 - v19 + v48 >= v51 )
    v53 = v52;
  else
    v53 = v48;
  v54 = DHfsRead(*v13, v50, v53);
  v55 = v47 / v15;
  v78[0] = bswap32(v47 / v15);
  if ( v54 < 1 )
  {
    v57 = 0;
    v59 = v49;
  }
  else
  {
    v56 = v47 % v15;
    v57 = v54;
    v58 = (unsigned int)v54;
    v59 = v49;
    v60 = v55 % v14;
    do
    {
      v61 = (_BYTE *)((unsigned __int64)v78 | v56 & 3);
      v62 = *(_BYTE *)(v16 + v60 + v56++);
      *v50 ^= v62 ^ *v61;
      if ( v56 >= v15 )
      {
        ++v55;
        v56 = 0;
        v63 = bswap32(v55);
        if ( v60 + 1 < v14 )
          ++v60;
        else
          v60 = 0;
        v78[0] = v63;
      }
      --v58;
      ++v50;
    }
    while ( v58 );
  }
  v25 = v57 + v59;
LABEL_46:
  a3 = v25;
LABEL_47:
  pthread_mutex_unlock(&stru_246B0);
  return (unsigned int)a3;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (000000000000F154) ----------------------------------------------------
__int64 __fastcall sub_F154(__int16 a1, int **a2)
{
  char *v3; // x21
  __int64 v4; // x20
  __int64 result; // x0
  int32x2_t **v6; // x25
  __int16 ClientID; // w0
  __int16 v8; // w0
  __int64 v9; // x8
  int32x2_t *v10; // x0
  int32x2_t *v11; // x22
  int32x2_t *v12; // x20
  int32x2_t *v13; // x8
  int32x2_t *v14; // x21
  unsigned __int64 v15; // x27
  _BYTE *v16; // x0
  __int16 v17; // w8
  _BYTE *v18; // x0
  _BYTE *v19; // x0
  __int16 v20; // w0
  unsigned int v21; // w0
  unsigned int v22; // w19
  unsigned __int64 v23; // x8
  __int16 SSEBaseStream; // w0
  _BYTE *v25; // x0
  int v26; // w19
  int *v27; // x0
  int *v28; // x21
  unsigned __int32 v29; // w9
  unsigned __int32 v30; // w10
  unsigned __int32 v31; // w8
  const void *v32; // x1
  const char *v33; // x0
  unsigned __int32 v34; // w8
  __int16 v35; // w9
  __int64 v36; // x24
  __int64 i; // x8
  int v38; // w9
  unsigned __int8 *v39; // x28
  int j; // w8
  __int64 *v41; // x24
  int k; // w8
  __int64 *v43; // x24
  int v44; // w8
  unsigned __int8 *v45; // x28
  int v46; // t1
  int v47; // t1
  unsigned __int32 v48; // w0
  int v49; // w8
  char *v50; // x22
  FILE **v51; // x22
  FILE *v52; // t1
  unsigned int v53; // w21
  unsigned int v54; // w8
  unsigned int v55; // w10
  unsigned __int8 v56; // w9
  const char *v57; // x0
  int v59; // [xsp+14h] [xbp-5Ch] BYREF
  unsigned __int8 ptr[4]; // [xsp+18h] [xbp-58h] BYREF
  unsigned int v61; // [xsp+1Ch] [xbp-54h] BYREF
  _BYTE v62[51]; // [xsp+20h] [xbp-50h] BYREF
  __int64 v63; // [xsp+58h] [xbp-18h] BYREF
  __int16 v64; // [xsp+60h] [xbp-10h]
  __int64 v65; // [xsp+68h] [xbp-8h]

  v65 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v61 = 0;
  v64 = 0;
  v63 = 0;
  memset(v62, 0, sizeof(v62));
  if ( !a1 )
    return 65533;
  if ( (~*((unsigned __int16 *)&stru_246B0 + a1 + 224) & 3) != 0 )
    return 65511;
  v3 = (char *)&stru_246B0 + 8 * a1;
  v4 = *((_QWORD *)v3 + 75);
  result = *(unsigned int *)(v4 + 864);
  if ( !(_DWORD)result )
  {
    if ( *(_DWORD *)(v4 + 860) != 1
      && (unsigned __int16)checkDomain(
                             *(_BYTE **)(v4 + 840),
                             *(_QWORD *)(v4 + 848),
                             *(char **)(*(_QWORD *)(v4 + 528) + 24LL)) != 1 )
    {
      return 65502;
    }
    v6 = (int32x2_t **)(v3 + 600);
    v59 = 51;
    ClientID = GetClientID(a1, (__int64)v62, &v59, (__int64)&stru_246B0);
    if ( ClientID )
    {
      result = (unsigned int)ClientID;
      if ( (result & 0x80000000) != 0 )
        return result;
    }
    else
    {
      v8 = compute_eTarget(
             *(const char **)((*v6)[66].n64_u64[0] + 128),
             v62,
             *(_BYTE **)((*v6)[66].n64_u64[0] + 136),
             *(const char **)((*v6)[66].n64_u64[0] + 24));
      if ( v8 < 0 )
        return (unsigned int)v8;
    }
    v9 = *(_QWORD *)(v4 + 528);
    if ( !*(_DWORD *)(v9 + 184) || *(_DWORD *)(v9 + 216) == 1 || (result = sub_101A4(a1), !(_WORD)result) )
    {
      v10 = (int32x2_t *)DHmalloc(56);
      if ( !v10 )
        return 65514;
      v10->n64_u64[0] = 0;
      v10[1].n64_u64[0] = 0;
      v10[4].n64_u64[0] = 0;
      v11 = v10 + 4;
      v12 = v10;
      v10[2].n64_u32[0] = 0;
      v10[5].n64_u64[0] = 0;
      v10[6].n64_u64[0] = 0;
      v13 = *v6;
      v10[3].n64_u32[0] = 0;
      v14 = v10 + 3;
      v10[3].n64_u8[4] = 0;
      v15 = v13[66].n64_u64[0];
      v10->n64_u32[1] = v13[75].n64_u32[0];
      v16 = *(_BYTE **)(v15 + 72);
      v12[1].n64_u64[0] = vrev64_s32(v13[77]).n64_u64[0];
      v17 = v16 && !(unsigned int)DHstrnicmp(v16, "RFC2630", 7);
      v18 = *(_BYTE **)(v15 + 64);
      v12[2].n64_u16[1] = v17;
      if ( v18 )
      {
        if ( (unsigned int)DHstrnicmp(v18, "aes128cbc", 9) )
        {
          v19 = *(_BYTE **)(v15 + 64);
          if ( !v19 || (unsigned int)DHstrnicmp(v19, "sse", 3) )
          {
            v12[2].n64_u16[0] = 0;
LABEL_29:
            sub_10908((void **)v12);
            return 65504;
          }
          v33 = *(const char **)(v15 + 64);
          if ( !v33 )
            goto LABEL_29;
          if ( DHstristr(v33, "Combined") )
          {
            v34 = 0;
            v35 = 4096;
          }
          else
          {
            v57 = *(const char **)(v15 + 64);
            if ( !v57 || !DHstristr(v57, "Separate") )
              goto LABEL_29;
            v34 = *(_DWORD *)(v15 + 84);
            v35 = 4097;
          }
          v36 = *(_QWORD *)(v15 + 64);
          v12[2].n64_u16[0] = v35;
          v14->n64_u32[0] = v34;
          DHmemset(&v63, 0, 10);
          for ( i = 0; ; ++i )
          {
            v38 = *(unsigned __int8 *)(v36 + i + 3);
            if ( !*(_BYTE *)(v36 + i + 3) || v38 == 45 )
              break;
            *((_BYTE *)&v63 + i) = v38;
          }
          v39 = (unsigned __int8 *)(v36 + i + 5);
          v12[4].n64_u32[1] = DHatoi();
          for ( j = *(v39 - 2); *(v39 - 2); j = *(++v39 - 2) )
          {
            if ( j == 47 )
              break;
          }
          v41 = &v63;
          DHmemset(&v63, 0, 10);
          for ( k = *(v39 - 1); *(v39 - 1); k = *v39++ )
          {
            if ( k == 45 )
              break;
            *(_BYTE *)v41 = k;
            v41 = (__int64 *)((char *)v41 + 1);
          }
          v43 = &v63;
          v11->n64_u32[0] = DHatoi();
          DHmemset(&v63, 0, 10);
          v46 = *v39;
          v45 = v39 + 1;
          v44 = v46;
          if ( v46 )
          {
            do
            {
              if ( v44 == 59 )
                break;
              *(_BYTE *)v43 = v44;
              v43 = (__int64 *)((char *)v43 + 1);
              v47 = *v45++;
              v44 = v47;
            }
            while ( v47 );
          }
          v48 = DHatoi();
          v49 = v12[2].n64_u16[1];
          v12[5].n64_u32[0] = v48;
          if ( v49 == 1 && v11->n64_u32[0] >= 0x100 )
            goto LABEL_29;
          SSEBaseStream = get_SSEBaseStream(
                            a1,
                            *(const char **)(v15 + 24),
                            *(_DWORD *)(v15 + 8),
                            *(const char **)(v15 + 128),
                            (__int64)v14,
                            (__int64)&stru_246B0);
          if ( SSEBaseStream < 0 )
            goto LABEL_67;
          if ( v12[2].n64_u16[0] == 4097 && v12[2].n64_u16[1] == 1 )
          {
            v50 = (char *)&stru_246B0 + 8 * a1;
            v52 = (FILE *)*((_QWORD *)v50 + 6);
            v51 = (FILE **)(v50 + 48);
            v53 = v14->n64_u32[0] - 1;
            if ( DHfsSeek(v52, (*v6)[75].n64_u32[0] + v53, 3) < 0
              || (int)DHfsRead(*v51, ptr, 1) <= 0
              || (v54 = v12[4].n64_u32[0],
                  v55 = v53 / v54 % v12[5].n64_u32[0],
                  v61 = bswap32(v53 / v54),
                  v56 = *(_BYTE *)(v12[6].n64_u64[0] + (int)(v55 + v53 % v54))
                      ^ ptr[0]
                      ^ *(_BYTE *)((unsigned __int64)&v61 | (v53 % v54) & 3LL),
                  ptr[0] = v56,
                  v12[3].n64_u8[4] = v56,
                  v54 < v56) )
            {
              sub_10908((void **)v12);
              return 65528;
            }
          }
        }
        else
        {
          v12[2].n64_u16[0] = 1;
          v20 = sub_1078C(a1);
          if ( v20 < 0 )
          {
            v22 = v20;
            v12[2].n64_u16[0] = 0;
            goto LABEL_68;
          }
        }
      }
      else
      {
        v12[2].n64_u16[0] = 0;
      }
      v21 = compute_eServiceCode(
              a1,
              *(const char **)((*v6)[66].n64_u64[0] + 24),
              *(_BYTE **)((*v6)[66].n64_u64[0] + 56),
              *(const char **)((*v6)[66].n64_u64[0] + 40),
              *(const char **)((*v6)[66].n64_u64[0] + 48),
              (__int64)&stru_246B0);
      if ( (_WORD)v21 )
      {
        v22 = v21;
LABEL_68:
        sub_10908((void **)v12);
        return v22;
      }
      v23 = (*v6)[66].n64_u64[0];
      SSEBaseStream = compute_eAuthCode(
                        a1,
                        *(const char **)(v23 + 200),
                        *(char **)(v23 + 176),
                        *(const char **)(v23 + 192),
                        *(unsigned __int8 **)(v23 + 208),
                        *(char **)(v23 + 24),
                        v12[2].n64_i16[0],
                        (__int64)&stru_246B0);
      if ( (SSEBaseStream & 0x8000) == 0 )
      {
        if ( !v12[6].n64_u64[0] )
        {
          v25 = DHmalloc(1);
          v12[6].n64_u64[0] = (unsigned __int64)v25;
          if ( !v25 )
          {
LABEL_48:
            sub_10908((void **)v12);
            return 65514;
          }
          *v25 = 0;
        }
        v26 = v12[4].n64_u32[1] + v12[4].n64_u32[0] + 57;
        v27 = (int *)DHmalloc(v26);
        if ( v27 )
        {
          v28 = v27;
          DHmemcpy(v27, v12, 56);
          v30 = v12[4].n64_u32[0];
          v29 = v12[4].n64_u32[1];
          v31 = v12[3].n64_u32[0];
          *v28 = v26;
          v32 = (const void *)v12[6].n64_u64[0];
          v28[6] = v31;
          DHmemcpy(v28 + 14, v32, v29 + v30 + 1);
          *((_QWORD *)v28 + 6) = (char *)v28 + (unsigned int)v28[11] + 56;
          sub_10908((void **)v12);
          result = 0;
          *a2 = v28;
          return result;
        }
        goto LABEL_48;
      }
LABEL_67:
      v22 = SSEBaseStream;
      goto LABEL_68;
    }
  }
  return result;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (000000000000F710) ----------------------------------------------------
__int64 __fastcall sub_F710(__int64 result)
{
  unsigned int v1; // w19
  char *v2; // x21
  __int64 v3; // x8
  int v4; // w9
  __int64 v5; // x22
  int v6; // w8
  int v7; // w0
  int v8; // w8
  int v9; // w23
  int v10; // w19
  int v11; // w24
  int v12; // w9
  int v13; // w8
  int v14; // w9
  int v15; // w8
  char *v16; // x22
  __int64 v17; // x8
  int *v18[2]; // [xsp+0h] [xbp-10h] BYREF

  v18[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v18[0] = 0;
  if ( !(_WORD)result )
    return result;
  v1 = result;
  if ( (~*((unsigned __int16 *)&stru_246B0 + (__int16)result + 224) & 3) != 0 )
    return result;
  v2 = (char *)&stru_246B0 + 8 * (__int16)result;
  v3 = *((_QWORD *)v2 + 75);
  v4 = *(_DWORD *)(v3 + 868);
  if ( v4 == -1 )
  {
    v16 = v2 + 600;
    result = sub_F154(result, v18);
    v17 = *((_QWORD *)v2 + 75);
    if ( (_WORD)result )
    {
      *(_QWORD *)(v17 + 872) = 0;
      *(_DWORD *)(*(_QWORD *)v16 + 868LL) = 0;
      return result;
    }
    *(int **)(v17 + 872) = v18[0];
    *(_DWORD *)(*(_QWORD *)v16 + 868LL) = 1;
    result = sub_F710(v1);
    v3 = *(_QWORD *)v16;
    if ( *(_DWORD *)(*(_QWORD *)v16 + 868LL) != 1 )
      return result;
  }
  else if ( v4 != 1 )
  {
    return result;
  }
  v5 = *(_QWORD *)(v3 + 872);
  v6 = *(unsigned __int16 *)(v5 + 16);
  if ( (unsigned int)(v6 - 4096) >= 2 )
  {
    if ( v6 != 1 )
      return result;
    v10 = DHfsTell();
    result = DHfsSeek(*((FILE **)v2 + 6), *(_DWORD *)(v5 + 4) + 16, 3);
    v15 = result - *(_DWORD *)(v5 + 4) - 16;
  }
  else
  {
    v7 = DHfsTell();
    v8 = *(_DWORD *)(v5 + 24);
    v9 = *(unsigned __int8 *)(v5 + 28);
    v10 = v7;
    v11 = v8 - v9;
    if ( v8 <= v9 )
      v12 = *(unsigned __int8 *)(v5 + 28);
    else
      v12 = 0;
    result = DHfsSeek(*((FILE **)v2 + 6), v12 + *(_DWORD *)(v5 + 4), 3);
    v13 = result - *(_DWORD *)(v5 + 4);
    if ( v13 >= v11 )
      v14 = v9;
    else
      v14 = 0;
    v15 = v13 - v14;
  }
  if ( v15 > *(_DWORD *)(v5 + 8) || v15 < 0 )
    return DHfsSeek(*((FILE **)v2 + 6), v10, 3);
  return result;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (000000000000F8DC) ----------------------------------------------------
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  int v4; // w24
  char *v7; // x22
  __int64 v8; // x8
  int v9; // w9
  __int64 v10; // x24
  int v11; // w8
  FILE **v12; // x27
  int v13; // w0
  int v14; // w25
  int v15; // w8
  int v16; // w20
  int v17; // w26
  int v18; // w8
  FILE *v19; // x0
  int v20; // w2
  int v21; // w9
  int v22; // w8
  bool v23; // cc
  int v24; // w8
  int v25; // w9
  _BOOL4 v26; // w8
  int v27; // w10
  int v28; // w8
  int v29; // w8
  int v30; // w1
  int v31; // w19
  char *v32; // x24
  __int16 v33; // w0
  __int64 v34; // x8
  FILE **v35; // x25
  int v36; // w0
  int v37; // w8
  FILE *v38; // x0
  int v39; // w1
  int v40; // w2
  int v42; // w9
  int v43; // w8
  int v44; // w10
  int v45; // w8
  int v46; // w9
  int v47; // w8
  int v48; // w9
  int v49; // w8
  int *v50[2]; // [xsp+0h] [xbp-10h] BYREF

  v4 = (unsigned __int16)a1;
  v50[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v50[0] = 0;
  pthread_mutex_lock(&stru_246B0);
  if ( !v4 )
  {
    v31 = -3;
    goto LABEL_35;
  }
  if ( (~*((unsigned __int16 *)&stru_246B0 + (__int16)a1 + 224) & 3) != 0 )
    goto LABEL_34;
  v7 = (char *)&stru_246B0 + 8 * (__int16)a1;
  v8 = *((_QWORD *)v7 + 75);
  v9 = *(_DWORD *)(v8 + 868);
  if ( v9 != -1 )
  {
    if ( v9 == 1 )
      goto LABEL_5;
LABEL_34:
    v31 = -25;
    goto LABEL_35;
  }
  v32 = v7 + 600;
  v33 = sub_F154(a1, v50);
  v34 = *((_QWORD *)v7 + 75);
  if ( v33 )
  {
    *(_QWORD *)(v34 + 872) = 0;
    v31 = v33;
    *(_DWORD *)(*(_QWORD *)v32 + 868LL) = 0;
    goto LABEL_35;
  }
  *(int **)(v34 + 872) = v50[0];
  *(_DWORD *)(*(_QWORD *)v32 + 868LL) = 1;
  sub_F710(a1);
  v8 = *(_QWORD *)v32;
  if ( *(_DWORD *)(*(_QWORD *)v32 + 868LL) != 1 )
    goto LABEL_34;
LABEL_5:
  v10 = *(_QWORD *)(v8 + 872);
  v11 = *(unsigned __int16 *)(v10 + 16);
  if ( (unsigned int)(v11 - 4096) >= 2 )
  {
    if ( v11 != 1 )
      goto LABEL_56;
    v35 = (FILE **)(v7 + 48);
    v36 = DHfsTell();
    v37 = *(_DWORD *)(v10 + 4);
    v16 = v36;
    switch ( a3 )
    {
      case 3:
        v38 = *v35;
        v49 = a2 + v37;
        break;
      case 2:
        v38 = *v35;
        v49 = a2 + v37 + *(_DWORD *)(v10 + 8);
        break;
      case 1:
        v38 = *v35;
        v39 = a2;
        v40 = 1;
LABEL_52:
        v31 = DHfsSeek(v38, v39, v40) - *(_DWORD *)(v10 + 4) - 16;
        goto LABEL_53;
      default:
        goto LABEL_56;
    }
    v39 = v49 + 16;
    v40 = 3;
    goto LABEL_52;
  }
  v12 = (FILE **)(v7 + 48);
  v13 = DHfsTell();
  v14 = *(unsigned __int8 *)(v10 + 28);
  v15 = *(_DWORD *)(v10 + 4);
  v16 = v13;
  v17 = *(_DWORD *)(v10 + 24) - v14;
  switch ( a3 )
  {
    case 3:
      v19 = *v12;
      v45 = v15 + a2;
      if ( v17 <= a2 )
        v46 = *(unsigned __int8 *)(v10 + 28);
      else
        v46 = 0;
      v30 = v45 + v46;
      break;
    case 2:
      v42 = *(_DWORD *)(v10 + 8);
      v19 = *v12;
      v43 = v15 + a2 + v42;
      if ( v42 + a2 >= v17 )
        v44 = *(unsigned __int8 *)(v10 + 28);
      else
        v44 = 0;
      v30 = v43 + v44;
      break;
    case 1:
      v18 = v13 - v15;
      v19 = *v12;
      v20 = 1;
      if ( v18 >= v17 )
        v21 = *(unsigned __int8 *)(v10 + 28);
      else
        v21 = 0;
      v22 = v18 - v21;
      v23 = v22 < v17;
      v24 = v22 + a2;
      v25 = !v23;
      v23 = v24 < v17;
      v26 = v24 < v17;
      if ( v23 )
        v27 = 1;
      else
        v27 = v25;
      if ( (v25 & v26) != 0 )
        v28 = *(unsigned __int8 *)(v10 + 28);
      else
        v28 = 0;
      if ( v27 )
        v29 = -v28;
      else
        v29 = *(unsigned __int8 *)(v10 + 28);
      v30 = v29 + a2;
      goto LABEL_45;
    default:
LABEL_56:
      v31 = -15;
      goto LABEL_35;
  }
  v20 = 3;
LABEL_45:
  v47 = DHfsSeek(v19, v30, v20) - *(_DWORD *)(v10 + 4);
  if ( v47 >= v17 )
    v48 = v14;
  else
    v48 = 0;
  v31 = v47 - v48;
LABEL_53:
  if ( v31 > *(_DWORD *)(v10 + 8) || v31 < 0 )
  {
    DHfsSeek(*((FILE **)v7 + 6), v16, 3);
    goto LABEL_56;
  }
LABEL_35:
  pthread_mutex_unlock(&stru_246B0);
  return (unsigned int)v31;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (000000000000FB9C) ----------------------------------------------------
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2)
{
  int v3; // w20
  char *v4; // x19
  __int64 v5; // x22
  _QWORD *v6; // x0
  char *v7; // x24
  _QWORD *v8; // x20
  __int64 v9; // x1
  __int16 DCFHeader; // w0
  int v11; // w19
  __int16 v12; // w23
  int v13; // w8
  int v14; // w9
  const char *v15; // x0
  int v16; // w27
  int v17; // w25
  int v18; // w24
  int v19; // w21
  int v20; // w23
  int v21; // w19
  int v22; // w28
  int v23; // w26
  int v24; // w22
  int *v25; // x0
  int *v26; // x21
  const void *v27; // x1
  const void *v28; // x1
  __int64 v29; // x8
  const void *v30; // x1
  __int64 v31; // x8
  const void *v32; // x1
  __int64 v33; // x8
  const void *v34; // x1
  __int64 v35; // x8
  const void *v36; // x1
  __int64 v37; // x8
  const void *v38; // x1
  __int64 v39; // x8
  const void *v40; // x1
  __int64 v41; // x8
  const void *v42; // x1
  __int64 v43; // x8
  const void *v44; // x1
  __int64 v45; // x8
  const void *v46; // x1
  __int64 v47; // x8
  __int64 v48; // x10
  __int64 v49; // x9
  __int64 v50; // x8
  __int64 v51; // x9
  __int64 v52; // x10
  char *v53; // x8
  __int64 v54; // x9
  char *v55; // x8
  __int64 v56; // x10
  char *v57; // x8
  __int64 v58; // x9
  char *v59; // x8
  __int64 v60; // x10
  char *v61; // x8
  __int64 v62; // x9
  __int64 result; // x0
  __int64 v64; // x8
  __int16 ClientID; // w0
  __int16 v66; // w0
  __int64 v67; // x8
  _BYTE *v68; // x0
  __int16 v69; // w22
  __int64 v70; // x8
  __int16 v71; // w0
  int v72; // [xsp+Ch] [xbp-74h]
  int v73; // [xsp+1Ch] [xbp-64h]
  int v74; // [xsp+20h] [xbp-60h]
  int v75; // [xsp+24h] [xbp-5Ch]
  int v77; // [xsp+3Ch] [xbp-44h] BYREF
  _BYTE v78[51]; // [xsp+40h] [xbp-40h] BYREF
  __int64 v79; // [xsp+78h] [xbp-8h]

  v3 = a1;
  v79 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v78, 0, sizeof(v78));
  pthread_mutex_lock(&stru_246B0);
  if ( !v3 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65533;
  }
  if ( (~*((unsigned __int16 *)&stru_246B0 + (__int16)a1 + 224) & 3) != 0 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65511;
  }
  v4 = (char *)&stru_246B0 + 8 * (__int16)a1;
  v5 = *((_QWORD *)v4 + 75);
  v6 = DHmalloc(224);
  if ( !v6 )
  {
    pthread_mutex_unlock(&stru_246B0);
    return 65514;
  }
  v6[1] = 0;
  v7 = v4 + 600;
  v6[3] = 0;
  v8 = v6;
  v6[5] = 0;
  v6[6] = 0;
  v6[9] = 0;
  v6[11] = 0;
  v6[13] = 0;
  v6[15] = 0;
  v6[17] = 0;
  v6[19] = 0;
  v6[23] = 0;
  v6[25] = 0;
  v6[27] = 0;
  *(_QWORD *)((char *)v6 + 172) = 0;
  *(_QWORD *)((char *)v6 + 164) = 0;
  *((_WORD *)v6 + 30) = 1;
  v9 = *(_QWORD *)(*((_QWORD *)v4 + 75) + 528LL);
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_DWORD *)v6 + 4) = 0;
  *((_DWORD *)v6 + 8) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 16) = 0;
  *((_DWORD *)v6 + 20) = 0;
  *((_DWORD *)v6 + 24) = 0;
  *((_DWORD *)v6 + 28) = 0;
  *((_DWORD *)v6 + 32) = 0;
  *((_DWORD *)v6 + 36) = 0;
  *((_WORD *)v6 + 80) = 0;
  *((_DWORD *)v6 + 48) = 0;
  *((_DWORD *)v6 + 52) = 0;
  DCFHeader = DA_DRA_GetDCFHeader((__int64)v6, v9);
  v11 = *(_DWORD *)(v5 + 864);
  if ( DCFHeader >= 0 )
    v12 = 1;
  else
    v12 = DCFHeader;
  if ( !v11 )
  {
    if ( *(_DWORD *)(v5 + 860) != 1
      && (unsigned __int16)checkDomain(
                             *(_BYTE **)(v5 + 840),
                             *(_QWORD *)(v5 + 848),
                             *(char **)(*(_QWORD *)(v5 + 528) + 24LL)) != 1 )
    {
      LOWORD(v11) = -34;
      goto LABEL_8;
    }
    v64 = *(_QWORD *)(v5 + 528);
    if ( *(_DWORD *)(v64 + 184) )
    {
      if ( *(_DWORD *)(v64 + 216) != 1 )
      {
        LOWORD(v11) = sub_101A4(a1);
        if ( (_WORD)v11 )
          goto LABEL_8;
      }
    }
    v77 = 51;
    ClientID = GetClientID(a1, (__int64)v78, &v77, (__int64)&stru_246B0);
    if ( ClientID )
    {
      LOWORD(v11) = ClientID;
      if ( ClientID < 0 )
        goto LABEL_8;
    }
    else
    {
      v66 = compute_eTarget(
              *(const char **)(*(_QWORD *)(*(_QWORD *)v7 + 528LL) + 128LL),
              v78,
              *(_BYTE **)(*(_QWORD *)(*(_QWORD *)v7 + 528LL) + 136LL),
              *(const char **)(*(_QWORD *)(*(_QWORD *)v7 + 528LL) + 24LL));
      if ( v66 < 0 )
      {
        LOWORD(v11) = v66;
        goto LABEL_8;
      }
    }
    v67 = *(_QWORD *)(*(_QWORD *)v7 + 528LL);
    v68 = *(_BYTE **)(v67 + 64);
    if ( v68 )
    {
      v69 = ((unsigned int)DHstrnicmp(v68, "sse", 3) == 0) << 12;
      v67 = *(_QWORD *)(*(_QWORD *)v7 + 528LL);
    }
    else
    {
      v69 = 0;
    }
    LOWORD(v11) = compute_eServiceCode(
                    a1,
                    *(const char **)(v67 + 24),
                    *(_BYTE **)(v67 + 56),
                    *(const char **)(v67 + 40),
                    *(const char **)(v67 + 48),
                    (__int64)&stru_246B0);
    if ( !(_WORD)v11 )
    {
      v70 = *(_QWORD *)(*(_QWORD *)v7 + 528LL);
      v71 = compute_eAuthCode(
              a1,
              *(const char **)(v70 + 200),
              *(char **)(v70 + 176),
              *(const char **)(v70 + 192),
              *(unsigned __int8 **)(v70 + 208),
              *(char **)(v70 + 24),
              v69,
              (__int64)&stru_246B0);
      if ( v71 >= 0 )
        LOWORD(v11) = v12;
      else
        LOWORD(v11) = v71;
    }
  }
LABEL_8:
  pthread_mutex_unlock(&stru_246B0);
  v14 = *((_DWORD *)v8 + 2);
  v13 = *((_DWORD *)v8 + 3);
  v15 = (const char *)v8[9];
  *((_WORD *)v8 + 30) = v11;
  v75 = v14;
  v16 = v13 + 1;
  v17 = DHstrlen(v15) + 1;
  v18 = DHstrlen((const char *)v8[11]) + 1;
  v19 = DHstrlen((const char *)v8[13]) + 1;
  v20 = DHstrlen((const char *)v8[15]) + 1;
  v21 = DHstrlen((const char *)v8[17]) + 1;
  v22 = DHstrlen((const char *)v8[19]) + 1;
  v23 = DHstrlen((const char *)v8[23]) + 1;
  v73 = DHstrlen((const char *)v8[25]) + 1;
  v72 = v19;
  v74 = DHstrlen((const char *)v8[27]) + 1;
  v24 = v75 + v16 + v17 + v18 + v19 + v20 + v21 + v22 + v23 + v73 + v74 + 225;
  v25 = (int *)DHmalloc(v24);
  if ( v25 )
  {
    v26 = v25;
    DHmemcpy(v25, v8, 224);
    *v26 = v24;
    v27 = (const void *)v8[3];
    v26[4] = 0;
    DHmemcpy(v26 + 56, v27, v75 + 1);
    v28 = (const void *)v8[5];
    v29 = (unsigned int)(v26[4] + v75 + 1);
    v26[8] = v29;
    DHmemcpy((char *)v26 + v29 + 224, v28, v16);
    v30 = (const void *)v8[9];
    v31 = (unsigned int)(v26[8] + v16);
    v26[16] = v31;
    DHmemcpy((char *)v26 + v31 + 224, v30, v17);
    v32 = (const void *)v8[11];
    v33 = (unsigned int)(v26[16] + v17);
    v26[20] = v33;
    DHmemcpy((char *)v26 + v33 + 224, v32, v18);
    v34 = (const void *)v8[13];
    v35 = (unsigned int)(v26[20] + v18);
    v26[24] = v35;
    DHmemcpy((char *)v26 + v35 + 224, v34, v72);
    v36 = (const void *)v8[15];
    v37 = (unsigned int)(v26[24] + v72);
    v26[28] = v37;
    DHmemcpy((char *)v26 + v37 + 224, v36, v20);
    v38 = (const void *)v8[17];
    v39 = (unsigned int)(v26[28] + v20);
    v26[32] = v39;
    DHmemcpy((char *)v26 + v39 + 224, v38, v21);
    v40 = (const void *)v8[19];
    v41 = (unsigned int)(v26[32] + v21);
    v26[36] = v41;
    DHmemcpy((char *)v26 + v41 + 224, v40, v22);
    v42 = (const void *)v8[23];
    v43 = (unsigned int)(v26[36] + v22);
    v26[44] = v43;
    DHmemcpy((char *)v26 + v43 + 224, v42, v23);
    v44 = (const void *)v8[25];
    v45 = (unsigned int)(v26[44] + v23);
    v26[48] = v45;
    DHmemcpy((char *)v26 + v45 + 224, v44, v73);
    v46 = (const void *)v8[27];
    v47 = (unsigned int)(v26[48] + v73);
    v26[52] = v47;
    DHmemcpy((char *)v26 + v47 + 224, v46, v74);
    v48 = (unsigned int)v26[16];
    v49 = (__int64)v26 + (unsigned int)v26[8] + 224;
    *((_QWORD *)v26 + 3) = (char *)v26 + (unsigned int)v26[4] + 224;
    v50 = (unsigned int)v26[20];
    *((_QWORD *)v26 + 5) = v49;
    v51 = (unsigned int)v26[24];
    *((_QWORD *)v26 + 9) = (char *)v26 + v48 + 224;
    v52 = (unsigned int)v26[28];
    *((_QWORD *)v26 + 11) = (char *)v26 + v50 + 224;
    v53 = (char *)v26 + v51 + 224;
    v54 = (unsigned int)v26[32];
    *((_QWORD *)v26 + 13) = v53;
    v55 = (char *)v26 + v52 + 224;
    v56 = (unsigned int)v26[36];
    *((_QWORD *)v26 + 15) = v55;
    v57 = (char *)v26 + v54 + 224;
    v58 = (unsigned int)v26[44];
    *((_QWORD *)v26 + 17) = v57;
    v59 = (char *)v26 + v56 + 224;
    v60 = (unsigned int)v26[48];
    *((_QWORD *)v26 + 19) = v59;
    v61 = (char *)v26 + v58 + 224;
    v62 = (unsigned int)v26[52];
    *((_QWORD *)v26 + 23) = v61;
    *((_QWORD *)v26 + 25) = (char *)v26 + v60 + 224;
    *((_QWORD *)v26 + 27) = (char *)v26 + v62 + 224;
    sub_10398(v8);
    result = 0;
    *a2 = v26;
  }
  else
  {
    sub_10398(v8);
    return 65514;
  }
  return result;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (00000000000101A4) ----------------------------------------------------
__int64 __fastcall sub_101A4(unsigned __int16 a1)
{
  char *v1; // x20
  int v2; // w19
  unsigned int v4; // w0
  __int64 v5; // x8
  __int64 v6; // x9
  unsigned int v7; // w8

  if ( (__int16)a1 < 1 )
    return 65533;
  v1 = (char *)&stru_246B0 + 8 * a1;
  if ( *(_DWORD *)(*((_QWORD *)v1 + 75) + 860LL) == 1 )
  {
    v2 = 0;
  }
  else
  {
    v2 = DHAuthTime();
    if ( !v2 )
      return 65431;
  }
  v4 = DHcurrentTime();
  if ( !v4 )
    return 65433;
  v5 = *((_QWORD *)v1 + 75);
  if ( *(_DWORD *)(v5 + 860) != 1 && v4 - v2 >= *(_DWORD *)(v5 + 856) )
    return 65430;
  v6 = *(_QWORD *)(v5 + 528);
  v7 = *(_DWORD *)(v6 + 184);
  if ( !v7 || *(_DWORD *)(v6 + 216) == 1 )
    return 0;
  if ( v4 <= v7 )
    return 0;
  return 4294967195LL;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (0000000000010270) ----------------------------------------------------
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, int *a3, __int64 a4)
{
  __int64 v6; // x23
  unsigned int v7; // w21
  __int64 result; // x0
  int v9; // w0
  __int64 v10; // x21
  int v11; // w22
  unsigned int v12; // w22

  v6 = *(_QWORD *)(a4 + 8LL * a1 + 600);
  if ( *(_DWORD *)(v6 + 832) )
  {
    if ( *(_BYTE *)(v6 + 536) )
    {
      v7 = DHstrlen((const char *)(v6 + 536));
      DHstrncpy_s(a2, *a3, v6 + 536, v7);
      result = 0;
      *a3 = v7;
    }
    else
    {
      return 65436;
    }
  }
  else
  {
    v9 = DHstrlen(*(const char **)(*(_QWORD *)(v6 + 528) + 128LL));
    v10 = *(_QWORD *)(v6 + 824);
    if ( v10 )
    {
      v11 = v9;
      while ( 1 )
      {
        if ( !(unsigned int)DHstrnicmp(*(_BYTE **)(*(_QWORD *)(v6 + 528) + 128LL), (_BYTE *)v10, v11) )
        {
          result = compute_eTarget(
                     *(const char **)(*(_QWORD *)(v6 + 528) + 128LL),
                     (const char *)(v10 + 16),
                     *(_BYTE **)(*(_QWORD *)(v6 + 528) + 136LL),
                     *(const char **)(*(_QWORD *)(v6 + 528) + 24LL));
          if ( (unsigned __int16)result != 65434 )
            break;
        }
        v10 = *(_QWORD *)(v10 + 72);
        if ( !v10 )
          return 65434;
      }
      if ( !(_WORD)result )
      {
        v12 = DHstrlen((const char *)(v10 + 16));
        DHstrncpy_s(a2, *a3, v10 + 16, v12);
        *a3 = v12;
        DHstrncpy_s(v6 + 536, 51, v10 + 16, v12);
        result = 1;
        *(_DWORD *)(v6 + 832) = 1;
      }
    }
    else
    {
      return 65434;
    }
  }
  return result;
}

//----- (0000000000010398) ----------------------------------------------------
void __fastcall sub_10398(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0

  v2 = (void *)a1[3];
  if ( v2 )
    DHfree(v2);
  v3 = (void *)a1[5];
  if ( v3 )
    DHfree(v3);
  v4 = (void *)a1[9];
  if ( v4 )
    DHfree(v4);
  v5 = (void *)a1[11];
  if ( v5 )
    DHfree(v5);
  v6 = (void *)a1[13];
  if ( v6 )
    DHfree(v6);
  v7 = (void *)a1[15];
  if ( v7 )
    DHfree(v7);
  v8 = (void *)a1[17];
  if ( v8 )
    DHfree(v8);
  v9 = (void *)a1[19];
  if ( v9 )
    DHfree(v9);
  v10 = (void *)a1[23];
  if ( v10 )
    DHfree(v10);
  v11 = (void *)a1[25];
  if ( v11 )
    DHfree(v11);
  v12 = (void *)a1[27];
  if ( v12 )
    DHfree(v12);
  DHfree(a1);
}

//----- (000000000001043C) ----------------------------------------------------
__int64 __fastcall DRM_GetUnsupportedValue(__int64 a1, _BYTE *a2, _BYTE *a3, int a4)
{
  __int64 result; // x0
  __int64 v9; // x24
  char *v10; // x26
  __int64 v11; // x22
  int v12; // w0
  unsigned int v13; // w3

  if ( !a1 )
    return 65501;
  result = 65501;
  if ( a2 && *(_QWORD *)(a1 + 216) )
  {
    pthread_mutex_lock(&stru_246B0);
    v9 = 0;
    while ( 1 )
    {
      if ( (~*((unsigned __int16 *)&stru_246B0 + v9 + 225) & 3) == 0 )
      {
        if ( *(_QWORD *)(a1 + 216) )
        {
          v10 = (char *)&stru_246B0 + 8 * v9;
          if ( *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v10 + 76) + 528LL) + 240LL) )
          {
            if ( !(unsigned int)DHstrcmp() )
              break;
          }
        }
      }
      if ( ++v9 == 49 )
      {
        *a3 = 0;
        pthread_mutex_unlock(&stru_246B0);
        return 65533;
      }
    }
    v11 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v10 + 76) + 528LL) + 248LL);
    if ( v11 )
    {
      while ( (unsigned int)DHstrnicmp((_BYTE *)v11, a2, 20) )
      {
        v11 = *(_QWORD *)(v11 + 640);
        if ( !v11 )
          goto LABEL_13;
      }
      v12 = DHstrlen((const char *)(v11 + 128));
      if ( v12 >= 255 )
        v13 = 255;
      else
        v13 = v12;
      DHstrncpy_s((__int64)a3, a4, v11 + 128, v13);
      pthread_mutex_unlock(&stru_246B0);
      return 0;
    }
    else
    {
LABEL_13:
      pthread_mutex_unlock(&stru_246B0);
      result = 65500;
      *a3 = 0;
    }
  }
  return result;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (0000000000010584) ----------------------------------------------------
void *__fastcall DRM_GetFilePath(unsigned __int16 a1)
{
  char *v2; // x22
  int v3; // w21
  void *v4; // x19

  if ( (__int16)a1 < 1 )
    return 0;
  pthread_mutex_lock(&stru_246B0);
  v2 = (char *)&stru_246B0 + 8 * a1;
  v3 = DHstrlen((const char *)(*((_QWORD *)v2 + 75) + 8LL));
  v4 = DHmalloc(v3 + 1);
  DHmemset(v4, 0, v3 + 1);
  DHmemcpy(v4, (const void *)(*((_QWORD *)v2 + 75) + 8LL), v3);
  pthread_mutex_unlock(&stru_246B0);
  return v4;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (0000000000010618) ----------------------------------------------------
__int64 __fastcall DRM_GetFileSize(unsigned __int16 a1)
{
  __int64 v2; // x8
  unsigned int v3; // w19

  if ( (__int16)a1 < 1 )
  {
    return (unsigned int)-3;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)&unk_246B0);
    v2 = *((_QWORD *)&unk_246B0 + a1 + 75);
    v3 = *(_DWORD *)(v2 + 600) + *(_DWORD *)(v2 + 616);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_246B0);
  }
  return v3;
}

//----- (0000000000010678) ----------------------------------------------------
__int64 DRM_SetClientID()
{
  __int64 result; // x0
  unsigned int v1; // w20

  if ( !qword_246A8 )
    qword_246A8 = (__int64)DHmalloc(14);
  result = DA_DRA_SetClientID();
  if ( (int)result <= 0 )
  {
    v1 = result;
    DHFreeClientID((void *)qword_246A8);
    result = v1;
    qword_246A8 = 0;
  }
  return result;
}
// 246A8: using guessed type __int64 qword_246A8;

//----- (00000000000106E8) ----------------------------------------------------
__int64 __fastcall DRM_GetOriginalFileSize(unsigned __int16 a1)
{
  unsigned int v2; // w19

  if ( (__int16)a1 < 1 )
  {
    return (unsigned int)-3;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)&unk_246B0);
    v2 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)&unk_246B0 + a1 + 75) + 528LL) + 80LL);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_246B0);
  }
  return v2;
}

//----- (0000000000010744) ----------------------------------------------------
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3)
{
  __int64 result; // x0
  unsigned int v4; // w19

  result = DHGetClientID_BySetVal(a1, a2, a3, (__int16 **)&qword_246A8);
  if ( (int)result <= 0 )
  {
    v4 = result;
    DHFreeClientID((void *)qword_246A8);
    result = v4;
    qword_246A8 = 0;
  }
  return result;
}
// 246A8: using guessed type __int64 qword_246A8;

//----- (000000000001078C) ----------------------------------------------------
__int64 __fastcall sub_1078C(__int16 a1)
{
  char *v1; // x20
  __int16 v2; // w0
  char *v3; // x20
  __int64 v4; // x8
  __int64 v5; // x9
  _BYTE *v6; // x10
  unsigned __int8 *v7; // x10
  unsigned int v8; // w13
  unsigned int v9; // w12
  _QWORD v11[4]; // [xsp+4h] [xbp-13Ch] BYREF
  _BYTE v12[244]; // [xsp+24h] [xbp-11Ch] BYREF
  __int128 v13; // [xsp+118h] [xbp-28h] BYREF
  _BYTE v14[16]; // [xsp+128h] [xbp-18h] BYREF
  __int64 v15; // [xsp+138h] [xbp-8h]

  v1 = (char *)&stru_246B0 + 8 * a1;
  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = compute_SSKey(
         a1,
         *(const char **)(*(_QWORD *)(*((_QWORD *)v1 + 75) + 528LL) + 152LL),
         *(char **)(*(_QWORD *)(*((_QWORD *)v1 + 75) + 528LL) + 24LL),
         v14,
         16,
         (__int64)&stru_246B0);
  if ( v2 < 0 )
    return (unsigned int)v2;
  v3 = v1 + 600;
  DHmemset(&v13, 0, 16);
  AES_set_decrypt_key();
  v4 = *(_QWORD *)v3;
  v5 = 0;
  v6 = *(_BYTE **)(*(_QWORD *)(*(_QWORD *)v3 + 528LL) + 168LL);
  if ( *v6 == 34 )
    ++v6;
  v7 = v6 + 1;
  do
  {
    v9 = *(v7 - 1);
    if ( v9 - 65 > 5 )
    {
      if ( v9 - 97 > 5 )
      {
        v9 -= 48;
        if ( v9 > 9 )
          return 65513;
      }
      else
      {
        LOBYTE(v9) = v9 - 87;
      }
    }
    else
    {
      LOBYTE(v9) = v9 - 55;
    }
    v8 = *v7;
    if ( v8 - 65 <= 5 )
    {
      LOBYTE(v8) = v8 - 55;
    }
    else if ( v8 - 97 > 5 )
    {
      v8 -= 48;
      if ( v8 > 9 )
        return 65513;
    }
    else
    {
      LOBYTE(v8) = v8 - 87;
    }
    v7 += 2;
    *((_BYTE *)v11 + v5++) = v8 | (16 * v9);
  }
  while ( v5 != 32 );
  AES_cbc_encrypt(v11, (int8x16_t *)(v4 + 680), 0x10u, (__int64)v12, &v13, 0);
  return 0;
}
// 246B0: using guessed type pthread_mutex_t stru_246B0;

//----- (0000000000010908) ----------------------------------------------------
void __fastcall sub_10908(void **a1)
{
  void **v1; // x19

  if ( a1[6] )
  {
    v1 = a1;
    DHfree(a1[6]);
    a1 = v1;
  }
  DHfree(a1);
}

//----- (0000000000010938) ----------------------------------------------------
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  int v10; // w26
  int v11; // w24
  char *v12; // x24
  unsigned int v13; // w27
  char v14; // w19
  int v15; // w0
  int v16; // w25
  void *v17; // x0
  int v18; // w22
  char *v19; // x19
  int v20; // w23
  __int64 v21; // x20
  int v22; // w8
  int v23; // w28
  int v24; // w19
  int v25; // w19
  void *v26; // x0
  void *v27; // x0
  int v28; // w19
  void *v29; // x0
  int v30; // w19
  void *v31; // x0
  unsigned int v32; // w0
  void *v33; // x0
  int v34; // w19
  int v35; // w19
  void *v36; // x0
  int v37; // w27
  void *v38; // x0
  int v39; // w19
  unsigned int v40; // w27
  __int64 v41; // x28
  void *v42; // x0
  __int64 v43; // x19
  unsigned int v44; // w27
  void *v45; // x0
  __int64 v46; // x8
  __int64 v47; // x9
  unsigned __int16 v48; // w19
  __int64 v49; // x19
  __int64 v50; // x28
  unsigned __int64 v51; // x19
  __int64 v52; // x8
  int v53; // w19
  void *v54; // x0
  unsigned int v55; // w19
  void *v56; // x0
  __int64 v57; // x8
  void *v58; // x0
  int v59; // w8
  __int16 **v60; // x3
  int v61; // w19
  int v62; // w25
  unsigned int v63; // w0
  int v64; // w0
  int v65; // w0
  int v66; // w0
  int v67; // w0
  int v68; // w0
  int v69; // w0
  int v70; // w0
  int v71; // w0
  int v72; // w0
  unsigned int v73; // w19
  __int64 v74; // x8
  __int64 v75; // x23
  unsigned int v76; // w26
  int8x16_t *v77; // x19
  char *v78; // x27
  __int64 i; // x23
  unsigned int v80; // w0
  int v81; // w0
  int v83; // w0
  int v84; // w19
  char *v85; // x0
  unsigned int v86; // w0
  unsigned int v87; // w19
  _BYTE *v88; // x0
  _BYTE *v89; // x19
  unsigned int v90; // w23
  int v91; // w23
  int8x16_t *v92; // x0
  int8x16_t *v93; // x23
  int v94; // w19
  void *v95; // x0
  __int64 v96; // x24
  int v97; // w20
  int v98; // w19
  int v99; // w19
  int v100; // w19
  __int64 v101; // x19
  unsigned int v102; // w0
  void *v103; // x0
  __int64 v104; // x19
  unsigned int v105; // w0
  unsigned __int64 v106; // [xsp+28h] [xbp-408h]
  unsigned __int64 v107; // [xsp+30h] [xbp-400h]
  _DWORD *v108; // [xsp+58h] [xbp-3D8h]
  __int64 *v109; // [xsp+60h] [xbp-3D0h]
  __int64 *v110; // [xsp+60h] [xbp-3D0h]
  _BYTE *v113; // [xsp+80h] [xbp-3B0h]
  int v114; // [xsp+8Ch] [xbp-3A4h] BYREF
  char v115[8]; // [xsp+90h] [xbp-3A0h] BYREF
  __int64 v116; // [xsp+98h] [xbp-398h] BYREF
  _QWORD v117[2]; // [xsp+A0h] [xbp-390h]
  char v118[8]; // [xsp+B0h] [xbp-380h] BYREF
  _QWORD v119[2]; // [xsp+B8h] [xbp-378h]
  __int64 v120; // [xsp+C8h] [xbp-368h] BYREF
  _QWORD v121[2]; // [xsp+D0h] [xbp-360h]
  char v122[32]; // [xsp+E0h] [xbp-350h] BYREF
  char s[16]; // [xsp+100h] [xbp-330h] BYREF
  __int128 v124; // [xsp+110h] [xbp-320h]
  const void *v125[4]; // [xsp+120h] [xbp-310h] BYREF
  __int128 v126; // [xsp+140h] [xbp-2F0h] BYREF
  __int128 v127; // [xsp+150h] [xbp-2E0h]
  __int128 v128; // [xsp+160h] [xbp-2D0h]
  __int128 v129; // [xsp+170h] [xbp-2C0h]
  _DWORD v130[8]; // [xsp+180h] [xbp-2B0h] BYREF
  __int128 v131; // [xsp+1A0h] [xbp-290h]
  __int128 v132; // [xsp+1B0h] [xbp-280h]
  __int128 v133; // [xsp+1C0h] [xbp-270h]
  __int128 v134; // [xsp+1D0h] [xbp-260h]
  __int128 v135; // [xsp+1E0h] [xbp-250h]
  __int128 v136; // [xsp+1F0h] [xbp-240h]
  __int128 v137; // [xsp+200h] [xbp-230h]
  __int128 v138; // [xsp+210h] [xbp-220h]
  __int128 v139; // [xsp+220h] [xbp-210h]
  __int128 v140; // [xsp+230h] [xbp-200h]
  __int128 v141; // [xsp+240h] [xbp-1F0h]
  __int128 v142; // [xsp+250h] [xbp-1E0h]
  __int128 v143; // [xsp+260h] [xbp-1D0h]
  __int128 v144; // [xsp+270h] [xbp-1C0h]
  __int128 v145; // [xsp+280h] [xbp-1B0h]
  __int128 v146; // [xsp+290h] [xbp-1A0h]
  __int128 v147; // [xsp+2A0h] [xbp-190h]
  __int128 v148; // [xsp+2B0h] [xbp-180h]
  __int128 v149; // [xsp+2C0h] [xbp-170h]
  __int128 v150; // [xsp+2D0h] [xbp-160h]
  __int128 v151; // [xsp+2E0h] [xbp-150h]
  __int128 v152; // [xsp+2F0h] [xbp-140h]
  __int64 v153; // [xsp+300h] [xbp-130h] BYREF
  _QWORD v154[2]; // [xsp+308h] [xbp-128h]
  __int64 v155; // [xsp+318h] [xbp-118h] BYREF
  _QWORD v156[2]; // [xsp+320h] [xbp-110h]
  __int128 v157; // [xsp+330h] [xbp-100h] BYREF
  __int128 v158; // [xsp+340h] [xbp-F0h]
  char v159[32]; // [xsp+350h] [xbp-E0h] BYREF
  __int128 v160; // [xsp+370h] [xbp-C0h] BYREF
  __int128 v161; // [xsp+380h] [xbp-B0h]
  _OWORD v162[3]; // [xsp+390h] [xbp-A0h] BYREF
  char v163; // [xsp+3C0h] [xbp-70h]
  int8x16_t v164; // [xsp+3D0h] [xbp-60h] BYREF
  __int128 v165; // [xsp+3E0h] [xbp-50h]
  _BYTE v166[33]; // [xsp+3F0h] [xbp-40h] BYREF
  __int64 v167; // [xsp+418h] [xbp-18h]

  v167 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v122, 0, 26);
  v120 = 0;
  v121[0] = 0;
  *(_QWORD *)((char *)v121 + 5) = 0;
  *(_QWORD *)v118 = 0;
  v119[0] = 0;
  *(_QWORD *)((char *)v119 + 5) = 0;
  v116 = 0;
  v117[0] = 0;
  *(_QWORD *)((char *)v117 + 5) = 0;
  memset(v159, 0, 26);
  v157 = 0u;
  v158 = 0u;
  v161 = 0u;
  memset(v162, 0, 19);
  v160 = 0u;
  v165 = 0u;
  memset(v166, 0, 19);
  v164 = 0u;
  v114 = 50;
  v155 = 0;
  v156[0] = 0;
  *(_QWORD *)((char *)v156 + 5) = 0;
  v154[0] = 0;
  v153 = 0;
  *(_QWORD *)((char *)v154 + 5) = 0;
  memset(v125, 0, sizeof(v125));
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  memset(v130, 0, sizeof(v130));
  v131 = 0u;
  v132 = 0u;
  v133 = 0u;
  v134 = 0u;
  v135 = 0u;
  v136 = 0u;
  v137 = 0u;
  v138 = 0u;
  v139 = 0u;
  v140 = 0u;
  v141 = 0u;
  v142 = 0u;
  v143 = 0u;
  v144 = 0u;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v152 = 0u;
  v124 = 0u;
  *(_OWORD *)s = 0u;
  *(_QWORD *)v115 = 0;
  printLogD();
  DHstrcpy_s((char *)&v157, 32, "melon");
  DHmemset(&v164, 0, 50);
  printLogD();
  v10 = DHGetDeviceID_ConstVal((char *)&v164);
  v11 = DHstrlen((const char *)&v164);
  printLogD();
  v113 = a1;
  if ( v10 )
  {
    v12 = 0;
    v13 = 65333;
    v14 = 1;
  }
  else
  {
    printLogD();
    v60 = (__int16 **)*a6;
    if ( !*a6 )
    {
      v60 = (__int16 **)DHmalloc(14);
      *a6 = v60;
    }
    v61 = DHGetClientID_BySetVal("min", (unsigned int *)&v114, (__int64)&v160, v60);
    printLogD();
    if ( v61 <= 0 )
    {
      DHFreeClientID(*a6);
      v12 = 0;
      *a6 = 0;
      v13 = 65436;
      v14 = 1;
    }
    else
    {
      strcpy(v159, "SS MAC-1 Token Generation");
      v62 = DHstrlen(v159);
      v63 = DHstrlen("ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=");
      DHstrncpy_s((__int64)s, 512, (__int64)"ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=", v63);
      v64 = DHstrlen((const char *)&v157);
      DHstrncat_s(s, 512, (__int64)&v157, v64);
      v65 = DHstrlen("\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:");
      DHstrncat_s(s, 512, (__int64)"\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:", v65);
      v66 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v66);
      v67 = DHstrlen("\ntt=120\nmc=6\nce=MIN:");
      DHstrncat_s(s, 512, (__int64)"\ntt=120\nmc=6\nce=MIN:", v67);
      printLogD();
      v68 = DHstrlen((const char *)&v160);
      DHstrncat_s(s, 512, (__int64)&v160, v68);
      v69 = DHstrlen("\nce=HID:");
      DHstrncat_s(s, 512, (__int64)"\nce=HID:", v69);
      v70 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v70);
      v71 = DHstrlen("\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n");
      DHstrncat_s(s, 512, (__int64)"\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n", v71);
      v72 = DHstrlen(s);
      if ( v72 < 1 )
      {
        v12 = 0;
        v14 = 0;
        v13 = 0;
      }
      else
      {
        v73 = v72;
        v110 = a3;
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)s, (uint32x4_t *)&v155, v73);
        v74 = 2LL * v11;
        v75 = v74 + 37;
        v76 = v62 + v74 + 37;
        v77 = (int8x16_t *)DHmalloc(v11 + 1);
        DHmemset(v77, 0, v11 + 1);
        inverse(&v164, v77, v11);
        v78 = (char *)DHmalloc(v76 + 1);
        DHmemset(v78, 0, v76 + 1);
        DHmemcpy(v78, &v155, 20);
        DHmemcpy(v78 + 20, "SSMAC-1", 7);
        DHmemcpy(v78 + 27, "DEV_SERIAL", 10);
        DHmemcpy(v78 + 37, &v164, v11);
        DHmemcpy(&v78[v11 + 37], v77, v11);
        DHmemcpy(&v78[v75], v159, v62);
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)v78, (uint32x4_t *)&v155, v76);
        DHfree(v78);
        DHfree(v77);
        DHmemset(&v153, 0, 21);
        DHmemset(&v115[4], 0, 4);
        for ( i = 0; i != 10; ++i )
        {
          if ( !DHultoa(*((unsigned __int8 *)&v156[-1] + i), (int8x16_t *)&v115[4], 0x10u) )
            return 0xFFFF;
          if ( (unsigned int)DHstrlen(&v115[4]) == 1 )
          {
            v80 = DHstrlen(&v115[4]);
            DHstrncpy_s((__int64)v115, 4, (__int64)&v115[4], v80);
            DHstrncpy_s((__int64)&v115[4], 4, (__int64)"0", 1u);
            v81 = DHstrlen(v115);
            DHstrncat_s(&v115[4], 4, (__int64)v115, v81);
          }
          DHstrncat_s((char *)&v153, 21, (__int64)&v115[4], 2);
          DHmemset(&v115[4], 0, 4);
        }
        DHfree(&v115[4]);
        DHstrcat();
        DHstrcat();
        DHstrcat();
        v83 = DHstrlen(s);
        a3 = v110;
        if ( v83 < 1 )
        {
          v12 = 0;
          v13 = 65332;
          v14 = 1;
        }
        else
        {
          v84 = v83;
          v85 = (char *)DHmalloc(v83 + 1);
          v12 = v85;
          if ( v85 )
          {
            DHmemset(v85, 0, v84 + 1);
            DHmemcpy(v12, s, v84);
            DHstrlen(v12);
            printLogD();
            v14 = 0;
            v13 = 0;
          }
          else
          {
            v13 = 65514;
            v14 = 1;
          }
        }
      }
    }
  }
  printLogD();
  if ( !v12 || (v14 & 1) != 0 )
    return v13;
  v15 = DHstrlen(v12);
  if ( v15 <= 0 )
  {
    DHfree(v12);
    printLogD();
    return 65336;
  }
  v16 = v15;
  printLogD();
  LOWORD(v130[0]) = 0;
  *(_QWORD *)&v130[3] = 0;
  *(_QWORD *)&v130[1] = 0;
  v124 = 0u;
  memset(v125, 0, 28);
  *(_OWORD *)s = 0u;
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  printLogD();
  v17 = DHmalloc(v16 + 1);
  *(_QWORD *)&v127 = v17;
  if ( !v17 )
  {
    DHfree(v12);
    return 65514;
  }
  v109 = a3;
  DHmemset(v17, 0, v16 + 1);
  printLogD();
  memset(v159, 0, 17);
  v161 = 0u;
  memset(v162, 0, sizeof(v162));
  v164 = 0u;
  v165 = 0u;
  memset(v166, 0, sizeof(v166));
  v163 = 0;
  v160 = 0u;
  v157 = 0u;
  LODWORD(v158) = 0;
  LOWORD(v156[0]) = 0;
  v155 = 0;
  LODWORD(v153) = 0;
  v114 = 0;
  printLogD();
  printLogD();
  v18 = 0;
  v19 = v12;
  v20 = v16;
  v108 = a5;
  do
  {
    DHmemset(&v160, 0, 80);
    printLogD();
    v21 = 0;
    v22 = (unsigned __int8)*v19;
    if ( *v19 )
    {
      do
      {
        if ( v22 == 10 )
          break;
        if ( v21 == 81 )
          goto LABEL_77;
        *((_BYTE *)&v160 + v21++) = v22;
        v22 = (unsigned __int8)v19[v21];
      }
      while ( v19[v21] );
    }
    v23 = v21 + 1;
    *((_BYTE *)&v160 + v21) = 0;
    printLogD();
    v13 = sub_126E8((unsigned __int8 *)&v160, (int)v21 + 1, v159, (int *)&v153, &v164, &v114);
    if ( (_WORD)v13 || (v24 = v153, (int)v153 < 2) )
    {
      if ( !(_WORD)v13 )
        goto LABEL_90;
      goto LABEL_78;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ve", v153) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v26 = DHmalloc(v114 + 1);
      *(_QWORD *)s = v26;
      if ( !v26 )
        goto LABEL_97;
      DHmemset(v26, 0, v25 + 1);
      v27 = *(void **)s;
LABEL_29:
      DHmemcpy(v27, &v164, v25);
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "sn", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v28 = v114;
      v29 = DHmalloc(v114 + 1);
      *(_QWORD *)&s[8] = v29;
      if ( !v29 )
        goto LABEL_97;
      DHmemset(v29, 0, v28 + 1);
      DHmemcpy(*(void **)&s[8], &v164, v28);
      HIDWORD(v127) = v28;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "am", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v30 = v114;
      v31 = DHmalloc(v114 + 1);
      *(_QWORD *)&v126 = v31;
      if ( !v31 )
        goto LABEL_97;
      DHmemset(v31, 0, v30 + 1);
      DHmemcpy((void *)v126, &v164, v30);
      DWORD2(v127) = v30;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "dl", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v32 = sub_125C0((__int64)&v164, v114, (__int64 **)&v126 + 1);
      if ( !(_WORD)v32 )
        goto LABEL_65;
      v13 = v32;
LABEL_78:
      DHfree(v12);
      sub_1233C((__int64)s);
      printLogD();
      return v13;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ci", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v33 = DHmalloc(v114 + 1);
      *(_QWORD *)&v124 = v33;
      if ( !v33 )
        goto LABEL_97;
      DHmemset(v33, 0, v25 + 1);
      v27 = (void *)v124;
      goto LABEL_29;
    }
    if ( (unsigned int)DHstrnicmp(v159, "rd", v24) )
    {
      if ( !(unsigned int)DHstrnicmp(v159, "tt", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        LODWORD(v125[3]) = 3600 * DHatoi();
        goto LABEL_65;
      }
      if ( !(unsigned int)DHstrnicmp(v159, "mc", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        DWORD2(v128) = DHatoi();
        goto LABEL_65;
      }
      if ( (unsigned int)DHstrnicmp(v159, "ce", v24) )
      {
        if ( (unsigned int)DHstrnicmp(v159, "vp", v24) )
        {
          if ( (unsigned int)DHstrnicmp(v159, "sa", v24) )
          {
            if ( (unsigned int)DHstrnicmp(v159, "sv", v24) )
            {
              v130[4] += v21 + 1;
              DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
              *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
              goto LABEL_65;
            }
            v25 = v114;
            v58 = DHmalloc(v114 + 1);
            v125[2] = v58;
            if ( !v58 )
              goto LABEL_97;
            DHmemset(v58, 0, v25 + 1);
            v27 = (void *)v125[2];
            goto LABEL_29;
          }
          v53 = v114;
          v54 = DHmalloc(v114 + 1);
          v125[1] = v54;
          if ( !v54 )
            goto LABEL_97;
          DHmemset(v54, 0, v53 + 1);
          DHmemcpy((void *)v125[1], &v164, v53);
          v130[3] = v53;
        }
        else
        {
          v130[4] += v21 + 1;
          DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
          *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164, 4);
          v48 = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_u8[4], 2);
          v49 = v48 | ((unsigned __int16)DHatoi() << 16);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (char *)&v164.n128_i32[1] + 2, 2);
          v50 = (unsigned __int16)DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_i8[8], 2);
          v51 = v49 | (DHatoi() << 48) | (v50 << 32);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xA), 2);
          LOWORD(v50) = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xC), 2);
          v52 = (unsigned __int16)v50 | ((unsigned __int16)DHatoi() << 16);
          if ( LOWORD(v130[0]) )
          {
            v107 = v107 & 0xFFFFFFFF00000000LL | v52;
            v130[2] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 2;
          }
          else
          {
            v106 = v106 & 0xFFFFFFFF00000000LL | v52;
            v130[1] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 1;
          }
          printLogD();
          printLogD();
        }
      }
      else
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        if ( ++HIDWORD(v128) > DWORD2(v128) )
        {
LABEL_77:
          printLogD();
          v13 = 65335;
          goto LABEL_78;
        }
        DHmemset(&v160, 0, 80);
        v39 = v114;
        DHmemcpy(&v160, &v164, v114);
        sub_126E8((unsigned __int8 *)&v160, v39 + 1, v159, (int *)&v153, &v164, &v114);
        v40 = v153;
        if ( !(unsigned int)DHstrnicmp(v159, "min", v153) )
        {
          LODWORD(v129) = v129 + 1;
          if ( v164.n128_u8[0] == 48 && v114 == 11 )
          {
            DHmemset(&v157, 0, 20);
            DHstrncpy_s((__int64)&v157, 20, (__int64)v164.n128_i64 + 1, 0xAu);
            DHmemset(&v164, 0, 11);
            DHstrncpy_s((__int64)&v164, 65, (__int64)&v157, 0xAu);
            v114 = 10;
          }
        }
        v41 = *((_QWORD *)&v129 + 1);
        v42 = DHmalloc(40);
        v43 = (__int64)v42;
        if ( v41 )
        {
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, v40 + 1);
          DHstrncpy_s(v43, 16, (__int64)v159, v40);
          v44 = v114;
          v45 = DHmalloc(v114 + 1);
          *(_QWORD *)(v43 + 16) = v45;
          if ( !v45 )
            goto LABEL_97;
          DHmemset(v45, 0, v44 + 1);
          DHstrncpy_s(*(_QWORD *)(v43 + 16), v44 + 1, (__int64)&v164, v44);
          *(_DWORD *)(v43 + 24) = v44;
          *(_QWORD *)(v43 + 32) = 0;
          v46 = *((_QWORD *)&v129 + 1);
          do
          {
            v47 = v46;
            v46 = *(_QWORD *)(v46 + 32);
          }
          while ( v46 );
          *(_QWORD *)(v47 + 32) = v43;
        }
        else
        {
          *((_QWORD *)&v129 + 1) = v42;
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, 16);
          DHstrncpy_s(*((__int64 *)&v129 + 1), 16, (__int64)v159, v40);
          v55 = v114;
          v56 = DHmalloc(v114 + 1);
          *(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL) = v56;
          if ( !v56 )
            goto LABEL_97;
          DHmemset(v56, 0, v55 + 1);
          DHstrncpy_s(*(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL), v40 + 1, (__int64)&v164, v55);
          v57 = *((_QWORD *)&v129 + 1);
          *(_DWORD *)(*((_QWORD *)&v129 + 1) + 24LL) = v55;
          *(_QWORD *)(v57 + 32) = 0;
        }
      }
    }
    else
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      DHmemset(&v160, 0, 80);
      v34 = v114;
      DHmemcpy(&v160, &v164, v114);
      sub_126E8((unsigned __int8 *)&v160, v34 + 1, v159, (int *)&v153, &v164, &v114);
      v35 = v153;
      v36 = DHmalloc((int)v153 + 1);
      *((_QWORD *)&v124 + 1) = v36;
      if ( !v36
        || (DHmemset(v36, 0, v35 + 1),
            DHmemcpy(*((void **)&v124 + 1), v159, v35),
            v37 = v114,
            LODWORD(v128) = v35,
            v38 = DHmalloc(v114 + 1),
            (v125[0] = v38) == 0) )
      {
LABEL_97:
        v13 = 65514;
        goto LABEL_78;
      }
      DHmemset(v38, 0, v37 + 1);
      DHmemcpy((void *)v125[0], &v164, v37);
      DWORD1(v128) = v37;
    }
LABEL_65:
    v59 = v20 - 1;
    v18 += 1 + v21;
    v20 = v20 - 1 - v21;
    v19 = &v12[v18];
  }
  while ( v59 - (int)v21 > 0 );
  printLogD();
LABEL_90:
  printLogD();
  DHfree(v12);
  if ( !v125[0] || !v125[1] || !*(_QWORD *)&s[8] || !(_QWORD)v126 )
  {
    sub_1233C((__int64)s);
    printLogD();
    return 65335;
  }
  printLogD();
  if ( v113 )
  {
    if ( (unsigned int)DHstrnicmp(v113, *(_BYTE **)&s[8], SHIDWORD(v127)) )
    {
LABEL_100:
      sub_1233C((__int64)s);
      goto LABEL_101;
    }
  }
  else if ( (unsigned int)DHstrnicmp("MELON", *(_BYTE **)&s[8], SHIDWORD(v127)) )
  {
    goto LABEL_100;
  }
  printLogD();
  v86 = DHcurrentTime();
  if ( !v86 )
  {
    sub_1233C((__int64)s);
    return 65433;
  }
  v87 = v86;
  printLogD();
  if ( LOWORD(v130[0]) == 1 )
  {
    if ( v87 > v130[1] )
      goto LABEL_105;
LABEL_109:
    printLogD();
    v88 = DHmalloc(50);
    if ( v88 )
    {
      v89 = v88;
      DHmemset(v88, 0, 50);
      if ( (unsigned int)DHGetDeviceID_ConstVal(v89) )
      {
        DHfree(v89);
        sub_1233C((__int64)s);
        DHstrlen(v89);
        printLogD();
        return 65333;
      }
      v90 = DHstrlen(v89);
      if ( v90 > 0x32 || v90 != DWORD1(v128) )
      {
        DHfree(v89);
        sub_1233C((__int64)s);
        printLogD();
        return 65333;
      }
      printLogD();
      printLogD();
      v91 = DHstrnicmp(v89, (_BYTE *)v125[0], SDWORD1(v128));
      DHfree(v89);
      if ( v91 )
      {
        sub_1233C((__int64)s);
        printLogD();
LABEL_101:
        printLogD();
        return 65335;
      }
      printLogD();
      strcpy(v122, "SS MAC-1 Token Generation");
      printLogD();
      DA_DRM_HASH_SHA1Digest(v127, (uint32x4_t *)&v120, v130[4]);
      printLogD();
      v92 = (int8x16_t *)DHmalloc(DWORD1(v128) + 1);
      if ( v92 )
      {
        v93 = v92;
        DHmemset(v92, 0, DWORD1(v128) + 1);
        inverse((int8x16_t *)v125[0], v93, SDWORD1(v128));
        v94 = v130[3] + v128 + 2 * DWORD1(v128);
        v95 = DHmalloc(v94 + 46);
        if ( v95 )
        {
          v96 = (__int64)v95;
          v97 = v94 + 20;
          DHmemset(v95, 0, v94 + 46);
          DHmemcpy((void *)v96, &v120, 20);
          DHmemcpy((void *)(v96 + 20), v125[1], v130[3]);
          v98 = v130[3] + 20;
          DHmemcpy((void *)(v96 + v130[3] + 20), *((const void **)&v124 + 1), v128);
          v99 = v128 + v98;
          DHmemcpy((void *)(v96 + v99), v125[0], SDWORD1(v128));
          v100 = DWORD1(v128) + v99;
          DHmemcpy((void *)(v96 + v100), v93, SDWORD1(v128));
          DHmemcpy((void *)(v96 + DWORD1(v128) + v100), v122, 25);
          printLogD();
          printLogD();
          DA_DRM_HASH_SHA1Digest(v96, (uint32x4_t *)v118, v97 + 25);
          printLogD();
          DHsprintf_s(
            (char *)&v116,
            21,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            (unsigned __int8)v118[0],
            (unsigned __int8)v118[1],
            (unsigned __int8)v118[2],
            (unsigned __int8)v118[3],
            (unsigned __int8)v118[4],
            v118[5]);
          printLogD();
          DHfree(v93);
          DHfree((void *)v96);
          if ( (unsigned int)DHstrncmp((const char *)v125[2], (const char *)&v116, 20) )
          {
            printLogD();
            sub_1233C((__int64)s);
            return 65335;
          }
          printLogD();
          v101 = *((_QWORD *)&v129 + 1);
          if ( *((_QWORD *)&v129 + 1) )
          {
            while ( 1 )
            {
              v102 = sub_12478(v101, a2);
              if ( (_WORD)v102 )
                break;
              v101 = *(_QWORD *)(v101 + 32);
              if ( !v101 )
                goto LABEL_129;
            }
            v13 = v102;
          }
          else
          {
LABEL_129:
            v103 = DHmalloc(DWORD2(v127) + 1);
            *v109 = (__int64)v103;
            if ( !v103 )
            {
              if ( *a2 )
                ClientIDDestroy((_QWORD *)*a2);
              sub_1233C((__int64)s);
              return 65514;
            }
            DHmemset(v103, 0, DWORD2(v127) + 1);
            DHstrncpy_s(*v109, DWORD2(v127) + 1, v126, DWORD2(v127));
            v104 = *((_QWORD *)&v126 + 1);
            if ( !*((_QWORD *)&v126 + 1) )
            {
LABEL_133:
              *v108 = v125[3];
              sub_1233C((__int64)s);
              return 0;
            }
            while ( 1 )
            {
              v105 = sub_125C0(*(_QWORD *)v104, *(_DWORD *)(v104 + 8), a4);
              if ( (_WORD)v105 )
                break;
              v104 = *(_QWORD *)(v104 + 16);
              if ( !v104 )
                goto LABEL_133;
            }
            v13 = v105;
            if ( *a2 )
              ClientIDDestroy((_QWORD *)*a2);
            DHfree(v109);
          }
          sub_1233C((__int64)s);
          return v13;
        }
        DHfree(v93);
      }
    }
    sub_1233C((__int64)s);
    printLogD();
    return 65514;
  }
  if ( v87 <= v130[2] && v87 >= v130[1] )
    goto LABEL_109;
LABEL_105:
  sub_1233C((__int64)s);
  printLogD();
  return 65334;
}
// 11498: variable 'v107' is possibly undefined
// 115CC: variable 'v106' is possibly undefined

//----- (000000000001233C) ----------------------------------------------------
void __fastcall sub_1233C(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x19
  __int64 v15; // x8
  __int64 v16; // x20

  v2 = *(void **)a1;
  if ( v2 )
    DHfree(v2);
  v3 = *(void **)(a1 + 8);
  if ( v3 )
    DHfree(v3);
  v4 = *(void **)(a1 + 16);
  if ( v4 )
    DHfree(v4);
  v5 = *(void **)(a1 + 24);
  if ( v5 )
    DHfree(v5);
  v6 = *(void **)(a1 + 32);
  if ( v6 )
    DHfree(v6);
  v7 = *(void **)(a1 + 40);
  if ( v7 )
    DHfree(v7);
  v8 = *(void **)(a1 + 48);
  if ( v8 )
    DHfree(v8);
  v9 = *(void **)(a1 + 80);
  if ( v9 )
    DHfree(v9);
  v10 = *(void **)(a1 + 64);
  if ( v10 )
    DHfree(v10);
  v11 = *(_QWORD *)(a1 + 72);
  if ( v11 )
  {
    v12 = *(_QWORD *)(v11 + 16);
    if ( v12 )
    {
      do
      {
        v13 = v12;
        if ( *(_QWORD *)v11 )
          DHfree(*(void **)v11);
        *(_QWORD *)v11 = 0;
        DHfree((void *)v11);
        v12 = *(_QWORD *)(v13 + 16);
        v11 = v13;
      }
      while ( v12 );
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 72);
    }
    if ( *(_QWORD *)v13 )
      DHfree(*(void **)v13);
    *(_QWORD *)v13 = 0;
    DHfree((void *)v13);
  }
  v14 = *(_QWORD *)(a1 + 120);
  if ( v14 )
  {
    v15 = *(_QWORD *)(v14 + 32);
    if ( v15 )
    {
      do
      {
        v16 = v15;
        DHfree(*(void **)(v14 + 16));
        DHfree((void *)v14);
        v15 = *(_QWORD *)(v16 + 32);
        v14 = v16;
      }
      while ( v15 );
    }
    else
    {
      v16 = v14;
    }
    DHfree(*(void **)(v16 + 16));
    DHfree((void *)v16);
  }
}

//----- (0000000000012478) ----------------------------------------------------
__int64 __fastcall sub_12478(__int64 a1, __int64 *a2)
{
  void *v4; // x0
  __int64 v5; // x19
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 result; // x0

  v4 = DHmalloc(81);
  if ( !v4 )
    return 65514;
  v5 = (__int64)v4;
  DHmemset(v4, 0, 16);
  DHmemset((void *)(v5 + 16), 0, 51);
  *(_QWORD *)(v5 + 72) = 0;
  DHstrncpy_s(v5, 16, a1, 0x10u);
  DHmemset((void *)(v5 + 16), 0, 51);
  DHstrncpy_s(v5 + 16, 51, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
  v6 = *a2;
  if ( *a2 )
  {
    do
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 72);
    }
    while ( v6 );
    a2 = (__int64 *)(v7 + 72);
  }
  result = 0;
  *a2 = v5;
  return result;
}

//----- (0000000000012530) ----------------------------------------------------
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  _QWORD *v1; // x8
  _QWORD *v2; // x20
  _QWORD *v3; // x19

  if ( a1 )
  {
    v1 = (_QWORD *)a1[9];
    v2 = a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        DHmemset(v2, 0, 16);
        DHmemset(v2 + 2, 0, 51);
        DHfree(v2);
        v1 = (_QWORD *)v3[9];
        v2 = v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    DHmemset(v3, 0, 16);
    DHmemset(v3 + 2, 0, 51);
    DHfree(v3);
  }
}

//----- (00000000000125C0) ----------------------------------------------------
__int64 __fastcall sub_125C0(__int64 a1, unsigned int a2, __int64 **a3)
{
  __int64 *v6; // x0
  __int64 *v7; // x19
  void *v8; // x0
  __int64 *v9; // x8
  __int64 *v10; // x9
  __int64 result; // x0

  v6 = (__int64 *)DHmalloc(25);
  if ( !v6 )
    return 65514;
  v7 = v6;
  *v6 = 0;
  v6[2] = 0;
  *((_DWORD *)v6 + 2) = a2;
  v8 = DHmalloc(a2 + 1);
  *v7 = (__int64)v8;
  if ( v8 )
  {
    DHmemset(v8, 0, a2 + 1);
    DHstrncpy_s(*v7, a2 + 1, a1, a2);
    v9 = *a3;
    if ( *a3 )
    {
      do
      {
        v10 = v9;
        v9 = (__int64 *)v9[2];
      }
      while ( v9 );
      result = 0;
      v10[2] = (__int64)v7;
    }
    else
    {
      result = 0;
      *a3 = v7;
    }
  }
  else
  {
    DHfree(v7);
    return 65514;
  }
  return result;
}

//----- (0000000000012678) ----------------------------------------------------
void __fastcall DomainListDestroy(__int64 a1)
{
  __int64 v1; // x8
  void **v2; // x20
  __int64 v3; // x19

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 16);
    v2 = (void **)a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        if ( *v2 )
          DHfree(*v2);
        *v2 = 0;
        DHfree(v2);
        v1 = *(_QWORD *)(v3 + 16);
        v2 = (void **)v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    if ( *(_QWORD *)v3 )
      DHfree(*(void **)v3);
    *(_QWORD *)v3 = 0;
    DHfree((void *)v3);
  }
}

//----- (00000000000126E8) ----------------------------------------------------
__int64 __fastcall sub_126E8(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6)
{
  int v12; // w9
  __int64 v13; // x10
  __int64 v14; // x8
  int v15; // w10
  int v16; // w9
  unsigned __int8 *v17; // x10
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // w10
  __int64 v21; // x11

  *a4 = 0;
  *a6 = 0;
  DHmemset(a3, 0, 16);
  DHmemset(a5, 0, 64);
  printLogD();
  while ( 1 )
  {
    v12 = *a1++;
    if ( v12 == 61 || v12 == 58 )
      break;
    if ( v12 == 32 )
    {
      --a2;
    }
    else
    {
      v13 = *a4;
      if ( (int)v13 >= 17 )
      {
LABEL_16:
        printLogD();
        return 65335;
      }
      *a4 = v13 + 1;
      *((_BYTE *)a3 + v13) = v12;
    }
  }
  *((_BYTE *)a3 + *a4) = 0;
  v14 = 0;
  do
    v15 = a1[v14++];
  while ( v15 == 32 );
  v16 = a2 - *a4;
  if ( ~(_DWORD)v14 + v16 >= 1 )
  {
    v17 = &a1[v14];
    v18 = v16 - v14;
    v19 = v17 - 1;
    do
    {
      v20 = *v19;
      if ( v20 == 32 )
        break;
      v21 = *a6;
      if ( (int)v21 >= 65 )
        goto LABEL_16;
      --v18;
      ++v19;
      *a6 = v21 + 1;
      *((_BYTE *)a5 + v21) = v20;
    }
    while ( v18 > 1 );
  }
  *((_BYTE *)a5 + *a6) = 0;
  printLogD();
  return 0;
}

//----- (000000000001287C) ----------------------------------------------------
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3)
{
  unsigned int v6; // w20
  int v7; // w3
  int v8; // w4
  void *v9; // x0
  int v10; // w8
  void *v12; // x0
  int v13; // w8
  int v14; // w21
  int v15; // w8
  int v16; // w21
  int v17; // w3
  int v18; // w22
  unsigned __int8 *v19; // x0
  unsigned __int8 *v20; // x21
  int v21; // w24
  unsigned __int8 *v22; // x13
  int v23; // w9
  unsigned __int8 *v24; // x8
  int v25; // w23
  int v26; // w10
  __int64 v27; // x9
  char *v28; // x8
  int v29; // w8
  __int64 v30; // x12
  char *v31; // x8
  char *v32; // x11
  __int64 v33; // x21
  int v34; // w10
  unsigned __int8 *v35; // x13
  unsigned __int8 *v36; // x9
  int v37; // w11
  int v38; // t1
  int v39; // w26
  int v40; // w24
  void *v41; // x0
  int v42; // w24
  void *v43; // x0
  int v44; // w23
  char *v45; // x10
  int v46; // w9
  __int64 v47; // x8
  unsigned __int8 *v48; // x9
  int v49; // w11
  unsigned __int8 *v50; // x10
  int v51; // w12
  int v52; // t1
  int v53; // w26
  int v54; // w21
  int v55; // w24
  void *v56; // x0
  int v57; // w24
  void *v58; // x0
  int v59; // w23
  char *v60; // x10
  int v61; // w9
  __int64 v62; // x8
  unsigned __int8 *v63; // x9
  int v64; // w11
  unsigned __int8 *v65; // x10
  int v66; // w12
  int v67; // t1
  int v68; // w24
  int v69; // w26
  int v70; // w21
  void *v71; // x0
  int v72; // w21
  void *v73; // x0
  int v74; // w24
  void *v75; // x0
  int v76; // w24
  void *v77; // x0
  int v78; // w24
  int v79; // w24
  void *v80; // x0
  int v81; // w21
  void *v82; // x0
  int v83; // w24
  void *v84; // x0
  char *v85; // x10
  int v86; // w9
  __int64 v87; // x8
  unsigned __int8 *v88; // x9
  int v89; // w11
  unsigned __int8 *v90; // x10
  int v91; // w12
  int v92; // t1
  int v93; // w26
  int v94; // w23
  __int64 v95; // x21
  void *v96; // x0
  __int64 v97; // x24
  __int64 v98; // x8
  __int64 v99; // x9
  __int64 v100; // x24
  int i; // w8
  void *v102; // x0
  int v103; // w21
  void *v104; // x0
  int v105; // w24
  void *v106; // x0
  int v107; // w21
  char *v108; // x10
  int v109; // w9
  __int64 v110; // x8
  unsigned __int8 *v111; // x9
  int v112; // w11
  unsigned __int8 *v113; // x10
  int v114; // w12
  int v115; // t1
  int v116; // w26
  int v117; // w23
  int v118; // w24
  void *v119; // x0
  void *v120; // x0
  int v121; // w24
  void *v122; // x0
  void *v123; // x0
  int v124; // w24
  void *v125; // x0
  void *v126; // x21
  const char *v127; // x0
  const char *v128; // x24
  void *v129; // x0
  char *v130; // x0
  __int64 v131; // x24
  int v132; // w21
  __int64 v133; // x21
  unsigned __int64 v134; // x21
  __int64 v135; // x21
  unsigned __int16 v136; // w24
  __int64 v137; // x24
  unsigned __int64 v138; // x21
  const char *v139; // x0
  const char *v140; // x24
  void *v141; // x0
  char *v142; // x0
  char *v143; // x10
  int v144; // w9
  __int64 v145; // x8
  unsigned __int8 *v146; // x9
  int v147; // w11
  unsigned __int8 *v148; // x10
  int v149; // w12
  int v150; // t1
  int v151; // w26
  int v152; // w23
  int v153; // w24
  void *v154; // x0
  int v155; // w24
  void *v156; // x0
  __int64 v157; // x23
  int v158; // w22
  int v159; // w24
  int v160; // w0
  void *v161; // x0
  __int64 j; // x23
  char *v163; // x26
  int v164; // w0
  char *v165; // x26
  int v166; // w0
  char *v167; // x24
  int v168; // w0
  char *v169; // x24
  int v170; // w0
  _BYTE *v171; // x0
  int v172; // w8
  char *v173; // x0
  unsigned __int64 v174; // [xsp+8h] [xbp-C78h]
  unsigned __int64 v175; // [xsp+10h] [xbp-C70h]
  int v176; // [xsp+18h] [xbp-C68h]
  char *v177; // [xsp+18h] [xbp-C68h]
  int v178; // [xsp+18h] [xbp-C68h]
  void **v179; // [xsp+20h] [xbp-C60h]
  void **v180; // [xsp+28h] [xbp-C58h]
  void **v181; // [xsp+30h] [xbp-C50h]
  void **v182; // [xsp+38h] [xbp-C48h]
  void *v183; // [xsp+40h] [xbp-C40h]
  unsigned __int8 *v184; // [xsp+50h] [xbp-C30h]
  int v185; // [xsp+5Ch] [xbp-C24h] BYREF
  int v186; // [xsp+60h] [xbp-C20h] BYREF
  _BYTE ptr[514]; // [xsp+64h] [xbp-C1Ch] BYREF
  _BYTE v188[10]; // [xsp+266h] [xbp-A1Ah] BYREF
  _BYTE v189[256]; // [xsp+270h] [xbp-A10h] BYREF
  _BYTE v190[256]; // [xsp+370h] [xbp-910h] BYREF
  char v191[2048]; // [xsp+470h] [xbp-810h] BYREF
  __int64 v192; // [xsp+C70h] [xbp-10h]

  v192 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  DHmemset(ptr, 0, 512);
  if ( (int)DHfsRead(a1, ptr, 3) < 3 )
  {
    v6 = 65523;
    goto LABEL_7;
  }
  v7 = ptr[1];
  v8 = ptr[2];
  *(_WORD *)a2 = ptr[0];
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  printLogD();
  if ( *(_WORD *)a2 != 1 )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  v9 = DHmalloc(*(_DWORD *)(a2 + 4) + 1);
  v10 = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a2 + 16) = v9;
  DHmemset(v9, 0, v10 + 1);
  if ( (int)DHfsRead(a1, *(void **)(a2 + 16), *(_DWORD *)(a2 + 4)) < *(_DWORD *)(a2 + 4) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v12 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  v13 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 24) = v12;
  DHmemset(v12, 0, v13 + 1);
  if ( (int)DHfsRead(a1, *(void **)(a2 + 24), *(_DWORD *)(a2 + 8)) < *(_DWORD *)(a2 + 8) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v14 = 0;
  while ( (int)DHfsRead(a1, v191, 1) >= 1 )
  {
    v15 = v191[0] & 0x7F | (v14 << 7);
    v14 = v15;
    if ( (v191[0] & 0x80) == 0 )
      goto LABEL_15;
  }
  v15 = -1;
LABEL_15:
  v16 = 0;
  *(_DWORD *)(a2 + 32) = v15;
  while ( (int)DHfsRead(a1, v191, 1) >= 1 )
  {
    v17 = v191[0] & 0x7F | (v16 << 7);
    v16 = v17;
    if ( (v191[0] & 0x80) == 0 )
      goto LABEL_20;
  }
  v17 = -1;
LABEL_20:
  *(_DWORD *)(a2 + 36) = v17;
  printLogD();
  v18 = *(_DWORD *)(a2 + 32);
  if ( !v18 )
  {
    *a3 = 0;
    v6 = 65528;
    goto LABEL_7;
  }
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 68) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  v182 = (void **)(a2 + 88);
  *(_QWORD *)(a2 + 192) = 0;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_QWORD *)(a2 + 200) = 0;
  *(_QWORD *)(a2 + 208) = 0;
  *(_DWORD *)(a2 + 216) = 0;
  *(_OWORD *)(a2 + 240) = 0u;
  printLogD();
  v19 = (unsigned __int8 *)DHmalloc(v18 + 1);
  if ( !v19 )
    goto LABEL_242;
  v20 = v19;
  v179 = (void **)(a2 + 192);
  v180 = (void **)(a2 + 224);
  v181 = (void **)(a2 + 40);
  v21 = DHfsRead(a1, v19, v18);
  printLogD();
  printLogD();
  v183 = v20;
  v20[v21] = 0;
  if ( v18 >= 1 )
  {
    v22 = v20;
    while ( 1 )
    {
      v23 = 0;
      v24 = v22;
      while ( 1 )
      {
        v26 = *v24;
        if ( v26 == 13 )
          break;
        ++v24;
LABEL_29:
        v25 = v23 + 1;
        v191[v23] = v26;
        v23 = v25;
        if ( v18 <= v25 )
          goto LABEL_33;
      }
      v191[v23] = 13;
      v25 = v23 + 1;
      v26 = v24[1];
      if ( v26 != 10 )
      {
        v24 += 2;
        ++v23;
        goto LABEL_29;
      }
LABEL_33:
      v27 = v25;
      v28 = &v191[v25];
      if ( v18 <= v25 )
      {
        *v28 = 0;
      }
      else
      {
        ++v25;
        *(v28 - 1) = 0;
        v27 = v25;
      }
      v29 = (unsigned __int8)v191[0];
      v185 = 0;
      if ( v191[0] == 32 )
      {
        v30 = 0;
        do
        {
          v31 = &v191[v30++];
          v29 = (unsigned __int8)v31[1];
        }
        while ( v29 == 32 );
        v185 = v30;
        v32 = &v191[v30];
      }
      else
      {
        LODWORD(v30) = 0;
        v32 = v191;
      }
      v33 = (int)v30;
      v34 = 0;
      v35 = &v22[v27];
      v18 -= v25;
      v36 = (unsigned __int8 *)(v32 + 1);
      while ( 2 )
      {
        if ( v29 > 58 )
        {
          if ( v29 == 59 )
          {
            v37 = 0;
          }
          else
          {
            if ( v29 == 61 )
              goto LABEL_51;
LABEL_50:
            v37 = v34 + 1;
            v190[v34] = v29;
          }
          ++v33;
          v38 = *v36++;
          v29 = v38;
          v185 = v33;
          v34 = v37;
          continue;
        }
        break;
      }
      if ( v29 && v29 != 58 )
        goto LABEL_50;
LABEL_51:
      v184 = v35;
      v190[v34] = 0;
      sub_1635C(&v191[v33 + 1], (__int64)v189, &v186, &v185);
      v39 = v185 + v33 + 2;
      if ( !(unsigned int)DHstrnicmp("encryption-method", v190, 17) )
        break;
      if ( !(unsigned int)DHstrnicmp("Service-Name", v190, 12) )
      {
        printLogD();
        v57 = v186;
        v58 = DHmalloc(v186 + 1);
        *v181 = v58;
        if ( !v58 )
          goto LABEL_248;
        DHmemset(v58, 0, v57 + 1);
        DHmemcpy(*v181, v189, v57);
        v59 = v25 - 1;
        while ( 1 )
        {
          v60 = &v191[v39];
          v185 = 0;
          v61 = (unsigned __int8)*v60;
          if ( v61 == 32 )
          {
            v62 = 0;
            do
            {
              v63 = (unsigned __int8 *)&v60[v62++];
              v61 = v63[1];
            }
            while ( v61 == 32 );
            v185 = v62;
            v60 += v62;
          }
          else
          {
            LODWORD(v62) = 0;
          }
          v64 = 0;
          v65 = (unsigned __int8 *)(v60 + 1);
          while ( v61 > 58 )
          {
            if ( v61 == 59 )
            {
              v66 = 0;
              goto LABEL_99;
            }
            if ( v61 == 61 )
              goto LABEL_107;
LABEL_106:
            v66 = v64 + 1;
            v190[v64] = v61;
LABEL_99:
            LODWORD(v62) = v62 + 1;
            v67 = *v65++;
            v61 = v67;
            v185 = v62;
            v64 = v66;
          }
          if ( v61 && v61 != 58 )
            goto LABEL_106;
LABEL_107:
          v68 = v39 + v62;
          v190[v64] = 0;
          sub_1635C(&v191[v39 + 1 + (int)v62], (__int64)v189, &v186, &v185);
          v69 = v185;
          if ( !(unsigned int)DHstrnicmp("cidType", v190, 7) )
          {
            v70 = v186;
            v71 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 48) = v71;
            if ( !v71 )
              goto LABEL_248;
            DHmemset(v71, 0, v70 + 1);
            DHmemcpy(*(void **)(a2 + 48), v189, v70 + 1);
          }
          if ( !(unsigned int)DHstrnicmp("eServiceCode", v190, 12) )
          {
            v72 = v186;
            v73 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 56) = v73;
            if ( !v73 )
              goto LABEL_248;
            DHmemset(v73, 0, v72 + 1);
            DHmemcpy(*(void **)(a2 + 56), v189, v72 + 1);
          }
          v39 = v68 + v69 + 2;
          if ( v39 >= v59 )
            goto LABEL_25;
        }
      }
      if ( !(unsigned int)DHstrnicmp("rights-issuer", v190, 13) )
      {
        printLogD();
        v74 = v186;
        v75 = DHmalloc(v186 + 1);
        *v182 = v75;
        if ( !v75 )
          goto LABEL_248;
        DHmemset(v75, 0, v74 + 1);
        DHmemcpy(*v182, v189, v74);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-name", v190, 12) )
      {
        printLogD();
        v76 = v186;
        v77 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 96) = v77;
        if ( !v77 )
          goto LABEL_248;
        DHmemset(v77, 0, v76 + 1);
        DHmemcpy(*(void **)(a2 + 96), v189, v76);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-description", v190, 19) )
      {
        printLogD();
        v78 = v186;
        *(_QWORD *)(a2 + 104) = DHmalloc(v186 + 1);
        printLogD();
        if ( !*(_QWORD *)(a2 + 104) )
        {
          printLogD();
          DHfree(v183);
          goto LABEL_241;
        }
        printLogD();
        printLogD();
        DHmemset(*(void **)(a2 + 104), 0, v78 + 1);
        DHmemcpy(*(void **)(a2 + 104), v189, v78);
        printLogD();
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-vendor", v190, 14) )
      {
        printLogD();
        v79 = v186;
        v80 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 112) = v80;
        if ( !v80 )
          goto LABEL_248;
        DHmemset(v80, 0, v79 + 1);
        DHmemcpy(*(void **)(a2 + 112), v189, v79);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("icon-uri", v190, 8) )
      {
        printLogD();
        v81 = v186;
        v82 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 120) = v82;
        if ( !v82 )
          goto LABEL_248;
        DHmemset(v82, 0, v81 + 1);
        DHmemcpy(*(void **)(a2 + 120), v189, v81 + 1);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("eTarget", v190, 7) )
      {
        printLogD();
        v100 = 0;
        for ( i = v189[0]; v189[v100]; i = (unsigned __int8)v189[v100] )
        {
          if ( i == 44 )
            break;
          ++v100;
        }
        v102 = DHmalloc((int)v100 + 1);
        *(_QWORD *)(a2 + 128) = v102;
        if ( !v102 )
          goto LABEL_248;
        DHmemset(v102, 0, v100 + 1);
        DHmemcpy(*(void **)(a2 + 128), v189, v100);
        DHstrlwr(*(_BYTE **)(a2 + 128));
        v103 = v186;
        v104 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 136) = v104;
        if ( !v104 )
          goto LABEL_248;
        DHmemset(v104, 0, v103 + 1);
        DHmemcpy(*(void **)(a2 + 136), &v189[v100 + 1], ~(_DWORD)v100 + v103);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("eCEK", v190, 4) )
      {
        printLogD();
        v105 = v186;
        v106 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 144) = v106;
        if ( !v106 )
          goto LABEL_248;
        DHmemset(v106, 0, v105 + 1);
        DHmemcpy(*(void **)(a2 + 144), v189, v105);
        v107 = v25 - 1;
        while ( 1 )
        {
          v108 = &v191[v39];
          v185 = 0;
          v109 = (unsigned __int8)*v108;
          if ( v109 == 32 )
          {
            v110 = 0;
            do
            {
              v111 = (unsigned __int8 *)&v108[v110++];
              v109 = v111[1];
            }
            while ( v109 == 32 );
            v185 = v110;
            v108 += v110;
          }
          else
          {
            LODWORD(v110) = 0;
          }
          v112 = 0;
          v113 = (unsigned __int8 *)(v108 + 1);
          while ( v109 > 58 )
          {
            if ( v109 == 59 )
            {
              v114 = 0;
              goto LABEL_167;
            }
            if ( v109 == 61 )
              goto LABEL_175;
LABEL_174:
            v114 = v112 + 1;
            v190[v112] = v109;
LABEL_167:
            LODWORD(v110) = v110 + 1;
            v115 = *v113++;
            v109 = v115;
            v185 = v110;
            v112 = v114;
          }
          if ( v109 && v109 != 58 )
            goto LABEL_174;
LABEL_175:
          v116 = v39 + v110;
          v190[v112] = 0;
          sub_1635C(&v191[v116 + 1], (__int64)v189, &v186, &v185);
          v117 = v185;
          if ( (unsigned int)DHstrnicmp("cidType", v190, 7) )
          {
            if ( (unsigned int)DHstrnicmp("dMethod", v190, 7) )
            {
              if ( !(unsigned int)DHstrnicmp("eValue", v190, 6) )
              {
                v118 = v186;
                v119 = DHmalloc(v186 + 1);
                *(_QWORD *)(a2 + 168) = v119;
                if ( !v119 )
                  goto LABEL_248;
                DHmemset(v119, 0, v118 + 1);
                v120 = *(void **)(a2 + 168);
                goto LABEL_158;
              }
            }
            else
            {
              v118 = v186;
              v123 = DHmalloc(v186 + 1);
              *(_QWORD *)(a2 + 160) = v123;
              if ( !v123 )
                goto LABEL_248;
              DHmemset(v123, 0, v118 + 1);
              v120 = *(void **)(a2 + 160);
LABEL_158:
              DHmemcpy(v120, v189, v118);
            }
          }
          else
          {
            v121 = v186;
            v122 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 152) = v122;
            if ( !v122 )
              goto LABEL_248;
            DHmemset(v122, 0, v121 + 1);
            DHmemcpy(*(void **)(a2 + 152), v189, v121);
            DHstrlwr(*(_BYTE **)(a2 + 152));
          }
          v39 = v116 + v117 + 2;
          if ( v39 >= v107 )
            goto LABEL_25;
        }
      }
      if ( (unsigned int)DHstrnicmp("Usage-Control", v190, 13) )
      {
        if ( (unsigned int)DHstrnicmp("Meta-Container", v190, 14) )
          goto LABEL_26;
        printLogD();
        v40 = v186;
        v41 = DHmalloc(v186 + 1);
        *v180 = v41;
        if ( !v41 )
          goto LABEL_248;
        DHmemset(v41, 0, v40 + 1);
        DHmemcpy(*v180, v189, v40);
        v176 = v25 - 1;
        while ( 2 )
        {
          v85 = &v191[v39];
          v185 = 0;
          v86 = (unsigned __int8)*v85;
          if ( v86 == 32 )
          {
            v87 = 0;
            do
            {
              v88 = (unsigned __int8 *)&v85[v87++];
              v86 = v88[1];
            }
            while ( v86 == 32 );
            v185 = v87;
            v85 += v87;
          }
          else
          {
            LODWORD(v87) = 0;
          }
          v89 = 0;
          v90 = (unsigned __int8 *)(v85 + 1);
LABEL_135:
          if ( v86 <= 58 )
          {
            if ( !v86 || v86 == 58 )
            {
LABEL_142:
              v93 = v39 + v87;
              v190[v89] = 0;
              sub_1635C(&v191[v93 + 1], (__int64)v189, &v186, &v185);
              v94 = v185;
              if ( (unsigned int)DHstrnicmp("encoding", v190, 8) )
              {
                v95 = *(_QWORD *)(a2 + 248);
                v96 = DHmalloc(648);
                v97 = (__int64)v96;
                if ( v95 )
                {
                  if ( !v96 )
                    goto LABEL_248;
                  DHmemset(v96, 0, 648);
                  DHstrncpy_s(v97, 128, (__int64)v190, 0x14u);
                  DHstrncpy_s(v97 + 128, 512, (__int64)v189, 0xFFu);
                  *(_QWORD *)(v97 + 640) = 0;
                  v98 = *(_QWORD *)(a2 + 248);
                  do
                  {
                    v99 = v98;
                    v98 = *(_QWORD *)(v98 + 640);
                  }
                  while ( v98 );
                  *(_QWORD *)(v99 + 640) = v97;
LABEL_126:
                  v39 = v93 + v94 + 2;
                  if ( v39 >= v176 )
                    goto LABEL_26;
                  continue;
                }
                *(_QWORD *)(a2 + 248) = v96;
                if ( v96 )
                {
                  DHmemset(v96, 0, 648);
                  DHstrncpy_s(*(_QWORD *)(a2 + 248), 128, (__int64)v190, 0x14u);
                  DHstrncpy_s(*(_QWORD *)(a2 + 248) + 128LL, 512, (__int64)v189, 0xFFu);
                  *(_QWORD *)(*(_QWORD *)(a2 + 248) + 640LL) = 0;
                  goto LABEL_126;
                }
              }
              else
              {
                v83 = v186;
                v84 = DHmalloc(v186 + 1);
                *(_QWORD *)(a2 + 232) = v84;
                if ( v84 )
                {
                  DHmemset(v84, 0, v83 + 1);
                  DHmemcpy(*(void **)(a2 + 232), v189, v83);
                  goto LABEL_126;
                }
              }
LABEL_248:
              DHfree(v183);
LABEL_241:
              printLogD();
LABEL_242:
              v6 = 65528;
              goto LABEL_7;
            }
LABEL_141:
            v91 = v89 + 1;
            v190[v89] = v86;
          }
          else
          {
            if ( v86 != 59 )
            {
              if ( v86 == 61 )
                goto LABEL_142;
              goto LABEL_141;
            }
            v91 = 0;
          }
          break;
        }
        LODWORD(v87) = v87 + 1;
        v92 = *v90++;
        v86 = v92;
        v185 = v87;
        v89 = v91;
        goto LABEL_135;
      }
      printLogD();
      v124 = v186;
      v125 = DHmalloc(v186 + 1);
      if ( !v125 )
        goto LABEL_249;
      v126 = v125;
      DHmemset(v125, 0, v124 + 1);
      DHmemcpy(v126, v189, v124);
      v127 = DHstristr((const char *)v126, "Time-Not-After");
      v177 = (char *)v126;
      if ( v127 )
      {
        v128 = v127;
        v129 = DHmalloc(19);
        *(_QWORD *)(a2 + 176) = v129;
        if ( !v129 )
        {
          DHfree(v183);
          v173 = (char *)v126;
          goto LABEL_250;
        }
        DHmemset(v129, 0, 19);
        DHmemcpy(*(void **)(a2 + 176), v128 + 15, 18);
        v130 = DHstrchr(*(const char **)(a2 + 176), 0x2Cu);
        if ( v130 )
          *v130 = 0;
        v131 = *(_QWORD *)(a2 + 176);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)v131, 4);
        v132 = (unsigned __int16)DHatoi();
        if ( v132 == 2099 )
          *(_DWORD *)(a2 + 216) = 1;
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 4), 2);
        v133 = v132 | ((unsigned int)DHatoi() << 16);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 6), 2);
        v134 = v133 | ((unsigned __int64)(unsigned __int16)DHatoi() << 32);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 8), 2);
        v174 = v134 | (DHatoi() << 48);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 10), 2);
        v135 = v131;
        v136 = DHatoi();
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v135 + 12), 2);
        v137 = v136 | ((unsigned __int16)DHatoi() << 16);
        v138 = v175 & 0xFFFFFFFF00000000LL | v137;
        *(_DWORD *)(a2 + 184) = DHmktime(v174, v137);
        printLogD();
      }
      else
      {
        v138 = v175;
      }
      v139 = DHstristr(v177, "Allowable-Services");
      v175 = v138;
      if ( v139 )
      {
        v140 = v139;
        v141 = DHmalloc(9);
        *v179 = v141;
        if ( !v141 )
        {
          DHfree(v183);
          v173 = v177;
          goto LABEL_250;
        }
        DHmemset(v141, 0, 9);
        DHmemcpy(*v179, v140 + 19, 8);
        v142 = DHstrchr((const char *)*v179, 0x2Cu);
        if ( v142 )
          *v142 = 0;
      }
      DHfree(v177);
      v178 = v25 - 1;
      while ( 2 )
      {
        v143 = &v191[v39];
        v185 = 0;
        v144 = (unsigned __int8)*v143;
        if ( v144 == 32 )
        {
          v145 = 0;
          do
          {
            v146 = (unsigned __int8 *)&v143[v145++];
            v144 = v146[1];
          }
          while ( v144 == 32 );
          v185 = v145;
          v143 += v145;
        }
        else
        {
          LODWORD(v145) = 0;
        }
        v147 = 0;
        v148 = (unsigned __int8 *)(v143 + 1);
        while ( 2 )
        {
          if ( v144 > 58 )
          {
            if ( v144 == 59 )
            {
              v149 = 0;
            }
            else
            {
              if ( v144 == 61 )
                goto LABEL_215;
LABEL_214:
              v149 = v147 + 1;
              v190[v147] = v144;
            }
            LODWORD(v145) = v145 + 1;
            v150 = *v148++;
            v144 = v150;
            v185 = v145;
            v147 = v149;
            continue;
          }
          break;
        }
        if ( v144 && v144 != 58 )
          goto LABEL_214;
LABEL_215:
        v151 = v39 + v145;
        v190[v147] = 0;
        sub_1635C(&v191[v151 + 1], (__int64)v189, &v186, &v185);
        v152 = v185;
        if ( (unsigned int)DHstrnicmp("cidType", v190, 7) )
        {
          if ( (unsigned int)DHstrnicmp("eAuthCode", v190, 9) )
            goto LABEL_199;
          v153 = v186;
          v154 = DHmalloc(v186 + 1);
          *(_QWORD *)(a2 + 208) = v154;
          if ( v154 )
          {
            DHmemset(v154, 0, v153 + 1);
            DHmemcpy(*(void **)(a2 + 208), v189, v153);
            goto LABEL_199;
          }
LABEL_249:
          v173 = (char *)v183;
LABEL_250:
          DHfree(v173);
          goto LABEL_241;
        }
        v155 = v186;
        v156 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 200) = v156;
        if ( !v156 )
          goto LABEL_249;
        DHmemset(v156, 0, v155 + 1);
        DHmemcpy(*(void **)(a2 + 200), v189, v155);
        DHstrlwr(*(_BYTE **)(a2 + 200));
LABEL_199:
        v39 = v151 + v152 + 2;
        if ( v39 < v178 )
          continue;
        break;
      }
LABEL_25:
      printLogD();
      printLogD();
LABEL_26:
      v22 = v184;
      if ( v18 <= 0 )
        goto LABEL_222;
    }
    printLogD();
    v42 = v186;
    v43 = DHmalloc(v186 + 1);
    *(_QWORD *)(a2 + 64) = v43;
    if ( !v43 )
      goto LABEL_248;
    DHmemset(v43, 0, v42 + 1);
    DHmemcpy(*(void **)(a2 + 64), v189, v42);
    v44 = v25 - 1;
LABEL_68:
    v45 = &v191[v39];
    v185 = 0;
    v46 = (unsigned __int8)*v45;
    if ( v46 == 32 )
    {
      v47 = 0;
      do
      {
        v48 = (unsigned __int8 *)&v45[v47++];
        v46 = v48[1];
      }
      while ( v46 == 32 );
      v185 = v47;
      v45 += v47;
    }
    else
    {
      LODWORD(v47) = 0;
    }
    v49 = 0;
    v50 = (unsigned __int8 *)(v45 + 1);
    while ( 1 )
    {
      if ( v46 <= 58 )
      {
        if ( !v46 || v46 == 58 )
        {
LABEL_83:
          v53 = v39 + v47;
          v190[v49] = 0;
          sub_1635C(&v191[v53 + 1], (__int64)v189, &v186, &v185);
          v54 = v185;
          if ( (unsigned int)DHstrnicmp("padding", v190, 7) )
          {
            if ( (unsigned int)DHstrnicmp("plaintextlen", v190, 12) )
            {
              if ( !(unsigned int)DHstrnicmp("hlen", v190, 4) )
                *(_DWORD *)(a2 + 84) = DHatoi();
            }
            else
            {
              *(_DWORD *)(a2 + 80) = DHatoi();
            }
          }
          else
          {
            v55 = v186;
            v56 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 72) = v56;
            if ( !v56 )
              goto LABEL_248;
            DHmemset(v56, 0, v55 + 1);
            DHmemcpy(*(void **)(a2 + 72), v189, v55);
          }
          v39 = v53 + v54 + 2;
          if ( v39 >= v44 )
            goto LABEL_25;
          goto LABEL_68;
        }
      }
      else
      {
        if ( v46 == 59 )
        {
          v51 = 0;
          goto LABEL_75;
        }
        if ( v46 == 61 )
          goto LABEL_83;
      }
      v51 = v49 + 1;
      v190[v49] = v46;
LABEL_75:
      LODWORD(v47) = v47 + 1;
      v52 = *v50++;
      v46 = v52;
      v185 = v47;
      v49 = v51;
    }
  }
LABEL_222:
  if ( *(_QWORD *)(a2 + 248) )
  {
    printLogD();
    v157 = *(_QWORD *)(a2 + 248);
    if ( v157 )
    {
      v158 = 1;
      do
      {
        v159 = DHstrlen((const char *)v157);
        v160 = DHstrlen((const char *)(v157 + 128));
        v157 = *(_QWORD *)(v157 + 640);
        v158 += v159 + v160 + 2;
      }
      while ( v157 );
    }
    else
    {
      v158 = 1;
    }
    v161 = DHmalloc(v158);
    *(_QWORD *)(a2 + 240) = v161;
    if ( !v161 )
    {
      DHfree(v183);
      goto LABEL_242;
    }
    DHmemset(v161, 0, v158);
    for ( j = *(_QWORD *)(a2 + 248); *(_QWORD *)(j + 640); j = *(_QWORD *)(j + 640) )
    {
      v163 = *(char **)(a2 + 240);
      v164 = DHstrlen((const char *)j);
      DHstrncat_s(v163, v158, j, v164);
      DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)"=", 1);
      v165 = *(char **)(a2 + 240);
      v166 = DHstrlen((const char *)(j + 128));
      DHstrncat_s(v165, v158, j + 128, v166);
      DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)";", 1);
    }
    v167 = *(char **)(a2 + 240);
    v168 = DHstrlen((const char *)j);
    DHstrncat_s(v167, v158, j, v168);
    DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)"=", 1);
    v169 = *(char **)(a2 + 240);
    v170 = DHstrlen((const char *)(j + 128));
    DHstrncat_s(v169, v158, j + 128, v170);
  }
  DHfree(v183);
  if ( !*(_QWORD *)(a2 + 128) )
    goto LABEL_241;
  printLogD();
  v171 = *(_BYTE **)(a2 + 64);
  if ( v171 )
  {
    if ( (unsigned int)DHstrnicmp(v171, "aes128ecb", 255) )
    {
      if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cbc", 255) )
      {
        if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cfb1", 255) )
          v172 = 0;
        else
          v172 = 3;
      }
      else
      {
        v172 = 2;
      }
    }
    else
    {
      v172 = 1;
    }
  }
  else
  {
    v172 = 0;
  }
  v6 = 0;
  *a3 = v172;
LABEL_7:
  printLogD();
  return v6;
}
// 13AC8: variable 'v175' is possibly undefined

//----- (0000000000014100) ----------------------------------------------------
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  __int64 v4; // d0
  void *v5; // x0
  void *v6; // x0
  int v7; // w8
  int v8; // w9
  const char *v9; // x0
  int v10; // w0
  void *v11; // x0
  void *v12; // x21
  int v13; // w0
  const char *v14; // x22
  void *v15; // x21
  int v16; // w0
  const char *v17; // x0
  int v18; // w0
  void *v19; // x0
  void *v20; // x21
  int v21; // w0
  const char *v22; // x22
  void *v23; // x21
  int v24; // w0
  const char *v25; // x0
  int v26; // w0
  void *v27; // x0
  void *v28; // x21
  int v29; // w0
  const char *v30; // x22
  void *v31; // x21
  int v32; // w0
  const char *v33; // x0
  int v34; // w0
  void *v35; // x0
  void *v36; // x21
  int v37; // w0
  const char *v38; // x22
  void *v39; // x21
  int v40; // w0
  __int64 result; // x0
  _BYTE *v42; // x0
  _BYTE *v43; // x0
  _BYTE *v44; // x0
  _BYTE *v45; // x0
  const char *v46; // x0
  int v47; // w0
  void *v48; // x0
  void *v49; // x21
  int v50; // w0
  const char *v51; // x22
  void *v52; // x21
  int v53; // w0
  _BYTE *v54; // x0
  const char *v55; // x0
  int v56; // w0
  void *v57; // x0
  void *v58; // x21
  int v59; // w0
  const char *v60; // x22
  void *v61; // x21
  int v62; // w0
  _BYTE *v63; // x0
  const char *v64; // x0
  int v65; // w0
  void *v66; // x0
  void *v67; // x21
  int v68; // w0
  const char *v69; // x22
  void *v70; // x21
  int v71; // w0
  _BYTE *v72; // x0
  const char *v73; // x0
  int v74; // w0
  void *v75; // x0
  void *v76; // x21
  int v77; // w0
  const char *v78; // x22
  void *v79; // x21
  int v80; // w0
  _BYTE *v81; // x0
  const char *v82; // x0
  int v83; // w0
  void *v84; // x0
  void *v85; // x21
  int v86; // w0
  const char *v87; // x20
  void *v88; // x19
  int v89; // w0
  _BYTE *v90; // x0
  _BYTE *v91; // x8

  printLogD();
  v4 = *(_QWORD *)(a2 + 4);
  *(_WORD *)(a1 + 4) = *(_WORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  v5 = DHmalloc((int)v4 + 1);
  *(_QWORD *)(a1 + 24) = v5;
  if ( !v5 )
    return 65514;
  DHmemset(v5, 0, *(_DWORD *)(a1 + 8) + 1);
  DHmemcpy(*(void **)(a1 + 24), *(const void **)(a2 + 16), *(_DWORD *)(a2 + 4));
  v6 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  *(_QWORD *)(a1 + 40) = v6;
  if ( !v6 )
    return 65514;
  DHmemset(v6, 0, *(_DWORD *)(a1 + 12) + 1);
  DHmemcpy(*(void **)(a1 + 40), *(const void **)(a2 + 24), *(_DWORD *)(a2 + 8));
  v8 = *(_DWORD *)(a2 + 32);
  v7 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 48) = v8;
  *(_DWORD *)(a1 + 52) = v7;
  if ( !v8 )
    return 0;
  if ( *(_DWORD *)(a2 + 80) )
    v7 = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 56) = v7;
  v9 = *(const char **)(a2 + 96);
  if ( !v9 )
  {
    v42 = DHmalloc(1);
    *(_QWORD *)(a1 + 72) = v42;
    if ( !v42 )
      return 65514;
    *v42 = 0;
    v17 = *(const char **)(a2 + 104);
    if ( v17 )
      goto LABEL_9;
LABEL_18:
    v43 = DHmalloc(1);
    *(_QWORD *)(a1 + 88) = v43;
    if ( !v43 )
      return 65514;
    *v43 = 0;
    v25 = *(const char **)(a2 + 112);
    if ( v25 )
      goto LABEL_11;
    goto LABEL_20;
  }
  v10 = DHstrlen(v9);
  v11 = DHmalloc(v10 + 1);
  *(_QWORD *)(a1 + 72) = v11;
  if ( !v11 )
    return 65514;
  v12 = v11;
  v13 = DHstrlen(*(const char **)(a2 + 96));
  DHmemset(v12, 0, v13 + 1);
  v14 = *(const char **)(a2 + 96);
  v15 = *(void **)(a1 + 72);
  v16 = DHstrlen(v14);
  DHmemcpy(v15, v14, v16 + 1);
  v17 = *(const char **)(a2 + 104);
  if ( !v17 )
    goto LABEL_18;
LABEL_9:
  v18 = DHstrlen(v17);
  v19 = DHmalloc(v18 + 1);
  *(_QWORD *)(a1 + 88) = v19;
  if ( !v19 )
    return 65514;
  v20 = v19;
  v21 = DHstrlen(*(const char **)(a2 + 104));
  DHmemset(v20, 0, v21 + 1);
  v22 = *(const char **)(a2 + 104);
  v23 = *(void **)(a1 + 88);
  v24 = DHstrlen(v22);
  DHmemcpy(v23, v22, v24 + 1);
  v25 = *(const char **)(a2 + 112);
  if ( v25 )
  {
LABEL_11:
    v26 = DHstrlen(v25);
    v27 = DHmalloc(v26 + 1);
    *(_QWORD *)(a1 + 104) = v27;
    if ( !v27 )
      return 65514;
    v28 = v27;
    v29 = DHstrlen(*(const char **)(a2 + 112));
    DHmemset(v28, 0, v29 + 1);
    v30 = *(const char **)(a2 + 112);
    v31 = *(void **)(a1 + 104);
    v32 = DHstrlen(v30);
    DHmemcpy(v31, v30, v32 + 1);
    v33 = *(const char **)(a2 + 120);
    if ( v33 )
      goto LABEL_13;
    goto LABEL_22;
  }
LABEL_20:
  v44 = DHmalloc(1);
  *(_QWORD *)(a1 + 104) = v44;
  if ( !v44 )
    return 65514;
  *v44 = 0;
  v33 = *(const char **)(a2 + 120);
  if ( v33 )
  {
LABEL_13:
    v34 = DHstrlen(v33);
    v35 = DHmalloc(v34 + 1);
    *(_QWORD *)(a1 + 120) = v35;
    if ( !v35 )
      return 65514;
    v36 = v35;
    v37 = DHstrlen(*(const char **)(a2 + 120));
    DHmemset(v36, 0, v37 + 1);
    v38 = *(const char **)(a2 + 120);
    v39 = *(void **)(a1 + 120);
    v40 = DHstrlen(v38);
    DHmemcpy(v39, v38, v40 + 1);
    goto LABEL_24;
  }
LABEL_22:
  v45 = DHmalloc(1);
  *(_QWORD *)(a1 + 120) = v45;
  if ( !v45 )
    return 65514;
  *v45 = 0;
LABEL_24:
  v46 = *(const char **)(a2 + 176);
  if ( v46 )
  {
    v47 = DHstrlen(v46);
    v48 = DHmalloc(v47 + 1);
    *(_QWORD *)(a1 + 136) = v48;
    if ( !v48 )
      return 65514;
    v49 = v48;
    v50 = DHstrlen(*(const char **)(a2 + 176));
    DHmemset(v49, 0, v50 + 1);
    v51 = *(const char **)(a2 + 176);
    v52 = *(void **)(a1 + 136);
    v53 = DHstrlen(v51);
    DHmemcpy(v52, v51, v53 + 1);
  }
  else
  {
    v54 = DHmalloc(1);
    *(_QWORD *)(a1 + 136) = v54;
    if ( !v54 )
      return 65514;
    *v54 = 0;
  }
  v55 = *(const char **)(a2 + 192);
  if ( v55 )
  {
    v56 = DHstrlen(v55);
    v57 = DHmalloc(v56 + 1);
    *(_QWORD *)(a1 + 152) = v57;
    if ( !v57 )
      return 65514;
    v58 = v57;
    v59 = DHstrlen(*(const char **)(a2 + 192));
    DHmemset(v58, 0, v59 + 1);
    v60 = *(const char **)(a2 + 192);
    v61 = *(void **)(a1 + 152);
    v62 = DHstrlen(v60);
    DHmemcpy(v61, v60, v62 + 1);
  }
  else
  {
    v63 = DHmalloc(1);
    *(_QWORD *)(a1 + 152) = v63;
    if ( !v63 )
      return 65514;
    *v63 = 0;
  }
  v64 = *(const char **)(a2 + 224);
  if ( v64 )
  {
    v65 = DHstrlen(v64);
    v66 = DHmalloc(v65 + 1);
    *(_QWORD *)(a1 + 184) = v66;
    if ( !v66 )
      return 65514;
    v67 = v66;
    v68 = DHstrlen(*(const char **)(a2 + 224));
    DHmemset(v67, 0, v68 + 1);
    v69 = *(const char **)(a2 + 224);
    v70 = *(void **)(a1 + 184);
    v71 = DHstrlen(v69);
    DHmemcpy(v70, v69, v71 + 1);
  }
  else
  {
    v72 = DHmalloc(1);
    *(_QWORD *)(a1 + 184) = v72;
    if ( !v72 )
      return 65514;
    *v72 = 0;
  }
  v73 = *(const char **)(a2 + 232);
  if ( v73 )
  {
    v74 = DHstrlen(v73);
    v75 = DHmalloc(v74 + 1);
    *(_QWORD *)(a1 + 200) = v75;
    if ( !v75 )
      return 65514;
    v76 = v75;
    v77 = DHstrlen(*(const char **)(a2 + 232));
    DHmemset(v76, 0, v77 + 1);
    v78 = *(const char **)(a2 + 232);
    v79 = *(void **)(a1 + 200);
    v80 = DHstrlen(v78);
    DHmemcpy(v79, v78, v80 + 1);
  }
  else
  {
    v81 = DHmalloc(1);
    *(_QWORD *)(a1 + 200) = v81;
    if ( !v81 )
      return 65514;
    *v81 = 0;
  }
  v82 = *(const char **)(a2 + 240);
  if ( v82 )
  {
    v83 = DHstrlen(v82);
    v84 = DHmalloc(v83 + 1);
    *(_QWORD *)(a1 + 216) = v84;
    if ( v84 )
    {
      v85 = v84;
      v86 = DHstrlen(*(const char **)(a2 + 240));
      DHmemset(v85, 0, v86 + 1);
      v87 = *(const char **)(a2 + 240);
      v88 = *(void **)(a1 + 216);
      v89 = DHstrlen(v87);
      DHmemcpy(v88, v87, v89 + 1);
      return 0;
    }
  }
  else
  {
    v90 = DHmalloc(1);
    *(_QWORD *)(a1 + 216) = v90;
    if ( v90 )
    {
      v91 = v90;
      result = 0;
      *v91 = 0;
      return result;
    }
  }
  return 65514;
}

//----- (00000000000145E8) ----------------------------------------------------
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  void *v18; // x0
  void *v19; // x0
  void *v20; // x0
  void *v21; // x0
  void *v22; // x0
  void *v23; // x0
  void *v24; // x0
  void *v25; // x0
  void *v26; // x0
  _QWORD *v27; // x0
  _QWORD *v28; // x8
  _QWORD *v29; // x20

  if ( a1 )
  {
    v2 = (void *)a1[2];
    if ( v2 )
      DHfree(v2);
    v3 = (void *)a1[3];
    if ( v3 )
      DHfree(v3);
    v4 = (void *)a1[8];
    if ( v4 )
      DHfree(v4);
    v5 = (void *)a1[9];
    if ( v5 )
      DHfree(v5);
    v6 = (void *)a1[11];
    if ( v6 )
      DHfree(v6);
    v7 = (void *)a1[12];
    if ( v7 )
      DHfree(v7);
    v8 = (void *)a1[13];
    if ( v8 )
      DHfree(v8);
    v9 = (void *)a1[14];
    if ( v9 )
      DHfree(v9);
    v10 = (void *)a1[15];
    if ( v10 )
      DHfree(v10);
    v11 = (void *)a1[17];
    if ( v11 )
      DHfree(v11);
    v12 = (void *)a1[16];
    if ( v12 )
      DHfree(v12);
    v13 = (void *)a1[5];
    if ( v13 )
      DHfree(v13);
    v14 = (void *)a1[6];
    if ( v14 )
      DHfree(v14);
    v15 = (void *)a1[7];
    if ( v15 )
      DHfree(v15);
    v16 = (void *)a1[18];
    if ( v16 )
      DHfree(v16);
    v17 = (void *)a1[20];
    if ( v17 )
      DHfree(v17);
    v18 = (void *)a1[21];
    if ( v18 )
      DHfree(v18);
    v19 = (void *)a1[19];
    if ( v19 )
      DHfree(v19);
    v20 = (void *)a1[22];
    if ( v20 )
      DHfree(v20);
    v21 = (void *)a1[24];
    if ( v21 )
      DHfree(v21);
    v22 = (void *)a1[26];
    if ( v22 )
      DHfree(v22);
    v23 = (void *)a1[25];
    if ( v23 )
      DHfree(v23);
    v24 = (void *)a1[28];
    if ( v24 )
      DHfree(v24);
    v25 = (void *)a1[29];
    if ( v25 )
      DHfree(v25);
    v26 = (void *)a1[30];
    if ( v26 )
      DHfree(v26);
    v27 = (_QWORD *)a1[31];
    if ( v27 )
    {
      v28 = (_QWORD *)v27[80];
      if ( v28 )
      {
        do
        {
          v29 = v28;
          DHfree(v27);
          v28 = (_QWORD *)v29[80];
          v27 = v29;
        }
        while ( v28 );
      }
      else
      {
        v29 = (_QWORD *)a1[31];
      }
      DHfree(v29);
    }
    DHfree(a1);
  }
}

//----- (0000000000014770) ----------------------------------------------------
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  __int64 v3; // x12
  __int64 v4; // x11
  int8x16_t *v5; // x9
  int8x16_t *v6; // x10
  int8x16_t *v7; // x9
  int8x16_t *v8; // x10
  __int64 v9; // x12
  int8x16_t v10; // q0
  int8x16_t v11; // q1
  int8x8_t *v12; // x13
  int8x8_t *v13; // x14
  __int64 v14; // x11
  int8x8_t v15; // t1
  int v16; // w8
  unsigned __int8 v17; // t1

  if ( a3 >= 1 )
  {
    LODWORD(v3) = 0;
    if ( (unsigned int)a3 < 8 || (unsigned __int64)((char *)a2 - (char *)result) < 0x20 )
    {
      v5 = result;
      v6 = a2;
      goto LABEL_16;
    }
    if ( (unsigned int)a3 < 0x20 )
    {
      v4 = 0;
      goto LABEL_11;
    }
    v4 = a3 & 0x7FFFFFE0;
    v7 = a2 + 1;
    v8 = result + 1;
    v9 = v4;
    do
    {
      v10 = v8[-1];
      v11 = *v8;
      v9 -= 32;
      v8 += 2;
      v7[-1] = vmvnq_s8(v10);
      *v7 = vmvnq_s8(v11);
      v7 += 2;
    }
    while ( v9 );
    if ( v4 != a3 )
    {
      if ( (a3 & 0x18) == 0 )
      {
        v6 = (int8x16_t *)((char *)a2 + v4);
        v5 = (int8x16_t *)((char *)result + v4);
        LODWORD(v3) = a3 & 0x7FFFFFE0;
        goto LABEL_16;
      }
LABEL_11:
      v3 = a3 & 0x7FFFFFF8;
      v12 = (int8x8_t *)((char *)a2 + v4);
      v13 = (int8x8_t *)((char *)result + v4);
      v5 = (int8x16_t *)((char *)result + v3);
      v6 = (int8x16_t *)((char *)a2 + v3);
      v14 = v4 - v3;
      do
      {
        v15.n64_u64[0] = v13->n64_u64[0];
        ++v13;
        v14 += 8;
        v12->n64_u64[0] = vmvn_s8(v15).n64_u64[0];
        ++v12;
      }
      while ( v14 );
      if ( v3 == a3 )
        return result;
LABEL_16:
      v16 = a3 - v3;
      do
      {
        v17 = v5->n128_u8[0];
        v5 = (int8x16_t *)((char *)v5 + 1);
        --v16;
        v6->n128_u8[0] = ~v17;
        v6 = (int8x16_t *)((char *)v6 + 1);
      }
      while ( v16 );
    }
  }
  return result;
}

//----- (0000000000014850) ----------------------------------------------------
__int64 __fastcall get_SSEBaseStream(
        __int16 a1,
        const char *a2,
        unsigned int a3,
        const char *a4,
        __int64 a5,
        __int64 a6)
{
  int v12; // w8
  int v13; // w9
  char *v14; // x0
  char *v15; // x21
  unsigned __int64 v16; // x27
  __int64 result; // x0
  int v18; // w8
  __int16 ClientID; // w0
  __int64 v20; // x8
  int v21; // w26
  __int64 v22; // x12
  char *v23; // x9
  int8x16_t *v24; // x10
  __int64 v25; // x11
  int8x16_t *v26; // x10
  __int64 v27; // x12
  int8x16_t *v28; // x9
  int8x16_t v29; // q0
  int8x16_t v30; // q1
  int8x8_t *v31; // x14
  int8x8_t *v32; // x13
  __int64 v33; // x11
  int8x8_t v34; // t1
  int v35; // w8
  char v36; // t1
  unsigned int v37; // w22
  int v38; // w23
  char *v39; // x0
  int v40; // w2
  int v41; // w23
  char *v42; // x26
  char *v43; // x24
  char *v44; // x24
  int v45; // w4
  int v46; // w5
  int v47; // w6
  int v48; // w7
  __int64 v49; // x22
  __int64 v50; // x24
  unsigned int v51; // w25
  int v52; // w26
  int v53; // w25
  void *v54; // x0
  int v55; // w2
  __int64 v56; // x25
  char *v57; // x27
  char v58[8]; // [xsp+0h] [xbp-110h]
  int v59; // [xsp+Ch] [xbp-104h]
  int8x16_t *v60; // [xsp+18h] [xbp-F8h]
  int v61; // [xsp+20h] [xbp-F0h]
  unsigned int v62; // [xsp+2Ch] [xbp-E4h] BYREF
  __int64 v63; // [xsp+30h] [xbp-E0h] BYREF
  _QWORD v64[2]; // [xsp+38h] [xbp-D8h]
  __int64 v65; // [xsp+48h] [xbp-C8h] BYREF
  _QWORD v66[2]; // [xsp+50h] [xbp-C0h]
  __int64 v67; // [xsp+60h] [xbp-B0h] BYREF
  __int16 v68; // [xsp+68h] [xbp-A8h]
  char v69[32]; // [xsp+70h] [xbp-A0h] BYREF
  char v70[48]; // [xsp+90h] [xbp-80h] BYREF
  __int128 v71; // [xsp+C0h] [xbp-50h] BYREF
  _BYTE v72[35]; // [xsp+D0h] [xbp-40h] BYREF
  __int64 v73; // [xsp+F8h] [xbp-18h]

  v73 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v72, 0, sizeof(v72));
  v71 = 0u;
  *(_QWORD *)&v70[30] = 0;
  v13 = *(_DWORD *)(a5 + 8);
  v12 = *(_DWORD *)(a5 + 12);
  *(_QWORD *)&v70[25] = 0;
  memset(v69, 0, sizeof(v69));
  v68 = 0;
  v67 = 0;
  v65 = 0;
  v66[0] = 0;
  *(_QWORD *)((char *)v66 + 5) = 0;
  v63 = 0;
  v64[0] = 0;
  *(_QWORD *)((char *)v64 + 5) = 0;
  v14 = (char *)DHmalloc(v12 + v13 + 1);
  *(_QWORD *)(a5 + 24) = v14;
  if ( !v14 )
    return 65514;
  v15 = v14;
  DHmemset(v14, 0, *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1);
  v16 = *(unsigned int *)(a5 + 12);
  result = 65501;
  if ( (_DWORD)v16 )
  {
    if ( !((unsigned int)v16 % 0x14) )
    {
      strcpy(v70, "SSE Primary-Level Base Key Generation");
      strcpy(v69, "SSE 2-Level Base Key Generation");
      DHmemset(&v63, 0, 21);
      DHmemset(&v67, 0, 10);
      v18 = DHstrlen(a2);
      result = 65509;
      if ( a3 )
      {
        if ( v18 >= 1 )
        {
          v61 = DHstrlen(a4);
          DHmemset(&v71, 0, 51);
          v62 = 51;
          ClientID = GetClientID(a1, (__int64)&v71, (int *)&v62, a6);
          if ( ClientID < 0 )
            return (unsigned int)ClientID;
          DHstrlwr(&v71);
          v60 = (int8x16_t *)DHmalloc(v62);
          if ( v60 )
          {
            v20 = v62;
            if ( (int)v62 < 1 )
            {
              v21 = v61;
              goto LABEL_28;
            }
            v21 = v61;
            LODWORD(v22) = 0;
            v23 = (char *)&v71;
            if ( v62 < 8 )
            {
              v24 = v60;
            }
            else
            {
              v24 = v60;
              if ( (unsigned __int64)((char *)v60 - (char *)&v71) >= 0x20 )
              {
                if ( v62 < 0x20 )
                {
                  v25 = 0;
                  goto LABEL_20;
                }
                v25 = v62 & 0x7FFFFFE0;
                v26 = (int8x16_t *)v72;
                v27 = v25;
                v28 = v60 + 1;
                do
                {
                  v29 = v26[-1];
                  v30 = *v26;
                  v27 -= 32;
                  v26 += 2;
                  v28[-1] = vmvnq_s8(v29);
                  *v28 = vmvnq_s8(v30);
                  v28 += 2;
                }
                while ( v27 );
                if ( v25 == v20 )
                  goto LABEL_27;
                if ( (v20 & 0x18) != 0 )
                {
LABEL_20:
                  v22 = v20 & 0x7FFFFFF8;
                  v23 = &v72[v22 - 16];
                  v31 = (int8x8_t *)&v72[v25 - 16];
                  v24 = (int8x16_t *)((char *)v60 + v22);
                  v32 = (int8x8_t *)((char *)v60 + v25);
                  v33 = v25 - v22;
                  do
                  {
                    v34.n64_u64[0] = v31->n64_u64[0];
                    ++v31;
                    v33 += 8;
                    v32->n64_u64[0] = vmvn_s8(v34).n64_u64[0];
                    ++v32;
                  }
                  while ( v33 );
                  if ( v22 == v20 )
                    goto LABEL_27;
                  goto LABEL_25;
                }
                LODWORD(v22) = v20 & 0x7FFFFFE0;
                v23 = &v72[v25 - 16];
                v24 = (int8x16_t *)((char *)v60 + v25);
              }
            }
LABEL_25:
            v35 = v20 - v22;
            do
            {
              v36 = *v23++;
              --v35;
              v24->n128_u8[0] = ~v36;
              v24 = (int8x16_t *)((char *)v24 + 1);
            }
            while ( v35 );
LABEL_27:
            LODWORD(v20) = v62;
LABEL_28:
            v37 = v21 + a3;
            v38 = v21 + a3 + 2 * v20;
            v39 = (char *)DHmalloc(v38 + 38);
            if ( v39 )
            {
              v40 = v38 + 38;
              v41 = v21;
              v42 = v39;
              DHmemset(v39, 0, v40);
              DHmemcpy(v42, a2, a3);
              DHstrlwr(v42);
              v43 = &v42[a3];
              DHmemcpy(v43, a4, v41);
              v44 = &v43[v41];
              DHmemcpy(v44, &v71, v62);
              DHmemcpy(&v44[v62], v60, v62);
              DHmemcpy(&v44[2 * v62], v70, 37);
              DA_DRM_HASH_SHA1Digest((__int64)v42, (uint32x4_t *)&v65, v37 + 2 * v62 + 37);
              DHmemcpy(v15, &v65, 20);
              DHfree(v42);
              if ( (unsigned int)v16 < 0x28 )
              {
LABEL_33:
                DHmemcpy(&v15[*(unsigned int *)(a5 + 12)], v15, *(_DWORD *)(a5 + 8));
                DHfree(v60);
                return 0;
              }
              v49 = 1;
              v50 = 0x1400000000LL;
              *(_QWORD *)v58 = (v16 * (unsigned __int128)0xCCCCCCCCCCCCCCDuLL) >> 64;
              v59 = v61 + 20;
              while ( 1 )
              {
                v51 = v62;
                DHsprintf_s((char *)&v67, 10, "%d", v49 + 1, v45, v46, v47, v48, v58[0]);
                v52 = DHstrlen((const char *)&v67);
                v53 = v52 + v59 + 2 * v51;
                v54 = DHmalloc(v53 + 31);
                if ( !v54 )
                  break;
                v55 = v53 + 31;
                v56 = (__int64)v54;
                DHmemset(v54, 0, v55);
                DHmemcpy((void *)v56, &v65, 20);
                DHmemcpy((void *)(v56 + 20), a4, v61);
                v57 = (char *)(v56 + 20 + v41);
                DHmemcpy(v57, &v71, v62);
                DHmemcpy(&v57[v62], v60, v62);
                DHmemcpy(&v57[2 * v62], v69, 4);
                DHmemcpy(&v57[2 * v62 + 4], &v67, v52);
                DHmemcpy(&v57[2 * v62 + 4 + v52], &v69[5], 26);
                DA_DRM_HASH_SHA1Digest(v56, (uint32x4_t *)&v65, v52 + v59 + 2 * v62 + 30);
                DHmemcpy(&v15[v50 >> 32], &v65, 20);
                DHfree((void *)v56);
                ++v49;
                v50 += 0x1400000000LL;
                if ( *(_QWORD *)v58 == v49 )
                  goto LABEL_33;
              }
            }
          }
          return 65514;
        }
      }
    }
  }
  return result;
}
// 14C0C: variable 'v45' is possibly undefined
// 14C0C: variable 'v46' is possibly undefined
// 14C0C: variable 'v47' is possibly undefined
// 14C0C: variable 'v48' is possibly undefined
// 14C0C: variable 'v58' is possibly undefined

//----- (0000000000014D80) ----------------------------------------------------
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  __int64 result; // x0
  signed int v9; // w25
  int8x16_t *v10; // x0
  int v11; // w21
  int8x16_t *v12; // x20
  __int64 v13; // x27
  __int64 v14; // x22
  int v15; // w8
  __int64 i; // x8
  int v17; // w10
  int v18; // w26
  int v19; // w25
  int8x16_t *v20; // x0
  __int64 v21; // x24
  __int64 v22; // x10
  char *v23; // x8
  int8x16_t *v24; // x9
  __int64 v25; // x11
  int8x16_t *v26; // x0
  int8x16_t *v27; // x8
  int8x16_t *v28; // x9
  __int64 v29; // x10
  int8x16_t v30; // q0
  int8x16_t v31; // q1
  int8x8_t *v32; // x12
  int8x8_t *v33; // x13
  __int64 v34; // x11
  int8x8_t v35; // t1
  int v36; // w10
  char v37; // t1
  int v38; // w25
  __int64 v39; // x23
  int v40; // w26
  int v41; // w27
  char *v42; // x0
  int v43; // w8
  char *v44; // x26
  char *v45; // x19
  int v46; // [xsp+Ch] [xbp-F4h]
  int8x16_t *v47; // [xsp+18h] [xbp-E8h]
  int v48; // [xsp+24h] [xbp-DCh] BYREF
  __int64 v49; // [xsp+28h] [xbp-D8h] BYREF
  _QWORD v50[2]; // [xsp+30h] [xbp-D0h]
  __int64 v51; // [xsp+40h] [xbp-C0h] BYREF
  __int16 v52; // [xsp+48h] [xbp-B8h]
  char v53[48]; // [xsp+50h] [xbp-B0h] BYREF
  __int64 v54; // [xsp+80h] [xbp-80h] BYREF
  _QWORD v55[2]; // [xsp+88h] [xbp-78h]
  __int64 v56; // [xsp+98h] [xbp-68h] BYREF
  _QWORD v57[2]; // [xsp+A0h] [xbp-60h]
  __int128 v58; // [xsp+B0h] [xbp-50h] BYREF
  _BYTE v59[35]; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v60; // [xsp+E8h] [xbp-18h]

  v60 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v59, 0, sizeof(v59));
  v58 = 0u;
  v56 = 0;
  v57[0] = 0;
  *(_QWORD *)((char *)v57 + 5) = 0;
  strcpy(v53, "Encrypted Target Identifying Token Generation");
  v54 = 0;
  v55[0] = 0;
  *(_QWORD *)((char *)v55 + 5) = 0;
  v52 = 0;
  v51 = 0;
  v49 = 0;
  v50[0] = 0;
  *(_QWORD *)((char *)v50 + 5) = 0;
  printLogD();
  printLogD();
  result = 65501;
  if ( a1 && a2 && a3 && a4 )
  {
    v9 = DHstrlen(a4);
    v10 = (int8x16_t *)DHmalloc(v9 + 1);
    if ( !v10 )
      return 65514;
    v11 = v9;
    v12 = v10;
    v13 = v9;
    DHstrncpy_s((__int64)v10, v9 + 1, (__int64)a4, v9);
    DHstrlwr(v12);
    DHmemset(&v51, 0, 10);
    DHmemset(&v49, 0, 21);
    DHmemset(&v56, 0, 21);
    DHmemset(&v54, 0, 21);
    v14 = 0;
    if ( *a3 == 34 )
      ++a3;
    v15 = (unsigned __int8)*a3;
    if ( !*a3 )
      goto LABEL_25;
    while ( v15 != 47 )
    {
      *((_BYTE *)&v51 + v14++) = v15;
      v15 = (unsigned __int8)a3[v14];
      if ( !a3[v14] )
        goto LABEL_25;
    }
    DHstrlwr(&v51);
    for ( i = 0; ; *((_BYTE *)&v50[-1] + i++) = v17 )
    {
      v17 = (unsigned __int8)a3[i + 1 + v14];
      if ( !a3[i + 1 + v14] || v17 == 34 )
        break;
    }
    if ( v17 != 34 || (unsigned int)i != 20 )
    {
LABEL_25:
      DHfree(v12);
      printLogD();
      return 65434;
    }
    v18 = DHstrlen(a1);
    v19 = DHstrlen(a2);
    DHstrncpy_s((__int64)&v58, 50, (__int64)a2, v19);
    DHstrlwr(&v58);
    v20 = (int8x16_t *)DHmalloc(v19);
    if ( !v20 )
    {
      v26 = v12;
      goto LABEL_45;
    }
    v21 = v19;
    if ( v19 < 1 )
    {
LABEL_41:
      v47 = v20;
      DHmemset(&v56, 0, 21);
      DHmemset(&v54, 0, 21);
      v38 = v18;
      v39 = v13;
      v40 = v18 + 2 * v21;
      v41 = v40 + v13 + v14 + 46;
      v42 = (char *)DHmalloc(v41);
      if ( v42 )
      {
        v43 = v11 + v14 + v40;
        v44 = v42;
        v46 = v43;
        DHmemset(v42, 0, v41);
        DHmemcpy(v44, v12, v11);
        DHmemcpy(&v44[v39], &v51, v14);
        DHmemcpy(&v44[v39 + (unsigned int)v14], a1, v38);
        v45 = &v44[v39 + (unsigned int)v14 + v38];
        DHmemcpy(v45, &v58, v21);
        DHmemcpy(&v45[v21], v47, v21);
        DHmemcpy(&v45[2 * v21], v53, 45);
        DA_DRM_HASH_SHA1Digest((__int64)v44, (uint32x4_t *)&v54, v46 + 45);
        PP_HexEncode_A((unsigned __int8 *)&v54, 0xAu, &v56, &v48);
        DHfree(v47);
        DHfree(v44);
        DHfree(v12);
        printLogD();
        printLogD();
        if ( !(unsigned int)DHstrnicmp(&v49, &v56, 255) )
        {
          printLogD();
          return 0;
        }
        printLogD();
        printLogD();
        return 65434;
      }
      DHfree(v12);
      v26 = v47;
LABEL_45:
      DHfree(v26);
      return 65514;
    }
    LODWORD(v22) = 0;
    v23 = (char *)&v58;
    if ( (unsigned int)v19 < 8 )
    {
      v24 = v20;
    }
    else
    {
      v24 = v20;
      if ( (unsigned __int64)((char *)v20 - (char *)&v58) >= 0x20 )
      {
        if ( (unsigned int)v19 < 0x20 )
        {
          v25 = 0;
          goto LABEL_34;
        }
        v25 = v19 & 0x7FFFFFE0LL;
        v27 = v20 + 1;
        v28 = (int8x16_t *)v59;
        v29 = v25;
        do
        {
          v30 = v28[-1];
          v31 = *v28;
          v29 -= 32;
          v28 += 2;
          v27[-1] = vmvnq_s8(v30);
          *v27 = vmvnq_s8(v31);
          v27 += 2;
        }
        while ( v29 );
        if ( v25 == v19 )
          goto LABEL_41;
        if ( (v19 & 0x18LL) != 0 )
        {
LABEL_34:
          v22 = v19 & 0x7FFFFFF8LL;
          v32 = (int8x8_t *)((char *)v20 + v25);
          v23 = &v59[v22 - 16];
          v24 = (int8x16_t *)((char *)v20 + v22);
          v33 = (int8x8_t *)&v59[v25 - 16];
          v34 = v25 - v22;
          do
          {
            v35.n64_u64[0] = v33->n64_u64[0];
            ++v33;
            v34 += 8;
            v32->n64_u64[0] = vmvn_s8(v35).n64_u64[0];
            ++v32;
          }
          while ( v34 );
          if ( v22 == v19 )
            goto LABEL_41;
          goto LABEL_39;
        }
        v24 = (int8x16_t *)((char *)v20 + v25);
        LODWORD(v22) = v19 & 0x7FFFFFE0;
        v23 = &v59[v25 - 16];
      }
    }
LABEL_39:
    v36 = v19 - v22;
    do
    {
      v37 = *v23++;
      --v36;
      v24->n128_u8[0] = ~v37;
      v24 = (int8x16_t *)((char *)v24 + 1);
    }
    while ( v36 );
    goto LABEL_41;
  }
  return result;
}

//----- (00000000000152E0) ----------------------------------------------------
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        char *a6,
        __int16 a7,
        __int64 a8)
{
  int v16; // w0
  int v17; // w20
  int v19; // w23
  char *v20; // x0
  char *v21; // x19
  int v22; // w26
  int v23; // w8
  unsigned __int8 *v24; // x8
  _BYTE *v25; // x20
  int v26; // w8
  __int64 v27; // x8
  int v28; // w9
  int v29; // w25
  __int16 ClientID; // w0
  int8x16_t *v31; // x0
  __int64 v32; // x9
  int8x16_t *v33; // x28
  int v34; // w8
  int v35; // w20
  __int64 v36; // x13
  char *v37; // x10
  int v38; // w26
  int8x16_t *v39; // x11
  __int64 v40; // x12
  unsigned int v41; // w20
  int8x16_t *v42; // x10
  int8x16_t *v43; // x11
  __int64 v44; // x13
  int8x16_t v45; // q0
  int8x16_t v46; // q1
  int8x8_t *v47; // x14
  int8x8_t *v48; // x15
  __int64 v49; // x12
  int8x8_t v50; // t1
  int v51; // w9
  char v52; // t1
  int v53; // w23
  char *v54; // x0
  char *v55; // x27
  __int64 v56; // x10
  char *v57; // x21
  char *v58; // x20
  __int64 v59; // [xsp+28h] [xbp-D8h]
  int v60; // [xsp+30h] [xbp-D0h]
  int v61; // [xsp+3Ch] [xbp-C4h]
  unsigned int v62; // [xsp+40h] [xbp-C0h]
  unsigned int v63; // [xsp+44h] [xbp-BCh]
  const char *v64; // [xsp+48h] [xbp-B8h]
  unsigned int v65; // [xsp+50h] [xbp-B0h] BYREF
  uint32x4_t v66; // [xsp+54h] [xbp-ACh] BYREF
  char v67[21]; // [xsp+6Bh] [xbp-95h] BYREF
  __int128 v68; // [xsp+80h] [xbp-80h] BYREF
  _OWORD v69[3]; // [xsp+90h] [xbp-70h] BYREF
  __int128 v70; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v71; // [xsp+D0h] [xbp-30h]
  __int16 v72; // [xsp+D8h] [xbp-28h]
  char v73; // [xsp+DAh] [xbp-26h]
  _BYTE v74[21]; // [xsp+DBh] [xbp-25h] BYREF
  __int64 v75; // [xsp+F0h] [xbp-10h]

  v75 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v69, 0, 35);
  v68 = 0u;
  printLogD();
  printLogD();
  if ( !a5 )
  {
    if ( (a7 & 0xFFFE) == 0x1000 )
      return 4294967271LL;
    else
      return 0;
  }
  v64 = a2;
  if ( a3 )
  {
    v16 = DHstrlen(a3);
    v17 = v16 + 14;
    v60 = v16;
    v63 = 14;
    if ( a4 )
    {
LABEL_4:
      v61 = DHstrlen(a4);
      v62 = 18;
      v17 += v61 + 18;
      goto LABEL_10;
    }
  }
  else
  {
    v60 = 0;
    v17 = 0;
    v63 = 0;
    if ( a4 )
      goto LABEL_4;
  }
  v61 = 0;
  v62 = 0;
LABEL_10:
  v19 = DHstrlen(a6);
  v20 = (char *)DHmalloc(v19 + 1);
  if ( !v20 )
    return 65514;
  v21 = v20;
  v59 = v19;
  DHmemset(v20, 0, v19 + 1);
  DHstrcpy_s(v21, v19 + 1, a6);
  DHstrlwr(v21);
  if ( a3 )
    DHstrlwr(a3);
  v22 = v19 + v17;
  printLogD();
  v23 = *a5;
  v73 = 0;
  v70 = xmmword_7390;
  if ( v23 == 34 )
    v24 = a5 + 1;
  else
    v24 = a5;
  v71 = *(_QWORD *)"Generatirati";
  v25 = v24 + 1;
  v72 = 28271;
  v26 = *v24;
  if ( !v26 )
    goto LABEL_32;
  while ( v26 != 47 )
  {
    v26 = (unsigned __int8)*v25++;
    if ( !*(v25 - 1) )
      goto LABEL_32;
  }
  printLogD();
  DHmemset(v74, 0, 21);
  v27 = 0;
  v28 = (unsigned __int8)*v25;
  if ( *v25 )
  {
    do
    {
      if ( v28 == 34 )
        break;
      v74[v27++] = v28;
      v28 = (unsigned __int8)v25[v27];
    }
    while ( v25[v27] );
  }
  if ( (_DWORD)v27 != 20 )
  {
LABEL_32:
    DHfree(v21);
    return 65511;
  }
  printLogD();
  v29 = DHstrlen(v64);
  DHmemset(&v68, 0, 51);
  v65 = 51;
  ClientID = GetClientID(a1, (__int64)&v68, (int *)&v65, a8);
  if ( ClientID < 0 )
  {
    v41 = ClientID;
    DHfree(v21);
    return v41;
  }
  DHstrlwr(&v68);
  printLogD();
  DHstrlwr(&v68);
  printLogD();
  v31 = (int8x16_t *)DHmalloc(v65);
  if ( !v31 )
    goto LABEL_59;
  v32 = v65;
  v33 = v31;
  v34 = v22 + v29;
  if ( (int)v65 < 1 )
  {
    v38 = v61;
    v35 = v60;
    goto LABEL_49;
  }
  v35 = v60;
  LODWORD(v36) = 0;
  v37 = (char *)&v68;
  if ( v65 < 8 )
  {
    v38 = v61;
    v39 = v31;
  }
  else
  {
    v38 = v61;
    v39 = v31;
    if ( (unsigned __int64)((char *)v31 - (char *)&v68) >= 0x20 )
    {
      if ( v65 < 0x20 )
      {
        v40 = 0;
        goto LABEL_41;
      }
      v40 = v65 & 0x7FFFFFE0;
      v42 = v31 + 1;
      v43 = (int8x16_t *)v69;
      v44 = v40;
      do
      {
        v45 = v43[-1];
        v46 = *v43;
        v44 -= 32;
        v43 += 2;
        v42[-1] = vmvnq_s8(v45);
        *v42 = vmvnq_s8(v46);
        v42 += 2;
      }
      while ( v44 );
      if ( v40 == v32 )
        goto LABEL_48;
      if ( (v32 & 0x18) != 0 )
      {
LABEL_41:
        v36 = v32 & 0x7FFFFFF8;
        v47 = (int8x8_t *)((char *)v31 + v40);
        v37 = (char *)&v69[-1] + v36;
        v39 = (int8x16_t *)((char *)v31 + v36);
        v48 = (int8x8_t *)((char *)&v69[-1] + v40);
        v49 = v40 - v36;
        do
        {
          v50.n64_u64[0] = v48->n64_u64[0];
          ++v48;
          v49 += 8;
          v47->n64_u64[0] = vmvn_s8(v50).n64_u64[0];
          ++v47;
        }
        while ( v49 );
        if ( v36 == v32 )
          goto LABEL_48;
        goto LABEL_46;
      }
      v39 = (int8x16_t *)((char *)v31 + v40);
      LODWORD(v36) = v32 & 0x7FFFFFE0;
      v37 = (char *)&v69[-1] + v40;
    }
  }
LABEL_46:
  v51 = v32 - v36;
  do
  {
    v52 = *v37++;
    --v51;
    v39->n128_u8[0] = ~v52;
    v39 = (int8x16_t *)((char *)v39 + 1);
  }
  while ( v51 );
LABEL_48:
  LODWORD(v32) = v65;
LABEL_49:
  v53 = v34 + 2 * v32;
  v54 = (char *)DHmalloc(v53 + 27);
  if ( !v54 )
  {
    DHfree(v33);
LABEL_59:
    DHfree(v21);
    return 65514;
  }
  v55 = v54;
  DHmemset(v54, 0, v53 + 27);
  DHmemcpy(v55, v21, v59);
  if ( v35 )
    DHmemcpy(&v55[v59], "time-not-after", v63);
  if ( v38 )
    DHmemcpy(&v55[v59 + v63], "allowable-services", v62);
  v56 = v59;
  if ( v35 )
  {
    DHmemcpy(&v55[v59 + v63 + v62], a3, v35);
    v56 = v59;
  }
  if ( v38 )
  {
    DHmemcpy(&v55[v56 + v63 + v62 + v35], a4, v38);
    v56 = v59;
  }
  v57 = &v55[v56 + v63 + v62 + v35 + v38];
  DHmemcpy(v57, v64, v29);
  v58 = &v57[v29];
  DHmemcpy(v58, &v68, v65);
  DHmemcpy(&v58[v65], v33, v65);
  DHmemcpy(&v58[2 * v65], &v70, 26);
  printLogD();
  DA_DRM_HASH_SHA1Digest((__int64)v55, &v66, v53 + 26);
  DHsprintf_s(
    v67,
    21,
    "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
    v66.n128_u8[0],
    v66.n128_u8[1],
    v66.n128_u8[2],
    v66.n128_u8[3],
    v66.n128_u8[4],
    v66.n128_i8[5]);
  DHfree(v33);
  DHfree(v55);
  DHfree(v21);
  printLogD();
  if ( (unsigned int)DHstrnicmp(v74, v67, 20) )
  {
    printLogD();
    return 65511;
  }
  printLogD();
  return 0;
}
// 7390: using guessed type __int128 xmmword_7390;

//----- (000000000001595C) ----------------------------------------------------
__int64 __fastcall compute_eServiceCode(
        __int16 a1,
        const char *a2,
        _BYTE *a3,
        const char *a4,
        const char *a5,
        __int64 a6)
{
  bool v7; // zf
  __int64 result; // x0
  signed int v14; // w20
  int8x16_t *v15; // x0
  int8x16_t *v16; // x19
  _BYTE *v17; // x8
  _BYTE *v18; // x8
  int v19; // w9
  __int64 v20; // x9
  int v21; // w11
  signed int v22; // w23
  int8x16_t *v23; // x0
  int8x16_t *v24; // x21
  unsigned int v25; // w0
  int v26; // w28
  unsigned int v27; // w22
  int8x16_t *v28; // x0
  int8x16_t *v29; // x21
  __int16 ClientID; // w0
  int8x16_t *v31; // x0
  __int64 v32; // x8
  int8x16_t *v33; // x26
  __int64 v34; // x12
  char *v35; // x9
  int8x16_t *v36; // x10
  __int64 v37; // x11
  int8x16_t *v38; // x0
  unsigned int v39; // w20
  int8x16_t *v40; // x9
  int8x16_t *v41; // x10
  __int64 v42; // x12
  int8x16_t v43; // q0
  int8x16_t v44; // q1
  int8x8_t *v45; // x13
  int8x8_t *v46; // x14
  __int64 v47; // x11
  int8x8_t v48; // t1
  int v49; // w8
  char v50; // t1
  __int64 v51; // x24
  int v52; // w28
  int v53; // w21
  char *v54; // x0
  char *v55; // x26
  __int64 v56; // x20
  int8x16_t *v57; // [xsp+30h] [xbp-E0h]
  int8x16_t *v58; // [xsp+40h] [xbp-D0h]
  int8x16_t *v59; // [xsp+48h] [xbp-C8h]
  unsigned int v60; // [xsp+54h] [xbp-BCh] BYREF
  __int64 v61; // [xsp+58h] [xbp-B8h] BYREF
  _QWORD v62[2]; // [xsp+60h] [xbp-B0h]
  char v63[8]; // [xsp+70h] [xbp-A0h] BYREF
  _QWORD v64[2]; // [xsp+78h] [xbp-98h]
  __int64 v65; // [xsp+88h] [xbp-88h] BYREF
  _QWORD v66[2]; // [xsp+90h] [xbp-80h]
  char v67[32]; // [xsp+A0h] [xbp-70h] BYREF
  __int128 v68; // [xsp+C0h] [xbp-50h] BYREF
  _BYTE v69[35]; // [xsp+D0h] [xbp-40h] BYREF
  __int64 v70; // [xsp+F8h] [xbp-18h]

  v7 = a1 == 0;
  result = 65501;
  v70 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v68 = 0u;
  memset(v69, 0, sizeof(v69));
  v65 = 0;
  v66[0] = 0;
  *(_QWORD *)((char *)v66 + 5) = 0;
  *(_QWORD *)v63 = 0;
  v64[0] = 0;
  *(_QWORD *)((char *)v64 + 5) = 0;
  v61 = 0;
  v62[0] = 0;
  *(_QWORD *)((char *)v62 + 5) = 0;
  if ( !v7 && a2 )
  {
    if ( !a3 && !a4 && !a5 )
      return 0;
    strcpy(v67, "eServiceCode Value Generation");
    v14 = DHstrlen(a2);
    v15 = (int8x16_t *)DHmalloc(v14 + 1);
    if ( !v15 )
      return 65514;
    v16 = v15;
    DHmemset(v15, 0, v14 + 1);
    DHstrncpy_s((__int64)v16, v14 + 1, (__int64)a2, v14);
    DHstrlwr(v16);
    v17 = a3 + 1;
    if ( *a3 != 34 )
      v17 = a3;
    v18 = v17 + 1;
    v19 = (unsigned __int8)*(v18 - 1);
    if ( !*(v18 - 1) )
      goto LABEL_27;
    while ( v19 != 47 )
    {
      v19 = (unsigned __int8)*v18++;
      if ( !*(v18 - 1) )
        goto LABEL_27;
    }
    v20 = 0;
    v21 = (unsigned __int8)*v18;
    if ( *v18 )
    {
      do
      {
        if ( v21 == 47 )
          break;
        *((_BYTE *)&v66[-1] + v20++) = v21;
        v21 = (unsigned __int8)v18[v20];
      }
      while ( v18[v20] );
    }
    if ( (_DWORD)v20 != 20 )
    {
LABEL_27:
      DHfree(v16);
      return 65432;
    }
    v22 = DHstrlen(a4);
    v23 = (int8x16_t *)DHmalloc(v22 + 1);
    if ( v23 )
    {
      v24 = v23;
      DHmemset(v23, 0, v22 + 1);
      DHstrncpy_s((__int64)v24, v22 + 1, (__int64)a4, v22);
      DHstrlwr(v24);
      v25 = DHstrlen(a5);
      v26 = v25 + 1;
      v27 = v25;
      v28 = (int8x16_t *)DHmalloc(v25 + 1);
      if ( v28 )
      {
        v59 = v24;
        v29 = v28;
        DHmemset(v28, 0, v26);
        DHstrncpy_s((__int64)v29, v26, (__int64)a5, v27);
        DHstrlwr(v29);
        v60 = v26;
        ClientID = GetClientID(a1, (__int64)&v68, (int *)&v60, a6);
        if ( ClientID < 0 )
        {
          v39 = ClientID;
          DHfree(v16);
          DHfree(v59);
          DHfree(v29);
          return v39;
        }
        v58 = v29;
        DHstrlwr(&v68);
        v31 = (int8x16_t *)DHmalloc(v60 + 1);
        if ( v31 )
        {
          v32 = v60;
          v33 = v31;
          if ( (int)v60 < 1 )
          {
LABEL_45:
            v51 = v14 + (__int64)v22;
            v52 = v27 + v51;
            v53 = v27 + v51 + 2 * v32;
            v54 = (char *)DHmalloc(v53 + 30);
            if ( v54 )
            {
              v57 = v33;
              v55 = v54;
              DHmemset(v54, 0, v53 + 30);
              DHmemcpy(v55, v16, v14);
              DHmemcpy(&v55[v14], v59, v22);
              DHmemcpy(&v55[v51], v58, v27);
              DHmemcpy(&v55[v52], &v68, v60);
              v56 = (int)(v60 + v52);
              DHmemcpy(&v55[v56], v57, v60);
              DHmemcpy(&v55[(int)v60 + v56], v67, 29);
              DHfree(v16);
              DHfree(v59);
              DHfree(v58);
              DHfree(v57);
              DA_DRM_HASH_SHA1Digest((__int64)v55, (uint32x4_t *)v63, v53 + 29);
              DHsprintf_s(
                (char *)&v61,
                21,
                "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                (unsigned __int8)v63[0],
                (unsigned __int8)v63[1],
                (unsigned __int8)v63[2],
                (unsigned __int8)v63[3],
                (unsigned __int8)v63[4],
                v63[5]);
              DHfree(v55);
              if ( (unsigned int)DHstrnicmp(&v65, &v61, 20) )
                return 4294967192LL;
              else
                return 0;
            }
            DHfree(v16);
            DHfree(v59);
            DHfree(v58);
            v38 = v33;
            goto LABEL_50;
          }
          LODWORD(v34) = 0;
          v35 = (char *)&v68;
          if ( v60 < 8 )
          {
            v36 = v31;
          }
          else
          {
            v36 = v31;
            if ( (unsigned __int64)((char *)v31 - (char *)&v68) >= 0x20 )
            {
              if ( v60 < 0x20 )
              {
                v37 = 0;
                goto LABEL_37;
              }
              v37 = v60 & 0x7FFFFFE0;
              v40 = v31 + 1;
              v41 = (int8x16_t *)v69;
              v42 = v37;
              do
              {
                v43 = v41[-1];
                v44 = *v41;
                v42 -= 32;
                v41 += 2;
                v40[-1] = vmvnq_s8(v43);
                *v40 = vmvnq_s8(v44);
                v40 += 2;
              }
              while ( v42 );
              if ( v37 == v32 )
                goto LABEL_44;
              if ( (v32 & 0x18) != 0 )
              {
LABEL_37:
                v34 = v32 & 0x7FFFFFF8;
                v45 = (int8x8_t *)((char *)v31 + v37);
                v35 = &v69[v34 - 16];
                v36 = (int8x16_t *)((char *)v31 + v34);
                v46 = (int8x8_t *)&v69[v37 - 16];
                v47 = v37 - v34;
                do
                {
                  v48.n64_u64[0] = v46->n64_u64[0];
                  ++v46;
                  v47 += 8;
                  v45->n64_u64[0] = vmvn_s8(v48).n64_u64[0];
                  ++v45;
                }
                while ( v47 );
                if ( v34 == v32 )
                  goto LABEL_44;
                goto LABEL_42;
              }
              v36 = (int8x16_t *)((char *)v31 + v37);
              LODWORD(v34) = v32 & 0x7FFFFFE0;
              v35 = &v69[v37 - 16];
            }
          }
LABEL_42:
          v49 = v32 - v34;
          do
          {
            v50 = *v35++;
            --v49;
            v36->n128_u8[0] = ~v50;
            v36 = (int8x16_t *)((char *)v36 + 1);
          }
          while ( v49 );
LABEL_44:
          LODWORD(v32) = v60;
          goto LABEL_45;
        }
        DHfree(v16);
        DHfree(v59);
        v38 = v29;
      }
      else
      {
        DHfree(v16);
        v38 = v24;
      }
    }
    else
    {
      v38 = v16;
    }
LABEL_50:
    DHfree(v38);
    return 65514;
  }
  return result;
}

//----- (0000000000015EA0) ----------------------------------------------------
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5, __int64 a6)
{
  int v12; // w25
  char *v13; // x0
  char *v14; // x21
  int v15; // w24
  __int16 ClientID; // w0
  int8x16_t *v17; // x0
  __int64 v18; // x8
  int8x16_t *v19; // x23
  __int64 v20; // x12
  char *v21; // x9
  int8x16_t *v22; // x10
  __int64 v23; // x11
  unsigned int v24; // w19
  int8x16_t *v25; // x9
  int8x16_t *v26; // x10
  __int64 v27; // x12
  int8x16_t v28; // q0
  int8x16_t v29; // q1
  int8x8_t *v30; // x13
  int8x8_t *v31; // x14
  __int64 v32; // x11
  int8x8_t v33; // t1
  int v34; // w8
  char v35; // t1
  int v36; // w28
  char *v37; // x0
  char *v38; // x26
  char *v39; // x25
  char *v40; // x22
  unsigned int v42; // [xsp+Ch] [xbp-84h] BYREF
  __int128 v43; // [xsp+10h] [xbp-80h] BYREF
  _OWORD v44[3]; // [xsp+20h] [xbp-70h] BYREF
  _OWORD v45[2]; // [xsp+50h] [xbp-40h] BYREF
  __int64 v46; // [xsp+70h] [xbp-20h] BYREF
  _QWORD v47[3]; // [xsp+78h] [xbp-18h]

  v47[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v46 = 0;
  v47[0] = 0;
  *(_QWORD *)((char *)v47 + 5) = 0;
  memset(v44, 0, 35);
  v43 = 0u;
  v12 = DHstrlen(a3);
  v13 = (char *)DHmalloc(v12 + 1);
  if ( v13 )
  {
    v14 = v13;
    DHstrcpy_s(v13, v12 + 1, a3);
    DHstrlwr(v14);
    v15 = DHstrlen(a2);
    DHmemset(&v43, 0, 51);
    v42 = 51;
    ClientID = GetClientID(a1, (__int64)&v43, (int *)&v42, a6);
    if ( ClientID < 0 )
    {
      v24 = ClientID;
      v19 = (int8x16_t *)v14;
    }
    else
    {
      DHstrlwr(&v43);
      v17 = (int8x16_t *)DHmalloc(v42);
      if ( v17 )
      {
        v18 = v42;
        v19 = v17;
        if ( (int)v42 < 1 )
        {
LABEL_25:
          v36 = v15 + v12 + 2 * v18;
          strcpy((char *)v45, "SSKEY-1 Key Generation");
          v37 = (char *)DHmalloc(v36 + 23);
          if ( v37 )
          {
            v38 = v37;
            DHmemset(v37, 0, v36 + 23);
            DHmemcpy(v38, v14, v12);
            v39 = &v38[v12];
            DHmemcpy(v39, a2, v15);
            v40 = &v39[v15];
            DHmemcpy(v40, &v43, v42);
            DHmemcpy(&v40[v42], v19, v42);
            DHmemcpy(&v40[2 * v42], v45, 22);
            DA_DRM_HASH_SHA1Digest((__int64)v38, (uint32x4_t *)&v46, v36 + 22);
            DHmemcpy(a4, &v46, a5);
            DHfree(v38);
            v24 = 0;
          }
          else
          {
            v24 = 65514;
          }
          DHfree(v14);
          goto LABEL_29;
        }
        LODWORD(v20) = 0;
        v21 = (char *)&v43;
        if ( v42 < 8 )
        {
          v22 = v17;
        }
        else
        {
          v22 = v17;
          if ( (unsigned __int64)((char *)v17 - (char *)&v43) >= 0x20 )
          {
            if ( v42 < 0x20 )
            {
              v23 = 0;
              goto LABEL_17;
            }
            v23 = v42 & 0x7FFFFFE0;
            v25 = v17 + 1;
            v26 = (int8x16_t *)v44;
            v27 = v23;
            do
            {
              v28 = v26[-1];
              v29 = *v26;
              v27 -= 32;
              v26 += 2;
              v25[-1] = vmvnq_s8(v28);
              *v25 = vmvnq_s8(v29);
              v25 += 2;
            }
            while ( v27 );
            if ( v23 == v18 )
              goto LABEL_24;
            if ( (v18 & 0x18) != 0 )
            {
LABEL_17:
              v20 = v18 & 0x7FFFFFF8;
              v30 = (int8x8_t *)((char *)v17 + v23);
              v21 = (char *)&v44[-1] + v20;
              v22 = (int8x16_t *)((char *)v17 + v20);
              v31 = (int8x8_t *)((char *)&v44[-1] + v23);
              v32 = v23 - v20;
              do
              {
                v33.n64_u64[0] = v31->n64_u64[0];
                ++v31;
                v32 += 8;
                v30->n64_u64[0] = vmvn_s8(v33).n64_u64[0];
                ++v30;
              }
              while ( v32 );
              if ( v20 == v18 )
                goto LABEL_24;
              goto LABEL_22;
            }
            v22 = (int8x16_t *)((char *)v17 + v23);
            LODWORD(v20) = v18 & 0x7FFFFFE0;
            v21 = (char *)&v44[-1] + v23;
          }
        }
LABEL_22:
        v34 = v18 - v20;
        do
        {
          v35 = *v21++;
          --v34;
          v22->n128_u8[0] = ~v35;
          v22 = (int8x16_t *)((char *)v22 + 1);
        }
        while ( v34 );
LABEL_24:
        LODWORD(v18) = v42;
        goto LABEL_25;
      }
      v24 = 65514;
      v19 = (int8x16_t *)v14;
    }
LABEL_29:
    DHfree(v19);
    return v24;
  }
  return 65514;
}

//----- (00000000000161B4) ----------------------------------------------------
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  __int64 v6; // x0
  char *v7; // x23
  unsigned int v8; // w22
  char *v9; // x0
  char *v10; // x21
  char *v12; // x0

  v6 = DHstrstr();
  if ( v6 )
    v7 = (char *)(v6 + 1);
  else
    v7 = a3;
  if ( !(unsigned int)DHstrnicmp(a1, "ALL", 4) )
    return 1;
  if ( !(unsigned int)DHstrnicmp(a1, "LOCAL", 6) )
    return (unsigned int)DHstrnicmp(v7, "local", 5) != 0;
  if ( (unsigned int)DHstrnicmp(v7, "p-cluster", 9) )
  {
    v8 = DHstrlen(v7);
    v9 = (char *)DHmalloc(v8 + 1);
    if ( v9 )
    {
      v10 = v9;
      DHmemset(v9, 0, v8 + 1);
      DHstrcpy_s(v10, v8 + 1, v7);
      DHstrlwr(v10);
      goto LABEL_13;
    }
    return 65514;
  }
  v8 = DHstrlen("p-cluster");
  v12 = (char *)DHmalloc(v8 + 1);
  if ( !v12 )
    return 65514;
  v10 = v12;
  DHmemset(v12, 0, v8 + 1);
  DHstrncpy_s((__int64)v10, v8 + 1, (__int64)"p-cluster", v8);
LABEL_13:
  if ( (unsigned int)DHstrnicmp(a1, "domain", 7) )
  {
    DHfree(v10);
    return 0;
  }
  else
  {
    if ( a2 )
    {
      while ( (unsigned int)DHstrnicmp(v10, *(_BYTE **)a2, v8) )
      {
        a2 = *(_QWORD *)(a2 + 16);
        if ( !a2 )
          goto LABEL_21;
      }
      LODWORD(a2) = 1;
    }
LABEL_21:
    DHfree(v10);
    return (unsigned int)a2;
  }
}

//----- (000000000001635C) ----------------------------------------------------
char *__fastcall sub_1635C(char *result, __int64 a2, int *a3, int *a4)
{
  int v4; // w8
  int v5; // w9
  int v6; // t1
  int v7; // w10
  int v8; // t1
  int v9; // w9
  int v10; // w11
  int v11; // w10
  int v12; // w10
  char v13; // w9
  __int64 v14; // x9
  char v15; // t1
  int v16; // w9
  int v17; // w9
  int v18; // w11
  int v19; // w12
  unsigned int v20; // w9
  char v21; // w10
  int v22; // w10
  char v23; // w9
  char v24; // w10
  __int64 v25; // x10
  int i; // w8

  *a4 = 0;
  *a3 = 0;
  v4 = (unsigned __int8)*result;
  if ( v4 == 32 )
  {
    v5 = *a4 + 1;
    do
    {
      *a4 = v5++;
      v6 = (unsigned __int8)*++result;
      v4 = v6;
    }
    while ( v6 == 32 );
  }
  if ( v4 == 34 )
  {
    ++*a4;
    v8 = (unsigned __int8)*++result;
    v7 = v8;
  }
  else
  {
    v7 = v4;
  }
  v9 = v4 != 34;
  v10 = v7 == 59 && v4 != 34;
  if ( !v7 )
    v10 = 1;
  if ( v7 != 34 )
    v9 = 1;
  if ( v9 != v10 )
  {
    while ( 1 )
    {
      if ( v7 != 92 )
        goto LABEL_24;
      v11 = (unsigned __int8)result[1];
      if ( v11 == 34 || v11 == 92 )
      {
        ++result;
        ++*a4;
LABEL_24:
        v14 = *a3;
        v15 = *result++;
        *a3 = v14 + 1;
        *(_BYTE *)(a2 + v14) = v15;
        v16 = *a4 + 1;
        goto LABEL_25;
      }
      if ( v11 != 48 || ((unsigned __int8)result[2] | 0x20) != 0x78 )
        goto LABEL_24;
      v12 = (unsigned __int8)result[3];
      v13 = v12 - 48;
      if ( (unsigned int)(v12 - 48) >= 0xA )
      {
        if ( (unsigned int)(v12 - 65) > 5 )
        {
          v20 = v12 - 97;
          v21 = v12 - 87;
          if ( v20 >= 6 )
            v13 = 0;
          else
            v13 = v21;
        }
        else
        {
          v13 = v12 - 55;
        }
      }
      v22 = (unsigned __int8)result[4];
      v23 = 16 * v13;
      if ( (unsigned int)(v22 - 48) > 9 )
      {
        if ( (unsigned int)(v22 - 65) <= 5 )
        {
          v24 = v22 - 55;
LABEL_44:
          v23 |= v24;
          goto LABEL_45;
        }
        if ( (unsigned int)(v22 - 97) <= 5 )
        {
          v24 = v22 - 87;
          goto LABEL_44;
        }
      }
      else
      {
        v23 |= v22 - 48;
      }
LABEL_45:
      v25 = *a3;
      result += 5;
      *a3 = v25 + 1;
      *(_BYTE *)(a2 + v25) = v23;
      v16 = *a4 + 5;
LABEL_25:
      *a4 = v16;
      v17 = *a3;
      if ( *a3 <= 254 )
      {
        v7 = (unsigned __int8)*result;
        v18 = v4 != 34;
        v19 = v7 == 59 && v4 != 34;
        if ( !*result )
          v19 = 1;
        if ( v7 != 34 )
          v18 = 1;
        if ( v18 != v19 )
          continue;
      }
      goto LABEL_47;
    }
  }
  v17 = *a3;
LABEL_47:
  *(_BYTE *)(a2 + v17) = 0;
  for ( i = (unsigned __int8)*result; *result; i = (unsigned __int8)*result )
  {
    if ( i == 59 )
      break;
    ++result;
    ++*a4;
  }
  return result;
}

//----- (0000000000016548) ----------------------------------------------------
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5)
{
  int v5; // w11
  __int64 v6; // x8
  _BYTE *v7; // x10
  unsigned int v8; // t1

  v5 = (int)a4;
  *a5 = 0;
  if ( a3 )
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *a2++;
      --v6;
      *v7 = a0123456789abcd[(unsigned __int64)v8 >> 4];
      v5 = (_DWORD)v7 + 2;
      v7[1] = a0123456789abcd[v8 & 0xF];
      v7 += 2;
    }
    while ( v6 );
  }
  *a5 = v5 - (_DWORD)a4;
}

//----- (000000000001659C) ----------------------------------------------------
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3)
{
  *a3 = 0;
}

//----- (00000000000165A4) ----------------------------------------------------
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  int v4; // w11
  __int64 v5; // x8
  _BYTE *v6; // x10
  unsigned int v7; // t1

  v4 = (int)a3;
  *a4 = 0;
  if ( a2 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      v7 = *result++;
      --v5;
      *v6 = a0123456789abcd[(unsigned __int64)v7 >> 4];
      v4 = (_DWORD)v6 + 2;
      v6[1] = a0123456789abcd[v7 & 0xF];
      v6 += 2;
    }
    while ( v5 );
  }
  *a4 = v4 - (_DWORD)a3;
  return result;
}

//----- (00000000000165F8) ----------------------------------------------------
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x1
  FILE *v6; // x0
  FILE *v7; // x22

  ++qword_24A98;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( !strcmp(a1, "*") )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4DED;
      else
        v5 = off_20068[a2 - 1];
      v6 = fopen(a1, v5);
      if ( v6 )
      {
        v7 = v6;
        printLogD();
        v4[1] = v7;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        ++qword_24AA0;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 20068: using guessed type char *off_20068[4];
// 24A98: using guessed type __int64 qword_24A98;
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (000000000001671C) ----------------------------------------------------
void *__fastcall DHmalloc(int a1)
{
  void *v1; // x19

  if ( a1 )
  {
    ++qword_24A98;
    v1 = malloc(a1);
    printLogD();
  }
  else
  {
    printLogD();
    return 0;
  }
  return v1;
}
// 24A98: using guessed type __int64 qword_24A98;

//----- (000000000001678C) ----------------------------------------------------
void __fastcall DHfree(void *a1)
{
  printLogD();
  if ( a1 )
  {
    ++qword_24AA0;
    free(a1);
  }
}
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (00000000000167E4) ----------------------------------------------------
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  FILE *v2; // x21

  if ( (unsigned int)(a2 - 1) > 3 )
    v2 = 0;
  else
    v2 = fopen(filename, off_20068[a2 - 1]);
  printLogD();
  return v2;
}
// 20068: using guessed type char *off_20068[4];

//----- (000000000001685C) ----------------------------------------------------
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x22
  int v6; // w0
  FILE *v7; // x0
  FILE *v8; // x22

  printLogD();
  ++qword_24A98;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( a1 < 1 )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4DED;
      else
        v5 = off_20068[a2 - 1];
      printLogD();
      v6 = dup(a1);
      v7 = fdopen(v6, v5);
      if ( v7 )
      {
        v8 = v7;
        rewind(v7);
        printLogD();
        v4[1] = v8;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        printLogD();
        ++qword_24AA0;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 20068: using guessed type char *off_20068[4];
// 24A98: using guessed type __int64 qword_24A98;
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (00000000000169C8) ----------------------------------------------------
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  __int64 v4; // x22
  int v5; // w0
  FILE *v6; // x0
  FILE *v7; // x21

  printLogD();
  if ( (unsigned int)(a2 - 1) <= 3
    && (v4 = *((int *)&unk_7470 + (unsigned int)(a2 - 1)),
        v5 = dup(a1),
        (v6 = fdopen(v5, (const char *)&unk_7470 + v4)) != 0) )
  {
    v7 = v6;
    rewind(v6);
    printLogD();
    return v7;
  }
  else
  {
    printLogD();
    return 0;
  }
}

//----- (0000000000016A80) ----------------------------------------------------
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  int v2; // w8
  FILE *v3; // x0
  FILE *v4; // x20

  if ( a1 )
  {
    v2 = *(unsigned __int16 *)a1;
    v3 = (FILE *)a1[1];
    if ( v2 )
    {
      fclose(v3);
    }
    else if ( v3 )
    {
      v4 = v3;
      printLogD();
      ++qword_24AA0;
      free(v4);
    }
    printLogD();
    ++qword_24AA0;
    free(a1);
  }
}
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (0000000000016B28) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(result + 28) = a2;
      return 1;
    }
  }
  return result;
}

//----- (0000000000016B48) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  _OWORD *v5; // x20
  _QWORD *v6; // x21
  __int64 v7; // x22
  __int64 v8; // x23
  int v9; // w24
  __int64 v10; // x24
  __int64 v11; // x22
  int v12; // w23
  __int64 v13; // x8
  __int128 *v14; // x10
  _OWORD *v15; // x11
  __int64 v16; // x12
  __int128 v17; // q0
  __int128 v18; // q1
  __int64 v19; // x12
  __int64 *v20; // x10
  _QWORD *v21; // x11
  __int64 v22; // x12
  __int64 v23; // t1
  __int64 v24; // x9
  _BYTE *v25; // x10
  char *v26; // x8
  char v27; // t1

  if ( result )
  {
    if ( *(_WORD *)result )
      return 0;
    v6 = (_QWORD *)(result + 8);
    v5 = *(_OWORD **)(result + 8);
    if ( *(_DWORD *)(result + 16) < a3 )
    {
      if ( v5 )
      {
        v7 = result;
        v8 = a2;
        v9 = a4;
        printLogD();
        ++qword_24AA0;
        free(v5);
        a2 = v8;
        result = v7;
        a4 = v9;
        *v6 = 0;
        v6[1] = 0;
      }
      if ( !a3 )
      {
        printLogD();
        result = 0;
        *v6 = 0;
        return result;
      }
      v10 = result;
      v11 = a2;
      v12 = a4;
      ++qword_24A98;
      v5 = malloc(a3);
      printLogD();
      *v6 = v5;
      if ( !v5 )
        return 0;
      result = v10;
      a4 = v12;
      a2 = v11;
      *(_DWORD *)(v10 + 16) = a3;
    }
    if ( a3 < 1 || !a2 || !v5 )
      goto LABEL_27;
    v13 = 0;
    if ( (unsigned int)a3 >= 8 && (unsigned __int64)v5 - a2 >= 0x20 )
    {
      if ( (unsigned int)a3 < 0x20 )
      {
        v13 = 0;
        goto LABEL_22;
      }
      v13 = a3 & 0x7FFFFFE0;
      v14 = (__int128 *)(a2 + 16);
      v15 = v5 + 1;
      v16 = v13;
      do
      {
        v17 = *(v14 - 1);
        v18 = *v14;
        v16 -= 32;
        v14 += 2;
        *(v15 - 1) = v17;
        *v15 = v18;
        v15 += 2;
      }
      while ( v16 );
      if ( v13 == a3 )
        goto LABEL_27;
      if ( (a3 & 0x18) != 0 )
      {
LABEL_22:
        v19 = v13;
        v13 = a3 & 0x7FFFFFF8;
        v20 = (__int64 *)(a2 + v19);
        v21 = (_QWORD *)((char *)v5 + v19);
        v22 = v19 - v13;
        do
        {
          v23 = *v20++;
          v22 += 8;
          *v21++ = v23;
        }
        while ( v22 );
        if ( v13 == a3 )
          goto LABEL_27;
      }
    }
    v24 = (unsigned int)a3 - v13;
    v25 = (char *)v5 + v13;
    v26 = (char *)(a2 + v13);
    do
    {
      v27 = *v26++;
      --v24;
      *v25++ = v27;
    }
    while ( v24 );
LABEL_27:
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
    return 1;
  }
  return result;
}
// 20: using guessed type __int64;
// 24A98: using guessed type __int64 qword_24A98;
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (0000000000016D34) ----------------------------------------------------
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v4; // x4
  __int64 v5; // x9
  __int64 v6; // x10
  _OWORD *v7; // x11
  _OWORD *v8; // x12
  __int128 v9; // q1
  __int64 v10; // x10

  v4 = 0;
  if ( a1 && a3 && a2 >= a4 )
  {
    if ( a4 < 1 )
      return a1;
    v5 = 0;
    if ( (unsigned int)a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( (unsigned int)a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_13;
      }
      v6 = 0;
      v5 = a4 & 0x7FFFFFE0;
      do
      {
        v7 = (_OWORD *)(a3 + v6);
        v8 = (_OWORD *)(a1 + v6);
        v6 += 32;
        v9 = v7[1];
        *v8 = *v7;
        v8[1] = v9;
      }
      while ( v5 != v6 );
      if ( v5 == a4 )
        return a1;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_13:
        v10 = v5;
        v5 = a4 & 0x7FFFFFF8;
        do
        {
          *(_QWORD *)(a1 + v10) = *(_QWORD *)(a3 + v10);
          v10 += 8;
        }
        while ( v5 != v10 );
        if ( v5 == a4 )
          return a1;
        goto LABEL_16;
      }
    }
    do
    {
LABEL_16:
      *(_BYTE *)(a1 + v5) = *(_BYTE *)(a3 + v5);
      ++v5;
    }
    while ( a4 != v5 );
    return a1;
  }
  return v4;
}

//----- (0000000000016DF4) ----------------------------------------------------
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  int v2; // w8
  int v3; // w9

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 28);
      v2 = *(_DWORD *)(result + 32);
      result = 1;
      if ( v2 == v3 )
        *a2 = 1;
    }
  }
  return result;
}

//----- (0000000000016E24) ----------------------------------------------------
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  int v3; // w8
  int v4; // w9
  int v5; // w8

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 32);
      v4 = *(_DWORD *)(result + 24);
      if ( v3 < v4 || *(_DWORD *)(result + 20) + v4 <= v3 )
      {
        *a2 = 1;
        v5 = *(_DWORD *)(result + 32);
        result = 1;
        *a3 = v5;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

//----- (0000000000016E7C) ----------------------------------------------------
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3)
{
  __int64 v3; // x8
  int v5; // w11
  int v6; // w8
  __int64 v7; // x9
  int v8; // w8
  __int64 v9; // x10
  __int64 v10; // x11
  __int64 v11; // x12
  __int64 v12; // x9
  char *v13; // x11
  char *v14; // x10
  char v15; // t1
  bool v16; // cf
  _OWORD *v17; // x13
  __int128 *v18; // x12
  __int64 v19; // x14
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x14
  __int64 v23; // x12
  char *v24; // x13
  __int64 v25; // x14
  __int64 *v26; // x12
  __int64 v27; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_WORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_DWORD *)(a1 + 24);
    v7 = (unsigned int)(v5 - v6);
    if ( v5 - v6 < 0 || (v8 = *(_DWORD *)(a1 + 20), v8 <= (int)v7) )
    {
      LODWORD(v3) = 0;
      return (unsigned int)v3;
    }
    if ( (int)(v7 + a3) <= v8 )
      v3 = a3;
    else
      v3 = (unsigned int)(v8 - v7);
    if ( !ptr )
      goto LABEL_20;
    v9 = *(_QWORD *)(a1 + 8);
    if ( !v9 || (int)v3 < 1 )
      goto LABEL_20;
    if ( (unsigned int)v3 < 8 || (unsigned __int64)&ptr[-v9 - v7] < 0x20 )
    {
      v10 = 0;
LABEL_16:
      v11 = v10 + v7;
      v12 = v10 - v3;
      v13 = &ptr[v10];
      v14 = (char *)(v9 + v11);
      do
      {
        v15 = *v14++;
        v16 = __CFADD__(v12++, 1);
        *v13++ = v15;
      }
      while ( !v16 );
LABEL_19:
      v5 = *(_DWORD *)(a1 + 32);
LABEL_20:
      *(_DWORD *)(a1 + 32) = v5 + v3;
      return (unsigned int)v3;
    }
    if ( (unsigned int)v3 >= 0x20 )
    {
      v10 = v3 & 0x7FFFFFE0;
      v17 = ptr + 16;
      v18 = (__int128 *)(v7 + v9 + 16);
      v19 = v10;
      do
      {
        v20 = *(v18 - 1);
        v21 = *v18;
        v19 -= 32;
        v18 += 2;
        *(v17 - 1) = v20;
        *v17 = v21;
        v17 += 2;
      }
      while ( v19 );
      if ( v10 == v3 )
        goto LABEL_19;
      if ( (v3 & 0x18) == 0 )
        goto LABEL_16;
    }
    else
    {
      v10 = 0;
    }
    v22 = v10;
    v10 = v3 & 0x7FFFFFF8;
    v23 = v22 + v7;
    v24 = &ptr[v22];
    v25 = v22 - v10;
    v26 = (__int64 *)(v9 + v23);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *(_QWORD *)v24 = v27;
      v24 += 8;
    }
    while ( v25 );
    if ( v10 == v3 )
      goto LABEL_19;
    goto LABEL_16;
  }
  LODWORD(v3) = fread(ptr, 1u, (int)a3, *(FILE **)(a1 + 8));
  return (unsigned int)v3;
}

//----- (0000000000016FD0) ----------------------------------------------------
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3)
{
  return fread(ptr, 1u, a3, stream);
}

//----- (0000000000016FF4) ----------------------------------------------------
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3)
{
  if ( a1 && *(_WORD *)a1 )
    return fwrite(ptr, 1u, a3, *(FILE **)(a1 + 8));
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000001702C) ----------------------------------------------------
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3)
{
  return fwrite(ptr, 1u, a3, s);
}

//----- (0000000000017050) ----------------------------------------------------
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  __int64 v3; // x19
  FILE *v4; // x0
  int v5; // w2
  int v7; // w8

  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
  {
    v3 = a1;
    v4 = *(FILE **)(a1 + 8);
    if ( a3 == 1 )
      v5 = 1;
    else
      v5 = 2 * (a3 == 2);
    if ( (fseek(v4, a2, v5) & 0x80000000) == 0 )
    {
      a1 = v3;
      if ( *(_WORD *)v3 )
        return ftell(*(FILE **)(v3 + 8));
      return *(int *)(a1 + 32);
    }
    return -1;
  }
  switch ( a3 )
  {
    case 3:
      *(_DWORD *)(a1 + 32) = a2;
      return *(int *)(a1 + 32);
    case 2:
      v7 = *(_DWORD *)(a1 + 28);
      goto LABEL_15;
    case 1:
      v7 = *(_DWORD *)(a1 + 32);
LABEL_15:
      *(_DWORD *)(a1 + 32) = v7 + a2;
      break;
  }
  return *(int *)(a1 + 32);
}

//----- (00000000000170F8) ----------------------------------------------------
__int64 __fastcall DHfsMetaTell(__int64 a1)
{
  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
    return ftell(*(FILE **)(a1 + 8));
  return *(int *)(a1 + 32);
}

//----- (000000000001711C) ----------------------------------------------------
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  if ( (unsigned int)(a3 - 1) > 2 || fseek(a1, a2, dword_7480[a3 - 1]) < 0 )
    return -1;
  else
    return ftell(a1);
}
// 7480: using guessed type _DWORD dword_7480[3];

//----- (0000000000017174) ----------------------------------------------------
__int64 __fastcall DHfsMetaSize(const char *a1)
{
  FILE *v2; // x0
  FILE *v3; // x20
  unsigned int v4; // w19

  if ( !strcmp(a1, "*") )
    return (unsigned int)-1;
  v2 = fopen(a1, "rb");
  if ( !v2 )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = v2;
    fseek(v2, 0, 2);
    v4 = ftell(v3);
    fclose(v3);
  }
  return v4;
}

//----- (00000000000171E4) ----------------------------------------------------
__int64 __fastcall DHfsSize(const char *a1)
{
  FILE *v1; // x19
  unsigned int v2; // w20

  v1 = fopen(a1, "rb");
  fseek(v1, 0, 2);
  v2 = ftell(v1);
  fseek(v1, 0, 0);
  fclose(v1);
  return v2;
}

//----- (0000000000017240) ----------------------------------------------------
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return memset(a1, a2, a3);
}

//----- (0000000000017248) ----------------------------------------------------
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return memcpy(a1, a2, a3);
}

//----- (0000000000017250) ----------------------------------------------------
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3)
{
  return memcmp(a1, a2, a3);
}

//----- (0000000000017258) ----------------------------------------------------
void *__fastcall DHmemchr(const void *a1, int a2, int a3)
{
  return memchr(a1, a2, a3);
}

//----- (0000000000017260) ----------------------------------------------------
void DHmemcount()
{
  printLogD();
  printLogD();
}
// 24A98: using guessed type __int64 qword_24A98;
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (00000000000172AC) ----------------------------------------------------
size_t __fastcall DHstrlen(const char *a1)
{
  return strlen(a1);
}

//----- (00000000000172C0) ----------------------------------------------------
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  if ( strlen(s) >= a2 )
    return 0xFFFFFFFFLL;
  strcpy(a1, s);
  return 0;
}

//----- (0000000000017318) ----------------------------------------------------
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3)
{
  return strncpy(a1, a2, a3);
}

//----- (0000000000017320) ----------------------------------------------------
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w8
  __int64 v5; // x8
  __int64 v6; // x9
  __int128 *v8; // x10
  _OWORD *v9; // x11
  __int64 v10; // x12
  __int128 v11; // q0
  __int128 v12; // q1
  __int64 v13; // x12
  __int64 *v14; // x10
  _QWORD *v15; // x11
  __int64 v16; // x12
  __int64 v17; // t1
  _BYTE *v18; // x10
  char *v19; // x11
  __int64 v20; // x8
  char v21; // t1

  v4 = 22;
  if ( !a1 || !a3 )
    return v4;
  if ( a2 < 1 )
    return 34;
  if ( (int)a4 >= 1 )
  {
    v5 = 0;
    v6 = a4;
    if ( a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_15;
      }
      v5 = a4 & 0x7FFFFFE0;
      v8 = (__int128 *)(a3 + 16);
      v9 = (_OWORD *)(a1 + 16);
      v10 = v5;
      do
      {
        v11 = *(v8 - 1);
        v12 = *v8;
        v10 -= 32;
        v8 += 2;
        *(v9 - 1) = v11;
        *v9 = v12;
        v9 += 2;
      }
      while ( v10 );
      if ( v5 == a4 )
        goto LABEL_20;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_15:
        v13 = v5;
        v5 = a4 & 0x7FFFFFF8;
        v14 = (__int64 *)(a3 + v13);
        v15 = (_QWORD *)(a1 + v13);
        v16 = v13 - v5;
        do
        {
          v17 = *v14++;
          v16 += 8;
          *v15++ = v17;
        }
        while ( v16 );
        if ( v5 == a4 )
          goto LABEL_20;
      }
    }
    v18 = (_BYTE *)(a1 + v5);
    v19 = (char *)(a3 + v5);
    v20 = a4 - v5;
    do
    {
      v21 = *v19++;
      --v20;
      *v18++ = v21;
    }
    while ( v20 );
    goto LABEL_20;
  }
  v6 = 0;
LABEL_20:
  v4 = 0;
  *(_BYTE *)(a1 + v6) = 0;
  return v4;
}

//----- (000000000001740C) ----------------------------------------------------
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4)
{
  int v5; // w8
  __int64 result; // x0

  v5 = strcmp(a1, s2);
  result = 0;
  *a4 = v5;
  return result;
}

//----- (000000000001743C) ----------------------------------------------------
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return strncmp(a1, a2, a3);
}

//----- (0000000000017444) ----------------------------------------------------
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // w8
  int v4; // w10
  int v5; // w9

  if ( a3 < 1 )
    return 0;
  v3 = a3 + 1;
  while ( 1 )
  {
    v4 = (unsigned __int8)*a2;
    v5 = (unsigned __int8)*a1;
    if ( !*a2 || !*a1 )
      break;
    if ( (unsigned int)(v4 - 97) < 0x1A )
      LOBYTE(v4) = v4 - 32;
    if ( (unsigned int)(v5 - 97) < 0x1A )
      LOBYTE(v5) = v5 - 32;
    if ( (unsigned __int8)v5 != (unsigned __int8)v4 )
      break;
    --v3;
    ++a1;
    ++a2;
    if ( v3 <= 1 )
      return 0;
  }
  return (unsigned __int8)(v5 - v4);
}

//----- (00000000000174B8) ----------------------------------------------------
char *__fastcall DHstrncat(char *a1, const char *a2, int a3)
{
  return strncat(a1, a2, a3);
}

//----- (00000000000174C0) ----------------------------------------------------
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  __int64 result; // x0
  char *v7; // x20
  signed __int64 v9; // x0
  __int64 v10; // x8
  __int64 v11; // x9
  unsigned __int64 v12; // x12
  unsigned __int64 v13; // x11
  char *v14; // x9
  __int64 v15; // x10
  char *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x15
  __int128 v19; // q0
  __int128 v20; // q1
  char *v21; // x10
  char v22; // t1

  result = 22;
  if ( s && a3 )
  {
    if ( a2 < 1 )
      return 34;
    v7 = s;
    LODWORD(v9) = strlen(s);
    if ( a4 < 1 )
    {
      v14 = v7;
    }
    else
    {
      v9 = (int)v9;
      v10 = (int)v9 + a4;
      if ( (int)v9 + 1LL > v10 )
        v11 = (int)v9 + 1LL;
      else
        v11 = (int)v9 + a4;
      v12 = v11 - (int)v9;
      if ( v12 >= 0x20 )
      {
        v14 = v7;
        v15 = a3;
        if ( (unsigned __int64)&v7[(int)v9 - a3] >= 0x20 )
        {
          v13 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = &v7[(int)v9 + 16];
          v17 = (__int128 *)(a3 + 16);
          v9 = (int)v9 + (v12 & 0xFFFFFFFFFFFFFFE0LL);
          v18 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v18 -= 32LL;
            v17 += 2;
            *((_OWORD *)v16 - 1) = v19;
            *(_OWORD *)v16 = v20;
            v16 += 32;
          }
          while ( v18 );
          if ( v12 == v13 )
            goto LABEL_19;
        }
        else
        {
          v13 = 0;
        }
      }
      else
      {
        v13 = 0;
        v14 = v7;
        v15 = a3;
      }
      v21 = (char *)(v15 + v13);
      do
      {
        v22 = *v21++;
        v14[v9++] = v22;
      }
      while ( v9 < v10 );
    }
LABEL_19:
    v14[(int)v9] = 0;
    return 0;
  }
  return result;
}

//----- (00000000000175D8) ----------------------------------------------------
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  int8x16_t *v3; // x19
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x9
  unsigned __int8 v6; // w12
  bool v7; // cf
  int8x16_t *v8; // x22
  int8x16_t *v9; // x8
  __int64 v10; // x10
  int8x16_t *v11; // x13
  int8x16_t *v12; // x14
  int8x16_t v13; // q0
  int8x16_t v14; // q1
  __int8 v15; // t1
  int8x16_t v17; // [xsp+7h] [xbp-29h] BYREF
  __int64 v18; // [xsp+28h] [xbp-8h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a3 - 37 >= 0xFFFFFFDD )
  {
    v3 = a2;
    v4 = 0;
    v5 = a1;
    do
    {
      if ( v5 % a3 >= 0xA )
        v6 = v5 % a3 + 87;
      else
        v6 = (v5 % a3) | 0x30;
      v7 = v5 >= a3;
      v17.n128_u8[v4++] = v6;
      v5 /= a3;
    }
    while ( v7 );
    v8 = (int8x16_t *)((char *)&v17 + v4);
    if ( !a2 )
    {
      if ( (_DWORD)v4 == -1 )
      {
        printLogD();
        v3 = 0;
      }
      else
      {
        ++qword_24A98;
        v3 = (int8x16_t *)malloc((int)v4 + 1);
        printLogD();
      }
    }
    v9 = v3;
    if ( v8 <= &v17 )
      goto LABEL_21;
    if ( v4 >= 0x20 )
    {
      if ( v3 >= v8 || (v9 = v3, &v17 >= (int8x16_t *)((char *)v3 + v4)) )
      {
        v10 = 0;
        v9 = (int8x16_t *)((char *)v3 + (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v8 = (int8x16_t *)((char *)&v17 + v4 - (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v11 = v3 + 1;
        do
        {
          v12 = (int8x16_t *)((char *)&v17 + v4 + v10);
          v10 -= 32;
          v13 = vrev64q_s8(v12[-1]);
          v14 = vrev64q_s8(v12[-2]);
          v11[-1] = vextq_s8(v13, v13, 8u);
          *v11 = vextq_s8(v14, v14, 8u);
          v11 += 2;
        }
        while ( -(__int64)(v4 & 0xFFFFFFFFFFFFFFE0LL) != v10 );
        if ( v4 == (v4 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_21;
      }
    }
    else
    {
      v9 = v3;
    }
    do
    {
      v15 = v8[-1].n128_i8[15];
      v8 = (int8x16_t *)((char *)v8 - 1);
      v9->n128_u8[0] = v15;
      v9 = (int8x16_t *)((char *)v9 + 1);
    }
    while ( v8 > &v17 );
LABEL_21:
    v9->n128_u8[0] = 0;
    return v3;
  }
  return 0;
}
// 24A98: using guessed type __int64 qword_24A98;

//----- (0000000000017790) ----------------------------------------------------
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return strchr(a1, a2);
}

//----- (0000000000017798) ----------------------------------------------------
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  int v4; // w0
  unsigned __int8 *v5; // x19
  int v6; // w0
  unsigned __int8 *v7; // x21
  int v8; // w23
  int v9; // w0
  int v10; // w24
  size_t v11; // x23
  size_t v12; // x23
  int v13; // w0
  int v15; // w8
  unsigned __int8 *v16; // x9
  int v17; // t1
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // t1
  char *v21; // x0
  const char *v22; // x23

  v4 = strlen(a1);
  if ( v4 == -1 )
  {
    printLogD();
    v5 = 0;
  }
  else
  {
    ++qword_24A98;
    v5 = (unsigned __int8 *)malloc(v4 + 1);
    printLogD();
  }
  v6 = strlen(a2);
  if ( v6 == -1 )
  {
    printLogD();
    if ( !v5 )
      return 0;
    goto LABEL_16;
  }
  ++qword_24A98;
  v7 = (unsigned __int8 *)malloc(v6 + 1);
  printLogD();
  if ( !v5 )
    return 0;
  if ( !v7 )
  {
LABEL_16:
    printLogD();
    ++qword_24AA0;
    free(v5);
    return 0;
  }
  v8 = strlen(a1);
  v9 = strlen(a2);
  if ( !a1 )
  {
    v13 = 22;
LABEL_22:
    strerror(v13);
    printLogD();
    return 0;
  }
  v10 = v9;
  if ( (strlen(a1) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v8 >= 1 )
  {
    v11 = v8 & 0x7FFFFFFF;
    memcpy(v5, a1, v11);
    v5[v11] = 0;
    if ( a2 )
      goto LABEL_13;
    goto LABEL_20;
  }
  *v5 = 0;
  if ( !a2 )
  {
LABEL_20:
    v13 = 22;
    goto LABEL_22;
  }
LABEL_13:
  if ( (strlen(a2) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v10 < 1 )
  {
    v12 = 0;
  }
  else
  {
    v12 = v10 & 0x7FFFFFFF;
    memcpy(v7, a2, v12);
  }
  v15 = *v5;
  v7[v12] = 0;
  if ( v15 )
  {
    v16 = v5 + 1;
    do
    {
      if ( (unsigned int)(v15 - 65) <= 0x19 )
        *(v16 - 1) = v15 | 0x20;
      v17 = *v16++;
      v15 = v17;
    }
    while ( v17 );
  }
  v18 = *v7;
  if ( *v7 )
  {
    v19 = v7 + 1;
    do
    {
      if ( (unsigned int)(v18 - 65) <= 0x19 )
        *(v19 - 1) = v18 | 0x20;
      v20 = *v19++;
      v18 = v20;
    }
    while ( v20 );
  }
  v21 = strstr((const char *)v5, (const char *)v7);
  if ( v21 )
    v22 = &a1[v21 - (char *)v5];
  else
    v22 = 0;
  printLogD();
  ++qword_24AA0;
  free(v5);
  printLogD();
  ++qword_24AA0;
  free(v7);
  return v22;
}
// 24A98: using guessed type __int64 qword_24A98;
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (0000000000017AA4) ----------------------------------------------------
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  int v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = (unsigned __int8)*result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned int)(v1 - 65) <= 0x19 )
        *(v2 - 1) = v1 | 0x20;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (0000000000017AD8) ----------------------------------------------------
_BYTE *__fastcall DHstrupr(_BYTE *result)
{
  char v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = *result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (0000000000017B10) ----------------------------------------------------
__int64 DHvsnprintf(char *a1, int a2, char *s, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v9; // [xsp+F8h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 && a2 >= 1 && s && (int)strlen(s) < a2 )
  {
    va_start(va, s);
    va_copy(arg, va);
    vsnprintf(a1, (unsigned int)a2, s, arg);
  }
  return 0;
}

//----- (0000000000017BEC) ----------------------------------------------------
__int64 DHsprintf(char *a1, const char *a2, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v5; // [xsp+F8h] [xbp-8h]

  va_start(va, a2);
  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, a2, arg);
  return 0;
}

//----- (0000000000017C80) ----------------------------------------------------
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v6; // [xsp+F8h] [xbp-8h]

  va_start(va, format);
  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, format, arg);
  return 0;
}

//----- (0000000000017D18) ----------------------------------------------------
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  unsigned int v2; // w19
  unsigned int v3; // w8
  int v4; // w8
  int v5; // w9
  struct tm v7; // [xsp+0h] [xbp-40h] BYREF
  __int64 v8; // [xsp+38h] [xbp-8h]

  v2 = 0;
  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (a1 & 0xFFFE) <= 0x7F5 )
    v3 = (unsigned __int16)a1;
  else
    v3 = 2037;
  v7.tm_isdst = 0;
  *(_QWORD *)&v7.tm_wday = 0;
  if ( v3 >= 0x7B2 )
  {
    v4 = v3 - 1900;
    v7.tm_hour = HIWORD(a1);
    v7.tm_mday = WORD2(a1);
    v5 = WORD1(a1) - 1;
    if ( (a1 & 0xFFFF0000) == 0 )
      v5 = 0;
    v7.tm_mon = v5;
    v7.tm_year = v4;
    v7.tm_sec = HIWORD(a2);
    v7.tm_min = (unsigned __int16)a2;
    v2 = mktime(&v7);
    printLogD();
  }
  return v2;
}

//----- (0000000000017DD8) ----------------------------------------------------
__int64 __fastcall DHGetStateInfo(void *a1)
{
  FILE *v2; // x0
  FILE *v3; // x21
  int v4; // w0
  unsigned int v6; // [xsp+4h] [xbp-D5Ch] BYREF
  int v7; // [xsp+8h] [xbp-D58h] BYREF
  _BYTE v8[244]; // [xsp+Ch] [xbp-D54h] BYREF
  __int128 v9; // [xsp+100h] [xbp-C60h] BYREF
  _BYTE v10[32]; // [xsp+110h] [xbp-C50h] BYREF
  int8x16_t src[2]; // [xsp+130h] [xbp-C30h] BYREF
  _QWORD v12[128]; // [xsp+158h] [xbp-C08h] BYREF
  char v13[1024]; // [xsp+558h] [xbp-808h] BYREF
  _BYTE s[1024]; // [xsp+958h] [xbp-408h] BYREF
  __int64 v15; // [xsp+D58h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  v6 = 0;
  v7 = 0;
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  memset(src, 0, sizeof(src));
  v2 = fopen("/data/data/com.skt.skaf.Z000HDRMDS/files/stateInfo.dat", "r");
  if ( v2 )
  {
    v3 = v2;
    printLogD();
    LODWORD(v3) = fread(s, 1u, 0x400u, v3);
    printLogD();
    __memcpy_chk(v13, s, (int)v3, 1024);
    printLogD();
    base64_decode(v13, (__int64)v12, (unsigned int *)&v7);
    printLogD();
    base64_decode("uLZ7EW2RgRj3xG7upVkEUg==", (__int64)v10, &v6);
    printLogD();
    AES_set_decrypt_key();
    AES_cbc_encrypt(v12, src, v7, (__int64)v8, &v9, 0);
    __strlen_chk((const char *)src, 0x20u);
    printLogD();
    v4 = __strlen_chk((const char *)src, 0x20u);
    memcpy(a1, src, v4);
    printLogD();
    return 0;
  }
  else
  {
    printLogD();
    return 0xFFFFFFFFLL;
  }
}
// 1B900: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018004) ----------------------------------------------------
__int64 DHcurrentTime_ByLib()
{
  return 0;
}

//----- (000000000001800C) ----------------------------------------------------
__int64 DHcurrentTime()
{
  unsigned int v0; // w19
  time_t v2; // [xsp+0h] [xbp-10h] BYREF
  __int64 v3; // [xsp+8h] [xbp-8h]

  v3 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = 0;
  v0 = time(&v2);
  printLogD();
  return v0;
}

//----- (000000000001807C) ----------------------------------------------------
__int64 DHAuthTime_ByLib()
{
  return 0;
}

//----- (0000000000018084) ----------------------------------------------------
__int64 DHAuthTime_ByFile()
{
  unsigned int v2; // w19
  __int64 v3; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v4; // [xsp+8h] [xbp-98h]
  char v5; // [xsp+Ah] [xbp-96h]
  __int128 v6; // [xsp+10h] [xbp-90h] BYREF
  __int128 v7; // [xsp+20h] [xbp-80h]
  __int128 v8; // [xsp+30h] [xbp-70h]
  __int128 v9; // [xsp+40h] [xbp-60h]
  __int128 v10; // [xsp+50h] [xbp-50h]
  __int128 v11; // [xsp+60h] [xbp-40h]
  __int128 v12; // [xsp+70h] [xbp-30h]
  __int128 v13; // [xsp+80h] [xbp-20h]
  __int64 v14; // [xsp+98h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v5 = 0;
  if ( (DHGetStateInfo(&v6) & 0x80000000) != 0 )
    return 0;
  if ( (unsigned __int16)v7 != 21582 || BYTE2(v7) != 58 )
  {
    fclose(0);
    return 0;
  }
  v3 = *(_QWORD *)((char *)&v7 + 3);
  v4 = *(_WORD *)((char *)&v7 + 11);
  __strlen_chk((const char *)&v3, 0xBu);
  v2 = atoi((const char *)&v3);
  printLogD();
  return v2;
}

//----- (0000000000018158) ----------------------------------------------------
__int64 DHAuthTime()
{
  time_t v1; // [xsp+0h] [xbp-10h] BYREF
  __int64 v2; // [xsp+8h] [xbp-8h]

  v2 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  return (unsigned int)time(&v1) - 1600;
}

//----- (00000000000181A4) ----------------------------------------------------
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  int v5; // w21
  __int64 v6; // x8
  int v7; // w9
  __int64 v8; // x9
  __int64 v9; // x10
  char *v10; // x12
  __int64 v11; // x11
  char *v12; // x10
  _BYTE *v13; // x12
  char v14; // t1
  __int128 *v16; // x11
  _OWORD *v17; // x12
  __int64 v18; // x13
  __int128 v19; // q0
  __int128 v20; // q1
  __int64 v21; // x13
  char *v22; // x12
  __int64 *v23; // x11
  __int64 v24; // x13
  _QWORD *v25; // x12
  __int64 v26; // t1
  __int128 v27; // [xsp+8h] [xbp-18h]

  _ReadStatusReg(TPIDR_EL0);
  printLogD();
  if ( !a3 )
  {
    ++qword_24A98;
    a3 = (__int16 *)malloc(0xEu);
    printLogD();
    if ( !a3 )
      return 0xFFFFFFFFLL;
  }
  v5 = strlen((const char *)a1);
  printLogD();
  if ( v5 != 11 )
  {
    *a3 = v5;
    if ( !a1 )
      return StrErrorReturn(22);
    v8 = (unsigned int)(__int16)v5;
    if ( (int)v8 < 1 )
    {
      v8 = 0;
LABEL_18:
      *((_BYTE *)a3 + v8 + 2) = 0;
      goto LABEL_19;
    }
    if ( (unsigned int)v8 < 8 || (unsigned __int64)((char *)a3 - (char *)a1 + 2) < 0x20 )
    {
      v9 = 0;
LABEL_11:
      v10 = (char *)a3 + v9;
      v11 = v8 - v9;
      v12 = (char *)a1 + v9;
      v13 = v10 + 2;
      do
      {
        v14 = *v12++;
        --v11;
        *v13++ = v14;
      }
      while ( v11 );
      goto LABEL_18;
    }
    if ( (unsigned int)v8 >= 0x20 )
    {
      v9 = v8 & 0x7FFFFFE0;
      v16 = (__int128 *)(a1 + 2);
      v17 = a3 + 9;
      v18 = v9;
      do
      {
        v19 = *(v16 - 1);
        v20 = *v16;
        v18 -= 32;
        v16 += 2;
        *(v17 - 1) = v19;
        *v17 = v20;
        v17 += 2;
      }
      while ( v18 );
      if ( v9 == v8 )
        goto LABEL_18;
      if ( (v5 & 0x18) == 0 )
        goto LABEL_11;
    }
    else
    {
      v9 = 0;
    }
    v21 = v9;
    v9 = v8 & 0x7FFFFFF8;
    v22 = (char *)a3 + v21;
    v23 = (__int64 *)((char *)a1 + v21);
    v24 = v21 - v9;
    v25 = v22 + 2;
    do
    {
      v26 = *v23++;
      v24 += 8;
      *v25++ = v26;
    }
    while ( v24 );
    if ( v9 == v8 )
      goto LABEL_18;
    goto LABEL_11;
  }
  if ( !a1 )
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  v6 = *a1;
  v7 = *(_DWORD *)((char *)a1 + 7);
  *a3 = 10;
  *(_QWORD *)&v27 = v6;
  *(_WORD *)((char *)&v27 + 7) = v7;
  *((_BYTE *)a3 + 12) = 0;
  a3[5] = HIWORD(v7);
  *(_QWORD *)(a3 + 1) = *(_QWORD *)((char *)&v27 + 1);
LABEL_19:
  printLogD();
  return (unsigned int)*a3;
}
// 24A98: using guessed type __int64 qword_24A98;

//----- (0000000000018420) ----------------------------------------------------
void __fastcall DHFreeClientID(void *a1)
{
  if ( a1 )
  {
    printLogD();
    printLogD();
    ++qword_24AA0;
    free(a1);
  }
}
// 24AA0: using guessed type __int64 qword_24AA0;

//----- (0000000000018484) ----------------------------------------------------
__int64 DHGetClientID_ByLib()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000001848C) ----------------------------------------------------
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  __int16 *v8; // x24
  __int64 v9; // x22
  __int64 v11; // x8
  char *v12; // x10
  __int64 v13; // x9
  _BYTE *v14; // x8
  char *v15; // x10
  char v16; // t1
  __int128 *v17; // x9
  _OWORD *v18; // x10
  __int64 v19; // x11
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x11
  char *v23; // x9
  _QWORD *v24; // x10
  __int64 v25; // x11
  __int64 *v26; // x9
  __int64 v27; // t1

  printLogD();
  if ( !a4 || (v8 = *a4) == 0 || (v9 = (unsigned int)*v8, !*v8) )
  {
    *a2 = 0;
    return 0xFFFFFFFFLL;
  }
  if ( !strcmp(a1, "min") )
  {
    *a2 = v9;
    if ( !a3 )
    {
      strerror(22);
      printLogD();
      return StrErrorReturn(22);
    }
    if ( (int)v9 < 1 )
    {
      v9 = 0;
LABEL_17:
      *(_BYTE *)(a3 + v9) = 0;
      goto LABEL_18;
    }
    if ( (unsigned int)v9 < 8 || (unsigned __int64)(a3 - (_QWORD)v8 - 2) < 0x20 )
    {
      v11 = 0;
LABEL_12:
      v12 = (char *)v8 + v11;
      v13 = v9 - v11;
      v14 = (_BYTE *)(a3 + v11);
      v15 = v12 + 2;
      do
      {
        v16 = *v15++;
        --v13;
        *v14++ = v16;
      }
      while ( v13 );
      goto LABEL_17;
    }
    if ( (unsigned int)v9 >= 0x20 )
    {
      v11 = v9 & 0x7FE0;
      v17 = (__int128 *)(v8 + 9);
      v18 = (_OWORD *)(a3 + 16);
      v19 = v11;
      do
      {
        v20 = *(v17 - 1);
        v21 = *v17;
        v19 -= 32;
        v17 += 2;
        *(v18 - 1) = v20;
        *v18 = v21;
        v18 += 2;
      }
      while ( v19 );
      if ( v11 == v9 )
        goto LABEL_17;
      if ( (v9 & 0x18) == 0 )
        goto LABEL_12;
    }
    else
    {
      v11 = 0;
    }
    v22 = v11;
    v11 = v9 & 0x7FF8;
    v23 = (char *)v8 + v22;
    v24 = (_QWORD *)(a3 + v22);
    v25 = v22 - v11;
    v26 = (__int64 *)(v23 + 2);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *v24++ = v27;
    }
    while ( v25 );
    if ( v11 == v9 )
      goto LABEL_17;
    goto LABEL_12;
  }
  *a2 = 0;
LABEL_18:
  printLogD();
  return *a2;
}

//----- (0000000000018664) ----------------------------------------------------
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned int v5; // w21
  __int64 v7; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v8; // [xsp+8h] [xbp-98h]
  char v9; // [xsp+Ah] [xbp-96h]
  _OWORD v10[8]; // [xsp+10h] [xbp-90h] BYREF
  __int64 v11; // [xsp+98h] [xbp-8h]

  v11 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  if ( (DHGetStateInfo(v10) & 0x80000000) != 0 )
  {
    return 0;
  }
  else if ( *(_DWORD *)((char *)v10 + 1) == 978209101 )
  {
    v7 = *(_QWORD *)((char *)v10 + 5);
    v8 = *(_WORD *)((char *)v10 + 13);
    v5 = __strlen_chk((const char *)&v7, 0xBu);
    *a2 = v5;
    __strncpy_chk2(a3, &v7, (int)v5, -1, 11);
    printLogD();
  }
  else
  {
    printLogD();
    v5 = 0;
    *a2 = 0;
  }
  return v5;
}
// 1C000: using guessed type __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018780) ----------------------------------------------------
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3)
{
  __int64 v7; // x8
  const char *v8; // x9
  char *v9; // x10
  __int64 v10; // x11
  char v11; // t1

  printLogD();
  if ( strcmp(a1, "min") )
  {
    *a2 = 0;
    return *a2;
  }
  v7 = *a2;
  if ( (int)v7 > 9 )
  {
    if ( a3 )
    {
      strcpy(a3, "1057402191");
      return *a2;
    }
  }
  else if ( a3 )
  {
    if ( (int)v7 < 1 )
    {
      *a3 = 0;
    }
    else
    {
      v8 = "1057402191";
      v9 = a3;
      v10 = *a2;
      do
      {
        v11 = *v8++;
        --v10;
        *v9++ = v11;
      }
      while ( v10 );
      a3[v7] = 0;
    }
    return *a2;
  }
  strerror(22);
  printLogD();
  return StrErrorReturn(22);
}

//----- (00000000000188C4) ----------------------------------------------------
__int64 DHGetDeviceID_ByLib()
{
  return 4294967286LL;
}

//----- (00000000000188CC) ----------------------------------------------------
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  __int64 result; // x0

  if ( a1 )
  {
    result = 0;
    strcpy(a1, "DIGICAPS1234567890");
  }
  else
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  return result;
}

//----- (000000000001893C) ----------------------------------------------------
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  void *v6; // x21
  uint32x4_t v7; // q0
  const float *v8; // x8
  uint32x4_t v9; // q1
  const float *v10; // x8
  uint32x4_t v11; // q3
  const float *v12; // x8
  uint32x4_t v13; // q4
  unsigned int v14; // w9
  __int128 v15; // [xsp+0h] [xbp-70h] BYREF
  __int64 v16; // [xsp+10h] [xbp-60h] BYREF
  unsigned int v17; // [xsp+18h] [xbp-58h]
  int v18; // [xsp+1Ch] [xbp-54h] BYREF
  _DWORD v19[2]; // [xsp+60h] [xbp-10h] BYREF
  __int64 v20; // [xsp+68h] [xbp-8h]

  v20 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = DHmalloc(a3 + 1);
  DHmemset(v6, 0, a3 + 1);
  DHmemcpy_s((__int64)v6, a3 + 1, a1, a3);
  v17 = 0;
  v15 = xmmword_7380;
  v16 = 3285377520LL;
  sub_18B4C(&v15, a1, a3);
  v19[0] = bswap32(v17);
  v19[1] = bswap32(HIDWORD(v16));
  sub_18B4C(&v15, (__int64)&unk_5808, 1u);
  while ( (WORD2(v16) & 0x1F8) != 0x1C0 )
    sub_18B4C(&v15, (__int64)&unk_748C, 1u);
  sub_18B4C(&v15, (__int64)v19, 8u);
  v7 = vld1q_dup_f32((const float *)&v15);
  v8 = (const float *)&v15 + 1;
  v9 = vld1q_dup_f32(v8);
  v10 = (const float *)&v15 + 2;
  v11 = vld1q_dup_f32(v10);
  v12 = (const float *)((unsigned __int64)&v15 | 0xC);
  v13 = vld1q_dup_f32(v12);
  LODWORD(v12) = WORD1(v16);
  v7.n128_u64[0] = vmovn_s32(vshlq_u32(v7, (uint32x4_t)xmmword_73F0)).n64_u64[0];
  v14 = bswap32((unsigned __int16)v16) >> 16;
  a2[1].n128_u8[0] = BYTE3(v16);
  a2[1].n128_u8[1] = (unsigned __int8)v12;
  v7.n128_u64[0] = vuzp1_s8((int8x8_t)v7.n128_u64[0], (int8x8_t)v7.n128_u64[0]).n64_u64[0];
  a2[1].n128_u16[1] = v14;
  v7.n128_u32[1] = vuzp1_s8(vmovn_s32(vshlq_u32(v9, (uint32x4_t)xmmword_73F0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0];
  v7.n128_u64[1] = __PAIR64__(
                     vuzp1_s8(vmovn_s32(vshlq_u32(v13, (uint32x4_t)xmmword_73F0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0],
                     vuzp1_s8(vmovn_s32(vshlq_u32(v11, (uint32x4_t)xmmword_73F0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0]);
  *a2 = v7;
  DHmemset(&v18, 0, 64);
  DHmemset(&v15, 0, 20);
  DHmemset((char *)&v16 + 4, 0, 8);
  DHmemset(v19, 0, 8);
  DHmemcpy_s(a1, a3 + 1, (__int64)v6, a3);
  DHfree(v6);
}
// 7380: using guessed type __int128 xmmword_7380;
// 73F0: using guessed type __int128 xmmword_73F0;

//----- (0000000000018B4C) ----------------------------------------------------
__int64 __fastcall sub_18B4C(_DWORD *a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // x8
  __int64 v7; // x24
  int v8; // w9
  unsigned int v9; // w22
  unsigned int v10; // w23
  __int64 v11; // x8

  v3 = (unsigned int)a1[5];
  v7 = (v3 >> 3) & 0x3F;
  v8 = a1[6] + __CFADD__((_DWORD)v3, 8 * a3) + (a3 >> 29);
  a1[5] = v3 + 8 * a3;
  a1[6] = v8;
  if ( (unsigned int)v7 + a3 < 0x40 )
  {
    v9 = 0;
    v11 = (v3 >> 3) & 0x3F;
  }
  else
  {
    v9 = 64 - v7;
    DHmemcpy_s((__int64)a1 + v7 + 28, 64, a2, 64 - v7);
    sub_18C28(a1, a1 + 7);
    v10 = v7 ^ 0x7F;
    if ( ((unsigned int)v7 ^ 0x7F) >= a3 )
    {
      v11 = 0;
    }
    else
    {
      do
      {
        sub_18C28(a1, (unsigned int *)(a2 + v10 - 63));
        v10 += 64;
      }
      while ( v10 < a3 );
      v11 = 0;
      v9 = v10 - 63;
    }
  }
  return DHmemcpy_s((__int64)a1 + v11 + 28, 64, a2 + v9, a3 - v9);
}

//----- (0000000000018C28) ----------------------------------------------------
int32x4_t __fastcall sub_18C28(_DWORD *a1, unsigned int *a2)
{
  int v2; // w9
  int v3; // w12
  int v4; // w14
  int v5; // w2
  unsigned __int64 v6; // t2
  int v7; // w16
  int v8; // w17
  int v9; // w9
  unsigned int v10; // w10
  unsigned int v11; // w11
  int v12; // w15
  int v13; // w17
  int v14; // w13
  int v15; // w12
  unsigned int v16; // w4
  int v17; // w2
  int v18; // w14
  unsigned int v19; // w15
  int v20; // w17
  int v21; // w9
  int v22; // w3
  int v23; // w16
  int v24; // w5
  int v25; // w6
  int v26; // w14
  int v27; // w11
  unsigned int v28; // w17
  int v29; // w12
  unsigned int v30; // w16
  int v31; // w13
  int v32; // w2
  int v33; // w5
  int v34; // w12
  int v35; // w15
  int v36; // w2
  unsigned int v37; // w20
  int v38; // w5
  int v39; // w21
  int v40; // w9
  unsigned int v41; // w13
  int v42; // w16
  unsigned int v43; // w19
  int v44; // w14
  int v45; // w2
  int v46; // w6
  unsigned int v47; // w12
  int v48; // w3
  int v49; // w6
  int v50; // w7
  int v51; // w14
  int v52; // w21
  int v53; // w5
  int v54; // w7
  int v55; // w3
  unsigned int v56; // w6
  int v57; // w21
  unsigned int v58; // w9
  int v59; // w22
  int v60; // w2
  int v61; // w23
  int v62; // w7
  int v63; // w22
  int v64; // w21
  unsigned int v65; // w5
  int v66; // w7
  int v67; // w23
  unsigned int v68; // w14
  int v69; // w22
  int v70; // w23
  int v71; // w26
  int v72; // w27
  int v73; // w24
  int v74; // w22
  unsigned int v75; // w3
  int v76; // w25
  int v77; // w7
  int v78; // w10
  int v79; // w2
  int v80; // w25
  int v81; // w24
  int v82; // w25
  unsigned int v83; // w7
  int v84; // w13
  int v85; // w21
  int v86; // w26
  int v87; // w23
  int v88; // w25
  int v89; // w2
  int v90; // w27
  int v91; // w23
  int v92; // w25
  int v93; // w21
  int v94; // w11
  int v95; // w25
  int v96; // w22
  int v97; // w11
  int v98; // w4
  int v99; // w22
  int v100; // w25
  int v101; // w23
  int v102; // w4
  int v103; // w24
  int v104; // w25
  int v105; // w4
  int v106; // w15
  int v107; // w24
  int v108; // w22
  int v109; // w25
  int v110; // w8
  int v111; // w15
  int v112; // w25
  int v113; // w8
  int v114; // w24
  int v115; // w26
  int v116; // w17
  int v117; // w16
  int v118; // w21
  int v119; // w25
  int v120; // w26
  int v121; // w23
  int v122; // w21
  int v123; // w20
  int v124; // w23
  int v125; // w16
  int v126; // w26
  int v127; // w12
  int v128; // w23
  int v129; // w22
  int v130; // w13
  int v131; // w26
  int v132; // w27
  int v133; // w23
  int v134; // w20
  int v135; // w19
  int v136; // w23
  int v137; // w24
  int v138; // w25
  int v139; // w13
  int v140; // w9
  int v141; // w23
  int v142; // w13
  int v143; // w19
  int v144; // w13
  int v145; // w16
  int v146; // w24
  int v147; // w6
  int v148; // w13
  int v149; // w16
  int v150; // w6
  int v151; // w23
  int v152; // w24
  int v153; // w26
  int v154; // w6
  int v155; // w24
  int v156; // w14
  int v157; // w6
  int v158; // w26
  int v159; // w16
  int v160; // w5
  int v161; // w16
  int v162; // w5
  int v163; // w24
  int v164; // w6
  int v165; // w19
  int v166; // w25
  int v167; // w23
  int v168; // w5
  int v169; // w24
  int v170; // w23
  int v171; // w26
  int v172; // w3
  int v173; // w19
  int v174; // w24
  int v175; // w3
  int v176; // w7
  int v177; // w19
  int v178; // w23
  int v179; // w24
  int v180; // w6
  int v181; // w19
  int v182; // w10
  int v183; // w24
  int v184; // w25
  int v185; // w27
  int v186; // w6
  int v187; // w7
  int v188; // w2
  int v189; // w6
  int v190; // w10
  int v191; // w6
  int v192; // w26
  int v193; // w24
  int v194; // w6
  int v195; // w11
  int v196; // w24
  int v197; // w26
  int v198; // w27
  int v199; // w4
  int v200; // w2
  int v201; // w23
  int v202; // w11
  int v203; // w24
  int v204; // w25
  int v205; // w24
  int v206; // w2
  int v207; // w15
  int v208; // w24
  int v209; // w23
  int v210; // w25
  int v211; // w10
  int v212; // w17
  int v213; // w24
  int v214; // w10
  int v215; // w25
  int v216; // w26
  int v217; // w15
  int v218; // w21
  int v219; // w15
  int v220; // w21
  int v221; // w25
  int v222; // w11
  int v223; // w24
  int v224; // w10
  int v225; // w25
  int v226; // w27
  int v227; // w22
  int v228; // w12
  int v229; // w21
  int v230; // w11
  int v231; // w20
  int v232; // w23
  int v233; // w25
  int v234; // w26
  int v235; // w27
  int v236; // w21
  int v237; // w23
  int v238; // w13
  int v239; // w24
  int v240; // w26
  int v241; // w22
  int v242; // w25
  int v243; // w23
  int v244; // w9
  int v245; // w23
  int v246; // w25
  int v247; // w26
  int v248; // w20
  int v249; // w24
  int v250; // w16
  int v251; // w24
  int v252; // w25
  int v253; // w26
  int v254; // w21
  int v255; // w23
  int v256; // w14
  int v257; // w23
  int v258; // w25
  int v259; // w26
  int v260; // w22
  int v261; // w24
  int v262; // w5
  int v263; // w24
  int v264; // w25
  int v265; // w26
  int v266; // w20
  int v267; // w23
  int v268; // w3
  int v269; // w23
  int v270; // w25
  int v271; // w26
  int v272; // w21
  int v273; // w24
  int v274; // w19
  int v275; // w24
  int v276; // w25
  int v277; // w26
  int v278; // w22
  int v279; // w23
  int v280; // w7
  int v281; // w23
  int v282; // w25
  int v283; // w26
  int v284; // w20
  int v285; // w24
  int v286; // w6
  int v287; // w24
  int v288; // w25
  int v289; // w26
  int v290; // w21
  int v291; // w23
  int v292; // w4
  int v293; // w23
  int v294; // w25
  int v295; // w26
  int v296; // w22
  int v297; // w24
  int v298; // w2
  int v299; // w24
  int v300; // w25
  int v301; // w26
  int v302; // w20
  int v303; // w23
  int v304; // w17
  int v305; // w23
  int v306; // w25
  int v307; // w26
  int v308; // w21
  int v309; // w24
  int v310; // w15
  int v311; // w25
  int v312; // w24
  int v313; // w26
  int v314; // w23
  int v315; // w10
  int v316; // w22
  int v317; // w23
  int v318; // w20
  int v319; // w25
  int v320; // w26
  int v321; // w20
  int v322; // w11
  int v323; // w22
  int v324; // w25
  int v325; // w26
  int v326; // w21
  int v327; // w11
  int v328; // w12
  int v329; // w21
  int v330; // w26
  int v331; // w24
  int v332; // w25
  int v333; // w26
  int v334; // w28
  int v335; // w27
  int v336; // w21
  int v337; // w12
  int v338; // w25
  int v339; // w26
  int v340; // w13
  int v341; // w9
  int v342; // w26
  int v343; // w16
  int v344; // w23
  int v345; // w25
  int v346; // w22
  int v347; // w16
  int v348; // w22
  int v349; // w25
  int v350; // w9
  int v351; // w24
  int v352; // w14
  int v353; // w9
  int v354; // w26
  int v355; // w9
  int v356; // w24
  int v357; // w12
  int v358; // w5
  int v359; // w22
  int v360; // w23
  int v361; // w24
  int v362; // w9
  int v363; // w3
  int v364; // w9
  int v365; // w19
  int v366; // w23
  int v367; // w22
  unsigned int v368; // w5
  int v369; // w22
  int v370; // w3
  int v371; // w26
  int v372; // w25
  int v373; // w7
  int v374; // w19
  int v375; // w26
  int v376; // w25
  unsigned int v377; // w3
  unsigned int v378; // w6
  int v379; // w24
  int v380; // w22
  int v381; // w23
  int v382; // w19
  int v383; // w25
  unsigned int v384; // w4
  int v385; // w22
  unsigned int v386; // w2
  int v387; // w24
  int v388; // w23
  int v389; // w7
  unsigned int v390; // w17
  int v391; // w22
  int v392; // w26
  unsigned int v393; // w15
  int v394; // w24
  int v395; // w23
  int v396; // w19
  unsigned int v397; // w10
  int v398; // w22
  int v399; // w25
  int v400; // w23
  int v401; // w24
  unsigned int v402; // w7
  int v403; // w23
  int v404; // w24
  int v405; // w20
  unsigned int v406; // w11
  int v407; // w22
  int v408; // w26
  int v409; // w24
  unsigned int v410; // w19
  int v411; // w21
  int v412; // w23
  int v413; // w24
  int v414; // w22
  unsigned int v415; // w13
  int v416; // w23
  int v417; // w25
  unsigned int v418; // w16
  int v419; // w24
  int v420; // w20
  int v421; // w26
  int v422; // w21
  int v423; // w14
  int v424; // w12
  int v425; // w21
  unsigned int v426; // w20
  int v427; // w5
  unsigned int v428; // w24
  int v429; // w23
  unsigned int v430; // w12
  unsigned int v431; // w11
  int v432; // w4
  int v433; // w22
  unsigned __int32 v434; // w2
  int32x4_t v435; // q0
  unsigned int v436; // w9
  int32x4_t v437; // q1
  int32x4_t result; // q0

  v2 = a1[1];
  v4 = a1[2];
  v3 = a1[3];
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v5 = v6 >> 27;
  v7 = v3 & ~v2;
  v8 = v4 & v2;
  HIDWORD(v6) = v2;
  LODWORD(v6) = v2;
  v9 = v6 >> 2;
  v10 = bswap32(*a2);
  v11 = bswap32(a2[1]);
  v12 = v5 + a1[4] + v10 + (v8 | v7) + 1518500249;
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v13 = v6 >> 27;
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v14 = v6 >> 2;
  v15 = v3 + v11 + (v9 & *a1 | v4 & ~*a1) + 1518500249 + v13;
  v16 = bswap32(a2[2]);
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v17 = v6 >> 2;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v18 = v4 + v16 + (v14 & v12 | v9 & ~v12) + 1518500249 + (v6 >> 27);
  v19 = bswap32(a2[3]);
  v20 = v9 + v19;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v21 = v6 >> 2;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v22 = v6 >> 27;
  v23 = v20 + (v17 & v15 | v14 & ~v15);
  v24 = v17 & ~v18;
  v25 = v21 & v18;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v26 = v6 >> 2;
  v27 = v19 ^ v11;
  v28 = bswap32(a2[4]);
  v29 = v23 + 1518500249 + v22;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v30 = bswap32(a2[5]);
  v31 = v14 + v28 + (v25 | v24) + 1518500249 + (v6 >> 27);
  v32 = v17 + v30 + (v26 & v29 | v21 & ~v29);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v33 = v6 >> 27;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v34 = v6 >> 2;
  v35 = v30 ^ v19;
  v36 = v32 + 1518500249 + v33;
  v37 = bswap32(a2[6]);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v38 = v6 >> 2;
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v39 = v21 + v37 + (v34 & v31 | v26 & ~v31) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v40 = v6 >> 2;
  v41 = bswap32(a2[7]);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v42 = v41 ^ v30;
  v43 = bswap32(a2[8]);
  v44 = v26 + v41 + (v38 & v36 | v34 & ~v36) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v45 = v6 >> 2;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v46 = v34 + v43 + (v40 & v39 | v38 & ~v39) + 1518500249;
  v47 = bswap32(a2[9]);
  v48 = v46 + (v6 >> 27);
  v49 = v45 & v44 | v40 & ~v44;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v50 = v6 >> 27;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v51 = v6 >> 2;
  v52 = v51 & v48;
  v53 = v38 + v47 + v49 + 1518500249 + v50;
  v54 = v45 & ~v48;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v55 = v6 >> 2;
  v56 = bswap32(a2[10]);
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v57 = v56 + v40 + (v52 | v54) + 1518500249 + (v6 >> 27);
  v58 = bswap32(a2[11]);
  v59 = v58 + v45;
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v60 = v6 >> 2;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v61 = v6 >> 27;
  v62 = v59 + (v55 & v53 | v51 & ~v53);
  v63 = v60 & v57 | v55 & ~v57;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v64 = v6 >> 2;
  v65 = bswap32(a2[12]);
  v66 = v62 + 1518500249 + v61;
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v67 = v65 + v51 + v63 + 1518500249;
  v68 = bswap32(a2[13]);
  v69 = v67 + (v6 >> 27);
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v70 = v6 >> 2;
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v71 = v64 & ~v69;
  v72 = v70 & v69;
  v73 = v68 + v55 + (v64 & v66 | v60 & ~v66) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v74 = v6 >> 2;
  v75 = bswap32(a2[14]);
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v76 = v6 >> 27;
  v77 = v70 & ~v73;
  HIDWORD(v6) = v16 ^ v10 ^ v43 ^ v68;
  LODWORD(v6) = HIDWORD(v6);
  v78 = v6 >> 31;
  v79 = v75 + v60 + (v72 | v71) + 1518500249 + v76;
  v80 = v74 & v73;
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v81 = v6 >> 2;
  v82 = v80 | v77;
  v83 = bswap32(a2[15]);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v84 = v47 ^ v41 ^ v83;
  v85 = v83 + v64 + v82 + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v86 = v6 >> 2;
  v87 = v78 + v70 + (v81 & v79 | v74 & ~v79);
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v88 = v6 >> 27;
  HIDWORD(v6) = v27 ^ v47 ^ v75;
  LODWORD(v6) = HIDWORD(v6);
  v89 = v6 >> 31;
  v90 = v86 & v85;
  v91 = v87 + 1518500249 + v88;
  v92 = v81 & ~v85;
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v93 = v6 >> 2;
  v94 = v90 | v92;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v95 = v6 >> 27;
  v96 = v89 + v74 + v94 + 1518500249;
  HIDWORD(v6) = v28 ^ v16 ^ v56 ^ v83;
  LODWORD(v6) = HIDWORD(v6);
  v97 = v6 >> 31;
  v98 = v86 & ~v91;
  v99 = v96 + v95;
  v100 = v93 & v91;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v101 = v6 >> 2;
  v102 = v97 + v81 + (v100 | v98);
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v103 = v6 >> 27;
  v104 = v102 + 1518500249;
  HIDWORD(v6) = v35 ^ v58 ^ v78;
  LODWORD(v6) = HIDWORD(v6);
  v105 = v6 >> 31;
  v106 = v101 & v99 | v93 & ~v99;
  v107 = v104 + v103;
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v108 = v6 >> 2;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v109 = v6 >> 27;
  v110 = v105 + v86 + v106 + 1518500249;
  HIDWORD(v6) = v37 ^ v28 ^ v65 ^ v89;
  LODWORD(v6) = HIDWORD(v6);
  v111 = v6 >> 31;
  v112 = v110 + v109;
  v113 = v108 ^ v101 ^ v107;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v114 = v6 >> 2;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v115 = v6 >> 27;
  HIDWORD(v6) = v42 ^ v68 ^ v97;
  LODWORD(v6) = HIDWORD(v6);
  v116 = v6 >> 31;
  v117 = v111 + v93 + v113 + 1859775393 + v115;
  v118 = v114 ^ v108 ^ v112;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v119 = v6 >> 2;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v120 = v6 >> 27;
  v121 = v116 + v101 + v118 + 1859775393;
  HIDWORD(v6) = v43 ^ v37 ^ v75 ^ v105;
  LODWORD(v6) = HIDWORD(v6);
  v122 = v6 >> 31;
  v123 = v121 + v120;
  v124 = v119 ^ v114 ^ v117;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v125 = v6 >> 2;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v126 = v6 >> 27;
  HIDWORD(v6) = v58 ^ v47 ^ v89 ^ v122;
  LODWORD(v6) = HIDWORD(v6);
  v127 = v6 >> 31;
  v128 = v122 + v108 + v124 + 1859775393;
  HIDWORD(v6) = v84 ^ v111;
  LODWORD(v6) = v84 ^ v111;
  v129 = v6 >> 31;
  v130 = v128 + v126;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v131 = v6 >> 2;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v132 = v6 >> 27;
  v133 = v129 + v114 + (v125 ^ v119 ^ v123) + 1859775393;
  HIDWORD(v6) = v56 ^ v43 ^ v78 ^ v116;
  LODWORD(v6) = HIDWORD(v6);
  v134 = v6 >> 31;
  v135 = v133 + v132;
  v136 = v131 ^ v125 ^ v130;
  v137 = v134 + v119;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v138 = v6 >> 2;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v139 = v6 >> 27;
  HIDWORD(v6) = v68 ^ v58 ^ v105 ^ v134;
  LODWORD(v6) = HIDWORD(v6);
  v140 = v6 >> 31;
  v141 = v137 + v136 + 1859775393 + v139;
  v142 = v138 ^ v131 ^ v135;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v143 = v6 >> 2;
  v144 = v127 + v125 + v142;
  v145 = v65 ^ v56 ^ v97 ^ v129;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v146 = v6 >> 27;
  v147 = v144 + 1859775393;
  HIDWORD(v6) = v145;
  LODWORD(v6) = v145;
  v148 = v6 >> 31;
  v149 = v147 + v146;
  v150 = v143 ^ v138 ^ v141;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v151 = v6 >> 2;
  v152 = v148 + v131;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v153 = v6 >> 27;
  v154 = v152 + v150;
  v155 = v151 ^ v143 ^ v149;
  HIDWORD(v6) = v83 ^ v68 ^ v116 ^ v148;
  LODWORD(v6) = HIDWORD(v6);
  v156 = v6 >> 31;
  v157 = v154 + 1859775393 + v153;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v158 = v6 >> 2;
  v159 = v75 ^ v65 ^ v111;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v160 = v6 >> 27;
  HIDWORD(v6) = v159 ^ v127;
  LODWORD(v6) = v159 ^ v127;
  v161 = v6 >> 31;
  v162 = v140 + v138 + v155 + 1859775393 + v160;
  v163 = v158 ^ v151 ^ v157;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v164 = v6 >> 2;
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v165 = v161 + v143 + v163 + 1859775393 + (v6 >> 27);
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v166 = v6 >> 2;
  v167 = v156 + v151 + (v164 ^ v158 ^ v162) + 1859775393;
  HIDWORD(v6) = v78 ^ v75 ^ v122 ^ v140;
  LODWORD(v6) = HIDWORD(v6);
  v168 = v6 >> 31;
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v169 = v168 + v158;
  v170 = v167 + (v6 >> 27);
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v171 = v6 >> 2;
  v172 = v169 + (v166 ^ v164 ^ v165);
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v173 = v6 >> 27;
  v174 = v172 + 1859775393;
  HIDWORD(v6) = v89 ^ v83 ^ v129 ^ v161;
  LODWORD(v6) = HIDWORD(v6);
  v175 = v6 >> 31;
  v176 = v174 + v173;
  v177 = v171 ^ v166 ^ v170;
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v178 = v6 >> 2;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v179 = v6 >> 27;
  v180 = v175 + v164 + v177;
  HIDWORD(v6) = v97 ^ v78 ^ v134 ^ v156;
  LODWORD(v6) = HIDWORD(v6);
  v181 = v6 >> 31;
  v182 = v180 + 1859775393 + v179;
  v183 = v181 + v166;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v184 = v6 >> 2;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v185 = v6 >> 27;
  v186 = v183 + (v178 ^ v171 ^ v176);
  HIDWORD(v6) = v105 ^ v89 ^ v127 ^ v168;
  LODWORD(v6) = HIDWORD(v6);
  v187 = v6 >> 31;
  v188 = v186 + 1859775393 + v185;
  v189 = v184 ^ v178 ^ v182;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v190 = v6 >> 2;
  v191 = v187 + v171 + v189;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v192 = v6 >> 27;
  v193 = v191 + 1859775393;
  HIDWORD(v6) = v111 ^ v97 ^ v148 ^ v175;
  LODWORD(v6) = HIDWORD(v6);
  v194 = v6 >> 31;
  v195 = v193 + v192;
  v196 = v190 ^ v184 ^ v188;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v197 = v6 >> 2;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v198 = v6 >> 27;
  HIDWORD(v6) = v116 ^ v105 ^ v140 ^ v181;
  LODWORD(v6) = HIDWORD(v6);
  v199 = v6 >> 31;
  v200 = v197 ^ v190 ^ v195;
  v201 = v194 + v178 + v196 + 1859775393 + v198;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v202 = v6 >> 2;
  v203 = v199 + v184;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v204 = v6 >> 27;
  v205 = v203 + v200 + 1859775393;
  HIDWORD(v6) = v122 ^ v111 ^ v161 ^ v187;
  LODWORD(v6) = HIDWORD(v6);
  v206 = v6 >> 31;
  v207 = v205 + v204;
  v208 = v202 ^ v197 ^ v201;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v209 = v6 >> 2;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v210 = v6 >> 27;
  v211 = v206 + v190 + v208;
  HIDWORD(v6) = v129 ^ v116 ^ v156 ^ v194;
  LODWORD(v6) = HIDWORD(v6);
  v212 = v6 >> 31;
  v213 = v209 ^ v202 ^ v207;
  v214 = v211 + 1859775393 + v210;
  v215 = v212 + v197;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v216 = v6 >> 2;
  v217 = v134 ^ v122 ^ v168;
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v218 = v6 >> 27;
  HIDWORD(v6) = v217 ^ v199;
  LODWORD(v6) = v217 ^ v199;
  v219 = v6 >> 31;
  v220 = v215 + v213 + 1859775393 + v218;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v221 = v6 >> 27;
  v222 = v219 + v202 + (v216 ^ v209 ^ v214);
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v223 = v6 >> 2;
  HIDWORD(v6) = v127 ^ v129 ^ v175 ^ v206;
  LODWORD(v6) = HIDWORD(v6);
  v224 = v6 >> 31;
  v225 = v222 + 1859775393 + v221;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v226 = v6 >> 27;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v227 = v6 >> 2;
  HIDWORD(v6) = v140 ^ v127 ^ v187 ^ v219;
  LODWORD(v6) = HIDWORD(v6);
  v228 = v6 >> 31;
  v229 = v224 + v209 + (v223 ^ v216 ^ v220) + 1859775393 + v226;
  HIDWORD(v6) = v148 ^ v134 ^ v181 ^ v212;
  LODWORD(v6) = HIDWORD(v6);
  v230 = v6 >> 31;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v231 = v6 >> 2;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v232 = v6 >> 27;
  v233 = v230 + v216 + ((v225 | v227) & v223 | v225 & v227);
  v234 = (v229 | v231) & v227;
  v235 = v229 & v231;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v236 = v6 >> 2;
  v237 = v233 - 1894007588 + v232;
  HIDWORD(v6) = v161 ^ v148 ^ v194 ^ v224;
  LODWORD(v6) = HIDWORD(v6);
  v238 = v6 >> 31;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v239 = v228 + v223 + (v234 | v235) - 1894007588 + (v6 >> 27);
  v240 = v238 + v227;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v241 = v6 >> 2;
  v242 = (v237 | v236) & v231 | v237 & v236;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v243 = v6 >> 27;
  HIDWORD(v6) = v156 ^ v140 ^ v199 ^ v230;
  LODWORD(v6) = HIDWORD(v6);
  v244 = v6 >> 31;
  v245 = v240 + v242 - 1894007588 + v243;
  v246 = (v239 | v241) & v236 | v239 & v241;
  v247 = v244 + v231;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v248 = v6 >> 2;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v249 = v6 >> 27;
  HIDWORD(v6) = v168 ^ v161 ^ v206 ^ v228;
  LODWORD(v6) = HIDWORD(v6);
  v250 = v6 >> 31;
  v251 = v247 + v246 - 1894007588 + v249;
  v252 = (v245 | v248) & v241 | v245 & v248;
  v253 = v250 + v236;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v254 = v6 >> 2;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v255 = v6 >> 27;
  HIDWORD(v6) = v175 ^ v156 ^ v212 ^ v238;
  LODWORD(v6) = HIDWORD(v6);
  v256 = v6 >> 31;
  v257 = v253 + v252 - 1894007588 + v255;
  v258 = (v251 | v254) & v248 | v251 & v254;
  v259 = v256 + v241;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v260 = v6 >> 2;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v261 = v6 >> 27;
  HIDWORD(v6) = v181 ^ v168 ^ v219 ^ v244;
  LODWORD(v6) = HIDWORD(v6);
  v262 = v6 >> 31;
  v263 = v259 + v258 - 1894007588 + v261;
  v264 = (v257 | v260) & v254 | v257 & v260;
  v265 = v262 + v248;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v266 = v6 >> 2;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v267 = v6 >> 27;
  HIDWORD(v6) = v187 ^ v175 ^ v224 ^ v250;
  LODWORD(v6) = HIDWORD(v6);
  v268 = v6 >> 31;
  v269 = v265 + v264 - 1894007588 + v267;
  v270 = (v263 | v266) & v260 | v263 & v266;
  v271 = v268 + v254;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v272 = v6 >> 2;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v273 = v6 >> 27;
  HIDWORD(v6) = v194 ^ v181 ^ v230 ^ v256;
  LODWORD(v6) = HIDWORD(v6);
  v274 = v6 >> 31;
  v275 = v271 + v270 - 1894007588 + v273;
  v276 = (v269 | v272) & v266 | v269 & v272;
  v277 = v274 + v260;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v278 = v6 >> 2;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v279 = v6 >> 27;
  HIDWORD(v6) = v199 ^ v187 ^ v228 ^ v262;
  LODWORD(v6) = HIDWORD(v6);
  v280 = v6 >> 31;
  v281 = v277 + v276 - 1894007588 + v279;
  v282 = (v275 | v278) & v272 | v275 & v278;
  v283 = v280 + v266;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v284 = v6 >> 2;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v285 = v6 >> 27;
  HIDWORD(v6) = v206 ^ v194 ^ v238 ^ v268;
  LODWORD(v6) = HIDWORD(v6);
  v286 = v6 >> 31;
  v287 = v283 + v282 - 1894007588 + v285;
  v288 = (v281 | v284) & v278 | v281 & v284;
  v289 = v286 + v272;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v290 = v6 >> 2;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v291 = v6 >> 27;
  HIDWORD(v6) = v212 ^ v199 ^ v244 ^ v274;
  LODWORD(v6) = HIDWORD(v6);
  v292 = v6 >> 31;
  v293 = v289 + v288 - 1894007588 + v291;
  v294 = (v287 | v290) & v284 | v287 & v290;
  v295 = v292 + v278;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v296 = v6 >> 2;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v297 = v6 >> 27;
  HIDWORD(v6) = v219 ^ v206 ^ v250 ^ v280;
  LODWORD(v6) = HIDWORD(v6);
  v298 = v6 >> 31;
  v299 = v295 + v294 - 1894007588 + v297;
  v300 = (v293 | v296) & v290 | v293 & v296;
  v301 = v298 + v284;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v302 = v6 >> 2;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v303 = v6 >> 27;
  HIDWORD(v6) = v224 ^ v212 ^ v256 ^ v286;
  LODWORD(v6) = HIDWORD(v6);
  v304 = v6 >> 31;
  v305 = v301 + v300 - 1894007588 + v303;
  v306 = (v299 | v302) & v296 | v299 & v302;
  v307 = v304 + v290;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v308 = v6 >> 2;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v309 = v6 >> 27;
  HIDWORD(v6) = v230 ^ v219 ^ v262 ^ v292;
  LODWORD(v6) = HIDWORD(v6);
  v310 = v6 >> 31;
  v311 = v307 + v306 - 1894007588 + v309;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v312 = v6 >> 2;
  v313 = (v305 | v308) & v302 | v305 & v308;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v314 = v6 >> 27;
  HIDWORD(v6) = v228 ^ v224 ^ v268 ^ v298;
  LODWORD(v6) = HIDWORD(v6);
  v315 = v6 >> 31;
  v316 = v310 + v296 + v313 - 1894007588 + v314;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v317 = v6 >> 2;
  v318 = v315 + v302 + ((v311 | v312) & v308 | v311 & v312);
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v319 = v6 >> 27;
  v320 = v318 - 1894007588;
  HIDWORD(v6) = v238 ^ v230 ^ v274 ^ v304;
  LODWORD(v6) = HIDWORD(v6);
  v321 = v6 >> 31;
  v322 = (v316 | v317) & v312 | v316 & v317;
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v323 = v6 >> 2;
  v324 = v320 + v319;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v325 = v6 >> 27;
  v326 = v321 + v308 + v322 - 1894007588;
  HIDWORD(v6) = v244 ^ v228 ^ v280 ^ v310;
  LODWORD(v6) = HIDWORD(v6);
  v327 = v6 >> 31;
  v328 = v326 + v325;
  v329 = (v324 | v323) & v317 | v324 & v323;
  v330 = v327 + v312;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v331 = v6 >> 2;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v332 = v6 >> 27;
  v333 = v330 + v329 - 1894007588;
  v334 = v328 & v331;
  v335 = (v328 | v331) & v323;
  HIDWORD(v6) = v250 ^ v238 ^ v286 ^ v315;
  LODWORD(v6) = HIDWORD(v6);
  v336 = v6 >> 31;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v337 = v6 >> 2;
  v338 = v333 + v332;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v339 = v6 >> 27;
  HIDWORD(v6) = v256 ^ v244 ^ v292 ^ v321;
  LODWORD(v6) = HIDWORD(v6);
  v340 = v6 >> 31;
  v341 = v262 ^ v250 ^ v298;
  v342 = v336 + v317 + (v335 | v334) - 1894007588 + v339;
  v343 = (v338 | v337) & v331 | v338 & v337;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v344 = v6 >> 2;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v345 = v6 >> 27;
  v346 = v340 + v323 + v343;
  HIDWORD(v6) = v341 ^ v327;
  LODWORD(v6) = v341 ^ v327;
  v347 = v6 >> 31;
  v348 = v346 - 1894007588 + v345;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v349 = v6 >> 2;
  v350 = v347 + v331;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v351 = v6 >> 27;
  HIDWORD(v6) = v268 ^ v256 ^ v304 ^ v336;
  LODWORD(v6) = HIDWORD(v6);
  v352 = v6 >> 31;
  v353 = v350 + (v344 ^ v337 ^ v342) - 899497514;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v354 = v6 >> 2;
  v355 = v353 + v351;
  v356 = v352 + v337;
  HIDWORD(v6) = v274 ^ v262 ^ v310 ^ v340;
  LODWORD(v6) = HIDWORD(v6);
  v357 = v6 >> 31;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v358 = v356 + (v349 ^ v344 ^ v348) - 899497514 + (v6 >> 27);
  v359 = v357 + v344 + (v354 ^ v349 ^ v355);
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v360 = v6 >> 27;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v361 = v6 >> 2;
  v362 = v280 ^ v268 ^ v315 ^ v347;
  v363 = v286 ^ v274;
  HIDWORD(v6) = v362;
  LODWORD(v6) = v362;
  v364 = v6 >> 31;
  v365 = v359 - 899497514 + v360;
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v366 = v6 >> 2;
  v367 = v361 ^ v354 ^ v358;
  HIDWORD(v6) = v363 ^ v321 ^ v352;
  LODWORD(v6) = HIDWORD(v6);
  v368 = v6 >> 31;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v369 = v364 + v349 + v367 - 899497514 + (v6 >> 27);
  v370 = v368 + v354 + (v366 ^ v361 ^ v365);
  v371 = v292 ^ v280 ^ v327;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v372 = v6 >> 27;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v373 = v6 >> 2;
  v374 = v371 ^ v357;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v375 = v6 >> 2;
  v376 = v370 - 899497514 + v372;
  HIDWORD(v6) = v374;
  LODWORD(v6) = v374;
  v377 = v6 >> 31;
  HIDWORD(v6) = v298 ^ v286 ^ v336 ^ v364;
  LODWORD(v6) = HIDWORD(v6);
  v378 = v6 >> 31;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v379 = v377 + v361 + (v373 ^ v366 ^ v369) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v380 = v6 >> 27;
  v381 = v378 + v366 + (v375 ^ v373 ^ v376) - 899497514;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v382 = v6 >> 2;
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v383 = v6 >> 2;
  HIDWORD(v6) = v304 ^ v292 ^ v340 ^ v368;
  LODWORD(v6) = HIDWORD(v6);
  v384 = v6 >> 31;
  v385 = v381 + v380;
  HIDWORD(v6) = v310 ^ v298 ^ v347 ^ v377;
  LODWORD(v6) = HIDWORD(v6);
  v386 = v6 >> 31;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v387 = v384 + v373 + (v382 ^ v375 ^ v379) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v388 = v6 >> 27;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v389 = v6 >> 2;
  HIDWORD(v6) = v315 ^ v304 ^ v352 ^ v378;
  LODWORD(v6) = HIDWORD(v6);
  v390 = v6 >> 31;
  v391 = v386 + v375 + (v383 ^ v382 ^ v385) - 899497514 + v388;
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v392 = v6 >> 2;
  HIDWORD(v6) = v321 ^ v310 ^ v357 ^ v384;
  LODWORD(v6) = HIDWORD(v6);
  v393 = v6 >> 31;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v394 = v390 + v382 + (v389 ^ v383 ^ v387) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v395 = v6 >> 27;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v396 = v6 >> 2;
  HIDWORD(v6) = v327 ^ v315 ^ v364 ^ v386;
  LODWORD(v6) = HIDWORD(v6);
  v397 = v6 >> 31;
  v398 = v393 + v383 + (v392 ^ v389 ^ v391) - 899497514 + v395;
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v399 = v6 >> 2;
  v400 = v396 ^ v392 ^ v394;
  v401 = v397 + v389;
  HIDWORD(v6) = v336 ^ v321 ^ v368 ^ v390;
  LODWORD(v6) = HIDWORD(v6);
  v402 = v6 >> 31;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v403 = v401 + v400 - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v404 = v6 >> 27;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v405 = v6 >> 2;
  HIDWORD(v6) = v340 ^ v327 ^ v377 ^ v393;
  LODWORD(v6) = HIDWORD(v6);
  v406 = v6 >> 31;
  v407 = v402 + v392 + (v399 ^ v396 ^ v398) - 899497514 + v404;
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v408 = v6 >> 2;
  v409 = v406 + v396;
  HIDWORD(v6) = v347 ^ v336 ^ v378 ^ v397;
  LODWORD(v6) = HIDWORD(v6);
  v410 = v6 >> 31;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v411 = v409 + (v405 ^ v399 ^ v403) - 899497514 + (v6 >> 27);
  v412 = v410 + v399 + (v408 ^ v405 ^ v407);
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v413 = v6 >> 27;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v414 = v6 >> 2;
  HIDWORD(v6) = v352 ^ v340 ^ v384 ^ v402;
  LODWORD(v6) = HIDWORD(v6);
  v415 = v6 >> 31;
  v416 = v412 - 899497514 + v413;
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v417 = v6 >> 2;
  HIDWORD(v6) = v357 ^ v347 ^ v386 ^ v406;
  LODWORD(v6) = HIDWORD(v6);
  v418 = v6 >> 31;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v419 = v415 + v405 + (v414 ^ v408 ^ v411) - 899497514 + (v6 >> 27);
  v420 = v418 + v408 + (v417 ^ v414 ^ v416);
  v421 = v364 ^ v352;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v422 = v6 >> 27;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v423 = v6 >> 2;
  v424 = v368 ^ v357 ^ v393;
  *a2 = v368;
  a2[1] = v377;
  v425 = v420 - 899497514 + v422;
  HIDWORD(v6) = v421 ^ v390 ^ v410;
  LODWORD(v6) = HIDWORD(v6);
  v426 = v6 >> 31;
  v427 = v423 ^ v417 ^ v419;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v428 = v6 >> 2;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v429 = v6 >> 27;
  a2[2] = v378;
  a2[3] = v384;
  HIDWORD(v6) = v424 ^ v415;
  LODWORD(v6) = v424 ^ v415;
  v430 = v6 >> 31;
  a2[4] = v386;
  a2[5] = v390;
  a2[8] = v402;
  a2[9] = v406;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v431 = v6 >> 2;
  v432 = v426 + v414 + v427 - 899497514 + v429;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v433 = v6 >> 27;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v434 = v6 >> 2;
  a2[6] = v393;
  a2[7] = v397;
  a2[10] = v410;
  a2[11] = v415;
  v435.n128_u32[0] = v430 + v417 + (v428 ^ v423 ^ v425) - 899497514 + v433;
  HIDWORD(v6) = v377 ^ v364 ^ v397 ^ v418;
  LODWORD(v6) = HIDWORD(v6);
  v436 = v6 >> 31;
  a2[12] = v418;
  a2[13] = v426;
  a2[14] = v430;
  a2[15] = v436;
  v435.n128_u32[1] = v434;
  v437 = *(int32x4_t *)(a1 + 1);
  v435.n128_u64[1] = __PAIR64__(v428, v431);
  HIDWORD(v6) = v435.n128_u32[0];
  LODWORD(v6) = v435.n128_u32[0];
  *a1 = *a1 + v436 + v423 + (v431 ^ v428 ^ v432) - 899497514 + (v6 >> 27);
  result = vaddq_s32(v435, v437);
  *(int32x4_t *)(a1 + 1) = result;
  return result;
}

//----- (0000000000019C18) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (0000000000019D38) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsMetaSeek((__int64)v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (0000000000019E58) ----------------------------------------------------
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
  return 0;
}

//----- (0000000000019F38) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x24
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  printLogD();
  v8 = DHfsPfdMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    printLogD();
    if ( (DHfsMetaSeek(*(_QWORD *)(a3 + 8 * v6), 0, 3) & 0x8000000000000000LL) == 0 )
    {
      printLogD();
      return v7;
    }
  }
  return 0;
}

//----- (000000000001A04C) ----------------------------------------------------
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2)
{
  __int64 v2; // x19

  v2 = a2 + 8LL * a1;
  DHfsMetaClose(*(_QWORD **)(v2 + 8));
  *(_QWORD *)(v2 + 8) = -1;
}

//----- (000000000001A078) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  result = DHfsClose();
  *(_QWORD *)(v2 + 8) = -1;
  return result;
}

//----- (000000000001A0A4) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (000000000001A1D4) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (000000000001A304) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  DHfsClose();
  result = 0;
  *(_QWORD *)(v2 + 48) = -1;
  return result;
}

//----- (000000000001A334) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_SetFileSize(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (000000000001A354) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5)
{
  return (unsigned int)(__int16)DHfs_VF_SetBuffer(*(_QWORD *)(a5 + 8LL * a1 + 8), a2, a3, a4);
}

//----- (000000000001A374) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_IsReachedToEndOfFile(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (000000000001A394) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4)
{
  return (unsigned int)(__int16)DHfs_VF_ShouldUpdateBuffer(*(_QWORD *)(a4 + 8LL * a1 + 8), a2, a3);
}

//----- (000000000001A3B8) ----------------------------------------------------
__int64 __fastcall StrErrorReturn(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -37;
  else
    v1 = -23;
  if ( a1 == 22 )
    return 4294967260LL;
  else
    return v1;
}

//----- (000000000001A3D8) ----------------------------------------------------
__int64 __fastcall StrErrorReturn_uch(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -28;
  else
    v1 = -1;
  if ( a1 == 22 )
    return 4294967269LL;
  else
    return v1;
}

//----- (000000000001A3F4) ----------------------------------------------------
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4)
{
  int v4; // w10
  char v5; // w14
  unsigned __int64 v6; // x15
  bool v7; // vf
  char v8; // w12
  _BYTE *v9; // x16
  unsigned int v10; // w11
  unsigned __int64 v11; // x12
  int v12; // w14
  char v13; // w13

  if ( a3 >= 1 )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( (unsigned int)a3 >= 3 )
        v10 = 3;
      else
        v10 = a3;
      v11 = *result << 16;
      if ( a3 == 1 || (v11 = (unsigned int)v11 | (result[1] << 8), a3 == 2) )
      {
        v12 = 0;
        if ( a3 == 1 )
        {
          v13 = 61;
LABEL_14:
          v5 = 61;
          goto LABEL_4;
        }
      }
      else
      {
        v12 = 1;
        v11 = (unsigned int)v11 | result[2];
      }
      v13 = aAbcdefghijklmn[((unsigned __int64)(unsigned int)v11 >> 6) & 0x3F];
      if ( !v12 )
        goto LABEL_14;
      v5 = aAbcdefghijklmn[v11 & 0x3F];
LABEL_4:
      v6 = (unsigned int)v11;
      result += v10;
      v7 = __OFSUB__(a3, v10);
      a3 -= v10;
      v8 = aAbcdefghijklmn[(v11 >> 12) & 0x3F];
      v9 = (_BYTE *)(a2 + v4);
      v4 += 4;
      LOBYTE(v6) = aAbcdefghijklmn[v6 >> 18];
      v9[2] = v13;
      v9[1] = v8;
      *v9 = v6;
      v9[3] = v5;
      if ( (a3 < 0) ^ v7 | (a3 == 0) )
      {
        *a4 = v4;
        return result;
      }
    }
  }
  *a4 = 0;
  return result;
}
// 1A490: conditional instruction was optimized away because w14.4==0
// 1A4A8: conditional instruction was optimized away because w2.4 is in (==0|>=3u)

//----- (000000000001A4D8) ----------------------------------------------------
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  int v2; // w9
  int v3; // w8
  int v4; // w10
  int v5; // w9
  int v6; // w11
  int v7; // w10
  int v8; // w12
  int v9; // w11
  __int64 result; // x0
  int v11; // w9
  unsigned int v12; // w13
  unsigned int v13; // w8
  __int16 v14; // w10

  v2 = *a1;
  v3 = v2 - 65;
  if ( (unsigned int)(v2 - 65) > 0x19 )
  {
    if ( (unsigned int)(v2 - 97) > 0x19 )
    {
      if ( (unsigned int)(v2 - 48) > 9 )
      {
        switch ( v2 )
        {
          case '+':
            v3 = 62;
            break;
          case '=':
            v3 = -1;
            break;
          case '/':
            v3 = 63;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v3 = v2 + 4;
      }
    }
    else
    {
      v3 = v2 - 71;
    }
  }
  v4 = a1[1];
  v5 = v4 - 65;
  if ( (unsigned int)(v4 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v4 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v4 - 48) >= 0xA )
      {
        switch ( v4 )
        {
          case '+':
            v5 = 62;
            break;
          case '/':
            v5 = 63;
            break;
          case '=':
            v5 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v5 = v4 + 4;
      }
    }
    else
    {
      v5 = v4 - 71;
    }
  }
  v6 = a1[2];
  v7 = v6 - 65;
  if ( (unsigned int)(v6 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v6 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v6 - 48) >= 0xA )
      {
        switch ( v6 )
        {
          case '+':
            v7 = 62;
            break;
          case '/':
            v7 = 63;
            break;
          case '=':
            v7 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v7 = v6 + 4;
      }
    }
    else
    {
      v7 = v6 - 71;
    }
  }
  v8 = a1[3];
  v9 = v8 - 65;
  if ( (unsigned int)(v8 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v8 - 97) < 0x1A )
    {
      v9 = v8 - 71;
      goto LABEL_21;
    }
    if ( (unsigned int)(v8 - 48) < 0xA )
    {
      v9 = v8 + 4;
      goto LABEL_21;
    }
    switch ( v8 )
    {
      case '+':
        v9 = 62;
        goto LABEL_21;
      case '/':
        v9 = 63;
        goto LABEL_21;
      case '=':
        v9 = -1;
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  result = 0;
  if ( v3 != -1 && v5 != -1 )
  {
    if ( v7 == -1 && v9 != -1 )
      return 0;
    v11 = v5 << 12;
    v12 = (v11 | (unsigned int)(v3 << 18)) >> 16;
    if ( v7 == -1 )
      v13 = 1;
    else
      v13 = 2;
    if ( v9 == -1 )
      result = v13;
    else
      result = 3;
    *a2 = v12;
    if ( v9 != -1 || v7 != -1 )
    {
      v14 = (_WORD)v7 << 6;
      a2[1] = (unsigned __int16)(v14 & 0xF00 | v11) >> 8;
      if ( v9 == -1 )
      {
        return v13;
      }
      else
      {
        result = 3;
        a2[2] = v9 & 0x3F | v14;
      }
    }
  }
  return result;
}

//----- (000000000001A704) ----------------------------------------------------
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  size_t result; // x0
  int v7; // w22
  __int64 v8; // x24
  unsigned int v9; // w23

  result = DHstrlen(a1);
  if ( (int)result < 1 )
  {
    v9 = 0;
LABEL_7:
    *a3 = v9;
  }
  else
  {
    v7 = result;
    v8 = 0;
    v9 = 0;
    while ( 1 )
    {
      result = base64_decode_atom((unsigned __int8 *)&a1[v8], (_BYTE *)(a2 + v9));
      if ( !(_DWORD)result )
        break;
      v8 += 4;
      v9 += result;
      if ( v7 <= (int)v8 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (000000000001A77C) ----------------------------------------------------
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  if ( a6 )
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (__fastcall *)(_QWORD *, _QWORD *, __int64))AES_encrypt);
  else
    CRYPTO_cbc128_decrypt(
      (__int64)a1,
      a2,
      a3,
      a4,
      (unsigned __int64)a5,
      (__int64 (__fastcall *)(int8x16_t *, int8x16_t *, __int64))AES_decrypt);
}

//----- (000000000001A798) ----------------------------------------------------
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w8
  int v4; // w8
  unsigned int v6; // w8
  unsigned int v7; // w9
  unsigned int v8; // w10
  unsigned int v9; // w11
  __int64 v10; // x9
  unsigned int *v11; // x14
  unsigned __int64 v12; // x16
  int v13; // w1
  int v14; // w0
  int v15; // w17
  unsigned int v16; // w12
  __int64 v17; // x13
  unsigned int *i; // x0
  int v19; // w2
  unsigned int v20; // w12
  __int64 v21; // x13
  unsigned int *j; // x0
  int v23; // w2
  int v24; // w3
  int v25; // w4

  v3 = -1;
  if ( a1 && a3 )
  {
    if ( a2 != 128 && a2 != 256 && a2 != 192 )
      return 4294967294LL;
    if ( a2 == 128 )
    {
      v4 = 10;
    }
    else if ( a2 == 192 )
    {
      v4 = 12;
    }
    else
    {
      v4 = 14;
    }
    a3[60] = v4;
    v6 = bswap32(*a1);
    *a3 = v6;
    v7 = bswap32(a1[1]);
    a3[1] = v7;
    v8 = bswap32(a1[2]);
    a3[2] = v8;
    v9 = bswap32(a1[3]);
    a3[3] = v9;
    if ( a2 == 128 )
    {
      v10 = 0;
      v11 = a3 + 4;
      do
      {
        v12 = *(v11 - 1);
        v13 = *(_DWORD *)((char *)&unk_8490 + v10);
        v10 += 4;
        v6 ^= (byte_7490[4 * BYTE2(v12) + 3] << 24)
            ^ (byte_7890[4 * BYTE1(v12) + 2] << 16)
            ^ (byte_7C90[4 * (unsigned __int8)v12 + 1] << 8)
            ^ byte_8090[(v12 >> 22) & 0x3FC]
            ^ v13;
        v14 = *(v11 - 3) ^ v6;
        v15 = *(v11 - 2) ^ v14;
        *v11 = v6;
        v11[1] = v14;
        v11[2] = v15;
        v11[3] = v15 ^ v12;
        v11 += 4;
      }
      while ( v10 != 40 );
    }
    else
    {
      a3[4] = bswap32(a1[4]);
      v16 = bswap32(a1[5]);
      a3[5] = v16;
      if ( a2 == 192 )
      {
        v17 = 0;
        for ( i = a3 + 11; ; i += 6 )
        {
          v6 ^= (byte_7490[4 * BYTE2(v16) + 3] << 24)
              ^ (byte_7890[4 * BYTE1(v16) + 2] << 16)
              ^ (byte_7C90[4 * (unsigned __int8)v16 + 1] << 8)
              ^ byte_8090[4 * HIBYTE(v16)]
              ^ *(_DWORD *)((char *)&unk_8490 + v17);
          v7 ^= v6;
          v8 ^= v7;
          *(i - 5) = v6;
          *(i - 4) = v7;
          v9 ^= v8;
          *(i - 3) = v8;
          *(i - 2) = v9;
          if ( v17 == 28 )
            break;
          v17 += 4;
          v19 = *(i - 7) ^ v9;
          v16 ^= v19;
          *(i - 1) = v19;
          *i = v16;
        }
      }
      else
      {
        a3[6] = bswap32(a1[6]);
        v20 = bswap32(a1[7]);
        a3[7] = v20;
        v21 = 0;
        for ( j = a3 + 8; ; j += 8 )
        {
          v6 ^= (byte_7490[4 * BYTE2(v20) + 3] << 24)
              ^ (byte_7890[4 * BYTE1(v20) + 2] << 16)
              ^ (byte_7C90[4 * (unsigned __int8)v20 + 1] << 8)
              ^ byte_8090[4 * HIBYTE(v20)]
              ^ *(_DWORD *)((char *)&unk_8490 + v21);
          v7 ^= v6;
          v8 ^= v7;
          *j = v6;
          j[1] = v7;
          v9 ^= v8;
          j[2] = v8;
          j[3] = v9;
          if ( v21 == 24 )
            break;
          v21 += 4;
          v23 = *(j - 4)
              ^ (byte_7490[4 * HIBYTE(v9) + 3] << 24)
              ^ (byte_7890[4 * BYTE2(v9) + 2] << 16)
              ^ (byte_7C90[4 * BYTE1(v9) + 1] << 8)
              ^ byte_8090[4 * (unsigned __int8)v9];
          v24 = *(j - 2);
          v25 = *(j - 3) ^ v23;
          j[4] = v23;
          j[5] = v25;
          v20 ^= v24 ^ v25;
          j[6] = v24 ^ v25;
          j[7] = v20;
        }
      }
    }
    return 0;
  }
  return v3;
}
// 1A9BC: conditional instruction was optimized away because w1.4==100
// 7490: using guessed type unsigned __int8 byte_7490[1024];
// 7890: using guessed type unsigned __int8 byte_7890[1024];
// 7C90: using guessed type unsigned __int8 byte_7C90[1024];
// 8090: using guessed type unsigned __int8 byte_8090[1024];

//----- (000000000001AABC) ----------------------------------------------------
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  __int64 result; // x0
  int v5; // w9
  int v6; // w10
  unsigned int *v7; // x9
  __int64 v8; // x8
  __int64 v9; // x11
  unsigned int *v10; // x10
  __int64 v11; // x11
  unsigned int v12; // w13
  bool v13; // cc
  unsigned int v14; // w13
  unsigned int v15; // w13
  unsigned int v16; // w13
  int *v17; // x11
  int v18; // w13
  unsigned __int64 v19; // x15
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x2
  __int64 v22; // x0
  __int64 v23; // x1
  __int64 v24; // x16
  __int64 v25; // x17
  __int64 v26; // x0
  unsigned __int64 v27; // x1
  __int64 v28; // x16
  __int64 v29; // x15
  __int64 v30; // x17
  __int64 v31; // x0
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x17
  __int64 v34; // x0
  __int64 v35; // x16
  __int64 v36; // x1

  result = private_AES_set_encrypt_key(a1, a2, a3);
  if ( (result & 0x80000000) == 0 )
  {
    v5 = a3[60];
    if ( v5 >= 1 )
    {
      v6 = 4 * v5;
      v7 = a3 + 2;
      v8 = 0;
      v9 = v6;
      v10 = &a3[v6 + 2];
      v11 = v9 - 4;
      do
      {
        v12 = *(v7 - 2);
        v8 += 4;
        v13 = v8 < v11;
        v11 -= 4;
        *(v7 - 2) = *(v10 - 2);
        *(v10 - 2) = v12;
        v14 = *(v7 - 1);
        *(v7 - 1) = *(v10 - 1);
        *(v10 - 1) = v14;
        v15 = *v7;
        *v7 = *v10;
        *v10 = v15;
        v16 = v7[1];
        v7[1] = v10[1];
        v7 += 4;
        v10[1] = v16;
        v10 -= 4;
      }
      while ( v13 );
      if ( (int)a3[60] >= 2 )
      {
        v17 = (int *)(a3 + 7);
        v18 = 1;
        do
        {
          v19 = (unsigned int)*(v17 - 3);
          v20 = (unsigned int)*(v17 - 2);
          ++v18;
          v21 = v20 >> 22;
          v22 = BYTE2(v20);
          v23 = BYTE1(v20);
          v24 = 4LL * (unsigned __int8)*(v17 - 2);
          *(v17 - 3) = dword_88B8[byte_8090[4 * BYTE2(v19)]]
                     ^ dword_84B8[byte_8090[(v19 >> 22) & 0x3FC]]
                     ^ dword_8CB8[byte_8090[4 * BYTE1(v19)]]
                     ^ dword_90B8[byte_8090[4 * (unsigned __int8)*(v17 - 3)]];
          v25 = byte_8090[4 * v22];
          v26 = byte_8090[4 * v23];
          v27 = (unsigned int)*(v17 - 1);
          LODWORD(v19) = dword_88B8[v25]
                       ^ dword_84B8[byte_8090[v21 & 0x3FC]]
                       ^ dword_8CB8[v26]
                       ^ dword_90B8[byte_8090[v24]];
          v28 = 4LL * (unsigned __int8)*(v17 - 1);
          *(v17 - 2) = v19;
          v29 = byte_8090[(v27 >> 22) & 0x3FC];
          v30 = byte_8090[4 * BYTE2(v27)];
          v31 = byte_8090[4 * BYTE1(v27)];
          v32 = (unsigned int)*v17;
          LODWORD(v29) = dword_88B8[v30] ^ dword_84B8[v29];
          v33 = v32 >> 22;
          LODWORD(v28) = dword_8CB8[v31] ^ dword_90B8[byte_8090[v28]];
          v34 = BYTE2(v32);
          LODWORD(v29) = v29 ^ v28;
          v35 = BYTE1(v32);
          v36 = (unsigned __int8)*v17;
          *(v17 - 1) = v29;
          *v17 = dword_88B8[byte_8090[4 * v34]]
               ^ dword_84B8[byte_8090[v33 & 0x3FC]]
               ^ dword_8CB8[byte_8090[4 * v35]]
               ^ dword_90B8[byte_8090[4 * v36]];
          v17 += 4;
        }
        while ( v18 < (int)a3[60] );
      }
    }
    return 0;
  }
  return result;
}
// 8090: using guessed type unsigned __int8 byte_8090[1024];
// 84B8: using guessed type _DWORD dword_84B8[256];
// 88B8: using guessed type _DWORD dword_88B8[256];
// 8CB8: using guessed type _DWORD dword_8CB8[256];
// 90B8: using guessed type _DWORD dword_90B8[256];

//----- (000000000001ACF8) ----------------------------------------------------
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w5
  unsigned int v4; // w16
  _DWORD *v5; // x14
  unsigned int v6; // w15
  unsigned int v7; // w17
  int i; // w13
  unsigned int v9; // w7
  int v10; // w0
  unsigned int v11; // w3
  int v12; // w17
  unsigned int v13; // w25
  unsigned int v14; // w21
  unsigned int v15; // w15
  unsigned int v16; // w22
  unsigned int v17; // w19
  int v18; // w6
  __int64 result; // x0
  int v20; // w24
  int v21; // w25
  int v22; // w5
  int v23; // w22
  int v24; // w23
  int v25; // w24
  int v26; // w26
  int v27; // w17
  int v28; // w0
  _DWORD *v29; // x12

  v3 = bswap32(*a1) ^ *a3;
  v4 = bswap32(a1[1]) ^ a3[1];
  v5 = a3 + 6;
  v6 = bswap32(a1[2]) ^ a3[2];
  v7 = bswap32(a1[3]) ^ a3[3];
  for ( i = ((int)a3[60] >> 1) - 1; ; --i )
  {
    v9 = *(_DWORD *)&byte_8090[4 * BYTE2(v4)]
       ^ *(_DWORD *)&byte_7C90[4 * HIBYTE(v3)]
       ^ *(_DWORD *)&byte_7490[4 * BYTE1(v6)]
       ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v7]
       ^ *(v5 - 2);
    v10 = BYTE2(v7);
    v11 = *(_DWORD *)&byte_8090[4 * BYTE2(v6)]
        ^ *(_DWORD *)&byte_7C90[4 * HIBYTE(v4)]
        ^ *(_DWORD *)&byte_7490[4 * BYTE1(v7)]
        ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v3]
        ^ *(v5 - 1);
    v12 = *(_DWORD *)&byte_8090[4 * BYTE2(v3)]
        ^ *(_DWORD *)&byte_7C90[4 * HIBYTE(v7)]
        ^ *(_DWORD *)&byte_7490[4 * BYTE1(v4)]
        ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v6];
    v13 = HIBYTE(v9);
    v14 = HIBYTE(v11);
    v15 = *(_DWORD *)&byte_8090[4 * v10]
        ^ *(_DWORD *)&byte_7C90[4 * HIBYTE(v6)]
        ^ *(_DWORD *)&byte_7490[4 * BYTE1(v3)]
        ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v4]
        ^ *v5;
    v16 = v12 ^ v5[1];
    v17 = HIBYTE(v15);
    v18 = BYTE2(v16);
    result = HIBYTE(v16);
    if ( !i )
      break;
    v20 = *(_DWORD *)&byte_8090[4 * BYTE2(v11)] ^ *(_DWORD *)&byte_7C90[4 * v13];
    v21 = *(_DWORD *)&byte_7490[4 * BYTE1(v16)];
    v22 = v20
        ^ *(_DWORD *)&byte_7490[4 * BYTE1(v15)]
        ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))];
    v23 = v5[2];
    v24 = v5[3];
    v25 = v5[4];
    v26 = v5[5];
    v27 = *(_DWORD *)&byte_8090[4 * BYTE2(v9)] ^ *(_DWORD *)&byte_7C90[4 * (unsigned int)result];
    v28 = *(_DWORD *)&byte_7490[4 * BYTE1(v11)] ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v15];
    v5 += 8;
    v3 = v22 ^ v23;
    v4 = *(_DWORD *)&byte_8090[4 * BYTE2(v15)]
       ^ *(_DWORD *)&byte_7C90[4 * v14]
       ^ v21
       ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v9]
       ^ v24;
    v6 = *(_DWORD *)&byte_8090[4 * v18]
       ^ *(_DWORD *)&byte_7C90[4 * v17]
       ^ *(_DWORD *)&byte_7490[4 * BYTE1(v9)]
       ^ *(_DWORD *)&byte_7890[4 * (unsigned __int8)v11]
       ^ v25;
    v7 = v27 ^ v28 ^ v26;
  }
  v29 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_7490[4 * v13 + 3] << 24)
         | (byte_7890[4 * BYTE2(v11) + 2] << 16)
         | (byte_7C90[4 * BYTE1(v15) + 1] << 8)
         | byte_8090[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))])
        ^ v29[8]);
  a2[1] = bswap32(
            ((byte_7490[4 * v14 + 3] << 24)
           | (byte_7890[4 * BYTE2(v15) + 2] << 16)
           | (byte_7C90[4 * BYTE1(v16) + 1] << 8)
           | byte_8090[4 * (unsigned __int8)v9])
          ^ v29[9]);
  a2[2] = bswap32(
            ((byte_7490[4 * v17 + 3] << 24)
           | (byte_7890[4 * BYTE2(v16) + 2] << 16)
           | (byte_7C90[4 * BYTE1(v9) + 1] << 8)
           | byte_8090[4 * (unsigned __int8)v11])
          ^ v29[10]);
  a2[3] = bswap32(
            ((byte_7490[4 * (unsigned int)result + 3] << 24)
           | (byte_7890[4 * BYTE2(v9) + 2] << 16)
           | (byte_7C90[4 * BYTE1(v11) + 1] << 8)
           | byte_8090[4 * (unsigned __int8)v15])
          ^ v29[11]);
  return result;
}
// 7490: using guessed type unsigned __int8 byte_7490[1024];
// 7890: using guessed type unsigned __int8 byte_7890[1024];
// 7C90: using guessed type unsigned __int8 byte_7C90[1024];
// 8090: using guessed type unsigned __int8 byte_8090[1024];

//----- (000000000001B034) ----------------------------------------------------
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w13
  unsigned int v4; // w17
  unsigned int v5; // w16
  _DWORD *v6; // x15
  unsigned int v7; // w0
  unsigned int v8; // w3
  int v9; // w14
  unsigned int v10; // w4
  unsigned __int64 v11; // x9
  int v12; // w5
  int v13; // w6
  int v14; // w7
  unsigned __int64 v15; // x16
  unsigned __int64 result; // x0
  unsigned __int64 v17; // x3
  int v18; // w7
  int v19; // w4
  int v20; // w5
  int v21; // w6
  int v22; // w19
  int v23; // w9
  _DWORD *v24; // x8

  v3 = a1[3];
  v4 = bswap32(*a1) ^ *a3;
  v5 = bswap32(a1[1]) ^ a3[1];
  v6 = a3 + 6;
  v7 = bswap32(a1[2]) ^ a3[2];
  v8 = bswap32(v3) ^ a3[3];
  v9 = ((int)a3[60] >> 1) - 1;
  while ( 1 )
  {
    v10 = *(v6 - 1);
    v11 = dword_88B8[BYTE2(v8)]
        ^ dword_84B8[HIBYTE(v4)]
        ^ (unsigned int)(dword_8CB8[BYTE1(v7)] ^ dword_90B8[(unsigned __int8)v5])
        ^ *(v6 - 2);
    v12 = BYTE2(v5);
    v13 = dword_88B8[BYTE2(v4)] ^ dword_84B8[HIBYTE(v5)] ^ dword_8CB8[BYTE1(v8)] ^ dword_90B8[(unsigned __int8)v7];
    v14 = dword_88B8[BYTE2(v7)] ^ dword_84B8[HIBYTE(v8)] ^ dword_8CB8[BYTE1(v5)] ^ dword_90B8[(unsigned __int8)v4];
    v15 = v13 ^ v10;
    result = dword_88B8[v12]
           ^ dword_84B8[HIBYTE(v7)]
           ^ (unsigned int)(dword_8CB8[BYTE1(v4)] ^ dword_90B8[(unsigned __int8)v8])
           ^ *v6;
    v17 = (unsigned int)v14 ^ v6[1];
    if ( !v9 )
      break;
    --v9;
    v18 = v6[3];
    v19 = dword_88B8[BYTE2(v11)] ^ dword_84B8[BYTE3(v15)] ^ dword_8CB8[BYTE1(v17)] ^ dword_90B8[(unsigned __int8)result];
    v4 = dword_88B8[BYTE2(v17)]
       ^ dword_84B8[BYTE3(v11)]
       ^ dword_8CB8[BYTE1(result)]
       ^ dword_90B8[(unsigned __int8)v15]
       ^ v6[2];
    v20 = dword_88B8[BYTE2(v15)] ^ dword_84B8[BYTE3(result)] ^ dword_8CB8[BYTE1(v11)] ^ dword_90B8[(unsigned __int8)v17];
    v21 = v6[4];
    v22 = v6[5];
    v23 = dword_88B8[BYTE2(result)] ^ dword_84B8[BYTE3(v17)] ^ dword_8CB8[BYTE1(v15)] ^ dword_90B8[(unsigned __int8)v11];
    v6 += 8;
    v5 = v19 ^ v18;
    v7 = v20 ^ v21;
    v8 = v23 ^ v22;
  }
  v24 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_94B8[v11 >> 24] << 24)
         | (byte_94B8[BYTE2(v17)] << 16)
         | (byte_94B8[BYTE1(result)] << 8)
         | byte_94B8[(unsigned __int8)(v13 ^ v10)])
        ^ v24[8]);
  a2[1] = bswap32(
            ((byte_94B8[v15 >> 24] << 24)
           | (byte_94B8[BYTE2(v11)] << 16)
           | (byte_94B8[BYTE1(v17)] << 8)
           | byte_94B8[(unsigned __int8)result])
          ^ v24[9]);
  a2[2] = bswap32(
            ((byte_94B8[result >> 24] << 24)
           | (byte_94B8[BYTE2(v15)] << 16)
           | (byte_94B8[BYTE1(v11)] << 8)
           | byte_94B8[(unsigned __int8)v17])
          ^ v24[10]);
  a2[3] = bswap32(
            ((byte_94B8[v17 >> 24] << 24)
           | (byte_94B8[BYTE2(result)] << 16)
           | (byte_94B8[BYTE1(v15)] << 8)
           | byte_94B8[(unsigned __int8)v11])
          ^ v24[11]);
  return result;
}
// 84B8: using guessed type _DWORD dword_84B8[256];
// 88B8: using guessed type _DWORD dword_88B8[256];
// 8CB8: using guessed type _DWORD dword_8CB8[256];
// 90B8: using guessed type _DWORD dword_90B8[256];
// 94B8: using guessed type unsigned __int8 byte_94B8[256];

//----- (000000000001B358) ----------------------------------------------------
const char *AES_options()
{
  return "aes(partial)";
}

//----- (000000000001B36C) ----------------------------------------------------
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  unsigned __int64 v9; // x22
  _QWORD *v12; // x8
  _QWORD *v13; // x25
  __int64 i; // x9
  unsigned __int64 v15; // x9
  __int64 v16; // x10
  long double result; // q0

  v9 = a3;
  v12 = a5;
  if ( a3 >= 0x10 )
  {
    do
    {
      v13 = a2;
      *a2 = *v12 ^ *a1;
      a2[1] = v12[1] ^ a1[1];
      a6(a2, a2, a4);
      v9 -= 16LL;
      a1 += 2;
      a2 += 2;
      v12 = v13;
    }
    while ( v9 > 0xF );
    v12 = a2 - 2;
  }
  if ( v9 )
  {
    for ( i = 0; i != v9; ++i )
      *((_BYTE *)a2 + i) = *((_BYTE *)v12 + i) ^ *((_BYTE *)a1 + i);
    if ( (unsigned __int64)(i - 1) <= 0xE )
    {
      if ( v9 > 8 || (unsigned __int64)((char *)a2 - (char *)v12) < 0x20 )
        goto LABEL_19;
      v15 = 16 - v9;
      *(_QWORD *)((char *)a2 + v9) = *(_QWORD *)((char *)v12 + v9);
      v16 = (16 - v9) & 0x18;
      if ( v16 != 8 )
        *(_QWORD *)((char *)a2 + v9 + 8) = *(_QWORD *)((char *)v12 + v9 + 8);
      v9 += v16;
      if ( v15 != v16 )
      {
LABEL_19:
        do
        {
          *((_BYTE *)a2 + v9) = *((_BYTE *)v12 + v9);
          ++v9;
        }
        while ( v9 != 16 );
      }
    }
    a6(a2, a2, a4);
  }
  else
  {
    a2 = v12;
  }
  result = *(long double *)a2;
  *a5 = *(_OWORD *)a2;
  return result;
}

//----- (000000000001B4C0) ----------------------------------------------------
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  int8x16_t *v9; // x22
  unsigned __int64 v10; // x20
  int8x16_t *v11; // x25
  _QWORD *n128_u64; // x27
  int8x16_t *v13; // x21
  __int64 v14; // x10
  __int64 v15; // x8
  _OWORD *v16; // x8
  __int64 v17; // x10
  unsigned __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x9
  int8x16_t *v21; // x21
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x10
  unsigned __int64 v25; // x13
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x14
  int8x16_t *v30; // x12
  unsigned __int64 v31; // x15
  bool v33; // w10
  bool v35; // w11
  bool v37; // w13
  bool v39; // w12
  int8x16_t *v41; // x10
  int8x16_t *v42; // x11
  int8x16_t *v43; // x12
  int8x16_t *v44; // x13
  unsigned __int64 v45; // x14
  int8x16_t v46; // q1
  int8x16_t v47; // q2
  int8x16_t v48; // q4
  int8x16_t v49; // q5
  int8x16_t v50; // q0
  int8x16_t v51; // q1
  __int128 *v52; // x11
  _OWORD *v53; // x12
  unsigned __int64 v54; // x13
  __int128 v55; // q0
  __int128 v56; // q1
  unsigned __int64 v57; // x13
  unsigned __int64 v58; // x10
  __int64 *v59; // x12
  _QWORD *v60; // x13
  __int64 v61; // t1
  unsigned __int64 v62; // x8
  _BYTE *v63; // x9
  char *v64; // x10
  char v65; // t1
  _QWORD v66[2]; // [xsp+8h] [xbp-18h] BYREF
  __int64 v67; // [xsp+18h] [xbp-8h] BYREF

  v9 = (int8x16_t *)result;
  v10 = a3;
  v67 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (int8x16_t *)result != a2 )
  {
    v11 = a2;
    if ( a3 < 0x10 )
    {
      v16 = (_OWORD *)a5;
    }
    else
    {
      n128_u64 = (_QWORD *)a5;
      do
      {
        v13 = v9;
        result = a6(v9, v11, a4);
        v14 = v11->n128_i64[1];
        v10 -= 16LL;
        ++v9;
        v11->n128_u64[0] ^= *n128_u64;
        v15 = n128_u64[1];
        n128_u64 = v13->n128_u64;
        v11->n128_u64[1] = v14 ^ v15;
        ++v11;
      }
      while ( v10 > 0xF );
      v16 = v9[-1].n128_u64;
    }
    v21 = v9;
    v9 = v11;
    *(_OWORD *)a5 = *v16;
LABEL_11:
    if ( !v10 )
      return result;
    goto LABEL_12;
  }
  if ( a3 >= 0x10 )
  {
    do
    {
      result = a6(v9, (int8x16_t *)v66, a4);
      v17 = v66[1];
      v10 -= 16LL;
      v18 = v9->n128_u64[0];
      v9->n128_u64[0] = *(_QWORD *)a5 ^ v66[0];
      v19 = *(_QWORD *)(a5 + 8);
      *(_QWORD *)a5 = v18;
      v20 = v9->n128_i64[1];
      v9->n128_u64[1] = v19 ^ v17;
      v21 = ++v9;
      *(_QWORD *)(a5 + 8) = v20;
    }
    while ( v10 > 0xF );
    goto LABEL_11;
  }
  v21 = (int8x16_t *)result;
  if ( !a3 )
    return result;
LABEL_12:
  result = a6(v21, (int8x16_t *)v66, a4);
  v22 = 17 - v10;
  if ( v10 < 0x20 )
  {
    v23 = 0;
    goto LABEL_14;
  }
  v29 = (unsigned __int64)v9->n128_u64 + v10;
  v30 = (int8x16_t *)((char *)v66 + v10);
  v31 = a5 + v10;
  v33 = v9 < (int8x16_t *)((char *)v21 + v10) && (unsigned __int64)v21 < v29;
  v35 = v9 < v30 && (unsigned __int64)v66 < v29;
  v23 = 0;
  v37 = (unsigned __int64)v21->n128_u64 + v10 > a5 && (unsigned __int64)v21 < v31;
  v39 = (unsigned __int64)v30 > a5 && (unsigned __int64)v66 < v31;
  if ( v29 > a5 && (unsigned __int64)v9 < v31 )
    goto LABEL_14;
  if ( v33 )
    goto LABEL_14;
  if ( v35 )
    goto LABEL_14;
  if ( v37 )
    goto LABEL_14;
  if ( v39 )
    goto LABEL_14;
  v23 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  v41 = v21 + 1;
  v22 |= v10 & 0xFFFFFFFFFFFFFFE0LL;
  v42 = (int8x16_t *)&v67;
  v43 = v9 + 1;
  v44 = (int8x16_t *)(a5 + 16);
  v45 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v45 -= 32LL;
    v46 = v42[-1];
    v47 = *v42;
    v42 += 2;
    v48 = v41[-1];
    v49 = *v41;
    v41 += 2;
    v50 = veorq_s8(v44[-1], v46);
    v51 = veorq_s8(*v44, v47);
    v44[-1] = v48;
    *v44 = v49;
    v44 += 2;
    v43[-1] = v50;
    *v43 = v51;
    v43 += 2;
  }
  while ( v45 );
  if ( v23 != v10 )
  {
LABEL_14:
    v24 = 0;
    v25 = a5 + v23;
    do
    {
      result = v21->n128_u8[v23 + v24];
      v9->n128_u8[v23 + v24] = *(_BYTE *)(v25 + v24) ^ *((_BYTE *)v66 + v23 + v24);
      *(_BYTE *)(v25 + v24++) = result;
    }
    while ( v23 - v10 + v24 );
    v26 = v22 + v24 - 1;
    if ( v23 + v24 - 1 > 0xE )
      return result;
    goto LABEL_17;
  }
  v26 = v23 - v10 + 16;
  if ( v23 - 1 > 0xE )
    return result;
LABEL_17:
  v27 = 16 - v10;
  if ( 16 - v10 < 8 || a5 - (unsigned __int64)v21 < 0x20 )
    goto LABEL_70;
  if ( v27 < 0x20 )
  {
    v28 = 0;
    goto LABEL_65;
  }
  v28 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  v52 = (__int128 *)((char *)&v21[1] + v10);
  v53 = (_OWORD *)(a5 + v10 + 16);
  v54 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v55 = *(v52 - 1);
    v56 = *v52;
    v54 -= 32LL;
    v52 += 2;
    *(v53 - 1) = v55;
    *v53 = v56;
    v53 += 2;
  }
  while ( v54 );
  if ( v27 != v28 )
  {
    if ( (v27 & 0x18) == 0 )
    {
      v10 += v28;
      goto LABEL_70;
    }
LABEL_65:
    v57 = v10 + v28;
    v10 += v27 & 0xFFFFFFFFFFFFFFF8LL;
    v58 = v28 - (v27 & 0xFFFFFFFFFFFFFFF8LL);
    v59 = (__int64 *)((char *)v21 + v57);
    v60 = (_QWORD *)(a5 + v57);
    do
    {
      v61 = *v59++;
      v58 += 8LL;
      *v60++ = v61;
    }
    while ( v58 );
    if ( v27 == (v27 & 0xFFFFFFFFFFFFFFF8LL) )
      return result;
LABEL_70:
    v62 = v26 - v10;
    v63 = (_BYTE *)(a5 + v10);
    v64 = (char *)v21 + v10;
    do
    {
      v65 = *v64++;
      --v62;
      *v63++ = v65;
    }
    while ( v62 );
  }
  return result;
}

//----- (000000000001B830) ----------------------------------------------------
void sub_1B830()
{
  JUMPOUT(0);
}
// 1B840: control flows out of bounds to 0

//----- (000000000001B890) ----------------------------------------------------
// attributes: thunk
void printLogD()
{
  printLogD();
}

//----- (000000000001B8C0) ----------------------------------------------------
// attributes: thunk
__int64 DRM_Init()
{
  return DRM_Init();
}

//----- (000000000001B8D0) ----------------------------------------------------
// attributes: thunk
void DRM_Destroy()
{
  DRM_Destroy();
}

//----- (000000000001B8E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPath(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        __int16 a5)
{
  return Java_DigiCAP_SKT_DRM_DRMInterface_DRMOpenPath(a1, a2, a3, a4, a5);
}

//----- (000000000001B910) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3)
{
  return DRM_Open_Path(a1, a2, a3);
}

//----- (000000000001B920) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  return DRM_Open_Pfd(a1, a2, a3);
}

//----- (000000000001B930) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Close(unsigned __int16 a1)
{
  return DRM_Close(a1);
}

//----- (000000000001B950) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, int a3)
{
  return DRM_Read(a1, a2, a3);
}

//----- (000000000001B970) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  return DRM_Seek(a1, a2, a3);
}

//----- (000000000001B980) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetOriginalFileSize(unsigned __int16 a1)
{
  return DRM_GetOriginalFileSize(a1);
}

//----- (000000000001B990) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetFileSize(unsigned __int16 a1)
{
  return DRM_GetFileSize(a1);
}

//----- (000000000001B9A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2)
{
  return DRM_GetContentInfo(a1, a2);
}

//----- (000000000001BA20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetUnsupportedValue(__int64 a1, _BYTE *a2, _BYTE *a3, int a4)
{
  return DRM_GetUnsupportedValue(a1, a2, a3, a4);
}

//----- (000000000001BA30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  return DRM_GetDCFMetaDataEncodingType(a1);
}

//----- (000000000001BA50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  return DHstrncpy_s(a1, a2, a3, a4);
}

//----- (000000000001BA60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3)
{
  return DRM_GetClientID(a1, a2, a3);
}

//----- (000000000001BA70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall StrErrorReturn(int a1)
{
  return StrErrorReturn(a1);
}

//----- (000000000001BA80) ----------------------------------------------------
// attributes: thunk
__int64 DRM_SetClientID()
{
  return DRM_SetClientID();
}

//----- (000000000001BA90) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DHstrlen(const char *a1)
{
  return DHstrlen(a1);
}

//----- (000000000001BB00) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return DHmemset(a1, a2, a3);
}

//----- (000000000001BB10) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfree(void *a1)
{
  DHfree(a1);
}

//----- (000000000001BB30) ----------------------------------------------------
// attributes: thunk
void __fastcall DHFreeClientID(void *a1)
{
  DHFreeClientID(a1);
}

//----- (000000000001BB40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3)
{
  return DA_DRA_FilePfdOpen(a1, a2, a3);
}

//----- (000000000001BB50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2)
{
  return DA_DRA_FileClose(a1, a2);
}

//----- (000000000001BB60) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmalloc(int a1)
{
  return DHmalloc(a1);
}

//----- (000000000001BB70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3)
{
  return DA_DRA_DCFParser(a1, a2, a3);
}

//----- (000000000001BB80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  return DHstrnicmp(a1, a2, a3);
}

//----- (000000000001BB90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  return ClusterAuthentication(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BBA0) ----------------------------------------------------
// attributes: thunk
__int64 DHfsTell()
{
  return DHfsTell();
}
// 17170: using guessed type __int64 DHfsTell(void);

//----- (000000000001BBB0) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return DHmemcpy(a1, a2, a3);
}

//----- (000000000001BBC0) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  DA_DRA_DCFDestroy(a1);
}

//----- (000000000001BBD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  return DHGetClientID_BySetVal(a1, a2, a3, a4);
}

//----- (000000000001BBE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3)
{
  return DA_DRA_FileOpen(a1, a2, a3);
}

//----- (000000000001BBF0) ----------------------------------------------------
// attributes: thunk
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  ClientIDDestroy(a1);
}

//----- (000000000001BC00) ----------------------------------------------------
// attributes: thunk
void __fastcall DomainListDestroy(__int64 a1)
{
  DomainListDestroy(a1);
}

//----- (000000000001BC10) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3)
{
  return DHfsRead(stream, ptr, a3);
}

//----- (000000000001BC20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  return DHfsSeek(a1, a2, a3);
}

//----- (000000000001BC30) ----------------------------------------------------
// attributes: thunk
__int64 AES_set_decrypt_key()
{
  return AES_set_decrypt_key();
}
// 1B368: using guessed type __int64 AES_set_decrypt_key(void);

//----- (000000000001BC40) ----------------------------------------------------
// attributes: thunk
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  AES_cbc_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BC50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  return checkDomain(a1, a2, a3);
}

//----- (000000000001BC60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, int *a3, __int64 a4)
{
  return GetClientID(a1, a2, a3, a4);
}

//----- (000000000001BC70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  return compute_eTarget(a1, a2, a3, a4);
}

//----- (000000000001BC80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eServiceCode(
        __int16 a1,
        const char *a2,
        _BYTE *a3,
        const char *a4,
        const char *a5,
        __int64 a6)
{
  return compute_eServiceCode(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BC90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        char *a6,
        __int16 a7,
        __int64 a8)
{
  return compute_eAuthCode(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (000000000001BCA0) ----------------------------------------------------
// attributes: thunk
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  return DHstristr(a1, a2);
}

//----- (000000000001BCB0) ----------------------------------------------------
// attributes: thunk
__int64 DHatoi()
{
  return DHatoi();
}
// 175D4: using guessed type __int64 DHatoi(void);

//----- (000000000001BCC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall get_SSEBaseStream(
        __int16 a1,
        const char *a2,
        unsigned int a3,
        const char *a4,
        __int64 a5,
        __int64 a6)
{
  return get_SSEBaseStream(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BCD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  return DA_DRA_GetDCFHeader(a1, a2);
}

//----- (000000000001BCE0) ----------------------------------------------------
// attributes: thunk
__int64 DHAuthTime()
{
  return DHAuthTime();
}

//----- (000000000001BCF0) ----------------------------------------------------
// attributes: thunk
__int64 DHcurrentTime()
{
  return DHcurrentTime();
}

//----- (000000000001BD00) ----------------------------------------------------
// attributes: thunk
__int64 DHstrcmp()
{
  return DHstrcmp();
}
// 17408: using guessed type __int64 DHstrcmp(void);

//----- (000000000001BD10) ----------------------------------------------------
// attributes: thunk
__int64 DA_DRA_SetClientID()
{
  return DA_DRA_SetClientID();
}
// 1A3B4: using guessed type __int64 DA_DRA_SetClientID(void);

//----- (000000000001BD20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5, __int64 a6)
{
  return compute_SSKey(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BD30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  return DHstrcpy_s(a1, a2, s);
}

//----- (000000000001BD40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  return DHGetDeviceID_ConstVal(a1);
}

//----- (000000000001BD50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  return DHstrncat_s(s, a2, a3, a4);
}

//----- (000000000001BD60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  return DHmktime(a1, a2);
}

//----- (000000000001BD70) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  DA_DRM_HASH_SHA1Digest(a1, a2, a3);
}

//----- (000000000001BD80) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  return inverse(result, a2, a3);
}

//----- (000000000001BD90) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  return DHultoa(a1, a2, a3);
}

//----- (000000000001BDA0) ----------------------------------------------------
// attributes: thunk
__int64 DHstrcat()
{
  return DHstrcat();
}
// 174B4: using guessed type __int64 DHstrcat(void);

//----- (000000000001BDB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9)
{
  return DHsprintf_s(a1, a2, format);
}

//----- (000000000001BDC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return DHstrncmp(a1, a2, a3);
}

//----- (000000000001BDD0) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  return DHstrlwr(result);
}

//----- (000000000001BDE0) ----------------------------------------------------
// attributes: thunk
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return DHstrchr(a1, a2);
}

//----- (000000000001BDF0) ----------------------------------------------------
// attributes: thunk
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  return PP_HexEncode_A(result, a2, a3, a4);
}

//----- (000000000001BE00) ----------------------------------------------------
// attributes: thunk
__int64 DHstrstr()
{
  return DHstrstr();
}
// 1778C: using guessed type __int64 DHstrstr(void);

//----- (000000000001BE10) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  return DHfsMetaOpen(a1, a2);
}

//----- (000000000001BE20) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  return DHfsOpen(filename, a2);
}

//----- (000000000001BE30) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  return DHfsPfdMetaOpen(a1, a2);
}

//----- (000000000001BE40) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  return DHfsPfdOpen(a1, a2);
}

//----- (000000000001BE50) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  DHfsMetaClose(a1);
}

//----- (000000000001BE60) ----------------------------------------------------
// attributes: thunk
__int64 DHfsClose()
{
  return DHfsClose();
}
// 16B24: using guessed type __int64 DHfsClose(void);

//----- (000000000001BE70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  return DHfs_VF_SetFileSize(result, a2);
}

//----- (000000000001BE80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  return DHfs_VF_SetBuffer(result, a2, a3, a4);
}

//----- (000000000001BE90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  return DHmemcpy_s(a1, a2, a3, a4);
}

//----- (000000000001BEA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  return DHfs_VF_IsReachedToEndOfFile(result, a2);
}

//----- (000000000001BEB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  return DHfs_VF_ShouldUpdateBuffer(result, a2, a3);
}

//----- (000000000001BEC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  return DHfsMetaSeek(a1, a2, a3);
}

//----- (000000000001BFC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetStateInfo(void *a1)
{
  return DHGetStateInfo(a1);
}

//----- (000000000001BFD0) ----------------------------------------------------
// attributes: thunk
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  return base64_decode(a1, a2, a3);
}

//----- (000000000001BFF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  return DHSetClientID(a1, a2, a3);
}

//----- (000000000001C010) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  return base64_decode_atom(a1, a2);
}

//----- (000000000001C020) ----------------------------------------------------
// attributes: thunk
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  return CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001C030) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  return CRYPTO_cbc128_decrypt(result, a2, a3, a4, a5, a6);
}

//----- (000000000001C040) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_encrypt_key(a1, a2, a3);
}

//----- (000000000001C050) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_decrypt_key(a1, a2, a3);
}

// nfuncs=358 queued=262 decompiled=262 lumina nreq=0 worse=0 better=0
// ALL OK, 262 function(s) have been successfully decompiled
