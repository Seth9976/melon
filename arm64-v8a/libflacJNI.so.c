/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_11430();
__int64 __fastcall FLAC__bitreader_read_raw_uint64(__int64 a1, unsigned __int64 *a2, unsigned int a3);
__int64 __fastcall FLAC__crc16(unsigned __int8 *a1, unsigned int a2);
void __fastcall std::vector<std::string>::__push_back_slow_path<std::string const&>(size_t **a1, __int64 a2);
void *__fastcall FLAC__subframe_add_lpc(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void *__cxa_get_globals_fast();
__int64 __fastcall FLAC__bitwriter_clear(__int64 result);
__int64 __fastcall FLAC__stream_decoder_get_state(unsigned int **a1);
void __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
__int64 __fastcall FLAC__crc8(char *a1, int a2);
_QWORD *FLAC__stream_decoder_new();
// void *realloc(void *ptr, size_t size);
__int64 operator new[]();
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond(__int64 a1, unsigned int a2);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
char *__fastcall FLAC__metadata_object_seektable_resize_points(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__format_seektable_is_legal(unsigned int *a1);
__int64 __fastcall FLAC__stream_decoder_init_stream(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall FLAC__metadata_object_clone(__int64 *a1);
__int64 __fastcall _JNIEnv::CallIntMethod(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall FLAC__stream_decoder_get_decode_position(__int64 a1, _QWORD *a2);
__int64 __fastcall FLAC__format_vorbiscomment_entry_name_is_legal(_BYTE *a1);
void __fastcall FLAC__metadata_chain_merge_padding(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_process_single(_DWORD **a1);
__int64 __fastcall _JNIEnv::NewObject(__int64 a1, __int64 a2, __int64 a3);
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int __cxa_finalize(void *);
void __cxa_end_catch(void);
_DWORD *__fastcall FLAC__bitwriter_write_raw_uint32_little_endian(_DWORD *result, unsigned int a2);
void *__fastcall FLAC__metadata_object_cuesheet_set_track(__int64 a1, unsigned int a2, __int64 a3, int a4);
// int isalpha(int);
// void *calloc(size_t nmemb, size_t size);
char *__fastcall FLAC__fixed_compute_residual(char *result, unsigned int a2, int a3, int32x4_t *a4);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
void *__fastcall FLAC__memory_alloc_aligned_unsigned_array(unsigned __int64 a1, void **a2, _QWORD *a3);
void *__fastcall FLAC__subframe_add_verbatim(__int64 *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_index(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall FLACParser::getSeekPositions(__int64 a1, __int64 a2, __int64 *a3);
void *__fastcall FLAC__subframe_add_constant(unsigned int *a1, unsigned int a2, int a3, __int64 a4);
void *__fastcall operator new(size_t a1);
int *__fastcall FLAC__fixed_restore_signal(int *result, int a2, int a3, int *a4);
void *__fastcall FLAC__bitwriter_zero_pad_to_byte_boundary(__int64 a1);
// int posix_memalign(void **memptr, size_t alignment, size_t size);
void __fastcall FLAC__bitreader_delete(void **a1);
// int fstat(int fd, struct stat *buf);
// int chmod(const char *file, __mode_t mode);
__int64 __fastcall _JNIEnv::CallBooleanMethod(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FLAC__format_cuesheet_is_legal(__int64 a1, int a2, const char **a3);
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_all(__int64 a1);
void *__fastcall safe_malloc_mul_2op_p(unsigned __int64 a1, unsigned __int64 a2);
// int strncasecmp(const char *s1, const char *s2, size_t n);
__int64 operator delete[]();
void __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(__int64 a1);
__int64 __fastcall FLAC__crc16_update_words32(unsigned int *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall FLACParser::reset(__int64 a1, __int64 a2);
void *__fastcall FLAC__bitwriter_get_buffer(__int64 a1, _QWORD *a2, _QWORD *a3);
// void __noreturn abort(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
__int64 __fastcall FLAC__bitreader_read_rice_signed_block(__int64 a1, unsigned int *a2, int a3, unsigned int a4);
void __noreturn __cxa_call_unexpected(void *);
// int fseeko(FILE *stream, __off_t off, int whence);
__int64 __fastcall FLAC__bitreader_read_byte_block_aligned_no_crc(__int64 a1, _BYTE *a2, unsigned int a3);
// char *strerror(int);
// void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
// __int64 __errno(void); weak
void __fastcall FLACParser::~FLACParser(_QWORD *a1);
__int64 __fastcall FLAC__stream_decoder_set_md5_checking(_QWORD *a1, int a2);
__int64 FLAC__bitwriter_release_buffer();
// int snprintf(char *s, size_t maxlen, const char *format, ...);
void *__fastcall FLAC__subframe_add_fixed(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void *__fastcall FLAC__bitwriter_write_utf8_uint32(__int64 a1, unsigned int a2);
void *__fastcall FLAC__bitwriter_get_write_crc16(__int64 a1, _WORD *a2);
__int64 __fastcall FLACParser::readBuffer(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall FLAC__metadata_object_delete_data(__int64 a1);
// int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data);
// __int64 __fastcall android_set_abort_message(_QWORD); weak
// int isupper(int);
void *__fastcall FLAC__bitwriter_get_write_crc8(__int64 a1, _BYTE *a2);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
// char *strrchr(const char *, int);
void *__fastcall FLAC__metadata_object_cuesheet_track_resize_indices(__int64 a1, unsigned int a2, unsigned int a3);
void __fastcall FLAC__stream_decoder_delete(void **a1);
__int64 __fastcall FLAC__bitreader_read_utf8_uint32(__int64 a1, int *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned int a1);
char *__fastcall FLAC__metadata_object_cuesheet_resize_tracks(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_all(__int64 a1);
// int memcmp(const void *, const void *, size_t);
__int64 __fastcall FLACParser::init(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_next(__int64 a1);
void *__fastcall FLAC__bitwriter_write_raw_uint64(__int64 a1, __int64 a2, unsigned int a3);
// int fclose(FILE *stream);
void __fastcall std::exception::~exception(std::exception *a1);
void __fastcall FLAC__bitwriter_delete(void **a1);
void __fastcall std::type_info::~type_info(std::type_info *a1);
__int64 __fastcall FLACParser::FLACParser(__int64 a1, __int64 a2);
unsigned __int64 std::get_new_handler();
// int fputc(int c, FILE *stream);
__int64 __fastcall FLAC__metadata_simple_iterator_prev(__int64 a1);
__int64 __fastcall FLAC__bitreader_read_raw_int32(__int64 a1, _DWORD *a2, unsigned int a3);
char *__fastcall FLAC__metadata_object_vorbiscomment_resize_comments(__int64 a1, unsigned int a2);
bool __fastcall FLAC__bitwriter_init(__int64 a1);
// int feof(FILE *stream);
// int fileno(FILE *stream);
__int64 **__fastcall FLAC__stream_encoder_finish(__int64 **result);
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_init(__int64 result);
void *__fastcall FLAC__bitwriter_write_utf8_uint64(__int64 a1, unsigned __int64 a2);
// void *memchr(const void *, int, size_t);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
__int64 __fastcall FLAC__format_vorbiscomment_entry_value_is_legal(unsigned __int8 *a1, int a2);
__int64 __fastcall FLACParser::decodeMetadata(__int64 a1);
bool __fastcall FLAC__stream_decoder_finish(__int64 a1);
__int64 __fastcall FLAC__bitreader_read_unary_unsigned(__int64 a1, _DWORD *a2);
__int64 __fastcall FLAC__bitreader_skip_bits_no_crc(__int64 a1, unsigned int a2);
void *FLAC__bitreader_new();
// void openlog(const char *ident, int option, int facility);
__int64 __fastcall FLAC__format_blocksize_is_subset(unsigned int a1, unsigned int a2);
void *__fastcall __cxa_get_globals();
// int __android_log_print(int prio, const char *tag, const char *fmt, ...);
bool __fastcall FLAC__format_sample_rate_is_valid(int a1);
// int unlink(const char *name);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_comment(__int64 a1, unsigned int a2, __int64 a3, unsigned __int8 *a4, int a5);
_DWORD *__fastcall FLAC__bitwriter_write_raw_int32(__int64 a1, unsigned int a2, unsigned int a3);
void __fastcall operator delete(void *p);
__int64 __fastcall FLAC__bitreader_bits_left_for_byte_alignment(__int64 a1);
// int utime(const char *file, const struct utimbuf *file_times);
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
// int strcmp(const char *, const char *);
// __off_t ftello(FILE *stream);
char *__fastcall FLAC__metadata_simple_iterator_init(__int64 a1, const char *a2, int a3, int a4);
__int64 __fastcall FLAC__stream_decoder_init_file(int **a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall FLAC__add_metadata_block(__int64 a1, _DWORD *a2);
__int64 operator delete[]();
void *FLAC__bitwriter_new();
__int64 __fastcall FLAC__bitreader_read_utf8_uint64(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4);
void *__cxa_allocate_exception(size_t thrown_size);
__int64 __fastcall FLAC__stream_decoder_reset(int **a1);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(int a1, unsigned int a2, unsigned int a3);
// void closelog(void);
void *__fastcall FLAC__bitwriter_write_raw_uint32(__int64 a1, unsigned int a2, unsigned int a3);
// void *pthread_getspecific(pthread_key_t key);
void __fastcall operator delete(void *p);
bool __fastcall FLAC__bitreader_is_consumed_byte_aligned(__int64 a1);
// void *memmove(void *, const void *, size_t);
void __noreturn std::terminate(void);
__int64 operator new[]();
__int64 __fastcall FLAC__format_vorbiscomment_entry_is_legal(unsigned __int8 *a1, int a2);
long double __fastcall FLAC__cpu_info(__int64 a1);
char *__fastcall FlacPicture::FlacPicture(char *result, __int64 a2);
__int64 __fastcall FLAC__bitreader_read_raw_uint32(__int64 a1, _DWORD *a2, unsigned int a3);
// int ferror(FILE *stream);
void *__fastcall FLAC__bitwriter_write_unary_unsigned(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__format_picture_is_legal(__int64 a1, _QWORD *a2);
// int isxdigit(int);
void *__cxa_begin_catch(void *);
__int64 __fastcall FLAC__format_sample_rate_is_subset(unsigned int a1);
void *__fastcall FLAC__bitwriter_write_byte_block(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall FLAC__format_seektable_sort(void **a1);
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *result);
// char *strdup(const char *);
void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
void __fastcall FLAC__bitwriter_free(__int64 a1);
__int64 __fastcall FLAC__bitreader_read_uint32_little_endian(__int64 a1, int *a2);
// size_t strlen(const char *);
__int64 __fastcall FLAC__bitreader_skip_byte_block_aligned_no_crc(__int64 a1, unsigned int a2);
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(__int64 a1, unsigned int a2);
// int stat(const char *file, struct stat *buf);
__int64 __fastcall FLAC__stream_decoder_init_ogg_stream(_DWORD **a1);
void __fastcall std::exception::~exception(std::exception *a1); // weak
// int chown(const char *file, __uid_t owner, __gid_t group);
// int rename(const char *old, const char *new);
void __noreturn __cxa_rethrow(void);
void __fastcall FLACParser::metadataCallback(__int64 a1, __int64 a2);
void *__fastcall FLAC__bitreader_init(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall FLAC__bitwriter_write_rice_signed_block(__int64 a1, int *a2, int a3, int a4);
void *__fastcall FLAC__metadata_object_new(unsigned int a1);
__int64 __fastcall FLAC__fixedpoint_log2(unsigned int a1, unsigned int a2, unsigned int a3);
bool __fastcall FLAC__metadata_chain_check_if_tempfile_needed(_QWORD *a1, int a2);
// int fprintf(FILE *stream, const char *format, ...);
void *__fastcall FLAC__memory_alloc_aligned_uint64_array(unsigned __int64 a1, void **a2, _QWORD *a3);
// void *malloc(size_t byte_count);
__int64 __fastcall FLAC__bitreader_get_input_bits_unconsumed(_DWORD *a1);
// void *memcpy(void *, const void *, size_t);
void *__fastcall FLAC__metadata_simple_iterator_get_block(__int64 a1);
void *__fastcall FLAC__frame_add_header(__int64 a1, __int64 a2);
void *__fastcall FLAC__bitwriter_write_zeroes(__int64 a1, unsigned int a2);
bool __fastcall FLAC__stream_decoder_flush(__int64 a1);
// void *memset(void *, int, size_t);
// FILE *fopen(const char *filename, const char *modes);
void __fastcall FLAC__bitreader_free(__int64 a1);
unsigned __int64 std::get_terminate();
char *__fastcall FLAC__stream_decoder_get_resolved_state_string(unsigned int **a1);
void __fastcall std::vector<FlacPicture>::__push_back_slow_path<FlacPicture const&>(char **a1, __int64 a2);
long double __fastcall FLAC__MD5Init(__int64 a1);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// void __android_log_assert(const char *cond, const char *tag, const char *fmt, ...);
unsigned __int64 std::get_unexpected();
signed __int64 __fastcall std::vector<std::string>::vector(signed __int64 *a1, __int64 *a2);
_BYTE *__fastcall FLAC__MD5Accumulate(__int64 a1, int32x4_t **a2, unsigned int a3, unsigned int a4, unsigned int a5);
// void free(void *p);
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_metadata(_DWORD **a1);
__int64 __fastcall FLAC__bitreader_clear(__int64 a1);
__int64 __fastcall FLAC__bitreader_reset_read_crc16(__int64 result, unsigned __int16 a2);
void *__fastcall FLAC__memory_alloc_aligned_int32_array(unsigned __int64 a1, void **a2, _QWORD *a3);
__int64 __fastcall FLAC__bitreader_get_read_crc16(__int64 *a1);
void __fastcall FLAC__metadata_object_delete(void *a1);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
void *__fastcall FLAC__MD5Final(_OWORD *a1, __int64 a2);
__int64 start();
__int64 (*__fastcall sub_1219C(__int64 (*result)(void)))(void);
__int64 __fastcall sub_121B4(void *a1);
_QWORD *Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacInit();
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeMetadata(__int64 a1, __int64 a2, __int64 *a3);
__int64 _JNIEnv::NewObject(__int64 a1, __int64 a2, __int64 a3, ...);
signed __int64 __fastcall std::vector<std::string>::vector(signed __int64 *a1, __int64 *a2);
__int64 _JNIEnv::CallBooleanMethod(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeToBuffer(__int64 a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeToArray(__int64 a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetDecodePosition(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetLastFrameTimestamp(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetLastFrameFirstSampleIndex(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetNextFrameFirstSampleIndex(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetSeekPoints(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetStateString(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacIsDecoderAtEndOfStream(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacFlush(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacReset(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall FLACParser::reset(__int64 a1, __int64 a2);
void __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacRelease(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall JavaDataSource::readAt(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 _JNIEnv::CallIntMethod(__int64 a1, __int64 a2, __int64 a3, ...);
char *__fastcall FlacPicture::FlacPicture(char *result, __int64 a2);
__int64 __fastcall FLACParser::read_callback(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4);
__int64 __fastcall FLACParser::readCallback(_QWORD *a1, __int64 a2, __int64 *a3);
__int64 __fastcall FLACParser::seek_callback(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FLACParser::seekCallback(__int64 a1, __int64 a2);
__int64 __fastcall FLACParser::tell_callback(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall FLACParser::tellCallback(__int64 a1, _QWORD *a2);
__int64 FLACParser::length_callback();
__int64 FLACParser::lengthCallback();
__int64 __fastcall FLACParser::eof_callback(__int64 a1, __int64 a2);
__int64 __fastcall FLACParser::eofCallback(__int64 a1);
__int64 __fastcall FLACParser::write_callback(__int64 a1, __int128 *a2, __int64 a3, __int64 a4);
__int64 __fastcall FLACParser::writeCallback(__int64 a1, __int128 *a2, __int64 a3);
void __fastcall FLACParser::metadata_callback(__int64 a1, __int64 a2, __int64 a3);
void __fastcall FLACParser::metadataCallback(__int64 a1, __int64 a2);
__int64 __fastcall FLACParser::error_callback(__int64 a1, int a2, __int64 a3);
__int64 __fastcall FLACParser::errorCallback(__int64 a1, int a2);
__int64 __fastcall FLACParser::FLACParser(__int64 a1, __int64 a2);
void __noreturn sub_13C5C();
void __fastcall FLACParser::~FLACParser(_QWORD *a1);
__int64 __fastcall FLACParser::init(__int64 a1);
__int64 __fastcall FLACParser::decodeMetadata(__int64 a1);
char *__fastcall sub_13F9C(char *result, __int64 *a2, unsigned int a3, unsigned int a4, unsigned int a5);
__int64 __fastcall FLACParser::readBuffer(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall FLACParser::getSeekPositions(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall std::vector<std::string>::__push_back_slow_path<std::string const&>(size_t **a1, __int64 a2);
void __fastcall std::vector<FlacPicture>::__push_back_slow_path<FlacPicture const&>(char **a1, __int64 a2);
__int64 __fastcall FLAC__bitmath_silog2(__int64 result);
void *FLAC__bitreader_new();
void __fastcall FLAC__bitreader_delete(void **a1);
void __fastcall FLAC__bitreader_free(__int64 a1);
void *__fastcall FLAC__bitreader_init(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FLAC__bitreader_clear(__int64 a1);
size_t __fastcall FLAC__bitreader_dump(__int64 a1, FILE *a2);
__int64 __fastcall FLAC__bitreader_reset_read_crc16(__int64 result, unsigned __int16 a2);
__int64 __fastcall FLAC__bitreader_get_read_crc16(__int64 *a1);
bool __fastcall FLAC__bitreader_is_consumed_byte_aligned(__int64 a1);
__int64 __fastcall FLAC__bitreader_bits_left_for_byte_alignment(__int64 a1);
__int64 __fastcall FLAC__bitreader_get_input_bits_unconsumed(_DWORD *a1);
__int64 __fastcall FLAC__bitreader_read_raw_uint32(__int64 a1, _DWORD *a2, unsigned int a3);
__int64 __fastcall sub_14D1C(char **a1);
__int64 __fastcall FLAC__bitreader_read_raw_int32(__int64 a1, _DWORD *a2, unsigned int a3);
__int64 __fastcall FLAC__bitreader_read_raw_uint64(__int64 a1, unsigned __int64 *a2, unsigned int a3);
__int64 __fastcall FLAC__bitreader_read_uint32_little_endian(__int64 a1, int *a2);
__int64 __fastcall FLAC__bitreader_skip_bits_no_crc(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__bitreader_skip_byte_block_aligned_no_crc(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__bitreader_read_byte_block_aligned_no_crc(__int64 a1, _BYTE *a2, unsigned int a3);
__int64 __fastcall FLAC__bitreader_read_unary_unsigned(__int64 a1, _DWORD *a2);
__int64 __fastcall FLAC__bitreader_read_rice_signed(__int64 a1, unsigned int *a2, unsigned int a3);
__int64 __fastcall FLAC__bitreader_read_rice_signed_block(__int64 a1, unsigned int *a2, int a3, unsigned int a4);
__int64 __fastcall FLAC__bitreader_read_utf8_uint32(__int64 a1, int *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall FLAC__bitreader_read_utf8_uint64(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4);
void *FLAC__bitwriter_new();
void __fastcall FLAC__bitwriter_delete(void **a1);
void __fastcall FLAC__bitwriter_free(__int64 a1);
bool __fastcall FLAC__bitwriter_init(__int64 a1);
__int64 __fastcall FLAC__bitwriter_clear(__int64 result);
size_t __fastcall FLAC__bitwriter_dump(__int64 a1, FILE *a2);
void *__fastcall FLAC__bitwriter_get_write_crc16(__int64 a1, _WORD *a2);
void *__fastcall FLAC__bitwriter_get_buffer(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 FLAC__bitwriter_release_buffer(void); // weak
void *__fastcall FLAC__bitwriter_get_write_crc8(__int64 a1, _BYTE *a2);
bool __fastcall FLAC__bitwriter_is_byte_aligned(__int64 a1);
__int64 __fastcall FLAC__bitwriter_get_input_bits_unconsumed(__int64 a1);
void *__fastcall FLAC__bitwriter_write_zeroes(__int64 a1, unsigned int a2);
void *__fastcall FLAC__bitwriter_write_raw_uint32(__int64 a1, unsigned int a2, unsigned int a3);
_DWORD *__fastcall FLAC__bitwriter_write_raw_int32(__int64 a1, unsigned int a2, unsigned int a3);
void *__fastcall FLAC__bitwriter_write_raw_uint64(__int64 a1, __int64 a2, unsigned int a3);
_DWORD *__fastcall FLAC__bitwriter_write_raw_uint32_little_endian(_DWORD *result, unsigned int a2);
void *__fastcall FLAC__bitwriter_write_byte_block(__int64 a1, __int64 a2, unsigned int a3);
void *__fastcall FLAC__bitwriter_write_unary_unsigned(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__bitwriter_rice_bits(int a1, int a2);
void *__fastcall FLAC__bitwriter_write_rice_signed(__int64 a1, int a2, int a3);
void *__fastcall FLAC__bitwriter_write_rice_signed_block(__int64 a1, int *a2, int a3, int a4);
void *__fastcall FLAC__bitwriter_write_utf8_uint32(__int64 a1, unsigned int a2);
void *__fastcall FLAC__bitwriter_write_utf8_uint64(__int64 a1, unsigned __int64 a2);
void *__fastcall FLAC__bitwriter_zero_pad_to_byte_boundary(__int64 a1);
long double __fastcall FLAC__cpu_info(__int64 a1);
__int64 __fastcall FLAC__crc8(char *a1, int a2);
__int64 __fastcall FLAC__crc16(unsigned __int8 *a1, unsigned int a2);
__int64 __fastcall FLAC__crc16_update_words32(unsigned int *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall FLAC__crc16_update_words64(unsigned __int64 *a1, int a2, unsigned int a3);
__int64 __fastcall FLAC__fixed_compute_best_predictor(int8x16_t *a1, unsigned int a2, unsigned int *a3);
__int64 __fastcall FLAC__fixed_compute_best_predictor_wide(__int64 a1, unsigned int a2, unsigned int *a3);
char *__fastcall FLAC__fixed_compute_residual(char *result, unsigned int a2, int a3, int32x4_t *a4);
int *__fastcall FLAC__fixed_restore_signal(int *result, int a2, int a3, int *a4);
__int64 __fastcall FLAC__fixedpoint_log2(unsigned int a1, unsigned int a2, unsigned int a3);
bool __fastcall FLAC__format_sample_rate_is_valid(int a1);
__int64 __fastcall FLAC__format_blocksize_is_subset(unsigned int a1, unsigned int a2);
__int64 __fastcall FLAC__format_sample_rate_is_subset(unsigned int a1);
__int64 __fastcall FLAC__format_seektable_is_legal(unsigned int *a1);
__int64 __fastcall FLAC__format_seektable_sort(void **a1);
__int64 __fastcall sub_1BA38(_QWORD *a1, _QWORD *a2);
__int64 __fastcall FLAC__format_vorbiscomment_entry_name_is_legal(_BYTE *a1);
__int64 __fastcall FLAC__format_vorbiscomment_entry_value_is_legal(unsigned __int8 *a1, int a2);
__int64 __fastcall sub_1BB3C(unsigned __int8 *a1);
__int64 __fastcall FLAC__format_vorbiscomment_entry_is_legal(unsigned __int8 *a1, int a2);
__int64 __fastcall FLAC__format_cuesheet_is_legal(__int64 a1, int a2, const char **a3);
__int64 __fastcall FLAC__format_picture_is_legal(__int64 a1, _QWORD *a2);
__int64 __fastcall FLAC__format_get_max_rice_partition_order(unsigned int a1, unsigned int a2);
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(int a1, unsigned int a2, unsigned int a3);
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned int a1);
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_init(__int64 result);
void __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(__int64 a1);
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(__int64 a1, unsigned int a2);
int *__fastcall FLAC__lpc_restore_signal(int *result, __int64 a2, int *a3, unsigned int a4, char a5, _DWORD *a6);
int *__fastcall FLAC__lpc_restore_signal_wide(int *result, __int64 a2, int *a3, unsigned int a4, char a5, _DWORD *a6);
long double __fastcall FLAC__MD5Init(__int64 a1);
void *__fastcall FLAC__MD5Final(_OWORD *a1, __int64 a2);
_DWORD *__fastcall sub_1D620(_DWORD *result, int *a2);
_BYTE *__fastcall FLAC__MD5Accumulate(__int64 a1, int32x4_t **a2, unsigned int a3, unsigned int a4, unsigned int a5);
void *__fastcall FLAC__memory_alloc_aligned(size_t a1, _QWORD *a2);
void *__fastcall FLAC__memory_alloc_aligned_int32_array(unsigned __int64 a1, void **a2, _QWORD *a3);
void *__fastcall FLAC__memory_alloc_aligned_uint32_array(unsigned __int64 a1, void **a2, _QWORD *a3);
void *__fastcall FLAC__memory_alloc_aligned_uint64_array(unsigned __int64 a1, void **a2, _QWORD *a3);
void *__fastcall FLAC__memory_alloc_aligned_unsigned_array(unsigned __int64 a1, void **a2, _QWORD *a3);
void *__fastcall safe_malloc_mul_2op_p(unsigned __int64 a1, unsigned __int64 a2);
int **__fastcall FLAC__metadata_get_streaminfo(const char *a1, void *a2);
int **__fastcall sub_1EE68(const char *a1, unsigned int a2);
bool __fastcall FLAC__metadata_get_tags(const char *a1, int ***a2);
bool __fastcall FLAC__metadata_get_cuesheet(const char *a1, int ***a2);
_QWORD *__fastcall FLAC__metadata_get_picture(const char *a1, void **a2, int a3, const char *a4, const char *a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9);
_QWORD *FLAC__metadata_simple_iterator_new();
char *__fastcall FLAC__metadata_simple_iterator_init(__int64 a1, const char *a2, int a3, int a4);
void __fastcall FLAC__metadata_simple_iterator_delete(void *a1);
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_type(__int64 a1);
void *__fastcall FLAC__metadata_simple_iterator_get_block(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_next(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_status(__int64 a1);
FILE *__fastcall sub_1F628(__int64 a1, int a2);
__int64 __fastcall FLAC__metadata_simple_iterator_is_writable(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_prev(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_is_last(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_offset(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_length(__int64 a1);
__int64 __fastcall FLAC__metadata_simple_iterator_get_application_id(__int64 a1, void *a2);
__int64 __fastcall FLAC__metadata_simple_iterator_set_block(_DWORD *a1, _DWORD *a2, int a3);
__int64 __fastcall sub_1FD90(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1FF2C(__int64 a1, _DWORD *a2, unsigned int a3, int a4);
__int64 __fastcall sub_201A0(__int64 a1, _DWORD *a2, int a3);
__int64 __fastcall FLAC__metadata_simple_iterator_insert_block_after(__int64 a1, _DWORD *a2, int a3);
int *__fastcall FLAC__metadata_simple_iterator_delete_block(_DWORD *a1, int a2);
_QWORD *FLAC__metadata_chain_new();
void __fastcall FLAC__metadata_chain_delete(__int64 a1);
__int64 __fastcall FLAC__metadata_chain_status(__int64 a1);
__int64 __fastcall FLAC__metadata_chain_read(__int64 a1, const char *a2);
__int64 __fastcall FLAC__metadata_chain_read_ogg(__int64 a1, const char *a2);
void **__fastcall FLAC__metadata_chain_read_with_callbacks(__int64 a1, __int64 a2, _OWORD *a3);
void **__fastcall sub_20F8C(__int64 a1, __int64 a2, __int64 a3, int a4);
void **__fastcall FLAC__metadata_chain_read_ogg_with_callbacks(__int64 a1, __int64 a2, _OWORD *a3);
bool __fastcall FLAC__metadata_chain_check_if_tempfile_needed(_QWORD *a1, int a2);
__int64 __fastcall FLAC__metadata_chain_write(__int64 a1, int a2, int a3);
__int64 __fastcall sub_21864(__int64 a1, int a2);
__int64 __fastcall sub_21B50(const char *a1, __int64 a2);
__int64 __fastcall FLAC__metadata_chain_write_with_callbacks(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall FLAC__metadata_chain_write_with_callbacks_and_tempfile(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall FLAC__metadata_chain_merge_padding(__int64 a1);
void __fastcall FLAC__metadata_chain_sort_padding(__int64 a1);
void *FLAC__metadata_iterator_new();
_QWORD *__fastcall FLAC__metadata_iterator_init(_QWORD *result, __int64 a2);
__int64 __fastcall FLAC__metadata_iterator_next(__int64 a1);
__int64 __fastcall FLAC__metadata_iterator_prev(__int64 a1);
__int64 __fastcall FLAC__metadata_iterator_get_block_type(__int64 a1);
__int64 __fastcall FLAC__metadata_iterator_get_block(__int64 a1);
__int64 __fastcall FLAC__metadata_iterator_set_block(_QWORD *a1, unsigned int *a2);
__int64 __fastcall FLAC__metadata_iterator_delete_block(_QWORD *a1, int a2);
__int64 __fastcall FLAC__metadata_iterator_insert_block_after(_QWORD *a1, unsigned int *a2);
_QWORD *__fastcall FLAC__metadata_iterator_insert_block_before(_QWORD *a1, _DWORD *a2);
__int64 sub_226F8();
void __fastcall sub_22700(__int64 a1, __int64 *a2, __int64 a3);
void __fastcall sub_22750(__int64 a1, int a2, _DWORD *a3);
int j__fseeko(FILE *stream, __off_t off, int whence);
void **__fastcall sub_22764(__int64 a1, __int64 a2, __int64 a3);
void **__fastcall sub_2287C(__int64 a1, __int64 a2, __int64 (*a3)(void), __int64 (__fastcall *a4)(__int64, __int64, __int64), __int64 (__fastcall *a5)(__int64));
__off_t j__ftello(FILE *stream);
__int64 __fastcall sub_22C00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 sub_22C70();
void __fastcall sub_22C78(__int64 a1, __int64 *a2, __int64 a3);
void __fastcall sub_22D28(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_22D34(__int64 a1, __int64 (*a2)(void), unsigned int (__fastcall *a3)(__int64, _QWORD, __int64), __int64 a4);
__int64 __fastcall sub_23C54(__int64 a1, __int64 (__fastcall *a2)(_BYTE *, __int64, __int64, __int64), __int64 a3, unsigned int a4);
__int64 __fastcall sub_23DF4(const char *a1, const char *a2, FILE **a3, const char **a4, int *a5);
__int64 sub_23F0C(char *a1, size_t a2, const char *a3, ...);
__int64 __fastcall sub_23FA4(__int64 a1, __int64 (__fastcall *a2)(char *, __int64, __int64, __int64), __int64 a3);
void *__fastcall FLAC__metadata_object_new(unsigned int a1);
__int64 __fastcall FLAC__metadata_object_clone(__int64 *a1);
void __fastcall FLAC__metadata_object_delete(void *a1);
void __fastcall FLAC__metadata_object_delete_data(__int64 a1);
__int64 __fastcall FLAC__metadata_object_is_equal(int *a1, __int64 a2);
void *__fastcall FLAC__metadata_object_application_set_data(__int64 a1, const void *a2, unsigned int a3, int a4);
char *__fastcall FLAC__metadata_object_seektable_resize_points(__int64 a1, unsigned int a2);
long double __fastcall FLAC__metadata_object_seektable_set_point(__int64 a1, unsigned int a2, __int64 a3);
char *__fastcall FLAC__metadata_object_seektable_insert_point(__int64 a1, int a2, __int128 *a3);
char *__fastcall FLAC__metadata_object_seektable_delete_point(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__metadata_object_seektable_is_legal(__int64 a1);
char *__fastcall FLAC__metadata_object_seektable_template_append_placeholders(__int64 a1, int a2);
char *__fastcall FLAC__metadata_object_seektable_template_append_point(__int64 a1, __int64 a2);
char *__fastcall FLAC__metadata_object_seektable_template_append_points(__int64 a1, __int64 *a2, unsigned int a3);
char *__fastcall FLAC__metadata_object_seektable_template_append_spaced_points(__int64 a1, unsigned int a2, __int64 a3);
char *__fastcall FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(__int64 a1, unsigned int a2, unsigned __int64 a3);
bool __fastcall FLAC__metadata_object_seektable_template_sort(__int64 a1, int a2);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_vendor_string(__int64 a1, __int64 a2, unsigned __int8 *a3, int a4);
char *__fastcall FLAC__metadata_object_vorbiscomment_resize_comments(__int64 a1, unsigned int a2);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_comment(__int64 a1, unsigned int a2, __int64 a3, unsigned __int8 *a4, int a5);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_insert_comment(__int64 a1, unsigned int a2, __int64 a3, unsigned __int8 *a4, int a5);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_append_comment(__int64 a1, __int64 a2, unsigned __int8 *a3, int a4);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_replace_comment(__int64 a1, __int64 a2, unsigned __int8 *a3, int a4, int a5);
char *__fastcall FLAC__metadata_object_vorbiscomment_delete_comment(__int64 a1, unsigned int a2);
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(__int64 a1, char *a2, unsigned __int8 *a3);
__int64 __fastcall FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(unsigned int a1, unsigned __int8 *a2, __int64 *a3, void **a4);
void *__fastcall FLAC__metadata_object_vorbiscomment_entry_matches(unsigned int a1, const void *a2, const char *a3, unsigned int a4);
__int64 __fastcall FLAC__metadata_object_vorbiscomment_find_entry_from(__int64 a1, unsigned int a2, const char *a3);
__int64 __fastcall FLAC__metadata_object_vorbiscomment_remove_entry_matching(__int64 a1, const char *a2);
__int64 __fastcall FLAC__metadata_object_vorbiscomment_remove_entries_matching(__int64 a1, const char *a2);
void *FLAC__metadata_object_cuesheet_track_new();
_QWORD *__fastcall FLAC__metadata_object_cuesheet_track_clone(__int64 a1);
void __fastcall FLAC__metadata_object_cuesheet_track_delete(_QWORD *a1);
void __fastcall FLAC__metadata_object_cuesheet_track_delete_data(__int64 a1);
void *__fastcall FLAC__metadata_object_cuesheet_track_resize_indices(__int64 a1, unsigned int a2, unsigned int a3);
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_index(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5);
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_blank_index(__int64 a1, unsigned int a2, unsigned int a3);
__int64 __fastcall FLAC__metadata_object_cuesheet_track_delete_index(__int64 a1, unsigned int a2, unsigned int a3);
char *__fastcall FLAC__metadata_object_cuesheet_resize_tracks(__int64 a1, unsigned int a2);
void *__fastcall FLAC__metadata_object_cuesheet_set_track(__int64 a1, unsigned int a2, __int64 a3, int a4);
char *__fastcall FLAC__metadata_object_cuesheet_insert_track(__int64 a1, unsigned int a2, __int64 a3, int a4);
char *__fastcall FLAC__metadata_object_cuesheet_insert_blank_track(__int64 a1, unsigned int a2);
char *__fastcall FLAC__metadata_object_cuesheet_delete_track(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__metadata_object_cuesheet_is_legal(__int64 a1, int a2, const char **a3);
__int64 __fastcall FLAC__metadata_object_cuesheet_calculate_cddb_id(__int64 a1);
char *__fastcall FLAC__metadata_object_picture_set_mime_type(__int64 a1, const char *a2, int a3);
char *__fastcall FLAC__metadata_object_picture_set_description(__int64 a1, const char *a2, int a3);
void *__fastcall FLAC__metadata_object_picture_set_data(__int64 a1, const void *a2, unsigned int a3, int a4);
__int64 __fastcall FLAC__metadata_object_picture_is_legal(__int64 a1, _QWORD *a2);
_QWORD *FLAC__stream_decoder_new();
void __fastcall FLAC__stream_decoder_delete(void **a1);
bool __fastcall FLAC__stream_decoder_finish(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_init_stream(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall sub_28AA0(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11);
__int64 __fastcall FLAC__stream_decoder_init_ogg_stream(_DWORD **a1);
__int64 __fastcall FLAC__stream_decoder_init_FILE(int **a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall FLAC__stream_decoder_init_ogg_FILE(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall FLAC__stream_decoder_init_file(int **a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall FLAC__stream_decoder_init_ogg_file(_QWORD *a1, const char *a2, __int64 a3, __int64 a4, __int64 a5);
__int64 FLAC__stream_decoder_set_ogg_serial_number();
__int64 __fastcall FLAC__stream_decoder_set_md5_checking(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_application(__int64 a1, const void *a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_all(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore(__int64 a1, unsigned int a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_application(__int64 a1, const void *a2);
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_all(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_state(unsigned int **a1);
char *__fastcall FLAC__stream_decoder_get_resolved_state_string(unsigned int **a1);
__int64 __fastcall FLAC__stream_decoder_get_md5_checking(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_total_samples(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_channels(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_channel_assignment(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_bits_per_sample(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_sample_rate(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_get_blocksize(__int64 a1);
bool __fastcall FLAC__stream_decoder_get_decode_position(__int64 a1, _QWORD *a2);
__int64 __fastcall FLAC__stream_decoder_get_input_bytes_unconsumed(__int64 a1);
bool __fastcall FLAC__stream_decoder_flush(__int64 a1);
__int64 __fastcall FLAC__stream_decoder_reset(int **a1);
__int64 __fastcall FLAC__stream_decoder_process_single(_DWORD **a1);
__int64 __fastcall sub_29870(__int64 a1);
__int64 __fastcall sub_29B48(__int64 a1);
__int64 __fastcall sub_2AB54(__int64 a1);
_QWORD *__fastcall sub_2ACF8(__int64 a1, _DWORD *a2, int a3);
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_metadata(_DWORD **a1);
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_stream(_DWORD **a1);
_QWORD *__fastcall FLAC__stream_decoder_skip_single_frame(_DWORD **a1);
__int64 __fastcall FLAC__stream_decoder_seek_absolute(__int64 a1, unsigned __int64 a2);
__int64 __fastcall get_client_data_from_decoder(__int64 a1);
__int64 __fastcall sub_2CD20(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_2CE3C(__int64 a1, void *a2, size_t *a3);
__int64 __fastcall sub_2CECC(__int64 a1, __off_t a2);
__int64 __fastcall sub_2CF08(__int64 a1, __off_t *a2);
__int64 __fastcall sub_2CF70(__int64 a1, _QWORD *a2);
bool __fastcall sub_2D010(__int64 a1);
__int64 __fastcall sub_2D034(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4, __int64 a5, int a6);
_QWORD *FLAC__stream_encoder_new();
void __fastcall FLAC__stream_encoder_delete(__int64 a1);
__int64 **__fastcall FLAC__stream_encoder_finish(__int64 **result);
__int64 __fastcall FLAC__stream_encoder_init_stream(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_2E074(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8);
__int64 __fastcall FLAC__stream_encoder_init_ogg_stream(_DWORD **a1);
__int64 __fastcall FLAC__stream_encoder_init_FILE(__int64 a1, char *a2, __int64 a3, __int64 a4);
__int64 __fastcall FLAC__stream_encoder_init_ogg_FILE(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FLAC__stream_encoder_init_file(__int64 a1, const char *a2, __int64 a3, __int64 a4);
__int64 __fastcall FLAC__stream_encoder_init_ogg_file(__int64 a1, const char *a2, __int64 a3);
void *__fastcall sub_2F0C0(_QWORD *a1, int a2);
__int64 FLAC__stream_encoder_set_ogg_serial_number();
__int64 __fastcall FLAC__stream_encoder_set_verify(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_streamable_subset(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_do_md5(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_channels(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_bits_per_sample(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_sample_rate(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_compression_level(_QWORD *a1, unsigned int a2);
__int64 __fastcall FLAC__stream_encoder_set_do_mid_side_stereo(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_loose_mid_side_stereo(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_max_lpc_order(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_qlp_coeff_precision(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_do_qlp_coeff_prec_search(_QWORD *a1, int a2);
bool __fastcall FLAC__stream_encoder_set_do_escape_coding(_DWORD **a1);
__int64 __fastcall FLAC__stream_encoder_set_do_exhaustive_model_search(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_min_residual_partition_order(_QWORD *a1, int a2);
__int64 __fastcall FLAC__stream_encoder_set_max_residual_partition_order(_QWORD *a1, int a2);
bool __fastcall FLAC__stream_encoder_set_rice_parameter_search_dist(_DWORD **a1);
__int64 __fastcall FLAC__stream_encoder_set_blocksize(_QWORD *a1, int a2);
bool __fastcall FLAC__stream_encoder_set_apodization(_DWORD **a1);
__int64 __fastcall FLAC__stream_encoder_set_total_samples_estimate(_QWORD *a1, unsigned __int64 a2);
void *__fastcall FLAC__stream_encoder_set_metadata(__int64 *a1, const void *a2, unsigned int a3);
__int64 __fastcall FLAC__stream_encoder_disable_constant_subframes(__int64 a1, int a2);
__int64 __fastcall FLAC__stream_encoder_disable_fixed_subframes(__int64 a1, int a2);
__int64 __fastcall FLAC__stream_encoder_disable_verbatim_subframes(__int64 a1, int a2);
__int64 __fastcall FLAC__stream_encoder_get_state(unsigned int **a1);
__int64 __fastcall FLAC__stream_encoder_get_verify_decoder_state(_QWORD *a1);
char *__fastcall FLAC__stream_encoder_get_resolved_state_string(unsigned int **a1);
__int64 __fastcall FLAC__stream_encoder_get_verify_decoder_error_stats(__int64 result, _QWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
__int64 __fastcall FLAC__stream_encoder_get_verify(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_streamable_subset(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_do_md5(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_channels(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_bits_per_sample(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_sample_rate(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_blocksize(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_do_mid_side_stereo(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_loose_mid_side_stereo(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_max_lpc_order(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_qlp_coeff_precision(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_do_qlp_coeff_prec_search(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_do_escape_coding(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_do_exhaustive_model_search(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_min_residual_partition_order(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_max_residual_partition_order(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_rice_parameter_search_dist(__int64 a1);
__int64 __fastcall FLAC__stream_encoder_get_total_samples_estimate(__int64 a1);
void *__fastcall FLAC__stream_encoder_process(_QWORD *a1, __int64 *a2, unsigned int a3);
void *__fastcall FLAC__stream_encoder_process_interleaved(_QWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_304C4(__int64 result, __int64 a2, int a3, int a4, int a5, int a6, int a7);
__int64 __fastcall sub_306FC(__int64 a1, _DWORD *a2, size_t *a3, __int64 a4);
__int64 __fastcall sub_307B8(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4);
__int64 __fastcall nullsub_4(); // weak
void __fastcall sub_30948(__int64 a1, __int64 a2, _DWORD **a3);
void *__fastcall sub_30958(int **a1, unsigned int a2);
__int64 __fastcall sub_30C44(__int64 a1, const void *a2, size_t a3, unsigned int a4);
__int64 __fastcall sub_30CD8(__int64 a1, __off_t a2);
__int64 __fastcall sub_30CFC(__int64 a1, __off_t *a2);
_QWORD *__fastcall sub_30D44(_QWORD *result, unsigned int a2, int a3, unsigned int *a4, int a5, _DWORD *a6, __int64 *a7, __int64 a8, __int64 a9, _BOOL4 *a10, unsigned int *a11);
void *__fastcall sub_3197C(_DWORD **a1, unsigned int a2, unsigned int a3, _DWORD *a4, __int64 a5);
void *__fastcall FLAC__add_metadata_block(__int64 a1, _DWORD *a2);
void *__fastcall FLAC__frame_add_header(__int64 a1, __int64 a2);
void *__fastcall FLAC__subframe_add_constant(unsigned int *a1, unsigned int a2, int a3, __int64 a4);
void *__fastcall FLAC__subframe_add_fixed(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void *__fastcall sub_32958(__int64 a1, int *a2, unsigned int a3, int a4, unsigned int *a5, unsigned int *a6, int a7, int a8);
void *__fastcall FLAC__subframe_add_lpc(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void *__fastcall FLAC__subframe_add_verbatim(__int64 *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
void __fastcall sub_32E4C(std::type_info *a1);
void __fastcall sub_32E70(std::type_info *a1);
void __fastcall sub_32E94(std::type_info *a1);
void __fastcall sub_32EB8(std::type_info *a1);
void __fastcall sub_32EDC(std::type_info *a1);
void __fastcall sub_32F00(std::type_info *a1);
void __fastcall sub_32F24(std::type_info *a1);
void __fastcall sub_32F48(std::type_info *a1);
void __fastcall sub_32F6C(std::type_info *a1);
void __fastcall sub_32F90(std::type_info *a1);
bool __fastcall sub_32FB4(__int64 a1, __int64 a2);
__int64 sub_32FC0();
__int64 sub_32FC8();
bool __fastcall sub_32FD0(__int64 a1, __int64 a2);
void *__fastcall sub_32FDC(const void *a1, const void *a2, _QWORD *a3);
void __fastcall sub_330B8(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_33114(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_3317C(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_331F4(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_33234(__int64 result, __int64 a2, char *a3, __int64 a4);
_BYTE *__fastcall sub_33380(const char **a1, const char **a2);
void (__fastcall **__fastcall sub_33400(__int64 a1, __int64 a2, _QWORD **a3))(std::type_info *__hidden this);
_DWORD *__fastcall sub_336F8(void *a1, const void *a2);
_QWORD *__fastcall sub_3382C(__int64 a1, const void *a2);
_DWORD *__fastcall sub_338A8(__int64 a1, const char **a2, _QWORD *a3);
void *_dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
void __fastcall sub_33B20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
void __fastcall sub_33BC0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_33BE0(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5);
__int64 __fastcall sub_33F4C(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, char a6);
__int64 __fastcall sub_33F84(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, char a5);
__int64 __fastcall sub_33FBC(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5);
__int64 __fastcall sub_3413C(__int64 result, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_34234(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6);
__int64 __fastcall sub_34430(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6);
__int64 __fastcall sub_34550(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6);
void *__fastcall operator new(size_t a1);
void *__fastcall operator new(size_t a1);
void __fastcall __noreturn sub_346C0(void *a1);
__int64 operator new[](void); // weak
__int64 operator new[]();
void __fastcall operator delete(void *p);
__int64 operator delete[](void); // weak
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
__int64 operator new[](void); // weak
__int64 operator new[]();
void __fastcall operator delete(void *p);
void __fastcall operator delete(void *p);
__int64 operator delete[](void); // weak
__int64 operator delete[]();
void std::type_info::~type_info(std::type_info *__hidden this); // weak
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *result);
void __fastcall std::bad_cast::~bad_cast(std::exception *a1);
const char *std::bad_cast::what();
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *result);
void __fastcall std::bad_typeid::~bad_typeid(std::exception *a1);
const char *std::bad_typeid::what();
void *_cxa_allocate_exception(size_t thrown_size);
void _cxa_free_exception(void *);
void *_cxa_allocate_dependent_exception();
void __noreturn _cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
void __fastcall __noreturn sub_34A54(__int64 a1);
void *_cxa_get_exception_ptr(void *);
void *_cxa_begin_catch(void *);
void _cxa_end_catch(void);
void __fastcall _cxa_decrement_exception_refcount(__int64 a1);
struct type_info *_cxa_current_exception_type(void);
void __noreturn _cxa_rethrow(void);
__int64 __fastcall _cxa_increment_exception_refcount(__int64 result);
unsigned __int64 **_cxa_current_primary_exception();
_DWORD *__fastcall _cxa_rethrow_primary_exception(_DWORD *result);
void __fastcall sub_34F3C(int a1, __int64 a2);
_DWORD *_cxa_uncaught_exception();
unsigned int *_cxa_uncaught_exceptions();
void *_cxa_get_globals();
void *_cxa_get_globals_fast();
__int64 sub_350BC();
__int64 __fastcall sub_350F0(void *a1);
unsigned __int64 std::get_unexpected();
void __fastcall __noreturn sub_3513C(void (*a1)(void));
void __noreturn std::unexpected();
unsigned __int64 std::get_terminate();
void __fastcall __noreturn sub_3518C(void (*a1)(void));
void __noreturn std::terminate();
unsigned __int64 __fastcall std::set_new_handler(unsigned __int64 a1);
unsigned __int64 std::get_new_handler();
__int64 __fastcall _gxx_personality_v0(int a1, char a2, __int64 a3, unsigned __int16 *a4, _QWORD *a5);
__int64 __fastcall sub_35434(__int64 result, char a2, char a3, unsigned __int16 *a4, __int64 a5);
void __fastcall __noreturn sub_359E4(char a1, void *a2);
void __noreturn _cxa_call_unexpected(void *);
unsigned __int64 __fastcall sub_35D90(unsigned __int16 **a1, unsigned int a2);
void __noreturn _cxa_pure_virtual(void);
void __noreturn _cxa_deleted_virtual(void);
void *__fastcall sub_35F0C(size_t a1);
unsigned __int16 *__fastcall sub_35F78(__int64 a1);
void *__fastcall sub_3606C(size_t a1, size_t a2);
void __fastcall _cxa_free_dependent_exception_0(int *a1);
void __fastcall sub_361E0(void *p);
void std::exception::~exception(std::exception *__hidden this); // weak
const char *std::exception::what();
const char *std::bad_exception::what();
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *result);
const char *std::bad_alloc::what();
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *result);
const char *std::bad_array_new_length::what();
_QWORD *__fastcall std::bad_array_length::bad_array_length(_QWORD *result);
const char *std::bad_array_length::what();
void __noreturn sub_36294(const char *a1, ...);
unsigned __int64 __fastcall std::set_unexpected(void (__noreturn *a1)());
unsigned __int64 __fastcall std::set_terminate(void (__noreturn *a1)());
void __noreturn sub_363E0();
void __noreturn sub_36508();
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
void __fastcall sub_36AA4(unsigned __int8 *a1, unsigned __int8 *a2, _QWORD *a3, _DWORD *a4);
unsigned __int8 *__fastcall sub_36F74(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_38008(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_401BC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4);
unsigned __int8 *__fastcall sub_42838(unsigned __int8 *result, unsigned __int8 *a2);
size_t *__fastcall sub_429F4(size_t *a1, size_t a2, char *a3, size_t a4);
size_t *__fastcall sub_42BE4(size_t *a1, const void *a2, size_t a3);
_QWORD *__fastcall sub_42D60(_QWORD *result, __int64 a2, __int64 *a3);
void __fastcall sub_42F30(void **a1);
unsigned __int8 *__fastcall sub_42FE0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_43E00(_BYTE *a1, unsigned __int8 *a2, void **a3);
__int64 __fastcall sub_454F4(_BYTE *a1, _BYTE *a2, __int64 a3);
_BYTE *__fastcall sub_46514(_BYTE *a1, _BYTE *a2, _QWORD *a3);
unsigned __int8 *__fastcall sub_46760(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
void __fastcall sub_47A3C(size_t *a1, const void *a2, size_t a3);
unsigned __int8 *__fastcall sub_47B84(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
long double __fastcall sub_4CB68(unsigned __int8 *a1, __int64 a2);
unsigned __int8 *__fastcall sub_4CCE0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3);
unsigned __int8 *__fastcall sub_4E518(unsigned __int8 *result, unsigned __int8 *a2, void **a3);
__int64 __fastcall sub_4EE40(__int64 a1, __int64 a2, unsigned __int8 *a3, _QWORD *a4);
__int64 __fastcall sub_4F434(__int64 a1, __int64 a2, unsigned __int8 *a3, _QWORD *a4);
__int64 __fastcall sub_4F704(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_50168(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 *a4);
// size_t *__usercall sub_50A9C@<X0>(unsigned __int8 *a1@<X0>, const char *a2@<X1>, size_t *a3@<X8>);
__int64 __fastcall sub_50BA4(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_50EE8(unsigned __int8 *a1, unsigned __int8 *a2, void **a3);
unsigned __int8 *__fastcall sub_51914(_BYTE *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_57438(unsigned __int8 *a1, unsigned __int8 *a2, void **a3);
// void __usercall sub_57B54(size_t *a1@<X0>, __int64 a2@<X8>);
void __fastcall sub_57F64(size_t *a1, char a2);
__int64 __fastcall sub_5808C(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3, unsigned __int8 *a4);
unsigned __int8 *__fastcall sub_58458(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3);
void __fastcall sub_5859C(__int64 a1);
unsigned __int8 *__fastcall sub_58698(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
char *__fastcall sub_5C3A4(char *result, _QWORD *a2);
char *__fastcall sub_5C3CC(char *result, _QWORD *a2);
char *__fastcall sub_5C40C(char a1, char *a2, char *a3, unsigned __int64 *a4);
__int64 sub_5C4FC();
__int64 __fastcall sub_5C610(__int64 result, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_5C64C(__int64 a1, int a2);
__int64 __fastcall sub_5C6A4(__int64 a1, __int64 a2);
__int64 __fastcall sub_5C7B0(__int64 a1);
_QWORD *__fastcall sub_5C7B8(_QWORD *result, int a2, __int64 a3);
__int64 __fastcall sub_5C810(__int64 a1);
__int64 __fastcall sub_5C818(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_5C82C(__int64 result, __int64 a2);
__int64 __fastcall sub_5C834(__int64 a1);
__int64 __fastcall sub_5C83C(__int64 a1);
__int64 __fastcall sub_5C844(__int64 a1);
__int64 __fastcall sub_5C87C(unsigned __int8 a1, __int64 a2);
char *__fastcall sub_5C8F4(char *result, unsigned __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_5CDEC(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_5D210(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_5D7C4(__int64 a1, __int64 *a2);
__int64 __fastcall sub_5D9D0(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5DAAC(__int64 a1, __int64 *a2);
__int64 __fastcall sub_5DAF8(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_5DBB8(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_5DCA4(__int64 a1, __int64 a2);
__int64 __fastcall nullsub_1(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_5DD9C(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
_QWORD *__fastcall sub_5DF14(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
_QWORD *__fastcall sub_5E008(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
_QWORD *__fastcall sub_5E104(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 __fastcall sub_5E1FC(__int64 result);
__int64 __fastcall sub_5E220(unsigned int (__fastcall *a1)(_QWORD *, __int64), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
char *__fastcall sub_5E2F0(char *result, _QWORD *a2);
char *__fastcall sub_5E318(char *result, _QWORD *a2);
__int64 __fastcall sub_5E358(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5E374(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3, int a4, int a5);
__int64 __fastcall sub_5E434(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3);
__int64 __fastcall sub_5E4E8(unsigned __int8 a1);
__int64 __fastcall sub_5E548(unsigned __int8 a1, __int64 a2);
__int64 __fastcall sub_5E5A8(unsigned __int8 a1, __int64 a2);
char *__fastcall sub_5E608(char a1, char *a2, char *a3, unsigned __int64 *a4);
__int64 __fastcall sub_5E6F8(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5E788(__int64 a1);
unsigned int *__fastcall sub_5E884(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_5E9E4(__int64 a1);
__int64 __fastcall sub_5E9F4(__int64 *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_5EE10(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5EEAC(__int64 a1, char *a2);
__int64 __fastcall sub_5F00C(__int64 a1, __int64 *a2, unsigned int *a3);
unsigned int *__fastcall sub_5F140(__int64 a1, unsigned __int64 a2);
__int64 *__fastcall sub_5F6B0(__int64 *result, _QWORD *a2, __int64 a3, __int64 a4);
__int64 *__fastcall sub_5F74C(__int64 *a1, _QWORD *a2);
__int64 *__fastcall sub_5F758(__int64 *result);
__int64 *__fastcall sub_5F798(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 *__fastcall sub_5F82C(__int64 a1, _QWORD *a2);
__int64 *__fastcall sub_5F838(__int64 a1);
__int64 __fastcall sub_5F864(_DWORD *a1);
__int64 __fastcall sub_5F964(_DWORD *);
void __fastcall sub_5F968(_DWORD *a1);
unsigned int *__fastcall sub_5F98C(unsigned __int64 a1, _QWORD *a2);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
Elf64_Sym stru_2800 = { 18741u, 17u, 0u, 17u, 519440uLL, 32uLL }; // weak
_UNKNOWN loc_349F4; // weak
_UNKNOWN loc_572B4; // weak
_UNKNOWN loc_5C290; // weak
unsigned __int8 FLAC__crc8_table[256] =
{
  0u,
  7u,
  14u,
  9u,
  28u,
  27u,
  18u,
  21u,
  56u,
  63u,
  54u,
  49u,
  36u,
  35u,
  42u,
  45u,
  112u,
  119u,
  126u,
  121u,
  108u,
  107u,
  98u,
  101u,
  72u,
  79u,
  70u,
  65u,
  84u,
  83u,
  90u,
  93u,
  224u,
  231u,
  238u,
  233u,
  252u,
  251u,
  242u,
  245u,
  216u,
  223u,
  214u,
  209u,
  196u,
  195u,
  202u,
  205u,
  144u,
  151u,
  158u,
  153u,
  140u,
  139u,
  130u,
  133u,
  168u,
  175u,
  166u,
  161u,
  180u,
  179u,
  186u,
  189u,
  199u,
  192u,
  201u,
  206u,
  219u,
  220u,
  213u,
  210u,
  255u,
  248u,
  241u,
  246u,
  227u,
  228u,
  237u,
  234u,
  183u,
  176u,
  185u,
  190u,
  171u,
  172u,
  165u,
  162u,
  143u,
  136u,
  129u,
  134u,
  147u,
  148u,
  157u,
  154u,
  39u,
  32u,
  41u,
  46u,
  59u,
  60u,
  53u,
  50u,
  31u,
  24u,
  17u,
  22u,
  3u,
  4u,
  13u,
  10u,
  87u,
  80u,
  89u,
  94u,
  75u,
  76u,
  69u,
  66u,
  111u,
  104u,
  97u,
  102u,
  115u,
  116u,
  125u,
  122u,
  137u,
  142u,
  135u,
  128u,
  149u,
  146u,
  155u,
  156u,
  177u,
  182u,
  191u,
  184u,
  173u,
  170u,
  163u,
  164u,
  249u,
  254u,
  247u,
  240u,
  229u,
  226u,
  235u,
  236u,
  193u,
  198u,
  207u,
  200u,
  221u,
  218u,
  211u,
  212u,
  105u,
  110u,
  103u,
  96u,
  117u,
  114u,
  123u,
  124u,
  81u,
  86u,
  95u,
  88u,
  77u,
  74u,
  67u,
  68u,
  25u,
  30u,
  23u,
  16u,
  5u,
  2u,
  11u,
  12u,
  33u,
  38u,
  47u,
  40u,
  61u,
  58u,
  51u,
  52u,
  78u,
  73u,
  64u,
  71u,
  82u,
  85u,
  92u,
  91u,
  118u,
  113u,
  120u,
  127u,
  106u,
  109u,
  100u,
  99u,
  62u,
  57u,
  48u,
  55u,
  34u,
  37u,
  44u,
  43u,
  6u,
  1u,
  8u,
  15u,
  26u,
  29u,
  20u,
  19u,
  174u,
  169u,
  160u,
  167u,
  178u,
  181u,
  188u,
  187u,
  150u,
  145u,
  152u,
  159u,
  138u,
  141u,
  132u,
  131u,
  222u,
  217u,
  208u,
  215u,
  194u,
  197u,
  204u,
  203u,
  230u,
  225u,
  232u,
  239u,
  250u,
  253u,
  244u,
  243u
}; // weak
unsigned __int16 FLAC__crc16_table[2048] =
{
  0u,
  32773u,
  32783u,
  10u,
  32795u,
  30u,
  20u,
  32785u,
  32819u,
  54u,
  60u,
  32825u,
  40u,
  32813u,
  32807u,
  34u,
  32867u,
  102u,
  108u,
  32873u,
  120u,
  32893u,
  32887u,
  114u,
  80u,
  32853u,
  32863u,
  90u,
  32843u,
  78u,
  68u,
  32833u,
  32963u,
  198u,
  204u,
  32969u,
  216u,
  32989u,
  32983u,
  210u,
  240u,
  33013u,
  33023u,
  250u,
  33003u,
  238u,
  228u,
  32993u,
  160u,
  32933u,
  32943u,
  170u,
  32955u,
  190u,
  180u,
  32945u,
  32915u,
  150u,
  156u,
  32921u,
  136u,
  32909u,
  32903u,
  130u,
  33155u,
  390u,
  396u,
  33161u,
  408u,
  33181u,
  33175u,
  402u,
  432u,
  33205u,
  33215u,
  442u,
  33195u,
  430u,
  420u,
  33185u,
  480u,
  33253u,
  33263u,
  490u,
  33275u,
  510u,
  500u,
  33265u,
  33235u,
  470u,
  476u,
  33241u,
  456u,
  33229u,
  33223u,
  450u,
  320u,
  33093u,
  33103u,
  330u,
  33115u,
  350u,
  340u,
  33105u,
  33139u,
  374u,
  380u,
  33145u,
  360u,
  33133u,
  33127u,
  354u,
  33059u,
  294u,
  300u,
  33065u,
  312u,
  33085u,
  33079u,
  306u,
  272u,
  33045u,
  33055u,
  282u,
  33035u,
  270u,
  260u,
  33025u,
  33539u,
  774u,
  780u,
  33545u,
  792u,
  33565u,
  33559u,
  786u,
  816u,
  33589u,
  33599u,
  826u,
  33579u,
  814u,
  804u,
  33569u,
  864u,
  33637u,
  33647u,
  874u,
  33659u,
  894u,
  884u,
  33649u,
  33619u,
  854u,
  860u,
  33625u,
  840u,
  33613u,
  33607u,
  834u,
  960u,
  33733u,
  33743u,
  970u,
  33755u,
  990u,
  980u,
  33745u,
  33779u,
  1014u,
  1020u,
  33785u,
  1000u,
  33773u,
  33767u,
  994u,
  33699u,
  934u,
  940u,
  33705u,
  952u,
  33725u,
  33719u,
  946u,
  912u,
  33685u,
  33695u,
  922u,
  33675u,
  910u,
  900u,
  33665u,
  640u,
  33413u,
  33423u,
  650u,
  33435u,
  670u,
  660u,
  33425u,
  33459u,
  694u,
  700u,
  33465u,
  680u,
  33453u,
  33447u,
  674u,
  33507u,
  742u,
  748u,
  33513u,
  760u,
  33533u,
  33527u,
  754u,
  720u,
  33493u,
  33503u,
  730u,
  33483u,
  718u,
  708u,
  33473u,
  33347u,
  582u,
  588u,
  33353u,
  600u,
  33373u,
  33367u,
  594u,
  624u,
  33397u,
  33407u,
  634u,
  33387u,
  622u,
  612u,
  33377u,
  544u,
  33317u,
  33327u,
  554u,
  33339u,
  574u,
  564u,
  33329u,
  33299u,
  534u,
  540u,
  33305u,
  520u,
  33293u,
  33287u,
  514u,
  0u,
  34307u,
  35843u,
  2560u,
  38915u,
  7680u,
  5120u,
  37379u,
  45059u,
  13824u,
  15360u,
  47619u,
  10240u,
  44547u,
  41987u,
  8704u,
  57347u,
  26112u,
  27648u,
  59907u,
  30720u,
  65027u,
  62467u,
  29184u,
  20480u,
  54787u,
  56323u,
  23040u,
  51203u,
  19968u,
  17408u,
  49667u,
  16387u,
  50688u,
  52224u,
  18947u,
  55296u,
  24067u,
  21507u,
  53760u,
  61440u,
  30211u,
  31747u,
  64000u,
  26627u,
  60928u,
  58368u,
  25091u,
  40960u,
  9731u,
  11267u,
  43520u,
  14339u,
  48640u,
  46080u,
  12803u,
  4099u,
  38400u,
  39936u,
  6659u,
  34816u,
  3587u,
  1027u,
  33280u,
  32774u,
  1541u,
  3077u,
  35334u,
  6149u,
  40454u,
  37894u,
  4613u,
  12293u,
  46598u,
  48134u,
  14853u,
  43014u,
  11781u,
  9221u,
  41478u,
  24581u,
  58886u,
  60422u,
  27141u,
  63494u,
  32261u,
  29701u,
  61958u,
  53254u,
  22021u,
  23557u,
  55814u,
  18437u,
  52742u,
  50182u,
  16901u,
  49157u,
  17926u,
  19462u,
  51717u,
  22534u,
  56837u,
  54277u,
  20998u,
  28678u,
  62981u,
  64517u,
  31238u,
  59397u,
  28166u,
  25606u,
  57861u,
  8198u,
  42501u,
  44037u,
  10758u,
  47109u,
  15878u,
  13318u,
  45573u,
  36869u,
  5638u,
  7174u,
  39429u,
  2054u,
  36357u,
  33797u,
  518u,
  32777u,
  1546u,
  3082u,
  35337u,
  6154u,
  40457u,
  37897u,
  4618u,
  12298u,
  46601u,
  48137u,
  14858u,
  43017u,
  11786u,
  9226u,
  41481u,
  24586u,
  58889u,
  60425u,
  27146u,
  63497u,
  32266u,
  29706u,
  61961u,
  53257u,
  22026u,
  23562u,
  55817u,
  18442u,
  52745u,
  50185u,
  16906u,
  49162u,
  17929u,
  19465u,
  51722u,
  22537u,
  56842u,
  54282u,
  21001u,
  28681u,
  62986u,
  64522u,
  31241u,
  59402u,
  28169u,
  25609u,
  57866u,
  8201u,
  42506u,
  44042u,
  10761u,
  47114u,
  15881u,
  13321u,
  45578u,
  36874u,
  5641u,
  7177u,
  39434u,
  2057u,
  36362u,
  33802u,
  521u,
  15u,
  34316u,
  35852u,
  2575u,
  38924u,
  7695u,
  5135u,
  37388u,
  45068u,
  13839u,
  15375u,
  47628u,
  10255u,
  44556u,
  41996u,
  8719u,
  57356u,
  26127u,
  27663u,
  59916u,
  30735u,
  65036u,
  62476u,
  29199u,
  20495u,
  54796u,
  56332u,
  23055u,
  51212u,
  19983u,
  17423u,
  49676u,
  16396u,
  50703u,
  52239u,
  18956u,
  55311u,
  24076u,
  21516u,
  53775u,
  61455u,
  30220u,
  31756u,
  64015u,
  26636u,
  60943u,
  58383u,
  25100u,
  40975u,
  9740u,
  11276u,
  43535u,
  14348u,
  48655u,
  46095u,
  12812u,
  4108u,
  38415u,
  39951u,
  6668u,
  34831u,
  3596u,
  1036u,
  33295u,
  0u,
  32791u,
  32811u,
  60u,
  32851u,
  68u,
  120u,
  32879u,
  32931u,
  180u,
  136u,
  32927u,
  240u,
  32999u,
  32987u,
  204u,
  33091u,
  340u,
  360u,
  33151u,
  272u,
  33031u,
  33083u,
  300u,
  480u,
  33271u,
  33227u,
  476u,
  33203u,
  420u,
  408u,
  33167u,
  33411u,
  660u,
  680u,
  33471u,
  720u,
  33479u,
  33531u,
  748u,
  544u,
  33335u,
  33291u,
  540u,
  33395u,
  612u,
  600u,
  33359u,
  960u,
  33751u,
  33771u,
  1020u,
  33683u,
  900u,
  952u,
  33711u,
  33635u,
  884u,
  840u,
  33631u,
  816u,
  33575u,
  33563u,
  780u,
  34051u,
  1300u,
  1320u,
  34111u,
  1360u,
  34119u,
  34171u,
  1388u,
  1440u,
  34231u,
  34187u,
  1436u,
  34291u,
  1508u,
  1496u,
  34255u,
  1088u,
  33879u,
  33899u,
  1148u,
  33811u,
  1028u,
  1080u,
  33839u,
  34019u,
  1268u,
  1224u,
  34015u,
  1200u,
  33959u,
  33947u,
  1164u,
  1920u,
  34711u,
  34731u,
  1980u,
  34771u,
  1988u,
  2040u,
  34799u,
  34595u,
  1844u,
  1800u,
  34591u,
  1904u,
  34663u,
  34651u,
  1868u,
  34499u,
  1748u,
  1768u,
  34559u,
  1680u,
  34439u,
  34491u,
  1708u,
  1632u,
  34423u,
  34379u,
  1628u,
  34355u,
  1572u,
  1560u,
  34319u,
  35331u,
  2580u,
  2600u,
  35391u,
  2640u,
  35399u,
  35451u,
  2668u,
  2720u,
  35511u,
  35467u,
  2716u,
  35571u,
  2788u,
  2776u,
  35535u,
  2880u,
  35671u,
  35691u,
  2940u,
  35603u,
  2820u,
  2872u,
  35631u,
  35811u,
  3060u,
  3016u,
  35807u,
  2992u,
  35751u,
  35739u,
  2956u,
  2176u,
  34967u,
  34987u,
  2236u,
  35027u,
  2244u,
  2296u,
  35055u,
  34851u,
  2100u,
  2056u,
  34847u,
  2160u,
  34919u,
  34907u,
  2124u,
  35267u,
  2516u,
  2536u,
  35327u,
  2448u,
  35207u,
  35259u,
  2476u,
  2400u,
  35191u,
  35147u,
  2396u,
  35123u,
  2340u,
  2328u,
  35087u,
  3840u,
  36631u,
  36651u,
  3900u,
  36691u,
  3908u,
  3960u,
  36719u,
  36771u,
  4020u,
  3976u,
  36767u,
  4080u,
  36839u,
  36827u,
  4044u,
  36419u,
  3668u,
  3688u,
  36479u,
  3600u,
  36359u,
  36411u,
  3628u,
  3808u,
  36599u,
  36555u,
  3804u,
  36531u,
  3748u,
  3736u,
  36495u,
  36227u,
  3476u,
  3496u,
  36287u,
  3536u,
  36295u,
  36347u,
  3564u,
  3360u,
  36151u,
  36107u,
  3356u,
  36211u,
  3428u,
  3416u,
  36175u,
  3264u,
  36055u,
  36075u,
  3324u,
  35987u,
  3204u,
  3256u,
  36015u,
  35939u,
  3188u,
  3144u,
  35935u,
  3120u,
  35879u,
  35867u,
  3084u,
  0u,
  37891u,
  43011u,
  15360u,
  53251u,
  17408u,
  30720u,
  60419u,
  8195u,
  46080u,
  34816u,
  7171u,
  61440u,
  25603u,
  22531u,
  52224u,
  16390u,
  54277u,
  59397u,
  31750u,
  36869u,
  1030u,
  14342u,
  44037u,
  24581u,
  62470u,
  51206u,
  23557u,
  45062u,
  9221u,
  6149u,
  35846u,
  32780u,
  5135u,
  10255u,
  48140u,
  20495u,
  50188u,
  63500u,
  27663u,
  40975u,
  13324u,
  2060u,
  39951u,
  28684u,
  58383u,
  55311u,
  19468u,
  49162u,
  21513u,
  26633u,
  64522u,
  4105u,
  33802u,
  47114u,
  11273u,
  57353u,
  29706u,
  18442u,
  56329u,
  12298u,
  41993u,
  38921u,
  3082u,
  32797u,
  5150u,
  10270u,
  48157u,
  20510u,
  50205u,
  63517u,
  27678u,
  40990u,
  13341u,
  2077u,
  39966u,
  28701u,
  58398u,
  55326u,
  19485u,
  49179u,
  21528u,
  26648u,
  64539u,
  4120u,
  33819u,
  47131u,
  11288u,
  57368u,
  29723u,
  18459u,
  56344u,
  12315u,
  42008u,
  38936u,
  3099u,
  17u,
  37906u,
  43026u,
  15377u,
  53266u,
  17425u,
  30737u,
  60434u,
  8210u,
  46097u,
  34833u,
  7186u,
  61457u,
  25618u,
  22546u,
  52241u,
  16407u,
  54292u,
  59412u,
  31767u,
  36884u,
  1047u,
  14359u,
  44052u,
  24596u,
  62487u,
  51223u,
  23572u,
  45079u,
  9236u,
  6164u,
  35863u,
  32831u,
  5180u,
  10300u,
  48191u,
  20540u,
  50239u,
  63551u,
  27708u,
  41020u,
  13375u,
  2111u,
  39996u,
  28735u,
  58428u,
  55356u,
  19519u,
  49209u,
  21562u,
  26682u,
  64569u,
  4154u,
  33849u,
  47161u,
  11322u,
  57402u,
  29753u,
  18489u,
  56378u,
  12345u,
  42042u,
  38970u,
  3129u,
  51u,
  37936u,
  43056u,
  15411u,
  53296u,
  17459u,
  30771u,
  60464u,
  8240u,
  46131u,
  34867u,
  7216u,
  61491u,
  25648u,
  22576u,
  52275u,
  16437u,
  54326u,
  59446u,
  31797u,
  36918u,
  1077u,
  14389u,
  44086u,
  24630u,
  62517u,
  51253u,
  23606u,
  45109u,
  9270u,
  6198u,
  35893u,
  34u,
  37921u,
  43041u,
  15394u,
  53281u,
  17442u,
  30754u,
  60449u,
  8225u,
  46114u,
  34850u,
  7201u,
  61474u,
  25633u,
  22561u,
  52258u,
  16420u,
  54311u,
  59431u,
  31780u,
  36903u,
  1060u,
  14372u,
  44071u,
  24615u,
  62500u,
  51236u,
  23591u,
  45092u,
  9255u,
  6183u,
  35876u,
  32814u,
  5165u,
  10285u,
  48174u,
  20525u,
  50222u,
  63534u,
  27693u,
  41005u,
  13358u,
  2094u,
  39981u,
  28718u,
  58413u,
  55341u,
  19502u,
  49192u,
  21547u,
  26667u,
  64552u,
  4139u,
  33832u,
  47144u,
  11307u,
  57387u,
  29736u,
  18472u,
  56363u,
  12328u,
  42027u,
  38955u,
  3112u,
  0u,
  32891u,
  33011u,
  136u,
  33251u,
  408u,
  272u,
  33131u,
  33731u,
  952u,
  816u,
  33611u,
  544u,
  33371u,
  33491u,
  680u,
  34691u,
  2040u,
  1904u,
  34571u,
  1632u,
  34331u,
  34451u,
  1768u,
  1088u,
  33851u,
  33971u,
  1224u,
  34211u,
  1496u,
  1360u,
  34091u,
  36611u,
  3960u,
  4080u,
  36747u,
  3808u,
  36507u,
  36371u,
  3688u,
  3264u,
  36027u,
  35891u,
  3144u,
  36131u,
  3416u,
  3536u,
  36267u,
  2176u,
  35067u,
  34931u,
  2056u,
  35171u,
  2328u,
  2448u,
  35307u,
  35651u,
  2872u,
  2992u,
  35787u,
  2720u,
  35547u,
  35411u,
  2600u,
  40451u,
  7800u,
  7920u,
  40587u,
  8160u,
  40859u,
  40723u,
  8040u,
  7616u,
  40379u,
  40243u,
  7496u,
  39971u,
  7256u,
  7376u,
  40107u,
  6528u,
  39419u,
  39283u,
  6408u,
  39011u,
  6168u,
  6288u,
  39147u,
  39491u,
  6712u,
  6832u,
  39627u,
  7072u,
  39899u,
  39763u,
  6952u,
  4352u,
  37243u,
  37363u,
  4488u,
  37091u,
  4248u,
  4112u,
  36971u,
  37571u,
  4792u,
  4656u,
  37451u,
  4896u,
  37723u,
  37843u,
  5032u,
  38531u,
  5880u,
  5744u,
  38411u,
  5984u,
  38683u,
  38803u,
  6120u,
  5440u,
  38203u,
  38323u,
  5576u,
  38051u,
  5336u,
  5200u,
  37931u,
  48131u,
  15480u,
  15600u,
  48267u,
  15840u,
  48539u,
  48403u,
  15720u,
  16320u,
  49083u,
  48947u,
  16200u,
  48675u,
  15960u,
  16080u,
  48811u,
  15232u,
  48123u,
  47987u,
  15112u,
  47715u,
  14872u,
  14992u,
  47851u,
  47171u,
  14392u,
  14512u,
  47307u,
  14752u,
  47579u,
  47443u,
  14632u,
  13056u,
  45947u,
  46067u,
  13192u,
  45795u,
  12952u,
  12816u,
  45675u,
  45251u,
  12472u,
  12336u,
  45131u,
  12576u,
  45403u,
  45523u,
  12712u,
  46211u,
  13560u,
  13424u,
  46091u,
  13664u,
  46363u,
  46483u,
  13800u,
  14144u,
  46907u,
  47027u,
  14280u,
  46755u,
  14040u,
  13904u,
  46635u,
  8704u,
  41595u,
  41715u,
  8840u,
  41955u,
  9112u,
  8976u,
  41835u,
  41411u,
  8632u,
  8496u,
  41291u,
  8224u,
  41051u,
  41171u,
  8360u,
  42371u,
  9720u,
  9584u,
  42251u,
  9312u,
  42011u,
  42131u,
  9448u,
  9792u,
  42555u,
  42675u,
  9928u,
  42915u,
  10200u,
  10064u,
  42795u,
  44291u,
  11640u,
  11760u,
  44427u,
  11488u,
  44187u,
  44051u,
  11368u,
  11968u,
  44731u,
  44595u,
  11848u,
  44835u,
  12120u,
  12240u,
  44971u,
  10880u,
  43771u,
  43635u,
  10760u,
  43875u,
  11032u,
  11152u,
  44011u,
  43331u,
  10552u,
  10672u,
  43467u,
  10400u,
  43227u,
  43091u,
  10280u,
  0u,
  63491u,
  28675u,
  34816u,
  57350u,
  6149u,
  36869u,
  26630u,
  16393u,
  47114u,
  12298u,
  51209u,
  40975u,
  22540u,
  53260u,
  10255u,
  32786u,
  30737u,
  61457u,
  2066u,
  24596u,
  38935u,
  4119u,
  59412u,
  49179u,
  14360u,
  45080u,
  18459u,
  8221u,
  55326u,
  20510u,
  43037u,
  32801u,
  30754u,
  61474u,
  2081u,
  24615u,
  38948u,
  4132u,
  59431u,
  49192u,
  14379u,
  45099u,
  18472u,
  8238u,
  55341u,
  20525u,
  43054u,
  51u,
  63536u,
  28720u,
  34867u,
  57397u,
  6198u,
  36918u,
  26677u,
  16442u,
  47161u,
  12345u,
  51258u,
  41020u,
  22591u,
  53311u,
  10300u,
  32839u,
  30788u,
  61508u,
  2119u,
  24641u,
  38978u,
  4162u,
  59457u,
  49230u,
  14413u,
  45133u,
  18510u,
  8264u,
  55371u,
  20555u,
  43080u,
  85u,
  63574u,
  28758u,
  34901u,
  57427u,
  6224u,
  36944u,
  26707u,
  16476u,
  47199u,
  12383u,
  51292u,
  41050u,
  22617u,
  53337u,
  10330u,
  102u,
  63589u,
  28773u,
  34918u,
  57440u,
  6243u,
  36963u,
  26720u,
  16495u,
  47212u,
  12396u,
  51311u,
  41065u,
  22634u,
  53354u,
  10345u,
  32884u,
  30839u,
  61559u,
  2164u,
  24690u,
  39025u,
  4209u,
  59506u,
  49277u,
  14462u,
  45182u,
  18557u,
  8315u,
  55416u,
  20600u,
  43131u,
  32907u,
  30856u,
  61576u,
  2187u,
  24717u,
  39054u,
  4238u,
  59533u,
  49282u,
  14465u,
  45185u,
  18562u,
  8324u,
  55431u,
  20615u,
  43140u,
  153u,
  63642u,
  28826u,
  34969u,
  57503u,
  6300u,
  37020u,
  26783u,
  16528u,
  47251u,
  12435u,
  51344u,
  41110u,
  22677u,
  53397u,
  10390u,
  170u,
  63657u,
  28841u,
  34986u,
  57516u,
  6319u,
  37039u,
  26796u,
  16547u,
  47264u,
  12448u,
  51363u,
  41125u,
  22694u,
  53414u,
  10405u,
  32952u,
  30907u,
  61627u,
  2232u,
  24766u,
  39101u,
  4285u,
  59582u,
  49329u,
  14514u,
  45234u,
  18609u,
  8375u,
  55476u,
  20660u,
  43191u,
  204u,
  63695u,
  28879u,
  35020u,
  57546u,
  6345u,
  37065u,
  26826u,
  16581u,
  47302u,
  12486u,
  51397u,
  41155u,
  22720u,
  53440u,
  10435u,
  32990u,
  30941u,
  61661u,
  2270u,
  24792u,
  39131u,
  4315u,
  59608u,
  49367u,
  14548u,
  45268u,
  18647u,
  8401u,
  55506u,
  20690u,
  43217u,
  33005u,
  30958u,
  61678u,
  2285u,
  24811u,
  39144u,
  4328u,
  59627u,
  49380u,
  14567u,
  45287u,
  18660u,
  8418u,
  55521u,
  20705u,
  43234u,
  255u,
  63740u,
  28924u,
  35071u,
  57593u,
  6394u,
  37114u,
  26873u,
  16630u,
  47349u,
  12533u,
  51446u,
  41200u,
  22771u,
  53491u,
  10480u,
  0u,
  33043u,
  33315u,
  816u,
  33859u,
  1360u,
  1632u,
  34675u,
  34947u,
  2448u,
  2720u,
  35763u,
  3264u,
  36307u,
  36579u,
  4080u,
  37123u,
  4112u,
  4896u,
  37427u,
  5440u,
  37971u,
  38755u,
  5744u,
  6528u,
  39059u,
  39843u,
  6832u,
  40387u,
  7376u,
  8160u,
  40691u,
  41475u,
  8976u,
  8224u,
  41267u,
  9792u,
  42835u,
  42083u,
  9584u,
  10880u,
  43923u,
  43171u,
  10672u,
  44739u,
  12240u,
  11488u,
  44531u,
  13056u,
  45587u,
  45347u,
  12336u,
  46915u,
  13904u,
  13664u,
  46195u,
  48003u,
  14992u,
  14752u,
  47283u,
  16320u,
  48851u,
  48611u,
  15600u,
  50179u,
  17680u,
  17952u,
  50995u,
  16448u,
  49491u,
  49763u,
  17264u,
  19584u,
  52627u,
  52899u,
  20400u,
  51395u,
  18896u,
  19168u,
  52211u,
  21760u,
  54291u,
  55075u,
  22064u,
  53571u,
  20560u,
  21344u,
  53875u,
  56707u,
  23696u,
  24480u,
  57011u,
  22976u,
  55507u,
  56291u,
  23280u,
  26112u,
  59155u,
  58403u,
  25904u,
  57923u,
  25424u,
  24672u,
  57715u,
  61059u,
  28560u,
  27808u,
  60851u,
  27328u,
  60371u,
  59619u,
  27120u,
  63235u,
  30224u,
  29984u,
  62515u,
  29504u,
  62035u,
  61795u,
  28784u,
  32640u,
  65171u,
  64931u,
  31920u,
  64451u,
  31440u,
  31200u,
  63731u,
  2051u,
  35088u,
  35360u,
  2867u,
  35904u,
  3411u,
  3683u,
  36720u,
  32896u,
  403u,
  675u,
  33712u,
  1219u,
  34256u,
  34528u,
  2035u,
  39168u,
  6163u,
  6947u,
  39472u,
  7491u,
  40016u,
  40800u,
  7795u,
  4483u,
  37008u,
  37792u,
  4787u,
  38336u,
  5331u,
  6115u,
  38640u,
  43520u,
  11027u,
  10275u,
  43312u,
  11843u,
  44880u,
  44128u,
  11635u,
  8835u,
  41872u,
  41120u,
  8627u,
  42688u,
  10195u,
  9443u,
  42480u,
  15107u,
  47632u,
  47392u,
  14387u,
  48960u,
  15955u,
  15715u,
  48240u,
  45952u,
  12947u,
  12707u,
  45232u,
  14275u,
  46800u,
  46560u,
  13555u,
  52224u,
  19731u,
  20003u,
  53040u,
  18499u,
  51536u,
  51808u,
  19315u,
  17539u,
  50576u,
  50848u,
  18355u,
  49344u,
  16851u,
  17123u,
  50160u,
  23811u,
  56336u,
  57120u,
  24115u,
  55616u,
  22611u,
  23395u,
  55920u,
  54656u,
  21651u,
  22435u,
  54960u,
  20931u,
  53456u,
  54240u,
  21235u,
  28163u,
  61200u,
  60448u,
  27955u,
  59968u,
  27475u,
  26723u,
  59760u,
  59008u,
  26515u,
  25763u,
  58800u,
  25283u,
  58320u,
  57568u,
  25075u,
  65280u,
  32275u,
  32035u,
  64560u,
  31555u,
  64080u,
  63840u,
  30835u,
  30595u,
  63120u,
  62880u,
  29875u,
  62400u,
  29395u,
  29155u,
  61680u,
  0u,
  4102u,
  8204u,
  12298u,
  16408u,
  20510u,
  24596u,
  28690u,
  32816u,
  36918u,
  41020u,
  45114u,
  49192u,
  53294u,
  57380u,
  61474u,
  32869u,
  36963u,
  41065u,
  45167u,
  49277u,
  53371u,
  57457u,
  61559u,
  85u,
  4179u,
  8281u,
  12383u,
  16461u,
  20555u,
  24641u,
  28743u,
  32975u,
  37065u,
  41155u,
  45253u,
  49367u,
  53457u,
  57563u,
  61661u,
  255u,
  4345u,
  8435u,
  12533u,
  16615u,
  20705u,
  24811u,
  28909u,
  170u,
  4268u,
  8358u,
  12448u,
  16562u,
  20660u,
  24766u,
  28856u,
  32922u,
  37020u,
  41110u,
  45200u,
  49282u,
  53380u,
  57486u,
  61576u,
  33179u,
  37277u,
  41367u,
  45457u,
  49539u,
  53637u,
  57743u,
  61833u,
  427u,
  4525u,
  8615u,
  12705u,
  16819u,
  20917u,
  25023u,
  29113u,
  510u,
  4600u,
  8690u,
  12788u,
  16870u,
  20960u,
  25066u,
  29164u,
  33230u,
  37320u,
  41410u,
  45508u,
  49622u,
  53712u,
  57818u,
  61916u,
  340u,
  4434u,
  8536u,
  12638u,
  16716u,
  20810u,
  24896u,
  28998u,
  33124u,
  37218u,
  41320u,
  45422u,
  49532u,
  53626u,
  57712u,
  61814u,
  33073u,
  37175u,
  41277u,
  45371u,
  49449u,
  53551u,
  57637u,
  61731u,
  257u,
  4359u,
  8461u,
  12555u,
  16665u,
  20767u,
  24853u,
  28947u,
  33587u,
  37685u,
  41791u,
  45881u,
  49963u,
  54061u,
  58151u,
  62241u,
  771u,
  4869u,
  8975u,
  13065u,
  17179u,
  21277u,
  25367u,
  29457u,
  854u,
  4944u,
  9050u,
  13148u,
  17230u,
  21320u,
  25410u,
  29508u,
  33638u,
  37728u,
  41834u,
  45932u,
  50046u,
  54136u,
  58226u,
  62324u,
  1020u,
  5114u,
  9200u,
  13302u,
  17380u,
  21474u,
  25576u,
  29678u,
  33740u,
  37834u,
  41920u,
  46022u,
  50132u,
  54226u,
  58328u,
  62430u,
  33689u,
  37791u,
  41877u,
  45971u,
  50049u,
  54151u,
  58253u,
  62347u,
  937u,
  5039u,
  9125u,
  13219u,
  17329u,
  21431u,
  25533u,
  29627u,
  680u,
  4782u,
  8868u,
  12962u,
  17072u,
  21174u,
  25276u,
  29370u,
  33432u,
  37534u,
  41620u,
  45714u,
  49792u,
  53894u,
  57996u,
  62090u,
  33485u,
  37579u,
  41665u,
  45767u,
  49877u,
  53971u,
  58073u,
  62175u,
  765u,
  4859u,
  8945u,
  13047u,
  17125u,
  21219u,
  25321u,
  29423u,
  33383u,
  37473u,
  41579u,
  45677u,
  49791u,
  53881u,
  57971u,
  62069u,
  599u,
  4689u,
  8795u,
  12893u,
  16975u,
  21065u,
  25155u,
  29253u,
  514u,
  4612u,
  8718u,
  12808u,
  16922u,
  21020u,
  25110u,
  29200u,
  33330u,
  37428u,
  41534u,
  45624u,
  49706u,
  53804u,
  57894u,
  61984u
}; // weak
_DWORD dword_61254[131] =
{
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  7,
  3,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  106,
  49,
  24,
  12,
  6,
  3,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4096,
  1700,
  789,
  381,
  188,
  93,
  46,
  23,
  12,
  6,
  3,
  1,
  1,
  0,
  0,
  0,
  65536,
  27200,
  12625,
  6102,
  3002,
  1489,
  742,
  370,
  185,
  92,
  46,
  23,
  12,
  6,
  3,
  0,
  1048576,
  435198,
  202003,
  97632,
  48029,
  23824,
  11865,
  5921,
  2958,
  1478,
  739,
  369,
  185,
  92,
  46,
  0,
  16777216,
  6963174,
  3232048,
  1562117,
  768458,
  381180,
  189839,
  94734,
  47320,
  23649,
  11821,
  5910,
  2955,
  1477,
  739,
  0,
  268435456,
  111410780,
  51712769,
  24993865,
  12295334,
  6098874,
  3037431,
  1515738,
  757127,
  378379,
  189143,
  94560,
  47277,
  23638,
  11819,
  0,
  0,
  0
}; // weak
__int128 xmmword_61460 = 0x0FFFFFFFFFFFFFFFFLL; // weak
int FLAC__STREAM_SYNC_STRING = 1130450022; // weak
int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN = 4; // weak
int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN = 5; // weak
int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER = 15; // weak
int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER = 31; // weak
__int128 xmmword_61BF0 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
char aId3_0[4] = "ID3"; // weak
__int128 xmmword_62A20 = 0x10000000100000000LL; // weak
__int128 xmmword_62A30 = 0xAC44000000100000000200000000LL; // weak
__int128 xmmword_62A40 = 8LL; // weak
__int128 xmmword_62A50 = 0x2600000000000000120LL; // weak
__int128 xmmword_62A60 = 0x4E000000000000003A0LL; // weak
__int128 xmmword_62A70 = 0x7600000000000000620LL; // weak
__int128 xmmword_62A80 = 0x9E000000000000008A0LL; // weak
__int128 xmmword_62A90 = 0xC600000000000000B20LL; // weak
__int128 xmmword_62AA0 = 0xEE00000000000000DA0LL; // weak
__int128 xmmword_62AB0 = 0x11600000000000001020LL; // weak
__int128 xmmword_62AC0 = 0x152000000000000013E0LL; // weak
__int128 xmmword_62AD0 = 0x17A00000000000001660LL; // weak
_DWORD dword_631E0[8] = { 1, 2, 4, 5, 6, 0, 0, 0 }; // weak
_UNKNOWN unk_63320; // weak
_UNKNOWN unk_63330; // weak
char aStdBadTypeid[16] = "std::bad_typeid"; // weak
_QWORD qword_63750[11] = { 1LL, 2LL, 3LL, 3LL, 3LL, 3LL, 3LL, 3LL, 1LL, 2LL, 3LL }; // weak
char asc_64834[3] = ", "; // weak
char aLambda[10] = "'lambda'("; // weak
void (__fastcall *off_7DFA0[2])(DataSource *__hidden this) = { &DataSource::~DataSource, &JavaDataSource::~JavaDataSource }; // weak
char *FLAC__StreamDecoderStateString[69] =
{
  "FLAC__STREAM_DECODER_SEARCH_FOR_METADATA",
  "FLAC__STREAM_DECODER_READ_METADATA",
  "FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC",
  "FLAC__STREAM_DECODER_READ_FRAME",
  "FLAC__STREAM_DECODER_END_OF_STREAM",
  "FLAC__STREAM_DECODER_OGG_ERROR",
  "FLAC__STREAM_DECODER_SEEK_ERROR",
  "FLAC__STREAM_DECODER_ABORTED",
  "FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR",
  "FLAC__STREAM_DECODER_UNINITIALIZED",
  "FLAC__STREAM_DECODER_INIT_STATUS_OK",
  "FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
  "FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS",
  "FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR",
  "FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE",
  "FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED",
  "FLAC__STREAM_DECODER_READ_STATUS_CONTINUE",
  "FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM",
  "FLAC__STREAM_DECODER_READ_STATUS_ABORT",
  "FLAC__STREAM_DECODER_SEEK_STATUS_OK",
  "FLAC__STREAM_DECODER_SEEK_STATUS_ERROR",
  "FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED",
  "FLAC__STREAM_DECODER_TELL_STATUS_OK",
  "FLAC__STREAM_DECODER_TELL_STATUS_ERROR",
  "FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED",
  "FLAC__STREAM_DECODER_LENGTH_STATUS_OK",
  "FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR",
  "FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED",
  "FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE",
  "FLAC__STREAM_DECODER_WRITE_STATUS_ABORT",
  "FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC",
  "FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER",
  "FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH",
  "FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM",
  "FLAC__STREAM_ENCODER_OK",
  "FLAC__STREAM_ENCODER_UNINITIALIZED",
  "FLAC__STREAM_ENCODER_OGG_ERROR",
  "FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR",
  "FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA",
  "FLAC__STREAM_ENCODER_CLIENT_ERROR",
  "FLAC__STREAM_ENCODER_IO_ERROR",
  "FLAC__STREAM_ENCODER_FRAMING_ERROR",
  "FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR",
  "FLAC__STREAM_ENCODER_INIT_STATUS_OK",
  "FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR",
  "FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION",
  "FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA",
  "FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED",
  "FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE",
  "FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM",
  "FLAC__STREAM_ENCODER_READ_STATUS_ABORT",
  "FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED",
  "FLAC__STREAM_ENCODER_WRITE_STATUS_OK",
  "FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_OK",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED",
  "FLAC__STREAM_ENCODER_TELL_STATUS_OK",
  "FLAC__STREAM_ENCODER_TELL_STATUS_ERROR",
  "FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"
}; // weak
char *FLAC__StreamEncoderStateString[35] =
{
  "FLAC__STREAM_ENCODER_OK",
  "FLAC__STREAM_ENCODER_UNINITIALIZED",
  "FLAC__STREAM_ENCODER_OGG_ERROR",
  "FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR",
  "FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA",
  "FLAC__STREAM_ENCODER_CLIENT_ERROR",
  "FLAC__STREAM_ENCODER_IO_ERROR",
  "FLAC__STREAM_ENCODER_FRAMING_ERROR",
  "FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR",
  "FLAC__STREAM_ENCODER_INIT_STATUS_OK",
  "FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR",
  "FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION",
  "FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER",
  "FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE",
  "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA",
  "FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED",
  "FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE",
  "FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM",
  "FLAC__STREAM_ENCODER_READ_STATUS_ABORT",
  "FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED",
  "FLAC__STREAM_ENCODER_WRITE_STATUS_OK",
  "FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_OK",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR",
  "FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED",
  "FLAC__STREAM_ENCODER_TELL_STATUS_OK",
  "FLAC__STREAM_ENCODER_TELL_STATUS_ERROR",
  "FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"
}; // weak
_UNKNOWN unk_7E438; // weak
__int64 *`typeinfo for'__cxxabiv1::__shim_type_info = &off_7F008; // weak
__int64 *`typeinfo for'__cxxabiv1::__class_type_info = &off_7F008; // weak
__int64 *`typeinfo for'__cxxabiv1::__pbase_type_info = &off_7F008; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_type_info = &off_7F008; // weak
__int64 *`typeinfo for'__cxxabiv1::__function_type_info = &off_7F008; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info = &off_7F008; // weak
void (__fastcall *`typeinfo for'void)(std::type_info *__hidden this) = &off_7E6F0; // weak
void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this) = &off_7E6F0; // weak
void (__fastcall *off_7F190[2])(std::bad_cast *__hidden this) = { &std::bad_cast::~bad_cast, &std::bad_cast::~bad_cast }; // weak
void (__fastcall *off_7F1B8[2])(std::bad_typeid *__hidden this) = { &std::bad_typeid::~bad_typeid, &std::bad_typeid::~bad_typeid }; // weak
void (__fastcall *off_7F250[2])(std::exception *__hidden this) = { &std::exception::~exception, &std::bad_alloc::~bad_alloc }; // weak
void (__fastcall *off_7F278[2])(std::exception *__hidden this) =
{
  &std::exception::~exception,
  &std::bad_array_new_length::~bad_array_new_length
}; // weak
void (__fastcall *off_7F2A0[2])(std::exception *__hidden this) = { &std::exception::~exception, &std::bad_array_length::~bad_array_length }; // weak
__int64 *`typeinfo for'std::exception = &off_7EFB8; // weak
__int64 *`typeinfo for'std::bad_alloc = &off_7F008; // weak
_UNKNOWN *off_80000 = &off_80000; // weak
char *FLAC__VENDOR_STRING = "reference libFLAC 1.3.3 20190804"; // weak
__int64 (__fastcall *_cxa_terminate_handler)() = &sub_363E0; // weak
void (__fastcall __noreturn *_cxa_unexpected_handler)() = &sub_36508; // weak
char *off_80030 = "uncaught"; // weak
__int64 qword_80038 = -1LL; // weak
int dword_80044; // weak
pthread_once_t dword_80048[2]; // weak
__int64 _cxa_new_handler; // weak
pthread_mutex_t stru_80060; // weak
__int64 qword_80088; // weak
int dword_80090[128]; // weak
char byte_80290[]; // weak
char byte_802AF; // weak
char byte_802D0; // weak
_BYTE algn_802F1[7]; // weak
__int64 qword_802F8; // weak
__int64 qword_80300; // weak
_UNKNOWN unk_80308; // weak
_UNKNOWN unk_80338; // weak
__int64 qword_80480; // weak
_BYTE algn_80488[8]; // weak
_UNKNOWN unk_80490; // weak
pthread_mutex_t stru_80498; // weak
__int64 qword_804C0; // weak
__int64 qword_804C8; // weak
// extern _UNKNOWN _sF; weak


//----- (0000000000011430) ----------------------------------------------------
void sub_11430()
{
  JUMPOUT(0);
}
// 11440: control flows out of bounds to 0

//----- (0000000000011450) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_raw_uint64(__int64 a1, unsigned __int64 *a2, unsigned int a3)
{
  return FLAC__bitreader_read_raw_uint64(a1, a2, a3);
}

//----- (0000000000011460) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__crc16(unsigned __int8 *a1, unsigned int a2)
{
  return FLAC__crc16(a1, a2);
}

//----- (0000000000011470) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<std::string>::__push_back_slow_path<std::string const&>(size_t **a1, __int64 a2)
{
  _ZNSt6__ndk16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE21__push_back_slow_pathIRKS6_EEvOT_(
    a1,
    a2);
}

//----- (0000000000011480) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__subframe_add_lpc(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  return FLAC__subframe_add_lpc(a1, a2, a3, a4, a5);
}

//----- (0000000000011490) ----------------------------------------------------
// attributes: thunk
void *__cxa_get_globals_fast()
{
  return _cxa_get_globals_fast();
}

//----- (00000000000114A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitwriter_clear(__int64 result)
{
  return FLAC__bitwriter_clear(result);
}

//----- (00000000000114B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_get_state(unsigned int **a1)
{
  return FLAC__stream_decoder_get_state(a1);
}

//----- (00000000000114C0) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  _cxa_throw(a1, lptinfo, a3);
}

//----- (00000000000114D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__crc8(char *a1, int a2)
{
  return FLAC__crc8(a1, a2);
}

//----- (00000000000114E0) ----------------------------------------------------
// attributes: thunk
_QWORD *FLAC__stream_decoder_new()
{
  return FLAC__stream_decoder_new();
}

//----- (0000000000011500) ----------------------------------------------------
// attributes: thunk
__int64 operator new[]()
{
  return _ZnamSt11align_val_t();
}
// 347F4: using guessed type __int64 operator new[](void);

//----- (0000000000011510) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond(__int64 a1, unsigned int a2)
{
  return FLAC__stream_decoder_set_metadata_respond(a1, a2);
}

//----- (0000000000011530) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__metadata_object_seektable_resize_points(__int64 a1, unsigned int a2)
{
  return FLAC__metadata_object_seektable_resize_points(a1, a2);
}

//----- (0000000000011540) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_seektable_is_legal(unsigned int *a1)
{
  return FLAC__format_seektable_is_legal(a1);
}

//----- (0000000000011550) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_init_stream(
        int **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  return FLAC__stream_decoder_init_stream(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0000000000011560) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__metadata_object_clone(__int64 *a1)
{
  return FLAC__metadata_object_clone(a1);
}

//----- (0000000000011570) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _JNIEnv::CallIntMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN7_JNIEnv13CallIntMethodEP8_jobjectP10_jmethodIDz(a1, a2, a3);
}

//----- (0000000000011580) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__stream_decoder_get_decode_position(__int64 a1, _QWORD *a2)
{
  return FLAC__stream_decoder_get_decode_position(a1, a2);
}

//----- (0000000000011590) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_vorbiscomment_entry_name_is_legal(_BYTE *a1)
{
  return FLAC__format_vorbiscomment_entry_name_is_legal(a1);
}

//----- (00000000000115A0) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__metadata_chain_merge_padding(__int64 a1)
{
  FLAC__metadata_chain_merge_padding(a1);
}

//----- (00000000000115B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_process_single(_DWORD **a1)
{
  return FLAC__stream_decoder_process_single(a1);
}

//----- (00000000000115C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _JNIEnv::NewObject(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN7_JNIEnv9NewObjectEP7_jclassP10_jmethodIDz(a1, a2, a3);
}

//----- (00000000000115F0) ----------------------------------------------------
// attributes: thunk
void __cxa_end_catch(void)
{
  _cxa_end_catch();
}

//----- (0000000000011600) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall FLAC__bitwriter_write_raw_uint32_little_endian(_DWORD *result, unsigned int a2)
{
  return FLAC__bitwriter_write_raw_uint32_little_endian(result, a2);
}

//----- (0000000000011610) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__metadata_object_cuesheet_set_track(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  return FLAC__metadata_object_cuesheet_set_track(a1, a2, a3, a4);
}

//----- (0000000000011640) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__fixed_compute_residual(char *result, unsigned int a2, int a3, int32x4_t *a4)
{
  return FLAC__fixed_compute_residual(result, a2, a3, a4);
}

//----- (0000000000011670) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__memory_alloc_aligned_unsigned_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  return FLAC__memory_alloc_aligned_unsigned_array(a1, a2, a3);
}

//----- (0000000000011680) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__subframe_add_verbatim(__int64 *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  return FLAC__subframe_add_verbatim(a1, a2, a3, a4, a5);
}

//----- (0000000000011690) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_index(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5)
{
  return FLAC__metadata_object_cuesheet_track_insert_index(a1, a2, a3, a4, a5);
}

//----- (00000000000116A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::getSeekPositions(__int64 a1, __int64 a2, __int64 *a3)
{
  return _ZN10FLACParser16getSeekPositionsElRNSt6__ndk15arrayIlLm4EEE(a1, a2, a3);
}

//----- (00000000000116B0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__subframe_add_constant(unsigned int *a1, unsigned int a2, int a3, __int64 a4)
{
  return FLAC__subframe_add_constant(a1, a2, a3, a4);
}

//----- (00000000000116C0) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new(size_t a1)
{
  return _Znwm(a1);
}

//----- (00000000000116D0) ----------------------------------------------------
// attributes: thunk
int *__fastcall FLAC__fixed_restore_signal(int *result, int a2, int a3, int *a4)
{
  return FLAC__fixed_restore_signal(result, a2, a3, a4);
}

//----- (00000000000116E0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_zero_pad_to_byte_boundary(__int64 a1)
{
  return FLAC__bitwriter_zero_pad_to_byte_boundary(a1);
}

//----- (0000000000011700) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__bitreader_delete(void **a1)
{
  FLAC__bitreader_delete(a1);
}

//----- (0000000000011730) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _JNIEnv::CallBooleanMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN7_JNIEnv17CallBooleanMethodEP8_jobjectP10_jmethodIDz(a1, a2, a3);
}

//----- (0000000000011740) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_cuesheet_is_legal(__int64 a1, int a2, const char **a3)
{
  return FLAC__format_cuesheet_is_legal(a1, a2, a3);
}

//----- (0000000000011750) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_all(__int64 a1)
{
  return FLAC__stream_decoder_set_metadata_ignore_all(a1);
}

//----- (0000000000011760) ----------------------------------------------------
// attributes: thunk
void *__fastcall safe_malloc_mul_2op_p(unsigned __int64 a1, unsigned __int64 a2)
{
  return safe_malloc_mul_2op_p(a1, a2);
}

//----- (0000000000011780) ----------------------------------------------------
// attributes: thunk
__int64 operator delete[]()
{
  return _ZdaPvSt11align_val_t();
}
// 3483C: using guessed type __int64 operator delete[](void);

//----- (0000000000011790) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(__int64 a1)
{
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(a1);
}

//----- (00000000000117A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__crc16_update_words32(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  return FLAC__crc16_update_words32(a1, a2, a3);
}

//----- (00000000000117B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::reset(__int64 a1, __int64 a2)
{
  return _ZN10FLACParser5resetEl(a1, a2);
}

//----- (00000000000117C0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_get_buffer(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return FLAC__bitwriter_get_buffer(a1, a2, a3);
}

//----- (00000000000117F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_rice_signed_block(__int64 a1, unsigned int *a2, int a3, unsigned int a4)
{
  return FLAC__bitreader_read_rice_signed_block(a1, a2, a3, a4);
}

//----- (0000000000011800) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_call_unexpected(void *a1)
{
  _cxa_call_unexpected(a1);
}

//----- (0000000000011820) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_byte_block_aligned_no_crc(__int64 a1, _BYTE *a2, unsigned int a3)
{
  return FLAC__bitreader_read_byte_block_aligned_no_crc(a1, a2, a3);
}

//----- (0000000000011860) ----------------------------------------------------
// attributes: thunk
void __fastcall FLACParser::~FLACParser(_QWORD *a1)
{
  _ZN10FLACParserD2Ev(a1);
}

//----- (0000000000011870) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_set_md5_checking(_QWORD *a1, int a2)
{
  return FLAC__stream_decoder_set_md5_checking(a1, a2);
}

//----- (0000000000011880) ----------------------------------------------------
// attributes: thunk
__int64 FLAC__bitwriter_release_buffer()
{
  return FLAC__bitwriter_release_buffer();
}
// 16090: using guessed type __int64 FLAC__bitwriter_release_buffer(void);

//----- (00000000000118A0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__subframe_add_fixed(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  return FLAC__subframe_add_fixed(a1, a2, a3, a4, a5);
}

//----- (00000000000118B0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_utf8_uint32(__int64 a1, unsigned int a2)
{
  return FLAC__bitwriter_write_utf8_uint32(a1, a2);
}

//----- (00000000000118C0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_get_write_crc16(__int64 a1, _WORD *a2)
{
  return FLAC__bitwriter_get_write_crc16(a1, a2);
}

//----- (00000000000118D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::readBuffer(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  return _ZN10FLACParser10readBufferEPvm(a1, a2, a3);
}

//----- (00000000000118E0) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__metadata_object_delete_data(__int64 a1)
{
  FLAC__metadata_object_delete_data(a1);
}

//----- (0000000000011920) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_get_write_crc8(__int64 a1, _BYTE *a2)
{
  return FLAC__bitwriter_get_write_crc8(a1, a2);
}

//----- (0000000000011930) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  return _ZnwmSt11align_val_t(a1, a2);
}

//----- (0000000000011950) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__metadata_object_cuesheet_track_resize_indices(__int64 a1, unsigned int a2, unsigned int a3)
{
  return FLAC__metadata_object_cuesheet_track_resize_indices(a1, a2, a3);
}

//----- (0000000000011960) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__stream_decoder_delete(void **a1)
{
  FLAC__stream_decoder_delete(a1);
}

//----- (0000000000011970) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_utf8_uint32(__int64 a1, int *a2, __int64 a3, _DWORD *a4)
{
  return FLAC__bitreader_read_utf8_uint32(a1, a2, a3, a4);
}

//----- (0000000000011980) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned int a1)
{
  return FLAC__format_get_max_rice_partition_order_from_blocksize(a1);
}

//----- (0000000000011990) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__metadata_object_cuesheet_resize_tracks(__int64 a1, unsigned int a2)
{
  return FLAC__metadata_object_cuesheet_resize_tracks(a1, a2);
}

//----- (00000000000119A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_all(__int64 a1)
{
  return FLAC__stream_decoder_set_metadata_respond_all(a1);
}

//----- (00000000000119C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::init(__int64 a1)
{
  return _ZN10FLACParser4initEv(a1);
}

//----- (00000000000119D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__metadata_simple_iterator_next(__int64 a1)
{
  return FLAC__metadata_simple_iterator_next(a1);
}

//----- (00000000000119E0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_raw_uint64(__int64 a1, __int64 a2, unsigned int a3)
{
  return FLAC__bitwriter_write_raw_uint64(a1, a2, a3);
}

//----- (0000000000011A00) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *a1)
{
  _ZNSt9exceptionD2Ev(a1);
}
// 36204: using guessed type void std::exception::~exception(std::exception *__hidden this);

//----- (0000000000011A10) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__bitwriter_delete(void **a1)
{
  FLAC__bitwriter_delete(a1);
}

//----- (0000000000011A20) ----------------------------------------------------
// attributes: thunk
void __fastcall std::type_info::~type_info(std::type_info *a1)
{
  _ZNSt9type_infoD2Ev(a1);
}
// 3484C: using guessed type void std::type_info::~type_info(std::type_info *__hidden this);

//----- (0000000000011A30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::FLACParser(__int64 a1, __int64 a2)
{
  return _ZN10FLACParserC2EP10DataSource(a1, a2);
}

//----- (0000000000011A40) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_new_handler()
{
  return _ZSt15get_new_handlerv();
}

//----- (0000000000011A70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__metadata_simple_iterator_prev(__int64 a1)
{
  return FLAC__metadata_simple_iterator_prev(a1);
}

//----- (0000000000011A80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_raw_int32(__int64 a1, _DWORD *a2, unsigned int a3)
{
  return FLAC__bitreader_read_raw_int32(a1, a2, a3);
}

//----- (0000000000011A90) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__metadata_object_vorbiscomment_resize_comments(__int64 a1, unsigned int a2)
{
  return FLAC__metadata_object_vorbiscomment_resize_comments(a1, a2);
}

//----- (0000000000011AA0) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__bitwriter_init(__int64 a1)
{
  return FLAC__bitwriter_init(a1);
}

//----- (0000000000011AD0) ----------------------------------------------------
// attributes: thunk
__int64 **__fastcall FLAC__stream_encoder_finish(__int64 **result)
{
  return FLAC__stream_encoder_finish(result);
}

//----- (0000000000011AE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_init(__int64 result)
{
  return FLAC__format_entropy_coding_method_partitioned_rice_contents_init(result);
}

//----- (0000000000011AF0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_utf8_uint64(__int64 a1, unsigned __int64 a2)
{
  return FLAC__bitwriter_write_utf8_uint64(a1, a2);
}

//----- (0000000000011B20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_vorbiscomment_entry_value_is_legal(unsigned __int8 *a1, int a2)
{
  return FLAC__format_vorbiscomment_entry_value_is_legal(a1, a2);
}

//----- (0000000000011B30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLACParser::decodeMetadata(__int64 a1)
{
  return _ZN10FLACParser14decodeMetadataEv(a1);
}

//----- (0000000000011B40) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__stream_decoder_finish(__int64 a1)
{
  return FLAC__stream_decoder_finish(a1);
}

//----- (0000000000011B50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_unary_unsigned(__int64 a1, _DWORD *a2)
{
  return FLAC__bitreader_read_unary_unsigned(a1, a2);
}

//----- (0000000000011B60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_skip_bits_no_crc(__int64 a1, unsigned int a2)
{
  return FLAC__bitreader_skip_bits_no_crc(a1, a2);
}

//----- (0000000000011B70) ----------------------------------------------------
// attributes: thunk
void *FLAC__bitreader_new()
{
  return FLAC__bitreader_new();
}

//----- (0000000000011B90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_blocksize_is_subset(unsigned int a1, unsigned int a2)
{
  return FLAC__format_blocksize_is_subset(a1, a2);
}

//----- (0000000000011BA0) ----------------------------------------------------
// attributes: thunk
void *__fastcall __cxa_get_globals()
{
  return _cxa_get_globals();
}

//----- (0000000000011BC0) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__format_sample_rate_is_valid(int a1)
{
  return FLAC__format_sample_rate_is_valid(a1);
}

//----- (0000000000011BE0) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_comment(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned __int8 *a4,
        int a5)
{
  return FLAC__metadata_object_vorbiscomment_set_comment(a1, a2, a3, a4, a5);
}

//----- (0000000000011BF0) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall FLAC__bitwriter_write_raw_int32(__int64 a1, unsigned int a2, unsigned int a3)
{
  return FLAC__bitwriter_write_raw_int32(a1, a2, a3);
}

//----- (0000000000011C00) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *p)
{
  _ZdlPvSt11align_val_t(p);
}

//----- (0000000000011C10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_bits_left_for_byte_alignment(__int64 a1)
{
  return FLAC__bitreader_bits_left_for_byte_alignment(a1);
}

//----- (0000000000011C30) ----------------------------------------------------
// attributes: thunk
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  return _cxa_demangle(lpmangled, lpout, lpoutlen, lpstatus);
}

//----- (0000000000011C60) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__metadata_simple_iterator_init(__int64 a1, const char *a2, int a3, int a4)
{
  return FLAC__metadata_simple_iterator_init(a1, a2, a3, a4);
}

//----- (0000000000011C70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_init_file(
        int **a1,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return FLAC__stream_decoder_init_file(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000011C80) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__add_metadata_block(__int64 a1, _DWORD *a2)
{
  return FLAC__add_metadata_block(a1, a2);
}

//----- (0000000000011C90) ----------------------------------------------------
// attributes: thunk
__int64 operator delete[]()
{
  return _ZdaPv();
}
// 34710: using guessed type __int64 operator delete[](void);

//----- (0000000000011CA0) ----------------------------------------------------
// attributes: thunk
void *FLAC__bitwriter_new()
{
  return FLAC__bitwriter_new();
}

//----- (0000000000011CB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_utf8_uint64(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4)
{
  return FLAC__bitreader_read_utf8_uint64(a1, a2, a3, a4);
}

//----- (0000000000011CC0) ----------------------------------------------------
// attributes: thunk
void *__cxa_allocate_exception(size_t thrown_size)
{
  return _cxa_allocate_exception(thrown_size);
}

//----- (0000000000011CD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_reset(int **a1)
{
  return FLAC__stream_decoder_reset(a1);
}

//----- (0000000000011CF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(
        int a1,
        unsigned int a2,
        unsigned int a3)
{
  return FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(a1, a2, a3);
}

//----- (0000000000011D10) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_raw_uint32(__int64 a1, unsigned int a2, unsigned int a3)
{
  return FLAC__bitwriter_write_raw_uint32(a1, a2, a3);
}

//----- (0000000000011D30) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *p)
{
  _ZdlPv(p);
}

//----- (0000000000011D40) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__bitreader_is_consumed_byte_aligned(__int64 a1)
{
  return FLAC__bitreader_is_consumed_byte_aligned(a1);
}

//----- (0000000000011D60) ----------------------------------------------------
// attributes: thunk
void __noreturn std::terminate(void)
{
  _ZSt9terminatev();
}

//----- (0000000000011D70) ----------------------------------------------------
// attributes: thunk
__int64 operator new[]()
{
  return _Znam();
}
// 346CC: using guessed type __int64 operator new[](void);

//----- (0000000000011D80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_vorbiscomment_entry_is_legal(unsigned __int8 *a1, int a2)
{
  return FLAC__format_vorbiscomment_entry_is_legal(a1, a2);
}

//----- (0000000000011D90) ----------------------------------------------------
// attributes: thunk
long double __fastcall FLAC__cpu_info(__int64 a1)
{
  return FLAC__cpu_info(a1);
}

//----- (0000000000011DA0) ----------------------------------------------------
// attributes: thunk
char *__fastcall FlacPicture::FlacPicture(char *result, __int64 a2)
{
  return _ZN11FlacPictureC2ERKS_(result, a2);
}

//----- (0000000000011DB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_raw_uint32(__int64 a1, _DWORD *a2, unsigned int a3)
{
  return FLAC__bitreader_read_raw_uint32(a1, a2, a3);
}

//----- (0000000000011DD0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_unary_unsigned(__int64 a1, unsigned int a2)
{
  return FLAC__bitwriter_write_unary_unsigned(a1, a2);
}

//----- (0000000000011DE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_picture_is_legal(__int64 a1, _QWORD *a2)
{
  return FLAC__format_picture_is_legal(a1, a2);
}

//----- (0000000000011E00) ----------------------------------------------------
// attributes: thunk
void *__cxa_begin_catch(void *a1)
{
  return _cxa_begin_catch(a1);
}

//----- (0000000000011E10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_sample_rate_is_subset(unsigned int a1)
{
  return FLAC__format_sample_rate_is_subset(a1);
}

//----- (0000000000011E20) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_byte_block(__int64 a1, __int64 a2, unsigned int a3)
{
  return FLAC__bitwriter_write_byte_block(a1, a2, a3);
}

//----- (0000000000011E30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_seektable_sort(void **a1)
{
  return FLAC__format_seektable_sort(a1);
}

//----- (0000000000011E40) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *result)
{
  return _ZNSt9bad_allocC2Ev(result);
}

//----- (0000000000011E60) ----------------------------------------------------
// attributes: thunk
void *__dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  return _dynamic_cast(lpsrc, lpstype, lpdtype, s2d);
}

//----- (0000000000011E70) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__bitwriter_free(__int64 a1)
{
  FLAC__bitwriter_free(a1);
}

//----- (0000000000011E80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_read_uint32_little_endian(__int64 a1, int *a2)
{
  return FLAC__bitreader_read_uint32_little_endian(a1, a2);
}

//----- (0000000000011EA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_skip_byte_block_aligned_no_crc(__int64 a1, unsigned int a2)
{
  return FLAC__bitreader_skip_byte_block_aligned_no_crc(a1, a2);
}

//----- (0000000000011EC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(
        __int64 a1,
        unsigned int a2)
{
  return FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(a1, a2);
}

//----- (0000000000011EE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_init_ogg_stream(_DWORD **a1)
{
  return FLAC__stream_decoder_init_ogg_stream(a1);
}

//----- (0000000000011EF0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *a1)
{
  _ZNSt9exceptionD2Ev(a1);
}
// 11EF0: using guessed type void __fastcall std::exception::~exception(std::exception *a1);
// 36204: using guessed type void std::exception::~exception(std::exception *__hidden this);

//----- (0000000000011F20) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_rethrow(void)
{
  _cxa_rethrow();
}

//----- (0000000000011F30) ----------------------------------------------------
// attributes: thunk
void __fastcall FLACParser::metadataCallback(__int64 a1, __int64 a2)
{
  _ZN10FLACParser16metadataCallbackEPK20FLAC__StreamMetadata(a1, a2);
}

//----- (0000000000011F40) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitreader_init(__int64 a1, __int64 a2, __int64 a3)
{
  return FLAC__bitreader_init(a1, a2, a3);
}

//----- (0000000000011F50) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_rice_signed_block(__int64 a1, int *a2, int a3, int a4)
{
  return FLAC__bitwriter_write_rice_signed_block(a1, a2, a3, a4);
}

//----- (0000000000011F60) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__metadata_object_new(unsigned int a1)
{
  return FLAC__metadata_object_new(a1);
}

//----- (0000000000011F70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__fixedpoint_log2(unsigned int a1, unsigned int a2, unsigned int a3)
{
  return FLAC__fixedpoint_log2(a1, a2, a3);
}

//----- (0000000000011F80) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__metadata_chain_check_if_tempfile_needed(_QWORD *a1, int a2)
{
  return FLAC__metadata_chain_check_if_tempfile_needed(a1, a2);
}

//----- (0000000000011FA0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__memory_alloc_aligned_uint64_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  return FLAC__memory_alloc_aligned_uint64_array(a1, a2, a3);
}

//----- (0000000000011FC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_get_input_bits_unconsumed(_DWORD *a1)
{
  return FLAC__bitreader_get_input_bits_unconsumed(a1);
}

//----- (0000000000011FE0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__metadata_simple_iterator_get_block(__int64 a1)
{
  return FLAC__metadata_simple_iterator_get_block(a1);
}

//----- (0000000000011FF0) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__frame_add_header(__int64 a1, __int64 a2)
{
  return FLAC__frame_add_header(a1, a2);
}

//----- (0000000000012000) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__bitwriter_write_zeroes(__int64 a1, unsigned int a2)
{
  return FLAC__bitwriter_write_zeroes(a1, a2);
}

//----- (0000000000012010) ----------------------------------------------------
// attributes: thunk
bool __fastcall FLAC__stream_decoder_flush(__int64 a1)
{
  return FLAC__stream_decoder_flush(a1);
}

//----- (0000000000012040) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__bitreader_free(__int64 a1)
{
  FLAC__bitreader_free(a1);
}

//----- (0000000000012050) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_terminate()
{
  return _ZSt13get_terminatev();
}

//----- (0000000000012060) ----------------------------------------------------
// attributes: thunk
char *__fastcall FLAC__stream_decoder_get_resolved_state_string(unsigned int **a1)
{
  return FLAC__stream_decoder_get_resolved_state_string(a1);
}

//----- (0000000000012070) ----------------------------------------------------
// attributes: thunk
void __fastcall std::vector<FlacPicture>::__push_back_slow_path<FlacPicture const&>(char **a1, __int64 a2)
{
  _ZNSt6__ndk16vectorI11FlacPictureNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_(a1, a2);
}

//----- (0000000000012080) ----------------------------------------------------
// attributes: thunk
long double __fastcall FLAC__MD5Init(__int64 a1)
{
  return FLAC__MD5Init(a1);
}

//----- (00000000000120B0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_unexpected()
{
  return _ZSt14get_unexpectedv();
}

//----- (00000000000120C0) ----------------------------------------------------
// attributes: thunk
signed __int64 __fastcall std::vector<std::string>::vector(signed __int64 *a1, __int64 *a2)
{
  return _ZNSt6__ndk16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEEC2ERKS8_(a1, a2);
}

//----- (00000000000120D0) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall FLAC__MD5Accumulate(__int64 a1, int32x4_t **a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  return FLAC__MD5Accumulate(a1, a2, a3, a4, a5);
}

//----- (00000000000120F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_metadata(_DWORD **a1)
{
  return FLAC__stream_decoder_process_until_end_of_metadata(a1);
}

//----- (0000000000012100) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_clear(__int64 a1)
{
  return FLAC__bitreader_clear(a1);
}

//----- (0000000000012110) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_reset_read_crc16(__int64 result, unsigned __int16 a2)
{
  return FLAC__bitreader_reset_read_crc16(result, a2);
}

//----- (0000000000012120) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__memory_alloc_aligned_int32_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  return FLAC__memory_alloc_aligned_int32_array(a1, a2, a3);
}

//----- (0000000000012130) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall FLAC__bitreader_get_read_crc16(__int64 *a1)
{
  return FLAC__bitreader_get_read_crc16(a1);
}

//----- (0000000000012140) ----------------------------------------------------
// attributes: thunk
void __fastcall FLAC__metadata_object_delete(void *a1)
{
  FLAC__metadata_object_delete(a1);
}

//----- (0000000000012180) ----------------------------------------------------
// attributes: thunk
void *__fastcall FLAC__MD5Final(_OWORD *a1, __int64 a2)
{
  return FLAC__MD5Final(a1, a2);
}

//----- (0000000000012190) ----------------------------------------------------
__int64 start()
{
  return __cxa_finalize(&off_80000);
}
// 80000: using guessed type _UNKNOWN *off_80000;

//----- (000000000001219C) ----------------------------------------------------
__int64 (*__fastcall sub_1219C(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (00000000000121B4) ----------------------------------------------------
__int64 __fastcall sub_121B4(void *a1)
{
  return __cxa_atexit((void (*)(void *))sub_1219C, a1, &off_80000);
}
// 80000: using guessed type _UNKNOWN *off_80000;

//----- (00000000000121CC) ----------------------------------------------------
_QWORD *Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacInit()
{
  _QWORD *v0; // x19
  _QWORD *v1; // x21
  _QWORD *v2; // x20

  v0 = operator new(0x10u);
  v1 = operator new(0x20u);
  v1[2] = 0;
  v1[3] = 0;
  *v0 = v1;
  *v1 = off_7DFA0;
  v1[1] = 0;
  v2 = operator new(0xF0u);
  FLACParser::FLACParser((__int64)v2, (__int64)v1);
  v0[1] = v2;
  if ( (FLACParser::init((__int64)v2) & 1) == 0 )
  {
    FLACParser::~FLACParser(v2);
    operator delete(v2);
    if ( *v0 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v0 + 8LL))(*v0);
    operator delete(v0);
    return 0;
  }
  return v0;
}
// 7DFA0: using guessed type void (__fastcall *[2])(DataSource *__hidden this);

//----- (0000000000012274) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeMetadata(
        __int64 a1,
        __int64 a2,
        __int64 *a3)
{
  _QWORD *v5; // x20
  __int64 v6; // x8
  __int64 v7; // x23
  __int64 v8; // x24
  __int64 v9; // x21
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 v12; // x22
  signed __int64 v13; // x20
  signed __int64 v14; // x1
  __int64 v15; // x25
  signed __int64 v16; // x21
  signed __int64 v17; // x25
  char v18; // t1
  void *v19; // x0
  __int64 v20; // x0
  __int64 v22; // x0
  __int64 v23; // x20
  __int64 v24; // x8
  __int64 v25; // x9
  signed __int64 v26; // x0
  char *v27; // x0
  __int64 v28; // x20
  __int64 v29; // x25
  char *v30; // x24
  char *v31; // x26
  char *v32; // x23
  __int64 v33; // x26
  __int64 v34; // x27
  char *v35; // x25
  char *v36; // x1
  __int64 v37; // x28
  char *v38; // x1
  __int64 v39; // x20
  __int64 v40; // x21
  void *v41; // x0
  char *v42; // x20
  __int64 v43; // x20
  __int64 v44; // x0
  __int64 v45; // [xsp+48h] [xbp-78h]
  void *v46; // [xsp+50h] [xbp-70h] BYREF
  signed __int64 v47; // [xsp+58h] [xbp-68h]
  __int64 v48; // [xsp+68h] [xbp-58h]

  v48 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v5 = (_QWORD *)*a3;
  v6 = *(_QWORD *)(*a3 + 24);
  v5[1] = a1;
  v5[2] = a2;
  if ( v6 )
  {
    if ( (FLACParser::decodeMetadata(a3[1]) & 1) != 0 )
      goto LABEL_3;
    return 0;
  }
  v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v5[3] = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
            a1,
            v20,
            "read",
            "(Ljava/nio/ByteBuffer;)I");
  if ( (FLACParser::decodeMetadata(a3[1]) & 1) == 0 )
    return 0;
LABEL_3:
  v7 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/util/ArrayList");
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
         a1,
         v7,
         "<init>",
         "()V");
  v9 = _JNIEnv::NewObject(a1, v7, v8);
  v10 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v7,
          "add",
          "(Ljava/lang/Object;)Z");
  v11 = a3[1];
  v12 = v10;
  if ( *(_BYTE *)(v11 + 144) )
  {
    std::vector<std::string>::vector((signed __int64 *)&v46, (__int64 *)(v11 + 120));
    v13 = (signed __int64)v46;
    if ( v46 == (void *)v47 )
    {
      v16 = (signed __int64)v46;
      if ( v46 )
      {
LABEL_10:
        if ( v13 == v16 )
        {
          v19 = (void *)v16;
        }
        else
        {
          v17 = v13;
          do
          {
            v18 = *(_BYTE *)(v17 - 24);
            v17 -= 24LL;
            if ( (v18 & 1) != 0 )
              operator delete(*(void **)(v13 - 8));
            v13 = v17;
          }
          while ( v16 != v17 );
          v19 = v46;
        }
        v47 = v16;
        operator delete(v19);
      }
    }
    else
    {
      do
      {
        if ( (*(_BYTE *)v13 & 1) != 0 )
          v14 = *(_QWORD *)(v13 + 16);
        else
          v14 = v13 + 1;
        v15 = (*(__int64 (__fastcall **)(__int64, signed __int64))(*(_QWORD *)a1 + 1336LL))(a1, v14);
        _JNIEnv::CallBooleanMethod(a1, v9, v12);
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v15);
        v13 += 24LL;
      }
      while ( v13 != v47 );
      v16 = (signed __int64)v46;
      if ( v46 )
        goto LABEL_10;
    }
  }
  v22 = _JNIEnv::NewObject(a1, v7, v8);
  v23 = a3[1];
  v45 = v22;
  if ( *(_BYTE *)(v23 + 176) )
  {
    v24 = *(_QWORD *)(v23 + 152);
    v25 = *(_QWORD *)(v23 + 160);
    v26 = v25 - v24;
    if ( v25 == v24 )
    {
      v30 = 0;
      v32 = 0;
    }
    else
    {
      if ( 0xAAAAAAAAAAAAAAABLL * (v26 >> 5) >= 0x2AAAAAAAAAAAAABLL )
        abort();
      v27 = (char *)operator new(v26);
      v29 = *(_QWORD *)(v23 + 152);
      v28 = *(_QWORD *)(v23 + 160);
      v30 = v27;
      if ( v29 == v28 )
      {
        v32 = v27;
      }
      else
      {
        v31 = v27;
        do
        {
          FlacPicture::FlacPicture(v31, v29);
          v29 += 96;
          v31 += 96;
        }
        while ( v28 != v29 );
        v32 = v30;
        v30 = v31;
      }
    }
    v33 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
            a1,
            "com/google/android/exoplayer2/metadata/flac/PictureFrame");
    v34 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
            a1,
            v33,
            "<init>",
            "(ILjava/lang/String;Ljava/lang/String;IIII[B)V");
    if ( v32 != v30 )
    {
      v35 = v32;
      do
      {
        if ( (v35[8] & 1) != 0 )
          v36 = (char *)*((_QWORD *)v35 + 3);
        else
          v36 = v35 + 9;
        v37 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v36);
        if ( (v35[32] & 1) != 0 )
          v38 = (char *)*((_QWORD *)v35 + 6);
        else
          v38 = v35 + 33;
        v39 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v38);
        v40 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(
                a1,
                (unsigned int)(*((_DWORD *)v35 + 20) - *((_DWORD *)v35 + 18)));
        (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 1664LL))(
          a1,
          v40,
          0,
          *((_DWORD *)v35 + 20) - (unsigned int)*((_QWORD *)v35 + 9));
        _JNIEnv::NewObject(a1, v33, v34);
        _JNIEnv::CallBooleanMethod(a1, v45, v12);
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v37);
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v39);
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v40);
        v35 += 96;
      }
      while ( v30 != v35 );
    }
    if ( v32 )
    {
      if ( v32 != v30 )
      {
        do
        {
          while ( 1 )
          {
            v41 = (void *)*((_QWORD *)v30 - 3);
            if ( v41 )
            {
              *((_QWORD *)v30 - 2) = v41;
              operator delete(v41);
            }
            if ( (*(v30 - 64) & 1) == 0 )
              break;
            operator delete(*((void **)v30 - 6));
            v42 = v30 - 96;
            if ( (*(v30 - 88) & 1) == 0 )
              goto LABEL_46;
LABEL_49:
            operator delete(*((void **)v30 - 9));
            v30 = v42;
            if ( v32 == v42 )
              goto LABEL_50;
          }
          v42 = v30 - 96;
          if ( (*(v30 - 88) & 1) != 0 )
            goto LABEL_49;
LABEL_46:
          v30 = v42;
        }
        while ( v32 != v42 );
      }
LABEL_50:
      operator delete(v32);
    }
  }
  v43 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
          a1,
          "com/google/android/exoplayer2/util/FlacStreamMetadata");
  v44 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v43,
          "<init>",
          "(IIIIIIIJLjava/util/ArrayList;Ljava/util/ArrayList;)V");
  return _JNIEnv::NewObject(a1, v43, v44);
}

//----- (00000000000127C4) ----------------------------------------------------
__int64 _JNIEnv::NewObject(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __va_list_tag *); // x8
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(TPIDR_EL0);
  v3 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __va_list_tag *))(*(_QWORD *)a1 + 232LL);
  va_copy(va1, va);
  return v3(a1, a2, a3, va1);
}

//----- (0000000000012864) ----------------------------------------------------
signed __int64 __fastcall std::vector<std::string>::vector(signed __int64 *a1, __int64 *a2)
{
  __int64 v4; // x9
  signed __int64 result; // x0
  unsigned __int64 v6; // x22
  _QWORD *v7; // x20
  __int64 v8; // x24
  __int64 v9; // x25
  size_t v10; // x21
  const void *v11; // x22
  void *v12; // x20
  void *v13; // x0

  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  v4 = a2[1];
  result = v4 - *a2;
  if ( v4 != *a2 )
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * (result >> 3);
    if ( v6 >= 0xAAAAAAAAAAAAAABLL )
LABEL_15:
      abort();
    result = (signed __int64)operator new(result);
    v7 = (_QWORD *)result;
    *a1 = result;
    a1[1] = result;
    a1[2] = result + 24 * v6;
    v8 = *a2;
    v9 = a2[1];
    if ( *a2 != v9 )
    {
      while ( 1 )
      {
        v7[1] = 0;
        v7[2] = 0;
        *v7 = 0;
        if ( (*(_BYTE *)v8 & 1) != 0 )
          break;
        v7[2] = *(_QWORD *)(v8 + 16);
        *(_OWORD *)v7 = *(_OWORD *)v8;
LABEL_13:
        v8 += 24;
        v7 = (_QWORD *)(a1[1] + 24);
        a1[1] = (signed __int64)v7;
        if ( v9 == v8 )
          return result;
      }
      v10 = *(_QWORD *)(v8 + 8);
      if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_15;
      v11 = *(const void **)(v8 + 16);
      if ( v10 >= 0x17 )
      {
        v13 = operator new((v10 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v7[1] = v10;
        v7[2] = v13;
        *v7 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v12 = v13;
      }
      else
      {
        *(_BYTE *)v7 = 2 * v10;
        v12 = (char *)v7 + 1;
        if ( !v10 )
          goto LABEL_12;
      }
      result = (signed __int64)memcpy(v12, v11, v10);
LABEL_12:
      *((_BYTE *)v12 + v10) = 0;
      goto LABEL_13;
    }
  }
  return result;
}

//----- (0000000000012994) ----------------------------------------------------
__int64 _JNIEnv::CallBooleanMethod(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __va_list_tag *); // x8
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(TPIDR_EL0);
  v3 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __va_list_tag *))(*(_QWORD *)a1 + 304LL);
  va_copy(va1, va);
  return v3(a1, a2, a3, va1);
}

//----- (0000000000012A34) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeToBuffer(
        __int64 a1,
        __int64 a2,
        __int64 *a3,
        __int64 a4)
{
  _QWORD *v5; // x22
  __int64 v8; // x8
  __int64 v9; // x0
  __int64 v10; // x22
  int v11; // w0

  v5 = (_QWORD *)*a3;
  v8 = *(_QWORD *)(*a3 + 24);
  v5[1] = a1;
  v5[2] = a2;
  if ( !v8 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
    v5[3] = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
              a1,
              v9,
              "read",
              "(Ljava/nio/ByteBuffer;)I");
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1840LL))(a1, a4);
  v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1848LL))(a1, a4);
  return FLACParser::readBuffer(a3[1], v10, v11);
}

//----- (0000000000012AE8) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacDecodeToArray(
        __int64 a1,
        __int64 a2,
        __int64 *a3,
        __int64 a4)
{
  _QWORD *v5; // x22
  __int64 v8; // x8
  __int64 v9; // x0
  __int64 v10; // x22
  int v11; // w0
  unsigned int Buffer; // w21

  v5 = (_QWORD *)*a3;
  v8 = *(_QWORD *)(*a3 + 24);
  v5[1] = a1;
  v5[2] = a2;
  if ( !v8 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
    v5[3] = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
              a1,
              v9,
              "read",
              "(Ljava/nio/ByteBuffer;)I");
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, a4, 0);
  v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a4);
  Buffer = FLACParser::readBuffer(a3[1], v10, v11);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a4, v10, 0);
  return Buffer;
}

//----- (0000000000012BC4) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetDecodePosition(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  __int64 v3; // x0
  _QWORD v5[2]; // [xsp+0h] [xbp-20h] BYREF

  v5[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v3 = *(_QWORD *)(*(_QWORD *)(a3 + 8) + 16LL);
  if ( !v3 )
    return -1;
  if ( FLAC__stream_decoder_get_decode_position(v3, v5) )
    return v5[0];
  return -1;
}

//----- (0000000000012C38) ----------------------------------------------------
unsigned __int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetLastFrameTimestamp(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  return 1000000LL
       * *(_QWORD *)(*(_QWORD *)(a3 + 8) + 208LL)
       / (unsigned __int64)*(unsigned int *)(*(_QWORD *)(a3 + 8) + 56LL);
}

//----- (0000000000012C58) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetLastFrameFirstSampleIndex(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  return *(_QWORD *)(*(_QWORD *)(a3 + 8) + 208LL);
}

//----- (0000000000012C64) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetNextFrameFirstSampleIndex(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  return *(_QWORD *)(*(_QWORD *)(a3 + 8) + 208LL) + *(unsigned int *)(*(_QWORD *)(a3 + 8) + 184LL);
}

//----- (0000000000012C78) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetSeekPoints(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5)
{
  char SeekPositions; // w20
  __int64 v9[5]; // [xsp+8h] [xbp-48h] BYREF

  v9[4] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  SeekPositions = FLACParser::getSeekPositions(*(_QWORD *)(a3 + 8), a4, v9);
  if ( (SeekPositions & 1) != 0 )
    (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64, __int64 *))(*(_QWORD *)a1 + 1696LL))(a1, a5, 0, 4, v9);
  return SeekPositions & 1;
}

//----- (0000000000012D08) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacGetStateString(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  char *resolved_state_string; // x1

  resolved_state_string = FLAC__stream_decoder_get_resolved_state_string(*(unsigned int ***)(*(_QWORD *)(a3 + 8) + 16LL));
  return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, resolved_state_string);
}

//----- (0000000000012D44) ----------------------------------------------------
bool __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacIsDecoderAtEndOfStream(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  return (unsigned int)FLAC__stream_decoder_get_state(*(unsigned int ***)(*(_QWORD *)(a3 + 8) + 16LL)) == 4;
}

//----- (0000000000012D68) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacFlush(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  return FLACParser::reset(*(_QWORD *)(a3 + 8), *(_QWORD *)(*(_QWORD *)(a3 + 8) + 24LL));
}

//----- (0000000000012D74) ----------------------------------------------------
__int64 __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacReset(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return FLACParser::reset(*(_QWORD *)(a3 + 8), a4);
}

//----- (0000000000012D80) ----------------------------------------------------
__int64 __fastcall FLACParser::reset(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v4; // x8
  __int64 v5; // x22
  __int64 v6; // x20
  char v7; // t1
  __int64 v8; // x20
  __int64 v9; // x21
  void *v10; // x0
  __int64 v11; // x22

  result = *(_QWORD *)(a1 + 16);
  if ( result )
  {
    *(_QWORD *)(a1 + 24) = a2;
    *(_BYTE *)(a1 + 32) = 0;
    if ( a2 )
      return FLAC__stream_decoder_flush(result);
    v5 = *(_QWORD *)(a1 + 120);
    v4 = *(_QWORD *)(a1 + 128);
    *(_BYTE *)(a1 + 96) = 0;
    *(_BYTE *)(a1 + 144) = 0;
    *(_BYTE *)(a1 + 176) = 0;
    if ( v4 != v5 )
    {
      v6 = v4;
      do
      {
        v7 = *(_BYTE *)(v6 - 24);
        v6 -= 24;
        if ( (v7 & 1) != 0 )
          operator delete(*(void **)(v4 - 8));
        v4 = v6;
      }
      while ( v5 != v6 );
    }
    v8 = *(_QWORD *)(a1 + 152);
    v9 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(a1 + 128) = v5;
    if ( v9 != v8 )
    {
      do
      {
        while ( 1 )
        {
          v10 = *(void **)(v9 - 24);
          if ( v10 )
          {
            *(_QWORD *)(v9 - 16) = v10;
            operator delete(v10);
          }
          if ( (*(_BYTE *)(v9 - 64) & 1) == 0 )
            break;
          operator delete(*(void **)(v9 - 48));
          v11 = v9 - 96;
          if ( (*(_BYTE *)(v9 - 88) & 1) == 0 )
            goto LABEL_15;
LABEL_18:
          operator delete(*(void **)(v9 - 72));
          v9 = v11;
          if ( v8 == v11 )
            goto LABEL_19;
        }
        v11 = v9 - 96;
        if ( (*(_BYTE *)(v9 - 88) & 1) != 0 )
          goto LABEL_18;
LABEL_15:
        v9 = v11;
      }
      while ( v8 != v11 );
    }
LABEL_19:
    *(_QWORD *)(a1 + 160) = v8;
    return FLAC__stream_decoder_reset(*(int ***)(a1 + 16));
  }
  return result;
}

//----- (0000000000012E84) ----------------------------------------------------
void __fastcall Java_com_google_android_exoplayer2_ext_flac_FlacDecoderJni_flacRelease(
        __int64 a1,
        __int64 a2,
        _QWORD *a3)
{
  void *v4; // x20

  if ( a3 )
  {
    v4 = (void *)a3[1];
    if ( v4 )
    {
      FLACParser::~FLACParser((_QWORD *)a3[1]);
      operator delete(v4);
    }
    if ( *a3 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a3 + 8LL))(*a3);
    operator delete(a3);
  }
}

//----- (0000000000012EE8) ----------------------------------------------------
__int64 __fastcall JavaDataSource::readAt(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v5; // w0
  _QWORD *v6; // x8
  int v7; // w19

  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1[1] + 1832LL))(a1[1], a3, a4);
  v5 = _JNIEnv::CallIntMethod(a1[1], a1[2], a1[3]);
  v6 = (_QWORD *)a1[1];
  v7 = v5;
  if ( (unsigned __int8)(*(_QWORD *(__fastcall **)(_QWORD *__return_ptr, _QWORD *))(*v6 + 1824LL))(v6, v6) )
    return -1;
  else
    return v7;
}

//----- (0000000000012F54) ----------------------------------------------------
__int64 _JNIEnv::CallIntMethod(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __va_list_tag *); // x8
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(TPIDR_EL0);
  v3 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __va_list_tag *))(*(_QWORD *)a1 + 400LL);
  va_copy(va1, va);
  return v3(a1, a2, a3, va1);
}

//----- (0000000000012FF4) ----------------------------------------------------
char *__fastcall FlacPicture::FlacPicture(char *result, __int64 a2)
{
  char *v3; // x19
  _OWORD *v4; // x21
  size_t v5; // x22
  const void *v6; // x23
  void *v7; // x21
  _OWORD *v8; // x21
  size_t v9; // x22
  const void *v10; // x23
  void *v11; // x21
  __int128 v12; // q0
  __int64 v13; // x8
  __int64 v14; // x9
  __int64 v15; // x22
  char *v16; // x21
  const void *v17; // x1
  __int64 v18; // x8
  __int64 v19; // x20

  v3 = result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *((_QWORD *)result + 1) = 0;
  v4 = result + 8;
  *((_QWORD *)result + 2) = 0;
  *((_QWORD *)result + 3) = 0;
  if ( (*(_BYTE *)(a2 + 8) & 1) == 0 )
  {
    *((_QWORD *)result + 3) = *(_QWORD *)(a2 + 24);
    *v4 = *(_OWORD *)(a2 + 8);
    goto LABEL_10;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_24;
  v6 = *(const void **)(a2 + 24);
  if ( v5 >= 0x17 )
  {
    v7 = operator new((v5 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *((_QWORD *)v3 + 2) = v5;
    *((_QWORD *)v3 + 3) = v7;
    *((_QWORD *)v3 + 1) = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    *(_BYTE *)v4 = 2 * v5;
    v7 = result + 9;
    if ( !v5 )
      goto LABEL_9;
  }
  result = (char *)memcpy(v7, v6, v5);
LABEL_9:
  *((_BYTE *)v7 + v5) = 0;
LABEL_10:
  *((_QWORD *)v3 + 4) = 0;
  v8 = v3 + 32;
  *((_QWORD *)v3 + 5) = 0;
  *((_QWORD *)v3 + 6) = 0;
  if ( (*(_BYTE *)(a2 + 32) & 1) == 0 )
  {
    *((_QWORD *)v3 + 6) = *(_QWORD *)(a2 + 48);
    *v8 = *(_OWORD *)(a2 + 32);
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a2 + 40);
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_24;
  v10 = *(const void **)(a2 + 48);
  if ( v9 >= 0x17 )
  {
    v11 = operator new((v9 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *((_QWORD *)v3 + 5) = v9;
    *((_QWORD *)v3 + 6) = v11;
    *((_QWORD *)v3 + 4) = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    *(_BYTE *)v8 = 2 * v9;
    v11 = v3 + 33;
    if ( !v9 )
      goto LABEL_18;
  }
  result = (char *)memcpy(v11, v10, v9);
LABEL_18:
  *((_BYTE *)v11 + v9) = 0;
LABEL_19:
  v12 = *(_OWORD *)(a2 + 56);
  *((_QWORD *)v3 + 10) = 0;
  *((_QWORD *)v3 + 11) = 0;
  *((_QWORD *)v3 + 9) = 0;
  *(_OWORD *)(v3 + 56) = v12;
  v13 = *(_QWORD *)(a2 + 72);
  v14 = *(_QWORD *)(a2 + 80);
  v15 = v14 - v13;
  if ( v14 == v13 )
    return result;
  if ( v15 < 0 )
LABEL_24:
    abort();
  result = (char *)operator new(v14 - v13);
  v16 = result;
  *((_QWORD *)v3 + 9) = result;
  *((_QWORD *)v3 + 10) = result;
  *((_QWORD *)v3 + 11) = &result[v15];
  v17 = *(const void **)(a2 + 72);
  v18 = *(_QWORD *)(a2 + 80);
  v19 = v18 - (_QWORD)v17;
  if ( v18 - (__int64)v17 >= 1 )
  {
    result = (char *)memcpy(result, v17, v18 - (_QWORD)v17);
    *((_QWORD *)v3 + 10) = &v16[v19];
  }
  return result;
}

//----- (000000000001319C) ----------------------------------------------------
__int64 __fastcall FLACParser::read_callback(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4)
{
  __int64 v6; // x0
  __int64 v7; // x8
  __int64 result; // x0

  v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(*(_QWORD *)*a4 + 16LL))(*a4, a4[3], a2, *a3);
  v7 = v6;
  if ( v6 < 0 )
  {
    *a3 = 0;
    return 2;
  }
  else if ( v6 )
  {
    *a3 = v6;
    result = 0;
    a4[3] += v7;
  }
  else
  {
    result = 1;
    *a3 = 0;
    *((_BYTE *)a4 + 32) = 1;
  }
  return result;
}

//----- (000000000001322C) ----------------------------------------------------
__int64 __fastcall FLACParser::readCallback(_QWORD *a1, __int64 a2, __int64 *a3)
{
  __int64 v5; // x0
  __int64 v6; // x8
  __int64 result; // x0

  v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(*a1, a1[3], a2, *a3);
  v6 = v5;
  if ( v5 < 0 )
  {
    *a3 = 0;
    return 2;
  }
  else if ( v5 )
  {
    *a3 = v5;
    result = 0;
    a1[3] += v6;
  }
  else
  {
    result = 1;
    *a3 = 0;
    *((_BYTE *)a1 + 32) = 1;
  }
  return result;
}

//----- (00000000000132BC) ----------------------------------------------------
__int64 __fastcall FLACParser::seek_callback(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0

  result = 0;
  *(_QWORD *)(a3 + 24) = a2;
  *(_BYTE *)(a3 + 32) = 0;
  return result;
}

//----- (00000000000132CC) ----------------------------------------------------
__int64 __fastcall FLACParser::seekCallback(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 24) = a2;
  *(_BYTE *)(a1 + 32) = 0;
  return 0;
}

//----- (00000000000132DC) ----------------------------------------------------
__int64 __fastcall FLACParser::tell_callback(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // x0

  result = 0;
  *a2 = *(_QWORD *)(a3 + 24);
  return result;
}

//----- (00000000000132EC) ----------------------------------------------------
__int64 __fastcall FLACParser::tellCallback(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 24);
  result = 0;
  *a2 = v2;
  return result;
}

//----- (00000000000132FC) ----------------------------------------------------
__int64 FLACParser::length_callback()
{
  return 2;
}

//----- (0000000000013304) ----------------------------------------------------
__int64 FLACParser::lengthCallback()
{
  return 2;
}

//----- (000000000001330C) ----------------------------------------------------
__int64 __fastcall FLACParser::eof_callback(__int64 a1, __int64 a2)
{
  return *(unsigned __int8 *)(a2 + 32);
}

//----- (0000000000013314) ----------------------------------------------------
__int64 __fastcall FLACParser::eofCallback(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

//----- (000000000001331C) ----------------------------------------------------
__int64 __fastcall FLACParser::write_callback(__int64 a1, __int128 *a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  __int128 v5; // q0

  if ( *(_BYTE *)(a4 + 177) )
  {
    *(_BYTE *)(a4 + 177) = 0;
    result = 0;
    *(_QWORD *)(a4 + 216) = *((_QWORD *)a2 + 4);
    *(_OWORD *)(a4 + 200) = a2[1];
    v5 = *a2;
    *(_QWORD *)(a4 + 224) = a3;
    *(_BYTE *)(a4 + 178) = 1;
    *(_OWORD *)(a4 + 184) = v5;
  }
  else
  {
    __android_log_print(6, "FLACParser", "FLACParser::writeCallback unexpected");
    return 1;
  }
  return result;
}

//----- (0000000000013380) ----------------------------------------------------
__int64 __fastcall FLACParser::writeCallback(__int64 a1, __int128 *a2, __int64 a3)
{
  __int64 result; // x0
  __int128 v5; // q0

  if ( *(_BYTE *)(a1 + 177) )
  {
    *(_BYTE *)(a1 + 177) = 0;
    result = 0;
    *(_QWORD *)(a1 + 216) = *((_QWORD *)a2 + 4);
    *(_OWORD *)(a1 + 200) = a2[1];
    v5 = *a2;
    *(_QWORD *)(a1 + 224) = a3;
    *(_BYTE *)(a1 + 178) = 1;
    *(_OWORD *)(a1 + 184) = v5;
  }
  else
  {
    __android_log_print(6, "FLACParser", "FLACParser::writeCallback unexpected");
    return 1;
  }
  return result;
}

//----- (00000000000133E8) ----------------------------------------------------
void __fastcall FLACParser::metadata_callback(__int64 a1, __int64 a2, __int64 a3)
{
  FLACParser::metadataCallback(a3, a2);
}

//----- (00000000000133F0) ----------------------------------------------------
void __fastcall FLACParser::metadataCallback(__int64 a1, __int64 a2)
{
  const char *v4; // x22
  size_t v5; // x0
  size_t v6; // x21
  char *v7; // x23
  size_t v8; // x24
  char v9; // w8
  unsigned __int64 v10; // x23
  size_t v11; // x21
  void *v12; // x22
  unsigned __int64 v13; // x26
  unsigned __int64 v14; // x27
  const void **v15; // x20
  const void *v16; // x22
  size_t v17; // x21
  char *v18; // x23
  size_t *v19; // x21
  size_t v20; // x22
  const void *v21; // x23
  void *v22; // x21
  size_t v23; // x24
  void *v24; // x0
  __int128 v25; // q0
  const char *v26; // x22
  size_t v27; // x0
  size_t v28; // x21
  char *v29; // x23
  size_t v30; // x24
  char v31; // w8
  unsigned __int64 v32; // x23
  size_t v33; // x21
  void *v34; // x22
  unsigned __int64 v35; // x8
  char *v36; // x0
  size_t v37; // x22
  char *v38; // x23
  char *v39; // x9
  size_t v40; // x12
  char *v41; // x8
  unsigned __int64 v42; // x11
  unsigned __int64 v43; // x14
  unsigned __int64 v44; // x15
  unsigned __int64 v45; // x18
  char *v46; // x16
  char *v47; // x17
  unsigned __int64 v48; // x8
  size_t v49; // x21
  char *v50; // x0
  char v51; // t1
  char *v52; // x13
  unsigned __int64 v53; // x16
  bool v54; // cf
  unsigned __int64 v55; // x18
  __int128 *v56; // x2
  _OWORD *v57; // x3
  __int64 v58; // x4
  __int128 v59; // q0
  __int128 v60; // q1
  char *v61; // x14
  char *v62; // x15
  char v63; // w17
  char *v64; // x10
  char *v65; // x9
  char v66; // t1
  char *v67; // x0
  char *v68; // x0
  size_t **v69; // [xsp+8h] [xbp-D8h]
  __int128 v70; // [xsp+10h] [xbp-D0h] BYREF
  _BYTE *v71; // [xsp+20h] [xbp-C0h]
  size_t v72[3]; // [xsp+28h] [xbp-B8h] BYREF
  _BYTE *v73; // [xsp+40h] [xbp-A0h]
  __int128 v74; // [xsp+48h] [xbp-98h] BYREF
  _BYTE *v75; // [xsp+58h] [xbp-88h]
  __int128 v76; // [xsp+60h] [xbp-80h]
  char *v77; // [xsp+70h] [xbp-70h]
  char *v78; // [xsp+78h] [xbp-68h]
  unsigned __int64 v79; // [xsp+80h] [xbp-60h]
  __int64 v80; // [xsp+88h] [xbp-58h]

  v80 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  switch ( *(_DWORD *)a2 )
  {
    case 0:
      if ( *(_BYTE *)(a1 + 96) )
      {
        __android_log_print(6, "FLACParser", "FLACParser::metadataCallback unexpected STREAMINFO");
      }
      else
      {
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 32);
        v25 = *(_OWORD *)(a2 + 16);
        *(_BYTE *)(a1 + 96) = 1;
        *(_OWORD *)(a1 + 40) = v25;
      }
      return;
    case 3:
      *(_QWORD *)(a1 + 104) = a2 + 16;
      return;
    case 4:
      if ( *(_BYTE *)(a1 + 144) )
      {
        __android_log_print(6, "FLACParser", "FLACParser::metadataCallback unexpected VORBISCOMMENT");
        return;
      }
      v13 = *(unsigned int *)(a2 + 32);
      if ( !(_DWORD)v13 )
        goto LABEL_40;
      v14 = 0;
      v15 = (const void **)(*(_QWORD *)(a2 + 40) + 8LL);
      v69 = (size_t **)(a1 + 120);
      while ( 1 )
      {
        v16 = *v15;
        if ( !*v15 )
          goto LABEL_39;
        v17 = *((unsigned int *)v15 - 2);
        memset(v72, 0, sizeof(v72));
        if ( (unsigned int)v17 >= 0x17 )
        {
          v18 = (char *)operator new((v17 + 16) & 0x1FFFFFFF0LL);
          v72[1] = v17;
          v72[2] = (size_t)v18;
          v72[0] = (v17 + 16) & 0x1FFFFFFF0LL | 1;
        }
        else
        {
          v18 = (char *)v72 + 1;
          LOBYTE(v72[0]) = 2 * v17;
          if ( !(_DWORD)v17 )
          {
            *((_BYTE *)v72 + v17 + 1) = 0;
            v19 = *(size_t **)(a1 + 128);
            if ( v19 == *(size_t **)(a1 + 136) )
              goto LABEL_28;
            goto LABEL_24;
          }
        }
        memcpy(v18, v16, v17);
        v18[v17] = 0;
        v19 = *(size_t **)(a1 + 128);
        if ( v19 == *(size_t **)(a1 + 136) )
        {
LABEL_28:
          std::vector<std::string>::__push_back_slow_path<std::string const&>(v69, (__int64)v72);
          if ( (v72[0] & 1) == 0 )
            goto LABEL_39;
LABEL_38:
          operator delete((void *)v72[2]);
          goto LABEL_39;
        }
LABEL_24:
        v19[1] = 0;
        v19[2] = 0;
        *v19 = 0;
        if ( (v72[0] & 1) == 0 )
        {
          v19[2] = v72[2];
          *(_OWORD *)v19 = *(_OWORD *)v72;
          goto LABEL_37;
        }
        v20 = v72[1];
        if ( v72[1] >= 0xFFFFFFFFFFFFFFF0LL )
          goto LABEL_103;
        v21 = (const void *)v72[2];
        if ( v72[1] >= 0x17 )
        {
          v23 = (v72[1] + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v24 = operator new(v23);
          v19[1] = v20;
          v19[2] = (size_t)v24;
          *v19 = v23 | 1;
          v22 = v24;
        }
        else
        {
          *(_BYTE *)v19 = 2 * LOBYTE(v72[1]);
          v22 = (char *)v19 + 1;
          if ( !v20 )
            goto LABEL_36;
        }
        memcpy(v22, v21, v20);
LABEL_36:
        *((_BYTE *)v22 + v20) = 0;
LABEL_37:
        *(_QWORD *)(a1 + 128) += 24LL;
        if ( (v72[0] & 1) != 0 )
          goto LABEL_38;
LABEL_39:
        ++v14;
        v15 += 2;
        if ( v14 >= v13 )
        {
LABEL_40:
          *(_BYTE *)(a1 + 144) = 1;
          return;
        }
      }
    case 6:
      v77 = 0;
      v78 = 0;
      v79 = 0;
      v75 = 0;
      v73 = 0;
      v74 = 0u;
      v72[1] = 0;
      v72[2] = 0;
      v4 = *(const char **)(a2 + 24);
      v70 = 0u;
      v71 = 0;
      v5 = strlen(v4);
      v6 = v5;
      if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_103;
      if ( v5 >= 0x17 )
      {
        v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v7 = (char *)operator new(v8);
        *((_QWORD *)&v70 + 1) = v6;
        v71 = v7;
        *(_QWORD *)&v70 = v8 | 1;
      }
      else
      {
        v7 = (char *)&v70 + 1;
        LOBYTE(v70) = 2 * v5;
        if ( !v5 )
        {
          BYTE1(v70) = 0;
LABEL_11:
          LOWORD(v72[1]) = 0;
          goto LABEL_43;
        }
      }
      memcpy(v7, v4, v6);
      v9 = v72[1];
      v7[v6] = 0;
      if ( (v9 & 1) == 0 )
        goto LABEL_11;
      *v73 = 0;
      v72[2] = 0;
      if ( (v72[1] & 1) != 0 )
      {
        BYTE1(v72[1]) = *v73;
        operator delete(v73);
        LOBYTE(v72[1]) = 0;
      }
      else if ( LOBYTE(v72[1]) >= 0x2Eu )
      {
        v10 = (unsigned __int64)LOBYTE(v72[1]) >> 1;
        v11 = (unsigned __int8)((LOBYTE(v72[1]) >> 1) + 16) & 0xF0;
        v12 = operator new(v11);
        memcpy(v12, (char *)&v72[1] + 1, v10 + 1);
        v72[1] = v11 | 1;
        v72[2] = v10;
        v73 = v12;
      }
LABEL_43:
      v73 = v71;
      *(_OWORD *)&v72[1] = v70;
      v26 = *(const char **)(a2 + 32);
      v70 = 0u;
      v71 = 0;
      v27 = strlen(v26);
      v28 = v27;
      if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_103:
        abort();
      if ( v27 >= 0x17 )
      {
        v30 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v29 = (char *)operator new(v30);
        *((_QWORD *)&v70 + 1) = v28;
        v71 = v29;
        *(_QWORD *)&v70 = v30 | 1;
LABEL_49:
        memcpy(v29, v26, v28);
        v31 = v74;
        v29[v28] = 0;
        if ( (v31 & 1) == 0 )
          goto LABEL_47;
        goto LABEL_50;
      }
      v29 = (char *)&v70 + 1;
      LOBYTE(v70) = 2 * v27;
      if ( v27 )
        goto LABEL_49;
      BYTE1(v70) = 0;
      if ( (v74 & 1) == 0 )
      {
LABEL_47:
        LOWORD(v74) = 0;
        goto LABEL_54;
      }
LABEL_50:
      *v75 = 0;
      *((_QWORD *)&v74 + 1) = 0;
      if ( (v74 & 1) != 0 )
      {
        BYTE1(v74) = *v75;
        operator delete(v75);
        LOBYTE(v74) = 0;
      }
      else if ( (unsigned __int8)v74 >= 0x2Eu )
      {
        v32 = (unsigned __int64)(unsigned __int8)v74 >> 1;
        v33 = (unsigned __int8)(((unsigned __int8)v74 >> 1) + 16) & 0xF0;
        v34 = operator new(v33);
        memcpy(v34, (char *)&v74 + 1, v32 + 1);
        *(_QWORD *)&v74 = v33 | 1;
        *((_QWORD *)&v74 + 1) = v32;
        v75 = v34;
      }
LABEL_54:
      v75 = v71;
      v74 = v70;
      v35 = v79;
      v36 = v77;
      v37 = *(unsigned int *)(a2 + 56);
      v38 = *(char **)(a2 + 64);
      if ( v79 - (unsigned __int64)v77 < v37 )
      {
        if ( v77 )
        {
          v78 = v77;
          operator delete(v77);
          v35 = 0;
          v77 = 0;
          v78 = 0;
          v79 = 0;
        }
        else if ( v79 > 0x3FFFFFFFFFFFFFFELL )
        {
          v49 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_70;
        }
        v48 = 2 * v35;
        if ( v48 >= v37 )
          v49 = v48;
        else
          v49 = v37;
LABEL_70:
        v50 = (char *)operator new(v49);
        v77 = v50;
        v78 = v50;
        v79 = (unsigned __int64)&v50[v49];
        if ( (_DWORD)v37 )
        {
          do
          {
            v51 = *v38++;
            --v37;
            *v50 = v51;
            v50 = ++v78;
          }
          while ( v37 );
        }
        goto LABEL_92;
      }
      v39 = v78;
      v40 = v78 - v77;
      v41 = &v38[v78 - v77];
      if ( v78 - v77 >= v37 )
        v42 = (unsigned __int64)&v38[v37];
      else
        v42 = (unsigned __int64)&v38[v78 - v77];
      if ( (char *)v42 == v38 )
      {
        v52 = v77;
        if ( v40 < v37 )
          goto LABEL_89;
LABEL_74:
        v78 = v52;
        goto LABEL_92;
      }
      v43 = v77 - 1 - v78;
      v44 = ~v37;
      if ( v43 <= ~v37 )
        v45 = ~v37;
      else
        v45 = v77 - 1 - v78;
      if ( v45 <= 0xFFFFFFFFFFFFFFDFLL )
      {
        if ( v43 <= v44 )
          v53 = ~v37;
        else
          v53 = v77 - 1 - v78;
        if ( v42 <= (unsigned __int64)v77 || (v54 = v38 >= &v77[~v53], v46 = v77, v47 = *(char **)(a2 + 64), v54) )
        {
          v55 = ~v45;
          v56 = (__int128 *)(v38 + 16);
          v46 = &v77[v55 & 0xFFFFFFE0];
          v47 = &v38[v55 & 0xFFFFFFE0];
          v57 = v77 + 16;
          v58 = (unsigned int)v55 & 0xFFFFFFE0;
          do
          {
            v59 = *(v56 - 1);
            v60 = *v56;
            v56 += 2;
            v58 -= 32;
            *(v57 - 1) = v59;
            *v57 = v60;
            v57 += 2;
          }
          while ( v58 );
          if ( (v55 & 0xFFFFFFE0) == v55 )
            goto LABEL_88;
        }
      }
      else
      {
        v46 = v77;
        v47 = *(char **)(a2 + 64);
      }
      if ( v43 <= v44 )
        v43 = ~v37;
      v61 = &v38[-v43];
      v62 = v47 + 1;
      do
      {
        v63 = *(v62++ - 1);
        *v46++ = v63;
      }
      while ( v61 != v62 );
LABEL_88:
      v52 = &v36[v42 - (_QWORD)v38];
      if ( v40 >= v37 )
        goto LABEL_74;
LABEL_89:
      if ( (char *)v42 != &v38[v37] )
      {
        v64 = v78;
        v65 = (char *)(&v36[v37] - v39);
        do
        {
          v66 = *v41++;
          --v65;
          *v64 = v66;
          v64 = ++v78;
        }
        while ( v65 );
      }
LABEL_92:
      v76 = *(_OWORD *)(a2 + 40);
      LODWORD(v72[0]) = *(_DWORD *)(a2 + 16);
      v67 = *(char **)(a1 + 160);
      if ( v67 != *(char **)(a1 + 168) )
      {
        FlacPicture::FlacPicture(v67, (__int64)v72);
        *(_QWORD *)(a1 + 160) += 96LL;
        *(_BYTE *)(a1 + 176) = 1;
        v68 = v77;
        if ( !v77 )
          goto LABEL_95;
        goto LABEL_94;
      }
      std::vector<FlacPicture>::__push_back_slow_path<FlacPicture const&>((char **)(a1 + 152), (__int64)v72);
      *(_BYTE *)(a1 + 176) = 1;
      v68 = v77;
      if ( v77 )
      {
LABEL_94:
        v78 = v68;
        operator delete(v68);
      }
LABEL_95:
      if ( (v74 & 1) == 0 )
      {
        if ( (v72[1] & 1) == 0 )
          return;
LABEL_99:
        operator delete(v73);
        return;
      }
      operator delete(v75);
      if ( (v72[1] & 1) != 0 )
        goto LABEL_99;
      return;
    default:
      __android_log_print(6, "FLACParser", "FLACParser::metadataCallback unexpected type %u", *(_DWORD *)a2);
      return;
  }
}
// 13510: conditional instruction was optimized away because %var_B8@8.1==0

//----- (0000000000013B48) ----------------------------------------------------
__int64 __fastcall FLACParser::error_callback(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // x0

  result = __android_log_print(6, "FLACParser", "FLACParser::errorCallback status=%d", a2);
  *(_DWORD *)(a3 + 232) = a2;
  return result;
}

//----- (0000000000013B88) ----------------------------------------------------
__int64 __fastcall FLACParser::errorCallback(__int64 a1, int a2)
{
  __int64 result; // x0

  result = __android_log_print(6, "FLACParser", "FLACParser::errorCallback status=%d", a2);
  *(_DWORD *)(a1 + 232) = a2;
  return result;
}

//----- (0000000000013BC8) ----------------------------------------------------
__int64 __fastcall FLACParser::FLACParser(__int64 a1, __int64 a2)
{
  __int64 result; // x0

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_13C5C;
  *(_BYTE *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 178) = 0;
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 232) = -1;
  result = __android_log_print(2, "FLACParser", "FLACParser::FLACParser");
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  return result;
}

//----- (0000000000013C5C) ----------------------------------------------------
void __noreturn sub_13C5C()
{
  __android_log_assert(
    0,
    "FLACParser",
    "/Users/leroy/StudioProjects/ExoPlayer/extensions/flac/src/main/jni/flac_parser.cc:259 Should not be here.");
}

//----- (0000000000013C7C) ----------------------------------------------------
void __fastcall FLACParser::~FLACParser(_QWORD *a1)
{
  void **v2; // x0
  __int64 v3; // x20
  __int64 v4; // x21
  void *v5; // x0
  __int64 v6; // x22
  void *v7; // x0
  __int64 v8; // x20
  __int64 v9; // x8
  __int64 v10; // x21
  char v11; // t1
  void *v12; // x0

  __android_log_print(2, "FLACParser", "FLACParser::~FLACParser");
  v2 = (void **)a1[2];
  if ( v2 )
  {
    FLAC__stream_decoder_delete(v2);
    a1[2] = 0;
  }
  v3 = a1[19];
  if ( v3 )
  {
    v4 = a1[20];
    if ( v4 != v3 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v5 = *(void **)(v4 - 24);
          if ( v5 )
          {
            *(_QWORD *)(v4 - 16) = v5;
            operator delete(v5);
          }
          if ( (*(_BYTE *)(v4 - 64) & 1) == 0 )
            break;
          operator delete(*(void **)(v4 - 48));
          v6 = v4 - 96;
          if ( (*(_BYTE *)(v4 - 88) & 1) == 0 )
            goto LABEL_9;
LABEL_12:
          operator delete(*(void **)(v4 - 72));
          v4 = v6;
          if ( v3 == v6 )
          {
LABEL_13:
            v7 = (void *)a1[19];
            goto LABEL_15;
          }
        }
        v6 = v4 - 96;
        if ( (*(_BYTE *)(v4 - 88) & 1) != 0 )
          goto LABEL_12;
LABEL_9:
        v4 = v6;
        if ( v3 == v6 )
          goto LABEL_13;
      }
    }
    v7 = (void *)a1[19];
LABEL_15:
    a1[20] = v3;
    operator delete(v7);
  }
  v8 = a1[15];
  if ( v8 )
  {
    v9 = a1[16];
    if ( v9 == v8 )
    {
      v12 = (void *)a1[15];
    }
    else
    {
      v10 = a1[16];
      do
      {
        v11 = *(_BYTE *)(v10 - 24);
        v10 -= 24;
        if ( (v11 & 1) != 0 )
          operator delete(*(void **)(v9 - 8));
        v9 = v10;
      }
      while ( v8 != v10 );
      v12 = (void *)a1[15];
    }
    a1[16] = v8;
    operator delete(v12);
  }
}

//----- (0000000000013DA0) ----------------------------------------------------
__int64 __fastcall FLACParser::init(__int64 a1)
{
  _QWORD *v2; // x0
  int inited; // w8

  v2 = FLAC__stream_decoder_new();
  *(_QWORD *)(a1 + 16) = v2;
  if ( !v2 )
  {
    __android_log_print(6, "FLACParser", "new failed");
    return 0;
  }
  FLAC__stream_decoder_set_md5_checking(v2, 0);
  FLAC__stream_decoder_set_metadata_ignore_all(*(_QWORD *)(a1 + 16));
  FLAC__stream_decoder_set_metadata_respond(*(_QWORD *)(a1 + 16), 0);
  FLAC__stream_decoder_set_metadata_respond(*(_QWORD *)(a1 + 16), 3u);
  FLAC__stream_decoder_set_metadata_respond(*(_QWORD *)(a1 + 16), 4u);
  FLAC__stream_decoder_set_metadata_respond(*(_QWORD *)(a1 + 16), 6u);
  inited = FLAC__stream_decoder_init_stream(
             *(int ***)(a1 + 16),
             (__int64)FLACParser::read_callback,
             (__int64)FLACParser::seek_callback,
             (__int64)FLACParser::tell_callback,
             (__int64)FLACParser::length_callback,
             (__int64)FLACParser::eof_callback,
             (__int64)FLACParser::write_callback,
             (__int64)FLACParser::metadata_callback,
             (__int64)FLACParser::error_callback,
             a1);
  if ( inited )
  {
    __android_log_print(6, "FLACParser", "init_stream failed %d", inited);
    return 0;
  }
  return 1;
}

//----- (0000000000013EB4) ----------------------------------------------------
__int64 __fastcall FLACParser::decodeMetadata(__int64 a1)
{
  unsigned __int64 v3; // t2

  if ( !(unsigned int)FLAC__stream_decoder_process_until_end_of_metadata(*(_DWORD ***)(a1 + 16)) )
  {
    __android_log_print(6, "FLACParser", "metadata decoding failed");
    return 0;
  }
  FLAC__stream_decoder_get_decode_position(*(_QWORD *)(a1 + 16), (_QWORD *)(a1 + 112));
  if ( !*(_BYTE *)(a1 + 96) )
  {
    __android_log_print(6, "FLACParser", "missing STREAMINFO");
    return 0;
  }
  if ( (unsigned int)(*(_DWORD *)(a1 + 60) - 1) < 8 )
  {
    HIDWORD(v3) = *(_DWORD *)(a1 + 64) - 8;
    LODWORD(v3) = HIDWORD(v3);
    if ( (unsigned int)(v3 >> 3) < 4 )
    {
      *(_QWORD *)(a1 + 8) = sub_13F9C;
      return 1;
    }
    __android_log_print(6, "FLACParser", "unsupported bits per sample %u");
  }
  else
  {
    __android_log_print(6, "FLACParser", "unsupported channel count %u");
  }
  return 0;
}

//----- (0000000000013F9C) ----------------------------------------------------
char *__fastcall sub_13F9C(char *result, __int64 *a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  char *v6; // x20
  size_t v7; // x21
  __int64 v8; // x22
  __int64 v9; // x23
  __int64 v10; // x24
  __int64 v11; // x25
  __int64 v12; // x26
  __int64 v13; // x27
  __int64 *v14; // x28
  __int64 v15; // t1

  v6 = result;
  if ( a4 && a5 )
  {
    v7 = a3;
    v8 = 0;
    v9 = a5;
    v10 = (a5 - 1 + 1LL) * a3;
    v11 = a4;
    do
    {
      v12 = 0;
      v13 = v9;
      v14 = a2;
      do
      {
        v15 = *v14++;
        result = (char *)memcpy(&v6[v12], (const void *)(v15 + 4 * v8), v7);
        --v13;
        v12 += v7;
      }
      while ( v13 );
      ++v8;
      v6 += v10;
    }
    while ( v8 != v11 );
  }
  return result;
}

//----- (000000000001403C) ----------------------------------------------------
__int64 __fastcall FLACParser::readBuffer(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  _DWORD **v4; // x0
  unsigned int v7; // w3
  char *resolved_state_string; // x3
  char *v9; // x3
  unsigned __int64 v10; // x20
  int v12; // w6
  int v13; // w8
  int v14; // w7
  int v15; // w4
  unsigned int v16; // w9

  v4 = *(_DWORD ***)(a1 + 16);
  *(_WORD *)(a1 + 177) = 1;
  if ( !(unsigned int)FLAC__stream_decoder_process_single(v4) )
  {
    resolved_state_string = FLAC__stream_decoder_get_resolved_state_string(*(unsigned int ***)(a1 + 16));
    __android_log_print(
      6,
      "FLACParser",
      "FLACParser::readBuffer process_single failed. Status: %s",
      resolved_state_string);
    return -1;
  }
  if ( !*(_BYTE *)(a1 + 178) )
  {
    if ( (unsigned int)FLAC__stream_decoder_get_state(*(unsigned int ***)(a1 + 16)) != 4 )
    {
      v9 = FLAC__stream_decoder_get_resolved_state_string(*(unsigned int ***)(a1 + 16));
      __android_log_print(6, "FLACParser", "FLACParser::readBuffer write did not complete. Status: %s", v9);
    }
    return -1;
  }
  v7 = *(_DWORD *)(a1 + 184);
  if ( !v7 || v7 > *(_DWORD *)(a1 + 44) )
  {
    __android_log_print(6, "FLACParser", "FLACParser::readBuffer write invalid blocksize %u", v7);
    return -1;
  }
  v12 = *(_DWORD *)(a1 + 188);
  v13 = *(_DWORD *)(a1 + 56);
  if ( v12 != v13 )
  {
    v15 = *(_DWORD *)(a1 + 60);
    v14 = *(_DWORD *)(a1 + 192);
    goto LABEL_17;
  }
  v14 = *(_DWORD *)(a1 + 192);
  v15 = *(_DWORD *)(a1 + 60);
  if ( v14 != v15 )
  {
LABEL_17:
    __android_log_print(
      6,
      "FLACParser",
      "FLACParser::readBuffer write changed parameters mid-stream: %d/%d/%d -> %d/%d/%d",
      v13,
      v15,
      *(_DWORD *)(a1 + 64),
      v12,
      v14,
      *(_DWORD *)(a1 + 200));
    return -1;
  }
  v16 = *(_DWORD *)(a1 + 200);
  if ( v16 != *(_DWORD *)(a1 + 64) )
  {
    v15 = *(_DWORD *)(a1 + 192);
    goto LABEL_17;
  }
  v10 = v14 * v7 * (v16 >> 3);
  if ( v10 > a3 )
  {
    __android_log_print(6, "FLACParser", "FLACParser::readBuffer not enough space in output buffer %zu < %zu", a3, v10);
    return -1;
  }
  (*(void (__fastcall **)(__int64, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 224));
  if ( *(_DWORD *)(a1 + 204) != 1 )
    __android_log_print(
      6,
      "FLACParser",
      "Check failed: %s ",
      "mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER");
  return v10;
}

//----- (0000000000014200) ----------------------------------------------------
__int64 __fastcall FLACParser::getSeekPositions(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned int *v3; // x9
  unsigned __int64 v4; // x8
  __int64 v5; // x10
  unsigned __int64 v6; // x12
  __int64 v7; // x11
  __int64 v8; // x13
  _QWORD *v9; // x10
  unsigned __int64 v10; // x14
  __int64 v11; // x17
  __int64 v12; // x16
  __int64 v13; // x13
  __int64 result; // x0
  __int64 v15; // x15
  __int64 v16; // x13
  __int64 v17; // x11
  __int64 v18; // x13

  v3 = *(unsigned int **)(a1 + 104);
  if ( !v3 )
    return 0;
  v4 = *(unsigned int *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 72);
  v6 = *v3;
  v7 = (__int64)(v4 * a2) / 1000000;
  if ( v7 >= v5 )
    v7 = v5 - 1;
  if ( (_DWORD)v6 )
  {
    v8 = *((_QWORD *)v3 + 1);
    v9 = (_QWORD *)(v8 + 24 * v6 + 8);
    v10 = *v3;
    while ( 1 )
    {
      v11 = (unsigned int)(v10 - 1);
      v12 = *(_QWORD *)(v8 + 24LL * (unsigned int)v11);
      if ( v12 != -1 && v12 <= v7 )
        break;
      --v10;
      v9 -= 3;
      if ( !(_DWORD)v10 )
        goto LABEL_9;
    }
    v15 = 1000000 * v12 / (__int64)v4;
    *a3 = v15;
    v16 = *(_QWORD *)(v8 + 24 * v11 + 8) + *(_QWORD *)(a1 + 112);
    a3[1] = v16;
    if ( v10 >= v6 || v12 == v7 || (v17 = *(v9 - 1), v17 == -1) )
    {
      a3[2] = v15;
      result = 1;
      a3[3] = v16;
    }
    else
    {
      a3[2] = 1000000 * v17 / v4;
      v18 = *v9 + *(_QWORD *)(a1 + 112);
      result = 1;
      a3[3] = v18;
    }
  }
  else
  {
LABEL_9:
    *a3 = 0;
    a3[1] = *(_QWORD *)(a1 + 112);
    a3[2] = 0;
    v13 = *(_QWORD *)(a1 + 112);
    result = 1;
    a3[3] = v13;
  }
  return result;
}

//----- (0000000000014320) ----------------------------------------------------
void __fastcall std::vector<std::string>::__push_back_slow_path<std::string const&>(size_t **a1, __int64 a2)
{
  char *v3; // x20
  char *v4; // x23
  unsigned __int64 v5; // x28
  __int64 v6; // x25
  char *v8; // x21
  size_t *v9; // x26
  char *v10; // x8
  char *v11; // x9
  size_t v12; // x20
  const void *v13; // x22
  void *v14; // x23
  char *v15; // x8
  char *v16; // x19
  char v17; // t1

  v3 = (char *)*a1;
  v4 = (char *)a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (char *)*a1) >> 3);
  v6 = 0xAAAAAAAAAAAAAAALL;
  if ( v5 + 1 > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_29;
  if ( 0xAAAAAAAAAAAAAAABLL * (((char *)a1[2] - v3) >> 3) > 0x555555555555554LL
    || (0x5555555555555556LL * (((char *)a1[2] - v3) >> 3) >= v5 + 1
      ? (v6 = 0x5555555555555556LL * (((char *)a1[2] - v3) >> 3))
      : (v6 = v5 + 1),
        v6) )
  {
    v8 = (char *)operator new(24 * v6);
  }
  else
  {
    v8 = 0;
  }
  v9 = (size_t *)&v8[24 * v5];
  v9[1] = 0;
  v9[2] = 0;
  *v9 = 0;
  if ( (*(_BYTE *)a2 & 1) == 0 )
  {
    v9[2] = *(_QWORD *)(a2 + 16);
    *(_OWORD *)v9 = *(_OWORD *)a2;
    v10 = &v8[24 * v6];
    v11 = (char *)(v9 + 3);
    if ( v4 == v3 )
      goto LABEL_20;
    goto LABEL_18;
  }
  v12 = *(_QWORD *)(a2 + 8);
  if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_29:
    abort();
  v13 = *(const void **)(a2 + 16);
  if ( v12 >= 0x17 )
  {
    v14 = operator new((v12 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    v15 = &v8[24 * v5];
    *((_QWORD *)v15 + 1) = v12;
    *((_QWORD *)v15 + 2) = v14;
    *v9 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    goto LABEL_16;
  }
  *(_BYTE *)v9 = 2 * v12;
  v14 = (char *)v9 + 1;
  if ( v12 )
LABEL_16:
    memcpy(v14, v13, v12);
  *((_BYTE *)v14 + v12) = 0;
  v3 = (char *)*a1;
  v4 = (char *)a1[1];
  v10 = &v8[24 * v6];
  v11 = (char *)(v9 + 3);
  if ( v4 == (char *)*a1 )
    goto LABEL_20;
  do
  {
LABEL_18:
    *(v9 - 1) = *((_QWORD *)v4 - 1);
    *(_OWORD *)(v9 - 3) = *(_OWORD *)(v4 - 24);
    *((_QWORD *)v4 - 3) = 0;
    *((_QWORD *)v4 - 2) = 0;
    *((_QWORD *)v4 - 1) = 0;
    v4 -= 24;
    v9 -= 3;
  }
  while ( v3 != v4 );
  v3 = (char *)*a1;
  v4 = (char *)a1[1];
LABEL_20:
  *a1 = v9;
  a1[1] = (size_t *)v11;
  a1[2] = (size_t *)v10;
  if ( v4 != v3 )
  {
    v16 = v4;
    do
    {
      v17 = *(v16 - 24);
      v16 -= 24;
      if ( (v17 & 1) != 0 )
        operator delete(*((void **)v4 - 1));
      v4 = v16;
    }
    while ( v3 != v16 );
  }
  if ( v3 )
    operator delete(v3);
}

//----- (000000000001451C) ----------------------------------------------------
void __fastcall std::vector<FlacPicture>::__push_back_slow_path<FlacPicture const&>(char **a1, __int64 a2)
{
  unsigned __int64 v3; // x20
  __int64 v4; // x22
  char *v6; // x0
  char *v7; // x20
  char *v8; // x22
  char *v9; // x10
  char *v10; // x8
  char *v11; // x9
  char *v12; // x11
  char *v13; // x12
  int v14; // w13
  char *v15; // x14
  __int64 v16; // x13
  __int128 v17; // q0
  char *v18; // x21
  char *v19; // x23
  bool v20; // zf
  void *v21; // x0
  char *v22; // x19

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  v4 = 0x2AAAAAAAAAAAAAALL;
  if ( v3 + 1 > 0x2AAAAAAAAAAAAAALL )
    abort();
  if ( 0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) > 0x155555555555554LL
    || (0x5555555555555556LL * ((a1[2] - *a1) >> 5) >= v3 + 1
      ? (v4 = 0x5555555555555556LL * ((a1[2] - *a1) >> 5))
      : (v4 = v3 + 1),
        v4) )
  {
    v6 = (char *)operator new(96 * v4);
  }
  else
  {
    v6 = 0;
  }
  v7 = &v6[96 * v3];
  v8 = &v6[96 * v4];
  FlacPicture::FlacPicture(v7, a2);
  v9 = a1[1];
  v10 = v7 + 96;
  if ( v9 == *a1 )
  {
    v18 = *a1;
    *a1 = v7;
    a1[1] = v10;
    a1[2] = v8;
  }
  else
  {
    v11 = 0;
    v12 = (char *)(*a1 - v9);
    do
    {
      v13 = &v11[(_QWORD)v9];
      v14 = *(_DWORD *)&v11[(_QWORD)v9 - 96];
      v15 = &v11[(_QWORD)v7];
      v11 -= 96;
      *((_DWORD *)v15 - 24) = v14;
      *((_QWORD *)v15 - 9) = *((_QWORD *)v13 - 9);
      *(_OWORD *)(v15 - 88) = *(_OWORD *)(v13 - 88);
      v16 = *((_QWORD *)v13 - 6);
      *((_QWORD *)v13 - 11) = 0;
      *((_QWORD *)v13 - 10) = 0;
      *((_QWORD *)v13 - 9) = 0;
      *((_QWORD *)v15 - 6) = v16;
      *((_OWORD *)v15 - 4) = *((_OWORD *)v13 - 4);
      v17 = *(_OWORD *)(v13 - 40);
      *((_QWORD *)v13 - 7) = 0;
      *((_QWORD *)v13 - 6) = 0;
      *((_QWORD *)v13 - 8) = 0;
      *((_QWORD *)v15 - 2) = 0;
      *((_QWORD *)v15 - 1) = 0;
      *((_QWORD *)v15 - 3) = 0;
      *(_OWORD *)(v15 - 40) = v17;
      *(_OWORD *)(v15 - 24) = *(_OWORD *)(v13 - 24);
      *((_QWORD *)v15 - 1) = *((_QWORD *)v13 - 1);
      *((_QWORD *)v13 - 3) = 0;
      *((_QWORD *)v13 - 2) = 0;
      *((_QWORD *)v13 - 1) = 0;
    }
    while ( v12 != v11 );
    v18 = *a1;
    v19 = a1[1];
    v20 = v19 == *a1;
    *a1 = &v11[(_QWORD)v7];
    a1[1] = v10;
    a1[2] = v8;
    if ( !v20 )
    {
      do
      {
        while ( 1 )
        {
          v21 = (void *)*((_QWORD *)v19 - 3);
          if ( v21 )
          {
            *((_QWORD *)v19 - 2) = v21;
            operator delete(v21);
          }
          if ( (*(v19 - 64) & 1) == 0 )
            break;
          operator delete(*((void **)v19 - 6));
          v22 = v19 - 96;
          if ( (*(v19 - 88) & 1) == 0 )
            goto LABEL_16;
LABEL_19:
          operator delete(*((void **)v19 - 9));
          v19 = v22;
          if ( v18 == v22 )
            goto LABEL_20;
        }
        v22 = v19 - 96;
        if ( (*(v19 - 88) & 1) != 0 )
          goto LABEL_19;
LABEL_16:
        v19 = v22;
      }
      while ( v18 != v22 );
    }
  }
LABEL_20:
  if ( v18 )
    operator delete(v18);
}

//----- (0000000000014710) ----------------------------------------------------
__int64 __fastcall FLAC__bitmath_silog2(__int64 result)
{
  if ( result )
  {
    if ( result == -1 )
      return 2;
    else
      return ((unsigned int)__clz(result ^ (result >> 63)) ^ 0x3F) + 2;
  }
  return result;
}

//----- (0000000000014738) ----------------------------------------------------
void *FLAC__bitreader_new()
{
  return calloc(1u, 0x38u);
}

//----- (0000000000014744) ----------------------------------------------------
void __fastcall FLAC__bitreader_delete(void **a1)
{
  void *v2; // x0

  v2 = *a1;
  if ( v2 )
    free(v2);
  free(a1);
}

//----- (0000000000014770) ----------------------------------------------------
void __fastcall FLAC__bitreader_free(__int64 a1)
{
  void *v2; // x0

  v2 = *(void **)a1;
  if ( v2 )
    free(v2);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
}

//----- (00000000000147A8) ----------------------------------------------------
void *__fastcall FLAC__bitreader_init(__int64 a1, __int64 a2, __int64 a3)
{
  void *result; // x0

  *(_QWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 2048;
  result = malloc(0x2000u);
  *(_QWORD *)a1 = result;
  if ( result )
  {
    result = &dword_0 + 1;
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = a3;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000147FC) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_clear(__int64 a1)
{
  __int64 result; // x0

  result = 1;
  *(_QWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0000000000014810) ----------------------------------------------------
size_t __fastcall FLAC__bitreader_dump(__int64 a1, FILE *a2)
{
  size_t result; // x0
  unsigned __int64 v5; // x21
  unsigned int v6; // w25
  int v7; // w26
  unsigned __int64 v8; // x8
  unsigned int v9; // w8
  unsigned int v10; // w23
  char v11; // w25
  unsigned int v12; // w9

  if ( !a1 )
    return fwrite("bitreader is NULL\n", 0x12u, 1u, a2);
  result = fprintf(
             a2,
             "bitreader: capacity=%u words=%u bytes=%u consumed: words=%u, bits=%u\n",
             *(_DWORD *)(a1 + 8),
             *(_DWORD *)(a1 + 12),
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24));
  if ( !*(_DWORD *)(a1 + 12) )
  {
    LODWORD(v5) = 0;
    if ( !*(_DWORD *)(a1 + 16) )
      return result;
    goto LABEL_13;
  }
  v5 = 0;
  do
  {
    fprintf(a2, "%08X: ", v5);
    v6 = 0;
    v7 = 31;
    do
    {
      while ( 1 )
      {
        v8 = *(unsigned int *)(a1 + 20);
        if ( v5 >= v8 && (v5 != v8 || v6 >= *(_DWORD *)(a1 + 24)) )
          break;
        fputc(46, a2);
        ++v6;
        --v7;
        if ( v6 == 32 )
          goto LABEL_11;
      }
      fprintf(a2, "%01d", (*(_DWORD *)(*(_QWORD *)a1 + 4 * v5) & (1 << v7)) != 0);
      ++v6;
      --v7;
    }
    while ( v6 != 32 );
LABEL_11:
    result = fputc(10, a2);
    ++v5;
  }
  while ( v5 < *(unsigned int *)(a1 + 12) );
  if ( *(_DWORD *)(a1 + 16) )
  {
LABEL_13:
    fprintf(a2, "%08X: ", v5);
    v9 = 8 * *(_DWORD *)(a1 + 16);
    if ( v9 )
    {
      v10 = 0;
      v11 = -1;
      do
      {
        v12 = *(_DWORD *)(a1 + 20);
        if ( (unsigned int)v5 < v12 || (_DWORD)v5 == v12 && v10 < *(_DWORD *)(a1 + 24) )
          fputc(46, a2);
        else
          fprintf(a2, "%01d", (*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned int)v5) & (1 << (v9 + v11))) != 0);
        ++v10;
        --v11;
        v9 = 8 * *(_DWORD *)(a1 + 16);
      }
      while ( v9 > v10 );
    }
    return fputc(10, a2);
  }
  return result;
}

//----- (0000000000014A28) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_reset_read_crc16(__int64 result, unsigned __int16 a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(result + 20);
  *(_DWORD *)(result + 28) = a2;
  *(_QWORD *)(result + 32) = v2;
  return result;
}

//----- (0000000000014A3C) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_get_read_crc16(__int64 *a1)
{
  unsigned int v2; // w8
  __int64 v3; // x12
  unsigned int v4; // w10
  __int64 v5; // x13
  unsigned int v6; // w11
  int v7; // w9
  unsigned int v8; // w12
  unsigned int v9; // w13
  unsigned int i; // w15
  unsigned int v11; // w8
  __int64 result; // x0
  unsigned int v13; // w9
  unsigned int v14; // w11

  v2 = *((_DWORD *)a1 + 5);
  v3 = *((unsigned int *)a1 + 8);
  if ( v2 > (unsigned int)v3 )
  {
    v4 = *((_DWORD *)a1 + 9);
    if ( v4 )
    {
      v5 = *a1;
      v6 = *((_DWORD *)a1 + 7);
      v7 = v3 + 1;
      *((_DWORD *)a1 + 8) = v3 + 1;
      if ( v4 <= 0x1F )
      {
        v8 = *(_DWORD *)(v5 + 4 * v3);
        v9 = 24 - v4;
        for ( i = v4; i < 0x20; i += 8 )
        {
          v6 = ((unsigned __int8)v6 << 8) ^ FLAC__crc16_table[(unsigned __int8)(v8 >> v9) ^ (v6 >> 8)];
          v9 -= 8;
        }
        *((_DWORD *)a1 + 9) = v4 + ((31 - v4) & 0xFFFFFFF8) + 8;
      }
      LODWORD(v3) = v7;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 9) = 0;
    }
  }
  LOWORD(result) = FLAC__crc16_update_words32(
                     (unsigned int *)(*a1 + 4LL * (unsigned int)v3),
                     v2 - (unsigned int)v3,
                     *((_DWORD *)a1 + 7));
  v11 = *((_DWORD *)a1 + 6);
  result = (unsigned __int16)result;
  *(__int64 *)((char *)a1 + 28) = (unsigned __int16)result;
  if ( v11 )
  {
    v13 = *((_DWORD *)a1 + 9);
    if ( v13 < v11 )
    {
      v14 = 24 - v13;
      do
      {
        v13 += 8;
        result = ((unsigned __int8)result << 8)
               ^ (unsigned int)FLAC__crc16_table[(unsigned __int8)(*(_DWORD *)(*a1 + 4LL * *((unsigned int *)a1 + 5)) >> v14)
                                               ^ ((unsigned int)result >> 8)];
        v14 -= 8;
      }
      while ( v13 < v11 );
      *((_DWORD *)a1 + 7) = result;
      *((_DWORD *)a1 + 9) = v13;
    }
  }
  return result;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (0000000000014B68) ----------------------------------------------------
bool __fastcall FLAC__bitreader_is_consumed_byte_aligned(__int64 a1)
{
  return (*(_BYTE *)(a1 + 24) & 7) == 0;
}

//----- (0000000000014B78) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_bits_left_for_byte_alignment(__int64 a1)
{
  return 8 - (*(_DWORD *)(a1 + 24) & 7u);
}

//----- (0000000000014B8C) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_get_input_bits_unconsumed(_DWORD *a1)
{
  return (unsigned int)(32 * (a1[3] - a1[5]) + 8 * a1[4] - a1[6]);
}

//----- (0000000000014BAC) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_raw_uint32(__int64 a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v6; // w8
  unsigned int v7; // w10
  int v8; // w9
  __int64 result; // x0
  char *v10; // x10
  unsigned int v11; // w11
  unsigned int v12; // w12
  char v13; // w9
  unsigned int v14; // w8
  unsigned int v15; // w8
  int v16; // w9
  unsigned int v17; // w8

  if ( !a3 )
  {
    *a2 = 0;
    return 1;
  }
  while ( 1 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = *(_DWORD *)(a1 + 12);
    v8 = *(_DWORD *)(a1 + 24);
    if ( 32 * (v7 - v6) + 8 * *(_DWORD *)(a1 + 16) - v8 >= a3 )
      break;
    result = sub_14D1C((char **)a1);
    if ( !(_DWORD)result )
      return result;
  }
  if ( v7 <= v6 )
  {
    v14 = *(_DWORD *)(*(_QWORD *)a1 + 4LL * v6);
    if ( v8 )
    {
      v14 &= 0xFFFFFFFF >> v8;
      v13 = 32 - a3 - v8;
    }
    else
    {
      v13 = 32 - a3;
    }
LABEL_16:
    *a2 = v14 >> v13;
    v15 = *(_DWORD *)(a1 + 24) + a3;
    goto LABEL_17;
  }
  if ( !v8 )
  {
    v17 = *(_DWORD *)(*(_QWORD *)a1 + 4LL * v6);
    if ( a3 > 0x1F )
    {
      *a2 = v17;
      ++*(_DWORD *)(a1 + 20);
    }
    else
    {
      *a2 = v17 >> (32 - a3);
      *(_DWORD *)(a1 + 24) = a3;
    }
    return 1;
  }
  v10 = *(char **)a1;
  v11 = 32 - v8;
  v12 = 0xFFFFFFFF >> v8;
  v13 = 32 - v8 - a3;
  v14 = *(_DWORD *)(*(_QWORD *)a1 + 4LL * v6) & v12;
  if ( v11 > a3 )
    goto LABEL_16;
  *a2 = v14;
  v15 = a3 - v11;
  *(_QWORD *)(a1 + 20) = (unsigned int)(*(_DWORD *)(a1 + 20) + 1);
  if ( a3 != v11 )
  {
    v16 = *a2 << v15;
    *a2 = v16;
    *a2 = (*(_DWORD *)&v10[4 * *(unsigned int *)(a1 + 20)] >> (32 - v15)) | v16;
LABEL_17:
    *(_DWORD *)(a1 + 24) = v15;
  }
  return 1;
}

//----- (0000000000014D1C) ----------------------------------------------------
__int64 __fastcall sub_14D1C(char **a1)
{
  unsigned int v2; // w8
  __int64 v3; // x12
  unsigned int v4; // w10
  _DWORD *v5; // x13
  unsigned int v6; // w11
  int v7; // w9
  unsigned int v8; // w12
  unsigned int v9; // w13
  unsigned int i; // w15
  __int64 v11; // x23
  unsigned int *v12; // x21
  int *v13; // x22
  int v14; // w8
  unsigned int v15; // w8
  __int64 v16; // x9
  unsigned int *v17; // x8
  __int64 result; // x0
  __int64 v19; // x11
  int v20; // w9
  int v21; // w8
  int v22; // w10
  unsigned int v23; // w12
  char *v24; // x10
  __int64 v25; // x9
  unsigned __int64 v26; // x12
  int8x8_t *v27; // x14
  int8x8_t *v28; // x14
  unsigned __int64 v29; // x15
  unsigned __int64 v30; // d1
  unsigned int *v31; // x10
  __int64 v32; // x9
  unsigned int v33; // w8
  _QWORD v34[2]; // [xsp+0h] [xbp-40h] BYREF

  v34[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = *((_DWORD *)a1 + 5);
  if ( v2 )
  {
    v3 = *((unsigned int *)a1 + 8);
    if ( v2 > (unsigned int)v3 )
    {
      v4 = *((_DWORD *)a1 + 9);
      if ( v4 )
      {
        v5 = *a1;
        v6 = *((_DWORD *)a1 + 7);
        v7 = v3 + 1;
        *((_DWORD *)a1 + 8) = v3 + 1;
        if ( v4 <= 0x1F )
        {
          v8 = v5[v3];
          v9 = 24 - v4;
          for ( i = v4; i < 0x20; i += 8 )
          {
            v6 = ((unsigned __int8)v6 << 8) ^ FLAC__crc16_table[(unsigned __int8)(v8 >> v9) ^ (v6 >> 8)];
            v9 -= 8;
          }
          *((_DWORD *)a1 + 9) = v4 + ((31 - v4) & 0xFFFFFFF8) + 8;
        }
        LODWORD(v3) = v7;
        *((_DWORD *)a1 + 7) = v6;
        *((_DWORD *)a1 + 9) = 0;
      }
    }
    *((_DWORD *)a1 + 7) = (unsigned __int16)FLAC__crc16_update_words32(
                                              (unsigned int *)&(*a1)[4 * (unsigned int)v3],
                                              v2 - (unsigned int)v3,
                                              *((_DWORD *)a1 + 7));
    *((_DWORD *)a1 + 8) = 0;
    v11 = *((unsigned int *)a1 + 5);
    v12 = (unsigned int *)a1 + 3;
    v13 = (int *)(a1 + 2);
    v14 = *((_DWORD *)a1 + 3) - v11;
    if ( *((_DWORD *)a1 + 4) )
      ++v14;
    memmove(*a1, &(*a1)[4 * v11], (unsigned int)(4 * v14));
    v15 = *v12 - v11;
    *v12 = v15;
    *((_DWORD *)a1 + 5) = 0;
  }
  else
  {
    v12 = (unsigned int *)a1 + 3;
    v15 = *((_DWORD *)a1 + 3);
    v13 = (int *)(a1 + 2);
  }
  v16 = *((unsigned int *)a1 + 4);
  v34[0] = 4 * (*((_DWORD *)a1 + 2) - v15) - (unsigned int)v16;
  if ( !LODWORD(v34[0]) )
    return 0;
  v17 = (unsigned int *)&(*a1)[4 * v15];
  if ( (_DWORD)v16 )
    *v17 = bswap32(*v17);
  result = ((__int64 (__fastcall *)(char *, _QWORD *, char *))a1[5])((char *)v17 + v16, v34, a1[6]);
  if ( (_DWORD)result )
  {
    v19 = *v12;
    v20 = *v13;
    v21 = v34[0];
    v22 = 4 * v19;
    v23 = (unsigned int)(*v13 + 4 * v19 + LODWORD(v34[0]) + 3) >> 2;
    if ( (unsigned int)v19 < v23 )
    {
      v24 = *a1;
      v25 = v23;
      v26 = v23 - v19;
      if ( v26 < 4 )
        goto LABEL_22;
      v27 = (int8x8_t *)&v24[4 * v19];
      v19 += v26 & 0xFFFFFFFFFFFFFFFCLL;
      v28 = v27 + 1;
      v29 = v26 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v29 -= 4LL;
        v30 = vrev32_s8((int8x8_t)v28->n64_u64[0]).n64_u64[0];
        v28[-1].n64_u64[0] = vrev32_s8(v28[-1]).n64_u64[0];
        v28->n64_u64[0] = v30;
        v28 += 2;
      }
      while ( v29 );
      if ( v26 != (v26 & 0xFFFFFFFFFFFFFFFCLL) )
      {
LABEL_22:
        v31 = (unsigned int *)&v24[4 * v19];
        v32 = v25 - v19;
        do
        {
          --v32;
          *v31 = bswap32(*v31);
          ++v31;
        }
        while ( v32 );
      }
      v20 = *v13;
      v22 = 4 * *v12;
    }
    v33 = v20 + v21 + v22;
    result = 1;
    *v12 = v33 >> 2;
    *v13 = v33 & 3;
  }
  return result;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (0000000000014F8C) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_raw_int32(__int64 a1, _DWORD *a2, unsigned int a3)
{
  char v4; // w20
  __int64 result; // x0
  int v6; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v7; // [xsp+8h] [xbp-28h]

  v4 = a3;
  v7 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitreader_read_raw_uint32(a1, &v6, a3);
  if ( (_DWORD)result )
  {
    result = 1;
    *a2 = (v6 ^ (1 << (v4 - 1))) - (1 << (v4 - 1));
  }
  return result;
}

//----- (0000000000015004) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_raw_uint64(__int64 a1, unsigned __int64 *a2, unsigned int a3)
{
  __int64 result; // x0
  unsigned int v6; // w9
  unsigned __int64 v7; // x8
  unsigned int v8; // [xsp+0h] [xbp-30h] BYREF
  unsigned int v9; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v10; // [xsp+8h] [xbp-28h]

  v10 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a3 < 0x21 )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v8, a3);
    if ( !(_DWORD)result )
      return result;
    v7 = v8;
    goto LABEL_7;
  }
  result = FLAC__bitreader_read_raw_uint32(a1, &v9, a3 - 32);
  if ( (_DWORD)result )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v8, 0x20u);
    if ( (_DWORD)result )
    {
      v6 = v9;
      *a2 = (unsigned __int64)v9 << 32;
      v7 = v8 | ((unsigned __int64)v6 << 32);
LABEL_7:
      result = 1;
      *a2 = v7;
    }
  }
  return result;
}

//----- (00000000000150B8) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_uint32_little_endian(__int64 a1, int *a2)
{
  __int64 result; // x0
  int v5; // w22
  int v6; // w22
  int v7; // [xsp+0h] [xbp-30h] BYREF
  int v8; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v9; // [xsp+8h] [xbp-28h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = 0;
  result = FLAC__bitreader_read_raw_uint32(a1, &v7, 8u);
  if ( (_DWORD)result )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v8, 8u);
    if ( (_DWORD)result )
    {
      v5 = v7 | (v8 << 8);
      v7 = v5;
      result = FLAC__bitreader_read_raw_uint32(a1, &v8, 8u);
      if ( (_DWORD)result )
      {
        v6 = v5 | (v8 << 16);
        v7 = v6;
        result = FLAC__bitreader_read_raw_uint32(a1, &v8, 8u);
        if ( (_DWORD)result )
        {
          result = 1;
          v7 = v6 | (v8 << 24);
          *a2 = v7;
        }
      }
    }
  }
  return result;
}

//----- (0000000000015184) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_skip_bits_no_crc(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w19
  unsigned int v4; // w21
  unsigned int v5; // w21
  unsigned int v6; // w8
  int v8; // [xsp+0h] [xbp-30h] BYREF
  int v9; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v10; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v10 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a2 )
    return 1;
  if ( (*(_DWORD *)(a1 + 24) & 7) != 0 )
  {
    if ( 8 - (*(_DWORD *)(a1 + 24) & 7u) >= a2 )
      v4 = a2;
    else
      v4 = 8 - (*(_DWORD *)(a1 + 24) & 7);
    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(a1, &v8, v4) )
      return 0;
    v2 -= v4;
  }
  v5 = v2 >> 3;
  if ( v2 >> 3 )
  {
    while ( *(_DWORD *)(a1 + 24) )
    {
      if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(a1, &v9, 8u) )
        return 0;
      if ( !--v5 )
        goto LABEL_22;
    }
    if ( v5 < 4 )
      goto LABEL_20;
    do
    {
      while ( 1 )
      {
        v6 = *(_DWORD *)(a1 + 20);
        if ( v6 < *(_DWORD *)(a1 + 12) )
          break;
        if ( !(unsigned int)sub_14D1C((char **)a1) )
          return 0;
      }
      *(_DWORD *)(a1 + 20) = v6 + 1;
      v5 -= 4;
    }
    while ( v5 > 3 );
    if ( !v5 )
    {
LABEL_22:
      v2 &= 7u;
      return !v2 || (unsigned int)FLAC__bitreader_read_raw_uint32(a1, &v8, v2);
    }
LABEL_20:
    while ( (unsigned int)FLAC__bitreader_read_raw_uint32(a1, &v9, 8u) )
    {
      if ( !--v5 )
        goto LABEL_22;
    }
    return 0;
  }
  return !v2 || (unsigned int)FLAC__bitreader_read_raw_uint32(a1, &v8, v2);
}
// 15254: conditional instruction was optimized away because w21.4>=4u

//----- (00000000000152D4) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_skip_byte_block_aligned_no_crc(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w19
  __int64 result; // x0
  unsigned int v5; // w8
  int v6; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v7; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v7 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a2 )
    return 1;
  while ( *(_DWORD *)(a1 + 24) )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v6, 8u);
    if ( !(_DWORD)result )
      return result;
    if ( !--v2 )
      return 1;
  }
  if ( v2 < 4 )
    goto LABEL_15;
  do
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(a1 + 20);
      if ( v5 < *(_DWORD *)(a1 + 12) )
        break;
      result = sub_14D1C((char **)a1);
      if ( !(_DWORD)result )
        return result;
    }
    *(_DWORD *)(a1 + 20) = v5 + 1;
    v2 -= 4;
  }
  while ( v2 > 3 );
  if ( !v2 )
    return 1;
LABEL_15:
  while ( 1 )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v6, 8u);
    if ( !(_DWORD)result )
      break;
    if ( !--v2 )
      return 1;
  }
  return result;
}
// 15390: conditional instruction was optimized away because w19.4>=4u

//----- (00000000000153CC) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_byte_block_aligned_no_crc(__int64 a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // w19
  __int64 result; // x0
  __int64 v7; // x8
  char *v8; // x9
  int v9; // w8
  int v10; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v11; // [xsp+8h] [xbp-28h]

  v3 = a3;
  v11 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a3 )
    return 1;
  while ( *(_DWORD *)(a1 + 24) )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v10, 8u);
    if ( !(_DWORD)result )
      return result;
    --v3;
    *a2++ = v10;
    if ( !v3 )
      return 1;
  }
  if ( v3 < 4 )
    goto LABEL_13;
  do
  {
    while ( 1 )
    {
      v7 = *(unsigned int *)(a1 + 20);
      if ( (unsigned int)v7 < *(_DWORD *)(a1 + 12) )
        break;
      result = sub_14D1C((char **)a1);
      if ( !(_DWORD)result )
        return result;
    }
    v8 = *(char **)a1;
    *(_DWORD *)(a1 + 20) = v7 + 1;
    v3 -= 4;
    v9 = *(_DWORD *)&v8[4 * v7];
    a2[3] = v9;
    *a2 = HIBYTE(v9);
    a2[1] = BYTE2(v9);
    a2[2] = BYTE1(v9);
    a2 += 4;
  }
  while ( v3 > 3 );
  if ( !v3 )
    return 1;
LABEL_13:
  while ( 1 )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v10, 8u);
    if ( !(_DWORD)result )
      break;
    --v3;
    *a2++ = v10;
    if ( !v3 )
      return 1;
  }
  return result;
}
// 15494: conditional instruction was optimized away because w19.4>=4u

//----- (00000000000154EC) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_unary_unsigned(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // w8
  char *v5; // x10
  int v6; // w11
  unsigned int v7; // w8
  unsigned int v8; // w9
  bool v9; // cf
  unsigned int v10; // w10
  unsigned int v11; // w11
  __int64 result; // x0
  unsigned int v13; // w8
  unsigned int v14; // w8
  unsigned int v15; // w8
  unsigned int v16; // w8

  *a2 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 < *(_DWORD *)(a1 + 12) )
      {
        v5 = *(char **)a1;
        v6 = *(_DWORD *)(a1 + 24);
        do
        {
          v7 = *(_DWORD *)&v5[4 * v4] << v6;
          if ( v7 )
          {
            v14 = __clz(v7);
            *a2 += v14;
            v15 = v14 + *(_DWORD *)(a1 + 24) + 1;
            *(_DWORD *)(a1 + 24) = v15;
            result = 1;
            if ( v15 > 0x1F )
              *(_QWORD *)(a1 + 20) = (unsigned int)(*(_DWORD *)(a1 + 20) + 1);
            return result;
          }
          LOBYTE(v8) = 0;
          *a2 += 32 - v6;
          v4 = *(_DWORD *)(a1 + 20) + 1;
          v9 = v4 >= *(_DWORD *)(a1 + 12);
          v6 = 0;
          *(_QWORD *)(a1 + 20) = v4;
        }
        while ( !v9 );
        v10 = 8 * *(_DWORD *)(a1 + 16);
        v11 = v10;
        if ( v10 )
          break;
        goto LABEL_8;
      }
      v8 = *(_DWORD *)(a1 + 24);
      v10 = 8 * *(_DWORD *)(a1 + 16);
      v11 = v10 - v8;
      if ( v10 > v8 )
        break;
LABEL_8:
      result = sub_14D1C((char **)a1);
      if ( !(_DWORD)result )
        return result;
    }
    v13 = (*(_DWORD *)(*(_QWORD *)a1 + 4LL * v4) & (-1 << (32 - v10))) << v8;
    if ( v13 )
      break;
    *a2 += v11;
    *(_DWORD *)(a1 + 24) = v10;
    result = sub_14D1C((char **)a1);
    if ( !(_DWORD)result )
      return result;
  }
  v16 = __clz(v13);
  result = 1;
  *a2 += v16;
  *(_DWORD *)(a1 + 24) += v16 + 1;
  return result;
}

//----- (0000000000015670) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_rice_signed(__int64 a1, unsigned int *a2, unsigned int a3)
{
  __int64 result; // x0
  _QWORD v7[2]; // [xsp+0h] [xbp-30h] BYREF

  v7[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7[0] = 0;
  result = FLAC__bitreader_read_unary_unsigned(a1, v7);
  if ( (_DWORD)result )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, (_DWORD *)v7 + 1, a3);
    if ( (_DWORD)result )
    {
      result = 1;
      *a2 = (((LODWORD(v7[0]) << a3) | HIDWORD(v7[0])) << 31 >> 31)
          ^ ((unsigned int)((LODWORD(v7[0]) << a3) | HIDWORD(v7[0])) >> 1);
    }
  }
  return result;
}

//----- (0000000000015704) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_rice_signed_block(__int64 a1, unsigned int *a2, int a3, unsigned int a4)
{
  unsigned int *v4; // x20
  unsigned __int64 v7; // x23
  unsigned int v8; // w8
  unsigned int v9; // w9
  int v10; // w13
  unsigned int v11; // w11
  __int64 v12; // x12
  unsigned int v13; // w14
  int v14; // w13
  unsigned int v15; // w24
  unsigned int v16; // w15
  unsigned int v17; // w15
  unsigned int v18; // w14
  unsigned int v19; // w25
  unsigned int v20; // w15
  unsigned int v21; // w10
  _BOOL4 v22; // w11
  _BOOL4 v23; // w9
  unsigned int v24; // w8
  unsigned int v25; // w9
  __int64 result; // x0
  unsigned int v27; // [xsp+0h] [xbp-50h] BYREF
  unsigned int v28; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v29; // [xsp+8h] [xbp-48h]

  v4 = a2;
  v7 = (unsigned __int64)&a2[a3];
  v29 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a4 )
  {
    v8 = *(_DWORD *)(a1 + 20);
    v9 = *(_DWORD *)(a1 + 12);
    if ( v8 >= v9 )
    {
      v15 = 0;
      goto LABEL_27;
    }
LABEL_3:
    v10 = *(_DWORD *)(a1 + 24);
    v11 = 32 - v10;
    if ( (unsigned __int64)v4 < v7 )
    {
      v12 = *(_QWORD *)a1;
      v13 = *(_DWORD *)(*(_QWORD *)a1 + 4LL * v8) << v10;
      v14 = 32 - a4;
      while ( v13 )
      {
        v15 = __clz(v13);
        LOBYTE(v16) = v15;
LABEL_10:
        v17 = 2 * (v13 << v16);
        v18 = ((_BYTE)v11 + 31 - (_BYTE)v15) & 0x1F;
        v11 = v18 - a4;
        v19 = v17 >> v14;
        v27 = v15;
        if ( v18 >= a4 )
        {
          v13 = v17 << a4;
        }
        else
        {
          if ( ++v8 >= v9 )
          {
            *(_DWORD *)(a1 + 20) = v8;
            *(_DWORD *)(a1 + 24) = 0;
            goto LABEL_29;
          }
          v20 = *(_DWORD *)(v12 + 4LL * v8);
          v11 = v18 + v14;
          v19 |= v20 >> (v18 + v14);
          v13 = v20 << (a4 - v18);
        }
        v28 = v19;
        *v4++ = -((v19 | (v15 << a4)) & 1) ^ ((v19 | (v15 << a4)) >> 1);
        if ( (unsigned __int64)v4 >= v7 )
          goto LABEL_15;
      }
      v15 = v11;
      while ( ++v8 < v9 )
      {
        v13 = *(_DWORD *)(v12 + 4LL * v8);
        v16 = __clz(v13);
        v15 += v16;
        if ( v13 )
          goto LABEL_10;
      }
      *(_DWORD *)(a1 + 20) = v8;
      *(_DWORD *)(a1 + 24) = 0;
LABEL_27:
      while ( 1 )
      {
        result = FLAC__bitreader_read_unary_unsigned(a1, &v27);
        if ( !(_DWORD)result )
          return result;
        v19 = 0;
        v18 = 0;
        v15 += v27;
        v27 = v15;
LABEL_29:
        result = FLAC__bitreader_read_raw_uint32(a1, &v28, a4 - v18);
        if ( !(_DWORD)result )
          return result;
        v28 |= v19;
        *v4++ = -(((v15 << a4) | v28) & 1) ^ (((v15 << a4) | v28) >> 1);
        v8 = *(_DWORD *)(a1 + 20);
        v9 = *(_DWORD *)(a1 + 12);
        if ( (unsigned __int64)v4 < v7 )
        {
          v15 = 0;
          if ( v8 >= v9 )
            continue;
        }
        goto LABEL_3;
      }
    }
LABEL_15:
    v21 = 32 - v11;
    v22 = v11 == 0;
    v23 = v8 < v9;
    v24 = v8 + (v23 && v22);
    if ( v23 && v22 )
      v25 = 0;
    else
      v25 = v21;
    *(_DWORD *)(a1 + 20) = v24;
    *(_DWORD *)(a1 + 24) = v25;
    return 1;
  }
  if ( !a3 )
    return 1;
  while ( 1 )
  {
    result = FLAC__bitreader_read_unary_unsigned(a1, &v27);
    if ( !(_DWORD)result )
      break;
    *v4++ = -(v27 & 1) ^ (v27 >> 1);
    if ( (unsigned __int64)v4 >= v7 )
      return 1;
  }
  return result;
}

//----- (0000000000015940) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_utf8_uint32(__int64 a1, int *a2, __int64 a3, _DWORD *a4)
{
  __int64 result; // x0
  int v9; // w8
  __int64 v10; // x9
  int v11; // w24
  int v12; // w25
  char v13; // w8
  __int64 v14; // x9
  int v15; // w11
  int v16; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v17; // [xsp+8h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
  if ( !(_DWORD)result )
    return result;
  v9 = v16;
  if ( a3 )
  {
    v10 = (unsigned int)*a4;
    *a4 = v10 + 1;
    *(_BYTE *)(a3 + v10) = v9;
  }
  if ( (v9 & 0x80) == 0 )
  {
LABEL_32:
    result = 1;
    *a2 = v9;
    return result;
  }
  if ( (v9 & 0xC0) != 0 && (v9 & 0x20) == 0 )
  {
    v11 = 1;
    v12 = v9 & 0x1F;
    if ( a3 )
      goto LABEL_8;
LABEL_15:
    while ( 1 )
    {
      result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
      if ( !(_DWORD)result )
        return result;
      if ( (v16 & 0xC0) != 0x80 )
        goto LABEL_31;
      v9 = v16 & 0x3F | (v12 << 6);
      --v11;
      v12 = v9;
      if ( !v11 )
        goto LABEL_32;
    }
  }
  if ( (v9 & 0xE0) != 0 && (v9 & 0x10) == 0 )
  {
    v11 = 2;
    v12 = v9 & 0xF;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xF0) != 0 && (v9 & 8) == 0 )
  {
    v11 = 3;
    v12 = v9 & 7;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xF8) != 0 && (v9 & 4) == 0 )
  {
    v11 = 4;
    v12 = v9 & 3;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xFC) == 0 || (v9 & 2) != 0 )
  {
LABEL_31:
    v9 = -1;
    goto LABEL_32;
  }
  v11 = 5;
  v12 = v9 & 1;
  if ( !a3 )
    goto LABEL_15;
LABEL_8:
  while ( 1 )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
    if ( !(_DWORD)result )
      return result;
    v13 = v16;
    v14 = (unsigned int)*a4;
    v15 = v16 & 0xC0;
    *a4 = v14 + 1;
    *(_BYTE *)(a3 + v14) = v13;
    if ( v15 != 128 )
      goto LABEL_31;
    v9 = v13 & 0x3F | (v12 << 6);
    --v11;
    v12 = v9;
    if ( !v11 )
      goto LABEL_32;
  }
}

//----- (0000000000015AF8) ----------------------------------------------------
__int64 __fastcall FLAC__bitreader_read_utf8_uint64(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4)
{
  __int64 result; // x0
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x25
  int v12; // w24
  char v13; // w8
  __int64 v14; // x9
  int v15; // w11
  unsigned int v16; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v17; // [xsp+8h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
  if ( !(_DWORD)result )
    return result;
  v9 = v16;
  if ( a3 )
  {
    v10 = (unsigned int)*a4;
    *a4 = v10 + 1;
    *(_BYTE *)(a3 + v10) = v9;
  }
  if ( (v9 & 0x80) == 0 )
  {
LABEL_36:
    result = 1;
    *a2 = v9;
    return result;
  }
  if ( (v9 & 0xC0) != 0 && (v9 & 0x20) == 0 )
  {
    v11 = v9 & 0x1F;
    v12 = 1;
    if ( a3 )
      goto LABEL_8;
LABEL_15:
    while ( 1 )
    {
      result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
      if ( !(_DWORD)result )
        return result;
      if ( (v16 & 0xC0) != 0x80 )
        goto LABEL_35;
      v9 = v16 & 0x3F | (unsigned __int64)(v11 << 6);
      --v12;
      v11 = v9;
      if ( !v12 )
        goto LABEL_36;
    }
  }
  if ( (v9 & 0xE0) != 0 && (v9 & 0x10) == 0 )
  {
    v11 = v9 & 0xF;
    v12 = 2;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xF0) != 0 && (v9 & 8) == 0 )
  {
    v11 = v9 & 7;
    v12 = 3;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xF8) != 0 && (v9 & 4) == 0 )
  {
    v11 = v9 & 3;
    v12 = 4;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xFC) != 0 && (v9 & 2) == 0 )
  {
    v11 = v9 & 1;
    v12 = 5;
    if ( !a3 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (v9 & 0xFE) == 0 || (v9 & 1) != 0 )
  {
LABEL_35:
    v9 = -1;
    goto LABEL_36;
  }
  v11 = 0;
  v12 = 6;
  if ( !a3 )
    goto LABEL_15;
LABEL_8:
  while ( 1 )
  {
    result = FLAC__bitreader_read_raw_uint32(a1, &v16, 8u);
    if ( !(_DWORD)result )
      return result;
    v13 = v16;
    v14 = (unsigned int)*a4;
    v15 = v16 & 0xC0;
    *a4 = v14 + 1;
    *(_BYTE *)(a3 + v14) = v13;
    if ( v15 != 128 )
      goto LABEL_35;
    v9 = v13 & 0x3F | (unsigned __int64)(v11 << 6);
    --v12;
    v11 = v9;
    if ( !v12 )
      goto LABEL_36;
  }
}

//----- (0000000000015CC0) ----------------------------------------------------
void *FLAC__bitwriter_new()
{
  return calloc(1u, 0x18u);
}

//----- (0000000000015CCC) ----------------------------------------------------
void __fastcall FLAC__bitwriter_delete(void **a1)
{
  void *v2; // x0

  v2 = *a1;
  if ( v2 )
    free(v2);
  free(a1);
}

//----- (0000000000015CF8) ----------------------------------------------------
void __fastcall FLAC__bitwriter_free(__int64 a1)
{
  void *v2; // x0

  v2 = *(void **)a1;
  if ( v2 )
    free(v2);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = 0;
}

//----- (0000000000015D2C) ----------------------------------------------------
bool __fastcall FLAC__bitwriter_init(__int64 a1)
{
  void *v2; // x0

  *(_DWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 12) = 0x2000;
  v2 = malloc(0x8000u);
  *(_QWORD *)a1 = v2;
  return v2 != 0;
}

//----- (0000000000015D70) ----------------------------------------------------
__int64 __fastcall FLAC__bitwriter_clear(__int64 result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

//----- (0000000000015D78) ----------------------------------------------------
size_t __fastcall FLAC__bitwriter_dump(__int64 a1, FILE *a2)
{
  size_t result; // x0
  unsigned __int64 v5; // x21
  int i; // w25
  unsigned int v7; // w8
  unsigned int v8; // w22
  int v9; // w23

  if ( !a1 )
    return fwrite("bitwriter is NULL\n", 0x12u, 1u, a2);
  result = fprintf(
             a2,
             "bitwriter: capacity=%u words=%u bits=%u total_bits=%u\n",
             *(_DWORD *)(a1 + 12),
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 20) + 32 * *(_DWORD *)(a1 + 16));
  if ( *(_DWORD *)(a1 + 16) )
  {
    v5 = 0;
    do
    {
      fprintf(a2, "%08X: ", v5);
      for ( i = 31; i != -1; --i )
        fprintf(a2, "%01d", (*(_DWORD *)(*(_QWORD *)a1 + 4 * v5) & (1 << i)) != 0);
      result = fputc(10, a2);
      ++v5;
    }
    while ( v5 < *(unsigned int *)(a1 + 16) );
    if ( !*(_DWORD *)(a1 + 20) )
      return result;
  }
  else
  {
    LODWORD(v5) = 0;
    if ( !*(_DWORD *)(a1 + 20) )
      return result;
  }
  fprintf(a2, "%08X: ", v5);
  v7 = *(_DWORD *)(a1 + 20);
  if ( v7 )
  {
    v8 = 0;
    v9 = -1;
    do
    {
      fprintf(a2, "%01d", (*(_DWORD *)(a1 + 8) & (1 << (v7 + v9))) != 0);
      v7 = *(_DWORD *)(a1 + 20);
      ++v8;
      --v9;
    }
    while ( v7 > v8 );
  }
  return fputc(10, a2);
}

//----- (0000000000015F10) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_get_write_crc16(__int64 a1, _WORD *a2)
{
  void *result; // x0
  __int64 v4; // [xsp+8h] [xbp-28h] BYREF
  unsigned __int8 *v5[2]; // [xsp+10h] [xbp-20h] BYREF

  v5[1] = *(unsigned __int8 **)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitwriter_get_buffer(a1, v5, &v4);
  if ( (_DWORD)result )
  {
    *a2 = FLAC__crc16(v5[0], v4);
    return &dword_0 + 1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000015F78) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_get_buffer(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // w8
  void *result; // x0
  unsigned int v8; // w9
  _DWORD *v9; // x23
  unsigned int v10; // w11
  unsigned int v11; // w10
  void *v12; // x22
  int v13; // w8
  unsigned int v14; // w24
  void *v15; // x10

  v4 = *(_DWORD *)(a1 + 20);
  if ( (v4 & 7) != 0 )
    return 0;
  if ( v4 )
  {
    v9 = (_DWORD *)(a1 + 16);
    v8 = *(_DWORD *)(a1 + 16);
    if ( v8 == *(_DWORD *)(a1 + 12) )
    {
      v10 = v4 + 63;
      v11 = v8 + ((unsigned int)(v4 + 63) >> 5);
      if ( v11 > v8 )
      {
        v12 = *(void **)a1;
        v13 = 1024 - ((v10 >> 5) & 0x3FF);
        if ( ((v10 >> 5) & 0x3FF) == 0 )
          v13 = 0;
        v14 = v13 + v11;
        if ( v13 + v11 )
        {
          result = realloc(*(void **)a1, 4LL * v14);
          if ( !result )
          {
            free(v12);
            return 0;
          }
        }
        else
        {
          result = realloc(*(void **)a1, 0);
          if ( !result )
            return result;
        }
        v8 = *(_DWORD *)(a1 + 16);
        v4 = *(_DWORD *)(a1 + 20);
        *(_QWORD *)a1 = result;
        *(_DWORD *)(a1 + 12) = v14;
      }
    }
    v15 = *(void **)a1;
    *(_DWORD *)(*(_QWORD *)a1 + 4LL * v8) = bswap32(*(_DWORD *)(a1 + 8) << (32 - v4));
    v4 = *(_DWORD *)(a1 + 20) >> 3;
  }
  else
  {
    v15 = *(void **)a1;
    v9 = (_DWORD *)(a1 + 16);
  }
  *a2 = v15;
  result = &dword_0 + 1;
  *a3 = (unsigned int)(v4 + 4 * *v9);
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000016094) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_get_write_crc8(__int64 a1, _BYTE *a2)
{
  void *result; // x0
  __int64 v4; // [xsp+8h] [xbp-28h] BYREF
  char *v5[2]; // [xsp+10h] [xbp-20h] BYREF

  v5[1] = *(char **)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitwriter_get_buffer(a1, v5, &v4);
  if ( (_DWORD)result )
  {
    *a2 = FLAC__crc8(v5[0], v4);
    return &dword_0 + 1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000160FC) ----------------------------------------------------
bool __fastcall FLAC__bitwriter_is_byte_aligned(__int64 a1)
{
  return (*(_BYTE *)(a1 + 20) & 7) == 0;
}

//----- (000000000001610C) ----------------------------------------------------
__int64 __fastcall FLAC__bitwriter_get_input_bits_unconsumed(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 20) + 32 * *(_DWORD *)(a1 + 16));
}

//----- (0000000000016118) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_zeroes(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w19
  int v4; // w8
  unsigned int v5; // w9
  unsigned int v6; // w8
  bool v7; // cf
  unsigned int v8; // w9
  void *v9; // x21
  bool v10; // zf
  int v11; // w9
  unsigned int v12; // w22
  void *result; // x0
  int v14; // w10
  int v15; // w11
  unsigned int v16; // w9
  int v17; // w10
  unsigned int v18; // w8
  __int64 v19; // x10
  _DWORD *v20; // x9
  _DWORD *v21; // x8
  unsigned int i; // w9
  __int64 v23; // x10

  v2 = a2;
  if ( a2 )
  {
    v5 = *(_DWORD *)(a1 + 12);
    v4 = *(_DWORD *)(a1 + 16);
    if ( v5 <= v4 + a2 )
    {
      v6 = v4 + ((a2 + *(_DWORD *)(a1 + 20) + 31) >> 5);
      v7 = v6 >= v5;
      v8 = v6 - v5;
      if ( v8 != 0 && v7 )
      {
        v9 = *(void **)a1;
        v10 = (v8 & 0x3FF) == 0;
        v11 = 1024 - (v8 & 0x3FF);
        if ( v10 )
          v11 = 0;
        v12 = v11 + v6;
        if ( v11 + v6 )
        {
          result = realloc(*(void **)a1, 4LL * v12);
          if ( !result )
          {
            free(v9);
            return 0;
          }
        }
        else
        {
          result = realloc(*(void **)a1, 0);
          if ( !result )
            return result;
        }
        *(_QWORD *)a1 = result;
        *(_DWORD *)(a1 + 12) = v12;
      }
    }
    v14 = *(_DWORD *)(a1 + 20);
    if ( !v14 )
      goto LABEL_18;
    v15 = *(_DWORD *)(a1 + 8);
    if ( 32 - v14 >= v2 )
      v16 = v2;
    else
      v16 = 32 - v14;
    v17 = v16 + v14;
    v18 = v15 << v16;
    *(_DWORD *)(a1 + 8) = v15 << v16;
    *(_DWORD *)(a1 + 20) = v17;
    if ( v17 == 32 )
    {
      v19 = *(unsigned int *)(a1 + 16);
      v2 -= v16;
      v20 = *(_DWORD **)a1;
      *(_DWORD *)(a1 + 16) = v19 + 1;
      v20[v19] = bswap32(v18);
      *(_DWORD *)(a1 + 20) = 0;
LABEL_18:
      if ( v2 >= 0x20 )
      {
        v21 = *(_DWORD **)a1;
        for ( i = v2; i > 0x1F; i -= 32 )
        {
          v23 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v23 + 1;
          v21[v23] = 0;
        }
        v2 &= 0x1Fu;
      }
      if ( v2 )
      {
        *(_DWORD *)(a1 + 8) = 0;
        *(_DWORD *)(a1 + 20) = v2;
      }
    }
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000016268) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_raw_uint32(__int64 a1, unsigned int a2, unsigned int a3)
{
  void *result; // x0
  void *v7; // x22
  int v8; // w8
  unsigned int v9; // w9
  unsigned int v10; // w8
  bool v11; // cf
  unsigned int v12; // w9
  int v13; // w9
  unsigned int v14; // w23
  int v15; // w9
  int v16; // w8
  int v17; // w8
  int v18; // w9
  __int64 v19; // x11
  unsigned int v20; // w8
  __int64 v21; // x8

  result = 0;
  if ( a1 )
  {
    if ( a3 >= 0x20 || a2 >> a3 == 0 )
    {
      result = 0;
      if ( a3 <= 0x20 )
      {
        v7 = *(void **)a1;
        if ( *(_QWORD *)a1 )
        {
          if ( a3 )
          {
            v9 = *(_DWORD *)(a1 + 12);
            v8 = *(_DWORD *)(a1 + 16);
            if ( v9 <= v8 + a3 )
            {
              v10 = v8 + ((a3 + *(_DWORD *)(a1 + 20) + 31) >> 5);
              v11 = v10 >= v9;
              v12 = v10 - v9;
              if ( v12 != 0 && v11 )
              {
                if ( (v12 & 0x3FF) != 0 )
                  v13 = 1024 - (v12 & 0x3FF);
                else
                  v13 = 0;
                v14 = v13 + v10;
                if ( v13 + v10 )
                {
                  result = realloc(*(void **)a1, 4LL * v14);
                  if ( !result )
                  {
                    free(v7);
                    return 0;
                  }
                }
                else
                {
                  result = realloc(*(void **)a1, 0);
                  if ( !result )
                    return result;
                }
                v7 = result;
                *(_QWORD *)a1 = result;
                *(_DWORD *)(a1 + 12) = v14;
              }
            }
            v15 = *(_DWORD *)(a1 + 20);
            v16 = 32 - v15;
            if ( 32 - v15 <= a3 )
            {
              if ( v15 )
              {
                v18 = *(_DWORD *)(a1 + 8);
                v19 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = a3 - v16;
                v20 = (v18 << v16) | (a2 >> (a3 - v16));
                *(_DWORD *)(a1 + 16) = v19 + 1;
                *((_DWORD *)v7 + v19) = HIBYTE(v20)
                                      | ((unsigned __int8)v20 << 24)
                                      | (v20 >> 8) & 0xFF00
                                      | (BYTE1(v20) << 16);
                *(_DWORD *)(a1 + 8) = a2;
              }
              else
              {
                v21 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v21 + 1;
                *((_DWORD *)v7 + v21) = bswap32(a2);
              }
            }
            else
            {
              v17 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 20) = v15 + a3;
              *(_DWORD *)(a1 + 8) = (v17 << a3) | a2;
            }
          }
          return &dword_0 + 1;
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000163F0) ----------------------------------------------------
_DWORD *__fastcall FLAC__bitwriter_write_raw_int32(__int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // w20
  _DWORD *result; // x0
  _DWORD *v7; // x22
  int v8; // w8
  unsigned int v9; // w9
  unsigned int v10; // w8
  bool v11; // cf
  unsigned int v12; // w9
  int v13; // w9
  unsigned int v14; // w23
  int v15; // w9
  int v16; // w8
  int v17; // w8
  int v18; // w9
  __int64 v19; // x11
  unsigned int v20; // w8
  __int64 v21; // x8

  v4 = a2;
  if ( a3 <= 0x1F )
    v4 = a2 & ~(-1 << a3);
  if ( !a1 )
    return 0;
  result = 0;
  if ( a3 <= 0x20 )
  {
    v7 = *(_DWORD **)a1;
    if ( *(_QWORD *)a1 )
    {
      if ( !a3 )
        return &dword_0 + 1;
      v9 = *(_DWORD *)(a1 + 12);
      v8 = *(_DWORD *)(a1 + 16);
      if ( v9 > v8 + a3
        || (v10 = v8 + ((a3 + *(_DWORD *)(a1 + 20) + 31) >> 5), v11 = v10 >= v9, v12 = v10 - v9, v12 == 0 || !v11) )
      {
LABEL_19:
        v15 = *(_DWORD *)(a1 + 20);
        v16 = 32 - v15;
        if ( 32 - v15 <= a3 )
        {
          if ( v15 )
          {
            v18 = *(_DWORD *)(a1 + 8);
            v19 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 20) = a3 - v16;
            v20 = (v18 << v16) | (v4 >> (a3 - v16));
            *(_DWORD *)(a1 + 16) = v19 + 1;
            v7[v19] = HIBYTE(v20) | ((unsigned __int8)v20 << 24) | (v20 >> 8) & 0xFF00 | (BYTE1(v20) << 16);
            *(_DWORD *)(a1 + 8) = v4;
          }
          else
          {
            v21 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v21 + 1;
            v7[v21] = bswap32(v4);
          }
        }
        else
        {
          v17 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v15 + a3;
          *(_DWORD *)(a1 + 8) = (v17 << a3) | v4;
        }
        return &dword_0 + 1;
      }
      if ( (v12 & 0x3FF) != 0 )
        v13 = 1024 - (v12 & 0x3FF);
      else
        v13 = 0;
      v14 = v13 + v10;
      if ( v13 + v10 )
      {
        result = realloc(*(void **)a1, 4LL * v14);
        if ( !result )
        {
          free(v7);
          return 0;
        }
      }
      else
      {
        result = realloc(*(void **)a1, 0);
        if ( !result )
          return result;
      }
      v7 = result;
      *(_QWORD *)a1 = result;
      *(_DWORD *)(a1 + 12) = v14;
      goto LABEL_19;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001656C) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_raw_uint64(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // w20
  void *result; // x0
  void *v6; // x21
  int v7; // w9
  unsigned int v8; // w10
  int v9; // w8
  unsigned int v10; // w9
  bool v11; // cf
  unsigned int v12; // w10
  int v13; // w8
  unsigned int v14; // w22
  __int64 v15; // x11
  unsigned int v16; // w8
  __int64 v17; // x8

  v3 = a2;
  if ( a3 < 0x21 )
    return FLAC__bitwriter_write_raw_uint32(a1, a2, a3);
  result = FLAC__bitwriter_write_raw_uint32(a1, HIDWORD(a2), a3 - 32);
  if ( !(_DWORD)result )
    return result;
  if ( !a1 )
    return 0;
  v6 = *(void **)a1;
  if ( !*(_QWORD *)a1 )
    return 0;
  v8 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 16);
  if ( v8 <= v7 + 32 )
  {
    v9 = *(_DWORD *)(a1 + 20);
    v10 = v7 + ((unsigned int)(v9 + 63) >> 5);
    v11 = v10 >= v8;
    v12 = v10 - v8;
    if ( v12 == 0 || !v11 )
      goto LABEL_19;
    v13 = 1024 - (v12 & 0x3FF);
    if ( (v12 & 0x3FF) == 0 )
      v13 = 0;
    v14 = v13 + v10;
    if ( v13 + v10 )
    {
      result = realloc(*(void **)a1, 4LL * v14);
      if ( !result )
      {
        free(v6);
        return 0;
      }
    }
    else
    {
      result = realloc(*(void **)a1, 0);
      if ( !result )
        return result;
    }
    v6 = result;
    *(_QWORD *)a1 = result;
    *(_DWORD *)(a1 + 12) = v14;
  }
  v9 = *(_DWORD *)(a1 + 20);
LABEL_19:
  if ( (unsigned int)(32 - v9) < 0x21 )
  {
    if ( v9 )
    {
      v15 = *(unsigned int *)(a1 + 16);
      v16 = (*(_DWORD *)(a1 + 8) << (32 - v9)) | (v3 >> v9);
      *(_DWORD *)(a1 + 16) = v15 + 1;
      *((_DWORD *)v6 + v15) = HIBYTE(v16) | ((unsigned __int8)v16 << 24) | (v16 >> 8) & 0xFF00 | (BYTE1(v16) << 16);
      *(_DWORD *)(a1 + 8) = v3;
    }
    else
    {
      v17 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v17 + 1;
      *((_DWORD *)v6 + v17) = bswap32(v3);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = -1;
    *(_DWORD *)(a1 + 20) = v9 + 32;
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (000000000001670C) ----------------------------------------------------
_DWORD *__fastcall FLAC__bitwriter_write_raw_uint32_little_endian(_DWORD *result, unsigned int a2)
{
  _DWORD *v3; // x19
  _DWORD *v4; // x21
  int v5; // w8
  unsigned int v6; // w9
  unsigned int v7; // w8
  bool v8; // cf
  unsigned int v9; // w9
  int v10; // w9
  unsigned int v11; // w22
  int v12; // w10
  int v13; // w9
  int v14; // w9
  int v15; // w8
  unsigned int v16; // w9
  unsigned int v17; // w8
  unsigned int v18; // w9
  int v19; // w9
  unsigned int v20; // w22
  int v21; // w10
  __int64 v22; // x12
  unsigned int v23; // w9
  __int64 v24; // x9
  int v25; // w10
  int v26; // w9
  int v27; // w9
  int v28; // w8
  unsigned int v29; // w10
  int v30; // w9
  unsigned int v31; // w8
  unsigned int v32; // w10
  int v33; // w9
  unsigned int v34; // w22
  int v35; // w10
  __int64 v36; // x12
  unsigned int v37; // w9
  __int64 v38; // x9
  int v39; // w10
  int v40; // w10
  int v41; // w8
  unsigned int v42; // w10
  int v43; // w9
  unsigned int v44; // w8
  unsigned int v45; // w10
  int v46; // w9
  unsigned int v47; // w22
  int v48; // w9
  __int64 v49; // x12
  unsigned int v50; // w9
  __int64 v51; // x9
  int v52; // w10
  unsigned int v53; // w8
  int v54; // w10
  int v55; // w9
  __int64 v56; // x12
  unsigned int v57; // w9
  __int64 v58; // x9

  v3 = result;
  if ( !result )
    return result;
  v4 = *(_DWORD **)result;
  if ( !*(_QWORD *)result )
    return 0;
  v6 = result[3];
  v5 = result[4];
  if ( v6 <= v5 + 8 )
  {
    v7 = v5 + ((unsigned int)(result[5] + 39) >> 5);
    v8 = v7 >= v6;
    v9 = v7 - v6;
    if ( v9 != 0 && v8 )
    {
      if ( (v9 & 0x3FF) != 0 )
        v10 = 1024 - (v9 & 0x3FF);
      else
        v10 = 0;
      v11 = v10 + v7;
      if ( v10 + v7 )
      {
        result = realloc(*(void **)result, 4LL * v11);
        if ( !result )
          goto LABEL_58;
      }
      else
      {
        result = realloc(*(void **)result, 0);
        if ( !result )
          return result;
      }
      v4 = result;
      *(_QWORD *)v3 = result;
      v3[3] = v11;
    }
  }
  v12 = v3[5];
  v13 = 32 - v12;
  if ( (unsigned int)(32 - v12) < 9 )
  {
    if ( v12 )
    {
      v21 = v3[2];
      v22 = (unsigned int)v3[4];
      v3[5] = 8 - v13;
      v23 = (v21 << v13) | ((unsigned __int8)a2 >> (8 - v13));
      v3[4] = v22 + 1;
      v4[v22] = HIBYTE(v23) | ((unsigned __int8)v23 << 24) | (v23 >> 8) & 0xFF00 | (BYTE1(v23) << 16);
      v3[2] = (unsigned __int8)a2;
      if ( v4 )
        goto LABEL_17;
    }
    else
    {
      v24 = (unsigned int)v3[4];
      v3[4] = v24 + 1;
      v4[v24] = bswap32((unsigned __int8)a2);
      if ( v4 )
        goto LABEL_17;
    }
    return 0;
  }
  v14 = v3[2];
  v3[5] = v12 + 8;
  v3[2] = (unsigned __int8)a2 | (v14 << 8);
  if ( !v4 )
    return 0;
LABEL_17:
  v16 = v3[3];
  v15 = v3[4];
  if ( v16 <= v15 + 8 )
  {
    v17 = v15 + ((unsigned int)(v3[5] + 39) >> 5);
    v8 = v17 >= v16;
    v18 = v17 - v16;
    if ( v18 != 0 && v8 )
    {
      if ( (v18 & 0x3FF) != 0 )
        v19 = 1024 - (v18 & 0x3FF);
      else
        v19 = 0;
      v20 = v19 + v17;
      if ( v19 + v17 )
      {
        result = realloc(v4, 4LL * v20);
        if ( !result )
          goto LABEL_58;
      }
      else
      {
        result = realloc(v4, 0);
        if ( !result )
          return result;
      }
      v4 = result;
      *(_QWORD *)v3 = result;
      v3[3] = v20;
    }
  }
  v25 = v3[5];
  v26 = 32 - v25;
  if ( (unsigned int)(32 - v25) < 9 )
  {
    if ( v25 )
    {
      v35 = v3[2];
      v36 = (unsigned int)v3[4];
      v3[5] = 8 - v26;
      v37 = (v35 << v26) | (BYTE1(a2) >> (8 - v26));
      v3[4] = v36 + 1;
      v4[v36] = HIBYTE(v37) | ((unsigned __int8)v37 << 24) | (v37 >> 8) & 0xFF00 | (BYTE1(v37) << 16);
      v3[2] = BYTE1(a2);
    }
    else
    {
      v38 = (unsigned int)v3[4];
      v3[4] = v38 + 1;
      v4[v38] = bswap32(BYTE1(a2));
    }
  }
  else
  {
    v27 = v3[2];
    v3[5] = v25 + 8;
    v3[2] = BYTE1(a2) | (v27 << 8);
  }
  v29 = v3[3];
  v28 = v3[4];
  if ( v29 > v28 + 8 )
    goto LABEL_48;
  v30 = v3[5];
  v31 = v28 + ((unsigned int)(v30 + 39) >> 5);
  v8 = v31 >= v29;
  v32 = v31 - v29;
  if ( v32 != 0 && v8 )
  {
    v33 = 1024 - (v32 & 0x3FF);
    if ( (v32 & 0x3FF) == 0 )
      v33 = 0;
    v34 = v33 + v31;
    if ( v33 + v31 )
    {
      result = realloc(v4, 4LL * v34);
      if ( !result )
        goto LABEL_58;
    }
    else
    {
      result = realloc(v4, 0);
      if ( !result )
        return result;
    }
    v4 = result;
    *(_QWORD *)v3 = result;
    v3[3] = v34;
LABEL_48:
    v30 = v3[5];
  }
  v39 = 32 - v30;
  if ( (unsigned int)(32 - v30) < 9 )
  {
    if ( v30 )
    {
      v48 = v3[2];
      v49 = (unsigned int)v3[4];
      v3[5] = 8 - v39;
      v50 = (v48 << v39) | (BYTE2(a2) >> (8 - v39));
      v3[4] = v49 + 1;
      v4[v49] = HIBYTE(v50) | ((unsigned __int8)v50 << 24) | (v50 >> 8) & 0xFF00 | (BYTE1(v50) << 16);
      v3[2] = BYTE2(a2);
    }
    else
    {
      v51 = (unsigned int)v3[4];
      v3[4] = v51 + 1;
      v4[v51] = bswap32(BYTE2(a2));
    }
  }
  else
  {
    v40 = v3[2];
    v3[5] = v30 + 8;
    v3[2] = BYTE2(a2) | (v40 << 8);
  }
  v42 = v3[3];
  v41 = v3[4];
  if ( v42 <= v41 + 8 )
  {
    v43 = v3[5];
    v44 = v41 + ((unsigned int)(v43 + 39) >> 5);
    v8 = v44 >= v42;
    v45 = v44 - v42;
    if ( v45 == 0 || !v8 )
      goto LABEL_65;
    v46 = 1024 - (v45 & 0x3FF);
    if ( (v45 & 0x3FF) == 0 )
      v46 = 0;
    v47 = v46 + v44;
    if ( v46 + v44 )
    {
      result = realloc(v4, 4LL * v47);
      if ( !result )
      {
LABEL_58:
        free(v4);
        return 0;
      }
    }
    else
    {
      result = realloc(v4, 0);
      if ( !result )
        return result;
    }
    v4 = result;
    *(_QWORD *)v3 = result;
    v3[3] = v47;
  }
  v43 = v3[5];
LABEL_65:
  v52 = 32 - v43;
  v53 = HIBYTE(a2);
  if ( (unsigned int)(32 - v43) < 9 )
  {
    if ( v43 )
    {
      v55 = v3[2];
      v56 = (unsigned int)v3[4];
      v3[5] = 8 - v52;
      v57 = (v55 << v52) | (v53 >> (8 - v52));
      v3[4] = v56 + 1;
      v4[v56] = HIBYTE(v57) | ((unsigned __int8)v57 << 24) | (v57 >> 8) & 0xFF00 | (BYTE1(v57) << 16);
      v3[2] = v53;
    }
    else
    {
      v58 = (unsigned int)v3[4];
      v3[4] = v58 + 1;
      v4[v58] = bswap32(v53);
    }
  }
  else
  {
    v54 = v3[2];
    v3[5] = v43 + 8;
    v3[2] = HIBYTE(a2) | (v54 << 8);
  }
  return &dword_0 + 1;
}
// 16908: conditional instruction was optimized away because x21.8!=0
// 169B0: conditional instruction was optimized away because x21.8!=0
// 169DC: conditional instruction was optimized away because x21.8!=0
// 16A2C: conditional instruction was optimized away because x21.8!=0
// 16AEC: conditional instruction was optimized away because x21.8!=0
// 16B18: conditional instruction was optimized away because x21.8!=0
// 0: using guessed type int dword_0;

//----- (0000000000016BE4) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_byte_block(__int64 a1, __int64 a2, unsigned int a3)
{
  int v4; // w8
  unsigned int v5; // w9
  unsigned int v8; // w8
  bool v9; // cf
  unsigned int v10; // w9
  void *v11; // x22
  bool v12; // zf
  int v13; // w9
  unsigned int v14; // w23
  void *result; // x0
  void *v16; // x0
  __int64 v17; // x22
  unsigned __int64 v18; // x23
  void *v19; // x21
  int v20; // w9
  unsigned int v21; // w10
  unsigned int v22; // w27
  int v23; // w8
  unsigned int v24; // w9
  unsigned int v25; // w10
  int v26; // w8
  unsigned int v27; // w28
  int v28; // w9
  int v29; // w9
  int v30; // w8
  __int64 v31; // x11
  unsigned int v32; // w8
  __int64 v33; // x8

  v5 = *(_DWORD *)(a1 + 12);
  v4 = *(_DWORD *)(a1 + 16);
  if ( v5 <= v4 + (a3 >> 2) + 1 )
  {
    v8 = v4 + ((*(_DWORD *)(a1 + 20) + 8 * a3 + 31) >> 5);
    v9 = v8 >= v5;
    v10 = v8 - v5;
    if ( v10 != 0 && v9 )
    {
      v11 = *(void **)a1;
      v12 = (v10 & 0x3FF) == 0;
      v13 = 1024 - (v10 & 0x3FF);
      if ( v12 )
        v13 = 0;
      v14 = v13 + v8;
      if ( v13 + v8 )
      {
        result = realloc(*(void **)a1, 4LL * v14);
        if ( !result )
        {
          v16 = v11;
LABEL_33:
          free(v16);
          return 0;
        }
      }
      else
      {
        result = realloc(*(void **)a1, 0);
        if ( !result )
          return result;
      }
      *(_QWORD *)a1 = result;
      *(_DWORD *)(a1 + 12) = v14;
    }
  }
  if ( a3 )
  {
    result = *(void **)a1;
    v17 = 0;
    v18 = a3;
    v19 = *(void **)a1;
    while ( 1 )
    {
      if ( !v19 )
        return 0;
      v21 = *(_DWORD *)(a1 + 12);
      v20 = *(_DWORD *)(a1 + 16);
      v22 = *(unsigned __int8 *)(a2 + v17);
      if ( v21 <= v20 + 8 )
      {
        v23 = *(_DWORD *)(a1 + 20);
        v24 = v20 + ((unsigned int)(v23 + 39) >> 5);
        v9 = v24 >= v21;
        v25 = v24 - v21;
        if ( v25 == 0 || !v9 )
          goto LABEL_25;
        v26 = 1024 - (v25 & 0x3FF);
        if ( (v25 & 0x3FF) == 0 )
          v26 = 0;
        v27 = v26 + v24;
        if ( v26 + v24 )
        {
          result = realloc(v19, 4LL * v27);
          if ( !result )
          {
            v16 = v19;
            goto LABEL_33;
          }
        }
        else
        {
          result = realloc(v19, 0);
          if ( !result )
            return result;
        }
        v19 = result;
        *(_QWORD *)a1 = result;
        *(_DWORD *)(a1 + 12) = v27;
      }
      v23 = *(_DWORD *)(a1 + 20);
LABEL_25:
      v28 = 32 - v23;
      if ( (unsigned int)(32 - v23) < 9 )
      {
        if ( v23 )
        {
          v30 = *(_DWORD *)(a1 + 8);
          v31 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v28;
          v32 = (v30 << v28) | (v22 >> (8 - v28));
          *(_DWORD *)(a1 + 16) = v31 + 1;
          *((_DWORD *)v19 + v31) = HIBYTE(v32) | ((unsigned __int8)v32 << 24) | (v32 >> 8) & 0xFF00 | (BYTE1(v32) << 16);
          *(_DWORD *)(a1 + 8) = v22;
          if ( ++v17 >= v18 )
            return &dword_0 + 1;
        }
        else
        {
          v33 = *(unsigned int *)(a1 + 16);
          v19 = result;
          *(_DWORD *)(a1 + 16) = v33 + 1;
          *((_DWORD *)result + v33) = bswap32(v22);
          if ( ++v17 >= v18 )
            return &dword_0 + 1;
        }
      }
      else
      {
        v29 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v23 + 8;
        *(_DWORD *)(a1 + 8) = (unsigned __int8)v22 | (v29 << 8);
        if ( ++v17 >= v18 )
          return &dword_0 + 1;
      }
    }
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000016E04) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_unary_unsigned(__int64 a1, unsigned int a2)
{
  void *v3; // x20
  int v4; // w8
  unsigned int v5; // w9
  unsigned int v6; // w21
  unsigned int v7; // w8
  bool v8; // cf
  unsigned int v9; // w9
  int v10; // w9
  unsigned int v11; // w22
  void *result; // x0
  unsigned int v13; // w8
  int v14; // w9
  unsigned int v15; // w10
  int v16; // w8
  unsigned int v17; // w9
  unsigned int v18; // w10
  int v19; // w8
  unsigned int v20; // w21
  int v21; // w10
  char v22; // w8
  unsigned int v23; // w9
  int v24; // w8
  int v25; // w10
  __int64 v26; // x11
  int v27; // w9
  int v28; // w8
  __int64 v29; // x10
  unsigned int v30; // w8
  __int64 v31; // x8

  if ( a2 > 0x1F )
  {
    v13 = (unsigned int)FLAC__bitwriter_write_zeroes(a1, a2);
    result = 0;
    if ( !a1 || !v13 )
      return result;
    v3 = *(void **)a1;
    if ( !*(_QWORD *)a1 )
      return 0;
    v15 = *(_DWORD *)(a1 + 12);
    v14 = *(_DWORD *)(a1 + 16);
    if ( v15 <= v14 + 1 )
    {
      v16 = *(_DWORD *)(a1 + 20);
      v17 = v14 + ((unsigned int)(v16 + 32) >> 5);
      v8 = v17 >= v15;
      v18 = v17 - v15;
      if ( v18 == 0 || !v8 )
        goto LABEL_36;
      v19 = 1024 - (v18 & 0x3FF);
      if ( (v18 & 0x3FF) == 0 )
        v19 = 0;
      v20 = v19 + v17;
      if ( v19 + v17 )
      {
        result = realloc(*(void **)a1, 4LL * v20);
        if ( !result )
        {
LABEL_23:
          free(v3);
          return 0;
        }
      }
      else
      {
        result = realloc(*(void **)a1, 0);
        if ( !result )
          return result;
      }
      v3 = result;
      *(_QWORD *)a1 = result;
      *(_DWORD *)(a1 + 12) = v20;
    }
    v16 = *(_DWORD *)(a1 + 20);
LABEL_36:
    v27 = 32 - v16;
    if ( (unsigned int)(32 - v16) < 2 )
    {
      if ( v16 )
      {
        v28 = *(_DWORD *)(a1 + 8);
        v29 = *(unsigned int *)(a1 + 16);
        result = &dword_0 + 1;
        *(_DWORD *)(a1 + 20) = 1 - v27;
        v30 = (v28 << v27) | (1u >> (1 - v27));
        *(_DWORD *)(a1 + 16) = v29 + 1;
        *((_DWORD *)v3 + v29) = HIBYTE(v30) | ((unsigned __int8)v30 << 24) | (v30 >> 8) & 0xFF00 | (BYTE1(v30) << 16);
        *(_DWORD *)(a1 + 8) = 1;
        return result;
      }
      goto LABEL_41;
    }
    result = &dword_0 + 1;
    *(_DWORD *)(a1 + 8) = (2 * *(_DWORD *)(a1 + 8)) | 1;
    *(_DWORD *)(a1 + 20) = v16 + 1;
    return result;
  }
  if ( !a1 )
    return 0;
  v3 = *(void **)a1;
  if ( !*(_QWORD *)a1 )
    return 0;
  v5 = *(_DWORD *)(a1 + 12);
  v4 = *(_DWORD *)(a1 + 16);
  v6 = a2 + 1;
  if ( v5 > v4 + a2 + 1 )
    goto LABEL_29;
  v7 = v4 + ((a2 + *(_DWORD *)(a1 + 20) + 32) >> 5);
  v8 = v7 >= v5;
  v9 = v7 - v5;
  if ( v9 == 0 || !v8 )
    goto LABEL_29;
  if ( (v9 & 0x3FF) != 0 )
    v10 = 1024 - (v9 & 0x3FF);
  else
    v10 = 0;
  v11 = v10 + v7;
  if ( v10 + v7 )
  {
    result = realloc(*(void **)a1, 4LL * v11);
    if ( !result )
      goto LABEL_23;
LABEL_28:
    v3 = result;
    *(_QWORD *)a1 = result;
    *(_DWORD *)(a1 + 12) = v11;
LABEL_29:
    v21 = *(_DWORD *)(a1 + 20);
    v22 = 32 - v21;
    v23 = v6 - (32 - v21);
    if ( v6 < 32 - v21 )
    {
      v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v21 + v6;
      *(_DWORD *)(a1 + 8) = (v24 << v6) | 1;
      return &dword_0 + 1;
    }
    if ( v21 )
    {
      v25 = *(_DWORD *)(a1 + 8);
      v26 = *(unsigned int *)(a1 + 16);
      result = &dword_0 + 1;
      *(_DWORD *)(a1 + 20) = v23;
      *(_DWORD *)(a1 + 16) = v26 + 1;
      *((_DWORD *)v3 + v26) = (((v25 << v22) | (1u >> v23)) >> 24)
                            | ((unsigned __int8)(((_BYTE)v25 << v22) | (1u >> v23)) << 24)
                            | (((v25 << v22) | (1u >> v23)) >> 8) & 0xFF00
                            | ((unsigned __int8)((unsigned __int16)(((_WORD)v25 << v22) | (1u >> v23)) >> 8) << 16);
      *(_DWORD *)(a1 + 8) = 1;
      return result;
    }
LABEL_41:
    v31 = *(unsigned int *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v31 + 1;
    *((_DWORD *)v3 + v31) = 0x1000000;
    return &dword_0 + 1;
  }
  result = realloc(*(void **)a1, 0);
  if ( result )
    goto LABEL_28;
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000170DC) ----------------------------------------------------
__int64 __fastcall FLAC__bitwriter_rice_bits(int a1, int a2)
{
  return a2 + (((2 * a1) ^ (unsigned int)(a1 >> 31)) >> a2) + 1;
}

//----- (00000000000170F4) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_rice_signed(__int64 a1, int a2, int a3)
{
  unsigned int v3; // w8
  int v4; // w9
  unsigned int v5; // w20
  unsigned int v6; // w1
  unsigned int v7; // w2
  unsigned int v9; // w21
  void *result; // x0

  v3 = (2 * a2) ^ (a2 >> 31);
  v4 = 1 << a3;
  v5 = a3 + 1;
  v6 = v3 >> a3;
  v7 = (v3 >> a3) + a3 + 1;
  v9 = (v4 - 1) & v3 | v4;
  if ( v7 <= 0x20 )
    return FLAC__bitwriter_write_raw_uint32(a1, (v4 - 1) & v3 | v4, v7);
  result = FLAC__bitwriter_write_zeroes(a1, v6);
  if ( (_DWORD)result )
    return (void *)((unsigned int)FLAC__bitwriter_write_raw_uint32(a1, v9, v5) != 0);
  return result;
}

//----- (0000000000017184) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_rice_signed_block(__int64 a1, int *a2, int a3, int a4)
{
  char v4; // w19
  int v5; // w20
  unsigned int v8; // w24
  int v9; // w14
  unsigned int v10; // w27
  int v11; // w9
  unsigned int v12; // w28
  unsigned int v13; // w25
  unsigned int v14; // w8
  int v15; // w10
  int v16; // w9
  unsigned int v17; // w10
  int v18; // w11
  unsigned int v19; // w8
  __int16 v20; // w9
  bool v21; // zf
  void *v22; // x23
  int v23; // w9
  unsigned int v24; // w26
  void *result; // x0
  int v26; // w9
  int v27; // w10
  unsigned int v28; // w8
  unsigned int v29; // w9
  __int64 v30; // x10
  _DWORD *v31; // x11
  _DWORD *v32; // x8
  unsigned int i; // w9
  __int64 v34; // x10
  int v35; // w9
  int v36; // w10
  unsigned int v37; // w8
  unsigned int v38; // w11
  unsigned int v39; // w9
  __int64 v40; // x11
  _DWORD *v41; // x12
  int v42; // [xsp+Ch] [xbp-54h]

  v4 = a4;
  v5 = a3;
  if ( a3 )
  {
    v8 = a4 + 1;
    v9 = -1 << a4;
    v10 = 0xFFFFFFFF >> (31 - a4);
    v42 = -1 << a4;
    while ( 1 )
    {
      while ( 1 )
      {
        v11 = *(_DWORD *)(a1 + 20);
        v12 = (2 * *a2) ^ (*a2 >> 31);
        v13 = v12 >> v4;
        v14 = (v12 >> v4) + v8;
        if ( !v11 )
          break;
        v15 = v14 + v11;
        if ( v14 + v11 > 0x1F )
          break;
        v16 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v15;
        *(_DWORD *)(a1 + 8) = (v16 << v14) | (v12 | v9) & v10;
        --v5;
        ++a2;
        if ( !v5 )
          return &dword_0 + 1;
      }
      v17 = *(_DWORD *)(a1 + 12);
      v18 = *(_DWORD *)(a1 + 16);
      if ( v17 <= v11 + v13 + v18 + 1 )
      {
        v19 = v18 + ((v11 + v14 + 31) >> 5);
        v20 = v19 - v17;
        if ( v19 > v17 )
        {
          v21 = (v20 & 0x3FF) == 0;
          v22 = *(void **)a1;
          v23 = 1024 - (v20 & 0x3FF);
          if ( v21 )
            v23 = 0;
          v24 = v23 + v19;
          if ( v23 + v19 )
          {
            result = realloc(*(void **)a1, 4LL * v24);
            if ( !result )
            {
              free(v22);
              return 0;
            }
          }
          else
          {
            result = realloc(*(void **)a1, 0);
            if ( !result )
              return result;
          }
          v9 = v42;
          *(_QWORD *)a1 = result;
          *(_DWORD *)(a1 + 12) = v24;
        }
      }
      if ( v13 )
      {
        v26 = *(_DWORD *)(a1 + 20);
        if ( !v26 )
          goto LABEL_21;
        v27 = *(_DWORD *)(a1 + 8);
        v28 = v13 - (32 - v26);
        if ( v13 >= 32 - v26 )
        {
          v29 = v27 << (32 - v26);
          v30 = *(unsigned int *)(a1 + 16);
          v31 = *(_DWORD **)a1;
          *(_DWORD *)(a1 + 8) = v29;
          v13 = v28;
          *(_DWORD *)(a1 + 16) = v30 + 1;
          v31[v30] = bswap32(v29);
          *(_DWORD *)(a1 + 20) = 0;
LABEL_21:
          if ( v13 >= 0x20 )
          {
            v32 = *(_DWORD **)a1;
            for ( i = v13; i > 0x1F; i -= 32 )
            {
              v34 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v34 + 1;
              v32[v34] = 0;
            }
            v13 &= 0x1Fu;
          }
          if ( v13 )
          {
            *(_DWORD *)(a1 + 8) = 0;
            *(_DWORD *)(a1 + 20) = v13;
          }
          goto LABEL_27;
        }
        *(_DWORD *)(a1 + 8) = v27 << v13;
        *(_DWORD *)(a1 + 20) = v26 + v13;
      }
LABEL_27:
      v35 = *(_DWORD *)(a1 + 20);
      v36 = *(_DWORD *)(a1 + 8);
      v37 = (v12 | v9) & v10;
      v38 = v8 - (32 - v35);
      if ( v8 >= 32 - v35 )
      {
        v39 = (v37 >> v38) | (v36 << (32 - v35));
        *(_DWORD *)(a1 + 20) = v38;
        v40 = *(unsigned int *)(a1 + 16);
        v41 = *(_DWORD **)a1;
        *(_DWORD *)(a1 + 16) = v40 + 1;
        v41[v40] = HIBYTE(v39) | ((unsigned __int8)v39 << 24) | (v39 >> 8) & 0xFF00 | (BYTE1(v39) << 16);
        *(_DWORD *)(a1 + 8) = v37;
        --v5;
        ++a2;
        if ( !v5 )
          return &dword_0 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = (v36 << v8) | v37;
        *(_DWORD *)(a1 + 20) = v35 + v8;
        --v5;
        ++a2;
        if ( !v5 )
          return &dword_0 + 1;
      }
    }
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000017404) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_utf8_uint32(__int64 a1, unsigned int a2)
{
  void *v4; // x21
  int v5; // w9
  unsigned int v6; // w10
  int v7; // w8
  unsigned int v8; // w9
  bool v9; // cf
  unsigned int v10; // w10
  int v11; // w8
  unsigned int v12; // w22
  void *result; // x0
  void *v14; // x21
  int v15; // w9
  unsigned int v16; // w10
  int v17; // w8
  unsigned int v18; // w9
  unsigned int v19; // w10
  int v20; // w8
  unsigned int v21; // w22
  void *v22; // x0
  void *v23; // x21
  int v24; // w8
  unsigned int v25; // w10
  int v26; // w9
  unsigned int v27; // w8
  unsigned int v28; // w10
  int v29; // w9
  unsigned int v30; // w22
  void *v31; // x0
  char v32; // w22
  _DWORD *v33; // x21
  void *v34; // x21
  int v35; // w8
  unsigned int v36; // w10
  int v37; // w9
  unsigned int v38; // w8
  unsigned int v39; // w10
  int v40; // w9
  unsigned int v41; // w22
  void *v42; // x0
  char v43; // w22
  _DWORD *v44; // x21
  void *v45; // x21
  int v46; // w8
  unsigned int v47; // w10
  int v48; // w9
  unsigned int v49; // w8
  unsigned int v50; // w10
  int v51; // w9
  unsigned int v52; // w22
  void *v53; // x0
  char v54; // w23
  _DWORD *v55; // x21
  int v56; // w22
  int v57; // w9
  void *v58; // x21
  int v59; // w8
  unsigned int v60; // w10
  int v61; // w9
  unsigned int v62; // w8
  unsigned int v63; // w10
  int v64; // w9
  unsigned int v65; // w22
  void *v66; // x0
  char v67; // w23
  _DWORD *v68; // x21
  int v69; // w22
  int v70; // w8
  int v71; // w9
  int v72; // w9
  int v73; // w8
  __int64 v74; // x11
  unsigned int v75; // w8
  __int64 v76; // x8
  int v77; // w10
  unsigned int v78; // w9
  int v79; // w10
  int v80; // w8
  __int64 v81; // x12
  _DWORD *v82; // x21
  int v83; // w8
  unsigned int v84; // w10
  int v85; // w9
  unsigned int v86; // w8
  unsigned int v87; // w10
  int v88; // w9
  unsigned int v89; // w23
  _DWORD *v90; // x0
  __int64 v91; // x10
  int v92; // w10
  unsigned int v93; // w8
  int v94; // w10
  int v95; // w9
  __int64 v96; // x12
  unsigned int v97; // w9
  __int64 v98; // x9
  int v99; // w10
  unsigned int v100; // w8
  int v101; // w10
  int v102; // w9
  __int64 v103; // x12
  unsigned int v104; // w9
  __int64 v105; // x9
  int v106; // w10
  unsigned int v107; // w8
  int v108; // w10
  int v109; // w9
  __int64 v110; // x12
  unsigned int v111; // w9
  int v112; // w8
  unsigned int v113; // w10
  int v114; // w9
  unsigned int v115; // w8
  unsigned int v116; // w10
  int v117; // w9
  unsigned int v118; // w24
  _DWORD *v119; // x0
  __int64 v120; // x9
  int v121; // w10
  unsigned int v122; // w8
  int v123; // w10
  int v124; // w9
  __int64 v125; // x12
  unsigned int v126; // w9
  __int64 v127; // x9
  int v128; // w10
  unsigned int v129; // w8
  int v130; // w10
  int v131; // w9
  __int64 v132; // x12
  unsigned int v133; // w9
  int v134; // w8
  unsigned int v135; // w10
  int v136; // w9
  unsigned int v137; // w8
  unsigned int v138; // w10
  int v139; // w9
  unsigned int v140; // w24
  _DWORD *v141; // x0
  _DWORD *v142; // x21
  char v143; // w23
  __int64 v144; // x9
  int v145; // w10
  unsigned int v146; // w8
  int v147; // w10
  int v148; // w9
  __int64 v149; // x12
  unsigned int v150; // w9
  int v151; // w8
  unsigned int v152; // w10
  int v153; // w9
  unsigned int v154; // w8
  unsigned int v155; // w10
  int v156; // w9
  unsigned int v157; // w24
  _DWORD *v158; // x0
  _DWORD *v159; // x21
  char v160; // w23
  __int64 v161; // x9
  int v162; // w10
  unsigned int v163; // w8
  int v164; // w10
  int v165; // w9
  __int64 v166; // x12
  unsigned int v167; // w9
  __int64 v168; // x9
  int v169; // w10
  unsigned int v170; // w8
  int v171; // w10
  int v172; // w9
  __int64 v173; // x12
  unsigned int v174; // w9
  __int64 v175; // x9
  int v176; // w9
  unsigned int v177; // w10
  int v178; // w8
  unsigned int v179; // w9
  unsigned int v180; // w10
  int v181; // w8
  unsigned int v182; // w24
  _DWORD *v183; // x0
  int v184; // w9
  unsigned int v185; // w22
  int v186; // w9
  int v187; // w8
  __int64 v188; // x11
  unsigned int v189; // w8
  __int64 v190; // x8
  int v191; // w8
  unsigned int v192; // w10
  int v193; // w9
  unsigned int v194; // w8
  unsigned int v195; // w10
  int v196; // w9
  unsigned int v197; // w23
  _DWORD *v198; // x0
  int v199; // w10
  unsigned int v200; // w8
  int v201; // w10
  int v202; // w9
  __int64 v203; // x12
  unsigned int v204; // w9
  __int64 v205; // x9
  int v206; // w9
  unsigned int v207; // w10
  int v208; // w8
  unsigned int v209; // w9
  unsigned int v210; // w10
  int v211; // w8
  unsigned int v212; // w24
  _DWORD *v213; // x0
  int v214; // w9
  unsigned int v215; // w22
  int v216; // w9
  _DWORD *v217; // x21
  char v218; // w22
  int v219; // w8
  __int64 v220; // x11
  unsigned int v221; // w8
  __int64 v222; // x8
  int v223; // w8
  unsigned int v224; // w10
  int v225; // w9
  unsigned int v226; // w8
  unsigned int v227; // w10
  int v228; // w9
  unsigned int v229; // w24
  _DWORD *v230; // x0
  int v231; // w10
  unsigned int v232; // w8
  int v233; // w10
  int v234; // w9
  __int64 v235; // x12
  unsigned int v236; // w9
  __int64 v237; // x9
  int v238; // w9
  unsigned int v239; // w10
  int v240; // w8
  unsigned int v241; // w9
  unsigned int v242; // w10
  int v243; // w8
  unsigned int v244; // w24
  _DWORD *v245; // x0
  int v246; // w9
  unsigned int v247; // w23
  int v248; // w9
  int v249; // w8
  __int64 v250; // x11
  unsigned int v251; // w8
  __int64 v252; // x8

  if ( (a2 & 0x80000000) != 0 )
    return 0;
  if ( a2 > 0x7F )
  {
    if ( a2 <= 0x7FF )
    {
      if ( a1 )
      {
        v14 = *(void **)a1;
        if ( *(_QWORD *)a1 )
        {
          v16 = *(_DWORD *)(a1 + 12);
          v15 = *(_DWORD *)(a1 + 16);
          if ( v16 <= v15 + 8 )
          {
            v17 = *(_DWORD *)(a1 + 20);
            v18 = v15 + ((unsigned int)(v17 + 39) >> 5);
            v9 = v18 >= v16;
            v19 = v18 - v16;
            if ( v19 == 0 || !v9 )
              goto LABEL_87;
            v20 = 1024 - (v19 & 0x3FF);
            if ( (v19 & 0x3FF) == 0 )
              v20 = 0;
            v21 = v20 + v18;
            if ( v20 + v18 )
            {
              v22 = realloc(*(void **)a1, 4LL * v21);
              if ( !v22 )
              {
                free(v14);
                goto LABEL_111;
              }
            }
            else
            {
              v22 = realloc(*(void **)a1, 0);
              if ( !v22 )
              {
LABEL_111:
                v82 = *(_DWORD **)a1;
                v69 = 0;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_317;
                goto LABEL_92;
              }
            }
            v14 = v22;
            *(_QWORD *)a1 = v22;
            *(_DWORD *)(a1 + 12) = v21;
          }
          v17 = *(_DWORD *)(a1 + 20);
LABEL_87:
          v77 = 32 - v17;
          v78 = (a2 >> 6) | 0xC0;
          if ( (unsigned int)(32 - v17) >= 9 )
          {
            v79 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v17 + 8;
            v78 |= v79 << 8;
            goto LABEL_91;
          }
          if ( v17 )
          {
            v80 = *(_DWORD *)(a1 + 8);
            v81 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 20) = 8 - v77;
            *(_DWORD *)(a1 + 16) = v81 + 1;
            *((_DWORD *)v14 + v81) = (((v80 << v77) | (v78 >> (8 - v77))) >> 24)
                                   | ((unsigned __int8)(((_BYTE)v80 << v77) | (v78 >> (8 - v77))) << 24)
                                   | (((v80 << v77) | (v78 >> (8 - v77))) >> 8) & 0xFF00
                                   | ((unsigned __int8)((unsigned __int16)(((_WORD)v80 << v77) | (v78 >> (8 - v77))) >> 8) << 16);
LABEL_91:
            *(_DWORD *)(a1 + 8) = v78;
            v82 = *(_DWORD **)a1;
            v69 = 1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_317;
            goto LABEL_92;
          }
          v91 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v91 + 1;
          *((_DWORD *)v14 + v91) = bswap32(v78);
          v82 = *(_DWORD **)a1;
          v69 = 1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_317;
LABEL_92:
          v84 = *(_DWORD *)(a1 + 12);
          v83 = *(_DWORD *)(a1 + 16);
          if ( v84 > v83 + 8 )
          {
LABEL_104:
            v85 = *(_DWORD *)(a1 + 20);
LABEL_105:
            v92 = 32 - v85;
            v93 = a2 & 0x3F | 0x80;
            if ( (unsigned int)(32 - v85) < 9 )
            {
              if ( v85 )
              {
                v95 = *(_DWORD *)(a1 + 8);
                v96 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v92;
                v97 = (v95 << v92) | (v93 >> (8 - v92));
                *(_DWORD *)(a1 + 16) = v96 + 1;
                v82[v96] = HIBYTE(v97) | ((unsigned __int8)v97 << 24) | (v97 >> 8) & 0xFF00 | (BYTE1(v97) << 16);
                *(_DWORD *)(a1 + 8) = v93;
              }
              else
              {
                v98 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v98 + 1;
                v82[v98] = bswap32(v93);
              }
            }
            else
            {
              v94 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 20) = v85 + 8;
              *(_DWORD *)(a1 + 8) = a2 & 0x3F | 0x80 | (v94 << 8);
            }
            v70 = 1;
            return (void *)(v70 & (unsigned int)v69);
          }
          v85 = *(_DWORD *)(a1 + 20);
          v86 = v83 + ((unsigned int)(v85 + 39) >> 5);
          v9 = v86 >= v84;
          v87 = v86 - v84;
          if ( v87 == 0 || !v9 )
            goto LABEL_105;
          v88 = 1024 - (v87 & 0x3FF);
          if ( (v87 & 0x3FF) == 0 )
            v88 = 0;
          v89 = v88 + v86;
          if ( v88 + v86 )
          {
            v90 = realloc(v82, 4LL * v89);
            if ( !v90 )
            {
              free(v82);
              v70 = 0;
              return (void *)(v70 & (unsigned int)v69);
            }
            goto LABEL_103;
          }
          v90 = realloc(v82, 0);
          if ( v90 )
          {
LABEL_103:
            v82 = v90;
            *(_QWORD *)a1 = v90;
            *(_DWORD *)(a1 + 12) = v89;
            goto LABEL_104;
          }
LABEL_317:
          v70 = 0;
          return (void *)(v70 & (unsigned int)v69);
        }
        v56 = 0;
        v57 = 1;
        goto LABEL_75;
      }
LABEL_73:
      v69 = 0;
      v70 = 0;
      return (void *)(v70 & (unsigned int)v69);
    }
    if ( !HIWORD(a2) )
    {
      if ( !a1 )
        goto LABEL_73;
      v23 = *(void **)a1;
      if ( *(_QWORD *)a1 )
      {
        v25 = *(_DWORD *)(a1 + 12);
        v24 = *(_DWORD *)(a1 + 16);
        if ( v25 <= v24 + 8 )
        {
          v26 = *(_DWORD *)(a1 + 20);
          v27 = v24 + ((unsigned int)(v26 + 39) >> 5);
          v9 = v27 >= v25;
          v28 = v27 - v25;
          if ( v28 == 0 || !v9 )
            goto LABEL_116;
          v29 = 1024 - (v28 & 0x3FF);
          if ( (v28 & 0x3FF) == 0 )
            v29 = 0;
          v30 = v29 + v27;
          if ( v29 + v27 )
          {
            v31 = realloc(*(void **)a1, 4LL * v30);
            if ( !v31 )
            {
              free(v23);
              v32 = 0;
              v33 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_312;
              goto LABEL_238;
            }
          }
          else
          {
            v31 = realloc(*(void **)a1, 0);
            if ( !v31 )
            {
              v32 = 0;
              v33 = *(_DWORD **)a1;
              if ( *(_QWORD *)a1 )
                goto LABEL_238;
              goto LABEL_312;
            }
          }
          v23 = v31;
          *(_QWORD *)a1 = v31;
          *(_DWORD *)(a1 + 12) = v30;
        }
        v26 = *(_DWORD *)(a1 + 20);
LABEL_116:
        v99 = 32 - v26;
        v100 = (a2 >> 12) | 0xE0;
        if ( (unsigned int)(32 - v26) >= 9 )
        {
          v101 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v26 + 8;
          *(_DWORD *)(a1 + 8) = v100 | (v101 << 8);
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_312;
LABEL_238:
          v192 = *(_DWORD *)(a1 + 12);
          v191 = *(_DWORD *)(a1 + 16);
          if ( v192 <= v191 + 8 )
          {
            v193 = *(_DWORD *)(a1 + 20);
            v194 = v191 + ((unsigned int)(v193 + 39) >> 5);
            v9 = v194 >= v192;
            v195 = v194 - v192;
            if ( v195 == 0 || !v9 )
            {
LABEL_249:
              v199 = 32 - v193;
              v200 = (a2 >> 6) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v193) < 9 )
              {
                if ( !v193 )
                {
                  v205 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v205 + 1;
                  v33[v205] = bswap32(v200);
                  v82 = *(_DWORD **)a1;
                  v69 = v32 & 1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_317;
                  goto LABEL_92;
                }
                v202 = *(_DWORD *)(a1 + 8);
                v203 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v199;
                v204 = (v202 << v199) | (v200 >> (8 - v199));
                *(_DWORD *)(a1 + 16) = v203 + 1;
                v33[v203] = HIBYTE(v204) | ((unsigned __int8)v204 << 24) | (v204 >> 8) & 0xFF00 | (BYTE1(v204) << 16);
              }
              else
              {
                v201 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v193 + 8;
                v200 = (a2 >> 6) & 0x3F | 0x80 | (v201 << 8);
              }
              *(_DWORD *)(a1 + 8) = v200;
              v82 = *(_DWORD **)a1;
              v69 = v32 & 1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_317;
              goto LABEL_92;
            }
            v196 = 1024 - (v195 & 0x3FF);
            if ( (v195 & 0x3FF) == 0 )
              v196 = 0;
            v197 = v196 + v194;
            if ( v196 + v194 )
            {
              v198 = realloc(v33, 4LL * v197);
              if ( !v198 )
              {
LABEL_305:
                free(v33);
                v82 = *(_DWORD **)a1;
                v69 = 0;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_317;
                goto LABEL_92;
              }
            }
            else
            {
              v198 = realloc(v33, 0);
              if ( !v198 )
                goto LABEL_312;
            }
            v33 = v198;
            *(_QWORD *)a1 = v198;
            *(_DWORD *)(a1 + 12) = v197;
          }
          v193 = *(_DWORD *)(a1 + 20);
          goto LABEL_249;
        }
        if ( v26 )
        {
          v102 = *(_DWORD *)(a1 + 8);
          v103 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v99;
          v104 = (v102 << v99) | (v100 >> (8 - v99));
          *(_DWORD *)(a1 + 16) = v103 + 1;
          *((_DWORD *)v23 + v103) = HIBYTE(v104)
                                  | ((unsigned __int8)v104 << 24)
                                  | (v104 >> 8) & 0xFF00
                                  | (BYTE1(v104) << 16);
          *(_DWORD *)(a1 + 8) = v100;
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( *(_QWORD *)a1 )
            goto LABEL_238;
        }
        else
        {
          v105 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v105 + 1;
          *((_DWORD *)v23 + v105) = bswap32(v100);
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( *(_QWORD *)a1 )
            goto LABEL_238;
        }
LABEL_312:
        v82 = *(_DWORD **)a1;
        v69 = 0;
        if ( !*(_QWORD *)a1 )
          goto LABEL_317;
        goto LABEL_92;
      }
      goto LABEL_74;
    }
    if ( !(a2 >> 21) )
    {
      if ( !a1 )
        goto LABEL_73;
      v34 = *(void **)a1;
      if ( *(_QWORD *)a1 )
      {
        v36 = *(_DWORD *)(a1 + 12);
        v35 = *(_DWORD *)(a1 + 16);
        if ( v36 <= v35 + 8 )
        {
          v37 = *(_DWORD *)(a1 + 20);
          v38 = v35 + ((unsigned int)(v37 + 39) >> 5);
          v9 = v38 >= v36;
          v39 = v38 - v36;
          if ( v39 == 0 || !v9 )
            goto LABEL_127;
          v40 = 1024 - (v39 & 0x3FF);
          if ( (v39 & 0x3FF) == 0 )
            v40 = 0;
          v41 = v40 + v38;
          if ( v40 + v38 )
          {
            v42 = realloc(*(void **)a1, 4LL * v41);
            if ( !v42 )
            {
              free(v34);
              v43 = 0;
              v44 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_194;
              goto LABEL_132;
            }
          }
          else
          {
            v42 = realloc(*(void **)a1, 0);
            if ( !v42 )
            {
              v43 = 0;
              v44 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_194;
              goto LABEL_132;
            }
          }
          v34 = v42;
          *(_QWORD *)a1 = v42;
          *(_DWORD *)(a1 + 12) = v41;
        }
        v37 = *(_DWORD *)(a1 + 20);
LABEL_127:
        v106 = 32 - v37;
        v107 = (a2 >> 18) | 0xF0;
        if ( (unsigned int)(32 - v37) < 9 )
        {
          if ( !v37 )
          {
            v120 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v120 + 1;
            *((_DWORD *)v34 + v120) = bswap32(v107);
            v43 = 1;
            v44 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_194;
            goto LABEL_132;
          }
          v109 = *(_DWORD *)(a1 + 8);
          v110 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v106;
          v111 = (v109 << v106) | (v107 >> (8 - v106));
          *(_DWORD *)(a1 + 16) = v110 + 1;
          *((_DWORD *)v34 + v110) = HIBYTE(v111)
                                  | ((unsigned __int8)v111 << 24)
                                  | (v111 >> 8) & 0xFF00
                                  | (BYTE1(v111) << 16);
        }
        else
        {
          v108 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v37 + 8;
          v107 |= v108 << 8;
        }
        *(_DWORD *)(a1 + 8) = v107;
        v43 = 1;
        v44 = *(_DWORD **)a1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_194;
LABEL_132:
        v113 = *(_DWORD *)(a1 + 12);
        v112 = *(_DWORD *)(a1 + 16);
        if ( v113 > v112 + 8 )
        {
LABEL_147:
          v114 = *(_DWORD *)(a1 + 20);
          goto LABEL_148;
        }
        v114 = *(_DWORD *)(a1 + 20);
        v115 = v112 + ((unsigned int)(v114 + 39) >> 5);
        v9 = v115 >= v113;
        v116 = v115 - v113;
        if ( v116 == 0 || !v9 )
        {
LABEL_148:
          v121 = 32 - v114;
          v122 = (a2 >> 12) & 0x3F | 0x80;
          if ( (unsigned int)(32 - v114) < 9 )
          {
            if ( v114 )
            {
              v124 = *(_DWORD *)(a1 + 8);
              v125 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v121;
              v126 = (v124 << v121) | (v122 >> (8 - v121));
              *(_DWORD *)(a1 + 16) = v125 + 1;
              v44[v125] = HIBYTE(v126) | ((unsigned __int8)v126 << 24) | (v126 >> 8) & 0xFF00 | (BYTE1(v126) << 16);
              *(_DWORD *)(a1 + 8) = v122;
            }
            else
            {
              v127 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v127 + 1;
              v44[v127] = bswap32(v122);
            }
          }
          else
          {
            v123 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v114 + 8;
            *(_DWORD *)(a1 + 8) = (a2 >> 12) & 0x3F | 0x80 | (v123 << 8);
          }
          v33 = *(_DWORD **)a1;
          LOBYTE(v56) = v43 & 1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_312;
LABEL_298:
          v239 = *(_DWORD *)(a1 + 12);
          v238 = *(_DWORD *)(a1 + 16);
          if ( v239 <= v238 + 8 )
          {
            v240 = *(_DWORD *)(a1 + 20);
            v241 = v238 + ((unsigned int)(v240 + 39) >> 5);
            v9 = v241 >= v239;
            v242 = v241 - v239;
            if ( v242 == 0 || !v9 )
            {
LABEL_310:
              v246 = 32 - v240;
              v247 = (a2 >> 6) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v240) < 9 )
              {
                if ( !v240 )
                {
                  v252 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v252 + 1;
                  v33[v252] = bswap32(v247);
                  v82 = *(_DWORD **)a1;
                  v69 = v56 & 1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_317;
                  goto LABEL_92;
                }
                v249 = *(_DWORD *)(a1 + 8);
                v250 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v246;
                v251 = (v249 << v246) | (v247 >> (8 - v246));
                *(_DWORD *)(a1 + 16) = v250 + 1;
                v33[v250] = HIBYTE(v251) | ((unsigned __int8)v251 << 24) | (v251 >> 8) & 0xFF00 | (BYTE1(v251) << 16);
              }
              else
              {
                v248 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v240 + 8;
                v247 = (a2 >> 6) & 0x3F | 0x80 | (v248 << 8);
              }
              *(_DWORD *)(a1 + 8) = v247;
              v82 = *(_DWORD **)a1;
              v69 = v56 & 1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_317;
              goto LABEL_92;
            }
            v243 = 1024 - (v242 & 0x3FF);
            if ( (v242 & 0x3FF) == 0 )
              v243 = 0;
            v244 = v243 + v241;
            if ( v243 + v241 )
            {
              v245 = realloc(v33, 4LL * v244);
              if ( !v245 )
                goto LABEL_305;
            }
            else
            {
              v245 = realloc(v33, 0);
              if ( !v245 )
                goto LABEL_312;
            }
            v33 = v245;
            *(_QWORD *)a1 = v245;
            *(_DWORD *)(a1 + 12) = v244;
          }
          v240 = *(_DWORD *)(a1 + 20);
          goto LABEL_310;
        }
        v117 = 1024 - (v116 & 0x3FF);
        if ( (v116 & 0x3FF) == 0 )
          v117 = 0;
        v118 = v117 + v115;
        if ( v117 + v115 )
        {
          v119 = realloc(v44, 4LL * v118);
          if ( !v119 )
          {
            free(v44);
            v33 = *(_DWORD **)a1;
            LOBYTE(v56) = 0;
            if ( !*(_QWORD *)a1 )
              goto LABEL_312;
            goto LABEL_298;
          }
          goto LABEL_146;
        }
        v119 = realloc(v44, 0);
        if ( v119 )
        {
LABEL_146:
          v44 = v119;
          *(_QWORD *)a1 = v119;
          *(_DWORD *)(a1 + 12) = v118;
          goto LABEL_147;
        }
LABEL_194:
        v33 = *(_DWORD **)a1;
        LOBYTE(v56) = 0;
        if ( !*(_QWORD *)a1 )
          goto LABEL_312;
        goto LABEL_298;
      }
LABEL_74:
      v57 = 0;
      v56 = 0;
LABEL_75:
      v70 = 0;
      v69 = v56 & v57;
      return (void *)(v70 & (unsigned int)v69);
    }
    if ( !(a2 >> 26) )
    {
      if ( !a1 )
        goto LABEL_73;
      v45 = *(void **)a1;
      if ( !*(_QWORD *)a1 )
        goto LABEL_73;
      v47 = *(_DWORD *)(a1 + 12);
      v46 = *(_DWORD *)(a1 + 16);
      if ( v47 <= v46 + 8 )
      {
        v48 = *(_DWORD *)(a1 + 20);
        v49 = v46 + ((unsigned int)(v48 + 39) >> 5);
        v9 = v49 >= v47;
        v50 = v49 - v47;
        if ( v50 == 0 || !v9 )
          goto LABEL_158;
        v51 = 1024 - (v50 & 0x3FF);
        if ( (v50 & 0x3FF) == 0 )
          v51 = 0;
        v52 = v51 + v49;
        if ( v51 + v49 )
        {
          v53 = realloc(*(void **)a1, 4LL * v52);
          if ( !v53 )
          {
            free(v45);
            v54 = 0;
            v55 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_217;
            goto LABEL_163;
          }
        }
        else
        {
          v53 = realloc(*(void **)a1, 0);
          if ( !v53 )
          {
            v54 = 0;
            v55 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_217;
            goto LABEL_163;
          }
        }
        v45 = v53;
        *(_QWORD *)a1 = v53;
        *(_DWORD *)(a1 + 12) = v52;
      }
      v48 = *(_DWORD *)(a1 + 20);
LABEL_158:
      v128 = 32 - v48;
      v129 = HIBYTE(a2) | 0xF8;
      if ( (unsigned int)(32 - v48) < 9 )
      {
        if ( !v48 )
        {
          v144 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v144 + 1;
          *((_DWORD *)v45 + v144) = bswap32(v129);
          v54 = 1;
          v55 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_217;
          goto LABEL_163;
        }
        v131 = *(_DWORD *)(a1 + 8);
        v132 = *(unsigned int *)(a1 + 16);
        *(_DWORD *)(a1 + 20) = 8 - v128;
        v133 = (v131 << v128) | (v129 >> (8 - v128));
        *(_DWORD *)(a1 + 16) = v132 + 1;
        *((_DWORD *)v45 + v132) = HIBYTE(v133)
                                | ((unsigned __int8)v133 << 24)
                                | (v133 >> 8) & 0xFF00
                                | (BYTE1(v133) << 16);
      }
      else
      {
        v130 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v48 + 8;
        v129 = HIBYTE(a2) | 0xF8 | (v130 << 8);
      }
      *(_DWORD *)(a1 + 8) = v129;
      v54 = 1;
      v55 = *(_DWORD **)a1;
      if ( !*(_QWORD *)a1 )
        goto LABEL_217;
LABEL_163:
      v135 = *(_DWORD *)(a1 + 12);
      v134 = *(_DWORD *)(a1 + 16);
      if ( v135 > v134 + 8 )
      {
LABEL_198:
        v136 = *(_DWORD *)(a1 + 20);
        goto LABEL_199;
      }
      v136 = *(_DWORD *)(a1 + 20);
      v137 = v134 + ((unsigned int)(v136 + 39) >> 5);
      v9 = v137 >= v135;
      v138 = v137 - v135;
      if ( v138 == 0 || !v9 )
      {
LABEL_199:
        v162 = 32 - v136;
        v163 = (a2 >> 18) & 0x3F | 0x80;
        if ( (unsigned int)(32 - v136) < 9 )
        {
          if ( v136 )
          {
            v165 = *(_DWORD *)(a1 + 8);
            v166 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 20) = 8 - v162;
            v167 = (v165 << v162) | (v163 >> (8 - v162));
            *(_DWORD *)(a1 + 16) = v166 + 1;
            v55[v166] = HIBYTE(v167) | ((unsigned __int8)v167 << 24) | (v167 >> 8) & 0xFF00 | (BYTE1(v167) << 16);
            *(_DWORD *)(a1 + 8) = v163;
          }
          else
          {
            v168 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v168 + 1;
            v55[v168] = bswap32(v163);
          }
        }
        else
        {
          v164 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v136 + 8;
          *(_DWORD *)(a1 + 8) = (a2 >> 18) & 0x3F | 0x80 | (v164 << 8);
        }
        v142 = *(_DWORD **)a1;
        v143 = v54 & 1;
        if ( !*(_QWORD *)a1 )
        {
LABEL_232:
          v33 = *(_DWORD **)a1;
          v32 = 0;
          if ( *(_QWORD *)a1 )
            goto LABEL_238;
          goto LABEL_312;
        }
LABEL_218:
        v177 = *(_DWORD *)(a1 + 12);
        v176 = *(_DWORD *)(a1 + 16);
        if ( v177 <= v176 + 8 )
        {
          v178 = *(_DWORD *)(a1 + 20);
          v179 = v176 + ((unsigned int)(v178 + 39) >> 5);
          v9 = v179 >= v177;
          v180 = v179 - v177;
          if ( v180 == 0 || !v9 )
          {
LABEL_230:
            v184 = 32 - v178;
            v185 = (a2 >> 12) & 0x3F | 0x80;
            if ( (unsigned int)(32 - v178) < 9 )
            {
              if ( v178 )
              {
                v187 = *(_DWORD *)(a1 + 8);
                v188 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v184;
                v189 = (v187 << v184) | (v185 >> (8 - v184));
                *(_DWORD *)(a1 + 16) = v188 + 1;
                v142[v188] = HIBYTE(v189) | ((unsigned __int8)v189 << 24) | (v189 >> 8) & 0xFF00 | (BYTE1(v189) << 16);
                *(_DWORD *)(a1 + 8) = v185;
              }
              else
              {
                v190 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v190 + 1;
                v142[v190] = bswap32(v185);
              }
            }
            else
            {
              v186 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 20) = v178 + 8;
              *(_DWORD *)(a1 + 8) = (a2 >> 12) & 0x3F | 0x80 | (v186 << 8);
            }
            v33 = *(_DWORD **)a1;
            v32 = v143 & 1;
            if ( *(_QWORD *)a1 )
              goto LABEL_238;
            goto LABEL_312;
          }
          v181 = 1024 - (v180 & 0x3FF);
          if ( (v180 & 0x3FF) == 0 )
            v181 = 0;
          v182 = v181 + v179;
          if ( v181 + v179 )
          {
            v183 = realloc(v142, 4LL * v182);
            if ( !v183 )
            {
              free(v142);
              v33 = *(_DWORD **)a1;
              v32 = 0;
              if ( *(_QWORD *)a1 )
                goto LABEL_238;
              goto LABEL_312;
            }
          }
          else
          {
            v183 = realloc(v142, 0);
            if ( !v183 )
              goto LABEL_232;
          }
          v142 = v183;
          *(_QWORD *)a1 = v183;
          *(_DWORD *)(a1 + 12) = v182;
        }
        v178 = *(_DWORD *)(a1 + 20);
        goto LABEL_230;
      }
      v139 = 1024 - (v138 & 0x3FF);
      if ( (v138 & 0x3FF) == 0 )
        v139 = 0;
      v140 = v139 + v137;
      if ( v139 + v137 )
      {
        v141 = realloc(v55, 4LL * v140);
        if ( !v141 )
        {
          free(v55);
          v142 = *(_DWORD **)a1;
          v143 = 0;
          if ( !*(_QWORD *)a1 )
            goto LABEL_232;
          goto LABEL_218;
        }
        goto LABEL_197;
      }
      v141 = realloc(v55, 0);
      if ( v141 )
      {
LABEL_197:
        v55 = v141;
        *(_QWORD *)a1 = v141;
        *(_DWORD *)(a1 + 12) = v140;
        goto LABEL_198;
      }
LABEL_217:
      v142 = *(_DWORD **)a1;
      v143 = 0;
      if ( !*(_QWORD *)a1 )
        goto LABEL_232;
      goto LABEL_218;
    }
    if ( !a1 )
      goto LABEL_73;
    v58 = *(void **)a1;
    if ( !*(_QWORD *)a1 )
      goto LABEL_74;
    v60 = *(_DWORD *)(a1 + 12);
    v59 = *(_DWORD *)(a1 + 16);
    if ( v60 <= v59 + 8 )
    {
      v61 = *(_DWORD *)(a1 + 20);
      v62 = v59 + ((unsigned int)(v61 + 39) >> 5);
      v9 = v62 >= v60;
      v63 = v62 - v60;
      if ( v63 == 0 || !v9 )
        goto LABEL_177;
      v64 = 1024 - (v63 & 0x3FF);
      if ( (v63 & 0x3FF) == 0 )
        v64 = 0;
      v65 = v64 + v62;
      if ( v64 + v62 )
      {
        v66 = realloc(*(void **)a1, 4LL * v65);
        if ( !v66 )
        {
          free(v58);
          v67 = 0;
          v68 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_258;
          goto LABEL_182;
        }
      }
      else
      {
        v66 = realloc(*(void **)a1, 0);
        if ( !v66 )
        {
          v67 = 0;
          v68 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_258;
          goto LABEL_182;
        }
      }
      v58 = v66;
      *(_QWORD *)a1 = v66;
      *(_DWORD *)(a1 + 12) = v65;
    }
    v61 = *(_DWORD *)(a1 + 20);
LABEL_177:
    v145 = 32 - v61;
    v146 = (a2 >> 30) | 0xFC;
    if ( (unsigned int)(32 - v61) < 9 )
    {
      if ( !v61 )
      {
        v161 = *(unsigned int *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v161 + 1;
        *((_DWORD *)v58 + v161) = bswap32(v146);
        v67 = 1;
        v68 = *(_DWORD **)a1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_258;
        goto LABEL_182;
      }
      v148 = *(_DWORD *)(a1 + 8);
      v149 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = 8 - v145;
      v150 = (v148 << v145) | (v146 >> (8 - v145));
      *(_DWORD *)(a1 + 16) = v149 + 1;
      *((_DWORD *)v58 + v149) = HIBYTE(v150)
                              | ((unsigned __int8)v150 << 24)
                              | (v150 >> 8) & 0xFF00
                              | (BYTE1(v150) << 16);
    }
    else
    {
      v147 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v61 + 8;
      v146 = (a2 >> 30) | 0xFC | (v147 << 8);
    }
    *(_DWORD *)(a1 + 8) = v146;
    v67 = 1;
    v68 = *(_DWORD **)a1;
    if ( !*(_QWORD *)a1 )
      goto LABEL_258;
LABEL_182:
    v152 = *(_DWORD *)(a1 + 12);
    v151 = *(_DWORD *)(a1 + 16);
    if ( v152 > v151 + 8 )
    {
LABEL_208:
      v153 = *(_DWORD *)(a1 + 20);
      goto LABEL_209;
    }
    v153 = *(_DWORD *)(a1 + 20);
    v154 = v151 + ((unsigned int)(v153 + 39) >> 5);
    v9 = v154 >= v152;
    v155 = v154 - v152;
    if ( v155 == 0 || !v9 )
    {
LABEL_209:
      v169 = 32 - v153;
      v170 = HIBYTE(a2) & 0x3F | 0x80;
      if ( (unsigned int)(32 - v153) < 9 )
      {
        if ( v153 )
        {
          v172 = *(_DWORD *)(a1 + 8);
          v173 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v169;
          v174 = (v172 << v169) | (v170 >> (8 - v169));
          *(_DWORD *)(a1 + 16) = v173 + 1;
          v68[v173] = HIBYTE(v174) | ((unsigned __int8)v174 << 24) | (v174 >> 8) & 0xFF00 | (BYTE1(v174) << 16);
          *(_DWORD *)(a1 + 8) = v170;
        }
        else
        {
          v175 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v175 + 1;
          v68[v175] = bswap32(v170);
        }
      }
      else
      {
        v171 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v153 + 8;
        *(_DWORD *)(a1 + 8) = HIBYTE(a2) & 0x3F | 0x80 | (v171 << 8);
      }
      v159 = *(_DWORD **)a1;
      v160 = v67 & 1;
      if ( !*(_QWORD *)a1 )
      {
LABEL_272:
        v217 = *(_DWORD **)a1;
        v218 = 0;
        if ( !*(_QWORD *)a1 )
          goto LABEL_292;
        goto LABEL_278;
      }
LABEL_259:
      v207 = *(_DWORD *)(a1 + 12);
      v206 = *(_DWORD *)(a1 + 16);
      if ( v207 <= v206 + 8 )
      {
        v208 = *(_DWORD *)(a1 + 20);
        v209 = v206 + ((unsigned int)(v208 + 39) >> 5);
        v9 = v209 >= v207;
        v210 = v209 - v207;
        if ( v210 == 0 || !v9 )
        {
LABEL_270:
          v214 = 32 - v208;
          v215 = (a2 >> 18) & 0x3F | 0x80;
          if ( (unsigned int)(32 - v208) < 9 )
          {
            if ( v208 )
            {
              v219 = *(_DWORD *)(a1 + 8);
              v220 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v214;
              v221 = (v219 << v214) | (v215 >> (8 - v214));
              *(_DWORD *)(a1 + 16) = v220 + 1;
              v159[v220] = HIBYTE(v221) | ((unsigned __int8)v221 << 24) | (v221 >> 8) & 0xFF00 | (BYTE1(v221) << 16);
              *(_DWORD *)(a1 + 8) = v215;
            }
            else
            {
              v222 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v222 + 1;
              v159[v222] = bswap32(v215);
            }
          }
          else
          {
            v216 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v208 + 8;
            *(_DWORD *)(a1 + 8) = (a2 >> 18) & 0x3F | 0x80 | (v216 << 8);
          }
          v217 = *(_DWORD **)a1;
          v218 = v160 & 1;
          if ( !*(_QWORD *)a1 )
          {
LABEL_292:
            v33 = *(_DWORD **)a1;
            v56 = 0;
            if ( *(_QWORD *)a1 )
              goto LABEL_298;
            goto LABEL_293;
          }
LABEL_278:
          v224 = *(_DWORD *)(a1 + 12);
          v223 = *(_DWORD *)(a1 + 16);
          if ( v224 <= v223 + 8 )
          {
            v225 = *(_DWORD *)(a1 + 20);
            v226 = v223 + ((unsigned int)(v225 + 39) >> 5);
            v9 = v226 >= v224;
            v227 = v226 - v224;
            if ( v227 == 0 || !v9 )
            {
LABEL_290:
              v231 = 32 - v225;
              v232 = (a2 >> 12) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v225) < 9 )
              {
                if ( v225 )
                {
                  v234 = *(_DWORD *)(a1 + 8);
                  v235 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v231;
                  v236 = (v234 << v231) | (v232 >> (8 - v231));
                  *(_DWORD *)(a1 + 16) = v235 + 1;
                  v217[v235] = HIBYTE(v236) | ((unsigned __int8)v236 << 24) | (v236 >> 8) & 0xFF00 | (BYTE1(v236) << 16);
                  *(_DWORD *)(a1 + 8) = v232;
                }
                else
                {
                  v237 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v237 + 1;
                  v217[v237] = bswap32(v232);
                }
              }
              else
              {
                v233 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v225 + 8;
                *(_DWORD *)(a1 + 8) = (a2 >> 12) & 0x3F | 0x80 | (v233 << 8);
              }
              v33 = *(_DWORD **)a1;
              v56 = v218 & 1;
              if ( *(_QWORD *)a1 )
                goto LABEL_298;
LABEL_293:
              v57 = 0;
              goto LABEL_75;
            }
            v228 = 1024 - (v227 & 0x3FF);
            if ( (v227 & 0x3FF) == 0 )
              v228 = 0;
            v229 = v228 + v226;
            if ( v228 + v226 )
            {
              v230 = realloc(v217, 4LL * v229);
              if ( !v230 )
              {
                free(v217);
                v33 = *(_DWORD **)a1;
                v56 = 0;
                if ( *(_QWORD *)a1 )
                  goto LABEL_298;
                goto LABEL_293;
              }
            }
            else
            {
              v230 = realloc(v217, 0);
              if ( !v230 )
                goto LABEL_292;
            }
            v217 = v230;
            *(_QWORD *)a1 = v230;
            *(_DWORD *)(a1 + 12) = v229;
          }
          v225 = *(_DWORD *)(a1 + 20);
          goto LABEL_290;
        }
        v211 = 1024 - (v210 & 0x3FF);
        if ( (v210 & 0x3FF) == 0 )
          v211 = 0;
        v212 = v211 + v209;
        if ( v211 + v209 )
        {
          v213 = realloc(v159, 4LL * v212);
          if ( !v213 )
          {
            free(v159);
            goto LABEL_272;
          }
        }
        else
        {
          v213 = realloc(v159, 0);
          if ( !v213 )
            goto LABEL_272;
        }
        v159 = v213;
        *(_QWORD *)a1 = v213;
        *(_DWORD *)(a1 + 12) = v212;
      }
      v208 = *(_DWORD *)(a1 + 20);
      goto LABEL_270;
    }
    v156 = 1024 - (v155 & 0x3FF);
    if ( (v155 & 0x3FF) == 0 )
      v156 = 0;
    v157 = v156 + v154;
    if ( v156 + v154 )
    {
      v158 = realloc(v68, 4LL * v157);
      if ( !v158 )
      {
        free(v68);
        v159 = *(_DWORD **)a1;
        v160 = 0;
        if ( !*(_QWORD *)a1 )
          goto LABEL_272;
        goto LABEL_259;
      }
      goto LABEL_207;
    }
    v158 = realloc(v68, 0);
    if ( v158 )
    {
LABEL_207:
      v68 = v158;
      *(_QWORD *)a1 = v158;
      *(_DWORD *)(a1 + 12) = v157;
      goto LABEL_208;
    }
LABEL_258:
    v159 = *(_DWORD **)a1;
    v160 = 0;
    if ( !*(_QWORD *)a1 )
      goto LABEL_272;
    goto LABEL_259;
  }
  if ( !a1 )
    return 0;
  v4 = *(void **)a1;
  if ( !*(_QWORD *)a1 )
    return 0;
  v6 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a1 + 16);
  if ( v6 > v5 + 8 )
    goto LABEL_78;
  v7 = *(_DWORD *)(a1 + 20);
  v8 = v5 + ((unsigned int)(v7 + 39) >> 5);
  v9 = v8 >= v6;
  v10 = v8 - v6;
  if ( v10 != 0 && v9 )
  {
    v11 = 1024 - (v10 & 0x3FF);
    if ( (v10 & 0x3FF) == 0 )
      v11 = 0;
    v12 = v11 + v8;
    if ( v11 + v8 )
    {
      result = realloc(*(void **)a1, 4LL * v12);
      if ( !result )
      {
        free(v4);
        return 0;
      }
    }
    else
    {
      result = realloc(*(void **)a1, 0);
      if ( !result )
        return result;
    }
    v4 = result;
    *(_QWORD *)a1 = result;
    *(_DWORD *)(a1 + 12) = v12;
LABEL_78:
    v7 = *(_DWORD *)(a1 + 20);
  }
  v71 = 32 - v7;
  if ( (unsigned int)(32 - v7) < 9 )
  {
    if ( v7 )
    {
      v73 = *(_DWORD *)(a1 + 8);
      v74 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = 8 - v71;
      v75 = (v73 << v71) | (a2 >> (8 - v71));
      *(_DWORD *)(a1 + 16) = v74 + 1;
      *((_DWORD *)v4 + v74) = HIBYTE(v75) | ((unsigned __int8)v75 << 24) | (v75 >> 8) & 0xFF00 | (BYTE1(v75) << 16);
      *(_DWORD *)(a1 + 8) = a2;
      return &dword_0 + 1;
    }
    else
    {
      v76 = *(unsigned int *)(a1 + 16);
      result = &dword_0 + 1;
      *(_DWORD *)(a1 + 16) = v76 + 1;
      *((_DWORD *)v4 + v76) = bswap32(a2);
    }
  }
  else
  {
    v72 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v7 + 8;
    result = &dword_0 + 1;
    *(_DWORD *)(a1 + 8) = a2 | (v72 << 8);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000187DC) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_write_utf8_uint64(__int64 a1, unsigned __int64 a2)
{
  void *result; // x0
  void *v5; // x21
  int v6; // w9
  unsigned int v7; // w10
  int v8; // w8
  unsigned int v9; // w9
  bool v10; // cf
  unsigned int v11; // w10
  int v12; // w8
  unsigned int v13; // w22
  void *v14; // x21
  int v15; // w9
  unsigned int v16; // w10
  int v17; // w8
  unsigned int v18; // w9
  unsigned int v19; // w10
  int v20; // w8
  unsigned int v21; // w22
  void *v22; // x0
  void *v23; // x21
  int v24; // w8
  unsigned int v25; // w10
  int v26; // w9
  unsigned int v27; // w8
  unsigned int v28; // w10
  int v29; // w9
  unsigned int v30; // w22
  void *v31; // x0
  char v32; // w22
  _DWORD *v33; // x21
  _DWORD *v34; // x21
  int v35; // w8
  unsigned int v36; // w10
  int v37; // w9
  unsigned int v38; // w8
  unsigned int v39; // w10
  int v40; // w9
  unsigned int v41; // w22
  _DWORD *v42; // x0
  char v43; // w22
  _DWORD *v44; // x21
  _DWORD *v45; // x21
  int v46; // w8
  unsigned int v47; // w10
  int v48; // w9
  unsigned int v49; // w8
  unsigned int v50; // w10
  int v51; // w9
  unsigned int v52; // w22
  _DWORD *v53; // x0
  char v54; // w22
  _DWORD *v55; // x21
  _DWORD *v56; // x21
  int v57; // w8
  unsigned int v58; // w10
  int v59; // w9
  unsigned int v60; // w8
  unsigned int v61; // w10
  int v62; // w9
  unsigned int v63; // w22
  _DWORD *v64; // x0
  char v65; // w22
  _DWORD *v66; // x21
  int v67; // w9
  int v68; // w9
  int v69; // w8
  __int64 v70; // x11
  unsigned int v71; // w8
  __int64 v72; // x8
  _DWORD *v73; // x21
  int v74; // w9
  unsigned int v75; // w10
  int v76; // w8
  unsigned int v77; // w9
  unsigned int v78; // w10
  int v79; // w8
  unsigned int v80; // w22
  _DWORD *v81; // x0
  char v82; // w23
  _DWORD *v83; // x21
  int v84; // w22
  int v85; // w8
  int v86; // w10
  unsigned int v87; // w9
  int v88; // w10
  _DWORD *v89; // x21
  int v90; // w8
  unsigned int v91; // w10
  int v92; // w9
  unsigned int v93; // w8
  unsigned int v94; // w10
  int v95; // w9
  unsigned int v96; // w23
  _DWORD *v97; // x0
  int v98; // w8
  __int64 v99; // x12
  int v100; // w10
  unsigned int v101; // w8
  int v102; // w10
  int v103; // w9
  __int64 v104; // x12
  unsigned int v105; // w9
  __int64 v106; // x9
  __int64 v107; // x10
  int v108; // w10
  unsigned int v109; // w8
  int v110; // w10
  int v111; // w9
  __int64 v112; // x12
  unsigned int v113; // w9
  __int64 v114; // x9
  unsigned int v115; // w10
  int v116; // w11
  char v117; // w22
  int v118; // w9
  unsigned int v119; // w8
  unsigned int v120; // w10
  int v121; // w9
  unsigned int v122; // w24
  void *v123; // x0
  _DWORD *v124; // x21
  char v125; // w22
  unsigned int v126; // w10
  int v127; // w11
  char v128; // w23
  int v129; // w9
  unsigned int v130; // w8
  unsigned int v131; // w10
  int v132; // w9
  unsigned int v133; // w24
  void *v134; // x0
  _DWORD *v135; // x21
  char v136; // w23
  int v137; // w10
  unsigned int v138; // w8
  int v139; // w10
  int v140; // w9
  __int64 v141; // x12
  unsigned int v142; // w9
  __int64 v143; // x9
  int v144; // w8
  unsigned int v145; // w10
  int v146; // w9
  unsigned int v147; // w8
  unsigned int v148; // w10
  int v149; // w9
  unsigned int v150; // w23
  _DWORD *v151; // x0
  int v152; // w10
  unsigned int v153; // w8
  int v154; // w10
  int v155; // w9
  __int64 v156; // x12
  unsigned int v157; // w9
  __int64 v158; // x9
  int v159; // w10
  unsigned int v160; // w8
  int v161; // w10
  int v162; // w9
  __int64 v163; // x12
  unsigned int v164; // w9
  __int64 v165; // x9
  int v166; // w8
  unsigned int v167; // w10
  int v168; // w9
  unsigned int v169; // w8
  unsigned int v170; // w10
  int v171; // w9
  unsigned int v172; // w23
  _DWORD *v173; // x0
  char v174; // w8
  _DWORD *v175; // x21
  int v176; // w10
  unsigned int v177; // w8
  int v178; // w10
  int v179; // w9
  __int64 v180; // x12
  unsigned int v181; // w9
  __int64 v182; // x9
  int v183; // w10
  unsigned int v184; // w8
  int v185; // w10
  int v186; // w9
  __int64 v187; // x12
  unsigned int v188; // w9
  __int64 v189; // x9
  int v190; // w8
  unsigned int v191; // w10
  int v192; // w9
  unsigned int v193; // w8
  unsigned int v194; // w10
  int v195; // w9
  unsigned int v196; // w23
  _DWORD *v197; // x0
  char v198; // w8
  void *v199; // x21
  int v200; // w9
  int v201; // w9
  int v202; // w8
  __int64 v203; // x12
  unsigned int v204; // w8
  __int64 v205; // x8
  int v206; // w8
  unsigned int v207; // w10
  int v208; // w9
  unsigned int v209; // w8
  unsigned int v210; // w10
  int v211; // w9
  unsigned int v212; // w22
  _DWORD *v213; // x0
  char v214; // w8
  void *v215; // x21
  int v216; // w10
  unsigned int v217; // w8
  int v218; // w10
  int v219; // w9
  __int64 v220; // x12
  unsigned int v221; // w9
  int v222; // w8
  unsigned int v223; // w10
  int v224; // w9
  unsigned int v225; // w8
  unsigned int v226; // w10
  int v227; // w9
  unsigned int v228; // w24
  _DWORD *v229; // x0
  char v230; // w22
  __int64 v231; // x9
  int v232; // w10
  unsigned int v233; // w8
  int v234; // w10
  int v235; // w9
  __int64 v236; // x12
  unsigned int v237; // w9
  int v238; // w8
  unsigned int v239; // w10
  int v240; // w9
  unsigned int v241; // w8
  unsigned int v242; // w10
  int v243; // w9
  unsigned int v244; // w24
  _DWORD *v245; // x0
  char v246; // w8
  _DWORD *v247; // x21
  __int64 v248; // x9
  unsigned int v249; // w10
  int v250; // w11
  char v251; // w22
  int v252; // w9
  unsigned int v253; // w8
  unsigned int v254; // w10
  int v255; // w9
  unsigned int v256; // w23
  _DWORD *v257; // x0
  int v258; // w10
  unsigned int v259; // w8
  int v260; // w10
  int v261; // w9
  __int64 v262; // x12
  unsigned int v263; // w9
  __int64 v264; // x9
  int v265; // w10
  unsigned int v266; // w8
  int v267; // w10
  int v268; // w9
  __int64 v269; // x12
  unsigned int v270; // w9
  __int64 v271; // x9
  int v272; // w10
  unsigned int v273; // w8
  int v274; // w10
  int v275; // w9
  __int64 v276; // x12
  unsigned int v277; // w9
  __int64 v278; // x9
  int v279; // w9
  unsigned int v280; // w10
  char v281; // w23
  int v282; // w8
  unsigned int v283; // w9
  unsigned int v284; // w10
  int v285; // w8
  unsigned int v286; // w24
  _DWORD *v287; // x0
  int v288; // w9
  unsigned int v289; // w22
  int v290; // w9
  int v291; // w8
  __int64 v292; // x11
  unsigned int v293; // w8
  int v294; // w8
  unsigned int v295; // w10
  int v296; // w9
  unsigned int v297; // w8
  unsigned int v298; // w10
  int v299; // w9
  unsigned int v300; // w23
  _DWORD *v301; // x0
  int v302; // w10
  unsigned int v303; // w8
  int v304; // w10
  int v305; // w9
  __int64 v306; // x12
  unsigned int v307; // w9
  __int64 v308; // x9
  __int64 v309; // x8
  int v310; // w10
  unsigned int v311; // w8
  int v312; // w10
  int v313; // w9
  __int64 v314; // x12
  unsigned int v315; // w9
  __int64 v316; // x9
  int v317; // w10
  unsigned int v318; // w8
  int v319; // w10
  int v320; // w9
  __int64 v321; // x12
  unsigned int v322; // w9
  __int64 v323; // x9
  int v324; // w9
  unsigned int v325; // w10
  int v326; // w8
  unsigned int v327; // w9
  unsigned int v328; // w10
  int v329; // w8
  unsigned int v330; // w24
  _DWORD *v331; // x0
  int v332; // w9
  unsigned int v333; // w23
  int v334; // w9
  int v335; // w8
  __int64 v336; // x11
  unsigned int v337; // w8
  __int64 v338; // x8

  if ( a2 >> 36 )
    return 0;
  if ( a2 > 0x7F )
  {
    if ( a2 <= 0x7FF )
    {
      if ( a1 )
      {
        v14 = *(void **)a1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_99;
        v16 = *(_DWORD *)(a1 + 12);
        v15 = *(_DWORD *)(a1 + 16);
        if ( v16 <= v15 + 8 )
        {
          v17 = *(_DWORD *)(a1 + 20);
          v18 = v15 + ((unsigned int)(v17 + 39) >> 5);
          v10 = v18 >= v16;
          v19 = v18 - v16;
          if ( v19 == 0 || !v10 )
            goto LABEL_97;
          v20 = 1024 - (v19 & 0x3FF);
          if ( (v19 & 0x3FF) == 0 )
            v20 = 0;
          v21 = v20 + v18;
          if ( v20 + v18 )
          {
            v22 = realloc(*(void **)a1, 4LL * v21);
            if ( !v22 )
            {
              free(v14);
              goto LABEL_99;
            }
          }
          else
          {
            v22 = realloc(*(void **)a1, 0);
            if ( !v22 )
            {
LABEL_99:
              v89 = *(_DWORD **)a1;
              v84 = 0;
              if ( !*(_QWORD *)a1 )
                goto LABEL_432;
              goto LABEL_100;
            }
          }
          v14 = v22;
          *(_QWORD *)a1 = v22;
          *(_DWORD *)(a1 + 12) = v21;
        }
        v17 = *(_DWORD *)(a1 + 20);
LABEL_97:
        v86 = 32 - v17;
        v87 = (a2 >> 6) | 0xC0;
        if ( (unsigned int)(32 - v17) >= 9 )
        {
          v88 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v17 + 8;
          v87 |= v88 << 8;
          goto LABEL_110;
        }
        if ( v17 )
        {
          v98 = *(_DWORD *)(a1 + 8);
          v99 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v86;
          *(_DWORD *)(a1 + 16) = v99 + 1;
          *((_DWORD *)v14 + v99) = (((v98 << v86) | (v87 >> (8 - v86))) >> 24)
                                 | ((unsigned __int8)(((_BYTE)v98 << v86) | (v87 >> (8 - v86))) << 24)
                                 | (((v98 << v86) | (v87 >> (8 - v86))) >> 8) & 0xFF00
                                 | ((unsigned __int8)((unsigned __int16)(((_WORD)v98 << v86) | (v87 >> (8 - v86))) >> 8) << 16);
LABEL_110:
          *(_DWORD *)(a1 + 8) = v87;
          v89 = *(_DWORD **)a1;
          v84 = 1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_432;
          goto LABEL_100;
        }
        v107 = *(unsigned int *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v107 + 1;
        *((_DWORD *)v14 + v107) = bswap32(v87);
        v89 = *(_DWORD **)a1;
        v84 = 1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_432;
LABEL_100:
        v91 = *(_DWORD *)(a1 + 12);
        v90 = *(_DWORD *)(a1 + 16);
        if ( v91 > v90 + 8 )
        {
LABEL_114:
          v92 = *(_DWORD *)(a1 + 20);
LABEL_115:
          v100 = 32 - v92;
          v101 = a2 & 0x3F | 0x80;
          if ( (unsigned int)(32 - v92) < 9 )
          {
            if ( v92 )
            {
              v103 = *(_DWORD *)(a1 + 8);
              v104 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v100;
              v105 = (v103 << v100) | (v101 >> (8 - v100));
              *(_DWORD *)(a1 + 16) = v104 + 1;
              v89[v104] = HIBYTE(v105) | ((unsigned __int8)v105 << 24) | (v105 >> 8) & 0xFF00 | (BYTE1(v105) << 16);
              *(_DWORD *)(a1 + 8) = v101;
            }
            else
            {
              v106 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v106 + 1;
              v89[v106] = bswap32(v101);
            }
          }
          else
          {
            v102 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v92 + 8;
            *(_DWORD *)(a1 + 8) = a2 & 0x3F | 0x80 | (v102 << 8);
          }
          v85 = 1;
          return (void *)(v85 & (unsigned int)v84);
        }
        v92 = *(_DWORD *)(a1 + 20);
        v93 = v90 + ((unsigned int)(v92 + 39) >> 5);
        v10 = v93 >= v91;
        v94 = v93 - v91;
        if ( v94 == 0 || !v10 )
          goto LABEL_115;
        v95 = 1024 - (v94 & 0x3FF);
        if ( (v94 & 0x3FF) == 0 )
          v95 = 0;
        v96 = v95 + v93;
        if ( v95 + v93 )
        {
          v97 = realloc(v89, 4LL * v96);
          if ( !v97 )
          {
            free(v89);
            v85 = 0;
            return (void *)(v85 & (unsigned int)v84);
          }
          goto LABEL_113;
        }
        v97 = realloc(v89, 0);
        if ( v97 )
        {
LABEL_113:
          v89 = v97;
          *(_QWORD *)a1 = v97;
          *(_DWORD *)(a1 + 12) = v96;
          goto LABEL_114;
        }
LABEL_432:
        v85 = 0;
        return (void *)(v85 & (unsigned int)v84);
      }
LABEL_92:
      v84 = 0;
      v85 = 0;
      return (void *)(v85 & (unsigned int)v84);
    }
    if ( !(a2 >> 16) )
    {
      if ( !a1 )
        goto LABEL_92;
      v23 = *(void **)a1;
      if ( *(_QWORD *)a1 )
      {
        v25 = *(_DWORD *)(a1 + 12);
        v24 = *(_DWORD *)(a1 + 16);
        if ( v25 <= v24 + 8 )
        {
          v26 = *(_DWORD *)(a1 + 20);
          v27 = v24 + ((unsigned int)(v26 + 39) >> 5);
          v10 = v27 >= v25;
          v28 = v27 - v25;
          if ( v28 == 0 || !v10 )
            goto LABEL_127;
          v29 = 1024 - (v28 & 0x3FF);
          if ( (v28 & 0x3FF) == 0 )
            v29 = 0;
          v30 = v29 + v27;
          if ( v29 + v27 )
          {
            v31 = realloc(*(void **)a1, 4LL * v30);
            if ( !v31 )
            {
              free(v23);
              v32 = 0;
              v33 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_431;
              goto LABEL_357;
            }
          }
          else
          {
            v31 = realloc(*(void **)a1, 0);
            if ( !v31 )
            {
              v32 = 0;
              v33 = *(_DWORD **)a1;
              if ( *(_QWORD *)a1 )
                goto LABEL_357;
              goto LABEL_431;
            }
          }
          v23 = v31;
          *(_QWORD *)a1 = v31;
          *(_DWORD *)(a1 + 12) = v30;
        }
        v26 = *(_DWORD *)(a1 + 20);
LABEL_127:
        v108 = 32 - v26;
        v109 = (a2 >> 12) | 0xE0;
        if ( (unsigned int)(32 - v26) >= 9 )
        {
          v110 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v26 + 8;
          *(_DWORD *)(a1 + 8) = v109 | (v110 << 8);
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_431;
LABEL_357:
          v295 = *(_DWORD *)(a1 + 12);
          v294 = *(_DWORD *)(a1 + 16);
          if ( v295 <= v294 + 8 )
          {
            v296 = *(_DWORD *)(a1 + 20);
            v297 = v294 + ((unsigned int)(v296 + 39) >> 5);
            v10 = v297 >= v295;
            v298 = v297 - v295;
            if ( v298 == 0 || !v10 )
            {
LABEL_368:
              v302 = 32 - v296;
              v303 = ((unsigned int)a2 >> 6) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v296) < 9 )
              {
                if ( !v296 )
                {
                  v308 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v308 + 1;
                  v33[v308] = bswap32(v303);
                  v89 = *(_DWORD **)a1;
                  v84 = v32 & 1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_432;
                  goto LABEL_100;
                }
                v305 = *(_DWORD *)(a1 + 8);
                v306 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v302;
                v307 = (v305 << v302) | (v303 >> (8 - v302));
                *(_DWORD *)(a1 + 16) = v306 + 1;
                v33[v306] = HIBYTE(v307) | ((unsigned __int8)v307 << 24) | (v307 >> 8) & 0xFF00 | (BYTE1(v307) << 16);
              }
              else
              {
                v304 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v296 + 8;
                v303 = ((unsigned int)a2 >> 6) & 0x3F | 0x80 | (v304 << 8);
              }
              *(_DWORD *)(a1 + 8) = v303;
              v89 = *(_DWORD **)a1;
              v84 = v32 & 1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_432;
              goto LABEL_100;
            }
            v299 = 1024 - (v298 & 0x3FF);
            if ( (v298 & 0x3FF) == 0 )
              v299 = 0;
            v300 = v299 + v297;
            if ( v299 + v297 )
            {
              v301 = realloc(v33, 4LL * v300);
              if ( !v301 )
              {
LABEL_364:
                free(v33);
                goto LABEL_431;
              }
            }
            else
            {
              v301 = realloc(v33, 0);
              if ( !v301 )
                goto LABEL_431;
            }
            v33 = v301;
            *(_QWORD *)a1 = v301;
            *(_DWORD *)(a1 + 12) = v300;
          }
          v296 = *(_DWORD *)(a1 + 20);
          goto LABEL_368;
        }
        if ( v26 )
        {
          v111 = *(_DWORD *)(a1 + 8);
          v112 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = 8 - v108;
          v113 = (v111 << v108) | (v109 >> (8 - v108));
          *(_DWORD *)(a1 + 16) = v112 + 1;
          *((_DWORD *)v23 + v112) = HIBYTE(v113)
                                  | ((unsigned __int8)v113 << 24)
                                  | (v113 >> 8) & 0xFF00
                                  | (BYTE1(v113) << 16);
          *(_DWORD *)(a1 + 8) = v109;
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( *(_QWORD *)a1 )
            goto LABEL_357;
        }
        else
        {
          v114 = *(unsigned int *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v114 + 1;
          *((_DWORD *)v23 + v114) = bswap32(v109);
          v32 = 1;
          v33 = *(_DWORD **)a1;
          if ( *(_QWORD *)a1 )
            goto LABEL_357;
        }
LABEL_431:
        v89 = *(_DWORD **)a1;
        v84 = 0;
        if ( !*(_QWORD *)a1 )
          goto LABEL_432;
        goto LABEL_100;
      }
LABEL_428:
      v89 = *(_DWORD **)a1;
      v84 = 0;
      if ( !*(_QWORD *)a1 )
        goto LABEL_432;
      goto LABEL_100;
    }
    if ( !(a2 >> 21) )
    {
      if ( !a1 )
        goto LABEL_92;
      v34 = *(_DWORD **)a1;
      if ( !*(_QWORD *)a1 )
        goto LABEL_431;
      v36 = *(_DWORD *)(a1 + 12);
      v35 = *(_DWORD *)(a1 + 16);
      if ( v36 <= v35 + 8 )
      {
        v37 = *(_DWORD *)(a1 + 20);
        v38 = v35 + ((unsigned int)(v37 + 39) >> 5);
        v10 = v38 >= v36;
        v39 = v38 - v36;
        if ( v39 == 0 || !v10 )
        {
LABEL_158:
          v137 = 32 - v37;
          v138 = (a2 >> 18) | 0xF0;
          if ( (unsigned int)(32 - v37) < 9 )
          {
            if ( v37 )
            {
              v140 = *(_DWORD *)(a1 + 8);
              v141 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v137;
              v142 = (v140 << v137) | (v138 >> (8 - v137));
              *(_DWORD *)(a1 + 16) = v141 + 1;
              v34[v141] = HIBYTE(v142) | ((unsigned __int8)v142 << 24) | (v142 >> 8) & 0xFF00 | (BYTE1(v142) << 16);
              *(_DWORD *)(a1 + 8) = v138;
              v43 = 1;
              v44 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
              {
LABEL_206:
                v33 = *(_DWORD **)a1;
                v32 = 0;
                if ( *(_QWORD *)a1 )
                  goto LABEL_357;
                goto LABEL_431;
              }
            }
            else
            {
              v143 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v143 + 1;
              v34[v143] = bswap32(v138);
              v43 = 1;
              v44 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_206;
            }
          }
          else
          {
            v139 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v37 + 8;
            *(_DWORD *)(a1 + 8) = v138 | (v139 << 8);
            v43 = 1;
            v44 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_206;
          }
LABEL_165:
          v145 = *(_DWORD *)(a1 + 12);
          v144 = *(_DWORD *)(a1 + 16);
          if ( v145 <= v144 + 8 )
          {
            v146 = *(_DWORD *)(a1 + 20);
            v147 = v144 + ((unsigned int)(v146 + 39) >> 5);
            v10 = v147 >= v145;
            v148 = v147 - v145;
            if ( v148 == 0 || !v10 )
            {
LABEL_179:
              v152 = 32 - v146;
              v153 = ((unsigned int)a2 >> 12) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v146) < 9 )
              {
                if ( v146 )
                {
                  v155 = *(_DWORD *)(a1 + 8);
                  v156 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v152;
                  v157 = (v155 << v152) | (v153 >> (8 - v152));
                  *(_DWORD *)(a1 + 16) = v156 + 1;
                  v44[v156] = HIBYTE(v157) | ((unsigned __int8)v157 << 24) | (v157 >> 8) & 0xFF00 | (BYTE1(v157) << 16);
                  *(_DWORD *)(a1 + 8) = v153;
                }
                else
                {
                  v158 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v158 + 1;
                  v44[v158] = bswap32(v153);
                }
              }
              else
              {
                v154 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v146 + 8;
                *(_DWORD *)(a1 + 8) = ((unsigned int)a2 >> 12) & 0x3F | 0x80 | (v154 << 8);
              }
              v33 = *(_DWORD **)a1;
              v32 = v43 & 1;
              if ( *(_QWORD *)a1 )
                goto LABEL_357;
              goto LABEL_431;
            }
            v149 = 1024 - (v148 & 0x3FF);
            if ( (v148 & 0x3FF) == 0 )
              v149 = 0;
            v150 = v149 + v147;
            if ( v149 + v147 )
            {
              v151 = realloc(v44, 4LL * v150);
              if ( !v151 )
              {
                free(v44);
                v33 = *(_DWORD **)a1;
                v32 = 0;
                if ( *(_QWORD *)a1 )
                  goto LABEL_357;
                goto LABEL_431;
              }
            }
            else
            {
              v151 = realloc(v44, 0);
              if ( !v151 )
                goto LABEL_206;
            }
            v44 = v151;
            *(_QWORD *)a1 = v151;
            *(_DWORD *)(a1 + 12) = v150;
          }
          v146 = *(_DWORD *)(a1 + 20);
          goto LABEL_179;
        }
        v40 = 1024 - (v39 & 0x3FF);
        if ( (v39 & 0x3FF) == 0 )
          v40 = 0;
        v41 = v40 + v38;
        if ( v40 + v38 )
        {
          v42 = realloc(*(void **)a1, 4LL * v41);
          if ( !v42 )
          {
            free(v34);
            v43 = 0;
            v44 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_206;
            goto LABEL_165;
          }
        }
        else
        {
          v42 = realloc(*(void **)a1, 0);
          if ( !v42 )
          {
            v43 = 0;
            v44 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_206;
            goto LABEL_165;
          }
        }
        v34 = v42;
        *(_QWORD *)a1 = v42;
        *(_DWORD *)(a1 + 12) = v41;
      }
      v37 = *(_DWORD *)(a1 + 20);
      goto LABEL_158;
    }
    if ( !(a2 >> 26) )
    {
      if ( !a1 )
        goto LABEL_92;
      v45 = *(_DWORD **)a1;
      if ( !*(_QWORD *)a1 )
        goto LABEL_428;
      v47 = *(_DWORD *)(a1 + 12);
      v46 = *(_DWORD *)(a1 + 16);
      if ( v47 <= v46 + 8 )
      {
        v48 = *(_DWORD *)(a1 + 20);
        v49 = v46 + ((unsigned int)(v48 + 39) >> 5);
        v10 = v49 >= v47;
        v50 = v49 - v47;
        if ( v50 == 0 || !v10 )
        {
LABEL_189:
          v159 = 32 - v48;
          v160 = (a2 >> 24) | 0xF8;
          if ( (unsigned int)(32 - v48) < 9 )
          {
            if ( v48 )
            {
              v162 = *(_DWORD *)(a1 + 8);
              v163 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v159;
              v164 = (v162 << v159) | (v160 >> (8 - v159));
              *(_DWORD *)(a1 + 16) = v163 + 1;
              v45[v163] = HIBYTE(v164) | ((unsigned __int8)v164 << 24) | (v164 >> 8) & 0xFF00 | (BYTE1(v164) << 16);
              *(_DWORD *)(a1 + 8) = v160;
              v54 = 1;
              v55 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
              {
LABEL_296:
                v174 = 0;
                v175 = *(_DWORD **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_428;
                goto LABEL_297;
              }
            }
            else
            {
              v165 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v165 + 1;
              v45[v165] = bswap32(v160);
              v54 = 1;
              v55 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_296;
            }
          }
          else
          {
            v161 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v48 + 8;
            *(_DWORD *)(a1 + 8) = v160 | (v161 << 8);
            v54 = 1;
            v55 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_296;
          }
LABEL_196:
          v167 = *(_DWORD *)(a1 + 12);
          v166 = *(_DWORD *)(a1 + 16);
          if ( v167 <= v166 + 8 )
          {
            v168 = *(_DWORD *)(a1 + 20);
            v169 = v166 + ((unsigned int)(v168 + 39) >> 5);
            v10 = v169 >= v167;
            v170 = v169 - v167;
            if ( v170 == 0 || !v10 )
            {
LABEL_211:
              v176 = 32 - v168;
              v177 = ((unsigned int)a2 >> 18) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v168) < 9 )
              {
                if ( v168 )
                {
                  v179 = *(_DWORD *)(a1 + 8);
                  v180 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v176;
                  v181 = (v179 << v176) | (v177 >> (8 - v176));
                  *(_DWORD *)(a1 + 16) = v180 + 1;
                  v55[v180] = HIBYTE(v181) | ((unsigned __int8)v181 << 24) | (v181 >> 8) & 0xFF00 | (BYTE1(v181) << 16);
                  *(_DWORD *)(a1 + 8) = v177;
                  v174 = 1;
                  v175 = *(_DWORD **)a1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_428;
                }
                else
                {
                  v182 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v182 + 1;
                  v55[v182] = bswap32(v177);
                  v174 = 1;
                  v175 = *(_DWORD **)a1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_428;
                }
              }
              else
              {
                v178 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v168 + 8;
                *(_DWORD *)(a1 + 8) = ((unsigned int)a2 >> 18) & 0x3F | 0x80 | (v178 << 8);
                v174 = 1;
                v175 = *(_DWORD **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_428;
              }
LABEL_297:
              v249 = *(_DWORD *)(a1 + 12);
              v250 = *(_DWORD *)(a1 + 16);
              v251 = v174 & v54;
              if ( v249 <= v250 + 8 )
              {
                v252 = *(_DWORD *)(a1 + 20);
                v253 = v250 + ((unsigned int)(v252 + 39) >> 5);
                v10 = v253 >= v249;
                v254 = v253 - v249;
                if ( v254 == 0 || !v10 )
                {
LABEL_309:
                  v258 = 32 - v252;
                  v259 = ((unsigned int)a2 >> 12) & 0x3F | 0x80;
                  if ( (unsigned int)(32 - v252) < 9 )
                  {
                    if ( !v252 )
                    {
                      v264 = *(unsigned int *)(a1 + 16);
                      *(_DWORD *)(a1 + 16) = v264 + 1;
                      v175[v264] = bswap32(v259);
                      v33 = *(_DWORD **)a1;
                      v32 = v251 & 1;
                      if ( *(_QWORD *)a1 )
                        goto LABEL_357;
                      goto LABEL_431;
                    }
                    v261 = *(_DWORD *)(a1 + 8);
                    v262 = *(unsigned int *)(a1 + 16);
                    *(_DWORD *)(a1 + 20) = 8 - v258;
                    v263 = (v261 << v258) | (v259 >> (8 - v258));
                    *(_DWORD *)(a1 + 16) = v262 + 1;
                    v175[v262] = HIBYTE(v263)
                               | ((unsigned __int8)v263 << 24)
                               | (v263 >> 8) & 0xFF00
                               | (BYTE1(v263) << 16);
                  }
                  else
                  {
                    v260 = *(_DWORD *)(a1 + 8);
                    *(_DWORD *)(a1 + 20) = v252 + 8;
                    v259 = ((unsigned int)a2 >> 12) & 0x3F | 0x80 | (v260 << 8);
                  }
                  *(_DWORD *)(a1 + 8) = v259;
                  v33 = *(_DWORD **)a1;
                  v32 = v251 & 1;
                  if ( *(_QWORD *)a1 )
                    goto LABEL_357;
                  goto LABEL_431;
                }
                v255 = 1024 - (v254 & 0x3FF);
                if ( (v254 & 0x3FF) == 0 )
                  v255 = 0;
                v256 = v255 + v253;
                if ( v255 + v253 )
                {
                  v257 = realloc(v175, 4LL * v256);
                  if ( !v257 )
                  {
                    free(v175);
                    v33 = *(_DWORD **)a1;
                    v32 = 0;
                    if ( *(_QWORD *)a1 )
                      goto LABEL_357;
                    goto LABEL_431;
                  }
                }
                else
                {
                  v257 = realloc(v175, 0);
                  if ( !v257 )
                  {
                    v33 = *(_DWORD **)a1;
                    v32 = 0;
                    if ( *(_QWORD *)a1 )
                      goto LABEL_357;
                    goto LABEL_431;
                  }
                }
                v175 = v257;
                *(_QWORD *)a1 = v257;
                *(_DWORD *)(a1 + 12) = v256;
              }
              v252 = *(_DWORD *)(a1 + 20);
              goto LABEL_309;
            }
            v171 = 1024 - (v170 & 0x3FF);
            if ( (v170 & 0x3FF) == 0 )
              v171 = 0;
            v172 = v171 + v169;
            if ( v171 + v169 )
            {
              v173 = realloc(v55, 4LL * v172);
              if ( !v173 )
              {
                free(v55);
                v174 = 0;
                v175 = *(_DWORD **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_428;
                goto LABEL_297;
              }
            }
            else
            {
              v173 = realloc(v55, 0);
              if ( !v173 )
                goto LABEL_296;
            }
            v55 = v173;
            *(_QWORD *)a1 = v173;
            *(_DWORD *)(a1 + 12) = v172;
          }
          v168 = *(_DWORD *)(a1 + 20);
          goto LABEL_211;
        }
        v51 = 1024 - (v50 & 0x3FF);
        if ( (v50 & 0x3FF) == 0 )
          v51 = 0;
        v52 = v51 + v49;
        if ( v51 + v49 )
        {
          v53 = realloc(*(void **)a1, 4LL * v52);
          if ( !v53 )
          {
            free(v45);
            v54 = 0;
            v55 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_296;
            goto LABEL_196;
          }
        }
        else
        {
          v53 = realloc(*(void **)a1, 0);
          if ( !v53 )
          {
            v54 = 0;
            v55 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_296;
            goto LABEL_196;
          }
        }
        v45 = v53;
        *(_QWORD *)a1 = v53;
        *(_DWORD *)(a1 + 12) = v52;
      }
      v48 = *(_DWORD *)(a1 + 20);
      goto LABEL_189;
    }
    if ( !(a2 >> 31) )
    {
      if ( !a1 )
        goto LABEL_92;
      v56 = *(_DWORD **)a1;
      if ( !*(_QWORD *)a1 )
        goto LABEL_328;
      v58 = *(_DWORD *)(a1 + 12);
      v57 = *(_DWORD *)(a1 + 16);
      if ( v58 <= v57 + 8 )
      {
        v59 = *(_DWORD *)(a1 + 20);
        v60 = v57 + ((unsigned int)(v59 + 39) >> 5);
        v10 = v60 >= v58;
        v61 = v60 - v58;
        if ( v61 == 0 || !v10 )
        {
LABEL_222:
          v183 = 32 - v59;
          v184 = (a2 >> 30) | 0xFC;
          if ( (unsigned int)(32 - v59) < 9 )
          {
            if ( v59 )
            {
              v186 = *(_DWORD *)(a1 + 8);
              v187 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v183;
              v188 = (v186 << v183) | (v184 >> (8 - v183));
              *(_DWORD *)(a1 + 16) = v187 + 1;
              v56[v187] = HIBYTE(v188) | ((unsigned __int8)v188 << 24) | (v188 >> 8) & 0xFF00 | (BYTE1(v188) << 16);
              *(_DWORD *)(a1 + 8) = v184;
              v65 = 1;
              v66 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
              {
LABEL_400:
                v198 = 0;
                v199 = *(void **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_328;
LABEL_136:
                v115 = *(_DWORD *)(a1 + 12);
                v116 = *(_DWORD *)(a1 + 16);
                v117 = v198 & v65;
                if ( v115 <= v116 + 8 )
                {
                  v118 = *(_DWORD *)(a1 + 20);
                  v119 = v116 + ((unsigned int)(v118 + 39) >> 5);
                  v10 = v119 >= v115;
                  v120 = v119 - v115;
                  if ( v120 == 0 || !v10 )
                    goto LABEL_260;
                  v121 = 1024 - (v120 & 0x3FF);
                  if ( (v120 & 0x3FF) == 0 )
                    v121 = 0;
                  v122 = v121 + v119;
                  if ( v121 + v119 )
                  {
                    v123 = realloc(v199, 4LL * v122);
                    if ( !v123 )
                    {
                      free(v199);
                      v124 = *(_DWORD **)a1;
                      v125 = 0;
                      if ( !*(_QWORD *)a1 )
                        goto LABEL_406;
                      goto LABEL_265;
                    }
                  }
                  else
                  {
                    v123 = realloc(v199, 0);
                    if ( !v123 )
                    {
                      v124 = *(_DWORD **)a1;
                      v125 = 0;
                      if ( !*(_QWORD *)a1 )
                        goto LABEL_406;
                      goto LABEL_265;
                    }
                  }
                  v199 = v123;
                  *(_QWORD *)a1 = v123;
                  *(_DWORD *)(a1 + 12) = v122;
                }
                v118 = *(_DWORD *)(a1 + 20);
LABEL_260:
                v216 = 32 - v118;
                v217 = ((unsigned int)a2 >> 18) & 0x3F | 0x80;
                if ( (unsigned int)(32 - v118) < 9 )
                {
                  if ( !v118 )
                  {
                    v231 = *(unsigned int *)(a1 + 16);
                    *(_DWORD *)(a1 + 16) = v231 + 1;
                    *((_DWORD *)v199 + v231) = bswap32(v217);
                    v124 = *(_DWORD **)a1;
                    v125 = v117 & 1;
                    if ( !*(_QWORD *)a1 )
                      goto LABEL_406;
                    goto LABEL_265;
                  }
                  v219 = *(_DWORD *)(a1 + 8);
                  v220 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v216;
                  v221 = (v219 << v216) | (v217 >> (8 - v216));
                  *(_DWORD *)(a1 + 16) = v220 + 1;
                  *((_DWORD *)v199 + v220) = HIBYTE(v221)
                                           | ((unsigned __int8)v221 << 24)
                                           | (v221 >> 8) & 0xFF00
                                           | (BYTE1(v221) << 16);
                }
                else
                {
                  v218 = *(_DWORD *)(a1 + 8);
                  *(_DWORD *)(a1 + 20) = v118 + 8;
                  v217 = ((unsigned int)a2 >> 18) & 0x3F | 0x80 | (v218 << 8);
                }
                *(_DWORD *)(a1 + 8) = v217;
                v124 = *(_DWORD **)a1;
                v125 = v117 & 1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_406;
LABEL_265:
                v223 = *(_DWORD *)(a1 + 12);
                v222 = *(_DWORD *)(a1 + 16);
                if ( v223 > v222 + 8 )
                {
LABEL_380:
                  v224 = *(_DWORD *)(a1 + 20);
                  goto LABEL_381;
                }
                v224 = *(_DWORD *)(a1 + 20);
                v225 = v222 + ((unsigned int)(v224 + 39) >> 5);
                v10 = v225 >= v223;
                v226 = v225 - v223;
                if ( v226 == 0 || !v10 )
                {
LABEL_381:
                  v310 = 32 - v224;
                  v311 = ((unsigned int)a2 >> 12) & 0x3F | 0x80;
                  if ( (unsigned int)(32 - v224) < 9 )
                  {
                    if ( v224 )
                    {
                      v313 = *(_DWORD *)(a1 + 8);
                      v314 = *(unsigned int *)(a1 + 16);
                      *(_DWORD *)(a1 + 20) = 8 - v310;
                      v315 = (v313 << v310) | (v311 >> (8 - v310));
                      *(_DWORD *)(a1 + 16) = v314 + 1;
                      v124[v314] = HIBYTE(v315)
                                 | ((unsigned __int8)v315 << 24)
                                 | (v315 >> 8) & 0xFF00
                                 | (BYTE1(v315) << 16);
                      *(_DWORD *)(a1 + 8) = v311;
                    }
                    else
                    {
                      v316 = *(unsigned int *)(a1 + 16);
                      *(_DWORD *)(a1 + 16) = v316 + 1;
                      v124[v316] = bswap32(v311);
                    }
                  }
                  else
                  {
                    v312 = *(_DWORD *)(a1 + 8);
                    *(_DWORD *)(a1 + 20) = v224 + 8;
                    *(_DWORD *)(a1 + 8) = ((unsigned int)a2 >> 12) & 0x3F | 0x80 | (v312 << 8);
                  }
                  v33 = *(_DWORD **)a1;
                  v230 = v125 & 1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_431;
LABEL_407:
                  v325 = *(_DWORD *)(a1 + 12);
                  v324 = *(_DWORD *)(a1 + 16);
                  if ( v325 <= v324 + 8 )
                  {
                    v326 = *(_DWORD *)(a1 + 20);
                    v327 = v324 + ((unsigned int)(v326 + 39) >> 5);
                    v10 = v327 >= v325;
                    v328 = v327 - v325;
                    if ( v328 == 0 || !v10 )
                    {
LABEL_418:
                      v332 = 32 - v326;
                      v333 = ((unsigned int)a2 >> 6) & 0x3F | 0x80;
                      if ( (unsigned int)(32 - v326) < 9 )
                      {
                        if ( v326 )
                        {
                          v335 = *(_DWORD *)(a1 + 8);
                          v336 = *(unsigned int *)(a1 + 16);
                          *(_DWORD *)(a1 + 20) = 8 - v332;
                          v337 = (v335 << v332) | (v333 >> (8 - v332));
                          *(_DWORD *)(a1 + 16) = v336 + 1;
                          v33[v336] = HIBYTE(v337)
                                    | ((unsigned __int8)v337 << 24)
                                    | (v337 >> 8) & 0xFF00
                                    | (BYTE1(v337) << 16);
                          *(_DWORD *)(a1 + 8) = v333;
                          v89 = *(_DWORD **)a1;
                          v84 = v230 & 1;
                          if ( !*(_QWORD *)a1 )
                            goto LABEL_432;
                        }
                        else
                        {
                          v338 = *(unsigned int *)(a1 + 16);
                          *(_DWORD *)(a1 + 16) = v338 + 1;
                          v33[v338] = bswap32(v333);
                          v89 = *(_DWORD **)a1;
                          v84 = v230 & 1;
                          if ( !*(_QWORD *)a1 )
                            goto LABEL_432;
                        }
                      }
                      else
                      {
                        v334 = *(_DWORD *)(a1 + 8);
                        *(_DWORD *)(a1 + 20) = v326 + 8;
                        *(_DWORD *)(a1 + 8) = ((unsigned int)a2 >> 6) & 0x3F | 0x80 | (v334 << 8);
                        v89 = *(_DWORD **)a1;
                        v84 = v230 & 1;
                        if ( !*(_QWORD *)a1 )
                          goto LABEL_432;
                      }
                      goto LABEL_100;
                    }
                    v329 = 1024 - (v328 & 0x3FF);
                    if ( (v328 & 0x3FF) == 0 )
                      v329 = 0;
                    v330 = v329 + v327;
                    if ( v329 + v327 )
                    {
                      v331 = realloc(v33, 4LL * v330);
                      if ( !v331 )
                        goto LABEL_364;
                    }
                    else
                    {
                      v331 = realloc(v33, 0);
                      if ( !v331 )
                        goto LABEL_431;
                    }
                    v33 = v331;
                    *(_QWORD *)a1 = v331;
                    *(_DWORD *)(a1 + 12) = v330;
                  }
                  v326 = *(_DWORD *)(a1 + 20);
                  goto LABEL_418;
                }
                v227 = 1024 - (v226 & 0x3FF);
                if ( (v226 & 0x3FF) == 0 )
                  v227 = 0;
                v228 = v227 + v225;
                if ( v227 + v225 )
                {
                  v229 = realloc(v124, 4LL * v228);
                  if ( !v229 )
                  {
                    free(v124);
                    v33 = *(_DWORD **)a1;
                    v230 = 0;
                    if ( !*(_QWORD *)a1 )
                      goto LABEL_431;
                    goto LABEL_407;
                  }
                  goto LABEL_379;
                }
                v229 = realloc(v124, 0);
                if ( v229 )
                {
LABEL_379:
                  v124 = v229;
                  *(_QWORD *)a1 = v229;
                  *(_DWORD *)(a1 + 12) = v228;
                  goto LABEL_380;
                }
LABEL_406:
                v33 = *(_DWORD **)a1;
                v230 = 0;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_431;
                goto LABEL_407;
              }
            }
            else
            {
              v189 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 16) = v189 + 1;
              v56[v189] = bswap32(v184);
              v65 = 1;
              v66 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_400;
            }
          }
          else
          {
            v185 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v59 + 8;
            *(_DWORD *)(a1 + 8) = v184 | (v185 << 8);
            v65 = 1;
            v66 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_400;
          }
LABEL_229:
          v191 = *(_DWORD *)(a1 + 12);
          v190 = *(_DWORD *)(a1 + 16);
          if ( v191 <= v190 + 8 )
          {
            v192 = *(_DWORD *)(a1 + 20);
            v193 = v190 + ((unsigned int)(v192 + 39) >> 5);
            v10 = v193 >= v191;
            v194 = v193 - v191;
            if ( v194 == 0 || !v10 )
            {
LABEL_322:
              v265 = 32 - v192;
              v266 = BYTE3(a2) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v192) < 9 )
              {
                if ( v192 )
                {
                  v268 = *(_DWORD *)(a1 + 8);
                  v269 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v265;
                  v270 = (v268 << v265) | (v266 >> (8 - v265));
                  *(_DWORD *)(a1 + 16) = v269 + 1;
                  v66[v269] = HIBYTE(v270) | ((unsigned __int8)v270 << 24) | (v270 >> 8) & 0xFF00 | (BYTE1(v270) << 16);
                  *(_DWORD *)(a1 + 8) = v266;
                }
                else
                {
                  v271 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v271 + 1;
                  v66[v271] = bswap32(v266);
                }
              }
              else
              {
                v267 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v192 + 8;
                *(_DWORD *)(a1 + 8) = BYTE3(a2) & 0x3F | 0x80 | (v267 << 8);
              }
              v198 = 1;
              v199 = *(void **)a1;
              if ( *(_QWORD *)a1 )
                goto LABEL_136;
LABEL_328:
              v33 = *(_DWORD **)a1;
              v230 = 0;
              if ( !*(_QWORD *)a1 )
                goto LABEL_431;
              goto LABEL_407;
            }
            v195 = 1024 - (v194 & 0x3FF);
            if ( (v194 & 0x3FF) == 0 )
              v195 = 0;
            v196 = v195 + v193;
            if ( v195 + v193 )
            {
              v197 = realloc(v66, 4LL * v196);
              if ( !v197 )
              {
                free(v66);
                v198 = 0;
                v199 = *(void **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_328;
                goto LABEL_136;
              }
            }
            else
            {
              v197 = realloc(v66, 0);
              if ( !v197 )
                goto LABEL_400;
            }
            v66 = v197;
            *(_QWORD *)a1 = v197;
            *(_DWORD *)(a1 + 12) = v196;
          }
          v192 = *(_DWORD *)(a1 + 20);
          goto LABEL_322;
        }
        v62 = 1024 - (v61 & 0x3FF);
        if ( (v61 & 0x3FF) == 0 )
          v62 = 0;
        v63 = v62 + v60;
        if ( v62 + v60 )
        {
          v64 = realloc(*(void **)a1, 4LL * v63);
          if ( !v64 )
          {
            free(v56);
            v65 = 0;
            v66 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_400;
            goto LABEL_229;
          }
        }
        else
        {
          v64 = realloc(*(void **)a1, 0);
          if ( !v64 )
          {
            v65 = 0;
            v66 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_400;
            goto LABEL_229;
          }
        }
        v56 = v64;
        *(_QWORD *)a1 = v64;
        *(_DWORD *)(a1 + 12) = v63;
      }
      v59 = *(_DWORD *)(a1 + 20);
      goto LABEL_222;
    }
    if ( !a1 )
      goto LABEL_92;
    v73 = *(_DWORD **)a1;
    if ( !*(_QWORD *)a1 )
      goto LABEL_339;
    v75 = *(_DWORD *)(a1 + 12);
    v74 = *(_DWORD *)(a1 + 16);
    if ( v75 <= v74 + 8 )
    {
      v76 = *(_DWORD *)(a1 + 20);
      v77 = v74 + ((unsigned int)(v76 + 39) >> 5);
      v10 = v77 >= v75;
      v78 = v77 - v75;
      if ( v78 == 0 || !v10 )
      {
LABEL_241:
        v200 = 32 - v76;
        if ( (unsigned int)(32 - v76) < 9 )
        {
          if ( v76 )
          {
            v202 = *(_DWORD *)(a1 + 8);
            v203 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 20) = 8 - v200;
            v204 = (v202 << v200) | (0xFEu >> (8 - v200));
            *(_DWORD *)(a1 + 16) = v203 + 1;
            v73[v203] = HIBYTE(v204) | ((unsigned __int8)v204 << 24) | (v204 >> 8) & 0xFF00 | (BYTE1(v204) << 16);
            *(_DWORD *)(a1 + 8) = 254;
            v82 = 1;
            v83 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
            {
LABEL_403:
              v214 = 0;
              v215 = *(void **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_339;
              goto LABEL_146;
            }
          }
          else
          {
            v205 = *(unsigned int *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v205 + 1;
            v73[v205] = -33554432;
            v82 = 1;
            v83 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_403;
          }
        }
        else
        {
          v201 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v76 + 8;
          *(_DWORD *)(a1 + 8) = (v201 << 8) | 0xFE;
          v82 = 1;
          v83 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_403;
        }
LABEL_248:
        v207 = *(_DWORD *)(a1 + 12);
        v206 = *(_DWORD *)(a1 + 16);
        if ( v207 <= v206 + 8 )
        {
          v208 = *(_DWORD *)(a1 + 20);
          v209 = v206 + ((unsigned int)(v208 + 39) >> 5);
          v10 = v209 >= v207;
          v210 = v209 - v207;
          if ( v210 == 0 || !v10 )
          {
LABEL_333:
            v272 = 32 - v208;
            v273 = (a2 >> 30) & 0x3F | 0x80;
            if ( (unsigned int)(32 - v208) < 9 )
            {
              if ( v208 )
              {
                v275 = *(_DWORD *)(a1 + 8);
                v276 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 20) = 8 - v272;
                v277 = (v275 << v272) | (v273 >> (8 - v272));
                *(_DWORD *)(a1 + 16) = v276 + 1;
                v83[v276] = HIBYTE(v277) | ((unsigned __int8)v277 << 24) | (v277 >> 8) & 0xFF00 | (BYTE1(v277) << 16);
                *(_DWORD *)(a1 + 8) = v273;
              }
              else
              {
                v278 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v278 + 1;
                v83[v278] = bswap32(v273);
              }
            }
            else
            {
              v274 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 20) = v208 + 8;
              *(_DWORD *)(a1 + 8) = (a2 >> 30) & 0x3F | 0x80 | (v274 << 8);
            }
            v214 = 1;
            v215 = *(void **)a1;
            if ( !*(_QWORD *)a1 )
            {
LABEL_339:
              v136 = 0;
              v246 = 0;
              v247 = *(_DWORD **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_428;
              goto LABEL_340;
            }
LABEL_146:
            v126 = *(_DWORD *)(a1 + 12);
            v127 = *(_DWORD *)(a1 + 16);
            v128 = v214 & v82;
            if ( v126 <= v127 + 8 )
            {
              v129 = *(_DWORD *)(a1 + 20);
              v130 = v127 + ((unsigned int)(v129 + 39) >> 5);
              v10 = v130 >= v126;
              v131 = v130 - v126;
              if ( v131 == 0 || !v10 )
                goto LABEL_279;
              v132 = 1024 - (v131 & 0x3FF);
              if ( (v131 & 0x3FF) == 0 )
                v132 = 0;
              v133 = v132 + v130;
              if ( v132 + v130 )
              {
                v134 = realloc(v215, 4LL * v133);
                if ( !v134 )
                {
                  free(v215);
                  v135 = *(_DWORD **)a1;
                  v136 = 0;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_427;
                  goto LABEL_284;
                }
              }
              else
              {
                v134 = realloc(v215, 0);
                if ( !v134 )
                {
                  v135 = *(_DWORD **)a1;
                  v136 = 0;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_427;
                  goto LABEL_284;
                }
              }
              v215 = v134;
              *(_QWORD *)a1 = v134;
              *(_DWORD *)(a1 + 12) = v133;
            }
            v129 = *(_DWORD *)(a1 + 20);
LABEL_279:
            v232 = 32 - v129;
            v233 = BYTE3(a2) & 0x3F | 0x80;
            if ( (unsigned int)(32 - v129) < 9 )
            {
              if ( !v129 )
              {
                v248 = *(unsigned int *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v248 + 1;
                *((_DWORD *)v215 + v248) = bswap32(v233);
                v135 = *(_DWORD **)a1;
                v136 = v128 & 1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_427;
                goto LABEL_284;
              }
              v235 = *(_DWORD *)(a1 + 8);
              v236 = *(unsigned int *)(a1 + 16);
              *(_DWORD *)(a1 + 20) = 8 - v232;
              v237 = (v235 << v232) | (v233 >> (8 - v232));
              *(_DWORD *)(a1 + 16) = v236 + 1;
              *((_DWORD *)v215 + v236) = HIBYTE(v237)
                                       | ((unsigned __int8)v237 << 24)
                                       | (v237 >> 8) & 0xFF00
                                       | (BYTE1(v237) << 16);
            }
            else
            {
              v234 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 20) = v129 + 8;
              v233 = BYTE3(a2) & 0x3F | 0x80 | (v234 << 8);
            }
            *(_DWORD *)(a1 + 8) = v233;
            v135 = *(_DWORD **)a1;
            v136 = v128 & 1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_427;
LABEL_284:
            v239 = *(_DWORD *)(a1 + 12);
            v238 = *(_DWORD *)(a1 + 16);
            if ( v239 > v238 + 8 )
            {
LABEL_390:
              v240 = *(_DWORD *)(a1 + 20);
              goto LABEL_391;
            }
            v240 = *(_DWORD *)(a1 + 20);
            v241 = v238 + ((unsigned int)(v240 + 39) >> 5);
            v10 = v241 >= v239;
            v242 = v241 - v239;
            if ( v242 == 0 || !v10 )
            {
LABEL_391:
              v317 = 32 - v240;
              v318 = ((unsigned int)a2 >> 18) & 0x3F | 0x80;
              if ( (unsigned int)(32 - v240) < 9 )
              {
                if ( v240 )
                {
                  v320 = *(_DWORD *)(a1 + 8);
                  v321 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 20) = 8 - v317;
                  v322 = (v320 << v317) | (v318 >> (8 - v317));
                  *(_DWORD *)(a1 + 16) = v321 + 1;
                  v135[v321] = HIBYTE(v322) | ((unsigned __int8)v322 << 24) | (v322 >> 8) & 0xFF00 | (BYTE1(v322) << 16);
                  *(_DWORD *)(a1 + 8) = v318;
                  v246 = 1;
                  v247 = *(_DWORD **)a1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_428;
                }
                else
                {
                  v323 = *(unsigned int *)(a1 + 16);
                  *(_DWORD *)(a1 + 16) = v323 + 1;
                  v135[v323] = bswap32(v318);
                  v246 = 1;
                  v247 = *(_DWORD **)a1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_428;
                }
              }
              else
              {
                v319 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v240 + 8;
                *(_DWORD *)(a1 + 8) = ((unsigned int)a2 >> 18) & 0x3F | 0x80 | (v319 << 8);
                v246 = 1;
                v247 = *(_DWORD **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_428;
              }
LABEL_340:
              v280 = *(_DWORD *)(a1 + 12);
              v279 = *(_DWORD *)(a1 + 16);
              v281 = v136 & v246;
              if ( v280 <= v279 + 8 )
              {
                v282 = *(_DWORD *)(a1 + 20);
                v283 = v279 + ((unsigned int)(v282 + 39) >> 5);
                v10 = v283 >= v280;
                v284 = v283 - v280;
                if ( v284 == 0 || !v10 )
                {
LABEL_352:
                  v288 = 32 - v282;
                  v289 = ((unsigned int)a2 >> 12) & 0x3F | 0x80;
                  if ( (unsigned int)(32 - v282) < 9 )
                  {
                    if ( !v282 )
                    {
                      v309 = *(unsigned int *)(a1 + 16);
                      *(_DWORD *)(a1 + 16) = v309 + 1;
                      v247[v309] = bswap32(v289);
                      v33 = *(_DWORD **)a1;
                      v32 = v281 & 1;
                      if ( *(_QWORD *)a1 )
                        goto LABEL_357;
                      goto LABEL_431;
                    }
                    v291 = *(_DWORD *)(a1 + 8);
                    v292 = *(unsigned int *)(a1 + 16);
                    *(_DWORD *)(a1 + 20) = 8 - v288;
                    v293 = (v291 << v288) | (v289 >> (8 - v288));
                    *(_DWORD *)(a1 + 16) = v292 + 1;
                    v247[v292] = HIBYTE(v293)
                               | ((unsigned __int8)v293 << 24)
                               | (v293 >> 8) & 0xFF00
                               | (BYTE1(v293) << 16);
                  }
                  else
                  {
                    v290 = *(_DWORD *)(a1 + 8);
                    *(_DWORD *)(a1 + 20) = v282 + 8;
                    v289 = ((unsigned int)a2 >> 12) & 0x3F | 0x80 | (v290 << 8);
                  }
                  *(_DWORD *)(a1 + 8) = v289;
                  v33 = *(_DWORD **)a1;
                  v32 = v281 & 1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_431;
                  goto LABEL_357;
                }
                v285 = 1024 - (v284 & 0x3FF);
                if ( (v284 & 0x3FF) == 0 )
                  v285 = 0;
                v286 = v285 + v283;
                if ( v285 + v283 )
                {
                  v287 = realloc(v247, 4LL * v286);
                  if ( !v287 )
                  {
                    free(v247);
                    v33 = *(_DWORD **)a1;
                    v32 = 0;
                    if ( *(_QWORD *)a1 )
                      goto LABEL_357;
                    goto LABEL_431;
                  }
                }
                else
                {
                  v287 = realloc(v247, 0);
                  if ( !v287 )
                  {
                    v33 = *(_DWORD **)a1;
                    v32 = 0;
                    if ( !*(_QWORD *)a1 )
                      goto LABEL_431;
                    goto LABEL_357;
                  }
                }
                v247 = v287;
                *(_QWORD *)a1 = v287;
                *(_DWORD *)(a1 + 12) = v286;
              }
              v282 = *(_DWORD *)(a1 + 20);
              goto LABEL_352;
            }
            v243 = 1024 - (v242 & 0x3FF);
            if ( (v242 & 0x3FF) == 0 )
              v243 = 0;
            v244 = v243 + v241;
            if ( v243 + v241 )
            {
              v245 = realloc(v135, 4LL * v244);
              if ( !v245 )
              {
                free(v135);
                v246 = 0;
                v247 = *(_DWORD **)a1;
                if ( !*(_QWORD *)a1 )
                  goto LABEL_428;
                goto LABEL_340;
              }
              goto LABEL_389;
            }
            v245 = realloc(v135, 0);
            if ( v245 )
            {
LABEL_389:
              v135 = v245;
              *(_QWORD *)a1 = v245;
              *(_DWORD *)(a1 + 12) = v244;
              goto LABEL_390;
            }
LABEL_427:
            v246 = 0;
            v247 = *(_DWORD **)a1;
            if ( !*(_QWORD *)a1 )
              goto LABEL_428;
            goto LABEL_340;
          }
          v211 = 1024 - (v210 & 0x3FF);
          if ( (v210 & 0x3FF) == 0 )
            v211 = 0;
          v212 = v211 + v209;
          if ( v211 + v209 )
          {
            v213 = realloc(v83, 4LL * v212);
            if ( !v213 )
            {
              free(v83);
              v214 = 0;
              v215 = *(void **)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_339;
              goto LABEL_146;
            }
          }
          else
          {
            v213 = realloc(v83, 0);
            if ( !v213 )
              goto LABEL_403;
          }
          v83 = v213;
          *(_QWORD *)a1 = v213;
          *(_DWORD *)(a1 + 12) = v212;
        }
        v208 = *(_DWORD *)(a1 + 20);
        goto LABEL_333;
      }
      v79 = 1024 - (v78 & 0x3FF);
      if ( (v78 & 0x3FF) == 0 )
        v79 = 0;
      v80 = v79 + v77;
      if ( v79 + v77 )
      {
        v81 = realloc(*(void **)a1, 4LL * v80);
        if ( !v81 )
        {
          free(v73);
          v82 = 0;
          v83 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_403;
          goto LABEL_248;
        }
      }
      else
      {
        v81 = realloc(*(void **)a1, 0);
        if ( !v81 )
        {
          v82 = 0;
          v83 = *(_DWORD **)a1;
          if ( !*(_QWORD *)a1 )
            goto LABEL_403;
          goto LABEL_248;
        }
      }
      v73 = v81;
      *(_QWORD *)a1 = v81;
      *(_DWORD *)(a1 + 12) = v80;
    }
    v76 = *(_DWORD *)(a1 + 20);
    goto LABEL_241;
  }
  if ( !a1 )
    return 0;
  v5 = *(void **)a1;
  if ( !*(_QWORD *)a1 )
    return 0;
  v7 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(a1 + 16);
  if ( v7 > v6 + 8 )
  {
LABEL_75:
    v8 = *(_DWORD *)(a1 + 20);
    goto LABEL_76;
  }
  v8 = *(_DWORD *)(a1 + 20);
  v9 = v6 + ((unsigned int)(v8 + 39) >> 5);
  v10 = v9 >= v7;
  v11 = v9 - v7;
  if ( v11 != 0 && v10 )
  {
    v12 = 1024 - (v11 & 0x3FF);
    if ( (v11 & 0x3FF) == 0 )
      v12 = 0;
    v13 = v12 + v9;
    if ( v12 + v9 )
    {
      result = realloc(*(void **)a1, 4LL * v13);
      if ( !result )
      {
        free(v5);
        return 0;
      }
    }
    else
    {
      result = realloc(*(void **)a1, 0);
      if ( !result )
        return result;
    }
    v5 = result;
    *(_QWORD *)a1 = result;
    *(_DWORD *)(a1 + 12) = v13;
    goto LABEL_75;
  }
LABEL_76:
  v67 = 32 - v8;
  if ( (unsigned int)(32 - v8) < 9 )
  {
    if ( v8 )
    {
      v69 = *(_DWORD *)(a1 + 8);
      v70 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = 8 - v67;
      v71 = (v69 << v67) | ((unsigned int)a2 >> (8 - v67));
      *(_DWORD *)(a1 + 16) = v70 + 1;
      *((_DWORD *)v5 + v70) = HIBYTE(v71) | ((unsigned __int8)v71 << 24) | (v71 >> 8) & 0xFF00 | (BYTE1(v71) << 16);
      *(_DWORD *)(a1 + 8) = a2;
      return &dword_0 + 1;
    }
    else
    {
      v72 = *(unsigned int *)(a1 + 16);
      result = &dword_0 + 1;
      *(_DWORD *)(a1 + 16) = v72 + 1;
      *((_DWORD *)v5 + v72) = bswap32(a2);
    }
  }
  else
  {
    v68 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v8 + 8;
    result = &dword_0 + 1;
    *(_DWORD *)(a1 + 8) = a2 | (v68 << 8);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001A314) ----------------------------------------------------
void *__fastcall FLAC__bitwriter_zero_pad_to_byte_boundary(__int64 a1)
{
  if ( (*(_DWORD *)(a1 + 20) & 7) != 0 )
    return FLAC__bitwriter_write_zeroes(a1, 8 - (*(_DWORD *)(a1 + 20) & 7u));
  else
    return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (000000000001A334) ----------------------------------------------------
long double __fastcall FLAC__cpu_info(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)a1 = 0x300000000LL;
  return result;
}

//----- (000000000001A358) ----------------------------------------------------
__int64 __fastcall FLAC__crc8(char *a1, int a2)
{
  unsigned int i; // w8
  char v3; // t1

  for ( i = 0; a2; i = FLAC__crc8_table[(unsigned __int8)(v3 ^ i)] )
  {
    v3 = *a1++;
    --a2;
  }
  return i;
}
// 60118: using guessed type unsigned __int8 FLAC__crc8_table[256];

//----- (000000000001A388) ----------------------------------------------------
__int64 __fastcall FLAC__crc16(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w9
  unsigned __int8 *v4; // x12
  unsigned int v5; // w8
  int v6; // w8
  int v7; // w14
  int v8; // w13
  int v9; // t1

  v2 = 0;
  v3 = a2 - 8;
  if ( a2 >= 8 )
  {
    v4 = a1;
    do
    {
      a2 -= 8;
      v5 = (v4[1] | (*v4 << 8)) ^ (unsigned __int16)v2;
      v6 = FLAC__crc16_table[(unsigned __int8)v5 + 1536]
         ^ FLAC__crc16_table[(v5 >> 8) + 1792]
         ^ FLAC__crc16_table[v4[2] + 1280]
         ^ FLAC__crc16_table[v4[3] + 1024]
         ^ FLAC__crc16_table[v4[4] + 768]
         ^ FLAC__crc16_table[v4[5] + 512];
      v7 = FLAC__crc16_table[v4[6] + 256];
      v8 = FLAC__crc16_table[v4[7]];
      v4 += 8;
      v2 = v6 ^ v7 ^ v8;
    }
    while ( a2 > 7 );
    a1 += (v3 & 0xFFFFFFF8) + 8;
    a2 = v3 & 7;
  }
  for ( ; a2; v2 = FLAC__crc16_table[v9 ^ BYTE1(v2)] ^ ((unsigned __int16)v2 << 8) )
  {
    v9 = *a1++;
    --a2;
  }
  return v2;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (000000000001A47C) ----------------------------------------------------
__int64 __fastcall FLAC__crc16_update_words32(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // w8
  unsigned int *v4; // x11
  unsigned int v5; // w12
  unsigned int v6; // w14

  v3 = a2 - 2;
  if ( a2 >= 2 )
  {
    v4 = a1;
    do
    {
      v5 = *v4;
      v6 = v4[1];
      v4 += 2;
      a2 -= 2;
      a3 = FLAC__crc16_table[(unsigned __int8)(a3 ^ BYTE2(v5)) + 1536]
         ^ FLAC__crc16_table[((unsigned int)((unsigned __int16)a3 ^ HIWORD(v5)) >> 8) + 1792]
         ^ FLAC__crc16_table[BYTE1(v5) + 1280]
         ^ FLAC__crc16_table[(unsigned __int8)v5 + 1024]
         ^ FLAC__crc16_table[HIBYTE(v6) + 768]
         ^ FLAC__crc16_table[BYTE2(v6) + 512]
         ^ FLAC__crc16_table[BYTE1(v6) + 256]
         ^ FLAC__crc16_table[(unsigned __int8)v6];
    }
    while ( a2 > 1 );
    a1 += (v3 & 0xFFFFFFFE) + 2;
    a2 = v3 & 1;
  }
  if ( a2 )
    return FLAC__crc16_table[(unsigned __int8)(a3 ^ HIWORD(*a1)) + 512]
         ^ FLAC__crc16_table[((unsigned int)((unsigned __int16)a3 ^ HIWORD(*a1)) >> 8) + 768]
         ^ FLAC__crc16_table[(unsigned __int8)BYTE1(*a1) + 256]
         ^ (unsigned int)FLAC__crc16_table[(unsigned __int8)*a1];
  return a3;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (000000000001A584) ----------------------------------------------------
__int64 __fastcall FLAC__crc16_update_words64(unsigned __int64 *a1, int a2, unsigned int a3)
{
  unsigned __int64 v3; // t1

  for ( ;
        a2;
        a3 = FLAC__crc16_table[(unsigned __int8)(a3 ^ BYTE6(v3)) + 1536]
           ^ *(unsigned __int16 *)((char *)&FLAC__crc16_table[1792]
                                 + (((unsigned int)((unsigned __int16)a3 ^ HIWORD(v3)) >> 7) & 0x1FE))
           ^ FLAC__crc16_table[BYTE5(v3) + 1280]
           ^ FLAC__crc16_table[BYTE4(v3) + 1024]
           ^ FLAC__crc16_table[BYTE3(v3) + 768]
           ^ FLAC__crc16_table[BYTE2(v3) + 512]
           ^ FLAC__crc16_table[BYTE1(v3) + 256]
           ^ FLAC__crc16_table[(unsigned __int8)v3] )
  {
    v3 = *a1++;
    --a2;
  }
  return a3;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (000000000001A624) ----------------------------------------------------
__int64 __fastcall FLAC__fixed_compute_best_predictor(int8x16_t *a1, unsigned int a2, unsigned int *a3)
{
  __int32 v5; // w8
  unsigned int v6; // w11
  __int32 v7; // w9
  unsigned int v8; // w13
  unsigned int v9; // w14
  unsigned int v10; // w12
  __int64 v11; // x10
  unsigned int v12; // w23
  unsigned int v13; // w24
  unsigned int v14; // w25
  unsigned int v15; // w26
  unsigned int v16; // w9
  int8x16_t v17; // q18
  int8x16_t v18; // q19
  int8x16_t v19; // q21
  int8x16_t v20; // q20
  int8x16_t *v21; // x9
  int32x4_t v22; // q0
  int32x4_t v23; // q1
  int32x4_t v24; // q2
  int32x4_t v25; // q3
  int32x4_t v26; // q4
  int32x4_t v27; // q5
  int32x4_t v28; // q6
  int32x4_t v29; // q7
  int32x4_t v30; // q16
  __int64 v31; // x11
  int32x4_t v32; // q17
  int8x16_t v33; // q22
  int32x4_t v34; // q23
  int8x16_t v35; // t1
  int8x16_t v36; // q23
  int8x16_t v37; // q24
  int8x16_t v38; // q22
  int32x4_t v39; // q25
  int *v40; // x15
  __int64 v41; // x8
  int v42; // w10
  int v43; // t1
  int v44; // w16
  unsigned int v45; // w17
  unsigned int v46; // w11
  unsigned int v47; // w16
  unsigned int v48; // w11
  int v49; // w14
  int v50; // w11
  int v51; // w12
  int v52; // w11
  unsigned int v53; // w8
  unsigned int v54; // w21
  unsigned int v55; // w8
  unsigned int v56; // w8
  unsigned int v57; // w9
  unsigned int v58; // w10
  unsigned int v59; // w10
  unsigned int v60; // w8
  signed int v61; // w22
  unsigned int v62; // w0
  unsigned int v63; // w8
  unsigned int v64; // w10
  int v65; // w8
  unsigned int v66; // w8
  unsigned int v67; // w9
  unsigned int v68; // w10
  unsigned int v69; // w10
  unsigned int v70; // w8
  signed int v71; // w22
  unsigned int v72; // w8
  unsigned int v73; // w8
  unsigned int v74; // w9
  unsigned int v75; // w10
  unsigned int v76; // w10
  unsigned int v77; // w8
  signed int v78; // w22
  unsigned int v79; // w0
  unsigned int v80; // w8
  unsigned int v81; // w9
  unsigned int v82; // w10
  unsigned int v83; // w10
  unsigned int v84; // w8
  signed int v85; // w22
  unsigned int v86; // w8
  unsigned int v87; // w8
  unsigned int v88; // w9
  unsigned int v89; // w10
  unsigned int v90; // w10
  unsigned int v91; // w8
  signed int v92; // w20

  if ( a2 )
  {
    v5 = a1[-1].n128_i32[2];
    v6 = a1[-1].n128_u32[3];
    v7 = a1[-1].n128_i32[1];
    v8 = v6 - v5;
    v9 = v7 - v5 + v6 - v5;
    v10 = 2 * v7 - v5 - a1[-1].n128_u32[0] + v9;
    if ( a2 >= 8 )
    {
      v11 = a2 & 0xFFFFFFF8;
      v17 = vdupq_n_s32(v6);
      v18 = vdupq_n_s32(v8);
      v19 = vdupq_n_s32(v10);
      v20 = vdupq_n_s32(v9);
      v21 = a1 + 1;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = v11;
      v32 = 0u;
      do
      {
        v33 = v21[-1];
        v31 -= 8;
        v34 = vextq_s8(v17, v33, 0xCu);
        v35 = *v21;
        v21 += 2;
        v17 = v35;
        v36 = vsubq_s32(v33, v34);
        v30 = vaddq_s32(vabsq_s32(v33), v30);
        v28 = vaddq_s32(vabsq_s32(v36), v28);
        v37 = vsubq_s32(v36, vextq_s8(v18, v36, 0xCu));
        v18 = vsubq_s32(v35, vextq_s8(v33, v35, 0xCu));
        v32 = vaddq_s32(vabsq_s32(v35), v32);
        v38 = vsubq_s32(v37, vextq_s8(v20, v37, 0xCu));
        v20 = vsubq_s32(v18, vextq_s8(v36, v18, 0xCu));
        v26 = vaddq_s32(vabsq_s32(v37), v26);
        v29 = vaddq_s32(vabsq_s32(v18), v29);
        v24 = vaddq_s32(vabsq_s32(v38), v24);
        v39 = vabsq_s32(vsubq_s32(v38, vextq_s8(v19, v38, 0xCu)));
        v19 = vsubq_s32(v20, vextq_s8(v37, v20, 0xCu));
        v27 = vaddq_s32(vabsq_s32(v20), v27);
        v22 = vaddq_s32(v39, v22);
        v25 = vaddq_s32(vabsq_s32(v19), v25);
        v23 = vaddq_s32(vabsq_s32(vsubq_s32(v19, vextq_s8(v38, v19, 0xCu))), v23);
      }
      while ( v31 );
      v16 = vaddvq_s32(vaddq_s32(v32, v30));
      v15 = vaddvq_s32(vaddq_s32(v29, v28));
      v14 = vaddvq_s32(vaddq_s32(v27, v26));
      v13 = vaddvq_s32(vaddq_s32(v25, v24));
      v12 = vaddvq_s32(vaddq_s32(v23, v22));
      if ( v11 == a2 )
        goto LABEL_26;
      v6 = v17.n128_u32[3];
      v8 = v18.n128_u32[3];
      v10 = v19.n128_u32[3];
      v9 = v20.n128_u32[3];
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
    }
    v40 = (int *)a1 + v11;
    v41 = a2 - v11;
    do
    {
      v43 = *v40++;
      v42 = v43;
      if ( v43 >= 0 )
        v44 = v42;
      else
        v44 = -v42;
      v45 = v42 - v6;
      v16 += v44;
      if ( (int)(v42 - v6) >= 0 )
        v46 = v42 - v6;
      else
        v46 = v6 - v42;
      v47 = v45 - v8;
      v15 += v46;
      if ( (int)(v45 - v8) >= 0 )
        v48 = v45 - v8;
      else
        v48 = v8 - v45;
      v49 = v47 - v9;
      v14 += v48;
      if ( v49 >= 0 )
        v50 = v49;
      else
        v50 = -v49;
      v51 = v49 - v10;
      v13 += v50;
      if ( v51 >= 0 )
        v52 = v51;
      else
        v52 = -v51;
      --v41;
      v12 += v52;
      v6 = v42;
      v8 = v45;
      v10 = v49;
      v9 = v47;
    }
    while ( v41 );
  }
  else
  {
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
  }
LABEL_26:
  if ( v15 >= v14 )
    v53 = v14;
  else
    v53 = v15;
  if ( v53 >= v13 )
    v53 = v13;
  if ( v53 >= v12 )
    v53 = v12;
  if ( v16 >= v53 )
  {
    if ( v14 >= v13 )
      v63 = v13;
    else
      v63 = v14;
    if ( v63 >= v12 )
      v63 = v12;
    if ( v15 >= v63 )
    {
      if ( v13 >= v12 )
        v64 = v12;
      else
        v64 = v13;
      if ( v13 < v12 )
        v65 = 3;
      else
        v65 = 4;
      if ( v14 >= v64 )
        v54 = v65;
      else
        v54 = 2;
      v55 = 0;
      if ( !v16 )
        goto LABEL_63;
    }
    else
    {
      v54 = 1;
      v55 = 0;
      if ( !v16 )
        goto LABEL_63;
    }
  }
  else
  {
    v54 = 0;
    v55 = 0;
    if ( !v16 )
      goto LABEL_63;
  }
  if ( v16 <= a2 )
    goto LABEL_63;
  v56 = 31 - (__clz(v16) ^ 0x1F);
  v57 = (v16 << v56) / a2;
  v58 = __clz(v57) ^ 0x1F;
  if ( v58 >= 0x10 )
  {
    v59 = v58 - 15;
    v57 >>= v59;
    v56 -= v59;
  }
  v60 = v56 + 16;
  v61 = v60 - (v60 & 3);
  v55 = FLAC__fixedpoint_log2((45426 * v57) >> (v60 & 3), v61, 0xFFFFFFFF);
  if ( !v55 )
  {
LABEL_63:
    v62 = 0;
    *a3 = v55;
    if ( !v15 )
      goto LABEL_73;
    goto LABEL_64;
  }
  if ( v61 > 15 )
  {
    if ( v61 != 16 )
      v55 >>= v61 - 16;
    goto LABEL_63;
  }
  v62 = 0;
  *a3 = v55 << (16 - v61);
  if ( !v15 )
    goto LABEL_73;
LABEL_64:
  if ( v15 <= a2 )
    goto LABEL_73;
  v66 = 31 - (__clz(v15) ^ 0x1F);
  v67 = (v15 << v66) / a2;
  v68 = __clz(v67) ^ 0x1F;
  if ( v68 >= 0x10 )
  {
    v69 = v68 - 15;
    v67 >>= v69;
    v66 -= v69;
  }
  v70 = v66 + 16;
  v71 = v70 - (v70 & 3);
  v62 = FLAC__fixedpoint_log2((45426 * v67) >> (v70 & 3), v71, 0xFFFFFFFF);
  if ( !v62 )
  {
LABEL_73:
    v72 = 0;
    a3[1] = v62;
    if ( !v14 )
      goto LABEL_83;
    goto LABEL_74;
  }
  if ( v71 > 15 )
  {
    if ( v71 != 16 )
      v62 >>= v71 - 16;
    goto LABEL_73;
  }
  v72 = 0;
  a3[1] = v62 << (16 - v71);
  if ( !v14 )
    goto LABEL_83;
LABEL_74:
  if ( v14 <= a2 )
    goto LABEL_83;
  v73 = 31 - (__clz(v14) ^ 0x1F);
  v74 = (v14 << v73) / a2;
  v75 = __clz(v74) ^ 0x1F;
  if ( v75 >= 0x10 )
  {
    v76 = v75 - 15;
    v74 >>= v76;
    v73 -= v76;
  }
  v77 = v73 + 16;
  v78 = v77 - (v77 & 3);
  v72 = FLAC__fixedpoint_log2((45426 * v74) >> (v77 & 3), v78, 0xFFFFFFFF);
  if ( !v72 )
  {
LABEL_83:
    v79 = 0;
    a3[2] = v72;
    if ( !v13 )
      goto LABEL_93;
    goto LABEL_84;
  }
  if ( v78 > 15 )
  {
    if ( v78 != 16 )
      v72 >>= v78 - 16;
    goto LABEL_83;
  }
  v79 = 0;
  a3[2] = v72 << (16 - v78);
  if ( !v13 )
    goto LABEL_93;
LABEL_84:
  if ( v13 <= a2 )
    goto LABEL_93;
  v80 = 31 - (__clz(v13) ^ 0x1F);
  v81 = (v13 << v80) / a2;
  v82 = __clz(v81) ^ 0x1F;
  if ( v82 >= 0x10 )
  {
    v83 = v82 - 15;
    v81 >>= v83;
    v80 -= v83;
  }
  v84 = v80 + 16;
  v85 = v84 - (v84 & 3);
  v79 = FLAC__fixedpoint_log2((45426 * v81) >> (v84 & 3), v85, 0xFFFFFFFF);
  if ( !v79 )
  {
LABEL_93:
    v86 = 0;
    a3[3] = v79;
    if ( !v12 )
      goto LABEL_102;
    goto LABEL_94;
  }
  if ( v85 > 15 )
  {
    if ( v85 != 16 )
      v79 >>= v85 - 16;
    goto LABEL_93;
  }
  v86 = 0;
  a3[3] = v79 << (16 - v85);
  if ( !v12 )
    goto LABEL_102;
LABEL_94:
  if ( v12 > a2 )
  {
    v87 = 31 - (__clz(v12) ^ 0x1F);
    v88 = (v12 << v87) / a2;
    v89 = __clz(v88) ^ 0x1F;
    if ( v89 >= 0x10 )
    {
      v90 = v89 - 15;
      v88 >>= v90;
      v87 -= v90;
    }
    v91 = v87 + 16;
    v92 = v91 - (v91 & 3);
    v86 = FLAC__fixedpoint_log2((45426 * v88) >> (v91 & 3), v92, 0xFFFFFFFF);
    if ( v86 )
    {
      if ( v92 > 15 )
      {
        if ( v92 != 16 )
          v86 >>= v92 - 16;
      }
      else
      {
        v86 <<= 16 - v92;
      }
    }
  }
LABEL_102:
  a3[4] = v86;
  return v54;
}

//----- (000000000001AC1C) ----------------------------------------------------
__int64 __fastcall FLAC__fixed_compute_best_predictor_wide(__int64 a1, unsigned int a2, unsigned int *a3)
{
  int v5; // w8
  unsigned int v6; // w11
  int v7; // w9
  unsigned int v8; // w13
  unsigned int v9; // w14
  unsigned int v10; // w12
  __int64 v11; // x10
  unsigned __int64 v12; // x23
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x25
  unsigned __int64 v15; // x26
  unsigned __int64 v16; // x8
  int8x8_t v17; // d18
  int8x8_t v18; // d19
  int8x8_t v19; // d21
  int8x8_t v20; // d20
  unsigned __int64 *v21; // x8
  int64x2_t v22; // q0
  int64x2_t v23; // q1
  int64x2_t v24; // q2
  int64x2_t v25; // q3
  int64x2_t v26; // q4
  int64x2_t v27; // q5
  int64x2_t v28; // q6
  int64x2_t v29; // q7
  int64x2_t v30; // q16
  __int64 v31; // x11
  int64x2_t v32; // q17
  int8x8_t v33; // d22
  int32x2_t v34; // d23
  int8x8_t v35; // t1
  int8x8_t v36; // d23
  int8x8_t v37; // d24
  int8x8_t v38; // d22
  uint32x2_t v39; // d25
  int *v40; // x15
  __int64 v41; // x9
  unsigned int v42; // w10
  int v43; // t1
  __int64 v44; // x16
  unsigned int v45; // w17
  __int64 v46; // x11
  unsigned int v47; // w16
  __int64 v48; // x11
  int v49; // w14
  __int64 v50; // x11
  int v51; // w12
  __int64 v52; // x11
  unsigned __int64 v53; // x9
  unsigned int v54; // w21
  int v55; // w9
  unsigned __int64 v56; // x8
  unsigned int v57; // w10
  unsigned int v58; // w10
  int v59; // w9
  signed int v60; // w22
  unsigned int v61; // w0
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x10
  int v64; // w9
  int v65; // w8
  unsigned __int64 v66; // x9
  unsigned int v67; // w10
  unsigned int v68; // w10
  int v69; // w8
  signed int v70; // w22
  unsigned int v71; // w0
  int v72; // w8
  unsigned __int64 v73; // x9
  unsigned int v74; // w10
  unsigned int v75; // w10
  int v76; // w8
  signed int v77; // w22
  unsigned int v78; // w0
  int v79; // w8
  unsigned __int64 v80; // x9
  unsigned int v81; // w10
  unsigned int v82; // w10
  int v83; // w8
  signed int v84; // w22
  unsigned int v85; // w0
  int v86; // w8
  unsigned __int64 v87; // x9
  unsigned int v88; // w10
  unsigned int v89; // w10
  int v90; // w8
  signed int v91; // w20
  unsigned int v92; // w0

  if ( a2 )
  {
    v5 = *(_DWORD *)(a1 - 8);
    v6 = *(_DWORD *)(a1 - 4);
    v7 = *(_DWORD *)(a1 - 12);
    v8 = v6 - v5;
    v9 = v7 - v5 + v6 - v5;
    v10 = 2 * v7 - v5 - *(_DWORD *)(a1 - 16) + v9;
    if ( a2 >= 4 )
    {
      v11 = a2 & 0xFFFFFFFC;
      v17.n64_u64[0] = vdup_n_s32(v6).n64_u64[0];
      v18.n64_u64[0] = vdup_n_s32(v8).n64_u64[0];
      v19.n64_u64[0] = vdup_n_s32(v10).n64_u64[0];
      v20.n64_u64[0] = vdup_n_s32(v9).n64_u64[0];
      v21 = (unsigned __int64 *)(a1 + 8);
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = v11;
      v32 = 0u;
      do
      {
        v33.n64_u64[0] = *(v21 - 1);
        v31 -= 4;
        v34.n64_u64[0] = vext_s8(v17, v33, 4u).n64_u64[0];
        v35.n64_u64[0] = *v21;
        v21 += 2;
        v17.n64_u64[0] = v35.n64_u64[0];
        v36.n64_u64[0] = vsub_s32(v33, v34).n64_u64[0];
        v30 = vaddw_u32(v30, vabs_s32(v33));
        v28 = vaddw_u32(v28, vabs_s32(v36));
        v37.n64_u64[0] = vsub_s32(v36, vext_s8(v18, v36, 4u)).n64_u64[0];
        v18.n64_u64[0] = vsub_s32(v35, vext_s8(v33, v35, 4u)).n64_u64[0];
        v32 = vaddw_u32(v32, vabs_s32(v35));
        v38.n64_u64[0] = vsub_s32(v37, vext_s8(v20, v37, 4u)).n64_u64[0];
        v20.n64_u64[0] = vsub_s32(v18, vext_s8(v36, v18, 4u)).n64_u64[0];
        v26 = vaddw_u32(v26, vabs_s32(v37));
        v29 = vaddw_u32(v29, vabs_s32(v18));
        v24 = vaddw_u32(v24, vabs_s32(v38));
        v39.n64_u64[0] = vabs_s32(vsub_s32(v38, vext_s8(v19, v38, 4u))).n64_u64[0];
        v19.n64_u64[0] = vsub_s32(v20, vext_s8(v37, v20, 4u)).n64_u64[0];
        v27 = vaddw_u32(v27, vabs_s32(v20));
        v22 = vaddw_u32(v22, v39);
        v25 = vaddw_u32(v25, vabs_s32(v19));
        v23 = vaddw_u32(v23, vabs_s32(vsub_s32(v19, vext_s8(v38, v19, 4u))));
      }
      while ( v31 );
      v16 = vaddvq_s64(vaddq_s64(v32, v30));
      v15 = vaddvq_s64(vaddq_s64(v29, v28));
      v14 = vaddvq_s64(vaddq_s64(v27, v26));
      v13 = vaddvq_s64(vaddq_s64(v25, v24));
      v12 = vaddvq_s64(vaddq_s64(v23, v22));
      if ( v11 == a2 )
        goto LABEL_26;
      v6 = v17.n64_u32[1];
      v8 = v18.n64_u32[1];
      v10 = v19.n64_u32[1];
      v9 = v20.n64_u32[1];
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
    }
    v40 = (int *)(a1 + 4 * v11);
    v41 = a2 - v11;
    do
    {
      v43 = *v40++;
      v42 = v43;
      if ( v43 >= 0 )
        v44 = v42;
      else
        v44 = -v42;
      v45 = v42 - v6;
      v16 += v44;
      if ( (int)(v42 - v6) >= 0 )
        v46 = v45;
      else
        v46 = v6 - v42;
      v47 = v45 - v8;
      v15 += v46;
      if ( (int)(v45 - v8) >= 0 )
        v48 = v47;
      else
        v48 = v8 - v45;
      v49 = v47 - v9;
      v14 += v48;
      if ( v49 >= 0 )
        v50 = (unsigned int)v49;
      else
        v50 = (unsigned int)-v49;
      v51 = v49 - v10;
      v13 += v50;
      if ( v51 >= 0 )
        v52 = (unsigned int)v51;
      else
        v52 = (unsigned int)-v51;
      --v41;
      v12 += v52;
      v6 = v42;
      v8 = v45;
      v10 = v49;
      v9 = v47;
    }
    while ( v41 );
  }
  else
  {
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
  }
LABEL_26:
  if ( v15 >= v14 )
    v53 = v14;
  else
    v53 = v15;
  if ( v53 >= v13 )
    v53 = v13;
  if ( v53 >= v12 )
    v53 = v12;
  if ( v16 < v53 )
  {
    v54 = 0;
    if ( v16 )
      goto LABEL_35;
LABEL_63:
    v61 = 0;
LABEL_64:
    *a3 = v61;
    if ( !v15 )
      goto LABEL_51;
    goto LABEL_65;
  }
  if ( v14 >= v13 )
    v62 = v13;
  else
    v62 = v14;
  if ( v62 >= v12 )
    v62 = v12;
  if ( v15 >= v62 )
  {
    if ( v13 >= v12 )
      v63 = v12;
    else
      v63 = v13;
    if ( v13 < v12 )
      v64 = 3;
    else
      v64 = 4;
    if ( v14 >= v63 )
      v54 = v64;
    else
      v54 = 2;
    if ( !v16 )
      goto LABEL_63;
  }
  else
  {
    v54 = 1;
    if ( !v16 )
      goto LABEL_63;
  }
LABEL_35:
  if ( v16 > a2 )
  {
    v55 = 63 - (__clz(v16) ^ 0x3F);
    v56 = (v16 << v55) / a2;
    v57 = __clz(v56) ^ 0x3F;
    if ( v57 >= 0x10 )
    {
      v58 = v57 - 15;
      v56 >>= v58;
      v55 -= v58;
    }
    v59 = v55 + 16;
    v60 = v59 - (v59 & 3);
    v61 = FLAC__fixedpoint_log2((unsigned int)(45426 * v56) >> (v59 & 3), v60, 0xFFFFFFFF);
    if ( v61 )
    {
      if ( v60 <= 15 )
      {
        *a3 = v61 << (16 - v60);
        if ( !v15 )
          goto LABEL_51;
        goto LABEL_65;
      }
      if ( v60 != 16 )
      {
        *a3 = v61 >> (v60 - 16);
        if ( !v15 )
        {
LABEL_51:
          a3[1] = 0;
          if ( !v14 )
            goto LABEL_73;
LABEL_80:
          if ( v14 <= a2 )
          {
            a3[2] = 0;
            if ( !v13 )
              goto LABEL_88;
            goto LABEL_92;
          }
          v72 = 63 - (__clz(v14) ^ 0x3F);
          v73 = (v14 << v72) / a2;
          v74 = __clz(v73) ^ 0x3F;
          if ( v74 >= 0x10 )
          {
            v75 = v74 - 15;
            v73 >>= v75;
            v72 -= v75;
          }
          v76 = v72 + 16;
          v77 = v76 - (v76 & 3);
          v78 = FLAC__fixedpoint_log2((unsigned int)(45426 * v73) >> (v76 & 3), v77, 0xFFFFFFFF);
          if ( v78 )
          {
            if ( v77 <= 15 )
            {
              a3[2] = v78 << (16 - v77);
              if ( v13 )
                goto LABEL_92;
              goto LABEL_88;
            }
            if ( v77 != 16 )
            {
              a3[2] = v78 >> (v77 - 16);
              if ( v13 )
                goto LABEL_92;
LABEL_88:
              a3[3] = 0;
              if ( !v12 )
                goto LABEL_108;
              goto LABEL_98;
            }
          }
          a3[2] = v78;
          if ( !v13 )
            goto LABEL_88;
          goto LABEL_92;
        }
        goto LABEL_65;
      }
    }
    goto LABEL_64;
  }
  *a3 = 0;
  if ( !v15 )
    goto LABEL_51;
LABEL_65:
  if ( v15 <= a2 )
  {
    a3[1] = 0;
    if ( !v14 )
      goto LABEL_73;
    goto LABEL_80;
  }
  v65 = 63 - (__clz(v15) ^ 0x3F);
  v66 = (v15 << v65) / a2;
  v67 = __clz(v66) ^ 0x3F;
  if ( v67 >= 0x10 )
  {
    v68 = v67 - 15;
    v66 >>= v68;
    v65 -= v68;
  }
  v69 = v65 + 16;
  v70 = v69 - (v69 & 3);
  v71 = FLAC__fixedpoint_log2((unsigned int)(45426 * v66) >> (v69 & 3), v70, 0xFFFFFFFF);
  if ( !v71 )
    goto LABEL_79;
  if ( v70 <= 15 )
  {
    a3[1] = v71 << (16 - v70);
    if ( v14 )
      goto LABEL_80;
    goto LABEL_73;
  }
  if ( v70 == 16 )
  {
LABEL_79:
    a3[1] = v71;
    if ( !v14 )
      goto LABEL_73;
    goto LABEL_80;
  }
  a3[1] = v71 >> (v70 - 16);
  if ( v14 )
    goto LABEL_80;
LABEL_73:
  a3[2] = 0;
  if ( !v13 )
    goto LABEL_88;
LABEL_92:
  if ( v13 <= a2 )
  {
    a3[3] = 0;
    if ( !v12 )
      goto LABEL_108;
    goto LABEL_98;
  }
  v79 = 63 - (__clz(v13) ^ 0x3F);
  v80 = (v13 << v79) / a2;
  v81 = __clz(v80) ^ 0x3F;
  if ( v81 >= 0x10 )
  {
    v82 = v81 - 15;
    v80 >>= v82;
    v79 -= v82;
  }
  v83 = v79 + 16;
  v84 = v83 - (v83 & 3);
  v85 = FLAC__fixedpoint_log2((unsigned int)(45426 * v80) >> (v83 & 3), v84, 0xFFFFFFFF);
  if ( !v85 )
    goto LABEL_107;
  if ( v84 > 15 )
  {
    if ( v84 != 16 )
    {
      a3[3] = v85 >> (v84 - 16);
      if ( !v12 )
        goto LABEL_108;
      goto LABEL_98;
    }
LABEL_107:
    a3[3] = v85;
    if ( !v12 )
      goto LABEL_108;
    goto LABEL_98;
  }
  a3[3] = v85 << (16 - v84);
  if ( !v12 )
  {
LABEL_108:
    v92 = 0;
    goto LABEL_109;
  }
LABEL_98:
  if ( v12 <= a2 )
    goto LABEL_108;
  v86 = 63 - (__clz(v12) ^ 0x3F);
  v87 = (v12 << v86) / a2;
  v88 = __clz(v87) ^ 0x3F;
  if ( v88 >= 0x10 )
  {
    v89 = v88 - 15;
    v87 >>= v89;
    v86 -= v89;
  }
  v90 = v86 + 16;
  v91 = v90 - (v90 & 3);
  v92 = FLAC__fixedpoint_log2((unsigned int)(45426 * v87) >> (v90 & 3), v91, 0xFFFFFFFF);
  if ( v92 )
  {
    if ( v91 > 15 )
    {
      if ( v91 != 16 )
        v92 >>= v91 - 16;
    }
    else
    {
      v92 <<= 16 - v91;
    }
  }
LABEL_109:
  a3[4] = v92;
  return v54;
}

//----- (000000000001B288) ----------------------------------------------------
char *__fastcall FLAC__fixed_compute_residual(char *result, unsigned int a2, int a3, int32x4_t *a4)
{
  __int64 v4; // x10
  char *v5; // x8
  _DWORD *v6; // x11
  __int64 v7; // x9
  int v8; // w10
  int v9; // w12
  __int64 v10; // x10
  __int64 v11; // x11
  __int64 v12; // x9
  _DWORD *v13; // x10
  char *v14; // x8
  int v15; // w11
  int v16; // w12
  int v17; // w13
  __int64 v18; // x10
  __int64 v19; // x9
  __int64 v20; // x10
  char *v21; // x11
  int32x4_t *v22; // x8
  char *v23; // x10
  int v24; // t1
  __int64 v25; // x10
  char *v26; // x12
  __int64 v27; // x9
  _DWORD *v28; // x10
  char *v29; // x11
  int v30; // t1
  int32x4_t *v31; // x11
  _OWORD *v32; // x12
  __int64 v33; // x13
  int32x4_t v34; // q0
  int32x4_t v35; // q1
  int32x4_t v36; // q2
  int32x4_t v37; // q3
  int32x4_t *v38; // x11
  char *v39; // x12
  __int64 v40; // x13
  int32x4_t v41; // q1
  int32x4_t *v42; // x11
  char *v43; // x12
  int32x4_t v44; // q0
  __int64 v45; // x13
  int32x4_t v46; // q2
  char *v47; // x11
  int32x4_t v48; // q0
  __int64 v49; // x12
  int32x4_t *v50; // x13

  switch ( a3 )
  {
    case 0:
      return (char *)memcpy(a4, result, 4LL * a2);
    case 1:
      if ( (int)a2 < 1 )
        return result;
      if ( a2 < 8 || &result[4 * a2] > (char *)a4 && result - 4 < (char *)a4 + 4 * a2 )
      {
        v4 = 0;
LABEL_8:
        v5 = &result[4 * v4];
        v6 = (_DWORD *)a4 + v4;
        v7 = a2 - v4;
        do
        {
          v9 = *((_DWORD *)v5 - 1);
          v8 = *(_DWORD *)v5;
          --v7;
          v5 += 4;
          *v6++ = v8 - v9;
        }
        while ( v7 );
        return result;
      }
      v4 = a2 & 0xFFFFFFF8;
      v31 = a4 + 1;
      v32 = result;
      v33 = v4;
      do
      {
        v34 = *(int32x4_t *)v32;
        v35 = *((int32x4_t *)v32 + 1);
        v36 = *(int32x4_t *)((char *)v32 - 4);
        v37 = *(int32x4_t *)((char *)v32 + 12);
        v33 -= 8;
        v32 += 2;
        v31[-1] = vsubq_s32(v34, v36);
        *v31 = vsubq_s32(v35, v37);
        v31 += 2;
      }
      while ( v33 );
      if ( v4 != a2 )
        goto LABEL_8;
      return result;
    case 2:
      if ( (int)a2 < 1 )
        return result;
      if ( a2 < 8 || &result[4 * a2] > (char *)a4 && result - 8 < (char *)a4 + 4 * a2 )
      {
        v10 = 0;
LABEL_16:
        v11 = 4 * v10;
        v12 = a2 - v10;
        v13 = (_DWORD *)a4 + v10;
        v14 = &result[v11];
        do
        {
          v16 = *((_DWORD *)v14 - 1);
          v15 = *(_DWORD *)v14;
          v17 = *((_DWORD *)v14 - 2);
          --v12;
          v14 += 4;
          *v13++ = v15 - 2 * v16 + v17;
        }
        while ( v12 );
        return result;
      }
      v10 = a2 & 0xFFFFFFF8;
      v38 = a4 + 1;
      v39 = result;
      v40 = v10;
      do
      {
        v41 = vaddq_s32(
                vsubq_s32(*((int32x4_t *)v39 + 1), vshlq_n_s32(*(int32x4_t *)(v39 + 12), 1u)),
                *(int32x4_t *)(v39 + 8));
        v40 -= 8;
        v38[-1] = vaddq_s32(
                    vsubq_s32(*(int32x4_t *)v39, vshlq_n_s32(*(int32x4_t *)(v39 - 4), 1u)),
                    *(int32x4_t *)(v39 - 8));
        *v38 = v41;
        v38 += 2;
        v39 += 32;
      }
      while ( v40 );
      if ( v10 != a2 )
        goto LABEL_16;
      return result;
    case 3:
      if ( (int)a2 < 1 )
        return result;
      if ( a2 < 8 || &result[4 * a2] > (char *)a4 && result - 12 < (char *)a4 + 4 * a2 )
      {
        v18 = 0;
LABEL_24:
        v19 = a2 - v18;
        v20 = 4 * v18;
        v21 = &result[v20 - 4];
        v22 = (int32x4_t *)((char *)a4 + v20);
        v23 = v21;
        do
        {
          v24 = *((_DWORD *)v23 + 1);
          v23 += 4;
          --v19;
          v22->n128_u32[0] = v24 - *((_DWORD *)v21 - 2) + 3 * (*((_DWORD *)v21 - 1) - *(_DWORD *)v21);
          v22 = (int32x4_t *)((char *)v22 + 4);
          v21 = v23;
        }
        while ( v19 );
        return result;
      }
      v18 = a2 & 0xFFFFFFF8;
      v42 = a4 + 1;
      v43 = result + 4;
      v44.n128_u64[0] = 0x300000003LL;
      v44.n128_u64[1] = 0x300000003LL;
      v45 = v18;
      do
      {
        v45 -= 8;
        v46 = vmlaq_s32(
                vsubq_s32(*(int32x4_t *)(v43 + 12), *(int32x4_t *)v43),
                vsubq_s32(*(int32x4_t *)(v43 + 4), *(int32x4_t *)(v43 + 8)),
                v44);
        v42[-1] = vmlaq_s32(
                    vsubq_s32(*(int32x4_t *)(v43 - 4), *((int32x4_t *)v43 - 1)),
                    vsubq_s32(*(int32x4_t *)(v43 - 12), *(int32x4_t *)(v43 - 8)),
                    v44);
        *v42 = v46;
        v42 += 2;
        v43 += 32;
      }
      while ( v45 );
      if ( v18 != a2 )
        goto LABEL_24;
      return result;
    case 4:
      if ( (int)a2 < 1 )
        return result;
      if ( a2 < 4 || &result[4 * a2] > (char *)a4 && result - 16 < (char *)a4 + 4 * a2 )
      {
        v25 = 0;
LABEL_32:
        v26 = &result[4 * v25 - 8];
        v27 = a2 - v25;
        v28 = (_DWORD *)a4 + v25;
        v29 = v26;
        do
        {
          v30 = *((_DWORD *)v29 + 1);
          v29 += 4;
          --v27;
          *v28++ = *((_DWORD *)v26 + 2) - 4 * v30 + 6 * *(_DWORD *)v26 - 4 * *((_DWORD *)v26 - 1) + *((_DWORD *)v26 - 2);
          v26 = v29;
        }
        while ( v27 );
        return result;
      }
      v25 = a2 & 0xFFFFFFFC;
      v47 = result - 8;
      v48.n128_u64[0] = 0x600000006LL;
      v48.n128_u64[1] = 0x600000006LL;
      v49 = v25;
      v50 = a4;
      do
      {
        v49 -= 4;
        *v50++ = vaddq_s32(
                   vsubq_s32(
                     vmlaq_s32(
                       vsubq_s32(*(int32x4_t *)(v47 + 8), vshlq_n_s32(*(int32x4_t *)(v47 + 4), 2u)),
                       *(int32x4_t *)v47,
                       v48),
                     vshlq_n_s32(*(int32x4_t *)(v47 - 4), 2u)),
                   *(int32x4_t *)(v47 - 8));
        v47 += 16;
      }
      while ( v49 );
      if ( v25 != a2 )
        goto LABEL_32;
      return result;
    default:
      return result;
  }
}

//----- (000000000001B5FC) ----------------------------------------------------
int *__fastcall FLAC__fixed_restore_signal(int *result, int a2, int a3, int *a4)
{
  int *v4; // x8
  int v5; // w9
  __int64 v6; // x10
  int v7; // t1
  int v8; // w9
  __int64 v9; // x10
  int v10; // t1
  int v11; // w9
  int v12; // w11
  __int64 v13; // x10
  int v14; // t1
  int v15; // w13
  int v16; // w11
  int v17; // w12
  __int64 v18; // x9
  int v19; // t1
  int v20; // w14

  v4 = result;
  switch ( a3 )
  {
    case 0:
      result = (int *)memcpy(a4, result, 4LL * (unsigned int)a2);
      break;
    case 1:
      if ( a2 >= 1 )
      {
        v5 = *(a4 - 1);
        v6 = (unsigned int)a2;
        do
        {
          v7 = *v4++;
          --v6;
          v5 += v7;
          *a4++ = v5;
        }
        while ( v6 );
      }
      break;
    case 2:
      if ( a2 >= 1 )
      {
        v8 = *(a4 - 1);
        v9 = (unsigned int)a2;
        do
        {
          v10 = *v4++;
          --v9;
          v8 = v10 + 2 * v8 - *(a4 - 2);
          *a4++ = v8;
        }
        while ( v9 );
      }
      break;
    case 3:
      if ( a2 >= 1 )
      {
        v11 = *(a4 - 1);
        v12 = *(a4 - 3);
        v13 = (unsigned int)a2;
        do
        {
          v14 = *v4++;
          v15 = *(a4 - 2);
          --v13;
          v11 = v12 + v14 + 3 * (v11 - v15);
          *a4++ = v11;
          v12 = v15;
        }
        while ( v13 );
      }
      break;
    case 4:
      if ( a2 >= 1 )
      {
        v16 = *(a4 - 1);
        v17 = *(a4 - 3);
        v18 = (unsigned int)a2;
        do
        {
          v19 = *v4++;
          v20 = *(a4 - 2);
          --v18;
          v16 = v19 - 6 * v20 - *(a4 - 4) + 4 * (v17 + v16);
          *a4++ = v16;
          v17 = v20;
        }
        while ( v18 );
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (000000000001B714) ----------------------------------------------------
__int64 __fastcall FLAC__fixedpoint_log2(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // w8
  unsigned int v4; // w9
  __int64 result; // x0
  unsigned int v6; // w10
  unsigned int v7; // w12
  unsigned int v8; // w11
  unsigned int v9; // w14

  v3 = a1;
  v4 = 1 << a2;
  if ( 1 << a2 > a1 )
    return 0;
  if ( a3 >= 0x10 )
    v6 = 16;
  else
    v6 = a3;
  result = 0;
  if ( v4 < v3 && v6 >= 2 )
  {
    result = 0;
    v7 = v3 >> 1;
    v8 = 1;
    do
    {
      v9 = v3 - v7;
      if ( v3 - v7 >= v4 )
      {
        v7 = v9 >> v8;
        result = (unsigned int)(dword_61254[16 * (unsigned __int64)(a2 >> 2) + v8] + result);
        v3 = v9;
        if ( v9 <= v4 )
          return result;
      }
      else
      {
        v7 >>= 1;
        ++v8;
        if ( v3 <= v4 )
          return result;
      }
    }
    while ( v8 < v6 );
  }
  return result;
}
// 61254: using guessed type _DWORD dword_61254[131];

//----- (000000000001B7B0) ----------------------------------------------------
bool __fastcall FLAC__format_sample_rate_is_valid(int a1)
{
  return (unsigned int)(a1 - 1) < 0x9FFF6;
}

//----- (000000000001B7C8) ----------------------------------------------------
__int64 __fastcall FLAC__format_blocksize_is_subset(unsigned int a1, unsigned int a2)
{
  if ( a1 <= 0x4000 )
    return (a1 < 0x1201) | (unsigned int)(a2 > 0xBB80);
  else
    return 0;
}

//----- (000000000001B7F8) ----------------------------------------------------
__int64 __fastcall FLAC__format_sample_rate_is_subset(unsigned int a1)
{
  if ( a1 - 1 <= 0x9FFF5 )
    return (a1 % 0xA == 0) | (a1 < 0x10000) | (unsigned int)(a1 % 0x3E8 == 0);
  else
    return 0;
}

//----- (000000000001B868) ----------------------------------------------------
__int64 __fastcall FLAC__format_seektable_is_legal(unsigned int *a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 *v2; // x10
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x12
  char v5; // w11
  unsigned __int64 v6; // x13

  v1 = *a1;
  if ( !(_DWORD)v1 )
    return 1;
  v2 = (unsigned __int64 *)*((_QWORD *)a1 + 1);
  v3 = 0;
  v4 = 0;
  v5 = 1;
  while ( 1 )
  {
    v6 = *v2;
    if ( (v5 & 1) == 0 && v6 != -1 && v6 <= v4 )
      break;
    ++v3;
    v5 = 0;
    v2 += 3;
    v4 = v6;
    if ( v3 >= v1 )
      return 1;
  }
  return 0;
}

//----- (000000000001B8C0) ----------------------------------------------------
__int64 __fastcall FLAC__format_seektable_sort(void **a1)
{
  size_t v2; // x1
  unsigned int v3; // w8
  unsigned __int64 v4; // x9
  __int64 v5; // x11
  __int64 result; // x0
  _QWORD *v7; // x12
  __int64 v8; // x13
  _OWORD *v9; // x8
  __int64 v10; // x13
  _QWORD *v11; // x12
  char *v12; // x9
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x10
  __int64 v15; // x13
  unsigned __int64 v16; // x14
  char *v17; // x9
  unsigned __int64 v18; // x8

  v2 = *(unsigned int *)a1;
  if ( !(_DWORD)v2 )
    return 0;
  qsort(a1[1], v2, 0x18u, (int (*)(const void *, const void *))sub_1BA38);
  if ( !*(_DWORD *)a1 )
    return 0;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 < 2u )
  {
    result = 1;
    if ( v3 <= 1 )
      return result;
LABEL_14:
    v12 = (char *)a1[1];
    v13 = v3 - (unsigned __int64)(unsigned int)result;
    if ( v13 >= 2 )
    {
      v14 = (v13 & 0xFFFFFFFFFFFFFFFELL) + (unsigned int)result;
      v15 = (__int64)&v12[24 * (unsigned int)result + 24];
      v16 = v13 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        *(_OWORD *)(v15 - 24) = xmmword_61460;
        *(_OWORD *)v15 = xmmword_61460;
        *(_DWORD *)(v15 - 8) = 0;
        *(_DWORD *)(v15 + 16) = 0;
        v16 -= 2LL;
        v15 += 48;
      }
      while ( v16 );
      if ( v13 == (v13 & 0xFFFFFFFFFFFFFFFELL) )
        return result;
    }
    else
    {
      v14 = (unsigned int)result;
    }
    v17 = &v12[24 * v14 + 16];
    v18 = v3 - v14;
    do
    {
      *((_OWORD *)v17 - 1) = xmmword_61460;
      *(_DWORD *)v17 = 0;
      v17 += 24;
      --v18;
    }
    while ( v18 );
    return result;
  }
  v4 = 1;
  v5 = 3;
  result = 1;
  do
  {
    v7 = a1[1];
    v8 = v7[v5];
    if ( v8 == -1 || v8 != v7[3 * (unsigned int)(result - 1)] )
    {
      v9 = &v7[v5];
      v10 = v7[v5 + 2];
      v11 = &v7[3 * (unsigned int)result];
      result = (unsigned int)(result + 1);
      v11[2] = v10;
      *(_OWORD *)v11 = *v9;
      v3 = *(_DWORD *)a1;
    }
    ++v4;
    v5 += 3;
  }
  while ( v4 < v3 );
  if ( (unsigned int)result < v3 )
    goto LABEL_14;
  return result;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];
// 61460: using guessed type __int128 xmmword_61460;

//----- (000000000001BA38) ----------------------------------------------------
__int64 __fastcall sub_1BA38(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2; // w8

  if ( *a1 < *a2 )
    v2 = -1;
  else
    v2 = 1;
  if ( *a1 == *a2 )
    return 0;
  else
    return v2;
}

//----- (000000000001BA54) ----------------------------------------------------
__int64 __fastcall FLAC__format_vorbiscomment_entry_name_is_legal(_BYTE *a1)
{
  char v1; // w9
  unsigned __int8 *v2; // x8
  __int64 result; // x0
  int v4; // t1

  v1 = *a1;
  if ( !*a1 )
    return 1;
  v2 = a1 + 1;
  while ( 1 )
  {
    result = 0;
    if ( v1 == 61 || (unsigned __int8)(v1 - 32) >= 0x5Eu )
      break;
    v4 = *v2++;
    v1 = v4;
    if ( !v4 )
      return 1;
  }
  return result;
}

//----- (000000000001BA9C) ----------------------------------------------------
__int64 __fastcall FLAC__format_vorbiscomment_entry_value_is_legal(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // x19
  unsigned __int8 *v3; // x20
  unsigned int v4; // w0
  __int64 result; // x0

  v2 = a1;
  if ( a2 == -1 )
  {
    if ( *a1 )
    {
      while ( 1 )
      {
        result = sub_1BB3C(v2);
        if ( !(_DWORD)result )
          break;
        v2 += (unsigned int)result;
        if ( !*v2 )
          return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v3 = &a1[a2];
    if ( a2 )
    {
      do
      {
        v4 = sub_1BB3C(v2);
        if ( !v4 )
          return 0;
        v2 += v4;
      }
      while ( v2 < v3 );
    }
    return v2 == v3;
  }
  return result;
}

//----- (000000000001BB3C) ----------------------------------------------------
__int64 __fastcall sub_1BB3C(unsigned __int8 *a1)
{
  int v1; // w8
  int v3; // w9
  unsigned __int8 v4; // w10
  unsigned __int8 v5; // w9
  unsigned __int8 v7; // w9
  unsigned __int8 v9; // w9

  v1 = *a1;
  if ( (v1 & 0x80) == 0 )
    return 1;
  if ( (v1 & 0xE0) == 0xC0 && (a1[1] & 0xC0) == 0x80 )
  {
    if ( (v1 & 0xFE) == 0xC0 )
      return 0;
    else
      return 2;
  }
  else if ( (v1 & 0xF0) == 0xE0 && (v3 = a1[1], (v3 & 0xC0) == 0x80) && (v4 = a1[2], (v4 & 0xC0) == 0x80) )
  {
    if ( v1 == 224 && (v3 & 0xE0) == 0x80 )
      return 0;
    if ( v1 == 239 )
    {
      if ( v3 == 191 && (v4 & 0xFE) == 0xBE )
        return 0;
    }
    else if ( v1 == 237 && (v3 & 0xE0) == 0xA0 )
    {
      return 0;
    }
    return 3;
  }
  else if ( (v1 & 0xF8) == 0xF0 && (v5 = a1[1], (v5 & 0xC0) == 0x80) && (a1[2] & 0xC0) == 0x80 && (a1[3] & 0xC0) == 0x80 )
  {
    if ( (v5 & 0xF0) == 0x80 && v1 == 240 )
      return 0;
    else
      return 4;
  }
  else if ( (v1 & 0xFC) == 0xF8
         && (v7 = a1[1], (v7 & 0xC0) == 0x80)
         && (a1[2] & 0xC0) == 0x80
         && (a1[3] & 0xC0) == 0x80
         && (a1[4] & 0xC0) == 0x80 )
  {
    if ( (v7 & 0xF8) == 0x80 && v1 == 248 )
      return 0;
    else
      return 5;
  }
  else if ( (v1 & 0xFE) == 0xFC )
  {
    v9 = a1[1];
    if ( (v9 & 0xC0) == 0x80 )
    {
      if ( (a1[2] & 0xC0) == 0x80 )
      {
        if ( (a1[3] & 0xC0) == 0x80 )
        {
          if ( (a1[4] & 0xC0) == 0x80 )
          {
            if ( (a1[5] & 0xC0) == 0x80 )
            {
              if ( (v9 & 0xFC) == 0x80 && v1 == 252 )
                return 0;
              else
                return 6;
            }
            else
            {
              return 0;
            }
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

//----- (000000000001BD74) ----------------------------------------------------
__int64 __fastcall FLAC__format_vorbiscomment_entry_is_legal(unsigned __int8 *a1, int a2)
{
  unsigned __int64 v2; // x20
  int v3; // w8
  unsigned __int8 *v4; // x19
  __int64 result; // x0

  v2 = (unsigned __int64)&a1[a2];
  if ( a2 )
  {
    do
    {
      v3 = *a1;
      if ( v3 == 61 )
        break;
      if ( (unsigned int)(v3 - 32) > 0x5D )
        return 0;
      ++a1;
    }
    while ( (unsigned __int64)a1 < v2 );
  }
  if ( a1 == (unsigned __int8 *)v2 )
    return 0;
  v4 = a1 + 1;
  if ( (unsigned __int64)(a1 + 1) >= v2 )
    return v4 == (unsigned __int8 *)v2;
  while ( 1 )
  {
    result = sub_1BB3C(v4);
    if ( !(_DWORD)result )
      break;
    v4 += (unsigned int)result;
    if ( (unsigned __int64)v4 >= v2 )
      return v4 == (unsigned __int8 *)v2;
  }
  return result;
}

//----- (000000000001BE1C) ----------------------------------------------------
__int64 __fastcall FLAC__format_cuesheet_is_legal(__int64 a1, int a2, const char **a3)
{
  unsigned __int64 v3; // x8
  __int64 result; // x0
  unsigned int v5; // w9
  __int64 v6; // x10
  unsigned int v7; // w8
  __int64 v8; // x10
  unsigned int v9; // w13
  unsigned int v10; // w14
  __int64 v11; // x16
  unsigned int v12; // w15
  unsigned __int8 *v13; // x17
  unsigned int v14; // w11
  __int64 v15; // x12
  unsigned __int64 v16; // x12
  unsigned __int64 v17; // x13
  __int64 v18; // x15
  const char *v19; // x8

  if ( a2 )
  {
    v3 = *(_QWORD *)(a1 + 136);
    if ( v3 <= 0x15887 )
    {
      result = 0;
      if ( a3 )
        *a3 = "CD-DA cue sheet must have a lead-in length of at least 2 seconds";
      return result;
    }
    if ( v3 % 0x24C )
    {
      result = 0;
      if ( a3 )
        *a3 = "CD-DA cue sheet lead-in length must be evenly divisible by 588 samples";
      return result;
    }
  }
  v5 = *(_DWORD *)(a1 + 148);
  if ( v5 )
  {
    v6 = *(_QWORD *)(a1 + 152);
    v7 = v5 - 1;
    if ( !a2 )
    {
      v14 = 0;
      result = 1;
      while ( 1 )
      {
        v15 = v6 + 32LL * v14;
        if ( !*(_BYTE *)(v15 + 8) )
          goto LABEL_55;
        v16 = *(unsigned __int8 *)(v15 + 23);
        if ( v14 < v7 )
        {
          if ( !(_DWORD)v16 )
          {
LABEL_57:
            result = 0;
            if ( a3 )
              *a3 = "cue sheet track must have at least one index point";
            return result;
          }
          if ( *(unsigned __int8 *)(*(_QWORD *)(v6 + 32LL * v14 + 24) + 8LL) >= 2u )
          {
LABEL_59:
            result = 0;
            if ( a3 )
              *a3 = "cue sheet track's first index number must be 0 or 1";
            return result;
          }
LABEL_38:
          v17 = 0;
          v18 = 8;
          while ( !v17
               || *(unsigned __int8 *)(*(_QWORD *)(v6 + 32LL * v14 + 24) + 16LL * (unsigned int)(v17 - 1) + 8) + 1 == *(unsigned __int8 *)(*(_QWORD *)(v6 + 32LL * v14 + 24) + v18) )
          {
            ++v17;
            v18 += 16;
            if ( v17 >= v16 )
              goto LABEL_42;
          }
LABEL_44:
          result = 0;
          if ( a3 )
            *a3 = "cue sheet track index numbers must increase by 1";
          return result;
        }
        if ( (_DWORD)v16 )
          goto LABEL_38;
LABEL_42:
        if ( ++v14 >= v5 )
          return result;
      }
    }
    if ( *(unsigned __int8 *)(v6 + 32LL * v7 + 8) == 170 )
    {
      v8 = *(_QWORD *)(a1 + 152);
      v9 = 0;
      while ( 1 )
      {
        v10 = *(unsigned __int8 *)(v8 + 32LL * v9 + 8);
        if ( !*(_BYTE *)(v8 + 32LL * v9 + 8) )
          break;
        if ( v10 >= 0x64 && v10 != 170 )
        {
          result = 0;
          if ( a3 )
            *a3 = "CD-DA cue sheet track number must be 1-99 or 170";
          return result;
        }
        if ( *(_QWORD *)(v8 + 32LL * v9) % 0x24CuLL )
        {
          if ( !a3 )
            return 0;
          result = 0;
          if ( v9 == v7 )
            v19 = "CD-DA cue sheet lead-out offset must be evenly divisible by 588 samples";
          else
            v19 = "CD-DA cue sheet track offset must be evenly divisible by 588 samples";
          *a3 = v19;
          return result;
        }
        if ( v9 < v7 )
        {
          if ( !*(_BYTE *)(v8 + 32LL * v9 + 23) )
            goto LABEL_57;
          if ( *(unsigned __int8 *)(*(_QWORD *)(v8 + 32LL * v9 + 24) + 8LL) <= 1u )
          {
LABEL_21:
            v11 = *(_QWORD *)(v8 + 32LL * v9 + 24);
            v12 = 0;
            v13 = (unsigned __int8 *)(v11 + 8);
            while ( !(*((_QWORD *)v13 - 1) % 0x24CuLL) )
            {
              if ( v12 && *(unsigned __int8 *)(v11 + 16LL * (v12 - 1) + 8) + 1 != *v13 )
                goto LABEL_44;
              ++v12;
              v13 += 16;
              if ( v12 >= *(unsigned __int8 *)(v8 + 32LL * v9 + 23) )
                goto LABEL_26;
            }
            result = 0;
            if ( a3 )
              *a3 = "CD-DA cue sheet track index offset must be evenly divisible by 588 samples";
            return result;
          }
          goto LABEL_59;
        }
        if ( *(_BYTE *)(v8 + 32LL * v9 + 23) )
          goto LABEL_21;
LABEL_26:
        ++v9;
        result = 1;
        if ( v9 >= v5 )
          return result;
      }
LABEL_55:
      result = 0;
      if ( a3 )
        *a3 = "cue sheet may not have a track number 0";
      return result;
    }
    result = 0;
    if ( a3 )
      *a3 = "CD-DA cue sheet must have a lead-out track number 170 (0xAA)";
  }
  else
  {
    result = 0;
    if ( a3 )
      *a3 = "cue sheet must have at least one track (the lead-out)";
  }
  return result;
}

//----- (000000000001C180) ----------------------------------------------------
__int64 __fastcall FLAC__format_picture_is_legal(__int64 a1, _QWORD *a2)
{
  _BYTE *v2; // x8
  char v4; // w9
  unsigned __int8 *v5; // x8
  int v6; // t1
  unsigned __int8 *v7; // x20
  unsigned int v8; // w0
  __int64 result; // x0

  v2 = *(_BYTE **)(a1 + 8);
  v4 = *v2;
  if ( *v2 )
  {
    v5 = v2 + 1;
    while ( (unsigned __int8)(v4 - 32) < 0x5Fu )
    {
      v6 = *v5++;
      v4 = v6;
      if ( !v6 )
        goto LABEL_5;
    }
    result = 0;
    if ( a2 )
      *a2 = "MIME type string must contain only printable ASCII characters (0x20-0x7e)";
  }
  else
  {
LABEL_5:
    v7 = *(unsigned __int8 **)(a1 + 16);
    if ( *v7 )
    {
      while ( 1 )
      {
        v8 = sub_1BB3C(v7);
        if ( !v8 )
          break;
        v7 += v8;
        if ( !*v7 )
          return 1;
      }
      result = 0;
      if ( a2 )
        *a2 = "description string must be valid UTF-8";
    }
    else
    {
      return 1;
    }
  }
  return result;
}

//----- (000000000001C250) ----------------------------------------------------
__int64 __fastcall FLAC__format_get_max_rice_partition_order(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w9
  char v4; // w10
  unsigned int v5; // w9

  v2 = 0;
  if ( (a1 & 1) == 0 )
  {
    v3 = a1;
    do
    {
      v4 = v3;
      ++v2;
      v3 >>= 1;
    }
    while ( (v4 & 2) == 0 );
    if ( v2 > 0xE )
      v2 = 15;
  }
  do
  {
    v5 = v2 - 1;
    if ( !v2 )
      break;
  }
  while ( a1 >> v2-- <= a2 );
  return v5 + 1;
}

//----- (000000000001C298) ----------------------------------------------------
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(
        int a1,
        unsigned int a2,
        unsigned int a3)
{
  int v3; // w8
  unsigned int v4; // w9

  do
  {
    v3 = a1 - 1;
    if ( !a1 )
      break;
    v4 = a2 >> a1--;
  }
  while ( v4 <= a3 );
  return (unsigned int)(v3 + 1);
}

//----- (000000000001C2B8) ----------------------------------------------------
__int64 __fastcall FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned int a1)
{
  unsigned int v1; // w8
  __int64 result; // x0
  char v3; // w9

  v1 = a1;
  if ( (a1 & 1) != 0 )
    return 0;
  LODWORD(result) = 0;
  do
  {
    v3 = v1;
    result = (unsigned int)(result + 1);
    v1 >>= 1;
  }
  while ( (v3 & 2) == 0 );
  if ( (unsigned int)result > 0xE )
    return 15;
  return result;
}

//----- (000000000001C2EC) ----------------------------------------------------
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_init(__int64 result)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (000000000001C2F8) ----------------------------------------------------
void __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0

  v2 = *(void **)a1;
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 8);
  if ( v3 )
    free(v3);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
}

//----- (000000000001C334) ----------------------------------------------------
__int64 __fastcall FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(
        __int64 a1,
        unsigned int a2)
{
  unsigned int v3; // w8
  __int64 result; // x0
  void *v6; // x22
  size_t v7; // x21
  void *v8; // x0
  void *v9; // x22
  void *v10; // x0

  v3 = *(_DWORD *)(a1 + 16);
  result = 1;
  if ( v3 < a2 )
  {
    v6 = *(void **)a1;
    v7 = 4LL * (1 << a2);
    v8 = realloc(*(void **)a1, v7);
    if ( v8 )
    {
      v9 = *(void **)(a1 + 8);
      *(_QWORD *)a1 = v8;
      v10 = realloc(v9, v7);
      if ( v10 )
      {
        *(_QWORD *)(a1 + 8) = v10;
        memset(v10, 0, v7);
        result = 1;
        *(_DWORD *)(a1 + 16) = a2;
      }
      else
      {
        free(v9);
        result = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
    else
    {
      free(v6);
      result = 0;
      *(_QWORD *)a1 = 0;
    }
  }
  return result;
}

//----- (000000000001C3F8) ----------------------------------------------------
int *__fastcall FLAC__lpc_restore_signal(int *result, __int64 a2, int *a3, unsigned int a4, char a5, _DWORD *a6)
{
  int v6; // w8
  int v7; // w9
  int v8; // w10
  int v9; // w11
  int v10; // w12
  int v11; // w13
  int v12; // w14
  int v13; // w15
  int v14; // w16
  int v15; // w17
  int v16; // w2
  int v17; // w18
  int v18; // w26
  int v19; // w27
  int v20; // w3
  int v21; // w6
  int v22; // w7
  int v23; // w19
  int v24; // w20
  int v25; // w21
  int v26; // w22
  int v27; // w23
  int v28; // w24
  int v29; // w25
  int v30; // w29
  int v31; // t1
  __int64 v32; // x8
  _DWORD *v33; // x9
  int v34; // w12
  int v35; // t1
  int v36; // w8
  int v37; // w9
  int v38; // w10
  int v39; // w11
  int v40; // w12
  int v41; // w13
  int v42; // w14
  int v43; // w15
  int v44; // w7
  int v45; // w19
  int v46; // w16
  int v47; // w17
  int v48; // w2
  int v49; // w18
  int v50; // w3
  int v51; // w6
  int v52; // w21
  int v53; // t1
  int v54; // w8
  int v55; // w9
  int v56; // w10
  int v57; // w11
  int v58; // w12
  int v59; // w13
  int v60; // w14
  int v61; // w15
  int v62; // w16
  int v63; // w17
  int v64; // w22
  int v65; // w23
  int v66; // w2
  int v67; // w18
  int v68; // w3
  int v69; // w6
  int v70; // w7
  int v71; // w19
  int v72; // w20
  int v73; // w21
  int v74; // w25
  int v75; // t1
  int v76; // w8
  int v77; // w9
  int v78; // w10
  int v79; // w11
  int v80; // w15
  int v81; // w16
  int v82; // w12
  int v83; // w14
  __int64 v84; // x13
  int v85; // t1
  int v86; // w18
  int v87; // w8
  int v88; // w10
  int v89; // w9
  int v90; // w12
  int v91; // w11
  int v92; // w14
  int v93; // w13
  int v94; // w16
  int v95; // w15
  int v96; // w18
  int v97; // w17
  int v98; // w24
  int v99; // w25
  int v100; // w2
  int v101; // w3
  int v102; // w6
  int v103; // w7
  int v104; // w19
  int v105; // w20
  int v106; // w21
  int v107; // w22
  int v108; // w23
  int v109; // w27
  int v110; // t1
  int v111; // w8
  int v112; // w9
  int v113; // w10
  int v114; // w11
  int v115; // w12
  int v116; // w13
  int v117; // w2
  int v118; // w3
  int v119; // w14
  int v120; // w15
  int v121; // w16
  int v122; // w18
  __int64 v123; // x17
  int v124; // w1
  int v125; // t1
  int v126; // w8
  int v127; // w10
  int v128; // w9
  int v129; // w12
  int v130; // w11
  int v131; // w14
  int v132; // w13
  int v133; // w16
  int v134; // w15
  int v135; // w20
  int v136; // w21
  int v137; // w17
  int v138; // w18
  int v139; // w2
  int v140; // w3
  int v141; // w6
  int v142; // w7
  int v143; // w19
  int v144; // w23
  int v145; // t1
  int v146; // w8
  int v147; // w9
  int v148; // w11
  int v149; // w12
  __int64 v150; // x10
  int v151; // t1
  int v152; // w14
  int v153; // w8
  int v154; // w10
  int v155; // w9
  int v156; // w12
  int v157; // w11
  int v158; // w14
  int v159; // w13
  int v160; // w3
  int v161; // w6
  int v162; // w15
  int v163; // w16
  int v164; // w17
  int v165; // w18
  int v166; // w2
  int v167; // w19
  int v168; // t1
  int v169; // w8
  int v170; // w10
  int v171; // w9
  int v172; // w13
  int v173; // w14
  int v174; // w11
  __int64 v175; // x12
  int v176; // t1
  int v177; // w16
  int v178; // w8
  int v179; // w10
  int v180; // w9
  int v181; // w12
  int v182; // w11
  int v183; // w17
  int v184; // w18
  int v185; // w13
  int v186; // w14
  int v187; // w16
  __int64 v188; // x15
  int v189; // w2
  int v190; // t1
  int v191; // w8
  int v192; // w10
  __int64 v193; // x9
  int v194; // t1

  if ( a4 > 0xC )
  {
    if ( (int)a2 >= 1 )
    {
      v32 = (unsigned int)a2;
      v33 = a6 - 16;
      do
      {
        v34 = 0;
        switch ( a4 )
        {
          case 0xDu:
            goto LABEL_31;
          case 0xEu:
            goto LABEL_30;
          case 0xFu:
            goto LABEL_29;
          case 0x10u:
            goto LABEL_28;
          case 0x11u:
            goto LABEL_27;
          case 0x12u:
            goto LABEL_26;
          case 0x13u:
            goto LABEL_25;
          case 0x14u:
            goto LABEL_24;
          case 0x15u:
            goto LABEL_23;
          case 0x16u:
            goto LABEL_22;
          case 0x17u:
            goto LABEL_21;
          case 0x18u:
            goto LABEL_20;
          case 0x19u:
            goto LABEL_19;
          case 0x1Au:
            goto LABEL_18;
          case 0x1Bu:
            goto LABEL_17;
          case 0x1Cu:
            goto LABEL_16;
          case 0x1Du:
            goto LABEL_15;
          case 0x1Eu:
            goto LABEL_14;
          case 0x1Fu:
            goto LABEL_13;
          case 0x20u:
            v34 = *(v33 - 16) * a3[31];
LABEL_13:
            v34 += *(v33 - 15) * a3[30];
LABEL_14:
            v34 += *(v33 - 14) * a3[29];
LABEL_15:
            v34 += *(v33 - 13) * a3[28];
LABEL_16:
            v34 += *(v33 - 12) * a3[27];
LABEL_17:
            v34 += *(v33 - 11) * a3[26];
LABEL_18:
            v34 += *(v33 - 10) * a3[25];
LABEL_19:
            v34 += *(v33 - 9) * a3[24];
LABEL_20:
            v34 += *(v33 - 8) * a3[23];
LABEL_21:
            v34 += *(v33 - 7) * a3[22];
LABEL_22:
            v34 += *(v33 - 6) * a3[21];
LABEL_23:
            v34 += *(v33 - 5) * a3[20];
LABEL_24:
            v34 += *(v33 - 4) * a3[19];
LABEL_25:
            v34 += *(v33 - 3) * a3[18];
LABEL_26:
            v34 += *(v33 - 2) * a3[17];
LABEL_27:
            v34 += *(v33 - 1) * a3[16];
LABEL_28:
            v34 += *v33 * a3[15];
LABEL_29:
            v34 += v33[1] * a3[14];
LABEL_30:
            v34 += v33[2] * a3[13];
LABEL_31:
            v34 += v33[3] * a3[12]
                 + v33[4] * a3[11]
                 + v33[5] * a3[10]
                 + v33[6] * a3[9]
                 + v33[7] * a3[8]
                 + v33[8] * a3[7]
                 + v33[9] * a3[6]
                 + v33[10] * a3[5]
                 + v33[11] * a3[4]
                 + v33[12] * a3[3]
                 + v33[13] * a3[2]
                 + v33[14] * a3[1]
                 + v33[15] * *a3;
            break;
          default:
            break;
        }
        v35 = *result++;
        --v32;
        v33[16] = v35 + (v34 >> a5);
        ++v33;
      }
      while ( v32 );
    }
  }
  else if ( a4 < 9 )
  {
    if ( a4 < 5 )
    {
      if ( a4 < 3 )
      {
        if ( a4 == 2 )
        {
          if ( (int)a2 >= 1 )
          {
            v146 = *a3;
            v147 = a3[1];
            v148 = *(a6 - 2);
            v149 = *(a6 - 1);
            v150 = (unsigned int)a2;
            do
            {
              v151 = *result++;
              v152 = v148 * v147 + v149 * v146;
              v148 = v149;
              v149 = (v152 >> a5) + v151;
              --v150;
              *a6++ = v149;
            }
            while ( v150 );
          }
        }
        else if ( (int)a2 >= 1 )
        {
          v191 = *a3;
          v192 = *(a6 - 1);
          v193 = (unsigned int)a2;
          do
          {
            v194 = *result++;
            --v193;
            v192 = ((v192 * v191) >> a5) + v194;
            *a6++ = v192;
          }
          while ( v193 );
        }
      }
      else if ( a4 == 4 )
      {
        if ( (int)a2 >= 1 )
        {
          v76 = a3[2];
          v77 = a3[3];
          v78 = *a3;
          v79 = a3[1];
          v80 = *(a6 - 4);
          v81 = *(a6 - 3);
          v82 = *(a6 - 2);
          v83 = *(a6 - 1);
          v84 = (unsigned int)a2;
          do
          {
            v85 = *result++;
            v86 = v80 * v77 + v81 * v76;
            v80 = v81;
            v81 = v82;
            v82 = v83;
            v83 = ((v86 + v81 * v79 + v83 * v78) >> a5) + v85;
            --v84;
            *a6++ = v83;
          }
          while ( v84 );
        }
      }
      else if ( (int)a2 >= 1 )
      {
        v170 = a3[1];
        v169 = a3[2];
        v171 = *a3;
        v172 = *(a6 - 3);
        v173 = *(a6 - 2);
        v174 = *(a6 - 1);
        v175 = (unsigned int)a2;
        do
        {
          v176 = *result++;
          v177 = v172 * v169 + v173 * v170;
          v172 = v173;
          v173 = v174;
          v174 = ((v177 + v174 * v171) >> a5) + v176;
          --v175;
          *a6++ = v174;
        }
        while ( v175 );
      }
    }
    else if ( a4 < 7 )
    {
      if ( a4 == 6 )
      {
        if ( (int)a2 >= 1 )
        {
          v111 = a3[4];
          v112 = a3[5];
          v113 = a3[2];
          v114 = a3[3];
          v115 = *a3;
          v116 = a3[1];
          v117 = *(a6 - 6);
          v118 = *(a6 - 5);
          v119 = *(a6 - 4);
          v120 = *(a6 - 3);
          v121 = *(a6 - 2);
          v122 = *(a6 - 1);
          v123 = (unsigned int)a2;
          do
          {
            v124 = v117 * v112 + v118 * v111;
            v117 = v118;
            v118 = v119;
            v119 = v120;
            v120 = v121;
            v121 = v122;
            v125 = *result++;
            v122 = ((v124 + v118 * v114 + v119 * v113 + v120 * v116 + v122 * v115) >> a5) + v125;
            --v123;
            *a6++ = v122;
          }
          while ( v123 );
        }
      }
      else if ( (int)a2 >= 1 )
      {
        v179 = a3[3];
        v178 = a3[4];
        v181 = a3[1];
        v180 = a3[2];
        v182 = *a3;
        v183 = *(a6 - 5);
        v184 = *(a6 - 4);
        v185 = *(a6 - 3);
        v186 = *(a6 - 2);
        v187 = *(a6 - 1);
        v188 = (unsigned int)a2;
        do
        {
          v189 = v183 * v178 + v184 * v179;
          v183 = v184;
          v184 = v185;
          v190 = *result++;
          v185 = v186;
          v186 = v187;
          v187 = ((v189 + v184 * v180 + v185 * v181 + v187 * v182) >> a5) + v190;
          --v188;
          *a6++ = v187;
        }
        while ( v188 );
      }
    }
    else if ( a4 == 8 )
    {
      if ( (int)a2 >= 1 )
      {
        v36 = a3[6];
        v37 = a3[7];
        v38 = a3[4];
        v39 = a3[5];
        v40 = a3[2];
        v41 = a3[3];
        v42 = *a3;
        v43 = a3[1];
        v44 = *(a6 - 8);
        v45 = *(a6 - 7);
        v46 = *(a6 - 6);
        v47 = *(a6 - 5);
        v49 = *(a6 - 4);
        v48 = *(a6 - 3);
        v50 = *(a6 - 2);
        v51 = *(a6 - 1);
        a2 = (unsigned int)a2;
        do
        {
          v52 = v44 * v37 + v45 * v36;
          v44 = v45;
          v45 = v46;
          v46 = v47;
          v47 = v49;
          v49 = v48;
          v48 = v50;
          v50 = v51;
          v53 = *result++;
          v51 = ((v52 + v45 * v39 + v46 * v38 + v47 * v41 + v49 * v40 + v48 * v43 + v51 * v42) >> a5) + v53;
          --a2;
          *a6++ = v51;
        }
        while ( a2 );
      }
    }
    else if ( (int)a2 >= 1 )
    {
      v154 = a3[5];
      v153 = a3[6];
      v156 = a3[3];
      v155 = a3[4];
      v158 = a3[1];
      v157 = a3[2];
      v159 = *a3;
      v160 = *(a6 - 7);
      v161 = *(a6 - 6);
      v162 = *(a6 - 5);
      v163 = *(a6 - 4);
      v164 = *(a6 - 3);
      v165 = *(a6 - 2);
      v166 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v167 = v160 * v153 + v161 * v154;
        v160 = v161;
        v161 = v162;
        v162 = v163;
        v163 = v164;
        v164 = v165;
        v165 = v166;
        v168 = *result++;
        v166 = ((v167 + v161 * v155 + v162 * v156 + v163 * v157 + v164 * v158 + v166 * v159) >> a5) + v168;
        --a2;
        *a6++ = v166;
      }
      while ( a2 );
    }
  }
  else if ( a4 < 0xB )
  {
    if ( a4 == 10 )
    {
      if ( (int)a2 >= 1 )
      {
        v54 = a3[8];
        v55 = a3[9];
        v56 = a3[6];
        v57 = a3[7];
        v58 = a3[4];
        v59 = a3[5];
        v60 = a3[2];
        v61 = a3[3];
        v62 = *a3;
        v63 = a3[1];
        v64 = *(a6 - 10);
        v65 = *(a6 - 9);
        v67 = *(a6 - 8);
        v66 = *(a6 - 7);
        v68 = *(a6 - 6);
        v69 = *(a6 - 5);
        v70 = *(a6 - 4);
        v71 = *(a6 - 3);
        v72 = *(a6 - 2);
        v73 = *(a6 - 1);
        a2 = (unsigned int)a2;
        do
        {
          v74 = v64 * v55 + v65 * v54;
          v64 = v65;
          v65 = v67;
          v67 = v66;
          v66 = v68;
          v68 = v69;
          v69 = v70;
          v70 = v71;
          v71 = v72;
          v72 = v73;
          v75 = *result++;
          v73 = ((v74 + v65 * v57 + v67 * v56 + v66 * v59 + v68 * v58 + v69 * v61 + v70 * v60 + v71 * v63 + v73 * v62) >> a5)
              + v75;
          --a2;
          *a6++ = v73;
        }
        while ( a2 );
      }
    }
    else if ( (int)a2 >= 1 )
    {
      v127 = a3[7];
      v126 = a3[8];
      v129 = a3[5];
      v128 = a3[6];
      v131 = a3[3];
      v130 = a3[4];
      v133 = a3[1];
      v132 = a3[2];
      v134 = *a3;
      v135 = *(a6 - 9);
      v136 = *(a6 - 8);
      v137 = *(a6 - 7);
      v138 = *(a6 - 6);
      v139 = *(a6 - 5);
      v140 = *(a6 - 4);
      v141 = *(a6 - 3);
      v142 = *(a6 - 2);
      v143 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v144 = v135 * v126 + v136 * v127;
        v135 = v136;
        v136 = v137;
        v137 = v138;
        v138 = v139;
        v139 = v140;
        v140 = v141;
        v141 = v142;
        v142 = v143;
        v145 = *result++;
        v143 = ((v144 + v136 * v128 + v137 * v129 + v138 * v130 + v139 * v131 + v140 * v132 + v141 * v133 + v143 * v134) >> a5)
             + v145;
        --a2;
        *a6++ = v143;
      }
      while ( a2 );
    }
  }
  else if ( a4 == 12 )
  {
    if ( (int)a2 >= 1 )
    {
      v6 = a3[10];
      v7 = a3[11];
      v8 = a3[8];
      v9 = a3[9];
      v10 = a3[6];
      v11 = a3[7];
      v12 = a3[4];
      v13 = a3[5];
      v14 = a3[2];
      v15 = a3[3];
      v17 = *a3;
      v16 = a3[1];
      v18 = *(a6 - 12);
      v19 = *(a6 - 11);
      v20 = *(a6 - 10);
      v21 = *(a6 - 9);
      v22 = *(a6 - 8);
      v23 = *(a6 - 7);
      v24 = *(a6 - 6);
      v25 = *(a6 - 5);
      v26 = *(a6 - 4);
      v27 = *(a6 - 3);
      v28 = *(a6 - 2);
      v29 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v30 = v18 * v7 + v19 * v6;
        v18 = v19;
        v19 = v20;
        v20 = v21;
        v21 = v22;
        v22 = v23;
        v23 = v24;
        v24 = v25;
        v25 = v26;
        v26 = v27;
        v27 = v28;
        v28 = v29;
        v31 = *result++;
        v29 = ((v30
              + v19 * v9
              + v20 * v8
              + v21 * v11
              + v22 * v10
              + v23 * v13
              + v24 * v12
              + v25 * v15
              + v26 * v14
              + v27 * v16
              + v29 * v17) >> a5)
            + v31;
        --a2;
        *a6++ = v29;
      }
      while ( a2 );
    }
  }
  else if ( (int)a2 >= 1 )
  {
    v88 = a3[9];
    v87 = a3[10];
    v90 = a3[7];
    v89 = a3[8];
    v92 = a3[5];
    v91 = a3[6];
    v94 = a3[3];
    v93 = a3[4];
    v96 = a3[1];
    v95 = a3[2];
    v97 = *a3;
    v98 = *(a6 - 11);
    v99 = *(a6 - 10);
    v100 = *(a6 - 9);
    v101 = *(a6 - 8);
    v102 = *(a6 - 7);
    v103 = *(a6 - 6);
    v104 = *(a6 - 5);
    v105 = *(a6 - 4);
    v106 = *(a6 - 3);
    v107 = *(a6 - 2);
    v108 = *(a6 - 1);
    a2 = (unsigned int)a2;
    do
    {
      v109 = v98 * v87 + v99 * v88;
      v98 = v99;
      v99 = v100;
      v100 = v101;
      v101 = v102;
      v102 = v103;
      v103 = v104;
      v104 = v105;
      v105 = v106;
      v106 = v107;
      v107 = v108;
      v110 = *result++;
      v108 = ((v109
             + v99 * v89
             + v100 * v90
             + v101 * v91
             + v102 * v92
             + v103 * v93
             + v104 * v94
             + v105 * v95
             + v106 * v96
             + v108 * v97) >> a5)
           + v110;
      --a2;
      *a6++ = v108;
    }
    while ( a2 );
  }
  return result;
}

//----- (000000000001CB9C) ----------------------------------------------------
int *__fastcall FLAC__lpc_restore_signal_wide(int *result, __int64 a2, int *a3, unsigned int a4, char a5, _DWORD *a6)
{
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 v8; // x10
  __int64 v9; // x11
  __int64 v10; // x12
  __int64 v11; // x13
  __int64 v12; // x14
  __int64 v13; // x15
  __int64 v14; // x16
  __int64 v15; // x17
  __int64 v16; // x2
  __int64 v17; // x18
  int v18; // w26
  int v19; // w27
  int v20; // w3
  int v21; // w6
  int v22; // w7
  int v23; // w19
  int v24; // w20
  int v25; // w21
  int v26; // w22
  int v27; // w23
  int v28; // w24
  int v29; // w25
  __int64 v30; // x28
  __int64 v31; // x29
  int v32; // t1
  __int64 v33; // x9
  int *v34; // x10
  __int64 v35; // x13
  int v36; // t1
  __int64 v37; // x8
  __int64 v38; // x9
  __int64 v39; // x10
  __int64 v40; // x11
  __int64 v41; // x12
  __int64 v42; // x13
  __int64 v43; // x14
  __int64 v44; // x15
  int v45; // w7
  int v46; // w19
  int v47; // w16
  int v48; // w17
  int v49; // w2
  int v50; // w18
  int v51; // w3
  int v52; // w6
  __int64 v53; // x20
  __int64 v54; // x21
  int v55; // t1
  __int64 v56; // x8
  __int64 v57; // x9
  __int64 v58; // x10
  __int64 v59; // x11
  __int64 v60; // x12
  __int64 v61; // x13
  __int64 v62; // x14
  __int64 v63; // x15
  __int64 v64; // x16
  __int64 v65; // x17
  int v66; // w22
  int v67; // w23
  int v68; // w2
  int v69; // w18
  int v70; // w3
  int v71; // w6
  int v72; // w7
  int v73; // w19
  int v74; // w20
  int v75; // w21
  __int64 v76; // x24
  __int64 v77; // x25
  int v78; // t1
  __int64 v79; // x8
  __int64 v80; // x9
  __int64 v81; // x10
  __int64 v82; // x11
  int v83; // w16
  int v84; // w17
  int v85; // w12
  int v86; // w15
  __int64 v87; // x14
  __int64 v88; // x18
  __int64 v89; // x1
  int v90; // t1
  __int64 v91; // x8
  __int64 v92; // x10
  __int64 v93; // x9
  __int64 v94; // x12
  __int64 v95; // x11
  __int64 v96; // x14
  __int64 v97; // x13
  __int64 v98; // x16
  __int64 v99; // x15
  __int64 v100; // x18
  __int64 v101; // x17
  int v102; // w24
  int v103; // w25
  int v104; // w2
  int v105; // w3
  int v106; // w6
  int v107; // w7
  int v108; // w19
  int v109; // w20
  int v110; // w21
  int v111; // w22
  int v112; // w23
  __int64 v113; // x26
  __int64 v114; // x27
  int v115; // t1
  __int64 v116; // x8
  __int64 v117; // x9
  __int64 v118; // x10
  __int64 v119; // x11
  __int64 v120; // x12
  __int64 v121; // x13
  int v122; // w3
  int v123; // w6
  int v124; // w14
  int v125; // w15
  int v126; // w2
  int v127; // w16
  __int64 v129; // x18
  __int64 v130; // x1
  __int64 v131; // x4
  int v132; // t1
  __int64 v133; // x8
  __int64 v134; // x10
  __int64 v135; // x9
  __int64 v136; // x12
  __int64 v137; // x11
  __int64 v138; // x14
  __int64 v139; // x13
  __int64 v140; // x16
  __int64 v141; // x15
  int v142; // w20
  int v143; // w21
  int v144; // w17
  int v145; // w18
  int v146; // w2
  int v147; // w3
  int v148; // w6
  int v149; // w7
  int v150; // w19
  __int64 v151; // x22
  __int64 v152; // x23
  int v153; // t1
  __int64 v154; // x8
  __int64 v155; // x9
  int v156; // w12
  int v157; // w13
  __int64 v158; // x11
  __int64 v159; // x14
  int v160; // t1
  __int64 v161; // x8
  __int64 v162; // x10
  __int64 v163; // x9
  __int64 v164; // x12
  __int64 v165; // x11
  __int64 v166; // x14
  __int64 v167; // x13
  int v168; // w6
  int v169; // w7
  int v170; // w15
  int v171; // w16
  int v172; // w17
  int v173; // w18
  int v174; // w3
  __int64 v176; // x4
  __int64 v177; // x19
  int v178; // t1
  __int64 v179; // x8
  __int64 v180; // x10
  __int64 v181; // x9
  int v182; // w14
  int v183; // w15
  int v184; // w13
  __int64 v185; // x12
  __int64 v186; // x16
  __int64 v187; // x17
  int v188; // t1
  __int64 v189; // x8
  __int64 v190; // x10
  __int64 v191; // x9
  __int64 v192; // x12
  __int64 v193; // x11
  int v194; // w2
  int v195; // w18
  int v196; // w13
  int v197; // w14
  int v198; // w17
  __int64 v199; // x16
  __int64 v200; // x1
  __int64 v201; // x3
  int v202; // t1
  __int64 v203; // x8
  int v204; // w11
  __int64 v205; // x10
  int v206; // t1

  if ( a4 > 0xC )
  {
    if ( (int)a2 >= 1 )
    {
      v33 = (unsigned int)a2;
      v34 = a6 - 16;
      do
      {
        v35 = 0;
        switch ( a4 )
        {
          case 0xDu:
            goto LABEL_31;
          case 0xEu:
            goto LABEL_30;
          case 0xFu:
            goto LABEL_29;
          case 0x10u:
            goto LABEL_28;
          case 0x11u:
            goto LABEL_27;
          case 0x12u:
            goto LABEL_26;
          case 0x13u:
            goto LABEL_25;
          case 0x14u:
            goto LABEL_24;
          case 0x15u:
            goto LABEL_23;
          case 0x16u:
            goto LABEL_22;
          case 0x17u:
            goto LABEL_21;
          case 0x18u:
            goto LABEL_20;
          case 0x19u:
            goto LABEL_19;
          case 0x1Au:
            goto LABEL_18;
          case 0x1Bu:
            goto LABEL_17;
          case 0x1Cu:
            goto LABEL_16;
          case 0x1Du:
            goto LABEL_15;
          case 0x1Eu:
            goto LABEL_14;
          case 0x1Fu:
            goto LABEL_13;
          case 0x20u:
            v35 = *(v34 - 16) * (__int64)a3[31];
LABEL_13:
            v35 += *(v34 - 15) * (__int64)a3[30];
LABEL_14:
            v35 += *(v34 - 14) * (__int64)a3[29];
LABEL_15:
            v35 += *(v34 - 13) * (__int64)a3[28];
LABEL_16:
            v35 += *(v34 - 12) * (__int64)a3[27];
LABEL_17:
            v35 += *(v34 - 11) * (__int64)a3[26];
LABEL_18:
            v35 += *(v34 - 10) * (__int64)a3[25];
LABEL_19:
            v35 += *(v34 - 9) * (__int64)a3[24];
LABEL_20:
            v35 += *(v34 - 8) * (__int64)a3[23];
LABEL_21:
            v35 += *(v34 - 7) * (__int64)a3[22];
LABEL_22:
            v35 += *(v34 - 6) * (__int64)a3[21];
LABEL_23:
            v35 += *(v34 - 5) * (__int64)a3[20];
LABEL_24:
            v35 += *(v34 - 4) * (__int64)a3[19];
LABEL_25:
            v35 += *(v34 - 3) * (__int64)a3[18];
LABEL_26:
            v35 += *(v34 - 2) * (__int64)a3[17];
LABEL_27:
            v35 += *(v34 - 1) * (__int64)a3[16];
LABEL_28:
            v35 += *v34 * (__int64)a3[15];
LABEL_29:
            v35 += v34[1] * (__int64)a3[14];
LABEL_30:
            v35 += v34[2] * (__int64)a3[13];
LABEL_31:
            v35 += v34[3] * (__int64)a3[12]
                 + v34[4] * (__int64)a3[11]
                 + v34[5] * (__int64)a3[10]
                 + v34[6] * (__int64)a3[9]
                 + v34[7] * (__int64)a3[8]
                 + v34[8] * (__int64)a3[7]
                 + v34[9] * (__int64)a3[6]
                 + v34[10] * (__int64)a3[5]
                 + v34[11] * (__int64)a3[4]
                 + v34[12] * (__int64)a3[3]
                 + v34[13] * (__int64)a3[2]
                 + v34[14] * (__int64)a3[1]
                 + v34[15] * (__int64)*a3;
            break;
          default:
            break;
        }
        v36 = *result++;
        --v33;
        v34[16] = v36 + (v35 >> a5);
        ++v34;
      }
      while ( v33 );
    }
  }
  else if ( a4 < 9 )
  {
    if ( a4 < 5 )
    {
      if ( a4 < 3 )
      {
        if ( a4 == 2 )
        {
          if ( (int)a2 >= 1 )
          {
            v154 = *a3;
            v155 = a3[1];
            v156 = *(a6 - 2);
            v157 = *(a6 - 1);
            v158 = (unsigned int)a2;
            do
            {
              v159 = v156;
              v156 = v157;
              v160 = *result++;
              v157 = v160 + ((v159 * v155 + v157 * v154) >> a5);
              --v158;
              *a6++ = v157;
            }
            while ( v158 );
          }
        }
        else if ( (int)a2 >= 1 )
        {
          v203 = *a3;
          v204 = *(a6 - 1);
          v205 = (unsigned int)a2;
          do
          {
            v206 = *result++;
            v204 = v206 + ((v204 * v203) >> a5);
            --v205;
            *a6++ = v204;
          }
          while ( v205 );
        }
      }
      else if ( a4 == 4 )
      {
        if ( (int)a2 >= 1 )
        {
          v79 = a3[2];
          v80 = a3[3];
          v81 = *a3;
          v82 = a3[1];
          v83 = *(a6 - 4);
          v84 = *(a6 - 3);
          v85 = *(a6 - 2);
          v86 = *(a6 - 1);
          v87 = (unsigned int)a2;
          do
          {
            v88 = v83;
            v89 = v84;
            v83 = v84;
            v84 = v85;
            v85 = v86;
            v90 = *result++;
            v86 = v90 + ((v88 * v80 + v89 * v79 + v84 * v82 + v86 * v81) >> a5);
            --v87;
            *a6++ = v86;
          }
          while ( v87 );
        }
      }
      else if ( (int)a2 >= 1 )
      {
        v180 = a3[1];
        v179 = a3[2];
        v181 = *a3;
        v182 = *(a6 - 3);
        v183 = *(a6 - 2);
        v184 = *(a6 - 1);
        v185 = (unsigned int)a2;
        do
        {
          v186 = v182;
          v187 = v183;
          v182 = v183;
          v183 = v184;
          v188 = *result++;
          v184 = v188 + ((v186 * v179 + v187 * v180 + v184 * v181) >> a5);
          --v185;
          *a6++ = v184;
        }
        while ( v185 );
      }
    }
    else if ( a4 < 7 )
    {
      if ( a4 == 6 )
      {
        if ( (int)a2 >= 1 )
        {
          v116 = a3[4];
          v117 = a3[5];
          v118 = a3[2];
          v119 = a3[3];
          v120 = *a3;
          v121 = a3[1];
          v122 = *(a6 - 6);
          v123 = *(a6 - 5);
          v124 = *(a6 - 4);
          v125 = *(a6 - 3);
          v127 = *(a6 - 2);
          v126 = *(a6 - 1);
          v129 = (unsigned int)a2;
          do
          {
            v130 = v122;
            v131 = v123;
            v122 = v123;
            v123 = v124;
            v124 = v125;
            v125 = v127;
            v127 = v126;
            v132 = *result++;
            v126 = v132 + ((v130 * v117 + v131 * v116 + v123 * v119 + v124 * v118 + v125 * v121 + v126 * v120) >> a5);
            --v129;
            *a6++ = v126;
          }
          while ( v129 );
        }
      }
      else if ( (int)a2 >= 1 )
      {
        v190 = a3[3];
        v189 = a3[4];
        v192 = a3[1];
        v191 = a3[2];
        v193 = *a3;
        v195 = *(a6 - 5);
        v194 = *(a6 - 4);
        v196 = *(a6 - 3);
        v197 = *(a6 - 2);
        v198 = *(a6 - 1);
        v199 = (unsigned int)a2;
        do
        {
          v200 = v195;
          v201 = v194;
          v195 = v194;
          v194 = v196;
          v196 = v197;
          v197 = v198;
          v202 = *result++;
          v198 = v202 + ((v200 * v189 + v201 * v190 + v194 * v191 + v196 * v192 + v198 * v193) >> a5);
          --v199;
          *a6++ = v198;
        }
        while ( v199 );
      }
    }
    else if ( a4 == 8 )
    {
      if ( (int)a2 >= 1 )
      {
        v37 = a3[6];
        v38 = a3[7];
        v39 = a3[4];
        v40 = a3[5];
        v41 = a3[2];
        v42 = a3[3];
        v43 = *a3;
        v44 = a3[1];
        v45 = *(a6 - 8);
        v46 = *(a6 - 7);
        v47 = *(a6 - 6);
        v48 = *(a6 - 5);
        v50 = *(a6 - 4);
        v49 = *(a6 - 3);
        v51 = *(a6 - 2);
        v52 = *(a6 - 1);
        a2 = (unsigned int)a2;
        do
        {
          v53 = v45;
          v54 = v46;
          v45 = v46;
          v46 = v47;
          v47 = v48;
          v48 = v50;
          v50 = v49;
          v49 = v51;
          v51 = v52;
          v55 = *result++;
          v52 = v55
              + ((v53 * v38 + v54 * v37 + v46 * v40 + v47 * v39 + v48 * v42 + v50 * v41 + v49 * v44 + v52 * v43) >> a5);
          --a2;
          *a6++ = v52;
        }
        while ( a2 );
      }
    }
    else if ( (int)a2 >= 1 )
    {
      v162 = a3[5];
      v161 = a3[6];
      v164 = a3[3];
      v163 = a3[4];
      v166 = a3[1];
      v165 = a3[2];
      v167 = *a3;
      v168 = *(a6 - 7);
      v169 = *(a6 - 6);
      v170 = *(a6 - 5);
      v171 = *(a6 - 4);
      v172 = *(a6 - 3);
      v173 = *(a6 - 2);
      v174 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v176 = v168;
        v177 = v169;
        v168 = v169;
        v169 = v170;
        v170 = v171;
        v171 = v172;
        v172 = v173;
        v173 = v174;
        v178 = *result++;
        v174 = v178
             + ((v176 * v161 + v177 * v162 + v169 * v163 + v170 * v164 + v171 * v165 + v172 * v166 + v174 * v167) >> a5);
        --a2;
        *a6++ = v174;
      }
      while ( a2 );
    }
  }
  else if ( a4 < 0xB )
  {
    if ( a4 == 10 )
    {
      if ( (int)a2 >= 1 )
      {
        v56 = a3[8];
        v57 = a3[9];
        v58 = a3[6];
        v59 = a3[7];
        v60 = a3[4];
        v61 = a3[5];
        v62 = a3[2];
        v63 = a3[3];
        v64 = *a3;
        v65 = a3[1];
        v66 = *(a6 - 10);
        v67 = *(a6 - 9);
        v69 = *(a6 - 8);
        v68 = *(a6 - 7);
        v70 = *(a6 - 6);
        v71 = *(a6 - 5);
        v72 = *(a6 - 4);
        v73 = *(a6 - 3);
        v74 = *(a6 - 2);
        v75 = *(a6 - 1);
        a2 = (unsigned int)a2;
        do
        {
          v76 = v66;
          v77 = v67;
          v66 = v67;
          v67 = v69;
          v69 = v68;
          v68 = v70;
          v70 = v71;
          v71 = v72;
          v72 = v73;
          v73 = v74;
          v74 = v75;
          v78 = *result++;
          v75 = v78
              + ((v76 * v57
                + v77 * v56
                + v67 * v59
                + v69 * v58
                + v68 * v61
                + v70 * v60
                + v71 * v63
                + v72 * v62
                + v73 * v65
                + v75 * v64) >> a5);
          --a2;
          *a6++ = v75;
        }
        while ( a2 );
      }
    }
    else if ( (int)a2 >= 1 )
    {
      v134 = a3[7];
      v133 = a3[8];
      v136 = a3[5];
      v135 = a3[6];
      v138 = a3[3];
      v137 = a3[4];
      v140 = a3[1];
      v139 = a3[2];
      v141 = *a3;
      v142 = *(a6 - 9);
      v143 = *(a6 - 8);
      v144 = *(a6 - 7);
      v145 = *(a6 - 6);
      v146 = *(a6 - 5);
      v147 = *(a6 - 4);
      v148 = *(a6 - 3);
      v149 = *(a6 - 2);
      v150 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v151 = v142;
        v152 = v143;
        v142 = v143;
        v143 = v144;
        v144 = v145;
        v145 = v146;
        v146 = v147;
        v147 = v148;
        v148 = v149;
        v149 = v150;
        v153 = *result++;
        v150 = v153
             + ((v151 * v133
               + v152 * v134
               + v143 * v135
               + v144 * v136
               + v145 * v137
               + v146 * v138
               + v147 * v139
               + v148 * v140
               + v150 * v141) >> a5);
        --a2;
        *a6++ = v150;
      }
      while ( a2 );
    }
  }
  else if ( a4 == 12 )
  {
    if ( (int)a2 >= 1 )
    {
      v6 = a3[10];
      v7 = a3[11];
      v8 = a3[8];
      v9 = a3[9];
      v10 = a3[6];
      v11 = a3[7];
      v12 = a3[4];
      v13 = a3[5];
      v14 = a3[2];
      v15 = a3[3];
      v17 = *a3;
      v16 = a3[1];
      v18 = *(a6 - 12);
      v19 = *(a6 - 11);
      v20 = *(a6 - 10);
      v21 = *(a6 - 9);
      v22 = *(a6 - 8);
      v23 = *(a6 - 7);
      v24 = *(a6 - 6);
      v25 = *(a6 - 5);
      v26 = *(a6 - 4);
      v27 = *(a6 - 3);
      v28 = *(a6 - 2);
      v29 = *(a6 - 1);
      a2 = (unsigned int)a2;
      do
      {
        v30 = v18;
        v31 = v19;
        v18 = v19;
        v19 = v20;
        v20 = v21;
        v21 = v22;
        v22 = v23;
        v23 = v24;
        v24 = v25;
        v25 = v26;
        v26 = v27;
        v27 = v28;
        v28 = v29;
        v32 = *result++;
        v29 = v32
            + ((v30 * v7
              + v31 * v6
              + v19 * v9
              + v20 * v8
              + v21 * v11
              + v22 * v10
              + v23 * v13
              + v24 * v12
              + v25 * v15
              + v26 * v14
              + v27 * v16
              + v29 * v17) >> a5);
        --a2;
        *a6++ = v29;
      }
      while ( a2 );
    }
  }
  else if ( (int)a2 >= 1 )
  {
    v92 = a3[9];
    v91 = a3[10];
    v94 = a3[7];
    v93 = a3[8];
    v96 = a3[5];
    v95 = a3[6];
    v98 = a3[3];
    v97 = a3[4];
    v100 = a3[1];
    v99 = a3[2];
    v101 = *a3;
    v102 = *(a6 - 11);
    v103 = *(a6 - 10);
    v104 = *(a6 - 9);
    v105 = *(a6 - 8);
    v106 = *(a6 - 7);
    v107 = *(a6 - 6);
    v108 = *(a6 - 5);
    v109 = *(a6 - 4);
    v110 = *(a6 - 3);
    v111 = *(a6 - 2);
    v112 = *(a6 - 1);
    a2 = (unsigned int)a2;
    do
    {
      v113 = v102;
      v114 = v103;
      v102 = v103;
      v103 = v104;
      v104 = v105;
      v105 = v106;
      v106 = v107;
      v107 = v108;
      v108 = v109;
      v109 = v110;
      v110 = v111;
      v111 = v112;
      v115 = *result++;
      v112 = v115
           + ((v113 * v91
             + v114 * v92
             + v103 * v93
             + v104 * v94
             + v105 * v95
             + v106 * v96
             + v107 * v97
             + v108 * v98
             + v109 * v99
             + v110 * v100
             + v112 * v101) >> a5);
      --a2;
      *a6++ = v112;
    }
    while ( a2 );
  }
  return result;
}

//----- (000000000001D540) ----------------------------------------------------
long double __fastcall FLAC__MD5Init(__int64 a1)
{
  long double result; // q0

  result = *(long double *)&xmmword_61BF0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = xmmword_61BF0;
  return result;
}
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];
// 61BF0: using guessed type __int128 xmmword_61BF0;

//----- (000000000001D558) ----------------------------------------------------
void *__fastcall FLAC__MD5Final(_OWORD *a1, __int64 a2)
{
  _BYTE *v4; // x0
  int v5; // w8
  void *v6; // x0
  _DWORD *v7; // x21
  size_t v8; // x2
  void *v9; // x0

  v4 = (_BYTE *)(a2 + (*(_DWORD *)(a2 + 80) & 0x3F));
  v5 = 55 - (*(_DWORD *)(a2 + 80) & 0x3F);
  *v4 = 0x80;
  v6 = v4 + 1;
  if ( v5 < 0 )
  {
    memset(v6, 0, v5 + 8);
    v7 = (_DWORD *)(a2 + 64);
    sub_1D620((_DWORD *)(a2 + 64), (int *)a2);
    v8 = 56;
    v6 = (void *)a2;
  }
  else
  {
    v7 = (_DWORD *)(a2 + 64);
    v8 = v5;
  }
  memset(v6, 0, v8);
  *(_QWORD *)(a2 + 56) = 8LL * *(_QWORD *)(a2 + 80);
  sub_1D620(v7, (int *)a2);
  *a1 = *(_OWORD *)v7;
  v9 = *(void **)(a2 + 88);
  if ( v9 )
  {
    free(v9);
    *(_QWORD *)(a2 + 88) = 0;
    *(_QWORD *)(a2 + 96) = 0;
  }
  return memset((void *)a2, 0, 0x68u);
}

//----- (000000000001D620) ----------------------------------------------------
_DWORD *__fastcall sub_1D620(_DWORD *result, int *a2)
{
  int v2; // w9
  int v3; // w10
  int v4; // w8
  int v5; // w3
  int v6; // w13
  unsigned __int64 v7; // t2
  int v8; // w2
  int v9; // w12
  int v10; // w17
  int v11; // w5
  int v12; // w6
  int v13; // w4
  int v14; // w14
  int v15; // w19
  int v16; // w27
  int v17; // w7
  int v18; // w15
  int v19; // w20
  int v20; // w5
  int v21; // w16
  int v22; // w18
  int v23; // w22
  int v24; // w27
  int v25; // w24
  int v26; // w2
  int v27; // w6
  int v28; // w23
  int v29; // w26
  int v30; // w27
  int v31; // w5
  int v32; // w19
  int v33; // w26
  int v34; // w22
  int v35; // w1
  int v36; // w20
  int v37; // w21
  int v38; // w23
  int v39; // w24
  int v40; // w22
  int v41; // w21
  int v42; // w23
  int v43; // w24
  int v44; // w22
  int v45; // w21
  int v46; // w23
  int v47; // w24
  int v48; // w22
  int v49; // w21
  int v50; // w23
  int v51; // w24
  int v52; // w22
  int v53; // w21
  int v54; // w23
  int v55; // w24
  int v56; // w22
  int v57; // w21
  int v58; // w23
  int v59; // w24
  int v60; // w22
  int v61; // w21
  int v62; // w23
  int v63; // w24
  int v64; // w22
  int v65; // w21
  int v66; // w23
  int v67; // w24
  int v68; // w22
  int v69; // w21
  int v70; // w3
  int v71; // w23
  int v72; // w22
  int v73; // w27
  int v74; // w20
  int v75; // w23
  int v76; // w20
  int v77; // w21
  int v78; // w19
  int v79; // w17
  int v80; // w3
  int v81; // w13
  int v82; // w1
  int v83; // w17
  int v84; // w18
  int v85; // w4
  int v86; // w13
  int v87; // w15
  int v88; // w14
  int v89; // w12
  int v90; // w13
  int v91; // w12

  v2 = result[2];
  v3 = result[3];
  v4 = result[1];
  v5 = *a2;
  v6 = a2[1];
  HIDWORD(v7) = *result + *a2 + ((v3 ^ v2) & v4 ^ v3) - 680876936;
  LODWORD(v7) = HIDWORD(v7);
  v8 = (v7 >> 25) + v4;
  v9 = a2[2];
  v10 = a2[3];
  HIDWORD(v7) = v3 + v6 + (v8 & (v2 ^ v4) ^ v2) - 389564586;
  LODWORD(v7) = HIDWORD(v7);
  v11 = (v7 >> 20) + v8;
  HIDWORD(v7) = v2 + v9 + (v11 & (v8 ^ v4) ^ v4) + 606105819;
  LODWORD(v7) = HIDWORD(v7);
  v12 = (v7 >> 15) + v11;
  v14 = a2[4];
  v13 = a2[5];
  HIDWORD(v7) = v4 + v10 + (v12 & (v11 ^ v8) ^ v8) - 1044525330;
  LODWORD(v7) = HIDWORD(v7);
  v15 = (v7 >> 10) + v12;
  HIDWORD(v7) = v14 + v8 + (v15 & (v12 ^ v11) ^ v11) - 176418897;
  LODWORD(v7) = HIDWORD(v7);
  v16 = (v7 >> 25) + v15;
  v18 = a2[6];
  v17 = a2[7];
  HIDWORD(v7) = v13 + v11 + (v16 & (v15 ^ v12) ^ v12) + 1200080426;
  LODWORD(v7) = HIDWORD(v7);
  v19 = (v7 >> 20) + v16;
  HIDWORD(v7) = v18 + v12 + (v19 & (v16 ^ v15) ^ v15) - 1473231341;
  LODWORD(v7) = HIDWORD(v7);
  v20 = (v7 >> 15) + v19;
  v22 = a2[8];
  v21 = a2[9];
  HIDWORD(v7) = v17 + v15 + (v20 & (v19 ^ v16) ^ v16) - 45705983;
  LODWORD(v7) = HIDWORD(v7);
  v23 = v22 + v16;
  v24 = (v7 >> 10) + v20;
  HIDWORD(v7) = v23 + (v24 & (v20 ^ v19) ^ v19) + 1770035416;
  LODWORD(v7) = HIDWORD(v7);
  v25 = (v7 >> 25) + v24;
  v27 = a2[10];
  v26 = a2[11];
  HIDWORD(v7) = v21 + v19 + (v25 & (v24 ^ v20) ^ v20) - 1958414417;
  LODWORD(v7) = HIDWORD(v7);
  v28 = (v7 >> 20) + v25;
  HIDWORD(v7) = v27 + v20 + (v28 & (v25 ^ v24) ^ v24) - 42063;
  LODWORD(v7) = HIDWORD(v7);
  v29 = v26 + v24;
  v30 = (v7 >> 15) + v28;
  v32 = a2[12];
  v31 = a2[13];
  HIDWORD(v7) = v29 + (v30 & (v28 ^ v25) ^ v25) - 1990404162;
  LODWORD(v7) = HIDWORD(v7);
  v33 = (v7 >> 10) + v30;
  HIDWORD(v7) = v32 + v25 + (v33 & (v30 ^ v28) ^ v28) + 1804603682;
  LODWORD(v7) = HIDWORD(v7);
  v34 = (v7 >> 25) + v33;
  v36 = a2[14];
  v35 = a2[15];
  HIDWORD(v7) = v31 + v28 + (v34 & (v33 ^ v30) ^ v30) - 40341101;
  LODWORD(v7) = HIDWORD(v7);
  v37 = (v7 >> 20) + v34;
  HIDWORD(v7) = v36 + v30 + (v37 & (v34 ^ v33) ^ v33) - 1502002290;
  LODWORD(v7) = HIDWORD(v7);
  v38 = (v7 >> 15) + v37;
  HIDWORD(v7) = v35 + v33 + (v38 & (v37 ^ v34) ^ v34) + 1236535329;
  LODWORD(v7) = HIDWORD(v7);
  v39 = (v7 >> 10) + v38;
  HIDWORD(v7) = v6 + v34 + ((v39 ^ v38) & v37 ^ v38) - 165796510;
  LODWORD(v7) = HIDWORD(v7);
  v40 = (v7 >> 27) + v39;
  HIDWORD(v7) = v18 + v37 + ((v40 ^ v39) & v38 ^ v39) - 1069501632;
  LODWORD(v7) = HIDWORD(v7);
  v41 = (v7 >> 23) + v40;
  HIDWORD(v7) = v26 + v38 + ((v41 ^ v40) & v39 ^ v40) + 643717713;
  LODWORD(v7) = HIDWORD(v7);
  v42 = (v7 >> 18) + v41;
  HIDWORD(v7) = v5 + v39 + ((v42 ^ v41) & v40 ^ v41) - 373897302;
  LODWORD(v7) = HIDWORD(v7);
  v43 = (v7 >> 12) + v42;
  HIDWORD(v7) = v13 + v40 + ((v43 ^ v42) & v41 ^ v42) - 701558691;
  LODWORD(v7) = HIDWORD(v7);
  v44 = (v7 >> 27) + v43;
  HIDWORD(v7) = v27 + v41 + ((v44 ^ v43) & v42 ^ v43) + 38016083;
  LODWORD(v7) = HIDWORD(v7);
  v45 = (v7 >> 23) + v44;
  HIDWORD(v7) = v35 + v42 + ((v45 ^ v44) & v43 ^ v44) - 660478335;
  LODWORD(v7) = HIDWORD(v7);
  v46 = (v7 >> 18) + v45;
  HIDWORD(v7) = v14 + v43 + ((v46 ^ v45) & v44 ^ v45) - 405537848;
  LODWORD(v7) = HIDWORD(v7);
  v47 = (v7 >> 12) + v46;
  HIDWORD(v7) = v21 + v44 + ((v47 ^ v46) & v45 ^ v46) + 568446438;
  LODWORD(v7) = HIDWORD(v7);
  v48 = (v7 >> 27) + v47;
  HIDWORD(v7) = v36 + v45 + ((v48 ^ v47) & v46 ^ v47) - 1019803690;
  LODWORD(v7) = HIDWORD(v7);
  v49 = (v7 >> 23) + v48;
  HIDWORD(v7) = v10 + v46 + ((v49 ^ v48) & v47 ^ v48) - 187363961;
  LODWORD(v7) = HIDWORD(v7);
  v50 = (v7 >> 18) + v49;
  HIDWORD(v7) = v22 + v47 + ((v50 ^ v49) & v48 ^ v49) + 1163531501;
  LODWORD(v7) = HIDWORD(v7);
  v51 = (v7 >> 12) + v50;
  HIDWORD(v7) = v31 + v48 + ((v51 ^ v50) & v49 ^ v50) - 1444681467;
  LODWORD(v7) = HIDWORD(v7);
  v52 = (v7 >> 27) + v51;
  HIDWORD(v7) = v9 + v49 + ((v52 ^ v51) & v50 ^ v51) - 51403784;
  LODWORD(v7) = HIDWORD(v7);
  v53 = (v7 >> 23) + v52;
  HIDWORD(v7) = v17 + v50 + ((v53 ^ v52) & v51 ^ v52) + 1735328473;
  LODWORD(v7) = HIDWORD(v7);
  v54 = (v7 >> 18) + v53;
  HIDWORD(v7) = v32 + v51 + ((v54 ^ v53) & v52 ^ v53) - 1926607734;
  LODWORD(v7) = HIDWORD(v7);
  v55 = (v7 >> 12) + v54;
  HIDWORD(v7) = v13 + v52 + (v54 ^ v53 ^ v55) - 378558;
  LODWORD(v7) = HIDWORD(v7);
  v56 = (v7 >> 28) + v55;
  HIDWORD(v7) = v22 + v53 + (v55 ^ v54 ^ v56) - 2022574463;
  LODWORD(v7) = HIDWORD(v7);
  v57 = (v7 >> 21) + v56;
  HIDWORD(v7) = v26 + v54 + (v56 ^ v55 ^ v57) + 1839030562;
  LODWORD(v7) = HIDWORD(v7);
  v58 = (v7 >> 16) + v57;
  HIDWORD(v7) = v36 + v55 + (v57 ^ v56 ^ v58) - 35309556;
  LODWORD(v7) = HIDWORD(v7);
  v59 = (v7 >> 9) + v58;
  HIDWORD(v7) = v6 + v56 + (v58 ^ v57 ^ v59) - 1530992060;
  LODWORD(v7) = HIDWORD(v7);
  v60 = (v7 >> 28) + v59;
  HIDWORD(v7) = v14 + v57 + (v59 ^ v58 ^ v60) + 1272893353;
  LODWORD(v7) = HIDWORD(v7);
  v61 = (v7 >> 21) + v60;
  HIDWORD(v7) = v17 + v58 + (v60 ^ v59 ^ v61) - 155497632;
  LODWORD(v7) = HIDWORD(v7);
  v62 = (v7 >> 16) + v61;
  HIDWORD(v7) = v27 + v59 + (v61 ^ v60 ^ v62) - 1094730640;
  LODWORD(v7) = HIDWORD(v7);
  v63 = (v7 >> 9) + v62;
  HIDWORD(v7) = v31 + v60 + (v62 ^ v61 ^ v63) + 681279174;
  LODWORD(v7) = HIDWORD(v7);
  v64 = (v7 >> 28) + v63;
  HIDWORD(v7) = v5 + v61 + (v63 ^ v62 ^ v64) - 358537222;
  LODWORD(v7) = HIDWORD(v7);
  v65 = (v7 >> 21) + v64;
  HIDWORD(v7) = v10 + v62 + (v64 ^ v63 ^ v65) - 722521979;
  LODWORD(v7) = HIDWORD(v7);
  v66 = (v7 >> 16) + v65;
  HIDWORD(v7) = v18 + v63 + (v65 ^ v64 ^ v66) + 76029189;
  LODWORD(v7) = HIDWORD(v7);
  v67 = (v7 >> 9) + v66;
  HIDWORD(v7) = v21 + v64 + (v66 ^ v65 ^ v67) - 640364487;
  LODWORD(v7) = HIDWORD(v7);
  v68 = (v7 >> 28) + v67;
  HIDWORD(v7) = v32 + v65 + (v67 ^ v66 ^ v68) - 421815835;
  LODWORD(v7) = HIDWORD(v7);
  v69 = (v7 >> 21) + v68;
  HIDWORD(v7) = v35 + v66 + (v68 ^ v67 ^ v69) + 530742520;
  LODWORD(v7) = HIDWORD(v7);
  v70 = v5 + v68;
  v71 = (v7 >> 16) + v69;
  HIDWORD(v7) = v9 + v67 + (v69 ^ v68 ^ v71) - 995338651;
  LODWORD(v7) = HIDWORD(v7);
  v72 = (v7 >> 9) + v71;
  HIDWORD(v7) = v70 + ((v72 | ~v69) ^ v71) - 198630844;
  LODWORD(v7) = HIDWORD(v7);
  v73 = (v7 >> 26) + v72;
  v74 = v36 + v71;
  HIDWORD(v7) = v17 + v69 + ((v73 | ~v71) ^ v72) + 1126891415;
  LODWORD(v7) = HIDWORD(v7);
  v75 = (v7 >> 22) + v73;
  HIDWORD(v7) = v74 + ((v75 | ~v72) ^ v73) - 1416354905;
  LODWORD(v7) = HIDWORD(v7);
  v76 = (v7 >> 17) + v75;
  HIDWORD(v7) = v13 + v72 + ((v76 | ~v73) ^ v75) - 57434055;
  LODWORD(v7) = HIDWORD(v7);
  v77 = (v7 >> 11) + v76;
  HIDWORD(v7) = v32 + v73 + ((v77 | ~v75) ^ v76) + 1700485571;
  LODWORD(v7) = HIDWORD(v7);
  v78 = (v7 >> 26) + v77;
  HIDWORD(v7) = v10 + v75 + ((v78 | ~v76) ^ v77) - 1894986606;
  LODWORD(v7) = HIDWORD(v7);
  v79 = (v7 >> 22) + v78;
  HIDWORD(v7) = v27 + v76 + ((v79 | ~v77) ^ v78) - 1051523;
  LODWORD(v7) = HIDWORD(v7);
  v80 = (v7 >> 17) + v79;
  HIDWORD(v7) = v6 + v77 + ((v80 | ~v78) ^ v79) - 2054922799;
  LODWORD(v7) = HIDWORD(v7);
  v81 = (v7 >> 11) + v80;
  v82 = v35 + v79;
  HIDWORD(v7) = v22 + v78 + ((v81 | ~v79) ^ v80) + 1873313359;
  LODWORD(v7) = HIDWORD(v7);
  v83 = (v7 >> 26) + v81;
  HIDWORD(v7) = v82 + ((v83 | ~v80) ^ v81) - 30611744;
  LODWORD(v7) = HIDWORD(v7);
  v84 = (v7 >> 22) + v83;
  v85 = v31 + v81;
  HIDWORD(v7) = v18 + v80 + ((v84 | ~v81) ^ v83) - 1560198380;
  LODWORD(v7) = HIDWORD(v7);
  v86 = (v7 >> 17) + v84;
  HIDWORD(v7) = v85 + ((v86 | ~v83) ^ v84) + 1309151649;
  LODWORD(v7) = HIDWORD(v7);
  v87 = (v7 >> 11) + v86;
  HIDWORD(v7) = v14 + v83 + ((v87 | ~v84) ^ v86) - 145523070;
  LODWORD(v7) = HIDWORD(v7);
  v88 = (v7 >> 26) + v87;
  v89 = v9 + v86;
  HIDWORD(v7) = v26 + v84 + ((v88 | ~v86) ^ v87) - 1120210379;
  LODWORD(v7) = HIDWORD(v7);
  v90 = (v7 >> 22) + v88;
  HIDWORD(v7) = v89 + ((v90 | ~v87) ^ v88) + 718787259;
  LODWORD(v7) = HIDWORD(v7);
  v91 = (v7 >> 17) + v90;
  HIDWORD(v7) = v21 + v87 + ((v91 | ~v88) ^ v90) - 343485551;
  LODWORD(v7) = HIDWORD(v7);
  *result += v88;
  result[1] = v91 + v4 + (v7 >> 11);
  result[2] = v91 + v2;
  result[3] = v90 + v3;
  return result;
}

//----- (000000000001E004) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_BYTE *__fastcall FLAC__MD5Accumulate(__int64 a1, int32x4_t **a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  __int64 v7; // x27
  __int64 v11; // x26
  _BYTE *result; // x0
  _BYTE *v13; // x21
  size_t v14; // x20
  _BYTE *v15; // x0
  int v16; // w8
  int32x4_t *v17; // x8
  __int64 v18; // x9
  unsigned __int64 v19; // x8
  __int64 v20; // x9
  __int64 v21; // x10
  int *v22; // x8
  int v23; // t1
  __int64 v24; // x8
  __int64 v25; // x8
  __int64 v26; // x10
  __int32 v27; // w9
  __int32 v28; // w9
  float32x4_t *v29; // x8
  float32x4_t *v30; // x9
  unsigned __int64 v31; // x10
  float32x4_t *v32; // x8
  float32x4_t *v33; // x9
  float32x4_t *v34; // x10
  float32x4_t *v35; // x11
  unsigned __int64 v36; // x12
  int32x4_t *v37; // x8
  int32x4_t *v38; // x9
  int32x4_t *v39; // x10
  int32x4_t *v40; // x11
  int32x4_t *v41; // x12
  int32x4_t *v42; // x13
  unsigned __int32 v43; // t1
  unsigned __int32 v44; // t1
  unsigned __int32 v45; // t1
  unsigned __int32 v46; // t1
  unsigned __int32 v47; // t1
  unsigned __int32 v48; // t1
  int32x4_t *v49; // x8
  int32x4_t *v50; // x9
  int32x4_t *v51; // x10
  int32x4_t *v52; // x11
  int32x4_t *v53; // x12
  int32x4_t *v54; // x13
  int32x4_t *v55; // x14
  int32x4_t *v56; // x15
  unsigned __int32 v57; // t1
  unsigned __int32 v58; // t1
  unsigned __int32 v59; // t1
  unsigned __int32 v60; // t1
  unsigned __int32 v61; // t1
  unsigned __int32 v62; // t1
  unsigned __int32 v63; // t1
  unsigned __int32 v64; // t1
  __int64 v65; // x8
  __int64 v66; // x10
  __int64 v67; // x8
  _BYTE *v68; // x10
  __int32 v69; // w9
  __int64 v70; // x8
  __int64 v71; // x10
  __int64 v72; // x8
  __int64 v73; // x10
  int32x4_t *v74; // x8
  int32x4_t *v75; // x9
  unsigned __int64 v76; // x10
  int32x4_t *v77; // x9
  int32x4_t *v78; // x10
  int32x4_t *v79; // x11
  int32x4_t *v80; // x12
  unsigned __int64 v81; // x13
  _WORD *v82; // x8
  int32x4_t *v83; // x8
  int32x4_t *v84; // x9
  int32x4_t *v85; // x10
  int32x4_t *v86; // x11
  int32x4_t *v87; // x12
  int32x4_t *v88; // x13
  unsigned __int32 v89; // t1
  unsigned __int32 v90; // t1
  unsigned __int32 v91; // t1
  unsigned __int32 v92; // t1
  unsigned __int32 v93; // t1
  unsigned __int32 v94; // t1
  int32x4_t *v95; // x8
  int32x4_t *v96; // x9
  int32x4_t *v97; // x10
  int32x4_t *v98; // x11
  int32x4_t *v99; // x12
  int32x4_t *v100; // x13
  int32x4_t *v101; // x14
  int32x4_t *v102; // x15
  unsigned __int32 v103; // t1
  unsigned __int32 v104; // t1
  unsigned __int32 v105; // t1
  unsigned __int32 v106; // t1
  unsigned __int32 v107; // t1
  unsigned __int32 v108; // t1
  unsigned __int32 v109; // t1
  unsigned __int32 v110; // t1
  __int64 v111; // x8
  __int64 v112; // x10
  __int64 v113; // x8
  __int32 v114; // w9
  float32x4_t *v115; // x12
  bool v116; // w13
  bool v117; // w12
  float *v118; // x12
  float32x4_t *v119; // x13
  float32x4_t *v120; // x14
  unsigned __int64 v121; // x15
  float *v122; // x16
  unsigned __int64 v123; // x11
  __int64 v124; // x10
  float32x4_t *v125; // x9
  float32x4_t *v126; // x8
  unsigned __int32 v127; // t1
  unsigned __int32 v128; // t1
  float32x4_t *v129; // x18
  bool v130; // w1
  bool v131; // w15
  bool v132; // w17
  bool v133; // w18
  float *v134; // x14
  float32x4_t *v135; // x15
  float32x4_t *v136; // x16
  float32x4_t *v137; // x17
  float32x4_t *v138; // x18
  unsigned __int64 v139; // x0
  float *v140; // x1
  unsigned __int64 v141; // x13
  __int64 v142; // x12
  float32x4_t *v143; // x11
  float32x4_t *v144; // x10
  float32x4_t *v145; // x9
  float32x4_t *v146; // x8
  unsigned __int32 v147; // t1
  unsigned __int32 v148; // t1
  unsigned __int32 v149; // t1
  unsigned __int32 v150; // t1
  int16x4_t *v151; // x10
  int32x4_t *v152; // x11
  __int64 v153; // x12
  int32x4_t v154; // q0
  int32x4_t v155; // q1
  __int64 v156; // x10
  int *v157; // x8
  int v158; // t1
  __int16 *v159; // x12
  int32x4_t *v160; // x13
  int32x4_t *v161; // x14
  unsigned __int64 v162; // x15
  int32x4_t v163; // q0 OVERLAPPED
  int32x4_t v164; // q1
  __int16 *v165; // x16
  unsigned __int64 v166; // x11
  __int64 v167; // x10
  int32x4_t *v168; // x9
  int32x4_t *v169; // x8
  unsigned __int32 v170; // t1
  unsigned __int32 v171; // t1
  unsigned __int64 v172; // x15
  int32x4_t *v173; // x16
  int32x4_t *v174; // x17
  int32x4_t *v175; // x18
  int32x4_t *v176; // x0
  int32x4_t v177; // t1
  int32x4_t v178; // q0
  int32x4_t v179; // t1
  int32x4_t v180; // q1
  int32x4_t v181; // t1
  int32x4_t v182; // q2
  int32x4_t v183; // t1
  unsigned __int64 v184; // x14
  __int64 v185; // x13
  int *v186; // x12
  int *v187; // x11
  int *v188; // x10
  int32x4_t *v189; // x9
  unsigned __int32 v190; // t1
  int v191; // t1
  int v192; // t1
  int v193; // t1
  int v194; // w8
  char *v195; // x21
  int v196; // w26
  __int64 v197; // x24
  void *v198; // x0
  size_t v199; // x2
  char *v200; // x1
  unsigned int v201; // w25
  char *v202; // x22
  int v203; // w20
  __int64 v204; // x24
  __int128 v205; // t1
  __int64 v206; // x8
  __int64 v207; // x9
  __int64 v208; // x14
  _WORD *v209; // x12
  __int64 v210; // x13
  int32x4_t **v211; // x14
  _WORD *v212; // x16
  int v213; // w15
  __int64 v214; // x13
  int32x4_t **v215; // x14
  __int64 v216; // t1
  __int64 v217; // x8
  __int64 v218; // x10
  int32x4_t **v219; // x11
  __int64 v220; // x12
  __int64 v221; // t1
  _BYTE *v222; // x14
  int v223; // w13
  __int64 v224; // x8
  __int64 v225; // x10
  _OWORD *v226; // x10
  __int128 *v227; // x11
  __int64 v228; // x12
  __int128 v229; // q0
  __int128 v230; // q1
  int16x4x2_t v231; // 0:d4.8,8:d5.8
  float32x4x2_t v232; // 0:q0.16,16:q1.16
  float32x4x2_t v233; // 0:q2.16,16:q3.16
  int16x4x4_t v234; // 0:d4.8,8:d5.8,16:d6.8,24:d7.8
  float32x4x4_t v235; // 0:q0.16,16:q1.16,32:q2.16,48:q3.16
  float32x4x4_t v236; // 0:q4.16,16:q5.16,32:q6.16,48:q7.16

  v7 = a3;
  if ( 0xFFFFFFFFFFFFFFFFLL / a5 < a3 )
    return 0;
  v11 = a4;
  if ( a5 * (unsigned __int64)a3 > 0xFFFFFFFFFFFFFFFFLL / a4 )
    return 0;
  v13 = *(_BYTE **)(a1 + 88);
  v14 = a4 * (unsigned __int64)a3 * a5;
  if ( *(_QWORD *)(a1 + 96) < v14 )
  {
    v15 = realloc(*(void **)(a1 + 88), a4 * (unsigned __int64)a3 * a5);
    if ( v15 )
    {
      v13 = v15;
      *(_QWORD *)(a1 + 88) = v15;
    }
    else
    {
      free(v13);
      result = malloc(v14);
      v13 = result;
      *(_QWORD *)(a1 + 88) = result;
      if ( !result )
      {
        *(_QWORD *)(a1 + 96) = 0;
        return result;
      }
    }
    *(_QWORD *)(a1 + 96) = v14;
  }
  v16 = a3 + 100 * a5;
  if ( v16 <= 300 )
  {
    switch ( v16 )
    {
      case 'e':
        if ( a4 )
        {
          v24 = 0;
          do
          {
            v13[v24] = (*a2)->n128_u32[v24];
            ++v24;
          }
          while ( a4 != v24 );
        }
        goto LABEL_127;
      case 'f':
        if ( a4 )
        {
          v65 = 0;
          do
          {
            v66 = v65++;
            *v13 = (*a2)->n128_u32[v66];
            v13[1] = a2[1]->n128_u32[v66];
            v13 += 2;
          }
          while ( a4 != v65 );
        }
        goto LABEL_127;
      case 'g':
      case 'i':
      case 'k':
        goto LABEL_80;
      case 'h':
        if ( a4 )
        {
          v67 = 0;
          do
          {
            v68 = &v13[v67 * 4];
            --v11;
            *v68 = (*a2)->n128_u32[v67];
            v68[1] = a2[1]->n128_u32[v67];
            v68[2] = a2[2]->n128_u32[v67];
            v69 = a2[3]->n128_i32[v67++];
            v68[3] = v69;
          }
          while ( v11 );
        }
        goto LABEL_127;
      case 'j':
        if ( a4 )
        {
          v70 = 0;
          do
          {
            v71 = v70++;
            *v13 = (*a2)->n128_u32[v71];
            v13[1] = a2[1]->n128_u32[v71];
            v13[2] = a2[2]->n128_u32[v71];
            v13[3] = a2[3]->n128_u32[v71];
            v13[4] = a2[4]->n128_u32[v71];
            v13[5] = a2[5]->n128_u32[v71];
            v13 += 6;
          }
          while ( a4 != v70 );
        }
        goto LABEL_127;
      case 'l':
        if ( a4 )
        {
          v72 = 0;
          do
          {
            v73 = v72++;
            *v13 = (*a2)->n128_u32[v73];
            v13[1] = a2[1]->n128_u32[v73];
            v13[2] = a2[2]->n128_u32[v73];
            v13[3] = a2[3]->n128_u32[v73];
            v13[4] = a2[4]->n128_u32[v73];
            v13[5] = a2[5]->n128_u32[v73];
            v13[6] = a2[6]->n128_u32[v73];
            v13[7] = a2[7]->n128_u32[v73];
            v13 += 8;
          }
          while ( a4 != v72 );
        }
        goto LABEL_127;
      default:
        switch ( v16 )
        {
          case 201:
            if ( !a4 )
              goto LABEL_127;
            v17 = *a2;
            if ( a4 < 8 )
            {
              v18 = 0;
LABEL_113:
              v156 = a4 - v18;
              v157 = (int *)v17 + v18;
              do
              {
                v158 = *v157++;
                --v156;
                *(_WORD *)v13 = v158;
                v13 += 2;
              }
              while ( v156 );
              goto LABEL_127;
            }
            v18 = (unsigned int)v11 & 0xFFFFFFF8;
            v151 = (int16x4_t *)(v13 + 8);
            v13 += 2 * v18;
            v152 = v17 + 1;
            v153 = v18;
            do
            {
              v154 = v152[-1];
              v155 = *v152;
              v153 -= 8;
              v152 += 2;
              v151[-1].n64_u64[0] = vmovn_s32(v154).n64_u64[0];
              v151->n64_u64[0] = vmovn_s32(v155).n64_u64[0];
              v151 += 2;
            }
            while ( v153 );
            if ( v18 != a4 )
              goto LABEL_113;
            goto LABEL_127;
          case 202:
            if ( !a4 )
              goto LABEL_127;
            v74 = *a2;
            v75 = a2[1];
            if ( a4 < 8 )
            {
              v76 = 0;
LABEL_119:
              v166 = a4 - v76;
              v167 = 4 * v76;
              v168 = (int32x4_t *)((char *)v75 + v167);
              v169 = (int32x4_t *)((char *)v74 + v167);
              do
              {
                v170 = v169->n128_u32[0];
                v169 = (int32x4_t *)((char *)v169 + 4);
                --v166;
                *(_WORD *)v13 = v170;
                v171 = v168->n128_u32[0];
                v168 = (int32x4_t *)((char *)v168 + 4);
                *((_WORD *)v13 + 1) = v171;
                v13 += 4;
              }
              while ( v166 );
              goto LABEL_127;
            }
            v76 = a4 - (unsigned __int64)(a4 & 7);
            v159 = (__int16 *)(v13 + 16);
            v160 = v74 + 1;
            v13 += 4 * v76;
            v161 = v75 + 1;
            v162 = v76;
            do
            {
              v163 = v160[-1];
              v164 = *v160;
              v165 = v159 - 8;
              v160 += 2;
              v231.val[0] = vmovn_s32(v163);
              v163.n128_u64[0] = vmovn_s32(v164).n64_u64[0];
              v231.val[1] = vmovn_s32(v161[-1]);
              v164.n128_u64[0] = vmovn_s32(*v161).n64_u64[0];
              v162 -= 8LL;
              vst2_s16(v165, v231);
              vst2_s16(v159, (int16x4x2_t)v163);
              v159 += 16;
              v161 += 2;
            }
            while ( v162 );
            if ( (v11 & 7) != 0 )
              goto LABEL_119;
            goto LABEL_127;
          case 204:
            if ( !a4 )
              goto LABEL_127;
            v77 = *a2;
            v78 = a2[1];
            v79 = a2[2];
            v80 = a2[3];
            if ( a4 < 4 )
            {
              v81 = 0;
              v82 = v13;
LABEL_125:
              v184 = a4 - v81;
              v185 = 4 * v81;
              v186 = (int *)((char *)v80 + v185);
              v187 = (int *)((char *)v79 + v185);
              v188 = (int *)((char *)v78 + v185);
              v189 = (int32x4_t *)((char *)v77 + v185);
              do
              {
                v190 = v189->n128_u32[0];
                v189 = (int32x4_t *)((char *)v189 + 4);
                --v184;
                *v82 = v190;
                v191 = *v188++;
                v82[1] = v191;
                v192 = *v187++;
                v82[2] = v192;
                v193 = *v186++;
                v82[3] = v193;
                v82 += 4;
              }
              while ( v184 );
              goto LABEL_127;
            }
            v81 = a4 - (unsigned __int64)(a4 & 3);
            v82 = &v13[8 * v81];
            v172 = v81;
            v173 = a2[3];
            v174 = a2[2];
            v175 = a2[1];
            v176 = *a2;
            do
            {
              v177 = *v176++;
              v178 = v177;
              v179 = *v175++;
              v180 = v179;
              v181 = *v174++;
              v182 = v181;
              v183 = *v173++;
              v234.val[0] = vmovn_s32(v178);
              v234.val[1] = vmovn_s32(v180);
              v234.val[2] = vmovn_s32(v182);
              v234.val[3] = vmovn_s32(v183);
              v172 -= 4LL;
              vst4_s16((__int16 *)v13, v234);
              v13 += 32;
            }
            while ( v172 );
            if ( (v11 & 3) != 0 )
              goto LABEL_125;
            break;
          case 206:
            if ( a4 )
            {
              v83 = *a2;
              v84 = a2[1];
              v85 = a2[2];
              v86 = a2[3];
              v87 = a2[4];
              v88 = a2[5];
              do
              {
                v89 = v83->n128_u32[0];
                v83 = (int32x4_t *)((char *)v83 + 4);
                --v11;
                *(_WORD *)v13 = v89;
                v90 = v84->n128_u32[0];
                v84 = (int32x4_t *)((char *)v84 + 4);
                *((_WORD *)v13 + 1) = v90;
                v91 = v85->n128_u32[0];
                v85 = (int32x4_t *)((char *)v85 + 4);
                *((_WORD *)v13 + 2) = v91;
                v92 = v86->n128_u32[0];
                v86 = (int32x4_t *)((char *)v86 + 4);
                *((_WORD *)v13 + 3) = v92;
                v93 = v87->n128_u32[0];
                v87 = (int32x4_t *)((char *)v87 + 4);
                *((_WORD *)v13 + 4) = v93;
                v94 = v88->n128_u32[0];
                v88 = (int32x4_t *)((char *)v88 + 4);
                *((_WORD *)v13 + 5) = v94;
                v13 += 12;
              }
              while ( v11 );
            }
            goto LABEL_127;
          case 208:
            if ( a4 )
            {
              v95 = *a2;
              v96 = a2[1];
              v97 = a2[2];
              v98 = a2[3];
              v99 = a2[4];
              v100 = a2[5];
              v101 = a2[6];
              v102 = a2[7];
              do
              {
                v103 = v95->n128_u32[0];
                v95 = (int32x4_t *)((char *)v95 + 4);
                --v11;
                *(_WORD *)v13 = v103;
                v104 = v96->n128_u32[0];
                v96 = (int32x4_t *)((char *)v96 + 4);
                *((_WORD *)v13 + 1) = v104;
                v105 = v97->n128_u32[0];
                v97 = (int32x4_t *)((char *)v97 + 4);
                *((_WORD *)v13 + 2) = v105;
                v106 = v98->n128_u32[0];
                v98 = (int32x4_t *)((char *)v98 + 4);
                *((_WORD *)v13 + 3) = v106;
                v107 = v99->n128_u32[0];
                v99 = (int32x4_t *)((char *)v99 + 4);
                *((_WORD *)v13 + 4) = v107;
                v108 = v100->n128_u32[0];
                v100 = (int32x4_t *)((char *)v100 + 4);
                *((_WORD *)v13 + 5) = v108;
                v109 = v101->n128_u32[0];
                v101 = (int32x4_t *)((char *)v101 + 4);
                *((_WORD *)v13 + 6) = v109;
                v110 = v102->n128_u32[0];
                v102 = (int32x4_t *)((char *)v102 + 4);
                *((_WORD *)v13 + 7) = v110;
                v13 += 16;
              }
              while ( v11 );
            }
            goto LABEL_127;
          default:
            goto LABEL_80;
        }
        break;
    }
    goto LABEL_127;
  }
  switch ( v16 )
  {
    case 401:
      if ( !a4 )
        goto LABEL_127;
      v19 = (unsigned __int64)*a2;
      if ( a4 < 8 || (unsigned __int64)v13 < v19 + 4LL * a4 && (unsigned __int64)&v13[4 * a4] > v19 )
      {
        v20 = 0;
LABEL_21:
        v21 = a4 - v20;
        v22 = (int *)(v19 + 4 * v20);
        do
        {
          v23 = *v22++;
          --v21;
          *(_DWORD *)v13 = v23;
          v13 += 4;
        }
        while ( v21 );
        goto LABEL_127;
      }
      v20 = (unsigned int)v11 & 0xFFFFFFF8;
      v226 = v13 + 16;
      v13 += 4 * v20;
      v227 = (__int128 *)(v19 + 16);
      v228 = v20;
      do
      {
        v229 = *(v227 - 1);
        v230 = *v227;
        v228 -= 8;
        v227 += 2;
        *(v226 - 1) = v229;
        *v226 = v230;
        v226 += 2;
      }
      while ( v228 );
      if ( v20 != a4 )
        goto LABEL_21;
      goto LABEL_127;
    case 402:
      if ( !a4 )
        goto LABEL_127;
      v29 = *a2;
      v30 = a2[1];
      if ( a4 < 8 )
      {
        v31 = 0;
LABEL_97:
        v123 = a4 - v31;
        v124 = 4 * v31;
        v125 = (float32x4_t *)((char *)v30 + v124);
        v126 = (float32x4_t *)((char *)v29 + v124);
        do
        {
          v127 = v126->n128_u32[0];
          v126 = (float32x4_t *)((char *)v126 + 4);
          --v123;
          *(_DWORD *)v13 = v127;
          v128 = v125->n128_u32[0];
          v125 = (float32x4_t *)((char *)v125 + 4);
          *((_DWORD *)v13 + 1) = v128;
          v13 += 8;
        }
        while ( v123 );
        goto LABEL_127;
      }
      v115 = (float32x4_t *)&v13[8 * a4];
      v31 = 0;
      v116 = v13 < (_BYTE *)v29 + 4 * a4 && v115 > v29;
      v117 = v115 > v30;
      if ( v116 )
        goto LABEL_97;
      if ( v13 < (_BYTE *)v30 + 4 * a4 && v117 )
        goto LABEL_97;
      v31 = a4 - (unsigned __int64)(a4 & 7);
      v118 = (float *)(v13 + 32);
      v119 = v29 + 1;
      v13 += 8 * v31;
      v120 = v30 + 1;
      v121 = v31;
      do
      {
        v232.val[0] = v119[-1];
        v233.val[0] = *v119;
        v232.val[1] = v120[-1];
        v233.val[1] = *v120;
        v122 = v118 - 8;
        v119 += 2;
        v121 -= 8LL;
        vst2q_f32(v122, v232);
        vst2q_f32(v118, v233);
        v118 += 16;
        v120 += 2;
      }
      while ( v121 );
      if ( (v11 & 7) != 0 )
        goto LABEL_97;
      goto LABEL_127;
    case 403:
    case 405:
    case 407:
      goto LABEL_80;
    case 404:
      if ( !a4 )
        goto LABEL_127;
      v32 = *a2;
      v33 = a2[1];
      v34 = a2[2];
      v35 = a2[3];
      if ( a4 < 8 )
      {
        v36 = 0;
LABEL_107:
        v141 = a4 - v36;
        v142 = 4 * v36;
        v143 = (float32x4_t *)((char *)v35 + v142);
        v144 = (float32x4_t *)((char *)v34 + v142);
        v145 = (float32x4_t *)((char *)v33 + v142);
        v146 = (float32x4_t *)((char *)v32 + v142);
        do
        {
          v147 = v146->n128_u32[0];
          v146 = (float32x4_t *)((char *)v146 + 4);
          --v141;
          *(_DWORD *)v13 = v147;
          v148 = v145->n128_u32[0];
          v145 = (float32x4_t *)((char *)v145 + 4);
          *((_DWORD *)v13 + 1) = v148;
          v149 = v144->n128_u32[0];
          v144 = (float32x4_t *)((char *)v144 + 4);
          *((_DWORD *)v13 + 2) = v149;
          v150 = v143->n128_u32[0];
          v143 = (float32x4_t *)((char *)v143 + 4);
          *((_DWORD *)v13 + 3) = v150;
          v13 += 16;
        }
        while ( v141 );
        goto LABEL_127;
      }
      v129 = (float32x4_t *)&v13[16 * a4];
      v130 = v13 < (_BYTE *)v32 + 4 * a4 && v129 > v32;
      v131 = v129 > v33;
      v132 = v129 > v34;
      v36 = 0;
      v133 = v129 > v35;
      if ( v130 )
        goto LABEL_107;
      if ( v13 < (_BYTE *)v33 + 4 * a4 && v131 )
        goto LABEL_107;
      if ( v13 < (_BYTE *)v34 + 4 * a4 && v132 )
        goto LABEL_107;
      if ( v13 < (_BYTE *)v35 + 4 * a4 && v133 )
        goto LABEL_107;
      v36 = a4 - (unsigned __int64)(a4 & 7);
      v134 = (float *)(v13 + 64);
      v135 = v35 + 1;
      v136 = v32 + 1;
      v137 = v34 + 1;
      v13 += 16 * v36;
      v138 = v33 + 1;
      v139 = v36;
      do
      {
        v235.val[0] = v136[-1];
        v236.val[0] = *v136;
        v235.val[1] = v138[-1];
        v236.val[1] = *v138;
        v235.val[2] = v137[-1];
        v236.val[2] = *v137;
        v235.val[3] = v135[-1];
        v236.val[3] = *v135;
        v140 = v134 - 16;
        v139 -= 8LL;
        v136 += 2;
        v137 += 2;
        v135 += 2;
        vst4q_f32(v140, v235);
        vst4q_f32(v134, v236);
        v134 += 32;
        v138 += 2;
      }
      while ( v139 );
      if ( (v11 & 7) != 0 )
        goto LABEL_107;
      goto LABEL_127;
    case 406:
      if ( a4 )
      {
        v37 = *a2;
        v38 = a2[1];
        v39 = a2[2];
        v40 = a2[3];
        v41 = a2[4];
        v42 = a2[5];
        do
        {
          v43 = v37->n128_u32[0];
          v37 = (int32x4_t *)((char *)v37 + 4);
          --v11;
          *(_DWORD *)v13 = v43;
          v44 = v38->n128_u32[0];
          v38 = (int32x4_t *)((char *)v38 + 4);
          *((_DWORD *)v13 + 1) = v44;
          v45 = v39->n128_u32[0];
          v39 = (int32x4_t *)((char *)v39 + 4);
          *((_DWORD *)v13 + 2) = v45;
          v46 = v40->n128_u32[0];
          v40 = (int32x4_t *)((char *)v40 + 4);
          *((_DWORD *)v13 + 3) = v46;
          v47 = v41->n128_u32[0];
          v41 = (int32x4_t *)((char *)v41 + 4);
          *((_DWORD *)v13 + 4) = v47;
          v48 = v42->n128_u32[0];
          v42 = (int32x4_t *)((char *)v42 + 4);
          *((_DWORD *)v13 + 5) = v48;
          v13 += 24;
        }
        while ( v11 );
      }
      goto LABEL_127;
    case 408:
      if ( a4 )
      {
        v49 = *a2;
        v50 = a2[1];
        v51 = a2[2];
        v52 = a2[3];
        v53 = a2[4];
        v54 = a2[5];
        v55 = a2[6];
        v56 = a2[7];
        do
        {
          v57 = v49->n128_u32[0];
          v49 = (int32x4_t *)((char *)v49 + 4);
          --v11;
          *(_DWORD *)v13 = v57;
          v58 = v50->n128_u32[0];
          v50 = (int32x4_t *)((char *)v50 + 4);
          *((_DWORD *)v13 + 1) = v58;
          v59 = v51->n128_u32[0];
          v51 = (int32x4_t *)((char *)v51 + 4);
          *((_DWORD *)v13 + 2) = v59;
          v60 = v52->n128_u32[0];
          v52 = (int32x4_t *)((char *)v52 + 4);
          *((_DWORD *)v13 + 3) = v60;
          v61 = v53->n128_u32[0];
          v53 = (int32x4_t *)((char *)v53 + 4);
          *((_DWORD *)v13 + 4) = v61;
          v62 = v54->n128_u32[0];
          v54 = (int32x4_t *)((char *)v54 + 4);
          *((_DWORD *)v13 + 5) = v62;
          v63 = v55->n128_u32[0];
          v55 = (int32x4_t *)((char *)v55 + 4);
          *((_DWORD *)v13 + 6) = v63;
          v64 = v56->n128_u32[0];
          v56 = (int32x4_t *)((char *)v56 + 4);
          *((_DWORD *)v13 + 7) = v64;
          v13 += 32;
        }
        while ( v11 );
      }
      goto LABEL_127;
    default:
      if ( v16 == 301 )
      {
        if ( a4 )
        {
          v113 = 0;
          do
          {
            v114 = (*a2)->n128_i32[v113++];
            *(_WORD *)v13 = v114;
            v13[2] = BYTE2(v114);
            v13 += 3;
          }
          while ( a4 != v113 );
        }
        goto LABEL_127;
      }
      if ( v16 != 302 )
      {
LABEL_80:
        switch ( a5 )
        {
          case 1u:
            if ( a3 && a4 )
            {
              v111 = 0;
              do
              {
                v112 = 0;
                do
                {
                  v13[v112] = a2[v112]->n128_u32[v111];
                  ++v112;
                }
                while ( v7 != v112 );
                ++v111;
                v13 += a3;
              }
              while ( v111 != a4 );
            }
            goto LABEL_127;
          case 2u:
            if ( !a3 || !a4 )
              goto LABEL_127;
            v206 = 0;
            v207 = (unsigned int)v7 & 0xFFFFFFFE;
            break;
          case 3u:
            if ( a3 && a4 )
            {
              v217 = 0;
              do
              {
                v218 = 0;
                v219 = a2;
                v220 = v7;
                do
                {
                  v221 = (__int64)*v219++;
                  v222 = &v13[v218];
                  --v220;
                  v218 += 3;
                  v223 = *(_DWORD *)(v221 + 4 * v217);
                  *(_WORD *)v222 = v223;
                  v222[2] = BYTE2(v223);
                }
                while ( v220 );
                ++v217;
                v13 += 3 * a3;
              }
              while ( v217 != a4 );
            }
            goto LABEL_127;
          case 4u:
            if ( a3 && a4 )
            {
              v224 = 0;
              do
              {
                v225 = 0;
                do
                {
                  *(_DWORD *)&v13[4 * v225] = a2[v225]->n128_u32[v224];
                  ++v225;
                }
                while ( v7 != v225 );
                ++v224;
                v13 += 4 * a3;
              }
              while ( v224 != a4 );
            }
            goto LABEL_127;
          default:
            goto LABEL_127;
        }
        while ( 1 )
        {
          if ( a3 >= 2 )
          {
            v210 = 0;
            v209 = &v13[2 * (v7 - (a3 & 1))];
            do
            {
              v211 = &a2[v210];
              v212 = &v13[2 * v210];
              v210 += 2;
              v213 = (*v211)->n128_i32[v206];
              LODWORD(v211) = v211[1]->n128_u32[v206];
              *v212 = v213;
              v212[1] = (_WORD)v211;
            }
            while ( v207 != v210 );
            v208 = (unsigned int)v7 & 0xFFFFFFFE;
            if ( v207 == v7 )
              goto LABEL_148;
          }
          else
          {
            v208 = 0;
            v209 = v13;
          }
          v214 = v7 - v208;
          v215 = &a2[v208];
          do
          {
            v216 = (__int64)*v215++;
            --v214;
            *v209++ = *(_DWORD *)(v216 + 4 * v206);
          }
          while ( v214 );
LABEL_148:
          ++v206;
          v13 += 2 * a3;
          if ( v206 == a4 )
            goto LABEL_127;
        }
      }
      if ( a4 )
      {
        v25 = 0;
        do
        {
          v26 = v25++;
          v27 = (*a2)->n128_i32[v26];
          *(_WORD *)v13 = v27;
          v13[2] = BYTE2(v27);
          v28 = a2[1]->n128_i32[v26];
          *(_WORD *)(v13 + 3) = v28;
          v13[5] = BYTE2(v28);
          v13 += 6;
        }
        while ( a4 != v25 );
      }
LABEL_127:
      v194 = *(_DWORD *)(a1 + 80);
      v195 = *(char **)(a1 + 88);
      *(_DWORD *)(a1 + 80) = v194 + v14;
      if ( __CFADD__(v194, (_DWORD)v14) )
        ++*(_DWORD *)(a1 + 84);
      v196 = v194 & 0x3F;
      v197 = (unsigned int)(64 - v196);
      v198 = (void *)(a1 - v197 + 64);
      if ( (unsigned int)v197 <= (unsigned int)v14 )
      {
        memcpy(v198, v195, (unsigned int)(64 - v196));
        sub_1D620((_DWORD *)(a1 + 64), (int *)a1);
        v201 = v14 - v197;
        v202 = &v195[v197];
        if ( (unsigned int)(v14 - v197) >= 0x40 )
        {
          v203 = v14 + v196 - 128;
          v204 = v197 + 64;
          do
          {
            *(_OWORD *)(a1 + 48) = *((_OWORD *)v202 + 3);
            *(_OWORD *)(a1 + 32) = *((_OWORD *)v202 + 2);
            *(_OWORD *)(a1 + 16) = *((_OWORD *)v202 + 1);
            v205 = *(_OWORD *)v202;
            v202 += 64;
            *(_OWORD *)a1 = v205;
            sub_1D620((_DWORD *)(a1 + 64), (int *)a1);
            v201 -= 64;
          }
          while ( v201 > 0x3F );
          v202 = &v195[v204 + (v203 & 0xFFFFFFC0)];
          v201 = v203 & 0x3F;
        }
        v199 = v201;
        v198 = (void *)a1;
        v200 = v202;
      }
      else
      {
        v199 = (unsigned int)v14;
        v200 = v195;
      }
      memcpy(v198, v200, v199);
      return (_BYTE *)(&dword_0 + 1);
  }
}
// 1E851: failed to expand linear variable q0.16
// 0: using guessed type int dword_0;

//----- (000000000001EBD4) ----------------------------------------------------
void *__fastcall FLAC__memory_alloc_aligned(size_t a1, _QWORD *a2)
{
  void *result; // x0

  if ( !a1 )
    a1 = 1;
  result = malloc(a1);
  *a2 = result;
  return result;
}

//----- (000000000001EC00) ----------------------------------------------------
void *__fastcall FLAC__memory_alloc_aligned_int32_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  void *result; // x0
  void *v6; // x21

  if ( a1 >> 62 )
    return 0;
  result = malloc((4 * a1 == 0) | (4 * a1));
  v6 = result;
  if ( result )
  {
    if ( *a2 )
      free(*a2);
    result = &dword_0 + 1;
    *a2 = v6;
    *a3 = v6;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001EC7C) ----------------------------------------------------
void *__fastcall FLAC__memory_alloc_aligned_uint32_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  void *result; // x0
  void *v6; // x21

  if ( a1 >> 62 )
    return 0;
  result = malloc((4 * a1 == 0) | (4 * a1));
  v6 = result;
  if ( result )
  {
    if ( *a2 )
      free(*a2);
    result = &dword_0 + 1;
    *a2 = v6;
    *a3 = v6;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001ECF8) ----------------------------------------------------
void *__fastcall FLAC__memory_alloc_aligned_uint64_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  void *result; // x0
  void *v6; // x21

  if ( a1 >> 61 )
    return 0;
  result = malloc((8 * a1 == 0) | (8 * a1));
  v6 = result;
  if ( result )
  {
    if ( *a2 )
      free(*a2);
    result = &dword_0 + 1;
    *a2 = v6;
    *a3 = v6;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001ED74) ----------------------------------------------------
void *__fastcall FLAC__memory_alloc_aligned_unsigned_array(unsigned __int64 a1, void **a2, _QWORD *a3)
{
  void *result; // x0
  void *v6; // x21

  if ( a1 >> 62 )
    return 0;
  result = malloc((4 * a1 == 0) | (4 * a1));
  v6 = result;
  if ( result )
  {
    if ( *a2 )
      free(*a2);
    result = &dword_0 + 1;
    *a2 = v6;
    *a3 = v6;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001EDF0) ----------------------------------------------------
void *__fastcall safe_malloc_mul_2op_p(unsigned __int64 a1, unsigned __int64 a2)
{
  size_t v2; // x8

  v2 = 1;
  if ( a1 && a2 )
  {
    if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )
      return 0;
    v2 = a2 * a1;
  }
  return malloc(v2);
}

//----- (000000000001EE20) ----------------------------------------------------
int **__fastcall FLAC__metadata_get_streaminfo(const char *a1, void *a2)
{
  int **result; // x0
  int **v4; // x20

  result = sub_1EE68(a1, 0);
  v4 = result;
  if ( result )
  {
    memcpy(a2, result, 0xB0u);
    FLAC__metadata_object_delete(v4);
    return (int **)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000001EE68) ----------------------------------------------------
int **__fastcall sub_1EE68(const char *a1, unsigned int a2)
{
  int **result; // x0
  int **v5; // x19
  int inited; // w0
  int v7; // w0
  int v8; // w21
  int v9; // w20
  int v10; // [xsp+8h] [xbp-38h] BYREF
  int **v11; // [xsp+10h] [xbp-30h]
  __int64 v12; // [xsp+18h] [xbp-28h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v10 = 0;
  v11 = 0;
  result = (int **)FLAC__stream_decoder_new();
  v5 = result;
  if ( result )
  {
    FLAC__stream_decoder_set_md5_checking(result, 0);
    FLAC__stream_decoder_set_metadata_ignore_all((__int64)v5);
    FLAC__stream_decoder_set_metadata_respond((__int64)v5, a2);
    inited = FLAC__stream_decoder_init_file(
               v5,
               a1,
               (__int64)sub_226F8,
               (__int64)sub_22700,
               (__int64)sub_22750,
               (__int64)&v10);
    if ( v10 | inited )
    {
      FLAC__stream_decoder_finish((__int64)v5);
      FLAC__stream_decoder_delete((void **)v5);
      return 0;
    }
    v7 = FLAC__stream_decoder_process_until_end_of_metadata(v5);
    v8 = v10;
    v9 = v7;
    FLAC__stream_decoder_finish((__int64)v5);
    FLAC__stream_decoder_delete((void **)v5);
    result = v11;
    if ( (!v9 || v8) && v11 )
    {
      FLAC__metadata_object_delete(v11);
      return 0;
    }
  }
  return result;
}

//----- (000000000001EF70) ----------------------------------------------------
bool __fastcall FLAC__metadata_get_tags(const char *a1, int ***a2)
{
  int **v3; // x0

  v3 = sub_1EE68(a1, 4u);
  *a2 = v3;
  return v3 != 0;
}

//----- (000000000001EFA4) ----------------------------------------------------
bool __fastcall FLAC__metadata_get_cuesheet(const char *a1, int ***a2)
{
  int **v3; // x0

  v3 = sub_1EE68(a1, 5u);
  *a2 = v3;
  return v3 != 0;
}

//----- (000000000001EFD8) ----------------------------------------------------
_QWORD *__fastcall FLAC__metadata_get_picture(
        const char *a1,
        void **a2,
        int a3,
        const char *a4,
        const char *a5,
        unsigned int a6,
        unsigned int a7,
        unsigned int a8,
        unsigned int a9)
{
  _QWORD *result; // x0
  __int64 v17; // x19
  const char **block; // x0
  const char **v19; // x27
  __int64 v20; // x21
  __int64 v21; // x28
  int v22; // w0
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x21
  int v25; // w8
  void *v26; // x0
  void *v27; // x0
  unsigned __int64 v28; // x28
  const char **v29; // x0
  const char **v30; // x26
  __int64 v31; // x21
  __int64 v32; // x27
  int v33; // w0
  unsigned __int64 v34; // x8
  unsigned __int64 v35; // x21
  int v36; // w8
  void *v37; // x0
  void *v38; // x0
  unsigned __int128 v39; // [xsp+8h] [xbp-68h]
  unsigned __int64 v40; // [xsp+10h] [xbp-60h]

  *a2 = 0;
  result = calloc(1u, 0xE8u);
  v17 = (__int64)result;
  if ( !result )
    return result;
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  result[21] = -1;
  result[26] = -1;
  if ( (unsigned int)FLAC__metadata_simple_iterator_init((__int64)result, a1, 1, 1) )
  {
    if ( a3 != -1 )
    {
      v39 = 0u;
      while ( 1 )
      {
        while ( *(_DWORD *)(v17 + 224) != 6 )
        {
LABEL_19:
          if ( !(unsigned int)FLAC__metadata_simple_iterator_next(v17) )
            goto LABEL_54;
        }
        block = (const char **)FLAC__metadata_simple_iterator_get_block(v17);
        v19 = block;
        if ( *((_DWORD *)block + 4) == a3 )
        {
          v21 = *((unsigned int *)block + 10);
          v20 = *((unsigned int *)block + 11);
          if ( !a4 || !strcmp(a4, block[3]) )
          {
            if ( a5 )
            {
              v22 = strcmp(a5, v19[4]);
              if ( (unsigned int)v20 > a7 || (unsigned int)v21 > a6 || v22 )
                goto LABEL_23;
            }
            else if ( (unsigned int)v21 > a6 || (unsigned int)v20 > a7 )
            {
              goto LABEL_23;
            }
            v23 = *((unsigned int *)v19 + 12);
            if ( (unsigned int)v23 <= a8 && *((_DWORD *)v19 + 13) <= a9 )
            {
              v24 = v20 * v21;
              if ( v39 < __PAIR128__(v24, v23) )
              {
                if ( *a2 )
                  FLAC__metadata_object_delete(*a2);
                *a2 = v19;
                *(_QWORD *)&v39 = *((unsigned int *)v19 + 12);
                *((_QWORD *)&v39 + 1) = v24;
                goto LABEL_19;
              }
            }
          }
        }
LABEL_23:
        FLAC__metadata_object_delete(v19);
        if ( !(unsigned int)FLAC__metadata_simple_iterator_next(v17) )
          goto LABEL_54;
      }
    }
    v28 = 0;
    v40 = 0;
    while ( 1 )
    {
      while ( *(_DWORD *)(v17 + 224) != 6 )
      {
LABEL_49:
        if ( !(unsigned int)FLAC__metadata_simple_iterator_next(v17) )
          goto LABEL_54;
      }
      v29 = (const char **)FLAC__metadata_simple_iterator_get_block(v17);
      v30 = v29;
      v32 = *((unsigned int *)v29 + 10);
      v31 = *((unsigned int *)v29 + 11);
      if ( !a4 || !strcmp(a4, v29[3]) )
      {
        if ( a5 )
        {
          v33 = strcmp(a5, v30[4]);
          if ( (unsigned int)v31 > a7 || (unsigned int)v32 > a6 || v33 )
            goto LABEL_53;
        }
        else if ( (unsigned int)v32 > a6 || (unsigned int)v31 > a7 )
        {
          goto LABEL_53;
        }
        v34 = *((unsigned int *)v30 + 12);
        if ( (unsigned int)v34 <= a8 && *((_DWORD *)v30 + 13) <= a9 )
        {
          v35 = v31 * v32;
          if ( v35 > v28 || v35 == v28 && v40 < v34 )
          {
            if ( *a2 )
              FLAC__metadata_object_delete(*a2);
            *a2 = v30;
            v28 = v35;
            v40 = *((unsigned int *)v30 + 12);
            goto LABEL_49;
          }
        }
      }
LABEL_53:
      FLAC__metadata_object_delete(v30);
      if ( !(unsigned int)FLAC__metadata_simple_iterator_next(v17) )
      {
LABEL_54:
        if ( *(_QWORD *)v17 )
        {
          fclose(*(FILE **)v17);
          v36 = *(_DWORD *)(v17 + 152);
          *(_QWORD *)v17 = 0;
          if ( v36 )
            sub_21B50(*(const char **)(v17 + 8), v17 + 24);
        }
        v37 = *(void **)(v17 + 8);
        if ( v37 )
        {
          free(v37);
          *(_QWORD *)(v17 + 8) = 0;
        }
        v38 = *(void **)(v17 + 16);
        if ( v38 )
          free(v38);
        free((void *)v17);
        return (_QWORD *)(*a2 != 0);
      }
    }
  }
  if ( *(_QWORD *)v17 )
  {
    fclose(*(FILE **)v17);
    v25 = *(_DWORD *)(v17 + 152);
    *(_QWORD *)v17 = 0;
    if ( v25 )
      sub_21B50(*(const char **)(v17 + 8), v17 + 24);
  }
  v26 = *(void **)(v17 + 8);
  if ( v26 )
  {
    free(v26);
    *(_QWORD *)(v17 + 8) = 0;
  }
  v27 = *(void **)(v17 + 16);
  if ( v27 )
    free(v27);
  free((void *)v17);
  return 0;
}

//----- (000000000001F30C) ----------------------------------------------------
_QWORD *FLAC__metadata_simple_iterator_new()
{
  _QWORD *result; // x0

  result = calloc(1u, 0xE8u);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    result[21] = -1;
    result[26] = -1;
  }
  return result;
}

//----- (000000000001F340) ----------------------------------------------------
char *__fastcall FLAC__metadata_simple_iterator_init(__int64 a1, const char *a2, int a3, int a4)
{
  FILE *v5; // x0
  int v9; // w8
  void *v10; // x0
  void *v11; // x0
  char *result; // x0

  v5 = *(FILE **)a1;
  if ( v5 )
  {
    fclose(v5);
    v9 = *(_DWORD *)(a1 + 152);
    *(_QWORD *)a1 = 0;
    if ( v9 )
      sub_21B50(*(const char **)(a1 + 8), a1 + 24);
  }
  v10 = *(void **)(a1 + 8);
  if ( v10 )
  {
    free(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v11 = *(void **)(a1 + 16);
  if ( v11 )
  {
    free(v11);
    *(_QWORD *)(a1 + 16) = 0;
  }
  if ( !a3 && a4 )
    *(_DWORD *)(a1 + 152) = stat(a2, (struct stat *)(a1 + 24)) == 0;
  result = strdup(a2);
  *(_QWORD *)(a1 + 8) = result;
  if ( result )
    return (char *)sub_1F628(a1, a3);
  *(_DWORD *)(a1 + 160) = 11;
  return result;
}

//----- (000000000001F404) ----------------------------------------------------
void __fastcall FLAC__metadata_simple_iterator_delete(void *a1)
{
  FILE *v2; // x0
  int v3; // w8
  void *v4; // x0
  void *v5; // x0

  v2 = *(FILE **)a1;
  if ( v2 )
  {
    fclose(v2);
    v3 = *((_DWORD *)a1 + 38);
    *(_QWORD *)a1 = 0;
    if ( v3 )
      sub_21B50(*((const char **)a1 + 1), (__int64)a1 + 24);
  }
  v4 = (void *)*((_QWORD *)a1 + 1);
  if ( v4 )
  {
    free(v4);
    *((_QWORD *)a1 + 1) = 0;
  }
  v5 = (void *)*((_QWORD *)a1 + 2);
  if ( v5 )
    free(v5);
  free(a1);
}

//----- (000000000001F464) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_type(__int64 a1)
{
  return *(unsigned int *)(a1 + 224);
}

//----- (000000000001F46C) ----------------------------------------------------
void *__fastcall FLAC__metadata_simple_iterator_get_block(__int64 a1)
{
  void *v2; // x0
  void *v3; // x19
  int v4; // w0

  v2 = FLAC__metadata_object_new(*(_DWORD *)(a1 + 224));
  v3 = v2;
  if ( v2 )
  {
    *((_DWORD *)v2 + 1) = *(_DWORD *)(a1 + 220);
    *((_DWORD *)v2 + 2) = *(_DWORD *)(a1 + 228);
    v4 = sub_22D34(
           *(_QWORD *)a1,
           (__int64 (*)(void))&fread,
           (unsigned int (__fastcall *)(__int64, _QWORD, __int64))j__fseeko,
           (__int64)v2);
    *(_DWORD *)(a1 + 160) = v4;
    if ( !v4 )
    {
      if ( !fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168) + 4LL, 0) )
        return v3;
      *(_DWORD *)(a1 + 160) = 7;
    }
    FLAC__metadata_object_delete(v3);
    return 0;
  }
  *(_DWORD *)(a1 + 160) = 11;
  return 0;
}

//----- (000000000001F51C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_next(__int64 a1)
{
  __int64 result; // x0
  int v3; // w8
  int v4; // w8
  unsigned __int8 ptr; // [xsp+4h] [xbp-1Ch] BYREF
  unsigned __int16 v6; // [xsp+5h] [xbp-1Bh]
  unsigned __int8 v7; // [xsp+7h] [xbp-19h]
  __int64 v8; // [xsp+8h] [xbp-18h]

  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( *(_DWORD *)(a1 + 220) )
    return 0;
  if ( fseeko(*(FILE **)a1, *(unsigned int *)(a1 + 228), 1) )
  {
    result = 0;
    v3 = 7;
  }
  else
  {
    *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168) = ftello(*(FILE **)a1);
    if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
    {
      result = 1;
      v4 = ptr & 0x7F;
      *(_DWORD *)(a1 + 220) = ptr >> 7;
      *(_DWORD *)(a1 + 224) = v4;
      *(_DWORD *)(a1 + 228) = v7 | (_byteswap_ushort(v6) << 8);
      return result;
    }
    result = 0;
    v3 = 6;
  }
  *(_DWORD *)(a1 + 160) = v3;
  return result;
}

//----- (000000000001F618) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_status(__int64 a1)
{
  unsigned int v1; // w8

  v1 = *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 160) = 0;
  return v1;
}

//----- (000000000001F628) ----------------------------------------------------
FILE *__fastcall sub_1F628(__int64 a1, int a2)
{
  FILE *result; // x0
  FILE *v4; // x20
  int v5; // w8
  _DWORD *v6; // x21
  size_t v7; // x0
  char v8; // w23
  char v9; // w24
  char v10; // w25
  size_t v11; // x0
  FILE *v12; // x0
  __off_t v13; // x0
  FILE *v14; // x3
  int v15; // w8
  int ptr; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v17; // [xsp+8h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 )
  {
    *(_DWORD *)(a1 + 156) = 0;
  }
  else
  {
    v4 = fopen(*(const char **)(a1 + 8), "r+b");
    *(_QWORD *)a1 = v4;
    if ( v4 )
    {
      *(_DWORD *)(a1 + 156) = 1;
      goto LABEL_7;
    }
    *(_DWORD *)(a1 + 156) = 0;
    if ( *(_DWORD *)__errno() != 13 )
    {
      result = 0;
      v5 = 2;
      goto LABEL_31;
    }
  }
  result = fopen(*(const char **)(a1 + 8), "rb");
  v4 = result;
  *(_QWORD *)a1 = result;
  if ( result )
  {
LABEL_7:
    v6 = (_DWORD *)__errno();
    *v6 = 0;
    v7 = fread(&ptr, 1u, 4u, v4);
    if ( *v6 )
      goto LABEL_8;
    if ( v7 == 4 )
    {
      if ( memcmp(&ptr, "ID3", 3u) )
        goto LABEL_11;
      if ( fseeko(v4, 2, 1) < 0 )
        goto LABEL_30;
      if ( !fread(&ptr, 1u, 1u, v4) )
        goto LABEL_8;
      v8 = ptr;
      if ( (ptr & 0x80) != 0 )
        goto LABEL_8;
      if ( !fread(&ptr, 1u, 1u, v4) )
        goto LABEL_8;
      v9 = ptr;
      if ( (ptr & 0x80) != 0 )
        goto LABEL_8;
      if ( !fread(&ptr, 1u, 1u, v4) )
        goto LABEL_8;
      v10 = ptr;
      if ( (ptr & 0x80) != 0 || !fread(&ptr, 1u, 1u, v4) || (ptr & 0x80) != 0 )
        goto LABEL_8;
      if ( fseeko(v4, ptr & 0x7F | ((v10 & 0x7F | ((v9 & 0x7F | ((unsigned __int8)(v8 & 0x7F) << 7)) << 7)) << 7), 1) < 0 )
      {
LABEL_30:
        result = 0;
        v5 = 7;
        goto LABEL_31;
      }
      *v6 = 0;
      v11 = fread(&ptr, 1u, 4u, v4);
      if ( *v6 )
      {
LABEL_8:
        result = 0;
        v5 = 6;
        goto LABEL_31;
      }
      if ( v11 == 4 )
      {
LABEL_11:
        if ( ptr == 1130450022 )
        {
          v12 = *(FILE **)a1;
          *(_DWORD *)(a1 + 216) = 0;
          v13 = ftello(v12);
          *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168) = v13;
          v14 = *(FILE **)a1;
          *(_QWORD *)(a1 + 208) = v13;
          if ( fread(&ptr, 1u, 4u, v14) == 4 )
          {
            result = (FILE *)(&dword_0 + 1);
            v15 = ptr & 0x7F;
            *(_DWORD *)(a1 + 220) = (unsigned __int8)ptr >> 7;
            *(_DWORD *)(a1 + 224) = v15;
            *(_DWORD *)(a1 + 228) = HIBYTE(ptr) | (_byteswap_ushort(*(unsigned __int16 *)((char *)&ptr + 1)) << 8);
            return result;
          }
          goto LABEL_8;
        }
      }
    }
    result = 0;
    v5 = 3;
    goto LABEL_31;
  }
  v5 = 2;
LABEL_31:
  *(_DWORD *)(a1 + 160) = v5;
  return result;
}
// 0: using guessed type int dword_0;
// 11850: using guessed type __int64 __errno(void);

//----- (000000000001F8D0) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_is_writable(__int64 a1)
{
  return *(unsigned int *)(a1 + 156);
}

//----- (000000000001F8D8) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_prev(__int64 a1)
{
  __off_t v2; // x1
  __int64 result; // x0
  int v4; // w8
  __off_t v5; // x20
  FILE *v6; // x3
  __off_t v7; // x0
  FILE *v8; // x0
  int v9; // w8
  __off_t v10; // x0
  __off_t v11; // x1
  __int64 v12; // x8
  __off_t *v13; // x8
  __off_t v14; // t1
  unsigned __int8 ptr; // [xsp+4h] [xbp-2Ch] BYREF
  unsigned __int16 v16; // [xsp+5h] [xbp-2Bh]
  unsigned __int8 v17; // [xsp+7h] [xbp-29h]
  __int64 v18; // [xsp+8h] [xbp-28h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = *(_QWORD *)(a1 + 208);
  if ( *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168) == v2 )
    return 0;
  if ( fseeko(*(FILE **)a1, v2, 0) )
  {
LABEL_5:
    v4 = 7;
LABEL_13:
    result = 0;
    *(_DWORD *)(a1 + 160) = v4;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 208);
    v6 = *(FILE **)a1;
    while ( 1 )
    {
      if ( fread(&ptr, 1u, 4u, v6) != 4 )
      {
        v4 = 6;
        goto LABEL_13;
      }
      v8 = *(FILE **)a1;
      v9 = ptr & 0x7F;
      *(_DWORD *)(a1 + 220) = ptr >> 7;
      *(_DWORD *)(a1 + 224) = v9;
      *(_DWORD *)(a1 + 228) = v17 | (_byteswap_ushort(v16) << 8);
      v10 = ftello(v8);
      v11 = *(unsigned int *)(a1 + 228);
      v12 = a1 + 8LL * *(unsigned int *)(a1 + 216);
      v14 = *(_QWORD *)(v12 + 168);
      v13 = (__off_t *)(v12 + 168);
      if ( v10 + v11 >= v14 )
        break;
      if ( fseeko(*(FILE **)a1, v11, 1) )
        goto LABEL_5;
      v7 = ftello(*(FILE **)a1);
      v6 = *(FILE **)a1;
      v5 = v7;
    }
    result = 1;
    *v13 = v5;
  }
  return result;
}

//----- (000000000001FA24) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_is_last(__int64 a1)
{
  return *(unsigned int *)(a1 + 220);
}

//----- (000000000001FA2C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_offset(__int64 a1)
{
  return *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168);
}

//----- (000000000001FA3C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_get_block_length(__int64 a1)
{
  return *(unsigned int *)(a1 + 228);
}

//----- (000000000001FA44) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_get_application_id(__int64 a1, void *a2)
{
  unsigned int v3; // w20
  int v4; // w8

  if ( *(_DWORD *)(a1 + 224) != 2 )
  {
    v4 = 1;
LABEL_7:
    v3 = 0;
    *(_DWORD *)(a1 + 160) = v4;
    return v3;
  }
  if ( fread(a2, 1u, 4u, *(FILE **)a1) != 4 )
  {
    v4 = 6;
    goto LABEL_7;
  }
  v3 = 1;
  if ( fseeko(*(FILE **)a1, -4, 1) )
  {
    v4 = 7;
    goto LABEL_7;
  }
  return v3;
}

//----- (000000000001FAE4) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_set_block(_DWORD *a1, _DWORD *a2, int a3)
{
  __int64 v3; // x19
  int v4; // w21
  _DWORD *v5; // x20
  int v6; // w8
  int v7; // w9
  int v8; // w3
  unsigned int v9; // w9
  unsigned int v10; // w8
  unsigned int v11; // w22
  int v13; // w8
  unsigned int v14; // w2
  __int64 v15; // x8
  __int64 v16; // x10
  unsigned int v17; // w8
  unsigned int v18; // w24
  int v19; // w22
  FILE *v20; // x0
  unsigned int v21; // w8
  int v22; // w8
  FILE *v23; // x0
  unsigned int v24; // w8
  int v25; // w8
  unsigned __int8 ptr; // [xsp+4h] [xbp-3Ch] BYREF
  unsigned __int16 v27; // [xsp+5h] [xbp-3Bh]
  unsigned __int8 v28; // [xsp+7h] [xbp-39h]
  __int64 v29; // [xsp+8h] [xbp-38h]

  v3 = (__int64)a1;
  v4 = a3;
  v5 = a2;
  v29 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1[39] )
  {
    v6 = a1[56];
    v7 = *a2;
    if ( v6 && v7 || v6 == v7 )
    {
      v8 = a1[55];
      v9 = a2[2];
      a2[1] = v8;
      v10 = a1[57];
      v11 = v9 - v10;
      if ( v9 == v10 )
        return sub_1FD90(v3, v5);
      if ( v9 < v10 )
      {
        if ( a3 && v10 >= v9 + 4 )
        {
          v14 = v10 - 4 - v9;
          return sub_1FF2C((__int64)a1, a2, v14, v8);
        }
        return sub_201A0(v3, v5, 0);
      }
      if ( v8 || !a3 )
        return sub_201A0(v3, v5, 0);
      v15 = (unsigned int)a1[54];
      v16 = *(_QWORD *)&a1[2 * v15 + 42];
      LODWORD(v15) = v15 + 1;
      *(_QWORD *)&a1[2 * (unsigned int)v15 + 42] = v16;
      a1[54] = v15;
      if ( !(unsigned int)FLAC__metadata_simple_iterator_next((__int64)a1) )
      {
        v20 = *(FILE **)v3;
        v21 = *(_DWORD *)(v3 + 216) - 1;
        *(_DWORD *)(v3 + 216) = v21;
        if ( fseeko(v20, *(_QWORD *)(v3 + 8LL * v21 + 168), 0) )
        {
LABEL_29:
          v13 = 7;
          goto LABEL_14;
        }
        if ( fread(&ptr, 1u, 4u, *(FILE **)v3) == 4 )
        {
          v22 = ptr & 0x7F;
          *(_DWORD *)(v3 + 220) = ptr >> 7;
          *(_DWORD *)(v3 + 224) = v22;
          *(_DWORD *)(v3 + 228) = v28 | (_byteswap_ushort(v27) << 8);
          return 0;
        }
LABEL_35:
        v13 = 6;
        goto LABEL_14;
      }
      if ( *(_DWORD *)(v3 + 224) == 1 )
      {
        v17 = *(_DWORD *)(v3 + 228);
        v18 = v17 + 4 - v11;
        if ( v17 + 4 == v11 )
        {
          v19 = 0;
          v5[1] = *(_DWORD *)(v3 + 220);
LABEL_28:
          v23 = *(FILE **)v3;
          v24 = *(_DWORD *)(v3 + 216) - 1;
          *(_DWORD *)(v3 + 216) = v24;
          if ( fseeko(v23, *(_QWORD *)(v3 + 8LL * v24 + 168), 0) )
            goto LABEL_29;
          if ( fread(&ptr, 1u, 4u, *(FILE **)v3) == 4 )
          {
            v25 = ptr & 0x7F;
            *(_DWORD *)(v3 + 220) = ptr >> 7;
            *(_DWORD *)(v3 + 224) = v25;
            *(_DWORD *)(v3 + 228) = v28 | (_byteswap_ushort(v27) << 8);
            if ( v4 )
            {
              if ( !v18 )
                return sub_1FD90(v3, v5);
              v14 = v18 - 4;
              a1 = (_DWORD *)v3;
              a2 = v5;
              v8 = v19;
              return sub_1FF2C((__int64)a1, a2, v14, v8);
            }
            return sub_201A0(v3, v5, 0);
          }
          goto LABEL_35;
        }
        if ( v17 >= v11 )
        {
          v19 = *(_DWORD *)(v3 + 220);
          v5[1] = 0;
          goto LABEL_28;
        }
      }
      v4 = 0;
      v18 = 0;
      v19 = 0;
      goto LABEL_28;
    }
    v13 = 1;
  }
  else
  {
    v13 = 4;
  }
LABEL_14:
  *(_DWORD *)(v3 + 160) = v13;
  return 0;
}

//----- (000000000001FD90) ----------------------------------------------------
__int64 __fastcall sub_1FD90(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0
  int v5; // w8
  unsigned int v6; // w8
  FILE *v7; // x3
  char v8; // w10
  int v9; // w8
  unsigned __int8 ptr; // [xsp+4h] [xbp-2Ch] BYREF
  unsigned __int16 v11; // [xsp+5h] [xbp-2Bh]
  unsigned __int8 v12; // [xsp+7h] [xbp-29h]
  __int64 v13; // [xsp+8h] [xbp-28h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168), 0) )
  {
    v6 = a2[2];
    if ( v6 >= 0x1000000
      || ((v7 = *(FILE **)a1, a2[1]) ? (v8 = 0x80) : (v8 = 0),
          ptr = v8 | *a2,
          HIBYTE(v11) = BYTE1(v6),
          v12 = v6,
          LOBYTE(v11) = BYTE2(v6),
          fwrite(&ptr, 1u, 4u, v7) != 4) )
    {
      result = 0;
      v5 = 8;
      goto LABEL_13;
    }
    result = sub_23FA4(*(_QWORD *)a1, (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite, (__int64)a2);
    *(_DWORD *)(a1 + 160) = 8 * ((_DWORD)result == 0);
    if ( !(_DWORD)result )
      return result;
    if ( !fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168), 0) )
    {
      if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
      {
        result = 1;
        v9 = ptr & 0x7F;
        *(_DWORD *)(a1 + 220) = ptr >> 7;
        *(_DWORD *)(a1 + 224) = v9;
        *(_DWORD *)(a1 + 228) = v12 | (_byteswap_ushort(v11) << 8);
        return result;
      }
      result = 0;
      v5 = 6;
      goto LABEL_13;
    }
  }
  result = 0;
  v5 = 7;
LABEL_13:
  *(_DWORD *)(a1 + 160) = v5;
  return result;
}

//----- (000000000001FF2C) ----------------------------------------------------
__int64 __fastcall sub_1FF2C(__int64 a1, _DWORD *a2, unsigned int a3, int a4)
{
  __int64 result; // x0
  int v9; // w8
  unsigned int v10; // w8
  FILE *v11; // x3
  _DWORD *v12; // x0
  void *v13; // x22
  FILE *v14; // x3
  char v15; // w8
  int v16; // w20
  int v17; // w8
  unsigned __int8 ptr; // [xsp+4h] [xbp-3Ch] BYREF
  unsigned __int16 v19; // [xsp+5h] [xbp-3Bh]
  unsigned __int8 v20; // [xsp+7h] [xbp-39h]
  __int64 v21; // [xsp+8h] [xbp-38h]

  v21 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168), 0) )
  {
    v10 = a2[2];
    a2[1] = 0;
    if ( v10 >= 0x1000000
      || (v11 = *(FILE **)a1,
          ptr = *a2,
          HIBYTE(v19) = BYTE1(v10),
          v20 = v10,
          LOBYTE(v19) = BYTE2(v10),
          fwrite(&ptr, 1u, 4u, v11) != 4) )
    {
      result = 0;
      v9 = 8;
      goto LABEL_17;
    }
    result = sub_23FA4(*(_QWORD *)a1, (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite, (__int64)a2);
    *(_DWORD *)(a1 + 160) = 8 * ((_DWORD)result == 0);
    if ( !(_DWORD)result )
      return result;
    v12 = FLAC__metadata_object_new(1u);
    v13 = v12;
    if ( !v12 )
      return 11;
    v12[1] = a4;
    v12[2] = a3;
    if ( a3 < 0x1000000
      && ((v14 = *(FILE **)a1, a4) ? (v15 = 0x80) : (v15 = 0),
          ptr = *v12 | v15,
          HIBYTE(v19) = BYTE1(a3),
          v20 = a3,
          LOBYTE(v19) = BYTE2(a3),
          fwrite(&ptr, 1u, 4u, v14) == 4) )
    {
      v16 = sub_23FA4(*(_QWORD *)a1, (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite, (__int64)v13);
      *(_DWORD *)(a1 + 160) = 8 * (v16 == 0);
      FLAC__metadata_object_delete(v13);
      if ( v16 )
      {
        if ( !fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168), 0) )
        {
          if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
          {
            result = 1;
            v17 = ptr & 0x7F;
            *(_DWORD *)(a1 + 220) = ptr >> 7;
            *(_DWORD *)(a1 + 224) = v17;
            *(_DWORD *)(a1 + 228) = v20 | (_byteswap_ushort(v19) << 8);
            return result;
          }
          result = 0;
          v9 = 6;
          goto LABEL_17;
        }
        goto LABEL_2;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 160) = 8;
      FLAC__metadata_object_delete(v13);
    }
    return 0;
  }
LABEL_2:
  result = 0;
  v9 = 7;
LABEL_17:
  *(_DWORD *)(a1 + 160) = v9;
  return result;
}

//----- (00000000000201A0) ----------------------------------------------------
__int64 __fastcall sub_201A0(__int64 a1, _DWORD *a2, int a3)
{
  int v5; // w28
  __int64 v6; // x22
  __int64 v7; // x24
  char v8; // w20
  int v9; // w8
  __int64 result; // x0
  _DWORD *v11; // x20
  FILE *v12; // x23
  FILE *v13; // x24
  size_t v14; // x25
  int *v15; // x27
  FILE *v16; // x23
  unsigned int v17; // w8
  char v18; // w10
  size_t v19; // x0
  int v20; // w0
  __int64 v21; // x22
  FILE *v22; // x0
  char *v23; // x19
  int v24; // w8
  FILE *v25; // x0
  __int64 v26; // x8
  __int64 v27; // x22
  __int64 v28; // x9
  int v29; // w0
  __int64 v30; // x8
  unsigned int v31; // w8
  int v32; // w8
  char *v33; // x19
  unsigned int v34; // w8
  int v35; // w8
  FILE *v36; // x23
  FILE *v37; // x24
  size_t v38; // x25
  FILE *v39; // x23
  unsigned __int8 v40; // w8
  __int64 v41; // x20
  const char *v42; // x23
  char *v43; // x22
  int v44; // w23
  int v45; // w8
  char *v46; // x19
  char *v47; // x19
  char v48; // [xsp+Ch] [xbp-2074h]
  __off_t off; // [xsp+10h] [xbp-2070h]
  char *name; // [xsp+18h] [xbp-2068h] BYREF
  FILE *s; // [xsp+20h] [xbp-2060h] BYREF
  unsigned __int8 ptr; // [xsp+28h] [xbp-2058h] BYREF
  unsigned __int16 v53; // [xsp+29h] [xbp-2057h]
  unsigned __int8 v54; // [xsp+2Bh] [xbp-2055h]
  __int64 v55; // [xsp+2028h] [xbp-58h]

  v55 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  name = 0;
  s = 0;
  if ( *(_DWORD *)(a1 + 220) )
  {
    if ( a3 )
    {
      v5 = 1;
      v6 = *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168);
      v7 = v6;
LABEL_5:
      v8 = 0;
      v6 += *(unsigned int *)(a1 + 228) + 4LL;
      goto LABEL_10;
    }
    if ( a2 )
    {
      v5 = 0;
      v7 = -1;
LABEL_8:
      v6 = *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168);
      goto LABEL_9;
    }
    v26 = *(unsigned int *)(a1 + 216);
    v27 = a1 + 168;
    v28 = *(_QWORD *)(a1 + 168 + 8 * v26);
    LODWORD(v26) = v26 + 1;
    *(_QWORD *)(a1 + 168 + 8LL * (unsigned int)v26) = v28;
    *(_DWORD *)(a1 + 216) = v26;
    v29 = FLAC__metadata_simple_iterator_prev(a1);
    v30 = *(unsigned int *)(a1 + 216);
    if ( v29 )
    {
      v7 = *(_QWORD *)(v27 + 8 * v30);
      v31 = v30 - 1;
      *(_DWORD *)(a1 + 216) = v31;
      if ( fseeko(*(FILE **)a1, *(_QWORD *)(v27 + 8LL * v31), 0) )
        goto LABEL_11;
      if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
      {
        v5 = -1;
        v32 = ptr & 0x7F;
        *(_DWORD *)(a1 + 220) = ptr >> 7;
        *(_DWORD *)(a1 + 224) = v32;
        *(_DWORD *)(a1 + 228) = v54 | (_byteswap_ushort(v53) << 8);
        goto LABEL_8;
      }
    }
    else
    {
      v34 = v30 - 1;
      *(_DWORD *)(a1 + 216) = v34;
      if ( fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 8LL * v34 + 168), 0) )
        goto LABEL_11;
      if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
      {
        result = 0;
        v35 = ptr & 0x7F;
        *(_DWORD *)(a1 + 220) = ptr >> 7;
        *(_DWORD *)(a1 + 224) = v35;
        *(_DWORD *)(a1 + 228) = v54 | (_byteswap_ushort(v53) << 8);
        return result;
      }
    }
    v9 = 6;
    goto LABEL_12;
  }
  v5 = 0;
  v7 = -1;
  v6 = *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168);
  if ( a3 )
    goto LABEL_5;
LABEL_9:
  v8 = 1;
LABEL_10:
  if ( fseeko(*(FILE **)a1, 0, 0) )
  {
LABEL_11:
    v9 = 7;
LABEL_12:
    result = 0;
    *(_DWORD *)(a1 + 160) = v9;
    return result;
  }
  if ( !(unsigned int)sub_23DF4(
                        *(const char **)(a1 + 8),
                        *(const char **)(a1 + 16),
                        &s,
                        (const char **)&name,
                        (int *)(a1 + 160)) )
  {
    v25 = s;
    if ( !s )
      goto LABEL_48;
    goto LABEL_47;
  }
  v48 = v8;
  v11 = (_DWORD *)(a1 + 160);
  off = v7;
  if ( v6 >= 1 )
  {
    v12 = *(FILE **)a1;
    v13 = s;
    while ( 1 )
    {
      if ( (unsigned __int64)v6 >= 0x2000 )
        v14 = 0x2000;
      else
        v14 = v6;
      if ( fread(&ptr, 1u, v14, v12) != v14 )
      {
        *v11 = 6;
        v25 = s;
        if ( !s )
          goto LABEL_48;
        goto LABEL_47;
      }
      if ( fwrite(&ptr, 1u, v14, v13) != v14 )
        break;
      v6 -= v14;
      if ( v6 < 1 )
        goto LABEL_22;
    }
    *v11 = 8;
    v25 = s;
    if ( !s )
      goto LABEL_48;
LABEL_47:
    fclose(v25);
    s = 0;
    goto LABEL_48;
  }
LABEL_22:
  v15 = (int *)(a1 + 160);
  if ( !a2 )
    goto LABEL_29;
  v16 = s;
  v17 = a2[2];
  if ( v17 >= 0x1000000
    || (a2[1] ? (v18 = 0x80) : (v18 = 0),
        ptr = v18 | *a2,
        HIBYTE(v53) = BYTE1(v17),
        v54 = v17,
        LOBYTE(v53) = BYTE2(v17),
        v19 = fwrite(&ptr, 1u, 4u, s),
        v16 = s,
        v19 != 4) )
  {
    *v11 = 8;
    if ( !v16 )
      goto LABEL_48;
    goto LABEL_43;
  }
  v20 = sub_23FA4((__int64)s, (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite, (__int64)a2);
  *v11 = 8 * (v20 == 0);
  if ( !v20 )
  {
    if ( !v16 )
      goto LABEL_48;
LABEL_43:
    v25 = v16;
    goto LABEL_47;
  }
LABEL_29:
  v21 = *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168);
  if ( fseeko(*(FILE **)a1, v21 + *(unsigned int *)(a1 + 228) + 4, 0) )
  {
    v22 = s;
    if ( !s )
    {
LABEL_32:
      v23 = name;
      if ( name )
      {
        unlink(name);
        free(v23);
        name = 0;
      }
LABEL_34:
      v24 = 7;
      goto LABEL_35;
    }
LABEL_31:
    fclose(v22);
    s = 0;
    goto LABEL_32;
  }
  v36 = *(FILE **)a1;
  v37 = s;
  do
  {
    while ( 1 )
    {
      if ( feof(v36) )
      {
        if ( v5 )
        {
          v39 = s;
          if ( fseeko(s, off, 0) )
          {
LABEL_65:
            if ( !v39 )
              goto LABEL_32;
            v22 = v39;
            goto LABEL_31;
          }
          if ( fread(&ptr, 1u, 1u, v39) != 1 )
          {
            if ( s )
            {
              fclose(s);
              s = 0;
            }
            v46 = name;
            if ( name )
            {
              unlink(name);
              free(v46);
              name = 0;
            }
LABEL_93:
            v24 = 6;
LABEL_35:
            result = 0;
            *v15 = v24;
            return result;
          }
          v39 = s;
          v40 = ptr | 0x80;
          if ( v5 > 0 )
            v40 = ptr & 0x7F;
          ptr = v40;
          if ( fseeko(s, off, 0) )
            goto LABEL_65;
          if ( fwrite(&ptr, 1u, 1u, v39) != 1 )
          {
            if ( s )
            {
              fclose(s);
              s = 0;
            }
            v47 = name;
            if ( name )
            {
              unlink(name);
              free(v47);
              name = 0;
            }
            v24 = 8;
            goto LABEL_35;
          }
        }
        v41 = v21;
        fclose(*(FILE **)a1);
        v42 = *(const char **)(a1 + 8);
        fclose(s);
        v43 = name;
        s = 0;
        v44 = rename(name, v42);
        if ( v43 )
        {
          unlink(v43);
          free(v43);
          name = 0;
        }
        if ( v44 )
        {
          v24 = 9;
          goto LABEL_35;
        }
        if ( *(_DWORD *)(a1 + 152) )
          sub_21B50(*(const char **)(a1 + 8), a1 + 24);
        result = (__int64)sub_1F628(a1, *(_DWORD *)(a1 + 156) == 0);
        if ( !(_DWORD)result )
          return result;
        if ( !a2 )
        {
          while ( *(_QWORD *)(a1 + 8LL * *(unsigned int *)(a1 + 216) + 168) + *(unsigned int *)(a1 + 228) + 4LL < v41 )
          {
            result = FLAC__metadata_simple_iterator_next(a1);
            if ( !(_DWORD)result )
              return result;
          }
          if ( (v48 & 1) == 0 )
            return FLAC__metadata_simple_iterator_next(a1);
          return 1;
        }
        *(_QWORD *)(a1 + 168) = v41;
        if ( fseeko(*(FILE **)a1, *(_QWORD *)(a1 + 168 + 8LL * *(unsigned int *)(a1 + 216)), 0) )
          goto LABEL_34;
        if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
        {
          v45 = ptr & 0x7F;
          *(_DWORD *)(a1 + 220) = ptr >> 7;
          *(_DWORD *)(a1 + 224) = v45;
          *(_DWORD *)(a1 + 228) = v54 | (_byteswap_ushort(v53) << 8);
          if ( (v48 & 1) == 0 )
            return FLAC__metadata_simple_iterator_next(a1);
          return 1;
        }
        goto LABEL_93;
      }
      v38 = fread(&ptr, 1u, 0x2000u, v36);
      if ( !v38 )
        break;
      if ( fwrite(&ptr, 1u, v38, v37) != v38 )
      {
        *v11 = 8;
        v25 = s;
        if ( !s )
          goto LABEL_48;
        goto LABEL_47;
      }
    }
  }
  while ( feof(v36) );
  *v11 = 6;
  v25 = s;
  if ( s )
    goto LABEL_47;
LABEL_48:
  v33 = name;
  if ( !name )
    return 0;
  unlink(name);
  free(v33);
  result = 0;
  name = 0;
  return result;
}

//----- (00000000000208EC) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_simple_iterator_insert_block_after(__int64 a1, _DWORD *a2, int a3)
{
  int v4; // w21
  int v6; // w8
  __int64 v7; // x8
  __int64 v8; // x10
  unsigned int v9; // w8
  int v10; // w9
  int v11; // w24
  int v12; // w22
  int v13; // w8
  FILE *v14; // x0
  unsigned int v15; // w8
  int v16; // w8
  FILE *v17; // x0
  unsigned int v18; // w8
  int v19; // w8
  unsigned __int8 ptr; // [xsp+4h] [xbp-3Ch] BYREF
  unsigned __int16 v22; // [xsp+5h] [xbp-3Bh]
  unsigned __int8 v23; // [xsp+7h] [xbp-39h]
  __int64 v24; // [xsp+8h] [xbp-38h]

  v4 = a3;
  v24 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !*(_DWORD *)(a1 + 156) )
  {
    v13 = 4;
LABEL_25:
    *(_DWORD *)(a1 + 160) = v13;
    return 0;
  }
  if ( !*a2 )
  {
    v13 = 1;
    goto LABEL_25;
  }
  v6 = *(_DWORD *)(a1 + 220);
  a2[1] = v6;
  if ( !a3 || v6 )
    return sub_201A0(a1, a2, 1);
  v7 = *(unsigned int *)(a1 + 216);
  v8 = *(_QWORD *)(a1 + 168 + 8 * v7);
  LODWORD(v7) = v7 + 1;
  *(_QWORD *)(a1 + 168 + 8LL * (unsigned int)v7) = v8;
  *(_DWORD *)(a1 + 216) = v7;
  if ( !(unsigned int)FLAC__metadata_simple_iterator_next(a1) )
  {
    v14 = *(FILE **)a1;
    v15 = *(_DWORD *)(a1 + 216) - 1;
    *(_DWORD *)(a1 + 216) = v15;
    if ( fseeko(v14, *(_QWORD *)(a1 + 8LL * v15 + 168), 0) )
    {
LABEL_17:
      v13 = 7;
      goto LABEL_25;
    }
    if ( fread(&ptr, 1u, 4u, *(FILE **)a1) == 4 )
    {
      v16 = ptr & 0x7F;
      *(_DWORD *)(a1 + 220) = ptr >> 7;
      *(_DWORD *)(a1 + 224) = v16;
      *(_DWORD *)(a1 + 228) = v23 | (_byteswap_ushort(v22) << 8);
      return 0;
    }
LABEL_24:
    v13 = 6;
    goto LABEL_25;
  }
  if ( *(_DWORD *)(a1 + 224) != 1 )
    goto LABEL_15;
  v9 = *(_DWORD *)(a1 + 228);
  v10 = a2[2];
  v11 = v9 - v10;
  if ( v9 == v10 )
  {
    v12 = 0;
    a2[1] = *(_DWORD *)(a1 + 220);
    goto LABEL_16;
  }
  if ( v9 >= v10 + 4 )
  {
    v12 = *(_DWORD *)(a1 + 220);
    a2[1] = 0;
  }
  else
  {
LABEL_15:
    v4 = 0;
    v11 = 0;
    v12 = 0;
  }
LABEL_16:
  v17 = *(FILE **)a1;
  v18 = *(_DWORD *)(a1 + 216) - 1;
  *(_DWORD *)(a1 + 216) = v18;
  if ( fseeko(v17, *(_QWORD *)(a1 + 8LL * v18 + 168), 0) )
    goto LABEL_17;
  if ( fread(&ptr, 1u, 4u, *(FILE **)a1) != 4 )
    goto LABEL_24;
  v19 = ptr & 0x7F;
  *(_DWORD *)(a1 + 220) = ptr >> 7;
  *(_DWORD *)(a1 + 224) = v19;
  *(_DWORD *)(a1 + 228) = v23 | (_byteswap_ushort(v22) << 8);
  if ( !v4 )
    return sub_201A0(a1, a2, 1);
  if ( !(unsigned int)FLAC__metadata_simple_iterator_next(a1) )
    return 0;
  if ( v11 )
    return sub_1FF2C(a1, a2, v11 - 4, v12);
  else
    return sub_1FD90(a1, a2);
}

//----- (0000000000020B60) ----------------------------------------------------
int *__fastcall FLAC__metadata_simple_iterator_delete_block(_DWORD *a1, int a2)
{
  int *result; // x0
  int *v4; // x20
  int v5; // w8
  int v6; // w9
  int v7; // w21
  int v8; // w8

  if ( !a1[39] )
  {
    result = 0;
    a1[40] = 4;
    return result;
  }
  if ( !a1[56] )
  {
    result = 0;
    a1[40] = 1;
    return result;
  }
  if ( !a2 )
    return (int *)sub_201A0((__int64)a1, 0, 0);
  result = (int *)FLAC__metadata_object_new(1u);
  v4 = result;
  if ( !result )
  {
    a1[40] = 11;
    return result;
  }
  result[2] = a1[57];
  if ( !a1[39] )
  {
    v8 = 4;
LABEL_17:
    a1[40] = v8;
    FLAC__metadata_object_delete(result);
    return 0;
  }
  v5 = a1[56];
  v6 = *result;
  if ( (!v5 || !v6) && v5 != v6 )
  {
    v8 = 1;
    goto LABEL_17;
  }
  result[1] = a1[55];
  v7 = sub_1FD90((__int64)a1, result);
  FLAC__metadata_object_delete(v4);
  if ( v7 )
    return (int *)((unsigned int)FLAC__metadata_simple_iterator_prev((__int64)a1) != 0);
  else
    return 0;
}

//----- (0000000000020CB0) ----------------------------------------------------
_QWORD *FLAC__metadata_chain_new()
{
  _QWORD *result; // x0

  result = calloc(1u, 0x50u);
  if ( result )
  {
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  return result;
}

//----- (0000000000020CD8) ----------------------------------------------------
void __fastcall FLAC__metadata_chain_delete(__int64 a1)
{
  __int64 v2; // x20
  __int64 v3; // x21

  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 )
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 16);
      if ( *(_QWORD *)v2 )
        FLAC__metadata_object_delete(*(void **)v2);
      free((void *)v2);
      v2 = v3;
    }
    while ( v3 );
  }
  if ( *(_QWORD *)a1 )
    free(*(void **)a1);
  free((void *)a1);
}

//----- (0000000000020D34) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_status(__int64 a1)
{
  unsigned int v1; // w8

  v1 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = 0;
  return v1;
}

//----- (0000000000020D44) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_read(__int64 a1, const char *a2)
{
  __int64 v3; // x21
  _QWORD *v4; // x22
  __int64 v6; // x23
  char *v7; // x0
  FILE *v8; // x20
  unsigned int v9; // w19
  __int64 result; // x0
  int v11; // w8

  v4 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 )
  {
    do
    {
      v6 = *(_QWORD *)(v3 + 16);
      if ( *(_QWORD *)v3 )
        FLAC__metadata_object_delete(*(void **)v3);
      free((void *)v3);
      v3 = v6;
    }
    while ( v6 );
  }
  if ( *(_QWORD *)a1 )
    free(*(void **)a1);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v7 = strdup(a2);
  *(_QWORD *)a1 = v7;
  if ( v7 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    v8 = fopen(a2, "rb");
    if ( v8 )
    {
      v9 = (unsigned int)sub_2287C(
                           a1,
                           (__int64)v8,
                           (__int64 (*)(void))&fread,
                           (__int64 (__fastcall *)(__int64, __int64, __int64))j__fseeko,
                           (__int64 (__fastcall *)(__int64))j__ftello);
      fclose(v8);
      return v9;
    }
    v11 = 2;
  }
  else
  {
    v11 = 11;
  }
  result = 0;
  *(_DWORD *)(a1 + 36) = v11;
  return result;
}

//----- (0000000000020E3C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_read_ogg(__int64 a1, const char *a2)
{
  __int64 v3; // x21
  _QWORD *v4; // x22
  __int64 v6; // x23
  char *v7; // x0
  FILE *v8; // x20
  unsigned int v9; // w19
  __int64 result; // x0
  int v11; // w8

  v4 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 )
  {
    do
    {
      v6 = *(_QWORD *)(v3 + 16);
      if ( *(_QWORD *)v3 )
        FLAC__metadata_object_delete(*(void **)v3);
      free((void *)v3);
      v3 = v6;
    }
    while ( v6 );
  }
  if ( *(_QWORD *)a1 )
    free(*(void **)a1);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v7 = strdup(a2);
  *(_QWORD *)a1 = v7;
  if ( v7 )
  {
    *(_DWORD *)(a1 + 8) = 1;
    v8 = fopen(a2, "rb");
    if ( v8 )
    {
      v9 = (unsigned int)sub_22764(a1, (__int64)v8, (__int64)&fread);
      fclose(v8);
      return v9;
    }
    v11 = 2;
  }
  else
  {
    v11 = 11;
  }
  result = 0;
  *(_DWORD *)(a1 + 36) = v11;
  return result;
}

//----- (0000000000020F28) ----------------------------------------------------
void **__fastcall FLAC__metadata_chain_read_with_callbacks(__int64 a1, __int64 a2, _OWORD *a3)
{
  _OWORD v4[3]; // [xsp+0h] [xbp-50h] BYREF
  __int64 v5; // [xsp+38h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4[2] = a3[2];
  v4[1] = a3[1];
  v4[0] = *a3;
  return sub_20F8C(a1, a2, (__int64)v4, 0);
}

//----- (0000000000020F8C) ----------------------------------------------------
void **__fastcall sub_20F8C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v5; // x23
  _QWORD *v6; // x24
  __int64 v10; // x25
  unsigned int (__fastcall *v11)(__int64, _QWORD, _QWORD); // x8
  int v12; // w8
  __int64 (*v14)(void); // x2

  v6 = (_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  if ( v5 )
  {
    do
    {
      v10 = *(_QWORD *)(v5 + 16);
      if ( *(_QWORD *)v5 )
        FLAC__metadata_object_delete(*(void **)v5);
      free((void *)v5);
      v5 = v10;
    }
    while ( v10 );
  }
  if ( *(_QWORD *)a1 )
    free(*(void **)a1);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = 0;
  if ( !*(_QWORD *)a3
    || (v11 = *(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD))(a3 + 16)) == 0
    || !*(_QWORD *)(a3 + 24) )
  {
    v12 = 13;
    goto LABEL_13;
  }
  *(_DWORD *)(a1 + 8) = a4;
  if ( v11(a2, 0, 0) )
  {
    v12 = 7;
LABEL_13:
    *(_DWORD *)(a1 + 36) = v12;
    return 0;
  }
  v14 = *(__int64 (**)(void))a3;
  if ( a4 )
    return sub_22764(a1, a2, (__int64)v14);
  else
    return sub_2287C(
             a1,
             a2,
             v14,
             *(__int64 (__fastcall **)(__int64, __int64, __int64))(a3 + 16),
             *(__int64 (__fastcall **)(__int64))(a3 + 24));
}

//----- (00000000000210AC) ----------------------------------------------------
void **__fastcall FLAC__metadata_chain_read_ogg_with_callbacks(__int64 a1, __int64 a2, _OWORD *a3)
{
  _OWORD v4[3]; // [xsp+0h] [xbp-50h] BYREF
  __int64 v5; // [xsp+38h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4[2] = a3[2];
  v4[1] = a3[1];
  v4[0] = *a3;
  return sub_20F8C(a1, a2, (__int64)v4, 1);
}

//----- (0000000000021110) ----------------------------------------------------
bool __fastcall FLAC__metadata_chain_check_if_tempfile_needed(_QWORD *a1, int a2)
{
  _QWORD *v2; // x8
  __int64 v3; // x9
  __int64 *v4; // x10
  __int64 v5; // x11
  __int64 v6; // x10
  __int64 v7; // x11
  unsigned int v8; // w9
  int v9; // w10
  bool v10; // cc
  __int64 v11; // x9
  __int64 v12; // x10
  _QWORD *v13; // x14
  __int64 v14; // x11
  unsigned int v15; // w15
  unsigned int v16; // w16
  unsigned int v17; // w14
  int v19; // w8

  v2 = (_QWORD *)a1[2];
  if ( v2 )
  {
    v3 = 0;
    v4 = (__int64 *)a1[2];
    do
    {
      v5 = *v4;
      v4 = (__int64 *)v4[2];
      v3 += (unsigned int)(*(_DWORD *)(v5 + 8) + 4);
    }
    while ( v4 );
    if ( !a2 )
      goto LABEL_16;
  }
  else
  {
    v3 = 0;
    if ( !a2 )
      goto LABEL_16;
  }
  v6 = a1[7];
  v7 = a1[3];
  if ( v3 >= v6 || **(_DWORD **)v7 != 1 )
  {
    if ( v6 >= v3 + 4 )
    {
      v8 = v6 - (v3 + 4);
      v9 = 2;
      if ( !v2 )
        goto LABEL_27;
      goto LABEL_17;
    }
    v10 = v3 <= v6;
    v11 = v3 - v6;
    if ( !v10 && **(_DWORD **)v7 == 1 )
    {
      v12 = *(unsigned int *)(*(_QWORD *)v7 + 8LL);
      if ( v12 + 4 == v11 )
      {
        v8 = 0;
        v9 = 3;
        if ( v2 )
          goto LABEL_17;
LABEL_27:
        v14 = 0;
LABEL_43:
        if ( v9 == 2 )
        {
          if ( v8 >= 0x1000000 )
            v19 = 0xFFFFFF;
          else
            v19 = v8;
          v14 += (unsigned int)(v19 + 4);
        }
        return v14 != a1[7];
      }
      if ( v11 <= v12 )
      {
        v8 = v12 - v11;
        v9 = 1;
        if ( v2 )
          goto LABEL_17;
        goto LABEL_27;
      }
    }
LABEL_16:
    v9 = 0;
    v8 = 0;
    if ( !v2 )
      goto LABEL_27;
    goto LABEL_17;
  }
  v8 = v6 - v3 + *(_DWORD *)(*(_QWORD *)v7 + 8LL);
  v9 = 1;
  if ( !v2 )
    goto LABEL_27;
LABEL_17:
  v13 = (_QWORD *)a1[3];
  if ( (v9 & 3) == 3 )
  {
    v14 = 0;
    while ( 1 )
    {
      if ( v2 != v13 )
      {
        v16 = *(_DWORD *)(*v2 + 8LL);
        if ( v16 >= 0x1000000 )
        {
          v16 = 0xFFFFFF;
          if ( *(_DWORD *)*v2 != 1 )
            return 0;
        }
        v14 += v16 + 4;
      }
      v2 = (_QWORD *)v2[2];
      if ( !v2 )
        goto LABEL_43;
    }
  }
  if ( (v9 & 3) == 1 )
  {
    v14 = 0;
    while ( 1 )
    {
      v15 = *(_DWORD *)(*v2 + 8LL);
      if ( v2 == v13 )
        v15 = v8;
      if ( v15 >= 0x1000000 )
      {
        v15 = 0xFFFFFF;
        if ( *(_DWORD *)*v2 != 1 )
          break;
      }
      v2 = (_QWORD *)v2[2];
      v14 += v15 + 4;
      if ( !v2 )
        goto LABEL_43;
    }
  }
  else
  {
    v14 = 0;
    while ( 1 )
    {
      v17 = *(_DWORD *)(*v2 + 8LL);
      if ( v17 >= 0x1000000 )
      {
        v17 = 0xFFFFFF;
        if ( *(_DWORD *)*v2 != 1 )
          break;
      }
      v14 += v17 + 4;
      v2 = (_QWORD *)v2[2];
      if ( !v2 )
        goto LABEL_43;
    }
  }
  return 0;
}

//----- (0000000000021380) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_write(__int64 a1, int a2, int a3)
{
  __int64 result; // x0
  __int64 v6; // x23
  const char *v7; // x0
  FILE *v8; // x21
  int v9; // w27
  int v10; // w8
  int v11; // w8
  FILE *v12; // x22
  const char *v13; // x24
  size_t v14; // x0
  size_t v15; // x25
  size_t v16; // x0
  char *v17; // x0
  char *v18; // x21
  FILE *v19; // x24
  __int64 v20; // x27
  size_t v21; // x25
  __int64 *v22; // x27
  unsigned int v23; // w8
  char v24; // w10
  __int64 *v25; // x23
  unsigned int v26; // w8
  char v27; // w10
  size_t v28; // x25
  const char *v29; // x22
  __int64 v30; // x8
  __int64 *v31; // x9
  __int64 v32; // x10
  _BYTE v33[128]; // [xsp+8h] [xbp-20D8h] BYREF
  char ptr; // [xsp+88h] [xbp-2058h] BYREF
  char v35; // [xsp+89h] [xbp-2057h]
  char v36; // [xsp+8Ah] [xbp-2056h]
  char v37; // [xsp+8Bh] [xbp-2055h]
  __int64 v38; // [xsp+2088h] [xbp-58h]

  v38 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( *(_DWORD *)(a1 + 8) )
  {
    result = 0;
    *(_DWORD *)(a1 + 36) = 12;
    return result;
  }
  if ( !*(_QWORD *)a1 )
  {
    v11 = 14;
    result = 0;
LABEL_37:
    *(_DWORD *)(a1 + 36) = v11;
    return result;
  }
  result = sub_21864(a1, a2);
  v6 = result;
  if ( !result )
    return result;
  if ( a3 )
    stat(*(const char **)a1, (struct stat *)v33);
  v7 = *(const char **)a1;
  if ( v6 != *(_QWORD *)(a1 + 56) )
  {
    result = (__int64)fopen(v7, "rb");
    v12 = (FILE *)result;
    if ( !result )
      goto LABEL_36;
    v13 = *(const char **)a1;
    v14 = strlen(*(const char **)a1);
    v15 = v14 + 15;
    if ( v14 == -15 )
      v16 = 1;
    else
      v16 = v14 + 15;
    v17 = (char *)malloc(v16);
    v18 = v17;
    if ( v17 )
    {
      sub_23F0C(v17, v15, "%s%s", v13, ".metadata_edit");
      v19 = fopen(v18, "w+b");
      if ( v19 )
      {
        v20 = *(_QWORD *)(a1 + 40);
        if ( v20 < 1 )
        {
LABEL_26:
          v22 = *(__int64 **)(a1 + 16);
          if ( v22 )
          {
            while ( 1 )
            {
              v23 = *(_DWORD *)(*v22 + 8);
              if ( v23 >= 0x1000000 )
                break;
              v24 = *(_DWORD *)(*v22 + 4) ? 0x80 : 0;
              ptr = v24 | *(_DWORD *)*v22;
              v36 = BYTE1(v23);
              v37 = v23;
              v35 = BYTE2(v23);
              if ( fwrite(&ptr, 1u, 4u, v19) != 4
                || !(unsigned int)sub_23FA4(
                                    (__int64)v19,
                                    (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite,
                                    *v22) )
              {
                break;
              }
              v22 = (__int64 *)v22[2];
              if ( !v22 )
                goto LABEL_34;
            }
LABEL_59:
            *(_DWORD *)(a1 + 36) = 8;
            fclose(v12);
          }
          else
          {
LABEL_34:
            if ( !fseeko(v12, *(_QWORD *)(a1 + 48), 0) )
            {
              while ( !feof(v12) )
              {
                v28 = fread(&ptr, 1u, 0x2000u, v12);
                if ( v28 )
                {
                  if ( fwrite(&ptr, 1u, v28, v19) != v28 )
                    goto LABEL_59;
                }
                else if ( !feof(v12) )
                {
                  goto LABEL_57;
                }
              }
              fclose(v12);
              v29 = *(const char **)a1;
              fclose(v19);
              LODWORD(v29) = rename(v18, v29);
              unlink(v18);
              free(v18);
              if ( !(_DWORD)v29 )
              {
                v30 = *(_QWORD *)(a1 + 40);
                v31 = *(__int64 **)(a1 + 16);
                *(_QWORD *)(a1 + 48) = v30;
                *(_QWORD *)(a1 + 56) = v6;
                if ( v31 )
                {
                  do
                  {
                    v32 = *v31;
                    v31 = (__int64 *)v31[2];
                    v30 += (unsigned int)(*(_DWORD *)(v32 + 8) + 4);
                  }
                  while ( v31 );
                  *(_QWORD *)(a1 + 48) = v30;
                }
                if ( !a3 )
                  return 1;
                goto LABEL_64;
              }
              return 0;
            }
            *(_DWORD *)(a1 + 36) = 7;
            fclose(v12);
          }
        }
        else
        {
          while ( 1 )
          {
            v21 = (unsigned __int64)v20 >= 0x2000 ? 0x2000LL : v20;
            if ( fread(&ptr, 1u, v21, v12) != v21 )
              break;
            if ( fwrite(&ptr, 1u, v21, v19) != v21 )
              goto LABEL_59;
            v20 -= v21;
            if ( v20 < 1 )
              goto LABEL_26;
          }
LABEL_57:
          *(_DWORD *)(a1 + 36) = 6;
          fclose(v12);
        }
        fclose(v19);
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 2;
        fclose(v12);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 36) = 11;
      fclose(v12);
    }
    if ( v18 )
    {
      unlink(v18);
      free(v18);
    }
    return 0;
  }
  result = (__int64)fopen(v7, "r+b");
  v8 = (FILE *)result;
  if ( !result )
  {
LABEL_36:
    v11 = 2;
    goto LABEL_37;
  }
  if ( fseeko((FILE *)result, *(_QWORD *)(a1 + 40), 0) )
  {
    v9 = 1;
    v10 = 7;
  }
  else
  {
    v25 = *(__int64 **)(a1 + 16);
    if ( v25 )
    {
      while ( 1 )
      {
        v26 = *(_DWORD *)(*v25 + 8);
        if ( v26 >= 0x1000000 )
          break;
        if ( *(_DWORD *)(*v25 + 4) )
          v27 = 0x80;
        else
          v27 = 0;
        ptr = v27 | *(_DWORD *)*v25;
        v36 = BYTE1(v26);
        v37 = v26;
        v35 = BYTE2(v26);
        v9 = 1;
        if ( fwrite(&ptr, 1u, 4u, v8) != 4 )
          goto LABEL_61;
        if ( !(unsigned int)sub_23FA4(
                              (__int64)v8,
                              (__int64 (__fastcall *)(char *, __int64, __int64, __int64))&fwrite,
                              *v25) )
          break;
        v25 = (__int64 *)v25[2];
        if ( !v25 )
          goto LABEL_46;
      }
      v9 = 1;
LABEL_61:
      v10 = 8;
    }
    else
    {
LABEL_46:
      v10 = 0;
      v9 = 0;
    }
  }
  *(_DWORD *)(a1 + 36) = v10;
  fclose(v8);
  result = v9 ^ 1u;
  if ( (v9 & 1) == 0 && a3 )
  {
LABEL_64:
    sub_21B50(*(const char **)a1, (__int64)v33);
    return 1;
  }
  return result;
}
// 21794: conditional instruction was optimized away because x24.8==0
// 21600: conditional instruction was optimized away because x24.8!=0
// 2177C: conditional instruction was optimized away because x24.8!=0
// 217AC: conditional instruction was optimized away because x24.8!=0

//----- (0000000000021864) ----------------------------------------------------
__int64 __fastcall sub_21864(__int64 a1, int a2)
{
  __int64 *v3; // x8
  _QWORD *v4; // x21
  __int64 result; // x0
  __int64 *v6; // x9
  __int64 v7; // x10
  __int64 v8; // x9
  _DWORD *v9; // x10
  _QWORD *v10; // x8
  int v11; // w22
  __int64 v12; // x11
  __int64 v13; // x10
  __int64 *v14; // x20
  _DWORD *v15; // x12
  __int64 v16; // x13
  bool v17; // zf
  _QWORD *v18; // x8
  _QWORD *v19; // x9
  __int64 *v20; // x8
  __int64 v21; // x9
  _DWORD *v22; // x20
  __int64 *v23; // x0
  _QWORD *v24; // x8
  int v25; // w9
  __int64 *v26; // x8
  int v27; // w8
  int v28; // w8
  __int64 v29; // x9
  _QWORD *v30; // x11
  _DWORD *v31; // x12
  __int64 *v32; // x12
  __int64 v33; // x13

  v4 = (_QWORD *)(a1 + 16);
  v3 = *(__int64 **)(a1 + 16);
  if ( v3 )
  {
    result = 0;
    v6 = v3;
    do
    {
      v7 = *v6;
      v6 = (__int64 *)v6[2];
      result += (unsigned int)(*(_DWORD *)(v7 + 8) + 4);
    }
    while ( v6 );
    if ( !a2 )
      goto LABEL_41;
  }
  else
  {
    result = 0;
    if ( !a2 )
      goto LABEL_41;
  }
  v8 = *(_QWORD *)(a1 + 56);
  if ( result < v8 )
  {
    v9 = **(_DWORD ***)(a1 + 24);
    if ( *v9 == 1 )
    {
      v9[2] += v8 - result;
      goto LABEL_8;
    }
  }
  v11 = result + 4;
  if ( result + 4 <= v8 )
  {
    v22 = FLAC__metadata_object_new(1u);
    if ( v22 )
    {
      v22[2] = *(_DWORD *)(a1 + 56) - v11;
      v23 = (__int64 *)calloc(1u, 0x18u);
      if ( v23 )
      {
        v23[1] = 0;
        v23[2] = 0;
        *v23 = (__int64)v22;
        v22[1] = 1;
        v24 = *(_QWORD **)(a1 + 24);
        if ( v24 )
          *(_DWORD *)(*v24 + 4LL) = 0;
        if ( *v4 )
        {
          v24[2] = v23;
          v23[1] = (__int64)v24;
          v25 = *(_DWORD *)(a1 + 32);
          v26 = *(__int64 **)(a1 + 16);
          *(_QWORD *)(a1 + 24) = v23;
          *(_DWORD *)(a1 + 32) = v25 + 1;
          if ( !v26 )
          {
            result = 0;
            v10 = (_QWORD *)*v4;
            if ( !*v4 )
              return result;
            goto LABEL_42;
          }
        }
        else
        {
          v28 = *(_DWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 16) = v23;
          *(_QWORD *)(a1 + 24) = v23;
          *(_DWORD *)(a1 + 32) = v28 + 1;
          v26 = v23;
        }
        result = 0;
        do
        {
          v29 = *v26;
          v26 = (__int64 *)v26[2];
          result += (unsigned int)(*(_DWORD *)(v29 + 8) + 4);
        }
        while ( v26 );
LABEL_41:
        v10 = (_QWORD *)*v4;
        if ( !*v4 )
          return result;
        goto LABEL_42;
      }
      FLAC__metadata_object_delete(v22);
    }
    v27 = 11;
    goto LABEL_51;
  }
  v12 = result - v8;
  if ( result <= v8 )
    goto LABEL_41;
  v13 = a1 + 24;
  v14 = *(__int64 **)(a1 + 24);
  v15 = (_DWORD *)*v14;
  if ( *(_DWORD *)*v14 != 1 )
    goto LABEL_41;
  v16 = (unsigned int)v15[2];
  if ( v16 + 4 == v12 )
  {
    v17 = v3 == v14;
    v18 = v4;
    if ( !v17 )
      v18 = (_QWORD *)(v14[1] + 16);
    *v18 = v14[2];
    v19 = (_QWORD *)(a1 + 24);
    if ( *(__int64 **)v13 != v14 )
      v19 = (_QWORD *)(v14[2] + 8);
    *v19 = v14[1];
    if ( *(_QWORD *)v13 )
      *(_DWORD *)(**(_QWORD **)v13 + 4LL) = 1;
    --*(_DWORD *)(a1 + 32);
    if ( *v14 )
      FLAC__metadata_object_delete((void *)*v14);
    free(v14);
    v20 = (__int64 *)*v4;
    if ( !*v4 )
      return 0;
    result = 0;
    do
    {
      v21 = *v20;
      v20 = (__int64 *)v20[2];
      result += (unsigned int)(*(_DWORD *)(v21 + 8) + 4);
    }
    while ( v20 );
    goto LABEL_41;
  }
  if ( v12 > v16 )
    goto LABEL_41;
  v15[2] = v16 - v12;
LABEL_8:
  result = v8;
  v10 = (_QWORD *)*v4;
  if ( !*v4 )
    return result;
LABEL_42:
  v30 = v10;
  while ( 1 )
  {
    v31 = (_DWORD *)*v30;
    if ( *(_DWORD *)(*v30 + 8LL) >= 0x1000000u )
      break;
LABEL_48:
    v30 = (_QWORD *)v30[2];
    if ( !v30 )
      return result;
  }
  if ( *v31 == 1 )
  {
    result = 0;
    v31[2] = 0xFFFFFF;
    if ( v10 )
    {
      v32 = v10;
      do
      {
        v33 = *v32;
        v32 = (__int64 *)v32[2];
        result += (unsigned int)(*(_DWORD *)(v33 + 8) + 4);
      }
      while ( v32 );
    }
    goto LABEL_48;
  }
  v27 = 5;
LABEL_51:
  result = 0;
  *(_DWORD *)(a1 + 36) = v27;
  return result;
}

//----- (0000000000021B50) ----------------------------------------------------
__int64 __fastcall sub_21B50(const char *a1, __int64 a2)
{
  int *v4; // x0
  char *v5; // x0
  __int64 result; // x0
  int *v7; // x0
  char *v8; // x0
  utimbuf file_times; // [xsp+8h] [xbp-38h] BYREF
  __int64 v10; // [xsp+18h] [xbp-28h]

  v10 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  file_times.actime = *(_QWORD *)(a2 + 72);
  file_times.modtime = *(_QWORD *)(a2 + 88);
  chmod(a1, *(_DWORD *)(a2 + 16));
  utime(a1, &file_times);
  if ( chown(a1, *(_DWORD *)(a2 + 24), 0xFFFFFFFF) < 0 )
  {
    v4 = (int *)__errno();
    v5 = strerror(*v4);
    fprintf((FILE *)((char *)&_sF + 304), "%s : %s\n", "chown(filename, stats->st_uid, -1)", v5);
  }
  result = chown(a1, 0xFFFFFFFF, *(_DWORD *)(a2 + 28));
  if ( (result & 0x80000000) != 0 )
  {
    v7 = (int *)__errno();
    v8 = strerror(*v7);
    return fprintf((FILE *)((char *)&_sF + 304), "%s : %s\n", "chown(filename, -1, stats->st_gid)", v8);
  }
  return result;
}
// 11850: using guessed type __int64 __errno(void);

//----- (0000000000021C4C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_write_with_callbacks(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  int v9; // w8
  __int64 (__fastcall *v10)(char *, __int64, __int64, __int64); // x21
  __int64 *v11; // x22
  unsigned int v12; // w8
  char v13; // w10
  _BYTE v14[4]; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v15; // [xsp+8h] [xbp-48h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( *(_DWORD *)(a1 + 8) )
  {
    result = 0;
    v9 = 12;
LABEL_10:
    *(_DWORD *)(a1 + 36) = v9;
    return result;
  }
  if ( *(_QWORD *)a1 )
  {
    result = 0;
    v9 = 14;
    goto LABEL_10;
  }
  if ( !*(_QWORD *)(a4 + 8) || !*(_QWORD *)(a4 + 16) )
  {
    result = 0;
    v9 = 13;
    goto LABEL_10;
  }
  if ( FLAC__metadata_chain_check_if_tempfile_needed((_QWORD *)a1, a2) )
  {
    result = 0;
    v9 = 15;
    goto LABEL_10;
  }
  result = sub_21864(a1, a2);
  if ( result )
  {
    v10 = *(__int64 (__fastcall **)(char *, __int64, __int64, __int64))(a4 + 8);
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD))(a4 + 16))(a3, *(_QWORD *)(a1 + 40), 0) )
    {
      result = 0;
      v9 = 7;
    }
    else
    {
      v11 = *(__int64 **)(a1 + 16);
      result = 1;
      if ( v11 )
      {
        while ( 1 )
        {
          v12 = *(_DWORD *)(*v11 + 8);
          if ( v12 >= 0x1000000 )
            break;
          v13 = *(_DWORD *)(*v11 + 4) ? 0x80 : 0;
          v14[0] = v13 | *(_DWORD *)*v11;
          v14[2] = BYTE1(v12);
          v14[3] = v12;
          v14[1] = BYTE2(v12);
          if ( v10(v14, 1, 4, a3) != 4 )
            break;
          result = sub_23FA4(a3, v10, *v11);
          if ( !(_DWORD)result )
            goto LABEL_26;
          v11 = (__int64 *)v11[2];
          v9 = 0;
          result = 1;
          if ( !v11 )
            goto LABEL_10;
        }
        result = 0;
LABEL_26:
        v9 = 8;
      }
      else
      {
        v9 = 0;
      }
    }
    goto LABEL_10;
  }
  return result;
}

//----- (0000000000021DF8) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_chain_write_with_callbacks_and_tempfile(
        __int64 a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v12; // w8
  __int64 result; // x0
  __int64 v14; // x22
  __int64 v15; // x27
  __int64 (__fastcall *v16)(_BYTE *, __int64, __int64, __int64); // x26
  __int64 (__fastcall *v17)(char *, __int64, __int64, __int64); // x23
  __int64 v18; // x24
  __int64 *v19; // x24
  unsigned int v20; // w8
  char v21; // w10
  __int64 v22; // x24
  __int64 v23; // x8
  __int64 *v24; // x9
  __int64 v25; // x10
  unsigned int (__fastcall *v26)(__int64); // [xsp+8h] [xbp-2068h]
  unsigned int (__fastcall *v27)(__int64, _QWORD, _QWORD); // [xsp+10h] [xbp-2060h]
  _BYTE v28[8192]; // [xsp+18h] [xbp-2058h] BYREF
  __int64 v29; // [xsp+2018h] [xbp-58h]

  v29 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( *(_DWORD *)(a1 + 8) )
  {
    v12 = 12;
LABEL_5:
    result = 0;
LABEL_6:
    *(_DWORD *)(a1 + 36) = v12;
    return result;
  }
  if ( *(_QWORD *)a1 )
  {
    v12 = 14;
    goto LABEL_5;
  }
  if ( *(_QWORD *)a4 && *(_QWORD *)(a4 + 16) && *(_QWORD *)(a4 + 32) && *(_QWORD *)(a6 + 8) )
  {
    result = FLAC__metadata_chain_check_if_tempfile_needed((_QWORD *)a1, a2);
    if ( !(_DWORD)result )
    {
      v12 = 15;
      goto LABEL_6;
    }
    result = sub_21864(a1, a2);
    v14 = result;
    if ( result )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD))(a4 + 16))(a3, 0, 0) )
        goto LABEL_14;
      v15 = *(_QWORD *)(a1 + 40);
      v16 = *(__int64 (__fastcall **)(_BYTE *, __int64, __int64, __int64))a4;
      v17 = *(__int64 (__fastcall **)(char *, __int64, __int64, __int64))(a6 + 8);
      v27 = *(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD))(a4 + 16);
      v26 = *(unsigned int (__fastcall **)(__int64))(a4 + 32);
      if ( v15 >= 1 )
      {
        while ( 1 )
        {
          v18 = (unsigned __int64)v15 >= 0x2000 ? 0x2000LL : v15;
          if ( v16(v28, 1, v18, a3) != v18 )
            break;
          if ( v17(v28, 1, v18, a5) != v18 )
            goto LABEL_44;
          v15 -= v18;
          if ( v15 < 1 )
            goto LABEL_25;
        }
LABEL_45:
        v12 = 6;
        goto LABEL_5;
      }
LABEL_25:
      v19 = *(__int64 **)(a1 + 16);
      if ( v19 )
      {
        while ( 1 )
        {
          v20 = *(_DWORD *)(*v19 + 8);
          if ( v20 >= 0x1000000 )
            break;
          v21 = *(_DWORD *)(*v19 + 4) ? 0x80 : 0;
          v28[0] = v21 | *(_DWORD *)*v19;
          v28[2] = BYTE1(v20);
          v28[3] = v20;
          v28[1] = BYTE2(v20);
          if ( v17(v28, 1, 4, a5) != 4 || !(unsigned int)sub_23FA4(a5, v17, *v19) )
            break;
          v19 = (__int64 *)v19[2];
          if ( !v19 )
            goto LABEL_33;
        }
LABEL_44:
        v12 = 8;
        goto LABEL_5;
      }
LABEL_33:
      if ( v27(a3, *(_QWORD *)(a1 + 48), 0) )
      {
LABEL_14:
        v12 = 7;
        goto LABEL_5;
      }
      while ( !v26(a3) )
      {
        v22 = v16(v28, 1, 0x2000, a3);
        if ( v22 )
        {
          if ( v17(v28, 1, v22, a5) != v22 )
            goto LABEL_44;
        }
        else if ( !v26(a3) )
        {
          goto LABEL_45;
        }
      }
      v23 = *(_QWORD *)(a1 + 40);
      v24 = *(__int64 **)(a1 + 16);
      *(_QWORD *)(a1 + 48) = v23;
      *(_QWORD *)(a1 + 56) = v14;
      if ( v24 )
      {
        do
        {
          v25 = *v24;
          v24 = (__int64 *)v24[2];
          v23 += (unsigned int)(*(_DWORD *)(v25 + 8) + 4);
        }
        while ( v24 );
        *(_QWORD *)(a1 + 48) = v23;
      }
      return 1;
    }
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 36) = 13;
  }
  return result;
}

//----- (00000000000220F8) ----------------------------------------------------
void __fastcall FLAC__metadata_chain_merge_padding(__int64 a1)
{
  _QWORD *v2; // x21
  _QWORD *v3; // x23
  __int64 v4; // x22
  void **v5; // x20
  _QWORD *v6; // x9
  _QWORD *v7; // x9

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 16);
  if ( v3 )
  {
    v4 = a1 + 24;
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v5 = (void **)v3[2];
          if ( *(_DWORD *)*v3 == 1 )
            break;
          v3 = (_QWORD *)v3[2];
          if ( !v5 )
            return;
        }
        if ( !v5 )
          return;
        if ( *(_DWORD *)*v5 == 1 )
          break;
        v3 = (_QWORD *)v3[2];
      }
      *(_DWORD *)(*v3 + 8LL) += *((_DWORD *)*v5 + 2) + 4;
      v6 = v2;
      if ( (void **)*v2 != v5 )
        v6 = (char *)v5[1] + 16;
      *v6 = v5[2];
      v7 = (_QWORD *)(a1 + 24);
      if ( *(void ***)v4 != v5 )
        v7 = (char *)v5[2] + 8;
      *v7 = v5[1];
      if ( *(_QWORD *)v4 )
        *(_DWORD *)(**(_QWORD **)v4 + 4LL) = 1;
      --*(_DWORD *)(a1 + 32);
      if ( *v5 )
        FLAC__metadata_object_delete(*v5);
      free(v5);
    }
    while ( v3 );
  }
}
// 221F4: conditional instruction was optimized away because x20.8!=0

//----- (000000000002220C) ----------------------------------------------------
void __fastcall FLAC__metadata_chain_sort_padding(__int64 a1)
{
  unsigned int v1; // w13
  _QWORD *v2; // x15
  unsigned int v3; // w8
  _QWORD *v4; // x9
  __int64 v5; // x10
  _QWORD *v6; // x14
  _QWORD *v7; // x12
  bool v8; // zf
  _QWORD *v9; // x15
  _QWORD *v10; // x16
  _QWORD *v11; // x17
  _QWORD *v12; // x13
  int v13; // w13

  v1 = *(_DWORD *)(a1 + 32);
  if ( v1 )
  {
    v2 = *(_QWORD **)(a1 + 16);
    v3 = 0;
    v4 = (_QWORD *)(a1 + 16);
    v5 = a1 + 24;
    v6 = v2;
    do
    {
      v7 = (_QWORD *)v6[2];
      if ( *(_DWORD *)*v6 == 1 )
      {
        v8 = v2 == v6;
        v9 = v6 + 1;
        v10 = (_QWORD *)(a1 + 16);
        if ( !v8 )
          v10 = (_QWORD *)(*v9 + 16LL);
        *v10 = v7;
        v11 = (_QWORD *)(a1 + 24);
        if ( *(_QWORD **)v5 != v6 )
          v11 = (_QWORD *)(v6[2] + 8LL);
        *v11 = v6[1];
        if ( *(_QWORD *)v5 )
          *(_DWORD *)(**(_QWORD **)v5 + 4LL) = 1;
        *(_DWORD *)(a1 + 32) = v1 - 1;
        *v9 = 0;
        v6[2] = 0;
        *(_DWORD *)(*v6 + 4LL) = 1;
        v12 = *(_QWORD **)(a1 + 24);
        if ( v12 )
          *(_DWORD *)(*v12 + 4LL) = 0;
        v2 = (_QWORD *)*v4;
        if ( *v4 )
        {
          v12[2] = v6;
          v6[1] = v12;
        }
        else
        {
          *v4 = v6;
          v2 = v6;
        }
        v13 = *(_DWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v6;
        v1 = v13 + 1;
        *(_DWORD *)(a1 + 32) = v1;
      }
      ++v3;
      v6 = v7;
    }
    while ( v3 < v1 );
  }
  FLAC__metadata_chain_merge_padding(a1);
}

//----- (00000000000222F0) ----------------------------------------------------
void *FLAC__metadata_iterator_new()
{
  return calloc(1u, 0x10u);
}

//----- (0000000000022300) ----------------------------------------------------
_QWORD *__fastcall FLAC__metadata_iterator_init(_QWORD *result, __int64 a2)
{
  *result = a2;
  result[1] = *(_QWORD *)(a2 + 16);
  return result;
}

//----- (0000000000022310) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_next(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x8

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0;
  v2 = *(_QWORD *)(v1 + 16);
  if ( !v2 )
    return 0;
  *(_QWORD *)(a1 + 8) = v2;
  return 1;
}

//----- (000000000002233C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_prev(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x8

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0;
  v2 = *(_QWORD *)(v1 + 8);
  if ( !v2 )
    return 0;
  *(_QWORD *)(a1 + 8) = v2;
  return 1;
}

//----- (0000000000022368) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_get_block_type(__int64 a1)
{
  return ***(unsigned int ***)(a1 + 8);
}

//----- (0000000000022378) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_get_block(__int64 a1)
{
  return **(_QWORD **)(a1 + 8);
}

//----- (0000000000022384) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_set_block(_QWORD *a1, unsigned int *a2)
{
  __int64 v3; // x21
  _QWORD *v5; // x22
  __int64 v6; // x8
  _QWORD *v7; // x9
  _QWORD *v8; // x11
  __int64 v9; // x9
  unsigned int v10; // w8
  _QWORD *v11; // x0
  __int64 v12; // x8
  _QWORD *v13; // x8
  __int64 v14; // x9

  v3 = a1[1];
  v5 = *(_QWORD **)(v3 + 8);
  if ( !v5 )
    return 0;
  v6 = *a1;
  v7 = (_QWORD *)(*a1 + 16LL);
  if ( *v7 != v3 )
    v7 = v5 + 2;
  *v7 = *(_QWORD *)(v3 + 16);
  v8 = (_QWORD *)(v6 + 24);
  if ( *(_QWORD *)(v6 + 24) != v3 )
    v8 = (_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL);
  *v8 = *(_QWORD *)(v3 + 8);
  v9 = *(_QWORD *)(v6 + 24);
  if ( v9 )
    *(_DWORD *)(*(_QWORD *)v9 + 4LL) = 1;
  --*(_DWORD *)(v6 + 32);
  if ( *(_QWORD *)v3 )
    FLAC__metadata_object_delete(*(void **)v3);
  free((void *)v3);
  a1[1] = v5;
  v10 = *a2;
  if ( *a2 )
  {
    v11 = calloc(1u, 0x18u);
    if ( v11 )
    {
      *v11 = a2;
      *(_DWORD *)(*v5 + 4LL) = 0;
      v11[1] = v5;
      v12 = v5[2];
      v11[2] = v12;
      if ( v12 )
        v13 = (_QWORD *)(v12 + 8);
      else
        v13 = (_QWORD *)(*a1 + 24LL);
      *v13 = v11;
      *(_QWORD *)(v11[1] + 16LL) = v11;
      v14 = *a1;
      v10 = 1;
      *(_DWORD *)(**(_QWORD **)(*a1 + 24LL) + 4LL) = 1;
      ++*(_DWORD *)(v14 + 32);
      a1[1] = v11;
      return v10;
    }
    return 0;
  }
  return v10;
}

//----- (00000000000224B4) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_delete_block(_QWORD *a1, int a2)
{
  __int64 *v3; // x20
  __int64 v4; // x21
  __int64 result; // x0
  __int64 v6; // x8
  __int64 **v7; // x9
  _QWORD *v8; // x11
  __int64 v9; // x9

  v3 = (__int64 *)a1[1];
  v4 = v3[1];
  if ( !v4 )
    return 0;
  if ( a2 )
  {
    FLAC__metadata_object_delete_data(*v3);
    **(_DWORD **)a1[1] = 1;
  }
  else
  {
    v6 = *a1;
    v7 = (__int64 **)(*a1 + 16LL);
    if ( *v7 != v3 )
      v7 = (__int64 **)(v4 + 16);
    *v7 = (__int64 *)v3[2];
    v8 = (_QWORD *)(v6 + 24);
    if ( *(__int64 **)(v6 + 24) != v3 )
      v8 = (_QWORD *)(v3[2] + 8);
    *v8 = v3[1];
    v9 = *(_QWORD *)(v6 + 24);
    if ( v9 )
      *(_DWORD *)(*(_QWORD *)v9 + 4LL) = 1;
    --*(_DWORD *)(v6 + 32);
    if ( *v3 )
      FLAC__metadata_object_delete((void *)*v3);
    free(v3);
  }
  result = 1;
  a1[1] = v4;
  return result;
}

//----- (0000000000022598) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_iterator_insert_block_after(_QWORD *a1, unsigned int *a2)
{
  unsigned int v3; // w8
  _QWORD *v5; // x0
  _QWORD *v6; // x8
  __int64 v7; // x8
  _QWORD *v8; // x8
  __int64 v10; // x9

  v3 = *a2;
  if ( !*a2 )
    return v3;
  v5 = calloc(1u, 0x18u);
  if ( !v5 )
    return 0;
  *v5 = a2;
  v6 = (_QWORD *)a1[1];
  *(_DWORD *)(*v6 + 4LL) = 0;
  v5[1] = v6;
  v7 = v6[2];
  v5[2] = v7;
  if ( v7 )
    v8 = (_QWORD *)(v7 + 8);
  else
    v8 = (_QWORD *)(*a1 + 24LL);
  *v8 = v5;
  *(_QWORD *)(v5[1] + 16LL) = v5;
  v10 = *a1;
  *(_DWORD *)(**(_QWORD **)(*a1 + 24LL) + 4LL) = 1;
  ++*(_DWORD *)(v10 + 32);
  a1[1] = v5;
  return 1;
}

//----- (0000000000022648) ----------------------------------------------------
_QWORD *__fastcall FLAC__metadata_iterator_insert_block_before(_QWORD *a1, _DWORD *a2)
{
  __int64 v4; // x21
  _QWORD *result; // x0
  __int64 v6; // x8

  if ( !*a2 )
    return 0;
  v4 = a1[1];
  if ( !*(_QWORD *)(v4 + 8) )
    return 0;
  result = calloc(1u, 0x18u);
  if ( result )
  {
    *result = a2;
    a2[1] = 0;
    v6 = *(_QWORD *)(v4 + 8);
    result[1] = v6;
    result[2] = v4;
    if ( !v6 )
      v6 = *a1;
    *(_QWORD *)(v6 + 16) = result;
    *(_QWORD *)(a1[1] + 8LL) = result;
    ++*(_DWORD *)(*a1 + 32LL);
    a1[1] = result;
    return (_QWORD *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000226F8) ----------------------------------------------------
__int64 sub_226F8()
{
  return 0;
}

//----- (0000000000022700) ----------------------------------------------------
void __fastcall sub_22700(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v4; // x0

  if ( !*(_DWORD *)a3 && !*(_QWORD *)(a3 + 8) )
  {
    v4 = FLAC__metadata_object_clone(a2);
    *(_QWORD *)(a3 + 8) = v4;
    if ( !v4 )
      *(_DWORD *)a3 = 1;
  }
}

//----- (0000000000022750) ----------------------------------------------------
void __fastcall sub_22750(__int64 a1, int a2, _DWORD *a3)
{
  if ( a2 )
    *a3 = 1;
}

//----- (0000000000022764) ----------------------------------------------------
void **__fastcall sub_22764(__int64 a1, __int64 a2, __int64 a3)
{
  void **result; // x0
  void **v5; // x20
  int v6; // w21
  __int64 *v7; // x8
  __int64 v8; // x9
  __int64 v9; // x10

  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  result = (void **)FLAC__stream_decoder_new();
  v5 = result;
  if ( result )
  {
    FLAC__stream_decoder_set_metadata_respond_all((__int64)result);
    if ( (unsigned int)FLAC__stream_decoder_init_ogg_stream((_DWORD **)v5) )
    {
      FLAC__stream_decoder_delete(v5);
      result = 0;
      *(_DWORD *)(a1 + 36) = 12;
    }
    else
    {
      *(_QWORD *)(a1 + 40) = 0;
      if ( (unsigned int)FLAC__stream_decoder_process_until_end_of_metadata((_DWORD **)v5) )
      {
        v6 = *(_DWORD *)(a1 + 36);
        FLAC__stream_decoder_delete(v5);
        if ( v6 )
        {
          return 0;
        }
        else
        {
          v7 = *(__int64 **)(a1 + 16);
          v8 = 0;
          for ( *(_QWORD *)(a1 + 48) = 0; v7; v8 += (unsigned int)(*(_DWORD *)(v9 + 8) + 4) )
          {
            v9 = *v7;
            v7 = (__int64 *)v7[2];
          }
          result = (void **)(&dword_0 + 1);
          *(_QWORD *)(a1 + 56) = v8;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 12;
        FLAC__stream_decoder_delete(v5);
        return 0;
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 11;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000002287C) ----------------------------------------------------
void **__fastcall sub_2287C(
        __int64 a1,
        __int64 a2,
        __int64 (*a3)(void),
        __int64 (__fastcall *a4)(__int64, __int64, __int64),
        __int64 (__fastcall *a5)(__int64))
{
  _DWORD *v10; // x24
  __int64 v11; // x0
  int v12; // w8
  void **result; // x0
  char v14; // w26
  char v15; // w27
  char v16; // w28
  __int64 v17; // x0
  __int64 v18; // x0
  void **v19; // x24
  unsigned int v20; // w28
  __int64 (__fastcall *v21)(__int64, __int64, __int64); // x25
  __int64 (__fastcall *v22)(__int64); // x22
  unsigned __int8 v23; // w20
  unsigned __int8 v24; // w27
  int v25; // w26
  _DWORD *v26; // x8
  unsigned int v27; // w28
  unsigned int v28; // w0
  int v29; // w8
  _DWORD *v30; // x8
  _QWORD *v31; // x8
  int v32; // w8
  __int64 v33; // x0
  __int64 *v34; // x8
  __int64 v35; // x9
  __int64 v36; // x10
  int v37; // [xsp+14h] [xbp-5Ch] BYREF
  __int64 v38; // [xsp+18h] [xbp-58h]

  v38 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v10 = (_DWORD *)__errno();
  *v10 = 0;
  v11 = ((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 4, a2);
  if ( *v10 )
    goto LABEL_2;
  if ( v11 != 4 )
    goto LABEL_6;
  if ( !memcmp(&v37, "ID3", 3u) )
  {
    if ( (a4(a2, 2, 1) & 0x80000000) != 0 )
      goto LABEL_42;
    if ( !((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 1, a2) )
      goto LABEL_2;
    v14 = v37;
    if ( (v37 & 0x80) != 0 )
      goto LABEL_2;
    if ( !((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 1, a2) )
      goto LABEL_2;
    v15 = v37;
    if ( (v37 & 0x80) != 0 )
      goto LABEL_2;
    if ( !((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 1, a2) )
      goto LABEL_2;
    v16 = v37;
    if ( (v37 & 0x80) != 0
      || !((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 1, a2)
      || (v37 & 0x80) != 0 )
    {
      goto LABEL_2;
    }
    if ( (a4(a2, v37 & 0x7F | ((v16 & 0x7F | ((v15 & 0x7F | ((unsigned __int8)(v14 & 0x7F) << 7)) << 7)) << 7), 1)
        & 0x80000000) != 0 )
    {
LABEL_42:
      v12 = 7;
LABEL_7:
      result = 0;
LABEL_8:
      *(_DWORD *)(a1 + 36) = v12;
      return result;
    }
    *v10 = 0;
    v17 = ((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 4, a2);
    if ( *v10 )
    {
LABEL_2:
      v12 = 6;
      goto LABEL_7;
    }
    if ( v17 != 4 )
      goto LABEL_6;
  }
  if ( v37 != 1130450022 )
  {
LABEL_6:
    v12 = 3;
    goto LABEL_7;
  }
  v18 = a5(a2);
  if ( v18 < 0 )
    goto LABEL_2;
  *(_QWORD *)(a1 + 40) = v18;
  do
  {
    result = (void **)calloc(1u, 0x18u);
    v19 = result;
    if ( !result )
    {
      v12 = 11;
      goto LABEL_8;
    }
    if ( ((__int64 (__fastcall *)(int *, __int64, __int64, __int64))a3)(&v37, 1, 4, a2) != 4 )
    {
      if ( *v19 )
        FLAC__metadata_object_delete(*v19);
      free(v19);
      goto LABEL_2;
    }
    v20 = (unsigned __int8)v37;
    v21 = a4;
    v22 = a5;
    v23 = BYTE1(v37);
    v24 = BYTE2(v37);
    v25 = HIBYTE(v37);
    v26 = FLAC__metadata_object_new(v37 & 0x7F);
    *v19 = v26;
    if ( !v26 )
    {
      free(v19);
      v12 = 11;
      goto LABEL_7;
    }
    v27 = v20 >> 7;
    v26[1] = v27;
    v26[2] = v25 & 0xFF0000FF | ((unsigned __int16)(v24 | (v23 << 8)) << 8);
    v28 = sub_22D34(a2, a3, (unsigned int (__fastcall *)(__int64, _QWORD, __int64))v21, (__int64)v26);
    if ( v28 >= 0xC )
      v29 = 12;
    else
      v29 = v28;
    *(_DWORD *)(a1 + 36) = v29;
    if ( v29 )
    {
      if ( *v19 )
        FLAC__metadata_object_delete(*v19);
      free(v19);
      return 0;
    }
    v30 = *v19;
    v19[1] = 0;
    v19[2] = 0;
    v30[1] = 1;
    v31 = *(_QWORD **)(a1 + 24);
    if ( v31 )
      *(_DWORD *)(*v31 + 4LL) = 0;
    a5 = v22;
    if ( *(_QWORD *)(a1 + 16) )
    {
      v31[2] = v19;
      v19[1] = v31;
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v19;
    }
    v32 = *(_DWORD *)(a1 + 32);
    a4 = v21;
    *(_QWORD *)(a1 + 24) = v19;
    *(_DWORD *)(a1 + 32) = v32 + 1;
  }
  while ( !v27 );
  v33 = a5(a2);
  if ( v33 < 0 )
    goto LABEL_2;
  v34 = *(__int64 **)(a1 + 16);
  v35 = 0;
  for ( *(_QWORD *)(a1 + 48) = v33; v34; v35 += (unsigned int)(*(_DWORD *)(v36 + 8) + 4) )
  {
    v36 = *v34;
    v34 = (__int64 *)v34[2];
  }
  result = (void **)(&dword_0 + 1);
  *(_QWORD *)(a1 + 56) = v35;
  return result;
}
// 0: using guessed type int dword_0;
// 11850: using guessed type __int64 __errno(void);
// 61A28: using guessed type int FLAC__STREAM_SYNC_STRING;

//----- (0000000000022C00) ----------------------------------------------------
__int64 __fastcall sub_22C00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v6; // x0

  if ( !*a3 )
    return 2;
  if ( *(_DWORD *)(a4 + 36) )
    return 2;
  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(a4 + 72))(a2, 1);
  *a3 = v6;
  return v6 == 0;
}

//----- (0000000000022C70) ----------------------------------------------------
__int64 sub_22C70()
{
  return 1;
}

//----- (0000000000022C78) ----------------------------------------------------
void __fastcall sub_22C78(__int64 a1, __int64 *a2, __int64 a3)
{
  _QWORD *v5; // x20
  __int64 v6; // x0
  _QWORD *v7; // x8
  int v8; // w8

  v5 = calloc(1u, 0x18u);
  if ( !v5 )
    goto LABEL_8;
  v6 = FLAC__metadata_object_clone(a2);
  *v5 = v6;
  if ( !v6 )
  {
    free(v5);
LABEL_8:
    *(_DWORD *)(a3 + 36) = 11;
    return;
  }
  v5[1] = 0;
  v5[2] = 0;
  *(_DWORD *)(v6 + 4) = 1;
  v7 = *(_QWORD **)(a3 + 24);
  if ( v7 )
    *(_DWORD *)(*v7 + 4LL) = 0;
  if ( *(_QWORD *)(a3 + 16) )
  {
    v7[2] = v5;
    v5[1] = v7;
  }
  else
  {
    *(_QWORD *)(a3 + 16) = v5;
  }
  v8 = *(_DWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 24) = v5;
  *(_DWORD *)(a3 + 32) = v8 + 1;
}

//----- (0000000000022D28) ----------------------------------------------------
void __fastcall sub_22D28(__int64 a1, __int64 a2, __int64 a3)
{
  *(_DWORD *)(a3 + 36) = 12;
}

//----- (0000000000022D34) ----------------------------------------------------
__int64 __fastcall sub_22D34(
        __int64 a1,
        __int64 (*a2)(void),
        unsigned int (__fastcall *a3)(__int64, _QWORD, __int64),
        __int64 a4)
{
  __int64 result; // x0
  unsigned __int8 v9; // w10
  int v10; // w9
  unsigned __int8 v11; // w8
  unsigned int v12; // w23
  unsigned int v13; // w24
  __int64 v14; // x23
  unsigned int v15; // w8
  unsigned int v16; // w10
  unsigned __int8 v17; // w8
  char *v18; // x0
  __int64 v19; // x27
  unsigned __int64 v20; // x26
  int v21; // w9
  unsigned int v22; // w23
  __int64 v23; // x8
  unsigned int v24; // w8
  __int64 v25; // x22
  _BYTE *v26; // x0
  unsigned int v27; // w9
  unsigned int v28; // w8
  int v29; // w22
  unsigned __int64 v30; // x10
  unsigned __int16 *v31; // x8
  unsigned __int8 v32; // t1
  unsigned __int64 v33; // x9
  int v34; // w22
  int v35; // w9
  unsigned __int16 *v36; // x8
  unsigned __int8 v37; // t1
  int v38; // w10
  void *v39; // x0
  __int64 v40; // x22
  unsigned __int64 v41; // x23
  __int64 v42; // x8
  int v43; // w22
  unsigned int v44; // w9
  unsigned __int8 *v45; // x8
  unsigned __int8 v46; // t1
  unsigned int v47; // w23
  int v48; // w22
  unsigned int v49; // w8
  unsigned __int16 *v50; // x9
  unsigned __int8 v51; // t1
  _QWORD *v52; // x24
  __int64 v53; // x23
  unsigned __int64 v54; // x10
  unsigned __int8 *v55; // x8
  int v56; // w9
  unsigned __int8 v57; // t1
  unsigned __int64 v58; // x11
  char *v59; // x9
  char *v60; // x22
  size_t v61; // x0
  void *v62; // x0
  _QWORD *v63; // x22
  __int64 v64; // x24
  unsigned __int64 v65; // x8
  unsigned __int8 *v66; // x9
  int v67; // w10
  unsigned __int8 v68; // t1
  void *v69; // x0
  __int64 v70; // x22
  _BYTE *v71; // x0
  int v72; // w22
  unsigned int v73; // w9
  unsigned __int8 *v74; // x8
  unsigned __int8 v75; // t1
  unsigned int v76; // w23
  void *v77; // x0
  __int64 v78; // x22
  _BYTE *v79; // x0
  int v80; // w22
  int v81; // w9
  unsigned __int16 *v82; // x8
  unsigned __int8 v83; // t1
  int v84; // w10
  int v85; // w22
  int v86; // w9
  unsigned __int16 *v87; // x8
  unsigned __int8 v88; // t1
  int v89; // w10
  int v90; // w22
  int v91; // w9
  unsigned __int16 *v92; // x8
  unsigned __int8 v93; // t1
  int v94; // w10
  int v95; // w22
  int v96; // w9
  unsigned __int16 *v97; // x8
  unsigned __int8 v98; // t1
  int v99; // w10
  int v100; // w22
  unsigned int v101; // w10
  unsigned __int8 *v102; // x9
  unsigned __int8 v103; // t1
  unsigned int v104; // w8
  void *v105; // x0
  __int64 v106; // x22
  _BYTE *v107; // x0
  _BYTE *v108; // x8
  __int64 v109; // x9
  unsigned __int8 *v110; // [xsp+60h] [xbp-480h]
  unsigned __int16 v111; // [xsp+68h] [xbp-478h] BYREF
  unsigned __int8 v112; // [xsp+6Ah] [xbp-476h]
  unsigned __int8 v113; // [xsp+6Bh] [xbp-475h]
  unsigned __int16 v114; // [xsp+6Ch] [xbp-474h]
  unsigned __int8 v115; // [xsp+6Eh] [xbp-472h]
  _BYTE v116[3]; // [xsp+6Fh] [xbp-471h]
  unsigned __int16 v117; // [xsp+72h] [xbp-46Eh]
  unsigned __int8 v118; // [xsp+74h] [xbp-46Ch]
  unsigned __int8 v119; // [xsp+75h] [xbp-46Bh]
  unsigned __int16 v120; // [xsp+76h] [xbp-46Ah]
  unsigned __int8 v121; // [xsp+78h] [xbp-468h]
  unsigned __int8 v122; // [xsp+79h] [xbp-467h]
  __int128 v123; // [xsp+7Ah] [xbp-466h]
  _BYTE v124[32]; // [xsp+468h] [xbp-78h] BYREF
  __int64 v125; // [xsp+488h] [xbp-58h]

  v125 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  switch ( *(_DWORD *)a4 )
  {
    case 0:
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 34, a1) != 34 )
        return 6;
      result = 0;
      *(_DWORD *)(a4 + 16) = HIBYTE(v111) | ((unsigned __int8)v111 << 8);
      *(_DWORD *)(a4 + 20) = v113 | (v112 << 8);
      *(_DWORD *)(a4 + 24) = v115 | (_byteswap_ushort(v114) << 8);
      *(_DWORD *)(a4 + 28) = v116[2] | (_byteswap_ushort(*(unsigned __int16 *)v116) << 8);
      v9 = v118;
      v10 = ((v118 >> 1) & 7) + 1;
      *(_DWORD *)(a4 + 32) = (v118 >> 4) & 0xFFF0000F | (16 * _byteswap_ushort(v117));
      *(_DWORD *)(a4 + 36) = v10;
      v11 = v119;
      *(_DWORD *)(a4 + 40) = ((v119 >> 4) & 0xFFFFFFEF | (16 * (v9 & 1))) + 1;
      *(_QWORD *)(a4 + 48) = v122
                           | ((unsigned __int64)(v11 & 0xF) << 32)
                           | ((v121 | ((unsigned __int64)_byteswap_ushort(v120) << 8) & 0xFFFFFF) << 8);
      *(_OWORD *)(a4 + 56) = v123;
      return result;
    case 1:
      if ( a3(a1, *(unsigned int *)(a4 + 8), 1) )
        return 7;
      else
        return 0;
    case 2:
      v22 = *(_DWORD *)(a4 + 8);
      v23 = ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64))a2)(a4 + 16, 1, 4, a1);
      result = 6;
      if ( v22 >= 4 && v23 == 4 )
      {
        v24 = v22 - 4;
        if ( v22 == 4 )
        {
          *(_QWORD *)(a4 + 24) = 0;
          return 0;
        }
        v25 = v24;
        v26 = malloc(v24);
        *(_QWORD *)(a4 + 24) = v26;
        if ( v26 )
          goto LABEL_27;
        return 11;
      }
      return result;
    case 3:
      v27 = *(_DWORD *)(a4 + 8);
      v28 = v27 / 0x12;
      *(_DWORD *)(a4 + 16) = v27 / 0x12;
      if ( v27 > 0x11 )
      {
        v39 = safe_malloc_mul_2op_p(v28, 0x18u);
        *(_QWORD *)(a4 + 24) = v39;
        if ( !v39 )
          return 11;
        if ( !*(_DWORD *)(a4 + 16) )
          return 0;
      }
      else
      {
        *(_QWORD *)(a4 + 24) = 0;
        if ( !v28 )
          return 0;
      }
      v40 = 0;
      v41 = 0;
      do
      {
        if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 18, a1) != 18 )
          return 6;
        v42 = *(_QWORD *)(a4 + 24) + v40;
        *(_QWORD *)v42 = v116[0]
                       | ((v115
                         | ((HIBYTE(v114)
                           | (((unsigned __int8)v114
                             | ((v113 | ((unsigned __int64)(v112 | (_byteswap_ushort(v111) << 8) & 0xFFFFFFu) << 8)) << 8)) << 8)) << 8)) << 8);
        *(_QWORD *)(v42 + 8) = HIBYTE(v120)
                             | (((unsigned __int8)v120
                               | ((v119
                                 | ((v118
                                   | ((HIBYTE(v117)
                                     | ((unsigned __int64)((unsigned __int8)v117
                                                         | (_byteswap_ushort(*(unsigned __int16 *)&v116[1]) << 8)
                                                         & 0xFFFFFFu) << 8)) << 8)) << 8)) << 8)) << 8);
        ++v41;
        v40 += 24;
        *(_DWORD *)(v42 + 16) = v122 | (v121 << 8);
      }
      while ( v41 < *(unsigned int *)(a4 + 16) );
      return 0;
    case 4:
      v12 = *(_DWORD *)(a4 + 8);
      result = sub_23C54(a1, (__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2, a4 + 16, v12);
      if ( v12 > 3 )
        v12 -= 4;
      if ( (_DWORD)result == 5 )
        goto LABEL_96;
      if ( (_DWORD)result )
        return result;
      v12 -= *(_DWORD *)(a4 + 16);
      v13 = v12 - 4;
      if ( v12 < 4 )
        goto LABEL_96;
      v14 = 4;
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 4, a1) != 4 )
        return 6;
      v15 = 0;
      do
      {
        v16 = v15;
        v17 = v124[--v14];
        v15 = v17 | (v16 << 8);
      }
      while ( (_DWORD)v14 );
      *(_DWORD *)(a4 + 32) = v15;
      if ( !v15 )
      {
        *(_QWORD *)(a4 + 40) = 0;
        v12 = v13;
LABEL_96:
        if ( !v12 )
          return 0;
LABEL_97:
        if ( !a3(a1, v12, 1) )
          return 0;
        return 7;
      }
      v18 = (char *)calloc(v15, 0x10u);
      *(_QWORD *)(a4 + 40) = v18;
      if ( !v18 )
      {
        *(_DWORD *)(a4 + 32) = 0;
        return 11;
      }
      v19 = 0;
      v20 = 0;
      v12 = v13;
      while ( 1 )
      {
        result = sub_23C54(a1, (__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2, (__int64)&v18[v19], v12);
        if ( v12 > 3 )
          v12 -= 4;
        if ( (_DWORD)result )
          break;
        v18 = *(char **)(a4 + 40);
        ++v20;
        v21 = *(_DWORD *)&v18[v19];
        v19 += 16;
        v12 -= v21;
        if ( v20 >= *(unsigned int *)(a4 + 32) )
          goto LABEL_96;
      }
      if ( (_DWORD)result != 5 )
        return result;
      *(_DWORD *)(a4 + 32) = v20;
      if ( v12 )
        goto LABEL_97;
      return 0;
    case 5:
      if ( ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64))a2)(a4 + 16, 1, 128, a1) != 128 )
        return 6;
      v29 = 8;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 8, a1) != 8 )
        return 6;
      v30 = 0;
      v31 = &v111;
      do
      {
        v32 = *(_BYTE *)v31;
        v31 = (unsigned __int16 *)((char *)v31 + 1);
        --v29;
        v33 = v32 | (v30 << 8);
        v30 = v33;
      }
      while ( v29 );
      *(_QWORD *)(a4 + 152) = v33;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 259, a1) != 259 )
        return 6;
      *(_DWORD *)(a4 + 160) = (unsigned __int8)v111 >> 7;
      v48 = 1;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 1, a1) != 1 )
        return 6;
      v49 = 0;
      v50 = &v111;
      do
      {
        v51 = *(_BYTE *)v50;
        v50 = (unsigned __int16 *)((char *)v50 + 1);
        --v48;
        v49 = v51 | (v49 << 8);
      }
      while ( v48 );
      *(_DWORD *)(a4 + 164) = v49;
      if ( !v49 )
      {
        result = 0;
        *(_QWORD *)(a4 + 168) = 0;
        return result;
      }
      v52 = calloc(v49, 0x20u);
      *(_QWORD *)(a4 + 168) = v52;
      if ( !v52 )
        return 11;
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 8, a1) != 8 )
        return 6;
      v53 = 0;
      while ( 2 )
      {
        v54 = 0;
        v55 = v124;
        v56 = 8;
        do
        {
          v57 = *v55++;
          --v56;
          v58 = v57 | (v54 << 8);
          v54 = v58;
        }
        while ( v56 );
        v52[4 * v53] = v58;
        if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 1, a1) == 1 )
        {
          v59 = (char *)&v52[4 * v53];
          v59[8] = v124[0];
          if ( ((__int64 (__fastcall *)(char *, __int64, __int64, __int64))a2)(v59 + 9, 1, 12, a1) == 12
            && ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 14, a1) == 14 )
          {
            BYTE6(v52[4 * v53 + 2]) = BYTE6(v52[4 * v53 + 2]) & 0xFC | (v124[0] >> 7) | (v124[0] >> 5) & 2;
            if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 1, a1) == 1 )
            {
              v60 = (char *)&v52[4 * v53];
              v61 = v124[0];
              v60[23] = v124[0];
              v110 = (unsigned __int8 *)(v60 + 23);
              if ( !v61 )
              {
                v52[4 * v53 + 3] = 0;
LABEL_81:
                if ( ++v53 >= (unsigned __int64)*(unsigned int *)(a4 + 164) )
                  return 0;
                v52 = *(_QWORD **)(a4 + 168);
                if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 8, a1) != 8 )
                  return 6;
                continue;
              }
              v62 = calloc(v61, 0x10u);
              *((_QWORD *)v60 + 3) = v62;
              v63 = v60 + 24;
              if ( !v62 )
                return 11;
              v64 = 0;
              while ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 8, a1) == 8 )
              {
                v65 = 0;
                v66 = v124;
                v67 = 8;
                do
                {
                  v68 = *v66++;
                  --v67;
                  v65 = v68 | (v65 << 8);
                }
                while ( v67 );
                *(_QWORD *)(*v63 + 16 * v64) = v65;
                if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 1, a1) != 1 )
                  break;
                *(_BYTE *)(*v63 + 16 * v64 + 8) = v124[0];
                if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 3, a1) != 3 )
                  break;
                if ( ++v64 >= (unsigned __int64)*v110 )
                  goto LABEL_81;
              }
            }
          }
        }
        return 6;
      }
    case 6:
      v34 = 4;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 4, a1) != 4 )
        return 6;
      v35 = 0;
      v36 = &v111;
      do
      {
        v37 = *(_BYTE *)v36;
        v36 = (unsigned __int16 *)((char *)v36 + 1);
        --v34;
        v38 = v37 | (v35 << 8);
        v35 = v38;
      }
      while ( v34 );
      *(_DWORD *)(a4 + 16) = v38;
      v43 = 4;
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 4, a1) != 4 )
        return 6;
      v44 = 0;
      v45 = v124;
      do
      {
        v46 = *v45++;
        --v43;
        v47 = v46 | (v44 << 8);
        v44 = v47;
      }
      while ( v43 );
      v69 = *(void **)(a4 + 24);
      if ( v69 )
        free(v69);
      v70 = v47;
      v71 = malloc(v47 + 1LL);
      *(_QWORD *)(a4 + 24) = v71;
      if ( !v71 )
        return 11;
      if ( v47 )
      {
        if ( a2() != v47 )
          return 6;
        v71 = *(_BYTE **)(a4 + 24);
      }
      else
      {
        v70 = 0;
      }
      v71[v70] = 0;
      v72 = 4;
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 4, a1) != 4 )
        return 6;
      v73 = 0;
      v74 = v124;
      do
      {
        v75 = *v74++;
        --v72;
        v76 = v75 | (v73 << 8);
        v73 = v76;
      }
      while ( v72 );
      v77 = *(void **)(a4 + 32);
      if ( v77 )
        free(v77);
      v78 = v76;
      v79 = malloc(v76 + 1LL);
      *(_QWORD *)(a4 + 32) = v79;
      if ( !v79 )
        return 11;
      if ( v76 )
      {
        if ( a2() != v76 )
          return 6;
        v79 = *(_BYTE **)(a4 + 32);
      }
      else
      {
        v78 = 0;
      }
      v79[v78] = 0;
      v80 = 4;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 4, a1) != 4 )
        return 6;
      v81 = 0;
      v82 = &v111;
      do
      {
        v83 = *(_BYTE *)v82;
        v82 = (unsigned __int16 *)((char *)v82 + 1);
        --v80;
        v84 = v83 | (v81 << 8);
        v81 = v84;
      }
      while ( v80 );
      *(_DWORD *)(a4 + 40) = v84;
      v85 = 4;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 4, a1) != 4 )
        return 6;
      v86 = 0;
      v87 = &v111;
      do
      {
        v88 = *(_BYTE *)v87;
        v87 = (unsigned __int16 *)((char *)v87 + 1);
        --v85;
        v89 = v88 | (v86 << 8);
        v86 = v89;
      }
      while ( v85 );
      *(_DWORD *)(a4 + 44) = v89;
      v90 = 4;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 4, a1) != 4 )
        return 6;
      v91 = 0;
      v92 = &v111;
      do
      {
        v93 = *(_BYTE *)v92;
        v92 = (unsigned __int16 *)((char *)v92 + 1);
        --v90;
        v94 = v93 | (v91 << 8);
        v91 = v94;
      }
      while ( v90 );
      *(_DWORD *)(a4 + 48) = v94;
      v95 = 4;
      if ( ((__int64 (__fastcall *)(unsigned __int16 *, __int64, __int64, __int64))a2)(&v111, 1, 4, a1) != 4 )
        return 6;
      v96 = 0;
      v97 = &v111;
      do
      {
        v98 = *(_BYTE *)v97;
        v97 = (unsigned __int16 *)((char *)v97 + 1);
        --v95;
        v99 = v98 | (v96 << 8);
        v96 = v99;
      }
      while ( v95 );
      *(_DWORD *)(a4 + 52) = v99;
      v100 = 4;
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v124, 1, 4, a1) != 4 )
        return 6;
      v101 = 0;
      v102 = v124;
      do
      {
        v103 = *v102++;
        --v100;
        v104 = v103 | (v101 << 8);
        v101 = v104;
      }
      while ( v100 );
      v105 = *(void **)(a4 + 64);
      *(_DWORD *)(a4 + 56) = v104;
      if ( v105 )
      {
        free(v105);
        v104 = *(_DWORD *)(a4 + 56);
      }
      v106 = v104;
      v107 = malloc(v104 + 1LL);
      v108 = v107;
      *(_QWORD *)(a4 + 64) = v107;
      if ( !v107 )
        return 11;
      if ( (_DWORD)v106 )
      {
        v109 = ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v107, 1, v106, a1);
        if ( v109 != *(_DWORD *)(a4 + 56) )
          return 6;
        v108 = *(_BYTE **)(a4 + 64);
      }
      else
      {
        v109 = 0;
      }
      result = 0;
      v108[v109] = 0;
      return result;
    default:
      v25 = *(unsigned int *)(a4 + 8);
      if ( !(_DWORD)v25 )
      {
        *(_QWORD *)(a4 + 16) = 0;
        return 0;
      }
      v26 = malloc(*(unsigned int *)(a4 + 8));
      *(_QWORD *)(a4 + 16) = v26;
      if ( !v26 )
        return 11;
LABEL_27:
      if ( ((__int64 (__fastcall *)(_BYTE *, __int64, __int64, __int64))a2)(v26, 1, v25, a1) == v25 )
        return 0;
      return 6;
  }
}
// 2343C: conditional instruction was optimized away because w28.4==8
// 2348C: conditional instruction was optimized away because w22.4==1
// 23530: conditional instruction was optimized away because w27.4==1
// 23568: conditional instruction was optimized away because w26.4==8
// 2356C: conditional instruction was optimized away because w27.4==1

//----- (0000000000023C54) ----------------------------------------------------
__int64 __fastcall sub_23C54(
        __int64 a1,
        __int64 (__fastcall *a2)(_BYTE *, __int64, __int64, __int64),
        __int64 a3,
        unsigned int a4)
{
  __int64 result; // x0
  __int64 v9; // x22
  unsigned int v10; // w11
  unsigned __int8 v11; // w8
  unsigned int v12; // w8
  void *v13; // x0
  __int64 v14; // x22
  _BYTE *v15; // x0
  __int64 v16; // x8
  _BYTE v17[4]; // [xsp+4h] [xbp-4Ch] BYREF
  __int64 v18; // [xsp+8h] [xbp-48h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a4 < 4 )
    return 5;
  v9 = 4;
  if ( a2(v17, 1, 4, a1) != 4 )
    return 6;
  v10 = 0;
  do
  {
    v11 = v17[--v9];
    v12 = v11 | (v10 << 8);
    v10 = v12;
  }
  while ( (_DWORD)v9 );
  *(_DWORD *)a3 = v12;
  if ( a4 - 4 >= v12 )
  {
    v13 = *(void **)(a3 + 8);
    if ( v13 )
    {
      free(v13);
      v12 = *(_DWORD *)a3;
    }
    if ( !v12 )
    {
      result = 0;
      *(_QWORD *)(a3 + 8) = 0;
      return result;
    }
    v14 = v12;
    v15 = malloc(v12 + 1LL);
    *(_QWORD *)(a3 + 8) = v15;
    if ( !v15 )
      return 11;
    v16 = a2(v15, 1, v14, a1);
    if ( v16 == *(_DWORD *)a3 )
    {
      result = 0;
      *(_BYTE *)(*(_QWORD *)(a3 + 8) + v16) = 0;
      return result;
    }
    return 6;
  }
  *(_DWORD *)a3 = 0;
  return 5;
}

//----- (0000000000023DF4) ----------------------------------------------------
__int64 __fastcall sub_23DF4(const char *a1, const char *a2, FILE **a3, const char **a4, int *a5)
{
  const char *v9; // x23
  char *v10; // x0
  size_t v11; // x24
  size_t v12; // x8
  size_t v13; // x24
  size_t v14; // x8
  size_t v15; // x0
  char *v16; // x0
  size_t v17; // x0
  size_t v18; // x22
  size_t v19; // x0
  char *v20; // x0
  FILE *v21; // x0
  __int64 result; // x0
  int v23; // w8

  v9 = a1;
  if ( !a2 )
  {
    v17 = strlen(a1);
    v18 = v17 + 15;
    if ( v17 == -15 )
      v19 = 1;
    else
      v19 = v17 + 15;
    v20 = (char *)malloc(v19);
    *a4 = v20;
    if ( v20 )
    {
      sub_23F0C(v20, v18, "%s%s", v9, ".metadata_edit");
      goto LABEL_14;
    }
LABEL_16:
    v23 = 11;
    goto LABEL_18;
  }
  v10 = strrchr(a1, 47);
  if ( v10 )
    v9 = v10 + 1;
  v11 = strlen(a2);
  v12 = v11 + strlen(v9);
  v13 = v12 + 16;
  v14 = v12 + 17;
  if ( v13 )
    v15 = v13;
  else
    v15 = v14;
  v16 = (char *)malloc(v15);
  *a4 = v16;
  if ( !v16 )
    goto LABEL_16;
  sub_23F0C(v16, v13, "%s/%s%s", a2, v9, ".metadata_edit");
LABEL_14:
  v21 = fopen(*a4, "w+b");
  *a3 = v21;
  if ( v21 )
    return 1;
  v23 = 2;
LABEL_18:
  result = 0;
  *a5 = v23;
  return result;
}

//----- (0000000000023F0C) ----------------------------------------------------
__int64 sub_23F0C(char *a1, size_t a2, const char *a3, ...)
{
  gcc_va_list arg; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF

  va_start(va, a3);
  _ReadStatusReg(TPIDR_EL0);
  va_copy(arg, va);
  return vsnprintf(a1, a2, a3, arg);
}

//----- (0000000000023FA4) ----------------------------------------------------
__int64 __fastcall sub_23FA4(__int64 a1, __int64 (__fastcall *a2)(char *, __int64, __int64, __int64), __int64 a3)
{
  int v6; // w8
  int v7; // w9
  unsigned int v8; // w10
  int v9; // w8
  int v10; // w8
  int v11; // w8
  unsigned int v12; // w8
  __int64 v13; // x8
  unsigned int v15; // w8
  char *v16; // x9
  int v17; // w10
  unsigned int v18; // w9
  char *v19; // x10
  int v20; // w11
  __int64 v21; // x8
  unsigned __int64 v22; // x23
  unsigned int v23; // w8
  char *v24; // x9
  int v25; // w10
  __int64 v26; // x0
  __int64 result; // x0
  int v28; // w23
  char *v29; // x0
  __int64 v30; // x21
  __int64 v31; // x22
  unsigned __int64 v32; // x23
  __int64 *v33; // x8
  __int64 v34; // x9
  __int64 v35; // x9
  __int16 v36; // kr00_2
  unsigned int v37; // w21
  int v38; // w23
  unsigned __int64 v39; // x8
  __int64 v40; // x10
  char *v41; // x11
  unsigned int v42; // w8
  __int64 v43; // x10
  char *v44; // x11
  size_t v45; // x22
  __int64 v46; // x9
  unsigned int v47; // w10
  char *v48; // x11
  unsigned int v49; // w8
  __int64 v50; // x10
  char *v51; // x11
  size_t v52; // x22
  __int64 v53; // x9
  unsigned int v54; // w10
  char *v55; // x11
  __int64 v56; // x25
  __int64 v57; // x9
  unsigned __int64 v58; // x8
  char *v59; // x10
  __int64 v60; // x9
  unsigned int v61; // w8
  char *v62; // x10
  __int64 v63; // x22
  __int64 v64; // x9
  unsigned int v65; // w8
  char *v66; // x10
  __int64 v67; // x25
  __int64 v68; // x9
  __int64 v69; // x22
  unsigned __int64 v70; // x8
  char *v71; // x10
  unsigned int v72; // w8
  __int64 v73; // x9
  char *v74; // x10
  unsigned int v75; // w8
  __int64 v76; // x10
  char *v77; // x11
  unsigned int v78; // w8
  __int64 v79; // x10
  char *v80; // x11
  unsigned int v81; // w8
  __int64 v82; // x10
  char *v83; // x11
  unsigned int v84; // w8
  __int64 v85; // x10
  char *v86; // x11
  unsigned int v87; // w8
  __int64 v88; // x10
  char *v89; // x11
  __int64 *v90; // [xsp+38h] [xbp-478h]
  __int64 v91; // [xsp+48h] [xbp-468h]
  _BYTE *v92; // [xsp+50h] [xbp-460h]
  char v93; // [xsp+58h] [xbp-458h] BYREF
  char v94; // [xsp+59h] [xbp-457h]
  char v95; // [xsp+5Ah] [xbp-456h]
  char v96; // [xsp+5Bh] [xbp-455h]
  char v97; // [xsp+5Ch] [xbp-454h]
  char v98; // [xsp+5Dh] [xbp-453h]
  char v99; // [xsp+5Eh] [xbp-452h]
  char v100; // [xsp+5Fh] [xbp-451h]
  char v101; // [xsp+60h] [xbp-450h]
  char v102; // [xsp+61h] [xbp-44Fh]
  char v103; // [xsp+62h] [xbp-44Eh]
  char v104; // [xsp+63h] [xbp-44Dh]
  char v105; // [xsp+64h] [xbp-44Ch]
  char v106; // [xsp+65h] [xbp-44Bh]
  char v107; // [xsp+66h] [xbp-44Ah]
  char v108; // [xsp+67h] [xbp-449h]
  char v109; // [xsp+68h] [xbp-448h]
  char v110; // [xsp+69h] [xbp-447h]
  __int128 v111; // [xsp+6Ah] [xbp-446h]
  __int64 v112; // [xsp+458h] [xbp-58h]

  v112 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  switch ( *(_DWORD *)a3 )
  {
    case 0:
      v6 = *(_DWORD *)(a3 + 16);
      v7 = *(_DWORD *)(a3 + 36);
      v8 = *(_DWORD *)(a3 + 40);
      v93 = BYTE1(v6);
      v94 = v6;
      v9 = *(_DWORD *)(a3 + 20);
      --v8;
      v95 = BYTE1(v9);
      v96 = v9;
      v10 = *(_DWORD *)(a3 + 24);
      v98 = BYTE1(v10);
      v99 = v10;
      v97 = BYTE2(v10);
      v11 = *(_DWORD *)(a3 + 28);
      v101 = BYTE1(v11);
      v102 = v11;
      v100 = BYTE2(v11);
      v12 = *(_DWORD *)(a3 + 32);
      v103 = v12 >> 12;
      v104 = v12 >> 4;
      v105 = (2 * v7 - 2) | (v8 >> 4) | (16 * v12);
      v13 = *(_QWORD *)(a3 + 48);
      v106 = BYTE4(v13) & 0xF | (16 * v8);
      v109 = BYTE1(v13);
      v110 = v13;
      v108 = BYTE2(v13);
      v107 = BYTE3(v13);
      v111 = *(_OWORD *)(a3 + 56);
      return a2(&v93, 1, 34, a1) == 34;
    case 1:
      v37 = *(_DWORD *)(a3 + 8);
      memset(&v93, 0, 0x400u);
      if ( !(v37 >> 10) )
        goto LABEL_30;
      v38 = 0;
      while ( a2(&v93, 1, 1024, a1) == 1024 )
      {
        if ( ++v38 >= v37 >> 10 )
        {
LABEL_30:
          v30 = v37 & 0x3FF;
          v29 = &v93;
          return a2(v29, 1, v30, a1) == v30;
        }
      }
      return 0;
    case 2:
      v28 = *(_DWORD *)(a3 + 8);
      if ( a2((char *)(a3 + 16), 1, 4, a1) != 4 )
        return 0;
      v29 = *(char **)(a3 + 24);
      v30 = (unsigned int)(v28 - 4);
      return a2(v29, 1, v30, a1) == v30;
    case 3:
      if ( !*(_DWORD *)(a3 + 16) )
        return 1;
      v31 = 0;
      v32 = 0;
      while ( 1 )
      {
        v33 = (__int64 *)(*(_QWORD *)(a3 + 24) + v31);
        v34 = *v33;
        v99 = BYTE1(*v33);
        v98 = BYTE2(v34);
        v97 = BYTE3(v34);
        v96 = BYTE4(v34);
        v100 = v34;
        v95 = BYTE5(v34);
        v94 = BYTE6(v34);
        v93 = HIBYTE(v34);
        v35 = v33[1];
        v107 = BYTE1(v35);
        v106 = BYTE2(v35);
        v105 = BYTE3(v35);
        v104 = BYTE4(v35);
        v108 = v35;
        v103 = BYTE5(v35);
        v102 = BYTE6(v35);
        v101 = HIBYTE(v35);
        v36 = *((_DWORD *)v33 + 4);
        v109 = HIBYTE(v36);
        v110 = v36;
        if ( a2(&v93, 1, 18, a1) != 18 )
          break;
        ++v32;
        v31 += 24;
        if ( v32 >= *(unsigned int *)(a3 + 16) )
          return 1;
      }
      return 0;
    case 4:
      v15 = *(_DWORD *)(a3 + 16);
      v16 = &v93;
      v17 = 4;
      do
      {
        *v16++ = v15;
        --v17;
        v15 >>= 8;
      }
      while ( v17 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      if ( a2(*(char **)(a3 + 24), 1, *(unsigned int *)(a3 + 16), a1) != *(_DWORD *)(a3 + 16) )
        return 0;
      v18 = *(_DWORD *)(a3 + 32);
      v19 = &v93;
      v20 = 4;
      do
      {
        *v19++ = v18;
        --v20;
        v18 >>= 8;
      }
      while ( v20 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      if ( !*(_DWORD *)(a3 + 32) )
        return 1;
      v21 = *(_QWORD *)(a3 + 40);
      v22 = 0;
      while ( 1 )
      {
        v23 = *(_DWORD *)(v21 + 16 * v22);
        v24 = &v93;
        v25 = 4;
        do
        {
          *v24++ = v23;
          --v25;
          v23 >>= 8;
        }
        while ( v25 );
        if ( a2(&v93, 1, 4, a1) != 4 )
          break;
        v26 = a2(
                *(char **)(*(_QWORD *)(a3 + 40) + 16 * v22 + 8),
                1,
                *(unsigned int *)(*(_QWORD *)(a3 + 40) + 16 * v22),
                a1);
        v21 = *(_QWORD *)(a3 + 40);
        if ( v26 != *(_DWORD *)(v21 + 16 * v22) )
          break;
        ++v22;
        result = 1;
        if ( v22 >= *(unsigned int *)(a3 + 32) )
          return result;
      }
      return 0;
    case 5:
      if ( a2((char *)(a3 + 16), 1, 128, a1) != 128 )
        return 0;
      v39 = *(_QWORD *)(a3 + 152);
      v40 = 8;
      do
      {
        v41 = &v93 + v40--;
        *(v41 - 1) = v39;
        v39 >>= 8;
      }
      while ( (_DWORD)v40 );
      if ( a2(&v93, 1, 8, a1) != 8 )
        return 0;
      memset(&v93, 0, 0x103u);
      if ( *(_DWORD *)(a3 + 160) )
        v93 |= 0x80u;
      if ( a2(&v93, 1, 259, a1) != 259 )
        return 0;
      v49 = *(_DWORD *)(a3 + 164);
      v50 = 1;
      do
      {
        v51 = &v93 + v50--;
        *(v51 - 1) = v49;
        v49 >>= 8;
      }
      while ( (_DWORD)v50 );
      if ( a2(&v93, 1, 1, a1) != 1 )
        return 0;
      if ( !*(_DWORD *)(a3 + 164) )
        return 1;
      v91 = 0;
      break;
    case 6:
      v42 = *(_DWORD *)(a3 + 16);
      v43 = 4;
      do
      {
        v44 = &v93 + v43--;
        *(v44 - 1) = v42;
        v42 >>= 8;
      }
      while ( (_DWORD)v43 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      v45 = strlen(*(const char **)(a3 + 24));
      v46 = 4;
      v47 = v45;
      do
      {
        v48 = &v93 + v46--;
        *(v48 - 1) = v47;
        v47 >>= 8;
      }
      while ( (_DWORD)v46 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      if ( a2(*(char **)(a3 + 24), 1, v45, a1) != v45 )
        return 0;
      v52 = strlen(*(const char **)(a3 + 32));
      v53 = 4;
      v54 = v52;
      do
      {
        v55 = &v93 + v53--;
        *(v55 - 1) = v54;
        v54 >>= 8;
      }
      while ( (_DWORD)v53 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      if ( a2(*(char **)(a3 + 32), 1, v52, a1) != v52 )
        return 0;
      v75 = *(_DWORD *)(a3 + 40);
      v76 = 4;
      do
      {
        v77 = &v93 + v76--;
        *(v77 - 1) = v75;
        v75 >>= 8;
      }
      while ( (_DWORD)v76 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      v78 = *(_DWORD *)(a3 + 44);
      v79 = 4;
      do
      {
        v80 = &v93 + v79--;
        *(v80 - 1) = v78;
        v78 >>= 8;
      }
      while ( (_DWORD)v79 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      v81 = *(_DWORD *)(a3 + 48);
      v82 = 4;
      do
      {
        v83 = &v93 + v82--;
        *(v83 - 1) = v81;
        v81 >>= 8;
      }
      while ( (_DWORD)v82 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      v84 = *(_DWORD *)(a3 + 52);
      v85 = 4;
      do
      {
        v86 = &v93 + v85--;
        *(v86 - 1) = v84;
        v84 >>= 8;
      }
      while ( (_DWORD)v85 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      v87 = *(_DWORD *)(a3 + 56);
      v88 = 4;
      do
      {
        v89 = &v93 + v88--;
        *(v89 - 1) = v87;
        v87 >>= 8;
      }
      while ( (_DWORD)v88 );
      if ( a2(&v93, 1, 4, a1) != 4 )
        return 0;
      return a2(*(char **)(a3 + 64), 1, *(unsigned int *)(a3 + 56), a1) == *(unsigned int *)(a3 + 56);
    default:
      v29 = *(char **)(a3 + 16);
      v30 = *(unsigned int *)(a3 + 8);
      return a2(v29, 1, v30, a1) == v30;
  }
  while ( 1 )
  {
    v56 = *(_QWORD *)(a3 + 168);
    v57 = 8;
    v58 = *(_QWORD *)(v56 + 32 * v91);
    do
    {
      v59 = &v93 + v57--;
      *(v59 - 1) = v58;
      v58 >>= 8;
    }
    while ( (_DWORD)v57 );
    if ( a2(&v93, 1, 8, a1) != 8 )
      return 0;
    v60 = 1;
    v61 = *(unsigned __int8 *)(v56 + 32 * v91 + 8);
    do
    {
      v62 = &v93 + v60--;
      *(v62 - 1) = v61;
      v61 >>= 8;
    }
    while ( (_DWORD)v60 );
    if ( a2(&v93, 1, 1, a1) != 1 )
      return 0;
    v63 = v56 + 32 * v91;
    if ( a2((char *)(v63 + 9), 1, 12, a1) != 12 )
      return 0;
    memset(&v93, 0, 0xEu);
    v93 = (32 * *(_BYTE *)(v63 + 22)) & 0x40 | (*(_BYTE *)(v63 + 22) << 7);
    if ( a2(&v93, 1, 14, a1) != 14 )
      return 0;
    v92 = (_BYTE *)(v56 + 32 * v91 + 23);
    v64 = 1;
    v65 = (unsigned __int8)*v92;
    do
    {
      v66 = &v93 + v64--;
      *(v66 - 1) = v65;
      v65 >>= 8;
    }
    while ( (_DWORD)v64 );
    if ( a2(&v93, 1, 1, a1) != 1 )
      return 0;
    if ( *v92 )
    {
      v90 = (__int64 *)(v56 + 32 * v91 + 24);
      v67 = 0;
      do
      {
        v68 = 8;
        v69 = *v90;
        v70 = *(_QWORD *)(*v90 + 16 * v67);
        do
        {
          v71 = &v93 + v68--;
          *(v71 - 1) = v70;
          v70 >>= 8;
        }
        while ( (_DWORD)v68 );
        if ( a2(&v93, 1, 8, a1) != 8 )
          return 0;
        v72 = *(unsigned __int8 *)(v69 + 16 * v67 + 8);
        v73 = 1;
        do
        {
          v74 = &v93 + v73--;
          *(v74 - 1) = v72;
          v72 >>= 8;
        }
        while ( (_DWORD)v73 );
        if ( a2(&v93, 1, 1, a1) != 1 )
          return 0;
        memset(&v93, 0, 3u);
        if ( a2(&v93, 1, 3, a1) != 3 )
          return 0;
      }
      while ( ++v67 < (unsigned __int64)(unsigned __int8)*v92 );
    }
    result = 1;
    if ( ++v91 >= (unsigned __int64)*(unsigned int *)(a3 + 164) )
      return result;
  }
}
// 24704: conditional instruction was optimized away because w17.4==8
// 24750: conditional instruction was optimized away because %var_480.4==1
// 24820: conditional instruction was optimized away because w26.4==1
// 24884: conditional instruction was optimized away because w26.4==8
// 24888: conditional instruction was optimized away because %var_4A0.4==1

//----- (0000000000024E38) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_new(unsigned int a1)
{
  void *v2; // x19
  _QWORD *v3; // x0
  int v4; // w8
  unsigned int v5; // w8
  char *v6; // x22
  int v7; // w0
  int v8; // w20
  void *v9; // x21
  unsigned int v10; // w8
  size_t v11; // x23
  void *v12; // x0
  char *v14; // x0
  char *v15; // x0

  if ( a1 <= 0x7E )
  {
    v3 = calloc(1u, 0xB0u);
    v2 = v3;
    if ( !v3 )
      return v2;
    *(_DWORD *)v3 = a1;
    switch ( a1 )
    {
      case 0u:
        v4 = 34;
        goto LABEL_14;
      case 2u:
        v5 = 32;
        goto LABEL_13;
      case 4u:
        v6 = FLAC__VENDOR_STRING;
        v7 = strlen(FLAC__VENDOR_STRING);
        v8 = v7;
        v9 = 0;
        *((_DWORD *)v2 + 4) = v7;
        if ( !v6 )
          goto LABEL_11;
        v10 = v7 + 1;
        if ( v7 == -1 )
          goto LABEL_11;
        v11 = v10;
        v12 = malloc(v10);
        v9 = v12;
        if ( !v12 )
          goto LABEL_20;
        memcpy(v12, v6, v11);
LABEL_11:
        *((_QWORD *)v2 + 3) = v9;
        v4 = v8 + 8;
LABEL_14:
        *((_DWORD *)v2 + 2) = v4;
        return v2;
      case 5u:
        v5 = 3168;
LABEL_13:
        v4 = v5 >> 3;
        goto LABEL_14;
      case 6u:
        v3[3] = 0;
        *((_DWORD *)v3 + 2) = 32;
        v3[4] = 0;
        v14 = strdup("");
        if ( !v14 )
          goto LABEL_20;
        *((_QWORD *)v2 + 3) = v14;
        v15 = strdup("");
        if ( v15 )
        {
          *((_QWORD *)v2 + 4) = v15;
          return v2;
        }
        free(*((void **)v2 + 3));
LABEL_20:
        free(v2);
        break;
      default:
        return v2;
    }
  }
  return 0;
}
// 80010: using guessed type char *FLAC__VENDOR_STRING;

//----- (0000000000025064) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_clone(__int64 *a1)
{
  _DWORD *v2; // x0
  __int64 v3; // x19
  __int64 v4; // d0
  size_t v5; // x21
  void *v6; // x22
  const void *v7; // x20
  void *v8; // x0
  bool v9; // zf
  unsigned int v10; // w8
  void *v11; // x21
  unsigned int v12; // w8
  const void *v13; // x20
  size_t v14; // x22
  void *v15; // x0
  void *v16; // x0
  size_t v17; // x21
  const void *v18; // x23
  _BYTE *v19; // x0
  _BYTE *v20; // x22
  size_t v21; // x21
  __int64 v22; // x25
  char *v23; // x20
  __int64 v24; // x26
  size_t v25; // x27
  size_t v26; // x22
  const void *v27; // x24
  _BYTE *v28; // x0
  _BYTE *v29; // x23
  char *v30; // x8
  unsigned __int64 v31; // x21
  __int64 v32; // x23
  char *v33; // x20
  __int64 v34; // x24
  unsigned __int64 i; // x25
  __int64 v36; // x26
  char *v37; // x8
  void *v38; // x0
  void *v39; // x22
  char *v40; // x21
  char *v41; // x22
  void *v42; // x21
  size_t v43; // x22
  const void *v44; // x20
  void *v45; // x0
  __int64 v46; // x22
  void *v47; // x0
  __int64 v48; // x22

  v2 = FLAC__metadata_object_new(*(_DWORD *)a1);
  v3 = (__int64)v2;
  if ( !v2 )
    return v3;
  v4 = *a1;
  *(_QWORD *)v2 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  v2[2] = v5;
  switch ( (int)v4 )
  {
    case 0:
      *((_QWORD *)v2 + 8) = a1[8];
      *((_OWORD *)v2 + 3) = *((_OWORD *)a1 + 3);
      *((_OWORD *)v2 + 2) = *((_OWORD *)a1 + 2);
      *((_OWORD *)v2 + 1) = *((_OWORD *)a1 + 1);
      return v3;
    case 1:
      return v3;
    case 2:
      if ( (unsigned int)v5 < 4 )
        goto LABEL_60;
      memcpy(v2 + 4, a1 + 2, sizeof(_DWORD));
      v10 = v5 - 4;
      v9 = (_DWORD)v5 == 4;
      v11 = 0;
      if ( v9 )
        goto LABEL_18;
      goto LABEL_15;
    case 3:
      v12 = *((_DWORD *)a1 + 4);
      v2[4] = v12;
      if ( v12 >= 0xAAAAAAB )
        goto LABEL_60;
      v10 = 24 * v12;
      v11 = 0;
      if ( !v10 )
        goto LABEL_18;
LABEL_15:
      v13 = (const void *)a1[3];
      if ( !v13 )
        goto LABEL_18;
      v14 = v10;
      v15 = malloc(v10);
      v11 = v15;
      if ( !v15 )
        goto LABEL_60;
      memcpy(v15, v13, v14);
LABEL_18:
      *(_QWORD *)(v3 + 24) = v11;
      return v3;
    case 4:
      v16 = (void *)*((_QWORD *)v2 + 3);
      if ( v16 )
      {
        free(v16);
        *(_QWORD *)(v3 + 24) = 0;
      }
      v17 = *((unsigned int *)a1 + 4);
      *(_DWORD *)(v3 + 16) = v17;
      v18 = (const void *)a1[3];
      if ( v18 )
      {
        v19 = malloc(v17 + 1);
        v20 = v19;
        if ( !v19 )
          goto LABEL_60;
        memcpy(v19, v18, v17);
        v20[v17] = 0;
        *(_QWORD *)(v3 + 24) = v20;
        v21 = *((unsigned int *)a1 + 8);
        if ( (_DWORD)v21 )
          goto LABEL_24;
LABEL_48:
        v23 = 0;
LABEL_49:
        *(_QWORD *)(v3 + 40) = v23;
        *(_DWORD *)(v3 + 32) = v21;
        return v3;
      }
      *(_QWORD *)(v3 + 24) = 0;
      v21 = *((unsigned int *)a1 + 8);
      if ( !(_DWORD)v21 )
        goto LABEL_48;
LABEL_24:
      v22 = a1[5];
      v23 = (char *)calloc(v21, 0x10u);
      if ( !v23 )
        goto LABEL_59;
      v24 = 0;
      v25 = 0;
      while ( 1 )
      {
        v26 = *(unsigned int *)(v22 + v24);
        *(_DWORD *)&v23[v24] = v26;
        v27 = *(const void **)(v22 + v24 + 8);
        if ( !v27 )
        {
          v29 = 0;
          goto LABEL_30;
        }
        v28 = malloc(v26 + 1);
        v29 = v28;
        if ( !v28 )
          break;
        memcpy(v28, v27, v26);
        v29[v26] = 0;
LABEL_30:
        ++v25;
        v30 = &v23[v24];
        v24 += 16;
        *((_QWORD *)v30 + 1) = v29;
        if ( v25 >= v21 )
          goto LABEL_49;
      }
      v48 = 8;
      do
      {
        free(*(void **)&v23[v48]);
        --v21;
        v48 += 16;
      }
      while ( v21 );
      free(v23);
LABEL_59:
      *(_QWORD *)(v3 + 40) = 0;
      *(_DWORD *)(v3 + 32) = 0;
LABEL_60:
      FLAC__metadata_object_delete_data(v3);
      free((void *)v3);
      return 0;
    case 5:
      memcpy(v2 + 4, a1 + 2, 0xA0u);
      v31 = *((unsigned int *)a1 + 41);
      if ( !(_DWORD)v31 )
        return v3;
      v32 = a1[21];
      v33 = (char *)calloc(*((unsigned int *)a1 + 41), 0x20u);
      if ( !v33 )
        goto LABEL_55;
      v34 = 0;
      for ( i = 0; i < v31; ++i )
      {
        v36 = v32 + v34;
        v37 = &v33[v34];
        *((_OWORD *)v37 + 1) = *(_OWORD *)(v32 + v34 + 16);
        *(_OWORD *)v37 = *(_OWORD *)(v32 + v34);
        if ( *(_QWORD *)(v32 + v34 + 24) )
        {
          v38 = safe_malloc_mul_2op_p(*(unsigned __int8 *)(v36 + 23), 0x10u);
          v39 = v38;
          if ( !v38 )
          {
            v46 = 24;
            do
            {
              v47 = *(void **)&v33[v46];
              if ( v47 )
                free(v47);
              --v31;
              v46 += 32;
            }
            while ( v31 );
            free(v33);
LABEL_55:
            *(_QWORD *)(v3 + 168) = 0;
            goto LABEL_60;
          }
          memcpy(v38, *(const void **)(v32 + v34 + 24), 16LL * *(unsigned __int8 *)(v36 + 23));
          *(_QWORD *)&v33[v34 + 24] = v39;
        }
        v34 += 32;
      }
      *(_QWORD *)(v3 + 168) = v33;
      return v3;
    case 6:
      v2[4] = *((_DWORD *)a1 + 4);
      v40 = strdup((const char *)a1[3]);
      if ( !v40 )
        goto LABEL_60;
      free(*(void **)(v3 + 24));
      *(_QWORD *)(v3 + 24) = v40;
      v41 = strdup((const char *)a1[4]);
      if ( !v41 )
        goto LABEL_60;
      free(*(void **)(v3 + 32));
      *(_QWORD *)(v3 + 32) = v41;
      v42 = 0;
      *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 5);
      v43 = *((unsigned int *)a1 + 14);
      *(_DWORD *)(v3 + 56) = v43;
      if ( !(_DWORD)v43 )
        goto LABEL_46;
      v44 = (const void *)a1[8];
      if ( !v44 )
        goto LABEL_46;
      v45 = malloc(v43);
      v42 = v45;
      if ( !v45 )
        goto LABEL_60;
      memcpy(v45, v44, v43);
LABEL_46:
      *(_QWORD *)(v3 + 64) = v42;
      return v3;
    default:
      v6 = 0;
      if ( !(_DWORD)v5 )
        goto LABEL_8;
      v7 = (const void *)a1[2];
      if ( !v7 )
        goto LABEL_8;
      v8 = malloc(v5);
      v6 = v8;
      if ( !v8 )
        goto LABEL_60;
      memcpy(v8, v7, v5);
LABEL_8:
      *(_QWORD *)(v3 + 16) = v6;
      return v3;
  }
}

//----- (0000000000025454) ----------------------------------------------------
void __fastcall FLAC__metadata_object_delete(void *a1)
{
  FLAC__metadata_object_delete_data((__int64)a1);
  free(a1);
}

//----- (0000000000025478) ----------------------------------------------------
void __fastcall FLAC__metadata_object_delete_data(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void **v5; // x20
  __int64 v6; // x21
  void **v7; // x22
  void *v8; // t1
  void **v9; // x20
  __int64 v10; // x21
  void **v11; // x22
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
      return;
    case 2:
    case 3:
      v2 = *(void **)(a1 + 24);
      if ( v2 )
      {
        free(v2);
        *(_QWORD *)(a1 + 24) = 0;
      }
      break;
    case 4:
      v4 = *(void **)(a1 + 24);
      if ( v4 )
      {
        free(v4);
        *(_QWORD *)(a1 + 24) = 0;
      }
      v5 = *(void ***)(a1 + 40);
      if ( v5 )
      {
        v6 = *(unsigned int *)(a1 + 32);
        if ( (_DWORD)v6 )
        {
          v7 = v5 + 1;
          do
          {
            v8 = *v7;
            v7 += 2;
            free(v8);
            --v6;
          }
          while ( v6 );
        }
        free(v5);
        *(_QWORD *)(a1 + 40) = 0;
        *(_DWORD *)(a1 + 32) = 0;
      }
      break;
    case 5:
      v9 = *(void ***)(a1 + 168);
      if ( v9 )
      {
        v10 = *(unsigned int *)(a1 + 164);
        if ( (_DWORD)v10 )
        {
          v11 = v9 + 3;
          do
          {
            if ( *v11 )
              free(*v11);
            --v10;
            v11 += 4;
          }
          while ( v10 );
        }
        free(v9);
        *(_QWORD *)(a1 + 168) = 0;
        *(_DWORD *)(a1 + 164) = 0;
      }
      break;
    case 6:
      v12 = *(void **)(a1 + 24);
      if ( v12 )
      {
        free(v12);
        *(_QWORD *)(a1 + 24) = 0;
      }
      v13 = *(void **)(a1 + 32);
      if ( v13 )
      {
        free(v13);
        *(_QWORD *)(a1 + 32) = 0;
      }
      v14 = *(void **)(a1 + 64);
      if ( v14 )
      {
        free(v14);
        *(_QWORD *)(a1 + 64) = 0;
      }
      break;
    default:
      v3 = *(void **)(a1 + 16);
      if ( v3 )
      {
        free(v3);
        *(_QWORD *)(a1 + 16) = 0;
      }
      break;
  }
}

//----- (00000000000255CC) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_is_equal(int *a1, __int64 a2)
{
  int v4; // w8
  size_t v5; // x2
  __int64 result; // x0
  const void *v7; // x0
  const void *v8; // x1
  unsigned int v10; // w10
  __int64 v11; // x8
  __int64 v12; // x9
  unsigned int v13; // w12
  __int64 v14; // x11
  __int64 v15; // x12
  __int64 v16; // x13
  size_t v17; // x2
  const void *v18; // x0
  const void *v19; // x1
  unsigned int v20; // w21
  __int64 v21; // x20
  __int64 v22; // x19
  unsigned int v23; // w8
  unsigned int v24; // w22
  __int64 v25; // x23
  unsigned __int64 v26; // x8
  __int64 v27; // x10
  __int64 v28; // x11
  unsigned __int64 v29; // x9
  unsigned __int8 *v30; // x10
  unsigned __int8 *v31; // x11
  const char *v32; // x8
  const char *v33; // x1
  const char *v34; // x8
  const char *v35; // x1
  size_t v36; // x2
  const void *v37; // x8
  const void *v38; // x1
  unsigned __int64 v39; // x21
  __int64 v40; // x9
  unsigned __int64 v41; // x22
  const void **v42; // x19
  const void **v43; // x20
  const void *v44; // x0
  const void *v45; // x1

  v4 = *a1;
  if ( *a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1[1] != *(_DWORD *)(a2 + 4) )
    return 0;
  v5 = (unsigned int)a1[2];
  if ( (_DWORD)v5 != *(_DWORD *)(a2 + 8) )
    return 0;
  result = 1;
  switch ( v4 )
  {
    case 0:
      if ( a1[4] != *(_DWORD *)(a2 + 16)
        || a1[5] != *(_DWORD *)(a2 + 20)
        || a1[6] != *(_DWORD *)(a2 + 24)
        || a1[7] != *(_DWORD *)(a2 + 28)
        || a1[8] != *(_DWORD *)(a2 + 32)
        || a1[9] != *(_DWORD *)(a2 + 36)
        || a1[10] != *(_DWORD *)(a2 + 40)
        || *((_QWORD *)a1 + 6) != *(_QWORD *)(a2 + 48) )
      {
        return 0;
      }
      v7 = a1 + 14;
      v8 = (const void *)(a2 + 56);
      v5 = 16;
      return memcmp(v7, v8, v5) == 0;
    case 1:
      return result;
    case 2:
      if ( a1[4] != *(_DWORD *)(a2 + 16) )
        return 0;
      v7 = (const void *)*((_QWORD *)a1 + 3);
      v8 = *(const void **)(a2 + 24);
      if ( v7 && v8 )
      {
        v5 -= 4LL;
        return memcmp(v7, v8, v5) == 0;
      }
      else
      {
        return v7 == v8;
      }
    case 3:
      v10 = a1[4];
      if ( v10 != *(_DWORD *)(a2 + 16) )
        return 0;
      v11 = *((_QWORD *)a1 + 3);
      v12 = *(_QWORD *)(a2 + 24);
      if ( !v11 || !v12 )
        return v11 == v12;
      if ( !v10 )
        return 1;
      v13 = 0;
      result = 1;
      while ( 1 )
      {
        v14 = v13;
        if ( *(_QWORD *)(v11 + 24LL * v13) != *(_QWORD *)(v12 + 24LL * v13) )
          break;
        v15 = v11 + 24LL * v13;
        v16 = v12 + 24 * v14;
        if ( *(_QWORD *)(v15 + 8) != *(_QWORD *)(v16 + 8) || *(_DWORD *)(v15 + 16) != *(_DWORD *)(v16 + 16) )
          break;
        v13 = v14 + 1;
        if ( (int)v14 + 1 >= v10 )
          return result;
      }
      return 0;
    case 4:
      v17 = (unsigned int)a1[4];
      if ( (_DWORD)v17 != *(_DWORD *)(a2 + 16) )
        return 0;
      v18 = (const void *)*((_QWORD *)a1 + 3);
      v19 = *(const void **)(a2 + 24);
      if ( v18 && v19 )
      {
        if ( memcmp(v18, v19, v17) )
          return 0;
      }
      else if ( v18 != v19 )
      {
        return 0;
      }
      v39 = (unsigned int)a1[8];
      if ( (_DWORD)v39 != *(_DWORD *)(a2 + 32) )
        return 0;
      if ( !(_DWORD)v39 )
        return 1;
      v40 = *(_QWORD *)(a2 + 40);
      v41 = 0;
      v42 = (const void **)(*((_QWORD *)a1 + 5) + 8LL);
      v43 = (const void **)(v40 + 8);
      do
      {
        v44 = *v42;
        v45 = *v43;
        if ( *v42 && v45 )
        {
          if ( memcmp(v44, v45, *((unsigned int *)v42 - 2)) )
            return 0;
        }
        else if ( v44 != v45 )
        {
          return 0;
        }
        ++v41;
        v42 += 2;
        v43 += 2;
        result = 1;
      }
      while ( v41 < v39 );
      return result;
    case 5:
      if ( strcmp((const char *)a1 + 16, (const char *)(a2 + 16)) )
        return 0;
      if ( *((_QWORD *)a1 + 19) != *(_QWORD *)(a2 + 152) )
        return 0;
      if ( a1[40] != *(_DWORD *)(a2 + 160) )
        return 0;
      v20 = a1[41];
      if ( v20 != *(_DWORD *)(a2 + 164) )
        return 0;
      v21 = *((_QWORD *)a1 + 21);
      v22 = *(_QWORD *)(a2 + 168);
      if ( !v21 || !v22 )
        return v21 == v22;
      if ( !v20 )
        return 1;
      v23 = 0;
      while ( 1 )
      {
        v24 = v23;
        v25 = 32LL * v23;
        if ( *(_QWORD *)(v21 + v25) != *(_QWORD *)(v22 + v25) )
          return 0;
        if ( *(unsigned __int8 *)(v21 + v25 + 8) != *(unsigned __int8 *)(v22 + v25 + 8) )
          return 0;
        if ( memcmp((const void *)(v21 + v25 + 9), (const void *)(v22 + v25 + 9), 0xDu) )
          return 0;
        if ( ((*(_BYTE *)(v22 + v25 + 22) ^ *(_BYTE *)(v21 + v25 + 22)) & 3) != 0 )
          return 0;
        v26 = *(unsigned __int8 *)(v21 + v25 + 23);
        if ( (_DWORD)v26 != *(unsigned __int8 *)(v22 + v25 + 23) )
          return 0;
        v27 = *(_QWORD *)(v21 + v25 + 24);
        v28 = *(_QWORD *)(v22 + v25 + 24);
        if ( v27 && v28 )
        {
          if ( *(_BYTE *)(v21 + v25 + 23) )
          {
            v29 = 0;
            v30 = (unsigned __int8 *)(v27 + 8);
            v31 = (unsigned __int8 *)(v28 + 8);
            while ( *((_QWORD *)v30 - 1) == *((_QWORD *)v31 - 1) && *v30 == *v31 )
            {
              ++v29;
              v30 += 16;
              v31 += 16;
              if ( v29 >= v26 )
                goto LABEL_59;
            }
            return 0;
          }
        }
        else if ( v27 != v28 )
        {
          return 0;
        }
LABEL_59:
        v23 = v24 + 1;
        if ( v24 + 1 >= v20 )
          return 1;
      }
    case 6:
      if ( a1[4] != *(_DWORD *)(a2 + 16) )
        return 0;
      v32 = (const char *)*((_QWORD *)a1 + 3);
      v33 = *(const char **)(a2 + 24);
      if ( v32 == v33 )
        goto LABEL_66;
      result = 0;
      if ( !v32 || !v33 )
        return result;
      if ( strcmp(*((const char **)a1 + 3), v33) )
        return 0;
LABEL_66:
      v34 = (const char *)*((_QWORD *)a1 + 4);
      v35 = *(const char **)(a2 + 32);
      if ( v34 == v35 )
        goto LABEL_70;
      result = 0;
      if ( !v34 || !v35 )
        return result;
      if ( strcmp(*((const char **)a1 + 4), v35) )
        return 0;
LABEL_70:
      if ( a1[10] != *(_DWORD *)(a2 + 40) )
        return 0;
      if ( a1[11] != *(_DWORD *)(a2 + 44) )
        return 0;
      if ( a1[12] != *(_DWORD *)(a2 + 48) )
        return 0;
      if ( a1[13] != *(_DWORD *)(a2 + 52) )
        return 0;
      v36 = (unsigned int)a1[14];
      if ( (_DWORD)v36 != *(_DWORD *)(a2 + 56) )
        return 0;
      v37 = (const void *)*((_QWORD *)a1 + 8);
      v38 = *(const void **)(a2 + 64);
      if ( v37 == v38 )
        return 1;
      result = 0;
      if ( !v37 || !v38 )
        return result;
      return !memcmp(*((const void **)a1 + 8), v38, v36);
    default:
      v7 = (const void *)*((_QWORD *)a1 + 2);
      v8 = *(const void **)(a2 + 16);
      if ( v7 && v8 )
        return memcmp(v7, v8, v5) == 0;
      return v8 == v7;
  }
}

//----- (0000000000025A94) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_application_set_data(__int64 a1, const void *a2, unsigned int a3, int a4)
{
  void *v5; // x21
  void *v8; // x22
  void *result; // x0

  v5 = *(void **)(a1 + 24);
  if ( a4 )
  {
    v8 = 0;
    if ( a2 && a3 )
    {
      result = malloc(a3);
      v8 = result;
      if ( !result )
        return result;
      memcpy(result, a2, a3);
    }
  }
  else
  {
    v8 = (void *)a2;
  }
  *(_QWORD *)(a1 + 24) = v8;
  free(v5);
  result = &dword_0 + 1;
  *(_DWORD *)(a1 + 8) = a3 + 4;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000025B2C) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_resize_points(__int64 a1, unsigned int a2)
{
  void *v3; // x22
  char *result; // x0
  __int64 v6; // x9
  __int64 v7; // x24
  unsigned __int64 v8; // x21
  _QWORD *v9; // x0
  __int64 v10; // x10
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 v13; // x11
  char *v14; // x10
  __int64 v15; // x11
  __int64 v16; // x10
  char *v17; // x9

  v3 = *(void **)(a1 + 24);
  if ( !v3 )
  {
    if ( !a2 )
      return (_BYTE *)(&dword_0 + 1);
    result = (char *)safe_malloc_mul_2op_p(a2, 0x18u);
    if ( !result )
    {
      *(_QWORD *)(a1 + 24) = 0;
      return result;
    }
    if ( a2 >= 2 )
    {
      v6 = a2 & 0xFFFFFFFE;
      v14 = result + 24;
      v15 = v6;
      do
      {
        *((_QWORD *)v14 - 3) = -1;
        *((_QWORD *)v14 - 2) = 0;
        *(_QWORD *)v14 = -1;
        *((_QWORD *)v14 + 1) = 0;
        *((_DWORD *)v14 - 2) = 0;
        *((_DWORD *)v14 + 4) = 0;
        v15 -= 2;
        v14 += 48;
      }
      while ( v15 );
      if ( v6 == a2 )
        goto LABEL_24;
    }
    else
    {
      v6 = 0;
    }
    v16 = a2 - v6;
    v17 = &result[24 * v6 + 16];
    do
    {
      *((_QWORD *)v17 - 2) = -1;
      *((_QWORD *)v17 - 1) = 0;
      *(_DWORD *)v17 = 0;
      v17 += 24;
      --v16;
    }
    while ( v16 );
LABEL_24:
    *(_QWORD *)(a1 + 24) = result;
    goto LABEL_25;
  }
  if ( a2 > 0xAAAAAAA )
    return 0;
  v7 = *(unsigned int *)(a1 + 16);
  v8 = 24LL * a2;
  if ( !a2 )
  {
    free(*(void **)(a1 + 24));
    v9 = 0;
    *(_QWORD *)(a1 + 24) = 0;
    if ( v8 > 24 * v7 )
      goto LABEL_11;
    goto LABEL_25;
  }
  v9 = realloc(*(void **)(a1 + 24), 24LL * a2);
  if ( v9 )
  {
    *(_QWORD *)(a1 + 24) = v9;
    if ( v8 > 24 * v7 )
    {
LABEL_11:
      v10 = *(unsigned int *)(a1 + 16);
      if ( (unsigned int)v10 < a2 )
      {
        v11 = 24 * v10;
        v9[3 * v10] = -1;
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24 * v10 + 8) = 0;
        *(_DWORD *)(*(_QWORD *)(a1 + 24) + 24 * v10 + 16) = 0;
        if ( v10 + 1 != a2 )
        {
          v12 = a2 - 1LL - v10;
          do
          {
            --v12;
            *(_QWORD *)(*(_QWORD *)(a1 + 24) + v11 + 24) = -1;
            *(_QWORD *)(*(_QWORD *)(a1 + 24) + v11 + 32) = 0;
            v13 = *(_QWORD *)(a1 + 24) + v11;
            v11 += 24;
            *(_DWORD *)(v13 + 40) = 0;
          }
          while ( v12 );
        }
      }
    }
LABEL_25:
    *(_DWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 8) = 18 * a2;
    return (_BYTE *)(&dword_0 + 1);
  }
  free(v3);
  result = 0;
  *(_QWORD *)(a1 + 24) = 0;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000025D14) ----------------------------------------------------
long double __fastcall FLAC__metadata_object_seektable_set_point(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x8
  long double result; // q0

  v3 = *(_QWORD *)(a1 + 24) + 24LL * a2;
  *(_QWORD *)(v3 + 16) = *(_QWORD *)(a3 + 16);
  result = *(long double *)a3;
  *(_OWORD *)v3 = *(_OWORD *)a3;
  return result;
}

//----- (0000000000025D34) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_insert_point(__int64 a1, int a2, __int128 *a3)
{
  char *result; // x0
  __int64 v7; // x10
  __int64 v8; // x8
  int v9; // w10
  __int64 v10; // x11
  __int64 v11; // x13
  __int64 v12; // x14
  __int64 v13; // x13
  __int128 v14; // q0
  __int64 v15; // x9

  _ReadStatusReg(TPIDR_EL0);
  result = FLAC__metadata_object_seektable_resize_points(a1, *(_DWORD *)(a1 + 16) + 1);
  if ( (_DWORD)result )
  {
    v7 = *(int *)(a1 + 16);
    v8 = v7 - 1;
    if ( (int)v7 - 1 > a2 )
    {
      v9 = v7 - 2;
      v10 = 24 * v8;
      do
      {
        v11 = *(_QWORD *)(a1 + 24);
        --v8;
        v12 = v11 + 24LL * v9;
        v13 = v11 + v10;
        --v9;
        v10 -= 24;
        *(_QWORD *)(v13 + 16) = *(_QWORD *)(v12 + 16);
        *(_OWORD *)v13 = *(_OWORD *)v12;
      }
      while ( v8 > a2 );
    }
    result = (_BYTE *)(&dword_0 + 1);
    v14 = *a3;
    v15 = *(_QWORD *)(a1 + 24) + 24LL * (unsigned int)a2;
    *(_QWORD *)(v15 + 16) = *((_QWORD *)a3 + 2);
    *(_OWORD *)v15 = v14;
    *(_DWORD *)(a1 + 8) = 18 * *(_DWORD *)(a1 + 16);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000025E28) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_delete_point(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // x1
  unsigned __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x10
  __int128 v7; // q0

  LODWORD(v3) = *(_DWORD *)(a1 + 16) - 1;
  if ( (unsigned int)v3 > a2 )
  {
    v4 = a2;
    v5 = 24LL * a2;
    do
    {
      ++v4;
      v6 = *(_QWORD *)(a1 + 24) + v5;
      v7 = *(_OWORD *)(v6 + 24);
      v5 += 24;
      *(_QWORD *)(v6 + 16) = *(_QWORD *)(v6 + 40);
      *(_OWORD *)v6 = v7;
      v3 = (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
    }
    while ( v4 < v3 );
  }
  return FLAC__metadata_object_seektable_resize_points(a1, v3);
}

//----- (0000000000025E7C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_seektable_is_legal(__int64 a1)
{
  return FLAC__format_seektable_is_legal((unsigned int *)(a1 + 16));
}

//----- (0000000000025E84) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_template_append_placeholders(__int64 a1, int a2)
{
  if ( a2 )
    return FLAC__metadata_object_seektable_resize_points(a1, *(_DWORD *)(a1 + 16) + a2);
  else
    return (_BYTE *)(&dword_0 + 1);
}
// 0: using guessed type int dword_0;

//----- (0000000000025E9C) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_template_append_point(__int64 a1, __int64 a2)
{
  char *result; // x0
  __int64 v5; // x8

  result = FLAC__metadata_object_seektable_resize_points(a1, *(_DWORD *)(a1 + 16) + 1);
  if ( (_DWORD)result )
  {
    result = (_BYTE *)(&dword_0 + 1);
    v5 = *(_QWORD *)(a1 + 24) + 24LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
    *(_QWORD *)v5 = a2;
    *(_QWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 16) = 0;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000025EEC) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_template_append_points(__int64 a1, __int64 *a2, unsigned int a3)
{
  unsigned int v6; // w22
  char *result; // x0
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // t1
  __int64 v11; // x12

  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 16);
    result = FLAC__metadata_object_seektable_resize_points(a1, v6 + a3);
    if ( !(_DWORD)result )
      return result;
    v8 = *(_QWORD *)(a1 + 24);
    v9 = a3;
    do
    {
      v10 = *a2++;
      v11 = v8 + 24LL * v6;
      --v9;
      ++v6;
      *(_DWORD *)(v11 + 16) = 0;
      *(_QWORD *)v11 = v10;
      *(_QWORD *)(v11 + 8) = 0;
    }
    while ( v9 );
  }
  return (_BYTE *)(&dword_0 + 1);
}
// 0: using guessed type int dword_0;

//----- (0000000000025F60) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_template_append_spaced_points(__int64 a1, unsigned int a2, __int64 a3)
{
  char *result; // x0
  unsigned int v7; // w22
  __int64 v8; // x8
  __int64 v9; // x11
  unsigned int v10; // w10
  unsigned __int64 v11; // x12
  __int64 v12; // x11
  unsigned __int64 v13; // x14
  __int64 v14; // x15
  unsigned __int64 v15; // x12
  __int64 v16; // x15
  unsigned __int64 v17; // x17
  unsigned __int64 v18; // x18
  __int64 v19; // x0
  __int64 v20; // x16

  result = (_BYTE *)(&dword_0 + 1);
  if ( a2 )
  {
    if ( a3 )
    {
      v7 = *(_DWORD *)(a1 + 16);
      result = FLAC__metadata_object_seektable_resize_points(a1, v7 + a2);
      if ( (_DWORD)result )
      {
        v8 = *(_QWORD *)(a1 + 24);
        if ( a2 >= 2 )
        {
          v9 = 0;
          if ( !__CFADD__(v7, a2 - 1) && !(((unsigned __int64)a2 - 1) >> 32) )
          {
            v9 = a2 & 0xFFFFFFFE;
            v15 = 0;
            v10 = v7 + (a2 & 0xFFFFFFFE);
            v16 = v9;
            do
            {
              v17 = a3 + v15;
              v18 = v15 / a2;
              v19 = v8 + 24LL * v7;
              v15 += 2 * a3;
              v16 -= 2;
              v20 = v8 + 24LL * (v7 + 1);
              v7 += 2;
              *(_QWORD *)v19 = v18;
              *(_QWORD *)(v19 + 8) = 0;
              *(_QWORD *)v20 = v17 / a2;
              *(_QWORD *)(v20 + 8) = 0;
              *(_DWORD *)(v19 + 16) = 0;
              *(_DWORD *)(v20 + 16) = 0;
            }
            while ( v16 );
            if ( v9 == a2 )
              return (_BYTE *)(&dword_0 + 1);
            goto LABEL_7;
          }
        }
        else
        {
          v9 = 0;
        }
        v10 = v7;
LABEL_7:
        v11 = v9 * a3;
        v12 = a2 - v9;
        do
        {
          v13 = v11 / a2;
          v14 = v8 + 24LL * v10++;
          --v12;
          v11 += a3;
          *(_QWORD *)v14 = v13;
          *(_QWORD *)(v14 + 8) = 0;
          *(_DWORD *)(v14 + 16) = 0;
        }
        while ( v12 );
        return (_BYTE *)(&dword_0 + 1);
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000026068) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(
        __int64 a1,
        unsigned int a2,
        unsigned __int64 a3)
{
  char *result; // x0
  unsigned int v5; // w20
  unsigned __int64 v6; // x22
  unsigned __int64 v7; // x21
  unsigned int v8; // w23
  __int64 v9; // x8
  __int64 v10; // x10
  __int64 v11; // x11
  __int64 v12; // x10
  unsigned __int64 v13; // x12
  bool v14; // w13
  unsigned __int64 v15; // x12
  __int64 v16; // x13
  unsigned int v17; // w14
  unsigned int v18; // w0
  __int64 v19; // x18
  __int64 v20; // x18
  unsigned __int64 v21; // x17
  __int64 v22; // x0
  unsigned int v23; // w12
  __int64 v24; // x13
  bool v25; // cc

  result = (_BYTE *)(&dword_0 + 1);
  if ( a2 && a3 )
  {
    v5 = *(_DWORD *)(a1 + 16);
    v6 = a3 % a2 ? a3 / a2 + 1 : a3 / a2;
    v7 = v6 <= 0x8000 ? v6 : 0x8000LL;
    v8 = v6 <= 0x8000 ? a2 : a3 >> 15;
    result = FLAC__metadata_object_seektable_resize_points(a1, v5 + (unsigned int)v7);
    if ( (_DWORD)result )
    {
      if ( v7 )
      {
        v9 = *(_QWORD *)(a1 + 24);
        if ( v7 == 1 )
        {
          v10 = 0;
          LODWORD(v11) = 0;
        }
        else
        {
          if ( ~v6 > 0xFFFFFFFFFFFF7FFFLL )
            v12 = ~v6;
          else
            v12 = -32769;
          v13 = -2 - v12;
          LODWORD(v11) = 0;
          v14 = __CFADD__(v5, -2 - v12);
          v10 = 0;
          if ( (_DWORD)v13 != -1 )
          {
            v15 = HIDWORD(v13);
            if ( !v15 && !v14 )
            {
              v11 = (unsigned __int16)v7 & 0xFFFE;
              v16 = 0;
              v17 = v5;
              v10 = v11 * v8;
              v5 += v7 & 0xFFFE;
              do
              {
                v18 = v17 + v16 + 1;
                v19 = v17 + (unsigned int)v16;
                v16 += 2;
                v20 = v9 + 24 * v19;
                v21 = v8 + v15;
                v22 = v9 + 24LL * v18;
                *(_QWORD *)v20 = v15;
                *(_QWORD *)(v20 + 8) = 0;
                v15 += 2LL * v8;
                *(_QWORD *)v22 = v21;
                *(_QWORD *)(v22 + 8) = 0;
                *(_DWORD *)(v20 + 16) = 0;
                *(_DWORD *)(v22 + 16) = 0;
              }
              while ( v16 != v11 );
              if ( v7 == v11 )
                return (_BYTE *)(&dword_0 + 1);
            }
          }
        }
        v23 = v11 + 1;
        do
        {
          v24 = v9 + 24LL * v5++;
          v25 = v7 > v23++;
          *(_QWORD *)v24 = v10;
          *(_QWORD *)(v24 + 8) = 0;
          v10 += v8;
          *(_DWORD *)(v24 + 16) = 0;
        }
        while ( v25 );
      }
      return (_BYTE *)(&dword_0 + 1);
    }
  }
  return result;
}
// 26124: conditional instruction was optimized away because x12.8==0
// 0: using guessed type int dword_0;

//----- (00000000000261C4) ----------------------------------------------------
bool __fastcall FLAC__metadata_object_seektable_template_sort(__int64 a1, int a2)
{
  unsigned int v4; // w1

  v4 = FLAC__format_seektable_sort((void **)(a1 + 16));
  return !a2 || (unsigned int)FLAC__metadata_object_seektable_resize_points(a1, v4) != 0;
}

//----- (0000000000026214) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_vendor_string(
        __int64 a1,
        __int64 a2,
        unsigned __int8 *a3,
        int a4)
{
  _BYTE *result; // x0
  void *v9; // x20
  _BYTE *v10; // x23
  __int64 v11; // x9
  int v12; // w11
  __int64 v13; // x10
  __int64 v14; // x12
  __int64 v15; // x12
  int32x4_t v16; // q0
  int32x4_t v17; // q2
  const float *v18; // x11
  int32x4_t v19; // q1
  __int64 v20; // x13
  const float *v21; // x14
  unsigned __int128 v22; // q3
  unsigned __int128 v23; // q16
  __int64 v24; // x9
  int *v25; // x10
  int v26; // t1

  result = (_BYTE *)FLAC__format_vorbiscomment_entry_value_is_legal(a3, a2);
  if ( (_DWORD)result )
  {
    v9 = *(void **)(a1 + 24);
    if ( a3 )
    {
      if ( a4 )
      {
        *(_DWORD *)(a1 + 16) = a2;
        result = malloc((unsigned int)a2 + 1LL);
        v10 = result;
        if ( !result )
          return result;
        memcpy(result, a3, (unsigned int)a2);
        v10[(unsigned int)a2] = 0;
        *(_QWORD *)(a1 + 24) = v10;
      }
      else
      {
        result = realloc(a3, (unsigned int)a2 + 1LL);
        if ( !result )
          return result;
        result[(unsigned int)a2] = 0;
        *(_QWORD *)(a1 + 16) = a2;
        *(_QWORD *)(a1 + 24) = result;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 16) = a2;
      *(_QWORD *)(a1 + 24) = 0;
    }
    free(v9);
    v11 = *(unsigned int *)(a1 + 32);
    v12 = *(_DWORD *)(a1 + 16) + 8;
    *(_DWORD *)(a1 + 8) = v12;
    if ( (_DWORD)v11 )
    {
      v13 = *(_QWORD *)(a1 + 40);
      if ( (unsigned int)v11 >= 9 )
      {
        v15 = v11 & 7;
        if ( (v11 & 7) == 0 )
          v15 = 8;
        v17 = vdupq_n_s32(0);
        v14 = v11 - v15;
        v16 = vdupq_n_s32(4u);
        v17.n128_u32[0] = v12;
        v18 = (const float *)(v13 + 64);
        v19 = 0u;
        v20 = v14;
        do
        {
          v21 = v18 - 16;
          v22 = (unsigned __int128)vld4q_f32(v18);
          v23 = (unsigned __int128)vld4q_f32(v21);
          v20 -= 8;
          v19 = vaddq_s32(vaddq_s32(v19, v16), (int32x4_t)v22);
          v17 = vaddq_s32(vaddq_s32(v17, v16), (int32x4_t)v23);
          v18 += 32;
        }
        while ( v20 );
        v12 = vaddvq_s32(vaddq_s32(v19, v17));
      }
      else
      {
        v14 = 0;
      }
      v24 = v11 - v14;
      v25 = (int *)(v13 + 16 * v14);
      do
      {
        v26 = *v25;
        v25 += 4;
        --v24;
        v12 += 4 + v26;
      }
      while ( v24 );
      *(_DWORD *)(a1 + 8) = v12;
    }
    return (_BYTE *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000026390) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_vorbiscomment_resize_comments(__int64 a1, unsigned int a2)
{
  __int64 v3; // x8
  char *result; // x0
  char *v6; // x21
  __int64 v7; // x24
  __int64 v8; // x22
  unsigned __int64 v9; // x23
  unsigned int v10; // w9
  void *v11; // x0
  unsigned __int64 v12; // x23
  void **v13; // x22
  __int64 v14; // x20
  void **v15; // x21
  void *v16; // t1
  int v17; // w9
  int v18; // w10
  __int64 v19; // x11
  __int64 v20; // x11
  int32x4_t v21; // q0
  int32x4_t v22; // q2
  const float *v23; // x10
  int32x4_t v24; // q1
  __int64 v25; // x12
  const float *v26; // x13
  unsigned __int128 v27; // q3
  unsigned __int128 v28; // q16
  __int64 v29; // x9
  char *v30; // x11
  int v31; // t1

  v3 = *(_QWORD *)(a1 + 40);
  if ( !v3 )
  {
    if ( !a2 )
      return (_BYTE *)(&dword_0 + 1);
    result = (char *)calloc(a2, 0x10u);
    v6 = result;
    *(_QWORD *)(a1 + 40) = result;
    if ( !result )
      return result;
LABEL_22:
    v17 = *(_DWORD *)(a1 + 16) + 4;
    *(_DWORD *)(a1 + 32) = a2;
    v18 = v17 + 4;
    *(_DWORD *)(a1 + 8) = v17 + 4;
    if ( a2 )
    {
      if ( a2 >= 9 )
      {
        v20 = a2 & 7;
        if ( (a2 & 7) == 0 )
          v20 = 8;
        v22 = vdupq_n_s32(0);
        v19 = a2 - v20;
        v21 = vdupq_n_s32(4u);
        v22.n128_u32[0] = v17 + 4;
        v23 = (const float *)(v6 + 64);
        v24 = 0u;
        v25 = v19;
        do
        {
          v26 = v23 - 16;
          v27 = (unsigned __int128)vld4q_f32(v23);
          v28 = (unsigned __int128)vld4q_f32(v26);
          v25 -= 8;
          v24 = vaddq_s32(vaddq_s32(v24, v21), (int32x4_t)v27);
          v22 = vaddq_s32(vaddq_s32(v22, v21), (int32x4_t)v28);
          v23 += 32;
        }
        while ( v25 );
        v18 = vaddvq_s32(vaddq_s32(v24, v22));
      }
      else
      {
        v19 = 0;
      }
      v29 = a2 - v19;
      v30 = &v6[16 * v19];
      do
      {
        v31 = *(_DWORD *)v30;
        v30 += 16;
        --v29;
        v18 += 4 + v31;
      }
      while ( v29 );
      *(_DWORD *)(a1 + 8) = v18;
    }
    return (_BYTE *)(&dword_0 + 1);
  }
  if ( a2 >> 28 )
    return 0;
  v7 = *(unsigned int *)(a1 + 32);
  if ( (unsigned int)v7 > a2 )
  {
    v8 = (16LL * a2) | 8;
    v9 = a2 + 1LL;
    v10 = *(_DWORD *)(a1 + 32);
    v11 = *(void **)(v3 + v8);
    if ( v11 )
      goto LABEL_11;
    while ( v9 < v10 )
    {
      v8 += 16;
      ++v9;
      v11 = *(void **)(*(_QWORD *)(a1 + 40) + v8);
      if ( v11 )
      {
LABEL_11:
        free(v11);
        v10 = *(_DWORD *)(a1 + 32);
      }
    }
  }
  v12 = 16LL * a2;
  if ( !a2 )
  {
    free(*(void **)(a1 + 40));
    v6 = 0;
    *(_QWORD *)(a1 + 40) = 0;
LABEL_20:
    if ( v12 > 16 * v7 )
      memset(&v6[16 * *(unsigned int *)(a1 + 32)], 0, v12 - 16 * v7);
    goto LABEL_22;
  }
  v13 = *(void ***)(a1 + 40);
  v6 = (char *)realloc(v13, 16LL * a2);
  *(_QWORD *)(a1 + 40) = v6;
  if ( v6 )
    goto LABEL_20;
  v14 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v14 )
  {
    v15 = v13 + 1;
    do
    {
      v16 = *v15;
      v15 += 2;
      free(v16);
      --v14;
    }
    while ( v14 );
  }
  free(v13);
  result = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000026594) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_set_comment(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned __int8 *a4,
        int a5)
{
  _BYTE *result; // x0
  __int64 v11; // x25
  void *v12; // x20
  _QWORD *v13; // x24
  _BYTE *v14; // x23
  __int64 v15; // x9
  int v16; // w11
  __int64 v17; // x10
  __int64 v18; // x12
  __int64 v19; // x12
  int32x4_t v20; // q0
  int32x4_t v21; // q2
  const float *v22; // x11
  int32x4_t v23; // q1
  __int64 v24; // x13
  const float *v25; // x14
  unsigned __int128 v26; // q3
  unsigned __int128 v27; // q16
  __int64 v28; // x9
  int *v29; // x10
  int v30; // t1

  result = (_BYTE *)FLAC__format_vorbiscomment_entry_is_legal(a4, a3);
  if ( (_DWORD)result )
  {
    v11 = *(_QWORD *)(a1 + 40) + 16LL * a2;
    v13 = (_QWORD *)(v11 + 8);
    v12 = *(void **)(v11 + 8);
    if ( a4 )
    {
      if ( a5 )
      {
        *(_DWORD *)v11 = a3;
        result = malloc((unsigned int)a3 + 1LL);
        v14 = result;
        if ( !result )
          return result;
        memcpy(result, a4, (unsigned int)a3);
        v14[(unsigned int)a3] = 0;
        *v13 = v14;
      }
      else
      {
        result = realloc(a4, (unsigned int)a3 + 1LL);
        if ( !result )
          return result;
        result[(unsigned int)a3] = 0;
        *(_QWORD *)v11 = a3;
        *v13 = result;
      }
    }
    else
    {
      *(_QWORD *)v11 = a3;
      *v13 = 0;
    }
    free(v12);
    v15 = *(unsigned int *)(a1 + 32);
    v16 = *(_DWORD *)(a1 + 16) + 8;
    *(_DWORD *)(a1 + 8) = v16;
    if ( (_DWORD)v15 )
    {
      v17 = *(_QWORD *)(a1 + 40);
      if ( (unsigned int)v15 >= 9 )
      {
        v19 = v15 & 7;
        if ( (v15 & 7) == 0 )
          v19 = 8;
        v21 = vdupq_n_s32(0);
        v18 = v15 - v19;
        v20 = vdupq_n_s32(4u);
        v21.n128_u32[0] = v16;
        v22 = (const float *)(v17 + 64);
        v23 = 0u;
        v24 = v18;
        do
        {
          v25 = v22 - 16;
          v26 = (unsigned __int128)vld4q_f32(v22);
          v27 = (unsigned __int128)vld4q_f32(v25);
          v24 -= 8;
          v23 = vaddq_s32(vaddq_s32(v23, v20), (int32x4_t)v26);
          v21 = vaddq_s32(vaddq_s32(v21, v20), (int32x4_t)v27);
          v22 += 32;
        }
        while ( v24 );
        v16 = vaddvq_s32(vaddq_s32(v23, v21));
      }
      else
      {
        v18 = 0;
      }
      v28 = v15 - v18;
      v29 = (int *)(v17 + 16 * v18);
      do
      {
        v30 = *v29;
        v29 += 4;
        --v28;
        v16 += 4 + v30;
      }
      while ( v28 );
      *(_DWORD *)(a1 + 8) = v16;
    }
    return (_BYTE *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000026734) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_insert_comment(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned __int8 *a4,
        int a5)
{
  __int64 v10; // x24
  __int64 v11; // x8

  if ( !(unsigned int)FLAC__format_vorbiscomment_entry_is_legal(a4, a3)
    || !(unsigned int)FLAC__metadata_object_vorbiscomment_resize_comments(a1, *(_DWORD *)(a1 + 32) + 1) )
  {
    return 0;
  }
  v10 = 16LL * a2;
  memmove(
    (void *)(*(_QWORD *)(a1 + 40) + 16LL * (a2 + 1)),
    (const void *)(*(_QWORD *)(a1 + 40) + v10),
    16LL * (*(_DWORD *)(a1 + 32) + ~a2));
  v11 = *(_QWORD *)(a1 + 40) + v10;
  *(_DWORD *)v11 = 0;
  *(_QWORD *)(v11 + 8) = 0;
  return FLAC__metadata_object_vorbiscomment_set_comment(a1, a2, a3, a4, a5);
}

//----- (00000000000267FC) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_append_comment(
        __int64 a1,
        __int64 a2,
        unsigned __int8 *a3,
        int a4)
{
  __int64 v5; // x22
  __int64 v9; // x8

  v5 = *(unsigned int *)(a1 + 32);
  if ( !(unsigned int)FLAC__format_vorbiscomment_entry_is_legal(a3, a2)
    || !(unsigned int)FLAC__metadata_object_vorbiscomment_resize_comments(a1, *(_DWORD *)(a1 + 32) + 1) )
  {
    return 0;
  }
  memmove(
    (void *)(*(_QWORD *)(a1 + 40) + 16LL * (unsigned int)(v5 + 1)),
    (const void *)(*(_QWORD *)(a1 + 40) + 16 * v5),
    16LL * (unsigned int)(*(_DWORD *)(a1 + 32) + ~(_DWORD)v5));
  v9 = *(_QWORD *)(a1 + 40) + 16 * v5;
  *(_DWORD *)v9 = 0;
  *(_QWORD *)(v9 + 8) = 0;
  return FLAC__metadata_object_vorbiscomment_set_comment(a1, v5, a2, a3, a4);
}

//----- (00000000000268BC) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_replace_comment(
        __int64 a1,
        __int64 a2,
        unsigned __int8 *a3,
        int a4,
        int a5)
{
  _BYTE *result; // x0
  unsigned __int64 v11; // x24
  int v12; // w28
  __int64 v13; // x21
  unsigned __int64 v14; // x26
  __int64 v15; // x19
  size_t v16; // x20
  const void *v17; // x27
  void *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x23
  __int64 v21; // x27
  unsigned __int64 v22; // x25
  const char *v23; // x24
  const void **v24; // x21
  const char *v25; // x22
  void *v26; // x0
  unsigned __int64 v27; // x23
  __int64 v28; // x19
  unsigned int v29; // w1
  __int64 v30; // x8
  unsigned __int64 v31; // x21
  const void **i; // x19
  const char *v33; // x22
  void *v34; // x0
  int v35; // [xsp+4h] [xbp-5Ch]
  __int64 v36; // [xsp+8h] [xbp-58h]

  result = (_BYTE *)FLAC__format_vorbiscomment_entry_is_legal(a3, a2);
  if ( (_DWORD)result )
  {
    result = memchr(a3, 61, (unsigned int)a2);
    if ( result )
    {
      v11 = *(unsigned int *)(a1 + 32);
      v35 = a5;
      v36 = a1;
      if ( !(_DWORD)v11 )
        goto LABEL_9;
      v12 = (_DWORD)result - (_DWORD)a3;
      v13 = 0;
      v14 = 0;
      v15 = *(_QWORD *)(a1 + 40);
      v16 = (unsigned int)((_DWORD)result - (_DWORD)a3);
      while ( 1 )
      {
        v17 = *(const void **)(v15 + v13 + 8);
        v18 = memchr(v17, 61, *(unsigned int *)(v15 + v13));
        if ( v18 )
        {
          if ( (_DWORD)v18 - (_DWORD)v17 == v12 && !strncasecmp((const char *)a3, (const char *)v17, v16) )
            break;
        }
        ++v14;
        v13 += 16;
        if ( v14 >= v11 )
          goto LABEL_9;
      }
      if ( (v14 & 0x80000000) != 0 )
      {
LABEL_9:
        result = (_BYTE *)FLAC__format_vorbiscomment_entry_is_legal(a3, a2);
        if ( (_DWORD)result )
        {
          result = FLAC__metadata_object_vorbiscomment_resize_comments(v36, *(_DWORD *)(v36 + 32) + 1);
          if ( (_DWORD)result )
          {
            memmove(
              (void *)(*(_QWORD *)(v36 + 40) + 16LL * (unsigned int)(v11 + 1)),
              (const void *)(*(_QWORD *)(v36 + 40) + 16 * v11),
              16LL * (unsigned int)(*(_DWORD *)(v36 + 32) + ~(_DWORD)v11));
            v19 = *(_QWORD *)(v36 + 40) + 16 * v11;
            *(_DWORD *)v19 = 0;
            *(_QWORD *)(v19 + 8) = 0;
            return FLAC__metadata_object_vorbiscomment_set_comment(v36, v11, a2, a3, v35);
          }
        }
      }
      else
      {
        result = FLAC__metadata_object_vorbiscomment_set_comment(v36, v14, a2, a3, v35);
        if ( (_DWORD)result )
        {
          if ( !a4 )
            return (_BYTE *)(&dword_0 + 1);
          v20 = *(unsigned int *)(v36 + 32);
          if ( (int)v14 + 1 >= (unsigned int)v20 )
            return (_BYTE *)(&dword_0 + 1);
          v21 = *(_QWORD *)(v36 + 40);
          v22 = v14 + 1;
          v23 = *(const char **)(v21 + v13 + 8);
          v24 = (const void **)(v21 + v13 + 24);
          do
          {
            v25 = (const char *)*v24;
            v26 = memchr(*v24, 61, *((unsigned int *)v24 - 2));
            if ( v26 )
            {
              if ( (_DWORD)v26 - (_DWORD)v25 == v12 && !strncasecmp(v23, v25, v16) )
                break;
            }
            ++v22;
            v24 += 2;
            result = (_BYTE *)(&dword_0 + 1);
          }
          while ( v22 < v20 );
          if ( (v22 & 0x80000000) == 0 )
          {
            while ( 1 )
            {
              v27 = (unsigned int)v22;
              v28 = 16LL * (unsigned int)v22;
              free(*(void **)(v21 + v28 + 8));
              memmove(
                (void *)(*(_QWORD *)(v36 + 40) + v28),
                (const void *)(*(_QWORD *)(v36 + 40) + 16LL * (unsigned int)(v22 + 1)),
                16LL * (unsigned int)(*(_DWORD *)(v36 + 32) + ~(_DWORD)v22));
              v29 = *(_DWORD *)(v36 + 32) - 1;
              v30 = *(_QWORD *)(v36 + 40) + 16LL * v29;
              *(_DWORD *)v30 = 0;
              *(_QWORD *)(v30 + 8) = 0;
              result = FLAC__metadata_object_vorbiscomment_resize_comments(v36, v29);
              if ( !(_DWORD)result )
                break;
              v31 = *(unsigned int *)(v36 + 32);
              if ( (unsigned int)v22 >= (unsigned int)v31 )
                return (_BYTE *)(&dword_0 + 1);
              for ( i = (const void **)(*(_QWORD *)(v36 + 40) + 16LL * (unsigned int)v22 + 8); ; i += 2 )
              {
                v33 = (const char *)*i;
                v34 = memchr(*i, 61, *((unsigned int *)i - 2));
                if ( v34 )
                {
                  if ( (_DWORD)v34 - (_DWORD)v33 == v12 && !strncasecmp(v23, v33, v16) )
                    break;
                }
                ++v27;
                result = (_BYTE *)(&dword_0 + 1);
                if ( v27 >= v31 )
                  return result;
              }
              if ( (v27 & 0x80000000) != 0 )
                return (_BYTE *)(&dword_0 + 1);
              LODWORD(v22) = v27;
              v21 = *(_QWORD *)(v36 + 40);
            }
          }
          else
          {
            return (_BYTE *)(&dword_0 + 1);
          }
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000026BBC) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_vorbiscomment_delete_comment(__int64 a1, unsigned int a2)
{
  __int64 v4; // x21
  unsigned int v5; // w1
  __int64 v6; // x8

  v4 = 16LL * a2;
  free(*(void **)(*(_QWORD *)(a1 + 40) + v4 + 8));
  memmove(
    (void *)(*(_QWORD *)(a1 + 40) + v4),
    (const void *)(*(_QWORD *)(a1 + 40) + 16LL * (a2 + 1)),
    16LL * (*(_DWORD *)(a1 + 32) + ~a2));
  v5 = *(_DWORD *)(a1 + 32) - 1;
  v6 = *(_QWORD *)(a1 + 40) + 16LL * v5;
  *(_DWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = 0;
  return FLAC__metadata_object_vorbiscomment_resize_comments(a1, v5);
}

//----- (0000000000026C3C) ----------------------------------------------------
_BYTE *__fastcall FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(
        __int64 a1,
        char *a2,
        unsigned __int8 *a3)
{
  _BYTE *result; // x0
  size_t v7; // x23
  size_t v8; // x22
  unsigned __int64 v9; // x25
  _BYTE *v10; // x24

  result = (_BYTE *)FLAC__format_vorbiscomment_entry_name_is_legal(a2);
  if ( (_DWORD)result )
  {
    result = (_BYTE *)FLAC__format_vorbiscomment_entry_value_is_legal(a3, -1);
    if ( (_DWORD)result )
    {
      v7 = strlen(a2);
      v8 = strlen((const char *)a3);
      v9 = v7 + 1 + v8;
      *(_DWORD *)a1 = v9;
      if ( v7 == -1 || v9 < v7 + 1 || v9 == -1 )
      {
        result = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
      else
      {
        result = malloc(v9 + 1);
        v10 = result;
        *(_QWORD *)(a1 + 8) = result;
        if ( result )
        {
          memcpy(result, a2, v7);
          v10[v7] = 61;
          memcpy(&v10[v7 + 1], a3, v8);
          result = (_BYTE *)(&dword_0 + 1);
          v10[(unsigned int)v9] = 0;
        }
      }
    }
  }
  return result;
}
// 26CC0: conditional instruction was optimized away because x25.8!=FFFFFFFFFFFFFFFF
// 0: using guessed type int dword_0;

//----- (0000000000026D28) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(
        unsigned int a1,
        unsigned __int8 *a2,
        __int64 *a3,
        void **a4)
{
  __int64 result; // x0
  __int64 v9; // x23
  size_t v10; // x22
  size_t v11; // x23
  void *v12; // x8
  void *v13; // x0
  size_t v14; // x23

  result = FLAC__format_vorbiscomment_entry_is_legal(a2, a1);
  if ( (_DWORD)result )
  {
    v9 = a1;
    result = (__int64)memchr(a2, 61, a1);
    if ( result )
    {
      v10 = result - (_QWORD)a2;
      if ( result - (_QWORD)a2 == -1 )
      {
        result = 0;
        *a3 = 0;
      }
      else
      {
        result = (__int64)malloc(v10 + 1);
        *a3 = result;
        if ( !result )
          return result;
        v11 = v9 - v10;
        if ( v11 )
        {
          v12 = malloc(v11);
          *a4 = v12;
          v13 = (void *)*a3;
          if ( v12 )
          {
            v14 = v11 - 1;
            memcpy(v13, a2, v10);
            memcpy(*a4, &a2[v10 + 1], v14);
            result = 1;
            *(_BYTE *)(*a3 + v10) = 0;
            *((_BYTE *)*a4 + v14) = 0;
            return result;
          }
        }
        else
        {
          *a4 = 0;
          v13 = (void *)*a3;
        }
        free(v13);
        return 0;
      }
    }
  }
  return result;
}

//----- (0000000000026E24) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_vorbiscomment_entry_matches(
        unsigned int a1,
        const void *a2,
        const char *a3,
        unsigned int a4)
{
  void *result; // x0

  result = memchr(a2, 61, a1);
  if ( result )
  {
    if ( (_DWORD)result - (_DWORD)a2 == a4 )
      return (void *)(strncasecmp(a3, (const char *)a2, a4) == 0);
    else
      return 0;
  }
  return result;
}

//----- (0000000000026E9C) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_vorbiscomment_find_entry_from(__int64 a1, unsigned int a2, const char *a3)
{
  unsigned int v6; // w0
  unsigned __int64 v7; // x24
  unsigned int v8; // w21
  __int64 v9; // x8
  unsigned __int64 v10; // x20
  const void **v11; // x25
  const char *v12; // x23
  void *v13; // x0

  v6 = strlen(a3);
  v7 = *(unsigned int *)(a1 + 32);
  v8 = v6;
  if ( (unsigned int)v7 <= a2 )
  {
LABEL_7:
    LODWORD(v10) = -1;
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 40);
    v10 = a2;
    v11 = (const void **)(v9 + 16LL * a2 + 8);
    while ( 1 )
    {
      v12 = (const char *)*v11;
      v13 = memchr(*v11, 61, *((unsigned int *)v11 - 2));
      if ( v13 )
      {
        if ( (_DWORD)v13 - (_DWORD)v12 == v8 && !strncasecmp(a3, v12, v8) )
          break;
      }
      ++v10;
      v11 += 2;
      if ( v10 >= v7 )
        goto LABEL_7;
    }
  }
  return (unsigned int)v10;
}

//----- (0000000000026F54) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_vorbiscomment_remove_entry_matching(__int64 a1, const char *a2)
{
  unsigned int v4; // w0
  unsigned __int64 v5; // x26
  unsigned int v6; // w21
  __int64 v7; // x27
  __int64 v8; // x25
  unsigned __int64 v9; // x24
  void *v10; // x23
  void *v11; // x0
  unsigned int v13; // w1
  __int64 v14; // x8

  v4 = strlen(a2);
  v5 = *(unsigned int *)(a1 + 32);
  v6 = v4;
  if ( !(_DWORD)v5 )
    return 0;
  v7 = *(_QWORD *)(a1 + 40);
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = *(void **)(v7 + v8 + 8);
    v11 = memchr(v10, 61, *(unsigned int *)(v7 + v8));
    if ( v11 )
    {
      if ( (_DWORD)v11 - (_DWORD)v10 == v6 && !strncasecmp(a2, (const char *)v10, v6) )
        break;
    }
    ++v9;
    v8 += 16;
    if ( v9 >= v5 )
      return 0;
  }
  free(v10);
  memmove(
    (void *)(*(_QWORD *)(a1 + 40) + v8),
    (const void *)(*(_QWORD *)(a1 + 40) + v8 + 16),
    16LL * (unsigned int)(*(_DWORD *)(a1 + 32) - 1 - v9));
  v13 = *(_DWORD *)(a1 + 32) - 1;
  v14 = *(_QWORD *)(a1 + 40) + 16LL * v13;
  *(_DWORD *)v14 = 0;
  *(_QWORD *)(v14 + 8) = 0;
  if ( (unsigned int)FLAC__metadata_object_vorbiscomment_resize_comments(a1, v13) )
    return 1;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000027060) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_vorbiscomment_remove_entries_matching(__int64 a1, const char *a2)
{
  unsigned int v4; // w0
  __int64 v5; // x24
  unsigned int v6; // w21
  int v7; // w26
  __int64 v8; // x27
  int v9; // w28
  __int64 v10; // x22
  const void *v11; // x23
  void *v12; // x0
  __int64 v13; // x23
  unsigned int v14; // w1
  __int64 v15; // x8
  bool v16; // cc
  unsigned int v18; // [xsp+4h] [xbp-5Ch]
  size_t n; // [xsp+8h] [xbp-58h]

  v4 = strlen(a2);
  v5 = *(unsigned int *)(a1 + 32);
  v6 = v4;
  if ( (int)v5 < 1 )
    return 0;
  n = v4;
  v7 = -(int)v5;
  v8 = 16LL * (int)v5;
  v9 = 1;
  v18 = 0;
  do
  {
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(const void **)(v10 + v8 - 8);
    v12 = memchr(v11, 61, *(unsigned int *)(v10 + v8 - 16));
    if ( v12 && (_DWORD)v12 - (_DWORD)v11 == v6 && !strncasecmp(a2, (const char *)v11, n) )
    {
      v13 = 16LL * (unsigned int)(v5 - 1);
      ++v18;
      free(*(void **)(v10 + v13 + 8));
      memmove(
        (void *)(*(_QWORD *)(a1 + 40) + v13),
        (const void *)(*(_QWORD *)(a1 + 40) + 16LL * (unsigned int)v5),
        16LL * (unsigned int)(v7 + *(_DWORD *)(a1 + 32)));
      v14 = *(_DWORD *)(a1 + 32) - 1;
      v15 = *(_QWORD *)(a1 + 40) + 16LL * v14;
      *(_DWORD *)v15 = 0;
      *(_QWORD *)(v15 + 8) = 0;
      v9 &= (unsigned int)FLAC__metadata_object_vorbiscomment_resize_comments(a1, v14);
    }
    if ( !v9 )
      break;
    ++v7;
    v16 = v5 <= 1;
    v8 -= 16;
    --v5;
  }
  while ( !v16 );
  if ( v9 )
    return v18;
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000271AC) ----------------------------------------------------
void *FLAC__metadata_object_cuesheet_track_new()
{
  return calloc(1u, 0x20u);
}

//----- (00000000000271B8) ----------------------------------------------------
_QWORD *__fastcall FLAC__metadata_object_cuesheet_track_clone(__int64 a1)
{
  _OWORD *v2; // x0
  _QWORD *v3; // x19
  void *v4; // x0
  void *v5; // x21
  void *v6; // x0

  v2 = calloc(1u, 0x20u);
  v3 = v2;
  if ( v2 )
  {
    v2[1] = *(_OWORD *)(a1 + 16);
    *v2 = *(_OWORD *)a1;
    if ( *(_QWORD *)(a1 + 24) )
    {
      v4 = safe_malloc_mul_2op_p(*(unsigned __int8 *)(a1 + 23), 0x10u);
      v5 = v4;
      if ( v4 )
      {
        memcpy(v4, *(const void **)(a1 + 24), 16LL * *(unsigned __int8 *)(a1 + 23));
        v3[3] = v5;
      }
      else
      {
        v6 = (void *)v3[3];
        if ( v6 )
          free(v6);
        free(v3);
        return 0;
      }
    }
  }
  return v3;
}

//----- (0000000000027254) ----------------------------------------------------
void __fastcall FLAC__metadata_object_cuesheet_track_delete(_QWORD *a1)
{
  void *v2; // x0

  v2 = (void *)a1[3];
  if ( v2 )
    free(v2);
  free(a1);
}

//----- (0000000000027280) ----------------------------------------------------
void __fastcall FLAC__metadata_object_cuesheet_track_delete_data(__int64 a1)
{
  void *v1; // x0

  v1 = *(void **)(a1 + 24);
  if ( v1 )
    free(v1);
}

//----- (0000000000027290) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_cuesheet_track_resize_indices(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v4; // x21
  __int64 v5; // x25
  char v6; // w20
  __int64 v7; // x23
  void *v8; // x22
  _QWORD *v9; // x24
  _BYTE *v10; // x23
  __int64 v11; // x25
  unsigned int v12; // t1
  void *result; // x0
  unsigned __int64 v14; // x21
  char *v15; // x0
  size_t v16; // x2
  __int64 v17; // x10
  int v18; // w8
  __int64 v19; // x11
  __int64 v20; // x12
  int v21; // w13
  unsigned __int8 *v22; // x14
  __int64 v23; // x15
  int v24; // w16
  int v25; // t1
  __int64 v26; // x10
  unsigned __int8 *v27; // x11
  int v28; // t1

  v4 = *(_QWORD *)(a1 + 168);
  v5 = a2;
  v6 = a3;
  v7 = v4 + 32LL * a2;
  v9 = (_QWORD *)(v7 + 24);
  v8 = *(void **)(v7 + 24);
  if ( v8 )
  {
    v12 = *(unsigned __int8 *)(v7 + 23);
    v10 = (_BYTE *)(v7 + 23);
    v11 = v12;
    if ( a3 >> 28 )
      return 0;
    v14 = 16LL * a3;
    if ( a3 )
    {
      v15 = (char *)realloc(v8, 16LL * a3);
      if ( !v15 )
      {
        free(v8);
        result = 0;
        *v9 = 0;
        return result;
      }
      *v9 = v15;
      v16 = v14 - 16 * v11;
      if ( v14 <= 16 * v11 )
        goto LABEL_13;
    }
    else
    {
      free(v8);
      v15 = 0;
      *v9 = 0;
      v16 = v14 - 16 * v11;
      if ( v14 <= 16 * v11 )
        goto LABEL_13;
    }
    memset(&v15[16 * (unsigned __int8)*v10], 0, v16);
    goto LABEL_13;
  }
  if ( !a3 )
    return &dword_0 + 1;
  result = calloc(a3, 0x10u);
  *v9 = result;
  if ( !result )
    return result;
  v10 = (_BYTE *)(v4 + 32 * v5 + 23);
LABEL_13:
  *v10 = v6;
  v17 = *(unsigned int *)(a1 + 164);
  v18 = ((36 * v17) & 0x1FFFFFFF) + 396;
  *(_DWORD *)(a1 + 8) = v18;
  if ( (_DWORD)v17 )
  {
    v19 = *(_QWORD *)(a1 + 168);
    if ( (_DWORD)v17 == 1 )
    {
      v20 = 0;
    }
    else
    {
      v20 = (unsigned int)v17 & 0xFFFFFFFE;
      v21 = 0;
      v22 = (unsigned __int8 *)(v19 + 55);
      v23 = v20;
      do
      {
        v24 = *(v22 - 32);
        v25 = *v22;
        v22 += 64;
        v23 -= 2;
        v18 += (12 * v24) & 0x1FFFFFFF;
        v21 += (12 * v25) & 0x1FFFFFFF;
      }
      while ( v23 );
      v18 += v21;
      if ( v20 == v17 )
        goto LABEL_21;
    }
    v26 = v17 - v20;
    v27 = (unsigned __int8 *)(v19 + 32 * v20 + 23);
    do
    {
      v28 = *v27;
      v27 += 32;
      --v26;
      v18 += (12 * v28) & 0x1FFFFFFF;
    }
    while ( v26 );
LABEL_21:
    *(_DWORD *)(a1 + 8) = v18;
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000027500) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_index(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5)
{
  __int64 v8; // x23
  void *result; // x0
  unsigned int v11; // w9
  int v12; // w12
  __int64 v13; // x22
  _QWORD *v14; // x8
  __int64 v15; // x10
  int v16; // w8
  __int64 v17; // x11
  __int64 v18; // x12
  int v19; // w13
  unsigned __int8 *v20; // x14
  __int64 v21; // x15
  int v22; // w16
  int v23; // t1
  __int64 v24; // x10
  unsigned __int8 *v25; // x11
  int v26; // t1

  v8 = *(_QWORD *)(a1 + 168) + 32LL * a2;
  result = FLAC__metadata_object_cuesheet_track_resize_indices(a1, a2, (unsigned int)*(unsigned __int8 *)(v8 + 23) + 1);
  if ( (_DWORD)result )
  {
    v11 = a3 + 1;
    v12 = ~a3;
    v13 = 16LL * a3;
    memmove(
      (void *)(*(_QWORD *)(v8 + 24) + 16LL * v11),
      (const void *)(*(_QWORD *)(v8 + 24) + v13),
      16LL * (v12 + (unsigned int)*(unsigned __int8 *)(v8 + 23)));
    v14 = (_QWORD *)(*(_QWORD *)(v8 + 24) + v13);
    *v14 = a4;
    v14[1] = a5;
    v15 = *(unsigned int *)(a1 + 164);
    v16 = ((36 * v15) & 0x1FFFFFFF) + 396;
    *(_DWORD *)(a1 + 8) = v16;
    if ( !(_DWORD)v15 )
      return &dword_0 + 1;
    v17 = *(_QWORD *)(a1 + 168);
    if ( (_DWORD)v15 == 1 )
    {
      v18 = 0;
    }
    else
    {
      v18 = (unsigned int)v15 & 0xFFFFFFFE;
      v19 = 0;
      v20 = (unsigned __int8 *)(v17 + 55);
      v21 = v18;
      do
      {
        v22 = *(v20 - 32);
        v23 = *v20;
        v20 += 64;
        v21 -= 2;
        v16 += (12 * v22) & 0x1FFFFFFF;
        v19 += (12 * v23) & 0x1FFFFFFF;
      }
      while ( v21 );
      v16 += v19;
      if ( v18 == v15 )
        goto LABEL_10;
    }
    v24 = v15 - v18;
    v25 = (unsigned __int8 *)(v17 + 32 * v18 + 23);
    do
    {
      v26 = *v25;
      v25 += 32;
      --v24;
      v16 += (12 * v26) & 0x1FFFFFFF;
    }
    while ( v24 );
LABEL_10:
    *(_DWORD *)(a1 + 8) = v16;
    return &dword_0 + 1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000027704) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_cuesheet_track_insert_blank_index(__int64 a1, unsigned int a2, unsigned int a3)
{
  return FLAC__metadata_object_cuesheet_track_insert_index(a1, a2, a3, 0, 0);
}

//----- (0000000000027710) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_cuesheet_track_delete_index(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v5; // x21
  __int64 v6; // x10
  int v7; // w8
  __int64 v8; // x11
  __int64 v9; // x12
  int v10; // w13
  unsigned __int8 *v11; // x14
  __int64 v12; // x15
  int v13; // w16
  int v14; // t1
  __int64 v15; // x10
  unsigned __int8 *v16; // x11
  int v17; // t1

  v5 = *(_QWORD *)(a1 + 168) + 32LL * a2;
  memmove(
    (void *)(*(_QWORD *)(v5 + 24) + 16LL * a3),
    (const void *)(*(_QWORD *)(v5 + 24) + 16LL * (a3 + 1)),
    16LL * (~a3 + *(unsigned __int8 *)(v5 + 23)));
  FLAC__metadata_object_cuesheet_track_resize_indices(a1, a2, *(unsigned __int8 *)(v5 + 23) - 1);
  v6 = *(unsigned int *)(a1 + 164);
  v7 = ((36 * v6) & 0x1FFFFFFF) + 396;
  *(_DWORD *)(a1 + 8) = v7;
  if ( (_DWORD)v6 )
  {
    v8 = *(_QWORD *)(a1 + 168);
    if ( (_DWORD)v6 == 1 )
    {
      v9 = 0;
    }
    else
    {
      v9 = (unsigned int)v6 & 0xFFFFFFFE;
      v10 = 0;
      v11 = (unsigned __int8 *)(v8 + 55);
      v12 = v9;
      do
      {
        v13 = *(v11 - 32);
        v14 = *v11;
        v11 += 64;
        v12 -= 2;
        v7 += (12 * v13) & 0x1FFFFFFF;
        v10 += (12 * v14) & 0x1FFFFFFF;
      }
      while ( v12 );
      v7 += v10;
      if ( v9 == v6 )
        goto LABEL_9;
    }
    v15 = v6 - v9;
    v16 = (unsigned __int8 *)(v8 + 32 * v9 + 23);
    do
    {
      v17 = *v16;
      v16 += 32;
      --v15;
      v7 += (12 * v17) & 0x1FFFFFFF;
    }
    while ( v15 );
LABEL_9:
    *(_DWORD *)(a1 + 8) = v7;
  }
  return 1;
}

//----- (00000000000278F0) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_cuesheet_resize_tracks(__int64 a1, unsigned int a2)
{
  void **v3; // x23
  char *result; // x0
  char *v6; // x21
  __int64 v7; // x24
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x21
  unsigned __int64 v10; // x23
  char *v11; // x0
  size_t v12; // x2
  int v13; // w8
  __int64 v14; // x11
  int v15; // w12
  unsigned __int8 *v16; // x13
  __int64 v17; // x14
  int v18; // w15
  int v19; // t1
  __int64 v20; // x10
  char *v21; // x11
  int v22; // t1

  v3 = *(void ***)(a1 + 168);
  if ( v3 )
  {
    if ( a2 >> 27 )
      return 0;
    v7 = *(unsigned int *)(a1 + 164);
    v8 = 32LL * a2;
    if ( (unsigned int)v7 > a2 )
    {
      free(v3[4 * a2 + 3]);
      v9 = a2 + 1LL;
      if ( v9 < *(unsigned int *)(a1 + 164) )
      {
        v10 = v8 + 56;
        do
        {
          free(*(void **)(*(_QWORD *)(a1 + 168) + v10));
          ++v9;
          v10 += 32LL;
        }
        while ( v9 < *(unsigned int *)(a1 + 164) );
      }
      v3 = *(void ***)(a1 + 168);
    }
    if ( !a2 )
    {
      free(v3);
      v6 = 0;
      *(_QWORD *)(a1 + 168) = 0;
      v12 = v8 - 32 * v7;
      if ( v8 <= 32 * v7 )
        goto LABEL_18;
      goto LABEL_17;
    }
    v11 = (char *)realloc(v3, 32LL * a2);
    v6 = v11;
    if ( v11 )
    {
      *(_QWORD *)(a1 + 168) = v11;
      v12 = v8 - 32 * v7;
      if ( v8 <= 32 * v7 )
        goto LABEL_18;
LABEL_17:
      memset(&v6[32 * *(unsigned int *)(a1 + 164)], 0, v12);
      goto LABEL_18;
    }
    free(v3);
    result = 0;
    *(_QWORD *)(a1 + 168) = 0;
  }
  else
  {
    if ( !a2 )
      return (_BYTE *)(&dword_0 + 1);
    result = (char *)calloc(a2, 0x20u);
    v6 = result;
    *(_QWORD *)(a1 + 168) = result;
    if ( result )
    {
LABEL_18:
      *(_DWORD *)(a1 + 164) = a2;
      v13 = ((36 * a2) & 0x1FFFFFFF) + 396;
      *(_DWORD *)(a1 + 8) = v13;
      if ( a2 )
      {
        if ( a2 == 1 )
        {
          v14 = 0;
        }
        else
        {
          v14 = a2 & 0xFFFFFFFE;
          v15 = 0;
          v16 = (unsigned __int8 *)(v6 + 55);
          v17 = v14;
          do
          {
            v18 = *(v16 - 32);
            v19 = *v16;
            v16 += 64;
            v17 -= 2;
            v13 += (12 * v18) & 0x1FFFFFFF;
            v15 += (12 * v19) & 0x1FFFFFFF;
          }
          while ( v17 );
          v13 += v15;
          if ( v14 == a2 )
            goto LABEL_26;
        }
        v20 = a2 - v14;
        v21 = &v6[32 * v14 + 23];
        do
        {
          v22 = (unsigned __int8)*v21;
          v21 += 32;
          --v20;
          v13 += (12 * v22) & 0x1FFFFFFF;
        }
        while ( v20 );
LABEL_26:
        *(_DWORD *)(a1 + 8) = v13;
      }
      return (_BYTE *)(&dword_0 + 1);
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000027B90) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_cuesheet_set_track(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  __int64 v6; // x8
  void *v7; // x20
  _QWORD *v8; // x23
  void *result; // x0
  void *v10; // x22
  __int64 v11; // x10
  int v12; // w8
  __int64 v13; // x11
  __int64 v14; // x12
  int v15; // w13
  unsigned __int8 *v16; // x14
  __int64 v17; // x15
  int v18; // w16
  int v19; // t1
  __int64 v20; // x10
  unsigned __int8 *v21; // x11
  int v22; // t1

  v6 = *(_QWORD *)(a1 + 168) + 32LL * a2;
  v8 = (_QWORD *)(v6 + 24);
  v7 = *(void **)(v6 + 24);
  *(_OWORD *)v6 = *(_OWORD *)a3;
  *(_OWORD *)(v6 + 16) = *(_OWORD *)(a3 + 16);
  if ( a4 && *(_QWORD *)(a3 + 24) )
  {
    result = safe_malloc_mul_2op_p(*(unsigned __int8 *)(a3 + 23), 0x10u);
    v10 = result;
    if ( !result )
      return result;
    memcpy(result, *(const void **)(a3 + 24), 16LL * *(unsigned __int8 *)(a3 + 23));
    *v8 = v10;
  }
  free(v7);
  v11 = *(unsigned int *)(a1 + 164);
  v12 = ((36 * v11) & 0x1FFFFFFF) + 396;
  *(_DWORD *)(a1 + 8) = v12;
  if ( (_DWORD)v11 )
  {
    v13 = *(_QWORD *)(a1 + 168);
    if ( (_DWORD)v11 == 1 )
    {
      v14 = 0;
    }
    else
    {
      v14 = (unsigned int)v11 & 0xFFFFFFFE;
      v15 = 0;
      v16 = (unsigned __int8 *)(v13 + 55);
      v17 = v14;
      do
      {
        v18 = *(v16 - 32);
        v19 = *v16;
        v16 += 64;
        v17 -= 2;
        v12 += (12 * v18) & 0x1FFFFFFF;
        v15 += (12 * v19) & 0x1FFFFFFF;
      }
      while ( v17 );
      v12 += v15;
      if ( v14 == v11 )
        goto LABEL_13;
    }
    v20 = v11 - v14;
    v21 = (unsigned __int8 *)(v13 + 32 * v14 + 23);
    do
    {
      v22 = *v21;
      v21 += 32;
      --v20;
      v12 += (12 * v22) & 0x1FFFFFFF;
    }
    while ( v20 );
LABEL_13:
    *(_DWORD *)(a1 + 8) = v12;
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000027D98) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_cuesheet_insert_track(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  char *result; // x0
  __int64 v9; // x23
  __int64 v10; // x8

  result = FLAC__metadata_object_cuesheet_resize_tracks(a1, *(_DWORD *)(a1 + 164) + 1);
  if ( (_DWORD)result )
  {
    v9 = 32LL * a2;
    memmove(
      (void *)(*(_QWORD *)(a1 + 168) + 32LL * (a2 + 1)),
      (const void *)(*(_QWORD *)(a1 + 168) + v9),
      32LL * (*(_DWORD *)(a1 + 164) + ~a2));
    v10 = *(_QWORD *)(a1 + 168) + v9;
    *(_BYTE *)(v10 + 23) = 0;
    *(_QWORD *)(v10 + 24) = 0;
    return (char *)FLAC__metadata_object_cuesheet_set_track(a1, a2, a3, a4);
  }
  return result;
}

//----- (0000000000027E40) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_cuesheet_insert_blank_track(__int64 a1, unsigned int a2)
{
  char *result; // x0
  __int64 v5; // x9
  int v6; // w12
  __int64 v7; // x20
  __int64 v8; // x8
  __int64 v9; // x8
  void *v10; // x0
  __int64 v11; // x10
  int v12; // w8
  __int64 v13; // x11
  __int64 v14; // x12
  int v15; // w13
  unsigned __int8 *v16; // x14
  __int64 v17; // x15
  int v18; // w16
  int v19; // t1
  __int64 v20; // x10
  unsigned __int8 *v21; // x11
  int v22; // t1

  _ReadStatusReg(TPIDR_EL0);
  result = FLAC__metadata_object_cuesheet_resize_tracks(a1, *(_DWORD *)(a1 + 164) + 1);
  if ( (_DWORD)result )
  {
    v5 = a2 + 1;
    v6 = ~a2;
    v7 = 32LL * a2;
    memmove(
      (void *)(*(_QWORD *)(a1 + 168) + 32 * v5),
      (const void *)(*(_QWORD *)(a1 + 168) + v7),
      32LL * (unsigned int)(*(_DWORD *)(a1 + 164) + v6));
    v8 = *(_QWORD *)(a1 + 168) + v7;
    *(_BYTE *)(v8 + 23) = 0;
    *(_QWORD *)(v8 + 24) = 0;
    v9 = *(_QWORD *)(a1 + 168) + v7;
    *(_OWORD *)v9 = 0u;
    v10 = *(void **)(v9 + 24);
    *(_OWORD *)(v9 + 16) = 0u;
    free(v10);
    v11 = *(unsigned int *)(a1 + 164);
    v12 = ((36 * v11) & 0x1FFFFFFF) + 396;
    *(_DWORD *)(a1 + 8) = v12;
    if ( !(_DWORD)v11 )
      return (_BYTE *)(&dword_0 + 1);
    v13 = *(_QWORD *)(a1 + 168);
    if ( (_DWORD)v11 == 1 )
    {
      v14 = 0;
    }
    else
    {
      v14 = (unsigned int)v11 & 0xFFFFFFFE;
      v15 = 0;
      v16 = (unsigned __int8 *)(v13 + 55);
      v17 = v14;
      do
      {
        v18 = *(v16 - 32);
        v19 = *v16;
        v16 += 64;
        v17 -= 2;
        v12 += (12 * v18) & 0x1FFFFFFF;
        v15 += (12 * v19) & 0x1FFFFFFF;
      }
      while ( v17 );
      v12 += v15;
      if ( v14 == v11 )
        goto LABEL_10;
    }
    v20 = v11 - v14;
    v21 = (unsigned __int8 *)(v13 + 32 * v14 + 23);
    do
    {
      v22 = *v21;
      v21 += 32;
      --v20;
      v12 += (12 * v22) & 0x1FFFFFFF;
    }
    while ( v20 );
LABEL_10:
    *(_DWORD *)(a1 + 8) = v12;
    return (_BYTE *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000002807C) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_cuesheet_delete_track(__int64 a1, unsigned int a2)
{
  __int64 v4; // x21
  __int64 v5; // x1
  __int64 v6; // x8

  v4 = 32LL * a2;
  free(*(void **)(*(_QWORD *)(a1 + 168) + v4 + 24));
  memmove(
    (void *)(*(_QWORD *)(a1 + 168) + v4),
    (const void *)(*(_QWORD *)(a1 + 168) + 32LL * (a2 + 1)),
    32LL * (*(_DWORD *)(a1 + 164) + ~a2));
  v5 = (unsigned int)(*(_DWORD *)(a1 + 164) - 1);
  v6 = *(_QWORD *)(a1 + 168) + 32 * v5;
  *(_BYTE *)(v6 + 23) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  return FLAC__metadata_object_cuesheet_resize_tracks(a1, v5);
}

//----- (00000000000280FC) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_cuesheet_is_legal(__int64 a1, int a2, const char **a3)
{
  return FLAC__format_cuesheet_is_legal(a1 + 16, a2, a3);
}

//----- (0000000000028104) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_cuesheet_calculate_cddb_id(__int64 a1)
{
  unsigned int v1; // w9
  unsigned __int64 v3; // x11
  unsigned int v4; // w10
  unsigned __int64 v5; // x8
  __int64 v6; // x15
  __int64 *v7; // x16
  __int64 v8; // x16
  unsigned __int64 v9; // x16
  int v10; // w15
  bool v11; // cc
  __int64 v12; // x13
  __int64 v13; // x12
  unsigned int v14; // w10
  bool v15; // zf
  unsigned __int64 v16; // x9
  __int64 *v17; // x14
  __int64 v18; // x14
  unsigned __int64 v19; // x12

  v1 = *(_DWORD *)(a1 + 164);
  if ( v1 < 2 )
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = v1 - 1;
  do
  {
    while ( v3 < v5 )
    {
      v6 = *(_QWORD *)(a1 + 168) + 32 * v3;
      if ( !*(_BYTE *)(v6 + 23) )
        break;
      v7 = *(__int64 **)(v6 + 24);
      if ( *((_BYTE *)v7 + 8) == 1 )
      {
        v8 = *v7;
        goto LABEL_8;
      }
      if ( *(unsigned __int8 *)(v6 + 23) < 2u || *((_BYTE *)v7 + 24) != 1 )
        break;
      v8 = v7[2];
LABEL_8:
      v9 = (*(_QWORD *)v6 + v8 + *(_QWORD *)(a1 + 152)) / 0xAC44uLL;
      if ( (_DWORD)v9 )
        goto LABEL_15;
LABEL_9:
      if ( ++v3 == v5 )
        goto LABEL_18;
    }
    v9 = (unsigned __int64)((0 * (unsigned __int128)0x17C6F8C751F176DDuLL) >> 64) >> 12;
    if ( !(_DWORD)v9 )
      goto LABEL_9;
LABEL_15:
    v10 = 0;
    do
    {
      v11 = (unsigned int)v9 > 9;
      v10 += (unsigned int)v9 % 0xA;
      LODWORD(v9) = (unsigned int)v9 / 0xA;
    }
    while ( v11 );
    ++v3;
    v4 += v10;
  }
  while ( v3 != v5 );
LABEL_18:
  v12 = *(_QWORD *)(a1 + 168);
  v13 = *(_QWORD *)(a1 + 152);
  v14 = (v4 % 0xFF) << 24;
  v15 = v1 == 1;
  v16 = (v13 + *(_QWORD *)(v12 + 32 * v5)) / 0xAC44uLL;
  if ( v15 || !*(_BYTE *)(v12 + 23) )
    goto LABEL_26;
  v17 = *(__int64 **)(v12 + 24);
  if ( *((_BYTE *)v17 + 8) == 1 )
  {
    v18 = *v17;
    goto LABEL_25;
  }
  if ( *(unsigned __int8 *)(v12 + 23) >= 2u && *((_BYTE *)v17 + 24) == 1 )
  {
    v18 = v17[2];
LABEL_25:
    v19 = *(_QWORD *)v12 + v18 + v13;
  }
  else
  {
LABEL_26:
    v19 = 0;
  }
  return v14 | (unsigned int)v5 | (((_DWORD)v16 - (unsigned int)(v19 / 0xAC44)) << 8);
}

//----- (00000000000282B4) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_picture_set_mime_type(__int64 a1, const char *a2, int a3)
{
  void *v4; // x20
  __int64 v7; // x25
  size_t v8; // x22
  const char *v9; // x23
  unsigned int v10; // w8
  size_t v11; // x24
  char *result; // x0

  v4 = *(void **)(a1 + 24);
  if ( v4 )
  {
    v7 = -(__int64)strlen(*(const char **)(a1 + 24));
    v8 = strlen(a2);
    if ( a3 )
      goto LABEL_3;
LABEL_9:
    v9 = a2;
LABEL_10:
    *(_QWORD *)(a1 + 24) = v9;
    free(v4);
    result = (_BYTE *)(&dword_0 + 1);
    *(_DWORD *)(a1 + 8) += v8 + v7;
    return result;
  }
  LODWORD(v7) = 0;
  v8 = strlen(a2);
  if ( !a3 )
    goto LABEL_9;
LABEL_3:
  if ( v8 != -1 )
  {
    v9 = 0;
    if ( a2 )
    {
      v10 = v8 + 1;
      if ( (_DWORD)v8 != -1 )
      {
        v11 = v10;
        result = (char *)malloc(v10);
        v9 = result;
        if ( !result )
          return result;
        memcpy(result, a2, v11);
      }
    }
    goto LABEL_10;
  }
  return 0;
}
// 0: using guessed type int dword_0;

//----- (0000000000028394) ----------------------------------------------------
char *__fastcall FLAC__metadata_object_picture_set_description(__int64 a1, const char *a2, int a3)
{
  void *v4; // x20
  __int64 v7; // x25
  size_t v8; // x22
  const char *v9; // x23
  unsigned int v10; // w8
  size_t v11; // x24
  char *result; // x0

  v4 = *(void **)(a1 + 32);
  if ( v4 )
  {
    v7 = -(__int64)strlen(*(const char **)(a1 + 32));
    v8 = strlen(a2);
    if ( a3 )
      goto LABEL_3;
LABEL_9:
    v9 = a2;
LABEL_10:
    *(_QWORD *)(a1 + 32) = v9;
    free(v4);
    result = (_BYTE *)(&dword_0 + 1);
    *(_DWORD *)(a1 + 8) += v8 + v7;
    return result;
  }
  LODWORD(v7) = 0;
  v8 = strlen(a2);
  if ( !a3 )
    goto LABEL_9;
LABEL_3:
  if ( v8 != -1 )
  {
    v9 = 0;
    if ( a2 )
    {
      v10 = v8 + 1;
      if ( (_DWORD)v8 != -1 )
      {
        v11 = v10;
        result = (char *)malloc(v10);
        v9 = result;
        if ( !result )
          return result;
        memcpy(result, a2, v11);
      }
    }
    goto LABEL_10;
  }
  return 0;
}
// 0: using guessed type int dword_0;

//----- (0000000000028474) ----------------------------------------------------
void *__fastcall FLAC__metadata_object_picture_set_data(__int64 a1, const void *a2, unsigned int a3, int a4)
{
  void *v5; // x21
  void *v8; // x22
  void *result; // x0
  int v10; // w8
  int v11; // w9

  v5 = *(void **)(a1 + 64);
  if ( a4 )
  {
    v8 = 0;
    if ( a2 && a3 )
    {
      result = malloc(a3);
      v8 = result;
      if ( !result )
        return result;
      memcpy(result, a2, a3);
    }
  }
  else
  {
    v8 = (void *)a2;
  }
  *(_QWORD *)(a1 + 64) = v8;
  free(v5);
  v10 = *(_DWORD *)(a1 + 56);
  v11 = *(_DWORD *)(a1 + 8);
  result = &dword_0 + 1;
  *(_DWORD *)(a1 + 56) = a3;
  *(_DWORD *)(a1 + 8) = v11 - v10 + a3;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000028510) ----------------------------------------------------
__int64 __fastcall FLAC__metadata_object_picture_is_legal(__int64 a1, _QWORD *a2)
{
  return FLAC__format_picture_is_legal(a1 + 16, a2);
}

//----- (0000000000028518) ----------------------------------------------------
_QWORD *FLAC__stream_decoder_new()
{
  _QWORD *v0; // x19
  _DWORD *v1; // x20
  _DWORD *v2; // x21
  void **v3; // x22
  void *v4; // x0

  v0 = calloc(1u, 0x10u);
  if ( v0 )
  {
    v1 = calloc(1u, 0x20u);
    *v0 = v1;
    if ( v1 )
    {
      v2 = calloc(1u, 0x1AD8u);
      v0[1] = v2;
      if ( v2 )
      {
        v3 = (void **)FLAC__bitreader_new();
        *((_QWORD *)v2 + 14) = v3;
        if ( v3 )
        {
          *((_QWORD *)v2 + 169) = 16;
          v4 = malloc(0x40u);
          *((_QWORD *)v2 + 167) = v4;
          if ( v4 )
          {
            *((_QWORD *)v2 + 55) = 0;
            v2[117] = 0;
            memset(v2 + 30, 0, 0x80u);
            *((_QWORD *)v2 + 512) = 0;
            *((_QWORD *)v2 + 511) = 0;
            *((_QWORD *)v2 + 510) = 0;
            *((_QWORD *)v2 + 509) = 0;
            *((_QWORD *)v2 + 508) = 0;
            *((_QWORD *)v2 + 507) = 0;
            *(_OWORD *)(v2 + 1010) = 0u;
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 62));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 68));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 74));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 80));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 86));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 92));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 98));
            FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 104));
            *v2 = 0;
            memset(v2 + 206, 0, 0x200u);
            v2[206] = 1;
            *((_QWORD *)v2 + 7) = 0;
            *((_QWORD *)v2 + 8) = 0;
            *((_QWORD *)v2 + 5) = 0;
            *((_QWORD *)v2 + 6) = 0;
            *((_QWORD *)v2 + 3) = 0;
            *((_QWORD *)v2 + 4) = 0;
            *((_QWORD *)v2 + 1) = 0;
            *((_QWORD *)v2 + 2) = 0;
            *((_QWORD *)v2 + 12) = 0;
            *((_QWORD *)v2 + 13) = 0;
            *((_QWORD *)v2 + 168) = 0;
            v1[7] = 0;
            *v1 = 9;
            return v0;
          }
          FLAC__bitreader_delete(v3);
        }
        free(v2);
      }
      free(v1);
    }
    free(v0);
    return 0;
  }
  return v0;
}

//----- (00000000000286A8) ----------------------------------------------------
void __fastcall FLAC__stream_decoder_delete(void **a1)
{
  void *v2; // x8
  void *v3; // x0

  if ( a1 )
  {
    FLAC__stream_decoder_finish((__int64)a1);
    v2 = a1[1];
    v3 = (void *)*((_QWORD *)v2 + 167);
    if ( v3 )
    {
      free(v3);
      v2 = a1[1];
    }
    FLAC__bitreader_delete(*((void ***)v2 + 14));
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 248);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 272);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 296);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 320);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 344);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 368);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 392);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear((__int64)a1[1] + 416);
    free(a1[1]);
    free(*a1);
    free(a1);
  }
}

//----- (000000000002876C) ----------------------------------------------------
bool __fastcall FLAC__stream_decoder_finish(__int64 a1)
{
  _BOOL4 v2; // w20
  __int64 *v3; // x20
  __int64 v4; // x0
  __int64 v5; // x21
  __int64 v6; // x8
  void *v7; // x0
  __int64 v8; // x8
  void *v9; // x0
  __int64 v10; // x8
  void *v11; // x0
  __int64 v12; // x8
  void *v13; // x0
  __int64 v14; // x8
  void *v15; // x0
  __int64 v16; // x8
  void *v17; // x0
  __int64 v18; // x8
  void *v19; // x0
  __int64 v20; // x8
  void *v21; // x0
  FILE *v22; // x0
  _QWORD *v23; // x8
  __int64 v24; // x8
  _DWORD *v25; // x8

  if ( **(_DWORD **)a1 == 9 )
  {
    return 1;
  }
  else
  {
    v3 = (__int64 *)(a1 + 8);
    FLAC__MD5Final((_OWORD *)(*(_QWORD *)(a1 + 8) + 4224LL), *(_QWORD *)(a1 + 8) + 4120LL);
    free(*(void **)(*v3 + 672));
    *(_QWORD *)(*v3 + 672) = 0;
    v4 = *(_QWORD *)(*v3 + 112);
    *(_DWORD *)(*v3 + 468) = 0;
    FLAC__bitreader_free(v4);
    v5 = *v3;
    v6 = *(_QWORD *)(*v3 + 120);
    if ( v6 )
    {
      free((void *)(v6 - 16));
      *(_QWORD *)(*v3 + 120) = 0;
      v5 = *v3;
    }
    v7 = *(void **)(v5 + 4040);
    if ( v7 )
    {
      free(v7);
      *(_QWORD *)(*v3 + 184) = 0;
      *(_QWORD *)(*v3 + 4040) = 0;
      v5 = *v3;
    }
    v8 = *(_QWORD *)(v5 + 128);
    if ( v8 )
    {
      free((void *)(v8 - 16));
      *(_QWORD *)(*v3 + 128) = 0;
      v5 = *v3;
    }
    v9 = *(void **)(v5 + 4048);
    if ( v9 )
    {
      free(v9);
      *(_QWORD *)(*v3 + 192) = 0;
      *(_QWORD *)(*v3 + 4048) = 0;
      v5 = *v3;
    }
    v10 = *(_QWORD *)(v5 + 136);
    if ( v10 )
    {
      free((void *)(v10 - 16));
      *(_QWORD *)(*v3 + 136) = 0;
      v5 = *v3;
    }
    v11 = *(void **)(v5 + 4056);
    if ( v11 )
    {
      free(v11);
      *(_QWORD *)(*v3 + 200) = 0;
      *(_QWORD *)(*v3 + 4056) = 0;
      v5 = *v3;
    }
    v12 = *(_QWORD *)(v5 + 144);
    if ( v12 )
    {
      free((void *)(v12 - 16));
      *(_QWORD *)(*v3 + 144) = 0;
      v5 = *v3;
    }
    v13 = *(void **)(v5 + 4064);
    if ( v13 )
    {
      free(v13);
      *(_QWORD *)(*v3 + 208) = 0;
      *(_QWORD *)(*v3 + 4064) = 0;
      v5 = *v3;
    }
    v14 = *(_QWORD *)(v5 + 152);
    if ( v14 )
    {
      free((void *)(v14 - 16));
      *(_QWORD *)(*v3 + 152) = 0;
      v5 = *v3;
    }
    v15 = *(void **)(v5 + 4072);
    if ( v15 )
    {
      free(v15);
      *(_QWORD *)(*v3 + 216) = 0;
      *(_QWORD *)(*v3 + 4072) = 0;
      v5 = *v3;
    }
    v16 = *(_QWORD *)(v5 + 160);
    if ( v16 )
    {
      free((void *)(v16 - 16));
      *(_QWORD *)(*v3 + 160) = 0;
      v5 = *v3;
    }
    v17 = *(void **)(v5 + 4080);
    if ( v17 )
    {
      free(v17);
      *(_QWORD *)(*v3 + 224) = 0;
      *(_QWORD *)(*v3 + 4080) = 0;
      v5 = *v3;
    }
    v18 = *(_QWORD *)(v5 + 168);
    if ( v18 )
    {
      free((void *)(v18 - 16));
      *(_QWORD *)(*v3 + 168) = 0;
      v5 = *v3;
    }
    v19 = *(void **)(v5 + 4088);
    if ( v19 )
    {
      free(v19);
      *(_QWORD *)(*v3 + 232) = 0;
      *(_QWORD *)(*v3 + 4088) = 0;
      v5 = *v3;
    }
    v20 = *(_QWORD *)(v5 + 176);
    if ( v20 )
    {
      free((void *)(v20 - 16));
      *(_QWORD *)(*v3 + 176) = 0;
      v5 = *v3;
    }
    v21 = *(void **)(v5 + 4096);
    if ( v21 )
    {
      free(v21);
      *(_QWORD *)(*v3 + 240) = 0;
      *(_QWORD *)(*v3 + 4096) = 0;
      v5 = *v3;
    }
    v23 = (_QWORD *)(v5 + 104);
    v22 = *(FILE **)(v5 + 104);
    *(_QWORD *)(v5 + 440) = 0;
    if ( v22 )
    {
      if ( v22 != (FILE *)&_sF )
      {
        fclose(v22);
        v5 = *v3;
        v23 = (_QWORD *)(*v3 + 104);
      }
      *v23 = 0;
    }
    if ( *(_DWORD *)(v5 + 4104) )
      v2 = memcmp((const void *)(v5 + 528), (const void *)(v5 + 4224), 0x10u) == 0;
    else
      v2 = 1;
    *(_DWORD *)(v5 + 4112) = 0;
    *(_DWORD *)v5 = 0;
    *(_QWORD *)(v5 + 96) = 0;
    memset((void *)(v5 + 824), 0, 0x200u);
    *(_QWORD *)(v5 + 56) = 0;
    *(_QWORD *)(v5 + 64) = 0;
    *(_QWORD *)(v5 + 40) = 0;
    *(_QWORD *)(v5 + 48) = 0;
    *(_QWORD *)(v5 + 24) = 0;
    *(_QWORD *)(v5 + 32) = 0;
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
    v24 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(v24 + 824) = 1;
    *(_QWORD *)(v24 + 1344) = 0;
    v25 = *(_DWORD **)a1;
    v25[7] = 0;
    *v25 = 9;
  }
  return v2;
}

//----- (0000000000028A78) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_stream(
        int **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  return sub_28AA0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0);
}

//----- (0000000000028AA0) ----------------------------------------------------
__int64 __fastcall sub_28AA0(
        int **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        int a11)
{
  __int64 result; // x0
  int *v20; // x8
  __int64 v21; // x0
  __int128 v22; // q0
  int *v23; // x8

  if ( **a1 != 9 )
    return 5;
  if ( a11 )
    return 1;
  result = 2;
  if ( a2 )
  {
    if ( a7 )
    {
      if ( a9 )
      {
        if ( !a3 || (result = 2, a4) && a5 && a6 )
        {
          FLAC__cpu_info((__int64)(a1[1] + 993));
          v20 = a1[1];
          v21 = *((_QWORD *)v20 + 14);
          *((_QWORD *)v20 + 11) = FLAC__lpc_restore_signal;
          *(_QWORD *)&v22 = FLAC__lpc_restore_signal;
          *((_QWORD *)&v22 + 1) = FLAC__lpc_restore_signal_wide;
          *(_OWORD *)(v20 + 18) = v22;
          if ( (unsigned int)FLAC__bitreader_init(v21, (__int64)sub_2CD20, (__int64)a1) )
          {
            v23 = a1[1];
            *((_QWORD *)v23 + 1) = a2;
            *((_QWORD *)v23 + 2) = a3;
            *((_QWORD *)v23 + 3) = a4;
            *((_QWORD *)v23 + 4) = a5;
            *((_QWORD *)v23 + 5) = a6;
            *((_QWORD *)v23 + 6) = a7;
            *((_QWORD *)v23 + 7) = a8;
            *((_QWORD *)v23 + 8) = a9;
            *((_QWORD *)v23 + 12) = a10;
            v23[992] = 0;
            v23[116] = 0;
            *((_QWORD *)v23 + 56) = 0;
            *((_QWORD *)v23 + 57) = 0;
            v23[1026] = (*a1)[7];
            *(_QWORD *)(v23 + 1027) = 1;
            if ( (unsigned int)FLAC__stream_decoder_reset(a1) )
              return 0;
            else
              return 3;
          }
          else
          {
            result = 3;
            **a1 = 8;
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000028BFC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_ogg_stream(_DWORD **a1)
{
  if ( **a1 == 9 )
    return 1;
  else
    return 5;
}

//----- (0000000000028C14) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_FILE(int **a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int *v7; // x8
  int *v13; // x8
  int *v14; // x8
  __int64 v15; // x0
  __int128 v16; // q0
  int *v17; // x12
  __int64 (__fastcall *v18)(__int64, _QWORD *); // x9
  __int64 (__fastcall *v19)(__int64, __off_t *); // x10
  __int64 (__fastcall *v20)(__int64, __off_t); // x11
  __int64 result; // x0

  v7 = *a1;
  if ( **a1 == 9 )
  {
    if ( a3 && a5 )
    {
      v13 = a1[1];
      *((_QWORD *)v13 + 13) = a2;
      FLAC__cpu_info((__int64)(v13 + 993));
      v14 = a1[1];
      v15 = *((_QWORD *)v14 + 14);
      *((_QWORD *)v14 + 11) = FLAC__lpc_restore_signal;
      *(_QWORD *)&v16 = FLAC__lpc_restore_signal;
      *((_QWORD *)&v16 + 1) = FLAC__lpc_restore_signal_wide;
      *(_OWORD *)(v14 + 18) = v16;
      if ( (unsigned int)FLAC__bitreader_init(v15, (__int64)sub_2CD20, (__int64)a1) )
      {
        v17 = a1[1];
        v18 = sub_2CF70;
        v19 = sub_2CF08;
        v20 = sub_2CECC;
        if ( a2 == &_sF )
        {
          v18 = 0;
          v19 = 0;
          v20 = 0;
        }
        *((_QWORD *)v17 + 1) = sub_2CE3C;
        *((_QWORD *)v17 + 2) = v20;
        *((_QWORD *)v17 + 3) = v19;
        *((_QWORD *)v17 + 4) = v18;
        *((_QWORD *)v17 + 5) = sub_2D010;
        *((_QWORD *)v17 + 6) = a3;
        *((_QWORD *)v17 + 7) = a4;
        *((_QWORD *)v17 + 8) = a5;
        *((_QWORD *)v17 + 12) = a6;
        v17[992] = 0;
        v17[116] = 0;
        *((_QWORD *)v17 + 56) = 0;
        *((_QWORD *)v17 + 57) = 0;
        v17[1026] = (*a1)[7];
        *(_QWORD *)(v17 + 1027) = 1;
        if ( (unsigned int)FLAC__stream_decoder_reset(a1) )
          return 0;
        else
          return 3;
      }
      else
      {
        result = 3;
        **a1 = 8;
      }
    }
    else
    {
      result = 2;
      v7[1] = 2;
    }
  }
  else
  {
    result = 5;
    v7[1] = 5;
  }
  return result;
}

//----- (0000000000028D78) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_ogg_FILE(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _DWORD *v5; // x8
  __int64 v6; // x8
  __int64 result; // x0

  v5 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 == 9 )
  {
    if ( a3 && a5 )
    {
      v6 = a1[1];
      result = 1;
      *(_QWORD *)(v6 + 104) = a2;
    }
    else
    {
      result = 2;
      v5[1] = 2;
    }
  }
  else
  {
    result = 5;
    v5[1] = 5;
  }
  return result;
}

//----- (0000000000028DB8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_file(
        int **a1,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int *v7; // x8
  FILE *v12; // x24
  __int64 result; // x0
  int *v14; // x8
  int *v15; // x8
  __int64 v16; // x0
  __int128 v17; // q0
  int *v18; // x11
  __int64 (__fastcall *v19)(__int64, _QWORD *); // x8
  __int64 (__fastcall *v20)(__int64, __off_t *); // x9
  __int64 (__fastcall *v21)(__int64, __off_t); // x10

  v7 = *a1;
  if ( **a1 != 9 )
    goto LABEL_7;
  if ( !a3 || !a5 )
  {
    result = 2;
    v7[1] = 2;
    return result;
  }
  if ( a2 )
  {
    v12 = fopen(a2, "rb");
    if ( !v12 )
      return 4;
    v7 = *a1;
    if ( **a1 != 9 )
    {
LABEL_7:
      result = 5;
      v7[1] = 5;
      return result;
    }
  }
  else
  {
    v12 = (FILE *)&_sF;
  }
  v14 = a1[1];
  *((_QWORD *)v14 + 13) = v12;
  FLAC__cpu_info((__int64)(v14 + 993));
  v15 = a1[1];
  v16 = *((_QWORD *)v15 + 14);
  *((_QWORD *)v15 + 11) = FLAC__lpc_restore_signal;
  *(_QWORD *)&v17 = FLAC__lpc_restore_signal;
  *((_QWORD *)&v17 + 1) = FLAC__lpc_restore_signal_wide;
  *(_OWORD *)(v15 + 18) = v17;
  if ( (unsigned int)FLAC__bitreader_init(v16, (__int64)sub_2CD20, (__int64)a1) )
  {
    v18 = a1[1];
    v19 = sub_2CF70;
    v20 = sub_2CF08;
    v21 = sub_2CECC;
    if ( v12 == (FILE *)&_sF )
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
    }
    *((_QWORD *)v18 + 1) = sub_2CE3C;
    *((_QWORD *)v18 + 2) = v21;
    *((_QWORD *)v18 + 3) = v20;
    *((_QWORD *)v18 + 4) = v19;
    *((_QWORD *)v18 + 5) = sub_2D010;
    *((_QWORD *)v18 + 6) = a3;
    *((_QWORD *)v18 + 7) = a4;
    *((_QWORD *)v18 + 8) = a5;
    *((_QWORD *)v18 + 12) = a6;
    v18[992] = 0;
    v18[116] = 0;
    *((_QWORD *)v18 + 56) = 0;
    *((_QWORD *)v18 + 57) = 0;
    v18[1026] = (*a1)[7];
    *(_QWORD *)(v18 + 1027) = 1;
    if ( (unsigned int)FLAC__stream_decoder_reset(a1) )
      return 0;
    else
      return 3;
  }
  else
  {
    result = 3;
    **a1 = 8;
  }
  return result;
}

//----- (0000000000028F5C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_init_ogg_file(_QWORD *a1, const char *a2, __int64 a3, __int64 a4, __int64 a5)
{
  _DWORD *v6; // x9
  __int64 result; // x0
  FILE *v8; // x8

  v6 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 9 )
    goto LABEL_7;
  result = 2;
  if ( !a3 || !a5 )
    goto LABEL_8;
  if ( !a2 )
  {
    v8 = (FILE *)&_sF;
LABEL_10:
    result = 1;
    *(_QWORD *)(a1[1] + 104LL) = v8;
    return result;
  }
  v8 = fopen(a2, "rb");
  if ( v8 )
  {
    v6 = (_DWORD *)*a1;
    if ( *(_DWORD *)*a1 != 9 )
    {
LABEL_7:
      result = 5;
LABEL_8:
      v6[1] = result;
      return result;
    }
    goto LABEL_10;
  }
  return 4;
}

//----- (0000000000028FFC) ----------------------------------------------------
__int64 FLAC__stream_decoder_set_ogg_serial_number()
{
  return 0;
}

//----- (0000000000029004) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_md5_checking(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 9 )
    return 0;
  result = 1;
  v2[7] = a2;
  return result;
}

//----- (0000000000029028) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond(__int64 a1, unsigned int a2)
{
  __int64 result; // x0
  __int64 v3; // x8

  if ( a2 > 0x7E )
    return 0;
  if ( **(_DWORD **)a1 != 9 )
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  result = 1;
  *(_DWORD *)(v3 + 4LL * a2 + 824) = 1;
  if ( a2 == 2 )
  {
    result = 1;
    *(_QWORD *)(v3 + 1344) = 0;
  }
  return result;
}

//----- (0000000000029074) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_application(__int64 a1, const void *a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  void *v6; // x21
  __int64 v7; // x22
  char *v8; // x0
  _QWORD *v9; // x8
  __int64 result; // x0
  _QWORD *v11; // x9

  if ( **(_DWORD **)a1 != 9 )
    return 0;
  v4 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v4 + 832) )
    return 1;
  v5 = *(_QWORD *)(v4 + 1344);
  v6 = *(void **)(v4 + 1336);
  if ( v5 != *(_QWORD *)(v4 + 1352) )
  {
    v8 = *(char **)(v4 + 1336);
LABEL_14:
    memcpy(&v8[4 * v5], a2, 4u);
    ++*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1344LL);
    return 1;
  }
  if ( v5 )
  {
    if ( v5 < 0 )
    {
      v9 = (_QWORD *)(v4 + 1336);
      goto LABEL_17;
    }
    v7 = 2 * v5;
    v8 = (char *)realloc(*(void **)(v4 + 1336), 2 * v5);
    if ( v7 && !v8 )
    {
      free(v6);
      v9 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 1336LL);
LABEL_17:
      *v9 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v8 = (char *)realloc(*(void **)(v4 + 1336), 0);
  }
  v11 = *(_QWORD **)(a1 + 8);
  v11[167] = v8;
  if ( v8 )
  {
    v5 = v11[168];
    v11[169] *= 2LL;
    goto LABEL_14;
  }
LABEL_18:
  result = 0;
  **(_DWORD **)a1 = 8;
  return result;
}

//----- (000000000002919C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_respond_all(__int64 a1)
{
  __int64 v1; // x8
  __int128 v2; // q0
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 9 )
    return 0;
  v1 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)&v2 = 0x100000001LL;
  *((_QWORD *)&v2 + 1) = 0x100000001LL;
  result = 1;
  *(_OWORD *)(v1 + 824) = v2;
  *(_OWORD *)(v1 + 840) = v2;
  *(_OWORD *)(v1 + 856) = v2;
  *(_OWORD *)(v1 + 872) = v2;
  *(_OWORD *)(v1 + 888) = v2;
  *(_OWORD *)(v1 + 904) = v2;
  *(_OWORD *)(v1 + 920) = v2;
  *(_OWORD *)(v1 + 936) = v2;
  *(_OWORD *)(v1 + 952) = v2;
  *(_OWORD *)(v1 + 968) = v2;
  *(_OWORD *)(v1 + 984) = v2;
  *(_OWORD *)(v1 + 1000) = v2;
  *(_OWORD *)(v1 + 1016) = v2;
  *(_OWORD *)(v1 + 1032) = v2;
  *(_OWORD *)(v1 + 1048) = v2;
  *(_OWORD *)(v1 + 1064) = v2;
  *(_OWORD *)(v1 + 1080) = v2;
  *(_OWORD *)(v1 + 1096) = v2;
  *(_OWORD *)(v1 + 1112) = v2;
  *(_OWORD *)(v1 + 1128) = v2;
  *(_OWORD *)(v1 + 1144) = v2;
  *(_OWORD *)(v1 + 1160) = v2;
  *(_OWORD *)(v1 + 1176) = v2;
  *(_OWORD *)(v1 + 1192) = v2;
  *(_OWORD *)(v1 + 1208) = v2;
  *(_OWORD *)(v1 + 1224) = v2;
  *(_OWORD *)(v1 + 1240) = v2;
  *(_OWORD *)(v1 + 1256) = v2;
  *(_OWORD *)(v1 + 1272) = v2;
  *(_OWORD *)(v1 + 1288) = v2;
  *(_OWORD *)(v1 + 1304) = v2;
  *(_OWORD *)(v1 + 1320) = v2;
  *(_QWORD *)(v1 + 1344) = 0;
  return result;
}

//----- (00000000000292C8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore(__int64 a1, unsigned int a2)
{
  __int64 v3; // x8

  if ( a2 > 0x7E )
    return 0;
  if ( **(_DWORD **)a1 != 9 )
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(v3 + 4LL * a2 + 824) = 0;
  if ( a2 == 2 )
    *(_QWORD *)(v3 + 1344) = 0;
  return 1;
}

//----- (0000000000029310) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_application(__int64 a1, const void *a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  void *v6; // x21
  __int64 v7; // x22
  char *v8; // x0
  _QWORD *v9; // x8
  __int64 result; // x0
  _QWORD *v11; // x9

  if ( **(_DWORD **)a1 != 9 )
    return 0;
  v4 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v4 + 832) )
    return 1;
  v5 = *(_QWORD *)(v4 + 1344);
  v6 = *(void **)(v4 + 1336);
  if ( v5 != *(_QWORD *)(v4 + 1352) )
  {
    v8 = *(char **)(v4 + 1336);
LABEL_14:
    memcpy(&v8[4 * v5], a2, 4u);
    ++*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1344LL);
    return 1;
  }
  if ( v5 )
  {
    if ( v5 < 0 )
    {
      v9 = (_QWORD *)(v4 + 1336);
      goto LABEL_17;
    }
    v7 = 2 * v5;
    v8 = (char *)realloc(*(void **)(v4 + 1336), 2 * v5);
    if ( v7 && !v8 )
    {
      free(v6);
      v9 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 1336LL);
LABEL_17:
      *v9 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v8 = (char *)realloc(*(void **)(v4 + 1336), 0);
  }
  v11 = *(_QWORD **)(a1 + 8);
  v11[167] = v8;
  if ( v8 )
  {
    v5 = v11[168];
    v11[169] *= 2LL;
    goto LABEL_14;
  }
LABEL_18:
  result = 0;
  **(_DWORD **)a1 = 8;
  return result;
}

//----- (0000000000029438) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_set_metadata_ignore_all(__int64 a1)
{
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 9 )
    return 0;
  memset((void *)(*(_QWORD *)(a1 + 8) + 824LL), 0, 0x200u);
  result = 1;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 1344LL) = 0;
  return result;
}

//----- (0000000000029494) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_state(unsigned int **a1)
{
  return **a1;
}

//----- (00000000000294A0) ----------------------------------------------------
char *__fastcall FLAC__stream_decoder_get_resolved_state_string(unsigned int **a1)
{
  return FLAC__StreamDecoderStateString[**a1];
}
// 7E210: using guessed type char *FLAC__StreamDecoderStateString[69];

//----- (00000000000294B8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_md5_checking(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 28LL);
}

//----- (00000000000294C4) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_total_samples(__int64 a1)
{
  __int64 v1; // x8

  v1 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v1 + 464) )
    return *(_QWORD *)(v1 + 520);
  else
    return 0;
}

//----- (00000000000294E0) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_channels(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 8LL);
}

//----- (00000000000294EC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_channel_assignment(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 12LL);
}

//----- (00000000000294F8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_bits_per_sample(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 16LL);
}

//----- (0000000000029504) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_sample_rate(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 20LL);
}

//----- (0000000000029510) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_blocksize(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 24LL);
}

//----- (000000000002951C) ----------------------------------------------------
bool __fastcall FLAC__stream_decoder_get_decode_position(__int64 a1, _QWORD *a2)
{
  __int64 v3; // x9
  unsigned int (__fastcall *v5)(__int64, _QWORD *, _QWORD); // x8
  _BOOL8 result; // x0
  __int64 v7; // x9

  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(unsigned int (__fastcall **)(__int64, _QWORD *, _QWORD))(v3 + 24);
  if ( !v5 )
    return 0;
  if ( v5(a1, a2, *(_QWORD *)(v3 + 96)) )
    return 0;
  result = FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL));
  if ( result )
  {
    v7 = (unsigned int)FLAC__bitreader_get_input_bits_unconsumed(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 112LL)) >> 3;
    result = 1;
    *a2 -= v7;
  }
  return result;
}

//----- (00000000000295AC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_get_input_bytes_unconsumed(__int64 a1)
{
  return (unsigned int)FLAC__bitreader_get_input_bits_unconsumed(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 112LL)) >> 3;
}

//----- (00000000000295CC) ----------------------------------------------------
bool __fastcall FLAC__stream_decoder_flush(__int64 a1)
{
  __int64 v2; // x8
  _BOOL8 result; // x0
  __int64 v4; // x0
  int v5; // w0
  bool v6; // zf
  int v7; // w9

  v2 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v2 + 4108) && **(_DWORD **)a1 == 9 )
    return 0;
  v4 = *(_QWORD *)(v2 + 112);
  *(_QWORD *)(v2 + 456) = 0;
  *(_DWORD *)(v2 + 4104) = 0;
  v5 = FLAC__bitreader_clear(v4);
  v6 = v5 == 0;
  result = v5 != 0;
  if ( v6 )
    v7 = 8;
  else
    v7 = 2;
  **(_DWORD **)a1 = v7;
  return result;
}

//----- (0000000000029640) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_reset(int **a1)
{
  int *v2; // x8
  __int64 result; // x0
  __int64 v4; // x0
  int *v5; // x8
  int v6; // w9
  int *v7; // x9
  void *v8; // x0
  int *v9; // x8
  int v10; // w9
  int *v11; // x8
  unsigned int (__fastcall *v12)(int **, _QWORD, _QWORD); // x10

  v2 = a1[1];
  if ( !v2[1027] && **a1 == 9 )
    return 0;
  v4 = *((_QWORD *)v2 + 14);
  *((_QWORD *)v2 + 57) = 0;
  v2[1026] = 0;
  result = FLAC__bitreader_clear(v4);
  v5 = *a1;
  if ( (_DWORD)result )
    v6 = 2;
  else
    v6 = 8;
  *v5 = v6;
  if ( (_DWORD)result )
  {
    v7 = a1[1];
    if ( v7[1027] )
    {
      v7[1027] = 0;
    }
    else
    {
      if ( *((_UNKNOWN **)v7 + 13) == &_sF )
        return 0;
      v12 = (unsigned int (__fastcall *)(int **, _QWORD, _QWORD))*((_QWORD *)v7 + 2);
      if ( v12 )
      {
        if ( v12(a1, 0, *((_QWORD *)v7 + 12)) == 1 )
          return 0;
        v5 = *a1;
        v7 = a1[1];
      }
    }
    *v5 = 0;
    v8 = (void *)*((_QWORD *)v7 + 84);
    v7[116] = 0;
    free(v8);
    *((_QWORD *)a1[1] + 84) = 0;
    v9 = a1[1];
    v9[117] = 0;
    v10 = (*a1)[7];
    *((_QWORD *)v9 + 56) = 0;
    v9[1026] = v10;
    FLAC__MD5Init((__int64)(v9 + 1030));
    v11 = a1[1];
    result = 1;
    *((_QWORD *)v11 + 856) = 0;
    v11[1716] = 0;
  }
  return result;
}

//----- (000000000002976C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_process_single(_DWORD **a1)
{
  __int64 result; // x0
  int v3; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v4; // [xsp+8h] [xbp-28h]

  v4 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  while ( 2 )
  {
    result = 1;
    switch ( **a1 )
    {
      case 0:
        result = sub_29870((__int64)a1);
        if ( (_DWORD)result )
          continue;
        break;
      case 1:
        result = (unsigned int)sub_29B48((__int64)a1) != 0;
        break;
      case 2:
        if ( (unsigned int)sub_2AB54((__int64)a1) )
          continue;
        result = 1;
        break;
      case 3:
        result = (__int64)sub_2ACF8((__int64)a1, &v3, 1);
        if ( (_DWORD)result )
        {
          if ( !v3 )
            continue;
          result = 1;
        }
        break;
      case 4:
      case 7:
        return result;
      default:
        result = 0;
        break;
    }
    break;
  }
  return result;
}

//----- (0000000000029870) ----------------------------------------------------
__int64 __fastcall sub_29870(__int64 a1)
{
  unsigned int v2; // w26
  int v3; // w25
  unsigned int v4; // w28
  __int64 v5; // x9
  int v6; // w8
  unsigned int v7; // w27
  char v9; // w26
  char v10; // w28
  char v11; // w21
  int v12; // w8
  __int64 result; // x0
  __int64 v14; // x8
  __int64 v15; // x8
  int v16; // [xsp+0h] [xbp-60h] BYREF
  int v17; // [xsp+4h] [xbp-5Ch] BYREF
  __int64 v18; // [xsp+8h] [xbp-58h]

  v2 = 0;
  v3 = 1;
  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
LABEL_2:
  while ( 2 )
  {
    v4 = 0;
    while ( 1 )
    {
      v5 = *(_QWORD *)(a1 + 8);
      if ( !*(_DWORD *)(v5 + 3968) )
        break;
      v6 = *(unsigned __int8 *)(v5 + 4038);
      v16 = v6;
      *(_DWORD *)(v5 + 3968) = 0;
      if ( v6 == *((unsigned __int8 *)&FLAC__STREAM_SYNC_STRING + v2) )
        goto LABEL_18;
LABEL_5:
      if ( v4 > 2 )
        return 0;
      if ( v6 != (unsigned __int8)aId3_0[v4] )
      {
        if ( v6 == 255 )
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 8) + 4036LL) = -1;
          result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v16, 8u);
          if ( !(_DWORD)result )
            return result;
          if ( v16 == 255 )
          {
            v14 = *(_QWORD *)(a1 + 8);
            *(_BYTE *)(v14 + 4038) = -1;
            *(_DWORD *)(v14 + 3968) = 1;
            if ( !v3 )
              goto LABEL_30;
LABEL_27:
            v15 = *(_QWORD *)(a1 + 8);
            if ( !*(_DWORD *)(v15 + 4112) )
              (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(v15 + 64))(a1, 0, *(_QWORD *)(v15 + 96));
            v2 = 0;
            v3 = 0;
            goto LABEL_2;
          }
          if ( (v16 & 0xFFFFFFFE) == 0xF8 )
          {
            result = 1;
            *(_BYTE *)(*(_QWORD *)(a1 + 8) + 4037LL) = v16;
            **(_DWORD **)a1 = 3;
            return result;
          }
        }
        if ( !v3 )
        {
LABEL_30:
          v2 = 0;
          goto LABEL_2;
        }
        goto LABEL_27;
      }
      v7 = v4 + 1;
      v2 = 0;
      if ( v4++ == 2 )
      {
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v17, 0x18u) )
          return 0;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v17, 8u) )
          return 0;
        v9 = v17;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v17, 8u) )
          return 0;
        v10 = v17;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v17, 8u) )
          return 0;
        v11 = v17;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v17, 8u) )
          return 0;
        v12 = FLAC__bitreader_skip_byte_block_aligned_no_crc(
                *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL),
                v17 & 0x7F | ((v11 & 0x7F | ((v10 & 0x7F | ((v9 & 0x7F) << 7) & 0x3FFF) << 7) & 0x1FFFFFu) << 7));
        v2 = 0;
        result = 0;
        v4 = v7;
        if ( !v12 )
          return result;
      }
    }
    result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v5 + 112), &v16, 8u);
    if ( !(_DWORD)result )
      return result;
    v6 = v16;
    if ( v16 != *((unsigned __int8 *)&FLAC__STREAM_SYNC_STRING + v2) )
      goto LABEL_5;
LABEL_18:
    ++v2;
    v3 = 1;
    if ( v2 < 4 )
      continue;
    break;
  }
  result = 1;
  **(_DWORD **)a1 = 1;
  return result;
}
// 61A28: using guessed type int FLAC__STREAM_SYNC_STRING;

//----- (0000000000029B48) ----------------------------------------------------
__int64 __fastcall sub_29B48(__int64 a1)
{
  _DWORD **v1; // x27
  __int64 *v2; // x19
  __int64 result; // x0
  int v4; // w26
  _BOOL4 v5; // w21
  unsigned int v6; // w22
  _DWORD *v7; // x8
  unsigned int v8; // w25
  __int64 v9; // x0
  __int64 v10; // x20
  const void *v11; // x0
  void (__fastcall *v12)(_DWORD **, __int64, _QWORD); // x8
  _DWORD *v13; // x8
  unsigned int v14; // w23
  __int64 v15; // x8
  void *v16; // x20
  void *v17; // x0
  __int64 v18; // x8
  int v19; // w9
  __int64 v20; // x24
  unsigned int v21; // w20
  int v22; // w26
  _BOOL4 v23; // w25
  bool v24; // cf
  void *v25; // x0
  __int64 v26; // x24
  unsigned __int64 v27; // x25
  __int64 v28; // x8
  __int64 v29; // x8
  unsigned __int64 v30; // x9
  int v31; // w9
  unsigned __int64 v32; // x27
  char *v33; // x22
  unsigned __int64 i; // x25
  void (__fastcall *v35)(_DWORD **, __int64, _QWORD); // x9
  __int64 v36; // x9
  unsigned int (__fastcall *v37)(_DWORD **, __int64, _QWORD); // x8
  _QWORD *v38; // x20
  _BYTE *v39; // x8
  unsigned int v40; // w21
  unsigned int v41; // w20
  unsigned __int64 *v42; // x0
  unsigned __int64 *v43; // x24
  __int64 v44; // x21
  unsigned __int64 *v45; // x9
  unsigned __int64 *v46; // x20
  _BYTE *v47; // x20
  char v48; // t1
  unsigned __int64 *v49; // x20
  bool v50; // zf
  size_t v51; // x0
  _BYTE *v52; // x23
  unsigned __int64 *v53; // x0
  unsigned __int64 *v54; // x24
  unsigned __int64 **v55; // x20
  __int64 v56; // x26
  __int64 v57; // x22
  int raw_uint64; // w0
  unsigned int v59; // w20
  _BYTE *v60; // x0
  _BYTE *v61; // x8
  __int64 v62; // x9
  __int64 v63; // x9
  void (__fastcall *v64)(_DWORD **, _DWORD *, _QWORD); // x8
  char v65; // w20
  unsigned int v66; // w8
  _BYTE *v67; // x0
  _DWORD *v68; // x8
  unsigned int v69; // w20
  _BYTE *v70; // x0
  _BYTE *v71; // x8
  __int64 v72; // x9
  int *v73; // x0
  int *v74; // x1
  __int64 v75; // x22
  unsigned int v76; // w20
  size_t v77; // x0
  _BYTE *v78; // x0
  void *v79; // x0
  unsigned int v80; // w8
  unsigned __int64 v81; // x21
  __int64 v82; // x22
  void *v83; // x0
  unsigned int v84; // w8
  unsigned __int64 v85; // x21
  __int64 v86; // x22
  void *v87; // x0
  __int64 v88; // x20
  char *v89; // x23
  __int64 v90; // x24
  void *v91; // x0
  char *v92; // x8
  _DWORD **v93; // [xsp+38h] [xbp-128h]
  int v94; // [xsp+44h] [xbp-11Ch]
  unsigned int v95; // [xsp+48h] [xbp-118h] BYREF
  unsigned int v96; // [xsp+4Ch] [xbp-114h] BYREF
  int v97; // [xsp+50h] [xbp-110h] BYREF
  _DWORD nmemb[5]; // [xsp+54h] [xbp-10Ch] BYREF
  void *v99; // [xsp+68h] [xbp-F8h] BYREF
  void *v100; // [xsp+70h] [xbp-F0h]
  void *v101; // [xsp+78h] [xbp-E8h] BYREF
  void *p; // [xsp+80h] [xbp-E0h] BYREF
  int v103; // [xsp+88h] [xbp-D8h] BYREF
  int v104; // [xsp+8Ch] [xbp-D4h] BYREF
  unsigned int v105; // [xsp+90h] [xbp-D0h] BYREF
  _BYTE *v106; // [xsp+98h] [xbp-C8h]
  unsigned __int64 v107; // [xsp+F0h] [xbp-70h] BYREF
  _BOOL4 v108; // [xsp+F8h] [xbp-68h]
  unsigned int v109; // [xsp+FCh] [xbp-64h]
  unsigned __int64 *v110; // [xsp+100h] [xbp-60h]
  __int64 v111; // [xsp+108h] [xbp-58h]

  v1 = (_DWORD **)a1;
  v111 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = (__int64 *)(a1 + 8);
  result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v97, 1u);
  if ( !(_DWORD)result )
    return result;
  v4 = v97;
  v5 = v97 != 0;
  result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &v96, 7u);
  if ( !(_DWORD)result )
    return result;
  result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &v95, 0x18u);
  if ( !(_DWORD)result )
    return result;
  v6 = v96;
  if ( v96 == 3 )
  {
    v13 = (_DWORD *)*v2;
    v13[117] = 0;
    v14 = v95;
    v13[162] = 3;
    v13[163] = v5;
    v13[164] = v14;
    v13[166] = v14 / 0x12;
    v15 = *(unsigned int *)(*v2 + 664);
    v16 = *(void **)(*v2 + 672);
    if ( (_DWORD)v15 )
    {
      v17 = realloc(*(void **)(*v2 + 672), 24 * v15);
      if ( v17 )
      {
        *(_QWORD *)(*v2 + 672) = v17;
        v18 = *v2;
        v19 = *(_DWORD *)(*v2 + 664);
        if ( !v19 )
          goto LABEL_39;
        goto LABEL_33;
      }
      free(v16);
      *(_QWORD *)(*v2 + 672) = 0;
    }
    else
    {
      v25 = realloc(*(void **)(*v2 + 672), 0);
      *(_QWORD *)(*v2 + 672) = v25;
      if ( v25 )
      {
        v18 = *v2;
        v19 = *(_DWORD *)(*v2 + 664);
        if ( !v19 )
          goto LABEL_39;
LABEL_33:
        v26 = 0;
        v27 = 0;
        do
        {
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint64(
                                *(_QWORD *)(v18 + 112),
                                (unsigned __int64 *)&nmemb[1],
                                0x40u) )
            return 0;
          v28 = *v2;
          *(_QWORD *)(*(_QWORD *)(*v2 + 672) + v26) = *(_QWORD *)&nmemb[1];
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint64(
                                *(_QWORD *)(v28 + 112),
                                (unsigned __int64 *)&nmemb[1],
                                0x40u) )
            return 0;
          v29 = *v2;
          *(_QWORD *)(*(_QWORD *)(*v2 + 672) + v26 + 8) = *(_QWORD *)&nmemb[1];
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v29 + 112), nmemb, 0x10u) )
            return 0;
          v18 = *v2;
          ++v27;
          *(_DWORD *)(*(_QWORD *)(*v2 + 672) + v26 + 16) = nmemb[0];
          v30 = *(unsigned int *)(v18 + 664);
          v26 += 24;
        }
        while ( v27 < v30 );
        v19 = -18 * v30;
LABEL_39:
        if ( v19 + v14 )
        {
          if ( !(unsigned int)FLAC__bitreader_skip_byte_block_aligned_no_crc(*(_QWORD *)(v18 + 112), v19 + v14) )
            return 0;
          v18 = *v2;
        }
        v31 = *(_DWORD *)(v18 + 4112);
        *(_DWORD *)(v18 + 468) = 1;
        if ( !v31 )
        {
          if ( *(_DWORD *)(v18 + 836) )
          {
            v35 = *(void (__fastcall **)(_DWORD **, __int64, _QWORD))(v18 + 56);
            if ( v35 )
            {
              v35(v1, v18 + 648, *(_QWORD *)(v18 + 96));
              if ( !v4 )
                return 1;
              goto LABEL_65;
            }
          }
        }
        goto LABEL_43;
      }
    }
    **v1 = 8;
    return 0;
  }
  if ( !v96 )
  {
    v7 = (_DWORD *)*v2;
    v8 = v95;
    v9 = *(_QWORD *)(*v2 + 112);
    v7[118] = 0;
    v7[119] = v5;
    v7[120] = v8;
    if ( (unsigned int)FLAC__bitreader_read_raw_uint32(v9, &nmemb[1], 0x10u) )
    {
      *(_DWORD *)(*v2 + 488) = nmemb[1];
      if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 0x10u) )
      {
        *(_DWORD *)(*v2 + 492) = nmemb[1];
        if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 0x18u) )
        {
          *(_DWORD *)(*v2 + 496) = nmemb[1];
          if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 0x18u) )
          {
            *(_DWORD *)(*v2 + 500) = nmemb[1];
            if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 0x14u) )
            {
              *(_DWORD *)(*v2 + 504) = nmemb[1];
              if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 3u) )
              {
                *(_DWORD *)(*v2 + 508) = nmemb[1] + 1;
                if ( (unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &nmemb[1], 5u) )
                {
                  *(_DWORD *)(*v2 + 512) = nmemb[1] + 1;
                  if ( (unsigned int)FLAC__bitreader_read_raw_uint64(
                                       *(_QWORD *)(*v2 + 112),
                                       (unsigned __int64 *)(*v2 + 520),
                                       0x24u) )
                  {
                    if ( (unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(
                                         *(_QWORD *)(*v2 + 112),
                                         (_BYTE *)(*v2 + 528),
                                         0x10u) )
                    {
                      result = FLAC__bitreader_skip_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v8 - 34);
                      if ( !(_DWORD)result )
                        return result;
                      v10 = *v2;
                      v11 = (const void *)(*v2 + 528);
                      *(_DWORD *)(*v2 + 464) = 1;
                      if ( !memcmp(v11, "", 0x10u) )
                        *(_DWORD *)(v10 + 4104) = 0;
                      if ( !*(_DWORD *)(v10 + 4112) )
                      {
                        if ( *(_DWORD *)(v10 + 824) )
                        {
                          v12 = *(void (__fastcall **)(_DWORD **, __int64, _QWORD))(v10 + 56);
                          if ( v12 )
                          {
                            v12(v1, v10 + 472, *(_QWORD *)(v10 + 96));
                            if ( !v4 )
                              return 1;
LABEL_65:
                            v36 = *v2;
                            v37 = *(unsigned int (__fastcall **)(_DWORD **, __int64, _QWORD))(*v2 + 24);
                            if ( v37
                              && (v38 = (_QWORD *)(v36 + 6848), !v37(v1, v36 + 6848, *(_QWORD *)(v36 + 96)))
                              && FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(*v2 + 112)) )
                            {
                              *v38 -= (unsigned int)FLAC__bitreader_get_input_bits_unconsumed(*(_DWORD **)(*v2 + 112)) >> 3;
                            }
                            else
                            {
                              *(_QWORD *)(*v2 + 6848) = 0;
                            }
                            **v1 = 2;
                            return 1;
                          }
                        }
                      }
LABEL_43:
                      if ( !v4 )
                        return 1;
                      goto LABEL_65;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  v20 = *v2;
  v94 = v4;
  v21 = v95;
  v22 = *(_DWORD *)(*v2 + 4LL * v96 + 824);
  v23 = v22 == 0;
  memset(&nmemb[1], 0, 0xB0u);
  *(_QWORD *)&nmemb[1] = __PAIR64__(v5, v6);
  nmemb[3] = v21;
  if ( v6 != 2 )
    goto LABEL_62;
  if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(v20 + 112), &v99, 4u) )
    return 0;
  v24 = v21 >= 4;
  v21 -= 4;
  if ( !v24 )
  {
    result = 0;
    **v1 = 8;
    return result;
  }
  v20 = *v2;
  v93 = v1;
  v32 = *(_QWORD *)(*v2 + 1344);
  if ( !v32 )
  {
LABEL_61:
    v1 = v93;
LABEL_62:
    if ( v23 )
      goto LABEL_63;
LABEL_53:
    switch ( v96 )
    {
      case 0u:
      case 3u:
        goto LABEL_127;
      case 1u:
        if ( !(unsigned int)FLAC__bitreader_skip_byte_block_aligned_no_crc(*(_QWORD *)(v20 + 112), v21) )
          goto LABEL_165;
        goto LABEL_127;
      case 2u:
        if ( !v21 )
        {
          v100 = 0;
          goto LABEL_127;
        }
        v39 = malloc(v21);
        v100 = v39;
        if ( !v39 )
          goto LABEL_140;
        goto LABEL_77;
      case 4u:
        v40 = v21 - 8;
        if ( v21 < 8 )
          goto LABEL_85;
        if ( !(unsigned int)FLAC__bitreader_read_uint32_little_endian(*(_QWORD *)(v20 + 112), (int *)&v99) )
          goto LABEL_165;
        v41 = (unsigned int)v99;
        if ( (_DWORD)v99 )
        {
          if ( v40 < (unsigned int)v99 )
          {
            LODWORD(v99) = 0;
            v100 = 0;
            goto LABEL_84;
          }
          v67 = malloc((unsigned int)v99 + 1LL);
          v100 = v67;
          if ( !v67 )
            goto LABEL_140;
          if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v67, v41) )
            goto LABEL_165;
          v40 -= v41;
          *((_BYTE *)v100 + (unsigned int)v99) = 0;
        }
        else
        {
          v100 = 0;
        }
        if ( !(unsigned int)FLAC__bitreader_read_uint32_little_endian(*(_QWORD *)(*v2 + 112), (int *)&v101) )
          goto LABEL_165;
        if ( (unsigned int)v101 >= 0x186A1 )
        {
          v65 = 0;
          LODWORD(v101) = 0;
          v66 = v96 - 1;
          if ( v96 - 1 <= 5 )
            goto LABEL_169;
          goto LABEL_209;
        }
        if ( !(_DWORD)v101 )
          goto LABEL_84;
        v73 = (int *)safe_malloc_mul_2op_p((unsigned int)v101, 0x10u);
        v74 = v73;
        p = v73;
        if ( !v73 )
        {
          v65 = 0;
          LODWORD(v101) = 0;
          goto LABEL_141;
        }
        if ( !(_DWORD)v101 )
          goto LABEL_84;
        LODWORD(v75) = 0;
        *v73 = 0;
        *((_QWORD *)v73 + 1) = 0;
        if ( v40 < 4 )
          goto LABEL_152;
        v88 = 0;
        v75 = 0;
        while ( 2 )
        {
          if ( !(unsigned int)FLAC__bitreader_read_uint32_little_endian(*(_QWORD *)(*v2 + 112), v74) )
          {
            v65 = 0;
            goto LABEL_208;
          }
          v89 = (char *)p;
          v40 -= 4;
          v90 = *(unsigned int *)((char *)p + v88);
          if ( (_DWORD)v90 )
          {
            if ( v40 < (unsigned int)v90 )
              goto LABEL_152;
            v91 = malloc(v90 + 1);
            *(_QWORD *)&v89[v88 + 8] = v91;
            if ( !v91 )
            {
              v65 = 0;
              **v1 = 8;
LABEL_208:
              LODWORD(v101) = v75;
              v66 = v96 - 1;
              if ( v96 - 1 <= 5 )
                goto LABEL_169;
              goto LABEL_209;
            }
            v40 -= v90;
            memset(v91, 0, *(unsigned int *)&v89[v88]);
            if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(
                                  *(_QWORD *)(*v2 + 112),
                                  *(_BYTE **)&v89[v88 + 8],
                                  *(_DWORD *)&v89[v88]) )
            {
              free(*(void **)((char *)p + v88 + 8));
              *(_QWORD *)((char *)p + v88 + 8) = 0;
LABEL_152:
              LODWORD(v101) = v75;
LABEL_84:
              v21 = v40;
LABEL_85:
              if ( !v21 )
                goto LABEL_127;
              if ( !(_DWORD)v101 )
              {
                free(p);
                p = 0;
              }
              if ( (unsigned int)FLAC__bitreader_skip_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v21) )
                goto LABEL_127;
LABEL_165:
              v65 = 0;
              v66 = v96 - 1;
              if ( v96 - 1 <= 5 )
              {
LABEL_169:
                switch ( v66 )
                {
                  case 0u:
                    break;
                  case 1u:
                    v79 = v100;
                    if ( v100 )
                      goto LABEL_210;
                    break;
                  case 3u:
                    if ( v100 )
                      free(v100);
                    v80 = (unsigned int)v101;
                    if ( (_DWORD)v101 )
                    {
                      v81 = 0;
                      v82 = 8;
                      do
                      {
                        v83 = *(void **)((char *)p + v82);
                        if ( v83 )
                        {
                          free(v83);
                          v80 = (unsigned int)v101;
                        }
                        ++v81;
                        v82 += 16;
                      }
                      while ( v81 < v80 );
                    }
                    v79 = p;
                    if ( p )
                      goto LABEL_210;
                    break;
                  case 4u:
                    v84 = v109;
                    if ( v109 )
                    {
                      v85 = 0;
                      v86 = 3;
                      do
                      {
                        v87 = (void *)v110[v86];
                        if ( v87 )
                        {
                          free(v87);
                          v84 = v109;
                        }
                        ++v85;
                        v86 += 4;
                      }
                      while ( v85 < v84 );
                    }
                    v79 = v110;
                    if ( v110 )
                      goto LABEL_210;
                    break;
                  case 5u:
                    if ( v100 )
                      free(v100);
                    if ( v101 )
                      free(v101);
                    v79 = v106;
                    if ( v106 )
                      goto LABEL_210;
                    break;
                  default:
                    goto LABEL_209;
                }
              }
              else
              {
LABEL_209:
                v79 = v99;
                if ( v99 )
LABEL_210:
                  free(v79);
              }
              if ( (v65 & 1) != 0 )
                goto LABEL_64;
              return 0;
            }
            *(_BYTE *)(*(_QWORD *)((char *)p + v88 + 8) + *(unsigned int *)((char *)p + v88)) = 0;
            if ( ++v75 >= (unsigned __int64)(unsigned int)v101 )
              goto LABEL_84;
          }
          else
          {
            *(_QWORD *)((char *)p + v88 + 8) = 0;
            if ( ++v75 >= (unsigned __int64)(unsigned int)v101 )
              goto LABEL_84;
          }
          v74 = (int *)((char *)p + 16 * v75);
          v92 = (char *)p + v88;
          v88 += 16;
          *((_DWORD *)v92 + 4) = 0;
          *((_QWORD *)v92 + 3) = 0;
          if ( v40 < 4 )
            goto LABEL_152;
          continue;
        }
      case 5u:
        memset(&v99, 0, 0xA0u);
        if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(v20 + 112), &v99, 0x80u) )
          goto LABEL_165;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint64(*(_QWORD *)(*v2 + 112), &v107, 0x40u) )
          goto LABEL_165;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 1u) )
          goto LABEL_165;
        v108 = nmemb[0] != 0;
        if ( !(unsigned int)FLAC__bitreader_skip_bits_no_crc(*(_QWORD *)(*v2 + 112), 0x817u)
          || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 8u) )
        {
          goto LABEL_165;
        }
        v109 = nmemb[0];
        if ( !nmemb[0] )
          goto LABEL_127;
        v42 = (unsigned __int64 *)calloc(nmemb[0], 0x20u);
        v43 = v42;
        v110 = v42;
        if ( !v42 )
          goto LABEL_167;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint64(*(_QWORD *)(*v2 + 112), v42, 0x40u) )
          goto LABEL_165;
        v44 = 0;
        while ( 2 )
        {
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 8u) )
            goto LABEL_165;
          v45 = &v43[4 * v44];
          *((_BYTE *)v45 + 8) = nmemb[0];
          if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(
                                *(_QWORD *)(*v2 + 112),
                                (_BYTE *)v45 + 9,
                                0xCu) )
            goto LABEL_165;
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 1u) )
            goto LABEL_165;
          v46 = &v43[4 * v44];
          v48 = *((_BYTE *)v46 + 22);
          v47 = (char *)v46 + 22;
          *v47 = v48 & 0xFE | nmemb[0] & 1;
          if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 1u) )
            goto LABEL_165;
          *v47 = (2 * (nmemb[0] & 1)) | *v47 & 0xFD;
          if ( !(unsigned int)FLAC__bitreader_skip_bits_no_crc(*(_QWORD *)(*v2 + 112), 0x6Eu)
            || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 8u) )
          {
            goto LABEL_165;
          }
          v49 = &v43[4 * v44];
          v51 = LOBYTE(nmemb[0]);
          v50 = LOBYTE(nmemb[0]) == 0;
          *((_BYTE *)v49 + 23) = nmemb[0];
          v52 = (char *)v49 + 23;
          if ( v50 )
            goto LABEL_115;
          v53 = (unsigned __int64 *)calloc(v51, 0x10u);
          v54 = v53;
          v49[3] = (unsigned __int64)v53;
          v55 = (unsigned __int64 **)(v49 + 3);
          if ( !v53 )
          {
LABEL_167:
            v68 = *v1;
            v65 = 0;
LABEL_168:
            *v68 = 8;
            v66 = v96 - 1;
            goto LABEL_169;
          }
          if ( *v52 )
          {
            if ( (unsigned int)FLAC__bitreader_read_raw_uint64(*(_QWORD *)(*v2 + 112), v53, 0x40u) )
            {
              v56 = 0;
              v57 = 1;
              do
              {
                if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 8u) )
                  break;
                LOBYTE(v54[v57]) = nmemb[0];
                if ( !(unsigned int)FLAC__bitreader_skip_bits_no_crc(*(_QWORD *)(*v2 + 112), 0x18u) )
                  break;
                if ( ++v56 >= (unsigned __int64)(unsigned __int8)*v52 )
                  goto LABEL_115;
                v54 = *v55;
                raw_uint64 = FLAC__bitreader_read_raw_uint64(*(_QWORD *)(*v2 + 112), &(*v55)[v57 + 1], 0x40u);
                v57 += 2;
              }
              while ( raw_uint64 );
            }
            goto LABEL_165;
          }
LABEL_115:
          if ( ++v44 < (unsigned __int64)v109 )
          {
            v43 = v110;
            if ( !(unsigned int)FLAC__bitreader_read_raw_uint64(*(_QWORD *)(*v2 + 112), &v110[4 * v44], 0x40u) )
              goto LABEL_165;
            continue;
          }
          break;
        }
LABEL_127:
        v63 = *v2;
        if ( !*(_DWORD *)(*v2 + 4112) )
        {
LABEL_128:
          v64 = *(void (__fastcall **)(_DWORD **, _DWORD *, _QWORD))(v63 + 56);
          if ( v64 )
            v64(v1, &nmemb[1], *(_QWORD *)(v63 + 96));
        }
LABEL_130:
        v65 = 1;
        v66 = v96 - 1;
        if ( v96 - 1 > 5 )
          goto LABEL_209;
        goto LABEL_169;
      case 6u:
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v20 + 112), nmemb, 0x20u) )
          goto LABEL_165;
        LODWORD(v99) = nmemb[0];
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 0x20u) )
          goto LABEL_165;
        v59 = nmemb[0];
        v60 = malloc(nmemb[0] + 1LL);
        v61 = v60;
        v100 = v60;
        if ( !v60 )
          goto LABEL_167;
        if ( v59 )
        {
          if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v60, v59) )
            goto LABEL_165;
          v61 = v100;
          v62 = nmemb[0];
        }
        else
        {
          v62 = 0;
        }
        v61[v62] = 0;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), nmemb, 0x20u) )
          goto LABEL_165;
        v69 = nmemb[0];
        v70 = malloc(nmemb[0] + 1LL);
        v71 = v70;
        v101 = v70;
        if ( !v70 )
          goto LABEL_167;
        if ( v69 )
        {
          if ( !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v70, v69) )
            goto LABEL_165;
          v71 = v101;
          v72 = nmemb[0];
        }
        else
        {
          v72 = 0;
        }
        v71[v72] = 0;
        if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &p, 0x20u)
          || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), (_DWORD *)&p + 1, 0x20u)
          || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &v103, 0x20u)
          || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &v104, 0x20u)
          || !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*v2 + 112), &v105, 0x20u) )
        {
          goto LABEL_165;
        }
        v76 = v105;
        if ( v105 )
          v77 = v105;
        else
          v77 = 1;
        v78 = malloc(v77);
        v106 = v78;
        if ( !v78 )
          goto LABEL_167;
        if ( v76 && !(unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(*v2 + 112), v78, v76) )
          goto LABEL_165;
        goto LABEL_127;
      default:
        if ( !v21 )
        {
          v99 = 0;
          v63 = *v2;
          if ( *(_DWORD *)(*v2 + 4112) )
            goto LABEL_130;
          goto LABEL_128;
        }
        v39 = malloc(v21);
        v99 = v39;
        if ( !v39 )
        {
LABEL_140:
          v65 = 0;
LABEL_141:
          v68 = *v1;
          goto LABEL_168;
        }
LABEL_77:
        if ( (unsigned int)FLAC__bitreader_read_byte_block_aligned_no_crc(*(_QWORD *)(v20 + 112), v39, v21) )
          goto LABEL_127;
        goto LABEL_165;
    }
  }
  v33 = *(char **)(v20 + 1336);
  for ( i = 0; i < v32; ++i )
  {
    if ( !memcmp(v33, &v99, 4u) )
    {
      v23 = v22 != 0;
      goto LABEL_61;
    }
    v33 += 4;
  }
  v1 = v93;
  if ( v22 )
    goto LABEL_53;
LABEL_63:
  if ( !(unsigned int)FLAC__bitreader_skip_byte_block_aligned_no_crc(*(_QWORD *)(v20 + 112), v21) )
    return 0;
LABEL_64:
  if ( v94 )
    goto LABEL_65;
  return 1;
}

//----- (000000000002AB54) ----------------------------------------------------
__int64 __fastcall sub_2AB54(__int64 a1)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  __int64 v4; // x20
  unsigned int v5; // w0
  __int64 result; // x0
  int v7; // w8
  __int64 v8; // x9
  int v9; // w23
  int v10; // w8
  __int64 v11; // x8
  __int64 v12; // x9
  int *v13; // x8
  int v14; // w9
  int v15; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v16; // [xsp+8h] [xbp-38h]

  v16 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v2 + 464) )
  {
    v3 = *(_QWORD *)(v2 + 520);
    if ( v3 )
    {
      if ( *(_QWORD *)(v2 + 456) >= v3 )
      {
        v13 = *(int **)a1;
        v14 = 4;
        goto LABEL_22;
      }
    }
  }
  if ( FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(v2 + 112))
    || (v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL),
        v5 = FLAC__bitreader_bits_left_for_byte_alignment(v4),
        result = FLAC__bitreader_read_raw_uint32(v4, &v15, v5),
        (_DWORD)result) )
  {
    v7 = 1;
    while ( 1 )
    {
      while ( 1 )
      {
        v8 = *(_QWORD *)(a1 + 8);
        v9 = v7;
        if ( *(_DWORD *)(v8 + 3968) )
          break;
        result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v8 + 112), &v15, 8u);
        if ( !(_DWORD)result )
          return result;
        if ( v15 != 255 )
          goto LABEL_17;
LABEL_12:
        *(_BYTE *)(*(_QWORD *)(a1 + 8) + 4036LL) = -1;
        result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v15, 8u);
        if ( !(_DWORD)result )
          return result;
        if ( v15 != 255 )
        {
          if ( (v15 & 0xFFFFFFFE) == 0xF8 )
          {
            *(_BYTE *)(*(_QWORD *)(a1 + 8) + 4037LL) = v15;
            v13 = *(int **)a1;
            v14 = 3;
LABEL_22:
            result = 1;
            *v13 = v14;
            return result;
          }
          goto LABEL_17;
        }
        v11 = *(_QWORD *)(a1 + 8);
        *(_BYTE *)(v11 + 4038) = -1;
        *(_DWORD *)(v11 + 3968) = 1;
        v7 = 0;
        if ( v9 )
          goto LABEL_18;
      }
      v10 = *(unsigned __int8 *)(v8 + 4038);
      v15 = v10;
      *(_DWORD *)(v8 + 3968) = 0;
      if ( v10 == 255 )
        goto LABEL_12;
LABEL_17:
      v7 = 0;
      if ( v9 )
      {
LABEL_18:
        v12 = *(_QWORD *)(a1 + 8);
        v7 = 0;
        if ( !*(_DWORD *)(v12 + 4112) )
        {
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(v12 + 64))(a1, 0, *(_QWORD *)(v12 + 96));
          v7 = 0;
        }
      }
    }
  }
  return result;
}

//----- (000000000002ACF8) ----------------------------------------------------
_QWORD *__fastcall sub_2ACF8(__int64 a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // x28
  __int64 v5; // x8
  __int64 v6; // x19
  unsigned int v8; // w9
  __int64 v9; // x8
  unsigned int v10; // w22
  __int64 v11; // x8
  int v12; // w9
  int *v13; // x8
  _QWORD *result; // x0
  unsigned int v15; // w11
  char v16; // w9
  int v17; // w8
  int v18; // w22
  __int64 v19; // x9
  int v20; // w10
  unsigned __int16 v21; // w10
  unsigned int v22; // w23
  int v23; // w11
  __int64 v24; // x9
  int v25; // w10
  int v26; // w11
  int v27; // w26
  int v28; // w10
  int v29; // w8
  __int64 v30; // x9
  __int64 v31; // x8
  __int64 v32; // x8
  __int64 v33; // x9
  __int64 v34; // x9
  int v35; // w8
  int v36; // w9
  char v37; // w9
  int v38; // w10
  int v39; // w9
  int v40; // w10
  unsigned int v41; // w12
  int v42; // w8
  int v43; // w20
  unsigned __int8 v44; // w0
  int v45; // w9
  __int64 v46; // x9
  __int64 v47; // x10
  __int64 v48; // x8
  unsigned __int64 v49; // x22
  unsigned __int64 v50; // x24
  __int64 v51; // x9
  void *v52; // x0
  __int64 v53; // x9
  void *v54; // x0
  __int64 v55; // x9
  void *v56; // x0
  __int64 v57; // x9
  void *v58; // x0
  __int64 v59; // x9
  void *v60; // x0
  __int64 v61; // x9
  void *v62; // x0
  __int64 v63; // x9
  void *v64; // x0
  __int64 v65; // x9
  void *v66; // x0
  __int64 v67; // x26
  __int64 v68; // x24
  int v69; // w9
  unsigned int v70; // w26
  bool v71; // zf
  char v72; // w22
  unsigned int v73; // w8
  __int64 v74; // x23
  bool v75; // cf
  _DWORD *v76; // x27
  int v77; // w9
  __int64 v78; // x8
  unsigned __int64 v79; // x9
  __int64 v80; // x8
  int v81; // w10
  _DWORD *v82; // x9
  unsigned __int64 v83; // x10
  __int64 v84; // x11
  int v85; // w12
  __int64 v86; // x20
  __int64 v87; // x27
  const void **v88; // x27
  unsigned __int64 v89; // x21
  unsigned __int64 v90; // x8
  size_t v91; // x2
  __int64 v92; // x9
  __int64 v93; // x10
  unsigned __int64 v94; // x27
  __int64 v95; // x0
  unsigned __int64 v96; // x20
  unsigned int v97; // w9
  __int64 v98; // x20
  __int64 v99; // x8
  __int64 v100; // x8
  unsigned int v101; // w2
  __int64 v102; // x9
  __int64 v103; // x10
  int v104; // w8
  unsigned __int64 v105; // x27
  __int64 v106; // x0
  unsigned __int64 v107; // x20
  unsigned int v108; // w28
  __int64 v109; // x21
  __int64 v110; // x21
  __int64 v111; // x9
  unsigned __int64 v112; // x20
  __int64 v113; // x0
  __int64 v114; // x21
  unsigned int v115; // w9
  __int64 v116; // x20
  __int64 v117; // x8
  unsigned int v118; // w2
  __int64 v119; // x8
  unsigned int v120; // w8
  __int64 v121; // x8
  __int64 v122; // x8
  unsigned int v123; // w8
  int *v124; // x8
  int v125; // w9
  unsigned __int16 crc16; // w22
  __int64 v127; // x8
  int v128; // w9
  __int64 v129; // x9
  __int64 v130; // x10
  unsigned __int64 v131; // x11
  __int64 v132; // x12
  int v133; // w13
  int v134; // w14
  __int64 v135; // x22
  unsigned int v136; // w0
  __int64 v137; // x8
  unsigned __int64 v138; // x20
  __int64 v139; // x22
  int v140; // w8
  int *v141; // x9
  __int64 v142; // d0
  int v143; // w8
  __int64 v144; // x3
  unsigned __int64 v145; // x24
  unsigned __int64 v146; // x23
  __int64 v147; // x21
  __int64 v148; // x20
  unsigned __int64 v149; // x26
  int v150; // w8
  __int64 v151; // x9
  unsigned __int64 v152; // x10
  __int64 v153; // x12
  __int64 v154; // x13
  __int64 v155; // x11
  __int64 *v156; // x12
  char *v157; // x13
  __int64 v158; // t1
  __int64 v159; // x12
  int v160; // w0
  __int64 v161; // x9
  __int64 v162; // x10
  unsigned __int64 v163; // x11
  __int64 v164; // x12
  int v165; // w13
  int v166; // w14
  int v167; // w15
  __int64 v168; // x9
  __int64 v169; // x10
  unsigned __int64 v170; // x11
  __int64 v171; // x12
  int v172; // w13
  int v173; // w14
  __int64 v174; // x10
  int64x2_t *v175; // x13
  int64x2_t *v176; // x14
  int64x2_t v177; // q0
  __int64 v178; // x15
  int64x2_t v179; // q1
  int64x2_t v180; // q2
  unsigned int *v181; // [xsp+10h] [xbp-100h]
  unsigned int *v182; // [xsp+18h] [xbp-F8h]
  int v183; // [xsp+3Ch] [xbp-D4h]
  int v184; // [xsp+3Ch] [xbp-D4h]
  _DWORD *v185; // [xsp+40h] [xbp-D0h]
  unsigned int v186; // [xsp+40h] [xbp-D0h]
  int v187; // [xsp+60h] [xbp-B0h] BYREF
  unsigned int v188; // [xsp+64h] [xbp-ACh] BYREF
  __int64 v189; // [xsp+68h] [xbp-A8h] BYREF
  unsigned int v190; // [xsp+74h] [xbp-9Ch] BYREF
  char v191[16]; // [xsp+78h] [xbp-98h] BYREF
  _QWORD v192[7]; // [xsp+88h] [xbp-88h] BYREF

  v3 = a2;
  v192[6] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  *a2 = 0;
  v6 = a1 + 8;
  v5 = *(_QWORD *)(a1 + 8);
  v8 = FLAC__crc16_table[*(unsigned __int8 *)(v5 + 4036)];
  FLAC__bitreader_reset_read_crc16(
    *(_QWORD *)(v5 + 112),
    FLAC__crc16_table[*(unsigned __int8 *)(v5 + 4037) ^ (v8 >> 8)] ^ ((_WORD)v8 << 8));
  v9 = *(_QWORD *)v6;
  v191[0] = *(_BYTE *)(*(_QWORD *)v6 + 4036LL);
  v10 = *(unsigned __int8 *)(v9 + 4037);
  v188 = 2;
  v191[1] = v10;
  if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v9 + 112), &v190, 8u) )
    return 0;
  if ( v190 == 255 )
    goto LABEL_5;
  v188 = 3;
  v191[2] = v190;
  if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)v6 + 112LL), &v190, 8u) )
    return 0;
  if ( v190 == 255 )
  {
LABEL_5:
    v11 = *(_QWORD *)v6;
    v12 = *(_DWORD *)(*(_QWORD *)v6 + 4112LL);
    *(_BYTE *)(v11 + 4038) = -1;
    *(_DWORD *)(v11 + 3968) = 1;
    if ( v12 )
      goto LABEL_7;
    goto LABEL_6;
  }
  v15 = v188;
  v191[v188] = v190;
  v16 = v191[2];
  v188 = v15 + 1;
  v190 = (unsigned __int8)v191[2] >> 4;
  if ( (v191[2] & 0x80) == 0 )
    __asm { BR              X12 }
  *(_DWORD *)(*(_QWORD *)v6 + 1360LL) = 256 << (((unsigned __int8)v191[2] >> 4) - 8);
  v17 = (v10 >> 1) & 1;
  v18 = v16 & 0xF;
  v190 = v18;
  switch ( v16 & 0xF )
  {
    case 0:
      v19 = *(_QWORD *)v6;
      if ( *(_DWORD *)(*(_QWORD *)v6 + 464LL) )
      {
        v20 = *(_DWORD *)(v19 + 504);
        v18 = 0;
        goto LABEL_30;
      }
      v18 = 0;
      v17 = 1;
      v22 = (unsigned __int8)v191[3];
      v23 = (unsigned __int8)v191[3] >> 4;
      v190 = v23;
      if ( (v191[3] & 0x80) == 0 )
        goto LABEL_32;
      goto LABEL_34;
    case 1:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 88200;
      goto LABEL_30;
    case 2:
      v19 = *(_QWORD *)v6;
      v21 = -20208;
      goto LABEL_29;
    case 3:
      v19 = *(_QWORD *)v6;
      v21 = -4608;
LABEL_29:
      v18 = 0;
      v20 = v21 | 0x20000;
      goto LABEL_30;
    case 4:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 8000;
      goto LABEL_30;
    case 5:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 16000;
      goto LABEL_30;
    case 6:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 22050;
      goto LABEL_30;
    case 7:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 24000;
      goto LABEL_30;
    case 8:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 32000;
      goto LABEL_30;
    case 9:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 44100;
      goto LABEL_30;
    case 0xA:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 48000;
      goto LABEL_30;
    case 0xB:
      v19 = *(_QWORD *)v6;
      v18 = 0;
      v20 = 96000;
LABEL_30:
      *(_DWORD *)(v19 + 1364) = v20;
      goto LABEL_31;
    case 0xF:
      v11 = *(_QWORD *)v6;
      goto LABEL_251;
    default:
LABEL_31:
      v22 = (unsigned __int8)v191[3];
      v23 = (unsigned __int8)v191[3] >> 4;
      v190 = v23;
      if ( (v191[3] & 0x80) == 0 )
      {
LABEL_32:
        v24 = *(_QWORD *)v6;
        v25 = 0;
        *(_DWORD *)(*(_QWORD *)v6 + 1368LL) = v23 + 1;
LABEL_39:
        *(_DWORD *)(v24 + 1372) = v25;
        goto LABEL_40;
      }
LABEL_34:
      v24 = *(_QWORD *)v6;
      v26 = (v22 >> 4) & 7;
      *(_DWORD *)(*(_QWORD *)v6 + 1368LL) = 2;
      v25 = 1;
      switch ( v26 )
      {
        case 0:
          goto LABEL_39;
        case 2:
          v25 = 3;
          goto LABEL_39;
        case 1:
          v25 = 2;
          goto LABEL_39;
      }
      v17 = 1;
LABEL_40:
      v27 = 1;
      v190 = (v22 >> 1) & 7;
      switch ( v190 )
      {
        case 0u:
          if ( *(_DWORD *)(v24 + 464) )
          {
            v28 = *(_DWORD *)(v24 + 512);
            goto LABEL_49;
          }
          v27 = 1;
          if ( (v191[1] & 1) == 0 )
            goto LABEL_51;
          goto LABEL_57;
        case 1u:
          v28 = 8;
          goto LABEL_49;
        case 2u:
          v28 = 12;
          goto LABEL_49;
        case 4u:
          v28 = 16;
          goto LABEL_49;
        case 5u:
          v28 = 20;
          goto LABEL_49;
        case 6u:
          v28 = 24;
LABEL_49:
          v27 = v17;
          *(_DWORD *)(v24 + 1376) = v28;
          break;
        default:
          break;
      }
      if ( (v191[1] & 1) != 0 )
        goto LABEL_57;
LABEL_51:
      if ( !*(_DWORD *)(v24 + 464) || *(_DWORD *)(v24 + 488) == *(_DWORD *)(v24 + 492) )
      {
        result = (_QWORD *)FLAC__bitreader_read_utf8_uint32(*(_QWORD *)(v24 + 112), (int *)&v190, (__int64)v191, &v188);
        if ( !(_DWORD)result )
          return result;
        v29 = v190;
        if ( v190 != -1 )
        {
          v30 = *(_QWORD *)v6;
          *(_DWORD *)(v30 + 1380) = 0;
          *(_DWORD *)(v30 + 1384) = v29;
          v31 = *(_QWORD *)v6;
          goto LABEL_60;
        }
LABEL_64:
        v11 = *(_QWORD *)v6;
        v37 = v191[v188 - 1];
        v38 = *(_DWORD *)(*(_QWORD *)v6 + 4112LL);
        *(_DWORD *)(v11 + 3968) = 1;
        *(_BYTE *)(v11 + 4038) = v37;
        if ( v38 )
          goto LABEL_7;
        goto LABEL_6;
      }
LABEL_57:
      result = (_QWORD *)FLAC__bitreader_read_utf8_uint64(*(_QWORD *)(v24 + 112), &v189, (__int64)v191, &v188);
      if ( !(_DWORD)result )
        return result;
      v32 = v189;
      if ( v189 == -1 )
        goto LABEL_64;
      v33 = *(_QWORD *)v6;
      *(_DWORD *)(v33 + 1380) = 1;
      *(_QWORD *)(v33 + 1384) = v32;
      v31 = *(_QWORD *)v6;
LABEL_60:
      if ( v18 )
      {
        result = (_QWORD *)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v31 + 112), &v190, 8u);
        if ( !(_DWORD)result )
          return result;
        v34 = v188;
        v35 = v190;
        ++v188;
        v191[v34] = v190;
        if ( v18 == 12 )
        {
          v36 = 1000 * v35;
        }
        else
        {
          result = (_QWORD *)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)v6 + 112LL), &v187, 8u);
          if ( !(_DWORD)result )
            return result;
          v39 = v187;
          v40 = v190;
          v41 = v188 + 1;
          v191[v188] = v187;
          v42 = v39 | (v40 << 8);
          v36 = 10 * v42;
          if ( v18 == 13 )
            v36 = v42;
          v188 = v41;
          v190 = v42;
        }
        v31 = *(_QWORD *)v6;
        *(_DWORD *)(*(_QWORD *)v6 + 1364LL) = v36;
      }
      result = (_QWORD *)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v31 + 112), &v190, 8u);
      if ( (_DWORD)result )
      {
        v43 = (unsigned __int8)v190;
        v44 = FLAC__crc8(v191, v188);
        v11 = *(_QWORD *)v6;
        if ( v44 == v43 )
        {
          v45 = *(_DWORD *)(v11 + 1380);
          *(_DWORD *)(v11 + 452) = 0;
          if ( !v45 )
          {
            v46 = *(unsigned int *)(v11 + 1384);
            v190 = *(_DWORD *)(v11 + 1384);
            v47 = *(unsigned int *)(v11 + 448);
            *(_DWORD *)(v11 + 1380) = 1;
            if ( !(_DWORD)v47 )
            {
              if ( *(_DWORD *)(v11 + 464) )
              {
                v174 = *(unsigned int *)(v11 + 488);
                if ( (_DWORD)v174 != *(_DWORD *)(v11 + 492) )
                  goto LABEL_305;
                *(_QWORD *)(v11 + 1384) = v174 * v46;
                *(_DWORD *)(*(_QWORD *)v6 + 452LL) = *(_DWORD *)(*(_QWORD *)v6 + 492LL);
                if ( (v22 & 1) == 0 )
                  goto LABEL_77;
                goto LABEL_304;
              }
              if ( !(_DWORD)v46 )
              {
                *(_QWORD *)(v11 + 1384) = 0;
                *(_DWORD *)(*(_QWORD *)v6 + 452LL) = *(_DWORD *)(*(_QWORD *)v6 + 1360LL);
                if ( (v22 & 1) == 0 )
                {
LABEL_77:
                  if ( !v27 )
                  {
                    if ( **(_DWORD **)a1 == 2 )
                      return (_QWORD *)(&dword_0 + 1);
                    goto LABEL_79;
                  }
                }
LABEL_304:
                v11 = *(_QWORD *)v6;
LABEL_305:
                if ( *(_DWORD *)(v11 + 4112) )
                  ++*(_DWORD *)(v11 + 6864);
                else
                  (*(void (__fastcall **)(__int64, __int64, _QWORD))(v11 + 64))(a1, 3, *(_QWORD *)(v11 + 96));
LABEL_7:
                v13 = *(int **)a1;
                *v13 = 2;
                if ( *v13 == 2 )
                  return (_QWORD *)(&dword_0 + 1);
LABEL_79:
                v48 = *(_QWORD *)v6;
                v49 = *(unsigned int *)(*(_QWORD *)v6 + 1360LL);
                v50 = *(unsigned int *)(*(_QWORD *)v6 + 1368LL);
                if ( *(_DWORD *)(*(_QWORD *)v6 + 440LL) < (unsigned int)v49
                  || *(_DWORD *)(v48 + 444) < (unsigned int)v50 )
                {
                  v51 = *(_QWORD *)(v48 + 120);
                  if ( v51 )
                  {
                    free((void *)(v51 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 120LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v52 = *(void **)(v48 + 4040);
                  if ( v52 )
                  {
                    free(v52);
                    *(_QWORD *)(*(_QWORD *)v6 + 184LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4040LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v53 = *(_QWORD *)(v48 + 128);
                  if ( v53 )
                  {
                    free((void *)(v53 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 128LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v54 = *(void **)(v48 + 4048);
                  if ( v54 )
                  {
                    free(v54);
                    *(_QWORD *)(*(_QWORD *)v6 + 192LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4048LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v55 = *(_QWORD *)(v48 + 136);
                  if ( v55 )
                  {
                    free((void *)(v55 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 136LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v56 = *(void **)(v48 + 4056);
                  if ( v56 )
                  {
                    free(v56);
                    *(_QWORD *)(*(_QWORD *)v6 + 200LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4056LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v57 = *(_QWORD *)(v48 + 144);
                  if ( v57 )
                  {
                    free((void *)(v57 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 144LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v58 = *(void **)(v48 + 4064);
                  if ( v58 )
                  {
                    free(v58);
                    *(_QWORD *)(*(_QWORD *)v6 + 208LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4064LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v59 = *(_QWORD *)(v48 + 152);
                  if ( v59 )
                  {
                    free((void *)(v59 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 152LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v60 = *(void **)(v48 + 4072);
                  if ( v60 )
                  {
                    free(v60);
                    *(_QWORD *)(*(_QWORD *)v6 + 216LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4072LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v61 = *(_QWORD *)(v48 + 160);
                  if ( v61 )
                  {
                    free((void *)(v61 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 160LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v62 = *(void **)(v48 + 4080);
                  if ( v62 )
                  {
                    free(v62);
                    *(_QWORD *)(*(_QWORD *)v6 + 224LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4080LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v63 = *(_QWORD *)(v48 + 168);
                  if ( v63 )
                  {
                    free((void *)(v63 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 168LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v64 = *(void **)(v48 + 4088);
                  if ( v64 )
                  {
                    free(v64);
                    *(_QWORD *)(*(_QWORD *)v6 + 232LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4088LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v65 = *(_QWORD *)(v48 + 176);
                  if ( v65 )
                  {
                    free((void *)(v65 - 16));
                    *(_QWORD *)(*(_QWORD *)v6 + 176LL) = 0;
                    v48 = *(_QWORD *)v6;
                  }
                  v66 = *(void **)(v48 + 4096);
                  if ( v66 )
                  {
                    free(v66);
                    *(_QWORD *)(*(_QWORD *)v6 + 240LL) = 0;
                    *(_QWORD *)(*(_QWORD *)v6 + 4096LL) = 0;
                  }
                  if ( (_DWORD)v50 )
                  {
                    v67 = 0;
                    while ( 1 )
                    {
                      result = malloc(4 * v49 + 16);
                      if ( !result )
                        break;
                      *result = 0;
                      result[1] = 0;
                      *(_QWORD *)(*(_QWORD *)v6 + 8 * v67 + 120) = result + 2;
                      result = FLAC__memory_alloc_aligned_int32_array(
                                 v49,
                                 (void **)(*(_QWORD *)v6 + 8 * v67 + 4040),
                                 (_QWORD *)(*(_QWORD *)v6 + 8 * v67 + 184));
                      if ( !(_DWORD)result )
                        break;
                      if ( ++v67 >= v50 )
                        goto LABEL_118;
                    }
                    v124 = *(int **)a1;
                    v125 = 8;
LABEL_230:
                    *v124 = v125;
                    return result;
                  }
LABEL_118:
                  v48 = *(_QWORD *)v6;
                  *(_DWORD *)(v48 + 444) = v50;
                  LODWORD(v50) = *(_DWORD *)(v48 + 1368);
                  *(_DWORD *)(v48 + 440) = v49;
                }
                if ( (_DWORD)v50 )
                {
                  v68 = 0;
                  while ( 1 )
                  {
                    v69 = *(_DWORD *)(v48 + 1372);
                    v70 = *(_DWORD *)(v48 + 1376);
                    if ( v69 == 3 )
                      goto LABEL_124;
                    if ( v69 != 2 )
                      break;
                    v71 = v68 == 0;
LABEL_126:
                    if ( v71 )
                      ++v70;
LABEL_128:
                    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v48 + 112), &v190, 8u) )
                      return 0;
                    v72 = v190;
                    v73 = v190 & 0xFE;
                    v190 = v73;
                    if ( (v72 & 1) != 0 )
                    {
                      if ( !(unsigned int)FLAC__bitreader_read_unary_unsigned(*(_QWORD *)(*(_QWORD *)v6 + 112LL), v191) )
                        return 0;
                      v74 = *(_QWORD *)v6;
                      v75 = v70 >= *(_DWORD *)v191 + 1;
                      v70 -= *(_DWORD *)v191 + 1;
                      *(_DWORD *)(*(_QWORD *)v6 + 320 * v68 + 1712) = *(_DWORD *)v191 + 1;
                      if ( v70 == 0 || !v75 )
                        return 0;
                      v73 = v190;
                      if ( (v190 & 0x80) != 0 )
                      {
LABEL_134:
                        if ( !*(_DWORD *)(v74 + 4112) )
                          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(v74 + 64))(a1, 0, *(_QWORD *)(v74 + 96));
                        goto LABEL_179;
                      }
                    }
                    else
                    {
                      v74 = *(_QWORD *)v6;
                      *(_DWORD *)(*(_QWORD *)v6 + 320 * v68 + 1712) = 0;
                      if ( (v73 & 0x80) != 0 )
                        goto LABEL_134;
                    }
                    if ( v73 == 2 )
                    {
                      v86 = *(_QWORD *)(v74 + 8 * v68 + 184);
                      v87 = v74 + 1360 + 320 * v68;
                      *(_QWORD *)(v87 + 48) = v86;
                      v88 = (const void **)(v87 + 48);
                      *((_DWORD *)v88 - 2) = 1;
                      if ( *(_DWORD *)(v74 + 1360) )
                      {
                        v183 = a3;
                        v89 = 0;
                        while ( (unsigned int)FLAC__bitreader_read_raw_int32(*(_QWORD *)(v74 + 112), v191, v70) )
                        {
                          *(_DWORD *)(v86 + 4 * v89) = *(_DWORD *)v191;
                          v74 = *(_QWORD *)v6;
                          ++v89;
                          v90 = *(unsigned int *)(*(_QWORD *)v6 + 1360LL);
                          if ( v89 >= v90 )
                          {
                            a3 = v183;
                            v91 = 4 * v90;
                            if ( v183 )
                              goto LABEL_173;
                            goto LABEL_174;
                          }
                        }
                        return 0;
                      }
                      v91 = 0;
                      if ( a3 )
LABEL_173:
                        memcpy(*(void **)(v74 + 8 * v68 + 120), *v88, v91);
LABEL_174:
                      if ( !a3 )
                        goto LABEL_180;
                      goto LABEL_146;
                    }
                    if ( !v73 )
                    {
                      v76 = *(_DWORD **)(v74 + 8 * v68 + 120);
                      *(_DWORD *)(v74 + 320 * v68 + 1400) = 0;
                      if ( !(unsigned int)FLAC__bitreader_read_raw_int32(*(_QWORD *)(v74 + 112), v191, v70) )
                        return 0;
                      v77 = *(_DWORD *)v191;
                      *(_DWORD *)(v74 + 320 * v68 + 1408) = *(_DWORD *)v191;
                      if ( a3 )
                      {
                        v78 = *(_QWORD *)v6;
                        if ( *(_DWORD *)(*(_QWORD *)v6 + 1360LL) )
                        {
                          *v76 = v77;
                          if ( *(_DWORD *)(v78 + 1360) >= 2u )
                          {
                            v79 = 1;
                            do
                              v76[v79++] = *(_DWORD *)v191;
                            while ( v79 < *(unsigned int *)(v78 + 1360) );
                          }
                        }
                      }
                      if ( !a3 )
                        goto LABEL_180;
LABEL_146:
                      if ( (v72 & 1) != 0 )
                        goto LABEL_147;
                      goto LABEL_180;
                    }
                    if ( v73 <= 0xF )
                      goto LABEL_177;
                    if ( v73 > 0x18 )
                    {
                      if ( v73 > 0x3F )
                      {
                        v102 = v74 + 320 * v68;
                        *(_DWORD *)(v102 + 1400) = 3;
                        v103 = *(_QWORD *)(v74 + 8 * v68 + 184);
                        v104 = (v73 >> 1) & 0x1F;
                        v105 = (unsigned int)(v104 + 1);
                        *(_DWORD *)(v102 + 1432) = v105;
                        *(_QWORD *)(v102 + 1704) = v103;
                        v106 = *(_QWORD *)(v74 + 112);
                        v185 = v3;
                        v184 = a3;
                        v107 = 0;
                        v108 = v104;
                        v109 = v102 + 1572;
                        while ( (unsigned int)FLAC__bitreader_read_raw_int32(v106, v191, v70) )
                        {
                          *(_DWORD *)(v109 + 4 * v107++) = *(_DWORD *)v191;
                          v106 = *(_QWORD *)(*(_QWORD *)v6 + 112LL);
                          if ( v107 >= v105 )
                          {
                            if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(v106, &v189, 4u) )
                              return 0;
                            if ( (_DWORD)v189 != 15 )
                            {
                              v110 = v74 + 320 * v68;
                              *(_DWORD *)(v110 + 1436) = v189 + 1;
                              if ( !(unsigned int)FLAC__bitreader_read_raw_int32(
                                                    *(_QWORD *)(*(_QWORD *)v6 + 112LL),
                                                    v191,
                                                    5u) )
                                return 0;
                              if ( (*(_DWORD *)v191 & 0x80000000) == 0 )
                              {
                                v111 = v74 + 320 * v68;
                                *(_DWORD *)(v111 + 1440) = *(_DWORD *)v191;
                                v112 = 0;
                                v113 = *(_QWORD *)(*(_QWORD *)v6 + 112LL);
                                v182 = (unsigned int *)(v110 + 1436);
                                v114 = v111 + 1444;
                                v181 = (unsigned int *)(v111 + 1440);
                                while ( (unsigned int)FLAC__bitreader_read_raw_int32(v113, v191, *v182) )
                                {
                                  *(_DWORD *)(v114 + 4 * v112++) = *(_DWORD *)v191;
                                  v113 = *(_QWORD *)(*(_QWORD *)v6 + 112LL);
                                  if ( v112 >= v105 )
                                  {
                                    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(v113, &v189, 2u) )
                                      return 0;
                                    v115 = v189;
                                    v116 = v74 + 320 * v68;
                                    *(_DWORD *)(v116 + 1408) = v189;
                                    v117 = *(_QWORD *)v6;
                                    if ( v115 > 1 )
                                    {
                                      if ( *(_DWORD *)(v117 + 4112) )
                                        ++*(_DWORD *)(v117 + 6864);
                                      else
                                        (*(void (__fastcall **)(__int64, __int64, _QWORD))(v117 + 64))(
                                          a1,
                                          3,
                                          *(_QWORD *)(v117 + 96));
                                      a3 = v184;
                                      v3 = v185;
                                      **(_DWORD **)a1 = 2;
                                      if ( v184 )
                                        goto LABEL_218;
                                      goto LABEL_180;
                                    }
                                    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(
                                                          *(_QWORD *)(v117 + 112),
                                                          &v189,
                                                          4u) )
                                      return 0;
                                    v100 = *(_QWORD *)v6;
                                    v118 = v189;
                                    if ( *(_DWORD *)(*(_QWORD *)v6 + 1360LL) >> v189 <= v108 )
                                      goto LABEL_168;
                                    v119 = v74 + 320 * v68;
                                    *(_DWORD *)(v119 + 1416) = v189;
                                    *(_QWORD *)(v119 + 1424) = *(_QWORD *)v6 + 24 * v68 + 248;
                                    v120 = *(_DWORD *)(v116 + 1408);
                                    if ( v120 < 2
                                      && !(unsigned int)sub_2D034(
                                                          a1,
                                                          v105,
                                                          v118,
                                                          (_QWORD *)(*(_QWORD *)(a1 + 8) + 24 * v68 + 248),
                                                          *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v68 + 184),
                                                          v120 == 1) )
                                    {
                                      return 0;
                                    }
                                    a3 = v184;
                                    v3 = v185;
                                    if ( !v184 )
                                      goto LABEL_217;
                                    memcpy(
                                      *(void **)(*(_QWORD *)v6 + 8 * v68 + 120),
                                      (const void *)(v74 + 320 * v68 + 1572),
                                      (unsigned int)(4 * v105));
                                    if ( (__clz(v105) ^ 0x1F) + v70 + *v182 > 0x20 )
                                    {
                                      (*(void (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD, _QWORD, unsigned __int64))(*(_QWORD *)v6 + 80LL))(
                                        *(_QWORD *)(*(_QWORD *)v6 + 8 * v68 + 184),
                                        (unsigned int)(*(_DWORD *)(*(_QWORD *)v6 + 1360LL) - v105),
                                        v74 + 320 * v68 + 1444,
                                        (unsigned int)v105,
                                        *v181,
                                        *(_QWORD *)(*(_QWORD *)v6 + 8 * v68 + 120) + 4 * v105);
                                    }
                                    else
                                    {
                                      v121 = *(_QWORD *)v6;
                                      if ( v70 > 0x10 || *v182 > 0x10 )
                                        (*(void (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD, _QWORD, unsigned __int64))(v121 + 72))(
                                          *(_QWORD *)(v121 + 8 * v68 + 184),
                                          (unsigned int)(*(_DWORD *)(v121 + 1360) - v105),
                                          v74 + 320 * v68 + 1444,
                                          (unsigned int)v105,
                                          *v181,
                                          *(_QWORD *)(v121 + 8 * v68 + 120) + 4 * v105);
                                      else
                                        (*(void (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD, _QWORD, unsigned __int64))(v121 + 88))(
                                          *(_QWORD *)(v121 + 8 * v68 + 184),
                                          (unsigned int)(*(_DWORD *)(v121 + 1360) - v105),
                                          v74 + 320 * v68 + 1444,
                                          (unsigned int)v105,
                                          *v181,
                                          *(_QWORD *)(v121 + 8 * v68 + 120) + 4 * v105);
                                      a3 = v184;
                                      v3 = v185;
                                    }
                                    goto LABEL_218;
                                  }
                                }
                                return 0;
                              }
                            }
                            if ( !*(_DWORD *)(*(_QWORD *)v6 + 4112LL) )
                              (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v6 + 64LL))(
                                a1,
                                0,
                                *(_QWORD *)(*(_QWORD *)v6 + 96LL));
                            **(_DWORD **)a1 = 2;
                            a3 = v184;
                            v3 = v185;
                            if ( v184 )
                              goto LABEL_218;
                            goto LABEL_180;
                          }
                        }
                        return 0;
                      }
LABEL_177:
                      if ( *(_DWORD *)(v74 + 4112) )
                        ++*(_DWORD *)(v74 + 6864);
                      else
                        (*(void (__fastcall **)(__int64, __int64, _QWORD))(v74 + 64))(a1, 3, *(_QWORD *)(v74 + 96));
LABEL_179:
                      **(_DWORD **)a1 = 2;
                      goto LABEL_180;
                    }
                    v92 = v74 + 320 * v68;
                    *(_DWORD *)(v92 + 1400) = 2;
                    v93 = *(_QWORD *)(v74 + 8 * v68 + 184);
                    v94 = (v73 >> 1) & 7;
                    *(_DWORD *)(v92 + 1432) = v94;
                    *(_QWORD *)(v92 + 1456) = v93;
                    v95 = *(_QWORD *)(v74 + 112);
                    v185 = v3;
                    v184 = a3;
                    if ( (_DWORD)v94 )
                    {
                      v96 = 0;
                      while ( (unsigned int)FLAC__bitreader_read_raw_int32(v95, v191, v70) )
                      {
                        *(_DWORD *)(v74 + 320 * v68 + 1436 + 4 * v96++) = *(_DWORD *)v191;
                        v95 = *(_QWORD *)(*(_QWORD *)v6 + 112LL);
                        if ( v96 >= v94 )
                          goto LABEL_164;
                      }
                      return 0;
                    }
LABEL_164:
                    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(v95, &v189, 2u) )
                      return 0;
                    v97 = v189;
                    v98 = v74 + 320 * v68;
                    *(_DWORD *)(v98 + 1408) = v189;
                    v99 = *(_QWORD *)v6;
                    if ( v97 > 1 )
                    {
                      if ( *(_DWORD *)(v99 + 4112) )
                        ++*(_DWORD *)(v99 + 6864);
                      else
                        (*(void (__fastcall **)(__int64, __int64, _QWORD))(v99 + 64))(a1, 3, *(_QWORD *)(v99 + 96));
                      **(_DWORD **)a1 = 2;
LABEL_217:
                      if ( !a3 )
                        goto LABEL_180;
                      goto LABEL_218;
                    }
                    if ( !(unsigned int)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(v99 + 112), &v189, 4u) )
                      return 0;
                    v100 = *(_QWORD *)v6;
                    v101 = v189;
                    if ( *(_DWORD *)(*(_QWORD *)v6 + 1360LL) >> v189 >= (unsigned int)v94 )
                    {
                      v122 = v74 + 320 * v68;
                      *(_DWORD *)(v122 + 1416) = v189;
                      *(_QWORD *)(v122 + 1424) = *(_QWORD *)v6 + 24 * v68 + 248;
                      v123 = *(_DWORD *)(v98 + 1408);
                      if ( v123 < 2
                        && !(unsigned int)sub_2D034(
                                            a1,
                                            v94,
                                            v101,
                                            (_QWORD *)(*(_QWORD *)(a1 + 8) + 24 * v68 + 248),
                                            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v68 + 184),
                                            v123 == 1) )
                      {
                        return 0;
                      }
                      if ( !a3 )
                        goto LABEL_217;
                      memcpy(
                        *(void **)(*(_QWORD *)v6 + 8 * v68 + 120),
                        (const void *)(v74 + 320 * v68 + 1436),
                        (unsigned int)(4 * v94));
                      FLAC__fixed_restore_signal(
                        *(int **)(*(_QWORD *)v6 + 8 * v68 + 184),
                        *(_DWORD *)(*(_QWORD *)v6 + 1360LL) - v94,
                        v94,
                        (int *)(*(_QWORD *)(*(_QWORD *)v6 + 8 * v68 + 120) + 4LL * (unsigned int)v94));
                    }
                    else
                    {
LABEL_168:
                      v3 = v185;
                      if ( !*(_DWORD *)(v100 + 4112) )
                        (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(v100 + 64))(a1, 0, *(_QWORD *)(v100 + 96));
                      a3 = v184;
                      **(_DWORD **)a1 = 2;
                      if ( !v184 )
                        goto LABEL_180;
                    }
LABEL_218:
                    if ( (v72 & 1) != 0 && **(_DWORD **)a1 != 2 )
                    {
LABEL_147:
                      v80 = *(_QWORD *)v6;
                      v81 = *(_DWORD *)(*(_QWORD *)v6 + 1360LL + 320 * v68 + 352);
                      v190 = v81;
                      if ( *(_DWORD *)(v80 + 1360) )
                      {
                        v82 = *(_DWORD **)(v80 + 8 * v68 + 120);
                        *v82 <<= v81;
                        if ( *(_DWORD *)(v80 + 1360) >= 2u )
                        {
                          v83 = 1;
                          do
                          {
                            v84 = v83;
                            v85 = v82[v83++];
                            v82[v84] = v85 << v190;
                          }
                          while ( v83 < *(unsigned int *)(v80 + 1360) );
                        }
                      }
                    }
LABEL_180:
                    if ( **(_DWORD **)a1 == 2 )
                      return (_QWORD *)(&dword_0 + 1);
                    v48 = *(_QWORD *)v6;
                    if ( ++v68 >= (unsigned __int64)*(unsigned int *)(*(_QWORD *)v6 + 1368LL) )
                      goto LABEL_231;
                  }
                  if ( v69 != 1 )
                    goto LABEL_128;
LABEL_124:
                  v71 = v68 == 1;
                  goto LABEL_126;
                }
LABEL_231:
                if ( FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(v48 + 112)) )
                  goto LABEL_232;
                *(_DWORD *)v191 = 0;
                v135 = *(_QWORD *)(*(_QWORD *)v6 + 112LL);
                v136 = FLAC__bitreader_bits_left_for_byte_alignment(v135);
                result = (_QWORD *)FLAC__bitreader_read_raw_uint32(v135, v191, v136);
                if ( !(_DWORD)result )
                  return result;
                if ( !*(_DWORD *)v191 )
                {
LABEL_232:
                  if ( **(_DWORD **)a1 == 2 )
                    return (_QWORD *)(&dword_0 + 1);
                }
                else
                {
                  if ( !*(_DWORD *)(*(_QWORD *)v6 + 4112LL) )
                    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v6 + 64LL))(
                      a1,
                      0,
                      *(_QWORD *)(*(_QWORD *)v6 + 96LL));
                  **(_DWORD **)a1 = 2;
                  if ( **(_DWORD **)a1 == 2 )
                    return (_QWORD *)(&dword_0 + 1);
                }
                crc16 = FLAC__bitreader_get_read_crc16(*(__int64 **)(*(_QWORD *)v6 + 112LL));
                result = (_QWORD *)FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)v6 + 112LL), &v189, 0x10u);
                if ( !(_DWORD)result )
                  return result;
                if ( (_DWORD)v189 == crc16 )
                {
                  if ( a3 )
                  {
                    v127 = *(_QWORD *)v6;
                    v128 = *(_DWORD *)(*(_QWORD *)v6 + 1372LL);
                    if ( v128 == 3 )
                    {
                      if ( *(_DWORD *)(v127 + 1360) )
                      {
                        v161 = *(_QWORD *)(v127 + 120);
                        v162 = *(_QWORD *)(v127 + 128);
                        v163 = 0;
                        do
                        {
                          v164 = 4 * v163;
                          v165 = *(_DWORD *)(v162 + 4 * v163);
                          v166 = *(_DWORD *)(v161 + 4 * v163++);
                          v167 = v165 & 1 | (2 * v166);
                          *(_DWORD *)(v161 + v164) = (v167 + v165) >> 1;
                          *(_DWORD *)(v162 + v164) = (v167 - v165) >> 1;
                        }
                        while ( v163 < *(unsigned int *)(v127 + 1360) );
                      }
                    }
                    else if ( v128 == 2 )
                    {
                      if ( *(_DWORD *)(v127 + 1360) )
                      {
                        v168 = *(_QWORD *)(v127 + 120);
                        v169 = *(_QWORD *)(v127 + 128);
                        v170 = 0;
                        do
                        {
                          v171 = 4 * v170;
                          v172 = *(_DWORD *)(v169 + 4 * v170);
                          v173 = *(_DWORD *)(v168 + 4 * v170++);
                          *(_DWORD *)(v168 + v171) = v173 + v172;
                        }
                        while ( v170 < *(unsigned int *)(v127 + 1360) );
                      }
                    }
                    else if ( v128 == 1 && *(_DWORD *)(v127 + 1360) )
                    {
                      v129 = *(_QWORD *)(v127 + 120);
                      v130 = *(_QWORD *)(v127 + 128);
                      v131 = 0;
                      do
                      {
                        v132 = 4 * v131;
                        v133 = *(_DWORD *)(v129 + 4 * v131);
                        v134 = *(_DWORD *)(v130 + 4 * v131++);
                        *(_DWORD *)(v130 + v132) = v133 - v134;
                      }
                      while ( v131 < *(unsigned int *)(v127 + 1360) );
                    }
                  }
                }
                else
                {
                  if ( !*(_DWORD *)(*(_QWORD *)v6 + 4112LL) )
                    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 64LL))(
                      a1,
                      2,
                      *(_QWORD *)(*(_QWORD *)v6 + 96LL));
                  if ( a3 )
                  {
                    v137 = *(_QWORD *)v6;
                    if ( *(_DWORD *)(*(_QWORD *)v6 + 1368LL) )
                    {
                      v138 = 0;
                      do
                      {
                        memset(*(void **)(v137 + 8 * v138 + 120), 0, 4LL * *(unsigned int *)(v137 + 1360));
                        v137 = *(_QWORD *)v6;
                        ++v138;
                      }
                      while ( v138 < *(unsigned int *)(*(_QWORD *)v6 + 1368LL) );
                    }
                  }
                }
                *v3 = 1;
                v139 = *(_QWORD *)v6;
                v140 = *(_DWORD *)(*(_QWORD *)v6 + 452LL);
                if ( v140 )
                  *(_DWORD *)(v139 + 448) = v140;
                v141 = *(int **)a1;
                v142 = *(_QWORD *)(v139 + 1368);
                *((_QWORD *)v141 + 1) = v142;
                v143 = *(_DWORD *)(v139 + 1376);
                v141[4] = v143;
                v141[5] = *(_DWORD *)(v139 + 1364);
                v144 = *(unsigned int *)(v139 + 1360);
                v141[6] = v144;
                v145 = *(_QWORD *)(v139 + 1384);
                v146 = v145 + v144;
                *(_QWORD *)(v139 + 456) = v145 + v144;
                if ( a3 )
                {
                  v147 = v139 + 1360;
                  v148 = v139 + 120;
                  if ( *(_DWORD *)(v139 + 4112) )
                  {
                    v149 = *(_QWORD *)(v139 + 6856);
                    v186 = v142;
                    memcpy((void *)(v139 + 4240), (const void *)(v139 + 1360), 0xA30u);
                    v150 = v149 - v145;
                    if ( v149 < v145 || v149 >= v146 )
                      goto LABEL_292;
                    v151 = *(_QWORD *)v6;
                    *(_DWORD *)(*(_QWORD *)v6 + 4112LL) = 0;
                    if ( v150 )
                    {
                      v152 = (unsigned int)(v149 - v145);
                      if ( !v186 )
                        goto LABEL_273;
                      if ( v186 >= 4
                        && (v139 + 8 * (unsigned __int64)v186 + 112 <= (unsigned __int64)v191
                         || v139 + 120 >= (unsigned __int64)&v191[8 * v186 - 8]) )
                      {
                        v153 = v186 & 0xFFFFFFFC;
                        v175 = (int64x2_t *)(v139 + 136);
                        v176 = (int64x2_t *)v192;
                        v177 = vshlq_n_s64(vdupq_n_s64(v152), 2u);
                        v178 = v153;
                        do
                        {
                          v179 = v175[-1];
                          v180 = *v175;
                          v175 += 2;
                          v178 -= 4;
                          v176[-1] = vaddq_s64(v179, v177);
                          *v176 = vaddq_s64(v180, v177);
                          v176 += 2;
                        }
                        while ( v178 );
                        if ( v153 == v186 )
                        {
LABEL_273:
                          v159 = *(_QWORD *)(v151 + 4264);
                          *(_DWORD *)(v151 + 4240) -= v150;
                          *(_QWORD *)(v151 + 4264) = v159 + v152;
                          if ( !(*(unsigned int (__fastcall **)(__int64, __int64, char *, _QWORD))(*(_QWORD *)(a1 + 8)
                                                                                                 + 48LL))(
                                  a1,
                                  *(_QWORD *)(a1 + 8) + 4240LL,
                                  v191,
                                  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 96LL)) )
                            goto LABEL_292;
LABEL_291:
                          v124 = *(int **)a1;
                          v125 = 7;
                          result = 0;
                          goto LABEL_230;
                        }
                      }
                      else
                      {
                        v153 = 0;
                      }
                      v154 = 8 * v153;
                      v155 = v186 - v153;
                      v156 = (__int64 *)(v139 + 8 * v153 + 120);
                      v157 = &v191[v154];
                      do
                      {
                        v158 = *v156++;
                        --v155;
                        *(_QWORD *)v157 = v158 + 4 * v152;
                        v157 += 8;
                      }
                      while ( v155 );
                      goto LABEL_273;
                    }
                    v160 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(v151 + 48))(
                             a1,
                             v147,
                             v148,
                             *(_QWORD *)(v151 + 96));
                  }
                  else
                  {
                    if ( *(_DWORD *)(v139 + 464) )
                    {
                      if ( *(_DWORD *)(v139 + 4104) )
                      {
                        if ( !(unsigned int)FLAC__MD5Accumulate(
                                              v139 + 4120,
                                              (int32x4_t **)(v139 + 120),
                                              v142,
                                              v144,
                                              (unsigned int)(v143 + 7) >> 3) )
                          goto LABEL_291;
                        v139 = *(_QWORD *)v6;
                      }
                    }
                    else
                    {
                      *(_DWORD *)(v139 + 4104) = 0;
                    }
                    v160 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(v139 + 48))(
                             a1,
                             v147,
                             v148,
                             *(_QWORD *)(v139 + 96));
                  }
                  if ( v160 )
                    goto LABEL_291;
                }
LABEL_292:
                **(_DWORD **)a1 = 2;
                return (_QWORD *)(&dword_0 + 1);
              }
              v47 = *(unsigned int *)(v11 + 1360);
            }
            *(_QWORD *)(v11 + 1384) = v47 * v46;
          }
          if ( (v22 & 1) == 0 )
            goto LABEL_77;
          goto LABEL_304;
        }
LABEL_251:
        if ( *(_DWORD *)(v11 + 4112) )
          goto LABEL_7;
LABEL_6:
        (*(void (__fastcall **)(__int64, __int64, _QWORD))(v11 + 64))(a1, 1, *(_QWORD *)(v11 + 96));
        goto LABEL_7;
      }
      return result;
  }
}
// 2BE34: conditional instruction was optimized away because %var_D4.4!=0
// 2BDE4: conditional instruction was optimized away because %var_D4.4!=0
// 0: using guessed type int dword_0;
// 60218: using guessed type unsigned __int16 FLAC__crc16_table[2048];

//----- (000000000002C334) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_metadata(_DWORD **a1)
{
  __int64 result; // x0

  while ( 2 )
  {
    result = 1;
    switch ( **a1 )
    {
      case 0:
        result = sub_29870((__int64)a1);
        if ( (_DWORD)result )
          continue;
        break;
      case 1:
        result = sub_29B48((__int64)a1);
        if ( (_DWORD)result )
          continue;
        break;
      case 2:
      case 3:
      case 4:
      case 7:
        return result;
      default:
        result = 0;
        break;
    }
    break;
  }
  return result;
}

//----- (000000000002C3A4) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_process_until_end_of_stream(_DWORD **a1)
{
  __int64 result; // x0
  int v3; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v4; // [xsp+8h] [xbp-28h]

  v4 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  while ( 2 )
  {
    result = 1;
    switch ( **a1 )
    {
      case 0:
        result = sub_29870((__int64)a1);
        if ( (_DWORD)result )
          continue;
        break;
      case 1:
        result = sub_29B48((__int64)a1);
        if ( (_DWORD)result )
          continue;
        break;
      case 2:
        if ( (unsigned int)sub_2AB54((__int64)a1) )
          continue;
        result = 1;
        break;
      case 3:
        result = (__int64)sub_2ACF8((__int64)a1, &v3, 1);
        if ( (_DWORD)result )
          continue;
        break;
      case 4:
      case 7:
        return result;
      default:
        result = 0;
        break;
    }
    break;
  }
  return result;
}

//----- (000000000002C478) ----------------------------------------------------
_QWORD *__fastcall FLAC__stream_decoder_skip_single_frame(_DWORD **a1)
{
  _QWORD *result; // x0
  int v3; // [xsp+4h] [xbp-2Ch] BYREF
  __int64 v4; // [xsp+8h] [xbp-28h]

  v4 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  while ( 2 )
  {
    result = 0;
    switch ( **a1 )
    {
      case 2:
        if ( (unsigned int)sub_2AB54((__int64)a1) )
          continue;
        return (_QWORD *)(&dword_0 + 1);
      case 3:
        result = sub_2ACF8((__int64)a1, &v3, 0);
        if ( !(_DWORD)result )
          return result;
        if ( !v3 )
          continue;
        return (_QWORD *)(&dword_0 + 1);
      case 4:
      case 7:
        return (_QWORD *)(&dword_0 + 1);
      default:
        return result;
    }
  }
}
// 0: using guessed type int dword_0;

//----- (000000000002C520) ----------------------------------------------------
__int64 __fastcall FLAC__stream_decoder_seek_absolute(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // x8
  __int64 result; // x0
  unsigned int (__fastcall *v6)(__int64, unsigned __int64 *, __int64); // x9
  __int64 v7; // x2
  unsigned int *v8; // x8
  unsigned int v9; // w9
  __int64 v10; // x11
  int v11; // w12
  signed __int64 v12; // x10
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x15
  int v15; // w13
  int v16; // w12
  int v17; // w0
  unsigned int v18; // w18
  unsigned int v19; // w17
  int *v20; // x14
  unsigned int v21; // w1
  unsigned __int64 v22; // x12
  __int64 v23; // x13
  __int64 v24; // x14
  unsigned __int64 v25; // x15
  __int64 v26; // x17
  _DWORD *v27; // x18
  unsigned __int64 v28; // x23
  unsigned __int64 v29; // x17
  unsigned __int64 v30; // x14
  unsigned __int64 v31; // x13
  __int64 v32; // x18
  unsigned __int64 v33; // x0
  unsigned __int64 v34; // x17
  char v35; // w8
  __int64 v36; // x11
  unsigned __int64 v37; // x15
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x18
  unsigned __int64 v40; // x8
  unsigned __int64 v41; // x13
  signed __int64 v42; // x8
  __int64 v43; // x21
  unsigned __int64 v44; // x25
  unsigned __int64 v45; // x24
  __int64 v46; // x8
  __int64 v47; // x0
  int v48; // w9
  unsigned int v49; // w8
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x13
  signed __int64 v52; // x8
  unsigned __int64 v53; // x25
  unsigned __int64 v54; // x24
  __int64 v55; // x8
  __int64 v56; // x0
  int v57; // w9
  unsigned int v58; // w8
  unsigned __int64 v59; // x9
  unsigned __int64 v60; // x12
  unsigned int (__fastcall *v61)(__int64, unsigned __int64 *, _QWORD); // x8
  unsigned __int64 v62; // x24
  unsigned int v63; // w0
  unsigned __int64 v64; // x9
  unsigned int input_bits_unconsumed; // w0
  __int64 v66; // x11
  unsigned __int64 v67; // [xsp+8h] [xbp-88h]
  unsigned int v68; // [xsp+14h] [xbp-7Ch]
  unsigned int v69; // [xsp+14h] [xbp-7Ch]
  unsigned __int64 v70; // [xsp+18h] [xbp-78h] BYREF
  unsigned __int64 v71; // [xsp+20h] [xbp-70h] BYREF
  unsigned __int64 v72; // [xsp+28h] [xbp-68h] BYREF
  int v73; // [xsp+34h] [xbp-5Ch] BYREF
  __int64 v74; // [xsp+38h] [xbp-58h]

  v74 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( **(_DWORD **)a1 > 4u )
    return 0;
  v4 = *(_QWORD *)(a1 + 8);
  if ( !*(_QWORD *)(v4 + 16) || *(_DWORD *)(v4 + 464) && *(_QWORD *)(v4 + 520) - 1LL < a2 )
    return 0;
  v6 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, __int64))(v4 + 32);
  v7 = *(_QWORD *)(v4 + 96);
  *(_DWORD *)(v4 + 4112) = 1;
  *(_DWORD *)(v4 + 4104) = 0;
  if ( v6(a1, &v70, v7) )
  {
LABEL_7:
    result = 0;
    goto LABEL_156;
  }
  v8 = *(unsigned int **)a1;
  v9 = **(_DWORD **)a1;
  if ( v9 <= 1 )
  {
    while ( 2 )
    {
      switch ( v9 )
      {
        case 0u:
          if ( (unsigned int)sub_29870(a1) )
            goto LABEL_11;
          goto LABEL_7;
        case 1u:
          if ( !(unsigned int)sub_29B48(a1) )
            goto LABEL_7;
LABEL_11:
          v8 = *(unsigned int **)a1;
          v9 = **(_DWORD **)a1;
          if ( v9 > 7 )
            goto LABEL_7;
          continue;
        case 2u:
        case 3u:
        case 4u:
        case 7u:
          v10 = *(_QWORD *)(a1 + 8);
          v11 = *(_DWORD *)(v10 + 464);
          if ( !v11 || *(_QWORD *)(v10 + 520) - 1LL >= a2 )
            goto LABEL_16;
          result = 0;
          *(_DWORD *)(v10 + 4112) = 0;
          break;
        default:
          goto LABEL_7;
      }
      return result;
    }
  }
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_DWORD *)(v10 + 464);
LABEL_16:
  v12 = v70;
  v13 = *(_QWORD *)(v10 + 6848);
  if ( v11 )
    v14 = *(_QWORD *)(v10 + 520);
  else
    v14 = 0;
  v15 = *(_DWORD *)(v10 + 468);
  v16 = *(_DWORD *)(v10 + 488);
  v17 = *(_DWORD *)(v10 + 500);
  v18 = v8[2];
  v19 = v8[4];
  v20 = (int *)(v10 + 664);
  if ( !v15 )
    v20 = 0;
  if ( v18 )
  {
    if ( v19 )
      goto LABEL_23;
  }
  else
  {
    v18 = *(_DWORD *)(v10 + 508);
    if ( v19 )
    {
LABEL_23:
      if ( v17 )
        goto LABEL_24;
LABEL_31:
      if ( v16 && v16 == *(_DWORD *)(v10 + 492) )
      {
        v21 = ((v18 * v16 * v19) >> 3) + 64;
        if ( v14 )
          v22 = v14;
        else
          v22 = a2;
        v71 = v70;
        v72 = v13;
        if ( !v15 )
          goto LABEL_63;
      }
      else
      {
        v21 = (((v18 * v19) & 0xFFFFF) << 9) | 0x40;
        if ( v14 )
          v22 = v14;
        else
          v22 = a2;
        v71 = v70;
        v72 = v13;
        if ( !v15 )
          goto LABEL_63;
      }
      goto LABEL_45;
    }
  }
  v19 = *(_DWORD *)(v10 + 512);
  if ( !v17 )
    goto LABEL_31;
LABEL_24:
  v21 = ((unsigned int)(*(_DWORD *)(v10 + 496) + v17) >> 1) + 1;
  if ( v14 )
    v22 = v14;
  else
    v22 = a2;
  v71 = v70;
  v72 = v13;
  if ( !v15 )
    goto LABEL_63;
LABEL_45:
  v23 = *v20;
  if ( (int)v23 >= 1 )
  {
    v24 = *((_QWORD *)v20 + 1);
    v25 = v14 - 1;
    v26 = v23 + 1;
    v27 = (_DWORD *)(v24 + 24 * v23 - 8);
    while ( 1 )
    {
      v28 = *((_QWORD *)v27 - 2);
      if ( v28 != -1 && v28 <= a2 && v25 >= v28 && *v27 )
        break;
      --v26;
      v27 -= 6;
      if ( v26 <= 1 )
      {
        v28 = 0;
        v29 = v13;
        goto LABEL_56;
      }
    }
    v29 = *((_QWORD *)v27 - 1) + v13;
LABEL_56:
    v32 = 0;
    while ( 1 )
    {
      v33 = *(_QWORD *)v24;
      if ( *(_QWORD *)v24 != -1 && v33 > a2 && v25 >= v33 && *(_DWORD *)(v24 + 16) )
        break;
      ++v32;
      v24 += 24;
      if ( v32 >= v23 )
      {
        v30 = v70;
        v31 = v22;
        if ( v70 >= v29 )
          goto LABEL_54;
        goto LABEL_63;
      }
    }
    v31 = *(_QWORD *)v24;
    v30 = *(_QWORD *)(v24 + 8) + v13;
    if ( v30 < v29 )
      goto LABEL_63;
    goto LABEL_54;
  }
  v28 = 0;
  v29 = v13;
  v30 = v70;
  v31 = v22;
  if ( v70 >= v13 )
  {
LABEL_54:
    v12 = v30;
    v13 = v29;
    v22 = v31;
    v71 = v30;
    v72 = v29;
    goto LABEL_64;
  }
LABEL_63:
  v28 = 0;
LABEL_64:
  if ( v22 == v28 )
    ++v22;
  v34 = v22 - v28;
  *(_QWORD *)(v10 + 6856) = a2;
  if ( v22 <= v28 || (v67 = v22, v12 < v13) )
  {
LABEL_155:
    result = 0;
    *v8 = 6;
    goto LABEL_156;
  }
  v35 = 1;
LABEL_69:
  v36 = *(_QWORD *)(a1 + 8);
  v37 = a2 - v28;
  v38 = (a2 - v28) >> 8;
  v39 = v34 >> 16;
  if ( (v35 & 1) != 0 )
  {
    while ( 1 )
    {
      v40 = (v12 - v13) * v37;
      if ( v12 - v13 < 0xFFFFFFFF )
      {
        v41 = v34;
      }
      else
      {
        v40 = ((v12 - v13) >> 8) * v38;
        v41 = v39;
      }
      v42 = v40 / v41 + v13 - v21;
      if ( v42 >= v12 )
        v42 = v12 - 1;
      if ( v42 >= (__int64)v13 )
        v43 = v42;
      else
        v43 = v13;
      v68 = v21;
      v44 = v38;
      v45 = v34;
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(v36 + 16))(a1, v43, *(_QWORD *)(v36 + 96)) )
        goto LABEL_154;
      v46 = *(_QWORD *)(a1 + 8);
      if ( !*(_DWORD *)(v46 + 4108) && **(_DWORD **)a1 == 9 )
        goto LABEL_7;
      v47 = *(_QWORD *)(v46 + 112);
      *(_QWORD *)(v46 + 456) = 0;
      *(_DWORD *)(v46 + 4104) = 0;
      result = FLAC__bitreader_clear(v47);
      if ( (_DWORD)result )
        v48 = 2;
      else
        v48 = 8;
      **(_DWORD **)a1 = v48;
      if ( !(_DWORD)result )
        goto LABEL_156;
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 6864LL) = 0;
      v49 = 2;
      while ( 2 )
      {
        switch ( v49 )
        {
          case 0u:
            if ( !(unsigned int)sub_29870(a1) )
              goto LABEL_154;
            goto LABEL_90;
          case 1u:
            if ( !(unsigned int)sub_29B48(a1) )
              goto LABEL_154;
            goto LABEL_96;
          case 2u:
            if ( (unsigned int)sub_2AB54(a1) )
              goto LABEL_90;
            goto LABEL_96;
          case 3u:
            if ( !(unsigned int)sub_2ACF8(a1, &v73, 1) )
              goto LABEL_154;
            if ( v73 )
              goto LABEL_96;
LABEL_90:
            v49 = **(_DWORD **)a1;
            if ( v49 > 7 )
              goto LABEL_154;
            continue;
          case 4u:
          case 7u:
LABEL_96:
            v8 = *(unsigned int **)a1;
            if ( **(_DWORD **)a1 == 7 )
              goto LABEL_154;
            v36 = *(_QWORD *)(a1 + 8);
            if ( !*(_DWORD *)(v36 + 4112) )
              goto LABEL_159;
            if ( *(_QWORD *)(v36 + 456) )
            {
              v59 = *(_QWORD *)(v36 + 4264);
              v60 = v59 + *(unsigned int *)(v36 + 4240);
              goto LABEL_142;
            }
            v13 = v72;
            if ( v43 == v72 )
              goto LABEL_155;
            v12 = v71;
            v37 = a2 - v28;
            v38 = v44;
            v21 = v68 ? 2 * v68 : 16;
            v34 = v45;
            if ( v71 < v72 )
              goto LABEL_155;
            break;
          default:
            goto LABEL_154;
        }
        break;
      }
    }
  }
LABEL_105:
  v50 = (v12 - v13) * v37;
  if ( v12 - v13 < 0xFFFFFFFF )
  {
    v51 = v34;
  }
  else
  {
    v50 = ((v12 - v13) >> 8) * v38;
    v51 = v39;
  }
  v52 = v50 / v51 + v13 - v21;
  if ( v52 >= v12 )
    v52 = v12 - 1;
  if ( v52 >= (__int64)v13 )
    v43 = v52;
  else
    v43 = v13;
  v69 = v21;
  v53 = v38;
  v54 = v34;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(v36 + 16))(a1, v43, *(_QWORD *)(v36 + 96)) )
    goto LABEL_154;
  v55 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v55 + 4108) && **(_DWORD **)a1 == 9 )
    goto LABEL_7;
  v56 = *(_QWORD *)(v55 + 112);
  *(_QWORD *)(v55 + 456) = 0;
  *(_DWORD *)(v55 + 4104) = 0;
  result = FLAC__bitreader_clear(v56);
  if ( (_DWORD)result )
    v57 = 2;
  else
    v57 = 8;
  **(_DWORD **)a1 = v57;
  if ( !(_DWORD)result )
    goto LABEL_156;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 6864LL) = 0;
  v58 = 2;
  while ( 2 )
  {
    switch ( v58 )
    {
      case 0u:
        if ( !(unsigned int)sub_29870(a1) )
          goto LABEL_154;
        goto LABEL_125;
      case 1u:
        if ( (unsigned int)sub_29B48(a1) )
          goto LABEL_131;
        goto LABEL_154;
      case 2u:
        if ( (unsigned int)sub_2AB54(a1) )
          goto LABEL_125;
        goto LABEL_131;
      case 3u:
        if ( !(unsigned int)sub_2ACF8(a1, &v73, 1) )
          goto LABEL_154;
        if ( !v73 )
        {
LABEL_125:
          v58 = **(_DWORD **)a1;
          if ( v58 > 7 )
            goto LABEL_154;
          continue;
        }
LABEL_131:
        v8 = *(unsigned int **)a1;
        if ( **(_DWORD **)a1 == 7 )
          goto LABEL_154;
        v36 = *(_QWORD *)(a1 + 8);
        if ( *(_DWORD *)(v36 + 4112) )
        {
          if ( !*(_QWORD *)(v36 + 456)
            || (v59 = *(_QWORD *)(v36 + 4264), v60 = v59 + *(unsigned int *)(v36 + 4240), v60 >= v67) )
          {
            v13 = v72;
            if ( v43 == v72 )
              goto LABEL_155;
            v12 = v71;
            v37 = a2 - v28;
            v38 = v53;
            v21 = v69 ? 2 * v69 : 16;
            v34 = v54;
            if ( v71 < v72 )
              goto LABEL_155;
            goto LABEL_105;
          }
LABEL_142:
          if ( v59 < v28 )
            goto LABEL_155;
          v61 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(v36 + 24);
          if ( v59 <= a2 )
          {
            v28 = v60;
            if ( !v61
              || v61(a1, &v72, *(_QWORD *)(v36 + 96))
              || !FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL))
              || (input_bits_unconsumed = FLAC__bitreader_get_input_bits_unconsumed(*(_DWORD **)(*(_QWORD *)(a1 + 8)
                                                                                               + 112LL)),
                  v64 = v72 - (input_bits_unconsumed >> 3),
                  v72 = v64,
                  v34 = v67 - v28,
                  v67 <= v28) )
            {
LABEL_154:
              v8 = *(unsigned int **)a1;
              goto LABEL_155;
            }
          }
          else
          {
            v62 = v60;
            if ( !v61 )
              goto LABEL_154;
            if ( v61(a1, &v71, *(_QWORD *)(v36 + 96)) )
              goto LABEL_154;
            if ( !FLAC__bitreader_is_consumed_byte_aligned(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL)) )
              goto LABEL_154;
            v63 = FLAC__bitreader_get_input_bits_unconsumed(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 112LL));
            v64 = v71 - (v63 >> 3);
            v71 = v64;
            v34 = v62 - v28;
            v67 = v62;
            if ( v62 <= v28 )
              goto LABEL_154;
          }
          v66 = v64 - v43;
          v12 = v71;
          v13 = v72;
          v35 = 0;
          v21 = 2 * v66 / 3uLL + 16;
          if ( v71 < v72 )
            goto LABEL_154;
          goto LABEL_69;
        }
LABEL_159:
        result = 1;
LABEL_156:
        *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4112LL) = 0;
        return result;
      case 4u:
      case 7u:
        goto LABEL_131;
      default:
        goto LABEL_154;
    }
  }
}

//----- (000000000002CD14) ----------------------------------------------------
__int64 __fastcall get_client_data_from_decoder(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 96LL);
}

//----- (000000000002CD20) ----------------------------------------------------
__int64 __fastcall sub_2CD20(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v4; // x9
  unsigned int (__fastcall *v7)(__int64, _QWORD); // x8
  __int64 result; // x0
  int *v9; // x8
  int v10; // w9
  __int64 v11; // x8
  int v12; // w0
  __int64 v13; // x9
  unsigned int (__fastcall *v14)(__int64, _QWORD); // x8

  v4 = *(_QWORD *)(a3 + 8);
  v7 = *(unsigned int (__fastcall **)(__int64, _QWORD))(v4 + 40);
  if ( v7 && v7(a3, *(_QWORD *)(v4 + 96)) )
  {
    result = 0;
    *a2 = 0;
LABEL_4:
    v9 = *(int **)a3;
    v10 = 4;
LABEL_10:
    *v9 = v10;
    return result;
  }
  if ( !*a2
    || (v11 = *(_QWORD *)(a3 + 8), *(_DWORD *)(v11 + 4112)) && *(_DWORD *)(v11 + 6864) >= 0x15u
    || (v12 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *, _QWORD))(v11 + 8))(
                a3,
                a1,
                a2,
                *(_QWORD *)(v11 + 96)),
        v12 == 2) )
  {
    v9 = *(int **)a3;
    result = 0;
    v10 = 7;
    goto LABEL_10;
  }
  if ( *a2 )
    return 1;
  if ( v12 == 1 )
  {
LABEL_16:
    result = 0;
    goto LABEL_4;
  }
  v13 = *(_QWORD *)(a3 + 8);
  v14 = *(unsigned int (__fastcall **)(__int64, _QWORD))(v13 + 40);
  if ( !v14 )
    return 1;
  if ( v14(a3, *(_QWORD *)(v13 + 96)) )
    goto LABEL_16;
  return 1;
}

//----- (000000000002CE3C) ----------------------------------------------------
__int64 __fastcall sub_2CE3C(__int64 a1, void *a2, size_t *a3)
{
  size_t v4; // x2
  size_t v6; // x21

  v4 = *a3;
  if ( !v4 )
    return 2;
  v6 = fread(a2, 1u, v4, *(FILE **)(*(_QWORD *)(a1 + 8) + 104LL));
  *a3 = v6;
  if ( ferror(*(FILE **)(*(_QWORD *)(a1 + 8) + 104LL)) )
    return 2;
  else
    return v6 == 0;
}

//----- (000000000002CECC) ----------------------------------------------------
__int64 __fastcall sub_2CECC(__int64 a1, __off_t a2)
{
  FILE *v2; // x0

  v2 = *(FILE **)(*(_QWORD *)(a1 + 8) + 104LL);
  if ( v2 == (FILE *)&_sF )
    return 2;
  else
    return (unsigned int)fseeko(v2, a2, 0) >> 31;
}

//----- (000000000002CF08) ----------------------------------------------------
__int64 __fastcall sub_2CF08(__int64 a1, __off_t *a2)
{
  FILE *v3; // x0
  __off_t v4; // x8
  __int64 result; // x0

  v3 = *(FILE **)(*(_QWORD *)(a1 + 8) + 104LL);
  if ( v3 == (FILE *)&_sF )
    return 2;
  v4 = ftello(v3);
  if ( v4 < 0 )
    return 1;
  result = 0;
  *a2 = v4;
  return result;
}

//----- (000000000002CF70) ----------------------------------------------------
__int64 __fastcall sub_2CF70(__int64 a1, _QWORD *a2)
{
  FILE *v3; // x0
  int v4; // w0
  __int64 result; // x0
  _BYTE v6[48]; // [xsp+8h] [xbp-98h] BYREF
  __int64 v7; // [xsp+38h] [xbp-68h]
  __int64 v8; // [xsp+88h] [xbp-18h]

  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v3 = *(FILE **)(*(_QWORD *)(a1 + 8) + 104LL);
  if ( v3 == (FILE *)&_sF )
    return 2;
  v4 = fileno(v3);
  result = fstat(v4, (struct stat *)v6);
  if ( (_DWORD)result )
    return 1;
  *a2 = v7;
  return result;
}

//----- (000000000002D010) ----------------------------------------------------
bool __fastcall sub_2D010(__int64 a1)
{
  return feof(*(FILE **)(*(_QWORD *)(a1 + 8) + 104LL)) != 0;
}

//----- (000000000002D034) ----------------------------------------------------
__int64 __fastcall sub_2D034(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4, __int64 a5, int a6)
{
  unsigned int v10; // w8
  unsigned int v12; // w10
  unsigned int v13; // w8
  unsigned int v14; // w22
  int *v15; // x8
  int *v16; // x9
  unsigned int v17; // w23
  unsigned int v18; // w1
  __int64 result; // x0
  unsigned int v20; // w8
  __int64 v21; // x24
  unsigned int v22; // w27
  unsigned __int64 v23; // x28
  unsigned int v24; // w8
  unsigned int v25; // w26
  unsigned int v26; // w26
  unsigned __int64 v27; // x24
  unsigned int v28; // w25
  unsigned __int64 v29; // x26
  unsigned int v30; // w27
  unsigned int v31; // w9
  unsigned int v32; // [xsp+Ch] [xbp-64h]
  int v33; // [xsp+10h] [xbp-60h] BYREF
  unsigned int v34; // [xsp+14h] [xbp-5Ch] BYREF
  __int64 v35; // [xsp+18h] [xbp-58h]

  v35 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1360LL);
  v12 = v10 >> a3;
  v13 = v10 - a2;
  if ( a3 )
    v14 = v12;
  else
    v14 = v13;
  v15 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
  if ( a6 )
    v15 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
  v16 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
  v17 = *v15;
  if ( a6 )
    v16 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;
  v32 = *v16;
  if ( a3 <= 6 )
    v18 = 6;
  else
    v18 = a3;
  result = FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size((__int64)a4, v18);
  if ( (_DWORD)result )
  {
    v20 = 1 << a3;
    if ( a3 )
    {
      v21 = 0;
      v22 = 0;
      v23 = v20;
      while ( 1 )
      {
        result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v34, v17);
        if ( !(_DWORD)result )
          break;
        *(_DWORD *)(*a4 + 4 * v21) = v34;
        if ( v34 >= v32 )
        {
          result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v34, 5u);
          if ( !(_DWORD)result )
            return result;
          if ( v21 )
            v26 = 0;
          else
            v26 = a2;
          for ( *(_DWORD *)(a4[1] + 4 * v21) = v34; v26 < v14; *(_DWORD *)(a5 + 4LL * v22++) = v33 )
          {
            result = FLAC__bitreader_read_raw_int32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v33, v34);
            if ( !(_DWORD)result )
              return result;
            ++v26;
          }
          if ( ++v21 >= v23 )
            return 1;
        }
        else
        {
          *(_DWORD *)(a4[1] + 4 * v21) = 0;
          if ( v21 )
            v24 = 0;
          else
            v24 = a2;
          v25 = v14 - v24;
          result = FLAC__bitreader_read_rice_signed_block(
                     *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL),
                     (unsigned int *)(a5 + 4LL * v22),
                     v14 - v24,
                     v34);
          if ( !(_DWORD)result )
            return result;
          v22 += v25;
          if ( ++v21 >= v23 )
            return 1;
        }
      }
    }
    else
    {
      v27 = 0;
      v28 = 0;
      v29 = v20;
      do
      {
        result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v34, v17);
        if ( !(_DWORD)result )
          break;
        *(_DWORD *)(*a4 + 4 * v27) = v34;
        if ( v34 >= v32 )
        {
          result = FLAC__bitreader_read_raw_uint32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v34, 5u);
          if ( !(_DWORD)result )
            return result;
          *(_DWORD *)(a4[1] + 4 * v27) = v34;
          if ( v14 )
          {
            v30 = 0;
            while ( 1 )
            {
              result = FLAC__bitreader_read_raw_int32(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL), &v33, v34);
              if ( !(_DWORD)result )
                return result;
              v31 = v28 + v30++;
              *(_DWORD *)(a5 + 4LL * v31) = v33;
              if ( v30 >= v14 )
              {
                v28 += v30;
                break;
              }
            }
          }
        }
        else
        {
          *(_DWORD *)(a4[1] + 4 * v27) = 0;
          result = FLAC__bitreader_read_rice_signed_block(
                     *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL),
                     (unsigned int *)(a5 + 4LL * v28),
                     v14,
                     v34);
          if ( !(_DWORD)result )
            return result;
          v28 += v14;
        }
        ++v27;
        result = 1;
      }
      while ( v27 < v29 );
    }
  }
  else
  {
    **(_DWORD **)a1 = 8;
  }
  return result;
}
// 61B14: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
// 61B18: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
// 61B20: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
// 61B24: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;

//----- (000000000002D33C) ----------------------------------------------------
_QWORD *FLAC__stream_encoder_new()
{
  _QWORD *v0; // x19
  _DWORD *v1; // x21
  char *v2; // x20
  void *v3; // x0
  int64x2_t v4; // q0

  v0 = calloc(1u, 0x10u);
  if ( !v0 )
    return v0;
  v1 = calloc(1u, 0x78u);
  *v0 = v1;
  if ( !v1 )
  {
LABEL_10:
    free(v0);
    return 0;
  }
  v2 = (char *)calloc(1u, 0x22E8u);
  v0[1] = v2;
  if ( !v2 )
  {
LABEL_9:
    free(v1);
    goto LABEL_10;
  }
  v3 = FLAC__bitwriter_new();
  *((_QWORD *)v2 + 996) = v3;
  if ( !v3 )
  {
    free(v2);
    goto LABEL_9;
  }
  *(_OWORD *)(v1 + 1) = xmmword_62A20;
  *((_QWORD *)v2 + 1057) = 0;
  *(_QWORD *)(v1 + 21) = 0;
  *(_QWORD *)(v1 + 19) = 0;
  *(_QWORD *)(v1 + 17) = 0;
  *(_QWORD *)(v1 + 15) = 0;
  *(_QWORD *)(v1 + 13) = 0;
  *(_QWORD *)(v1 + 11) = 0;
  *(_QWORD *)(v1 + 9) = 0;
  *((_QWORD *)v2 + 1021) = 0;
  *(_OWORD *)(v1 + 5) = xmmword_62A30;
  memset(v2 + 8376, 0, 0x48u);
  if ( *v1 == 1 )
  {
    *((_QWORD *)v1 + 2) = 1;
    *(_OWORD *)(v1 + 10) = xmmword_62A40;
    *(_QWORD *)(v1 + 15) = 0x500000000LL;
  }
  v4 = vdupq_n_s64((unsigned __int64)v2);
  *((int64x2_t *)v2 + 418) = vaddq_s64(v4, (int64x2_t)xmmword_62A50);
  *((int64x2_t *)v2 + 419) = vaddq_s64(v4, (int64x2_t)xmmword_62A60);
  *((int64x2_t *)v2 + 420) = vaddq_s64(v4, (int64x2_t)xmmword_62A70);
  *((_DWORD *)v2 + 2232) = 0;
  *((int64x2_t *)v2 + 421) = vaddq_s64(v4, (int64x2_t)xmmword_62A80);
  *((_QWORD *)v2 + 850) = v2 + 4768;
  *((int64x2_t *)v2 + 422) = vaddq_s64(v4, (int64x2_t)xmmword_62A90);
  *((int64x2_t *)v2 + 423) = vaddq_s64(v4, (int64x2_t)xmmword_62AA0);
  *((int64x2_t *)v2 + 424) = vaddq_s64(v4, (int64x2_t)xmmword_62AB0);
  *(int64x2_t *)(v2 + 6808) = vaddq_s64(v4, (int64x2_t)xmmword_62AC0);
  *(int64x2_t *)(v2 + 6824) = vaddq_s64(v4, (int64x2_t)xmmword_62AD0);
  *((_QWORD *)v2 + 855) = v2 + 6368;
  *((_QWORD *)v2 + 952) = v2 + 6848;
  *((_QWORD *)v2 + 953) = v2 + 6872;
  *((_QWORD *)v2 + 954) = v2 + 6896;
  *((_QWORD *)v2 + 955) = v2 + 6920;
  *((_QWORD *)v2 + 956) = v2 + 6944;
  *((_QWORD *)v2 + 957) = v2 + 6968;
  *((_QWORD *)v2 + 958) = v2 + 6992;
  *((_QWORD *)v2 + 959) = v2 + 7016;
  *((_QWORD *)v2 + 960) = v2 + 7040;
  *((_QWORD *)v2 + 961) = v2 + 7064;
  *((_QWORD *)v2 + 962) = v2 + 7088;
  *((_QWORD *)v2 + 963) = v2 + 7112;
  *((_QWORD *)v2 + 964) = v2 + 7136;
  *((_QWORD *)v2 + 965) = v2 + 7160;
  *((_QWORD *)v2 + 966) = v2 + 7184;
  *((_QWORD *)v2 + 967) = v2 + 7208;
  *((_QWORD *)v2 + 968) = v2 + 7232;
  *((_QWORD *)v2 + 969) = v2 + 7256;
  *((_QWORD *)v2 + 970) = v2 + 7280;
  *((_QWORD *)v2 + 971) = v2 + 7304;
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6848));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6872));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6896));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6920));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6944));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6968));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 6992));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7016));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7040));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7064));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7088));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7112));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7136));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7160));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7184));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7208));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7232));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7256));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7280));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 7304));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 8744));
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init((__int64)(v2 + 8768));
  *(_DWORD *)*v0 = 1;
  return v0;
}
// 62A20: using guessed type __int128 xmmword_62A20;
// 62A30: using guessed type __int128 xmmword_62A30;
// 62A40: using guessed type __int128 xmmword_62A40;
// 62A50: using guessed type __int128 xmmword_62A50;
// 62A60: using guessed type __int128 xmmword_62A60;
// 62A70: using guessed type __int128 xmmword_62A70;
// 62A80: using guessed type __int128 xmmword_62A80;
// 62A90: using guessed type __int128 xmmword_62A90;
// 62AA0: using guessed type __int128 xmmword_62AA0;
// 62AB0: using guessed type __int128 xmmword_62AB0;
// 62AC0: using guessed type __int128 xmmword_62AC0;
// 62AD0: using guessed type __int128 xmmword_62AD0;

//----- (000000000002D6F0) ----------------------------------------------------
void __fastcall FLAC__stream_encoder_delete(__int64 a1)
{
  __int64 v2; // x8
  void **v3; // x0

  if ( a1 )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8928LL) = 1;
    FLAC__stream_encoder_finish((__int64 **)a1);
    v2 = *(_QWORD *)(a1 + 8);
    v3 = *(void ***)(v2 + 8792);
    if ( v3 )
    {
      FLAC__stream_decoder_delete(v3);
      v2 = *(_QWORD *)(a1 + 8);
    }
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(v2 + 6848);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6872LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6896LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6920LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6944LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6968LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 6992LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7016LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7040LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7064LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7088LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7112LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7136LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7160LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7184LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7208LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7232LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7256LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7280LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 7304LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 8744LL);
    FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(*(_QWORD *)(a1 + 8) + 8768LL);
    FLAC__bitwriter_delete(*(void ***)(*(_QWORD *)(a1 + 8) + 7968LL));
    free(*(void **)(a1 + 8));
    free(*(void **)a1);
    free((void *)a1);
  }
}

//----- (000000000002D8C0) ----------------------------------------------------
__int64 **__fastcall FLAC__stream_encoder_finish(__int64 **result)
{
  __int64 **v1; // x19
  __int64 *v2; // x8
  int v3; // w9
  __int64 *v4; // x9
  _BOOL4 v5; // w21
  __int64 **v6; // x22
  __int64 *v7; // x27
  __int64 *v8; // x8
  FILE *v9; // x0
  __int64 *v10; // x8
  void *v11; // x0
  __int64 v12; // x23
  void *v13; // x0
  unsigned __int64 v14; // x10
  __int64 *v15; // x8
  void *v16; // x0
  void *v17; // x0
  unsigned __int64 v18; // x23
  __int64 v19; // x24
  __int64 *v20; // x8
  void *v21; // x0
  void *v22; // x0
  __int64 *v23; // x8
  void *v24; // x0
  void *v25; // x0
  void *v26; // x0
  void *v27; // x0
  void *v28; // x0
  void *v29; // x0
  __int64 *v30; // x9
  __int64 v31; // x22
  void *v32; // x0
  unsigned __int64 v33; // x11
  __int64 *v34; // x8
  __int64 *v35; // x8
  __int64 *v36; // x8
  __int64 *v37; // x8
  __int64 (__fastcall *v38)(__int64 **, __int64, __int64); // x9
  int v39; // w23
  int v40; // w24
  int v41; // w25
  int v42; // w0
  int v43; // w9
  int v44; // w10
  void (__fastcall *v45)(__int64 **, __int64 *, __int64); // x9
  __int64 v46; // x0
  void **v47; // x0
  __int64 *v48; // x8
  unsigned int *v49; // x9
  __int64 v50; // x23
  unsigned __int64 v51; // x24
  __int64 *v52; // x10
  __int64 v53; // x11
  __int64 v54; // x10
  __int16 v55; // kr00_2
  __int64 v56; // [xsp+18h] [xbp-78h]
  char v57; // [xsp+24h] [xbp-6Ch] BYREF
  char v58; // [xsp+25h] [xbp-6Bh]
  char v59; // [xsp+26h] [xbp-6Ah]
  char v60; // [xsp+27h] [xbp-69h]
  char v61; // [xsp+28h] [xbp-68h]
  char v62; // [xsp+29h] [xbp-67h]
  char v63; // [xsp+2Ah] [xbp-66h]
  char v64; // [xsp+2Bh] [xbp-65h]
  char v65; // [xsp+2Ch] [xbp-64h]
  char v66; // [xsp+2Dh] [xbp-63h]
  char v67; // [xsp+2Eh] [xbp-62h]
  char v68; // [xsp+2Fh] [xbp-61h]
  char v69; // [xsp+30h] [xbp-60h]
  char v70; // [xsp+31h] [xbp-5Fh]
  char v71; // [xsp+32h] [xbp-5Eh]
  char v72; // [xsp+33h] [xbp-5Dh]
  char v73; // [xsp+34h] [xbp-5Ch]
  char v74; // [xsp+35h] [xbp-5Bh]
  __int64 v75; // [xsp+38h] [xbp-58h]

  v1 = result;
  v75 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !result )
    return result;
  v2 = *result;
  v3 = *(_DWORD *)*result;
  if ( v3 == 1 )
    return (__int64 **)(&dword_0 + 1);
  if ( v3 || (v4 = result[1], *((_DWORD *)v4 + 2232)) || (v43 = *((_DWORD *)v4 + 2044)) == 0 )
  {
    v5 = 0;
    v6 = result + 1;
    if ( !*((_DWORD *)v2 + 3) )
      goto LABEL_7;
    goto LABEL_6;
  }
  v44 = *((_DWORD *)v2 + 9);
  *((_DWORD *)v2 + 9) = v43;
  v5 = (unsigned int)sub_2F0C0(result, v44 != v43) == 0;
  v6 = v1 + 1;
  if ( *((_DWORD *)*v1 + 3) )
LABEL_6:
    FLAC__MD5Final((_OWORD *)*v6 + 503, (__int64)(*v6 + 1023));
LABEL_7:
  v7 = *v6;
  if ( *((_DWORD *)*v6 + 2232) )
    goto LABEL_8;
  v37 = *v1;
  if ( !*(_DWORD *)*v1 )
  {
    v38 = (__int64 (__fastcall *)(__int64 **, __int64, __int64))v7[1050];
    if ( !v38 )
    {
LABEL_67:
      v45 = (void (__fastcall *)(__int64 **, __int64 *, __int64))v7[1053];
      if ( v45 )
      {
        v45(v1, v7 + 999, v7[1055]);
        v37 = *v1;
      }
      goto LABEL_69;
    }
    v39 = *((_DWORD *)v7 + 2004);
    v40 = *((_DWORD *)v7 + 2005);
    v56 = v7[1005];
    v41 = *((_DWORD *)v7 + 2008);
    v42 = v38(v1, v37[12] + 22, v7[1055]);
    if ( v42 )
      goto LABEL_58;
    if ( ((unsigned int (__fastcall *)(__int64 **, __int64 *, __int64, _QWORD, _QWORD, __int64))v1[1][1052])(
           v1,
           v7 + 1006,
           16,
           0,
           0,
           v1[1][1055]) )
    {
      goto LABEL_64;
    }
    v61 = v56;
    v57 = (16 * v41 - 16) | BYTE4(v56) & 0xF;
    v58 = BYTE3(v56);
    v59 = BYTE2(v56);
    v60 = BYTE1(v56);
    v42 = ((__int64 (__fastcall *)(__int64 **, __int64, __int64))v1[1][1050])(v1, (*v1)[12] + 17, v1[1][1055]);
    if ( v42 )
      goto LABEL_58;
    if ( ((unsigned int (__fastcall *)(__int64 **, char *, __int64, _QWORD, _QWORD, __int64))v1[1][1052])(
           v1,
           &v57,
           5,
           0,
           0,
           v1[1][1055]) )
    {
      *(_DWORD *)*v1 = 5;
      goto LABEL_65;
    }
    v57 = BYTE2(v39);
    v58 = BYTE1(v39);
    v59 = v39;
    v60 = BYTE2(v40);
    v61 = BYTE1(v40);
    v62 = v40;
    v42 = ((__int64 (__fastcall *)(__int64 **, __int64, __int64))v1[1][1050])(v1, (*v1)[12] + 8, v1[1][1055]);
    if ( v42 )
      goto LABEL_58;
    if ( ((unsigned int (__fastcall *)(__int64 **, char *, __int64, _QWORD, _QWORD, __int64))v1[1][1052])(
           v1,
           &v57,
           6,
           0,
           0,
           v1[1][1055]) )
    {
      goto LABEL_64;
    }
    v47 = (void **)(*v6)[1021];
    if ( !v47 || !*(_DWORD *)v47 || !(*v1)[13] )
    {
LABEL_65:
      v37 = *v1;
      v7 = v1[1];
      if ( *(_DWORD *)*v1 )
        v5 = 1;
      goto LABEL_67;
    }
    FLAC__format_seektable_sort(v47);
    v42 = ((__int64 (__fastcall *)(__int64 **, __int64, __int64))v1[1][1050])(v1, (*v1)[13] + 4, v1[1][1055]);
    if ( v42 )
    {
LABEL_58:
      if ( v42 != 1 )
        goto LABEL_65;
    }
    else
    {
      v48 = *v6;
      v49 = (unsigned int *)(*v6)[1021];
      if ( !*v49 )
        goto LABEL_65;
      v50 = 0;
      v51 = 0;
      while ( 1 )
      {
        v52 = (__int64 *)(*((_QWORD *)v49 + 1) + v50);
        v53 = *v52;
        v63 = BYTE1(*v52);
        v62 = BYTE2(v53);
        v61 = BYTE3(v53);
        v60 = BYTE4(v53);
        v64 = v53;
        v59 = BYTE5(v53);
        v58 = BYTE6(v53);
        v57 = HIBYTE(v53);
        v54 = v52[1];
        v71 = BYTE1(v54);
        v70 = BYTE2(v54);
        v72 = v54;
        v69 = BYTE3(v54);
        v68 = BYTE4(v54);
        v67 = BYTE5(v54);
        v66 = BYTE6(v54);
        v65 = HIBYTE(v54);
        v55 = *(_DWORD *)(*((_QWORD *)v49 + 1) + v50 + 16);
        v73 = HIBYTE(v55);
        v74 = v55;
        if ( ((unsigned int (__fastcall *)(__int64 **, char *, __int64, _QWORD, _QWORD, __int64))v48[1052])(
               v1,
               &v57,
               18,
               0,
               0,
               v48[1055]) )
        {
          break;
        }
        v48 = *v6;
        ++v51;
        v50 += 24;
        v49 = (unsigned int *)(*v6)[1021];
        if ( v51 >= *v49 )
          goto LABEL_65;
      }
    }
LABEL_64:
    *(_DWORD *)*v1 = 5;
    goto LABEL_65;
  }
LABEL_69:
  if ( *((_DWORD *)v37 + 1) )
  {
    v46 = (*v6)[1099];
    if ( v46 )
    {
      if ( !FLAC__stream_decoder_finish(v46) )
      {
        if ( !v5 )
          *(_DWORD *)*v1 = 4;
        v5 = 1;
        v8 = *v6;
        v9 = (FILE *)(*v6)[1057];
        if ( !v9 )
          goto LABEL_12;
        goto LABEL_9;
      }
    }
  }
LABEL_8:
  v8 = *v6;
  v9 = (FILE *)(*v6)[1057];
  if ( v9 )
  {
LABEL_9:
    if ( v9 != (FILE *)((char *)&_sF + 152) )
    {
      fclose(v9);
      v8 = *v6;
    }
    v8[1057] = 0;
  }
LABEL_12:
  v10 = *v1;
  v11 = (void *)(*v1)[10];
  if ( v11 )
  {
    free(v11);
    v10 = *v1;
    v10[10] = 0;
    *((_DWORD *)v10 + 22) = 0;
  }
  if ( *((_DWORD *)v10 + 6) )
  {
    v12 = 1061;
    do
    {
      v13 = (void *)(*v6)[v12];
      if ( v13 )
      {
        free(v13);
        v1[1][v12] = 0;
        v10 = *v1;
      }
      v14 = v12 - 1060;
      ++v12;
    }
    while ( v14 < *((unsigned int *)v10 + 6) );
  }
  v15 = *v6;
  v16 = (void *)(*v6)[1069];
  if ( v16 )
  {
    free(v16);
    (*v6)[1069] = 0;
    v15 = *v6;
  }
  v17 = (void *)v15[1070];
  if ( v17 )
  {
    free(v17);
    (*v6)[1070] = 0;
  }
  if ( *((_DWORD *)*v1 + 6) )
  {
    v18 = 0;
    v19 = 1072;
    do
    {
      v20 = *v6;
      v21 = (void *)(*v6)[v19 - 1];
      if ( v21 )
      {
        free(v21);
        (*v6)[v19 - 1] = 0;
        v20 = *v6;
      }
      v22 = (void *)v20[v19];
      if ( v22 )
      {
        free(v22);
        (*v6)[v19] = 0;
      }
      ++v18;
      v19 += 2;
    }
    while ( v18 < *((unsigned int *)*v1 + 6) );
  }
  v23 = *v6;
  v24 = (void *)(*v6)[1087];
  if ( v24 )
  {
    free(v24);
    (*v6)[1087] = 0;
    v23 = *v6;
  }
  v25 = (void *)v23[1088];
  if ( v25 )
  {
    free(v25);
    (*v6)[1088] = 0;
    v23 = *v6;
  }
  v26 = (void *)v23[1089];
  if ( v26 )
  {
    free(v26);
    (*v6)[1089] = 0;
    v23 = *v6;
  }
  v27 = (void *)v23[1090];
  if ( v27 )
  {
    free(v27);
    (*v6)[1090] = 0;
    v23 = *v6;
  }
  v28 = (void *)v23[1091];
  if ( v28 )
  {
    free(v28);
    v23 = *v6;
    (*v6)[1091] = 0;
  }
  v29 = (void *)v23[1092];
  if ( v29 )
  {
    free(v29);
    v23 = *v6;
    (*v6)[1092] = 0;
  }
  v30 = *v1;
  if ( *((_DWORD *)*v1 + 1) && *((_DWORD *)v30 + 6) )
  {
    v31 = 1101;
    do
    {
      v32 = (void *)v23[v31];
      if ( v32 )
      {
        free(v32);
        v1[1][v31] = 0;
        v30 = *v1;
        v23 = v1[1];
      }
      v33 = v31 - 1100;
      ++v31;
    }
    while ( v33 < *((unsigned int *)v30 + 6) );
  }
  FLAC__bitwriter_free(v23[996]);
  v34 = *v1;
  *(__int64 *)((char *)v34 + 84) = 0;
  *(_OWORD *)((char *)v34 + 4) = xmmword_62A20;
  *(__int64 *)((char *)v34 + 76) = 0;
  *(__int64 *)((char *)v34 + 68) = 0;
  *(__int64 *)((char *)v34 + 60) = 0;
  *(__int64 *)((char *)v34 + 52) = 0;
  *(__int64 *)((char *)v34 + 44) = 0;
  *(__int64 *)((char *)v34 + 36) = 0;
  *(_OWORD *)((char *)v34 + 20) = xmmword_62A30;
  v35 = v1[1];
  v35[1021] = 0;
  memset(v35 + 1047, 0, 0x48u);
  v36 = *v1;
  if ( *(_DWORD *)*v1 == 1 )
  {
    v36[2] = 1;
    *(_OWORD *)(v36 + 5) = xmmword_62A40;
    *(__int64 *)((char *)v36 + 60) = 0x500000000LL;
  }
  if ( !v5 )
    *(_DWORD *)v36 = 1;
  return (__int64 **)!v5;
}
// 0: using guessed type int dword_0;
// 62A20: using guessed type __int128 xmmword_62A20;
// 62A30: using guessed type __int128 xmmword_62A30;
// 62A40: using guessed type __int128 xmmword_62A40;

//----- (000000000002E040) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_stream(
        int **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return sub_2E074(a1, 0, a2, a3, a4, a5, a6, 0);
}

//----- (000000000002E074) ----------------------------------------------------
__int64 __fastcall sub_2E074(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8)
{
  int *v11; // x8
  __int64 result; // x0
  int v17; // w9
  unsigned int v18; // w9
  int *v19; // x8
  unsigned int v20; // w9
  int v21; // w9
  unsigned int v22; // w9
  unsigned int v23; // w9
  bool v24; // cf
  unsigned __int64 v25; // t2
  unsigned int v26; // w9
  _DWORD *v27; // x10
  int **v28; // x9
  unsigned __int64 v29; // x10
  __int64 v30; // x11
  int *v31; // x12
  unsigned int v32; // w26
  int *v33; // x28
  int v34; // w8
  __int64 v35; // kr00_8
  int *v36; // x9
  int **v37; // x28
  unsigned __int64 v38; // x8
  __int64 v39; // x10
  int *v40; // x9
  __int64 v41; // x8
  __int64 v42; // x10
  unsigned __int64 v43; // x12
  int *v44; // x8
  int *v45; // x8
  unsigned __int64 v46; // x9
  unsigned __int64 v47; // x9
  int *v48; // x8
  __int128 v49; // q0
  int *v50; // x9
  unsigned __int64 v51; // x20
  int *v52; // x8
  __int64 v53; // x22
  unsigned __int64 v54; // x23
  unsigned int v55; // w0
  _QWORD *v56; // x8
  unsigned int v57; // w0
  _QWORD *v58; // x8
  unsigned int v59; // w0
  _QWORD *v60; // x8
  __int64 v61; // x24
  __int64 v62; // x21
  unsigned int v63; // w0
  __int64 v64; // x23
  unsigned int v65; // w0
  unsigned int v66; // w0
  int *v67; // x8
  int v68; // w9
  _BOOL4 v69; // w0
  int *v70; // x9
  unsigned int v71; // w10
  void *v72; // x0
  __int64 v73; // x20
  void *v74; // x0
  int v75; // w9
  bool v76; // w9
  int **v77; // x0
  int inited; // w0
  int *v79; // x10
  int *v80; // x8
  int *v81; // x9
  int *v82; // x8
  unsigned int v83; // w8
  int *v84; // x8
  unsigned __int64 v85; // x9
  unsigned __int64 v86; // x20
  __int64 v87; // x0
  __int64 (__fastcall *v88)(int **, int *, _QWORD); // x9
  int v89; // w8
  __int64 v90; // [xsp+20h] [xbp-120h]
  char *v91; // [xsp+28h] [xbp-118h]
  char *v92; // [xsp+28h] [xbp-118h]
  __int64 v93; // [xsp+30h] [xbp-110h]
  _DWORD v94[6]; // [xsp+38h] [xbp-108h] BYREF
  __int64 v95; // [xsp+50h] [xbp-F0h]
  int v96; // [xsp+58h] [xbp-E8h]
  __int64 v97; // [xsp+60h] [xbp-E0h]
  __int64 v98; // [xsp+E8h] [xbp-58h]

  v98 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11 = *a1;
  if ( **a1 != 1 )
    return 13;
  if ( a8 )
    return 2;
  if ( !a3 || a4 && !a5 )
    return 3;
  v17 = v11[6];
  if ( (unsigned int)(v17 - 1) > 7 )
    return 4;
  if ( v17 == 2 )
  {
    if ( v11[4] )
      goto LABEL_17;
  }
  else
  {
    v11[4] = 0;
  }
  v11[5] = 0;
LABEL_17:
  v18 = v11[7];
  if ( v18 >= 0x20 )
  {
    v11[4] = 0;
    return 5;
  }
  if ( v18 - 4 > 0x14 )
    return 5;
  if ( !FLAC__format_sample_rate_is_valid(v11[8]) )
    return 6;
  v19 = *a1;
  result = (unsigned int)(*a1)[9];
  if ( !(_DWORD)result )
  {
    if ( v19[10] )
      result = 4096;
    else
      result = 1152;
    v19[9] = result;
  }
  if ( (unsigned int)(result - 16) >> 4 > 0xFFE )
    return 7;
  v20 = v19[10];
  if ( v20 > 0x20 )
    return 8;
  if ( (unsigned int)result < v20 )
    return 10;
  v21 = v19[11];
  if ( !v21 )
  {
    v22 = v19[7];
    if ( v22 <= 0xF )
    {
      v23 = (v22 >> 1) + 2;
      if ( v23 <= 5 )
        v23 = 5;
      goto LABEL_50;
    }
    if ( v22 == 16 )
    {
      if ( (unsigned int)result < 0xC1 )
      {
        v23 = 7;
LABEL_50:
        v19[11] = v23;
        goto LABEL_51;
      }
      if ( (unsigned int)result < 0x181 )
      {
        v23 = 8;
        goto LABEL_50;
      }
      if ( (unsigned int)result < 0x241 )
      {
        v23 = 9;
        goto LABEL_50;
      }
      if ( (unsigned int)result < 0x481 )
      {
        v23 = 10;
        goto LABEL_50;
      }
      if ( (unsigned int)result < 0x901 )
      {
        v23 = 11;
        goto LABEL_50;
      }
      v24 = (unsigned int)result >= 0x1201;
      v23 = 12;
    }
    else
    {
      if ( (unsigned int)result < 0x181 )
      {
        v23 = 13;
        goto LABEL_50;
      }
      v24 = (unsigned int)result >= 0x481;
      v23 = 14;
    }
    if ( v24 )
      ++v23;
    goto LABEL_50;
  }
  if ( (unsigned int)(v21 - 5) > 0xA )
    return 9;
LABEL_51:
  if ( v19[2] )
  {
    if ( !(unsigned int)FLAC__format_blocksize_is_subset(result, v19[8]) )
      return 11;
    result = FLAC__format_sample_rate_is_subset((*a1)[8]);
    if ( !(_DWORD)result )
      return 11;
    v19 = *a1;
    HIDWORD(v25) = (*a1)[7] - 8;
    LODWORD(v25) = HIDWORD(v25);
    if ( (unsigned int)(v25 >> 2) > 4 )
      return 11;
    v27 = v19 + 16;
    v26 = v19[16];
    if ( v26 > 8 || (unsigned int)v19[8] <= 0xBB80 && ((unsigned int)v19[9] > 0x1200 || (unsigned int)v19[10] > 0xC) )
      return 11;
  }
  else
  {
    v27 = v19 + 16;
    v26 = v19[16];
  }
  if ( v26 >= 0x10 )
  {
    v26 = 15;
    *v27 = 15;
    if ( (unsigned int)v19[15] < 0xF )
    {
LABEL_60:
      v28 = (int **)*((_QWORD *)v19 + 10);
      v29 = (unsigned int)v19[22];
      if ( v28 )
        goto LABEL_61;
LABEL_69:
      if ( (_DWORD)v29 )
        return 12;
      goto LABEL_95;
    }
  }
  else if ( v19[15] < v26 )
  {
    goto LABEL_60;
  }
  v19[15] = v26;
  v28 = (int **)*((_QWORD *)v19 + 10);
  v29 = (unsigned int)v19[22];
  if ( !v28 )
    goto LABEL_69;
LABEL_61:
  if ( !(_DWORD)v29 )
  {
LABEL_95:
    HIDWORD(v93) = 0;
    goto LABEL_96;
  }
  v30 = 0;
  while ( 1 )
  {
    v31 = v28[v30];
    if ( v31 )
    {
      if ( *v31 == 3 )
        break;
    }
    if ( ++v30 >= v29 )
      goto LABEL_72;
  }
  *((_QWORD *)a1[1] + 1021) = v31 + 4;
LABEL_72:
  v32 = 0;
  v90 = 0;
  v93 = 0;
  v33 = *v28;
  v34 = **v28;
LABEL_73:
  v35 = result;
  result = 12;
  switch ( v34 )
  {
    case 0:
      return result;
    case 3:
      if ( (_DWORD)v93 )
        return 12;
      result = FLAC__format_seektable_is_legal((unsigned int *)v33 + 4);
      if ( !(_DWORD)result )
        return 12;
      LODWORD(v93) = 1;
      goto LABEL_93;
    case 4:
      if ( HIDWORD(v93) )
        return 12;
      HIDWORD(v93) = 1;
      goto LABEL_93;
    case 5:
      result = FLAC__format_cuesheet_is_legal((__int64)(v33 + 4), v33[40], 0);
      if ( !(_DWORD)result )
        return 12;
      goto LABEL_93;
    case 6:
      v91 = (char *)(v33 + 4);
      result = FLAC__format_picture_is_legal((__int64)(v33 + 4), 0);
      if ( !(_DWORD)result )
        return 12;
      if ( *(_DWORD *)v91 != 2 )
      {
        if ( *(_DWORD *)v91 != 1 )
          goto LABEL_93;
        if ( !(_DWORD)v90 )
        {
          v92 = (char *)*((_QWORD *)v33 + 3);
          result = strcmp(v92, "image/png");
          if ( !(_DWORD)result || (result = strcmp(v92, "-->"), !(_DWORD)result) )
          {
            if ( v33[10] == 32 && v33[11] == 32 )
            {
              LODWORD(v90) = 1;
              goto LABEL_93;
            }
          }
        }
        return 12;
      }
      if ( HIDWORD(v90) )
        return 12;
      HIDWORD(v90) = 1;
LABEL_93:
      while ( 1 )
      {
        v19 = *a1;
        if ( ++v32 >= (*a1)[22] )
          break;
        v33 = *(int **)(*((_QWORD *)v19 + 10) + 8LL * v32);
        v34 = *v33;
        if ( (unsigned int)*v33 <= 6 )
          goto LABEL_73;
      }
      break;
    default:
      result = v35;
      goto LABEL_93;
  }
LABEL_96:
  v37 = a1 + 1;
  v36 = a1[1];
  *v36 = 0;
  if ( v19[6] )
  {
    v38 = 0;
    do
    {
      v39 = 2 * v38;
      *(_QWORD *)&v36[2 * v38++ + 2] = 0;
      *(_QWORD *)&a1[1][v39 + 2122] = 0;
      v36 = a1[1];
    }
    while ( v38 < (unsigned int)(*a1)[6] );
  }
  *((_QWORD *)v36 + 9) = 0;
  *((_QWORD *)a1[1] + 1069) = 0;
  *((_QWORD *)a1[1] + 10) = 0;
  *((_QWORD *)a1[1] + 1070) = 0;
  v40 = a1[1];
  if ( (*a1)[6] )
  {
    v41 = 0;
    v42 = 1968;
    do
    {
      *(_QWORD *)&v40[v41 + 32] = 0;
      v43 = v42 - 1967;
      *(_QWORD *)&a1[1][v41 + 2142] = 0;
      *(_QWORD *)&a1[1][v41 + 34] = 0;
      *(_QWORD *)&a1[1][v41 + 2144] = 0;
      v40 = a1[1];
      v41 += 4;
      v40[v42++] = 0;
    }
    while ( v43 < (unsigned int)(*a1)[6] );
  }
  *((_QWORD *)v40 + 32) = 0;
  *((_QWORD *)a1[1] + 1087) = 0;
  *((_QWORD *)a1[1] + 33) = 0;
  *((_QWORD *)a1[1] + 1088) = 0;
  v44 = a1[1];
  v44[1976] = 0;
  *((_QWORD *)v44 + 34) = 0;
  *((_QWORD *)a1[1] + 1089) = 0;
  *((_QWORD *)a1[1] + 35) = 0;
  *((_QWORD *)a1[1] + 1090) = 0;
  v45 = a1[1];
  v45[1977] = 0;
  *((_OWORD *)v45 + 497) = 0u;
  *(_OWORD *)(v45 + 2182) = 0u;
  v46 = 1717960704 * (unsigned __int64)(unsigned int)(*a1)[8] / (unsigned int)((*a1)[9] << 16);
  v45[1995] = 0;
  *((_QWORD *)v45 + 1022) = 0;
  v47 = (v46 + 0x8000) >> 16;
  if ( !(_DWORD)v47 )
    LODWORD(v47) = 1;
  v45[1994] = v47;
  FLAC__cpu_info((__int64)(v45 + 2072));
  v48 = a1[1];
  *(_QWORD *)&v49 = FLAC__fixed_compute_best_predictor;
  *((_QWORD *)&v49 + 1) = FLAC__fixed_compute_best_predictor_wide;
  *((_QWORD *)v48 + 1044) = sub_304C4;
  *(_OWORD *)(v48 + 2090) = v49;
  v50 = *a1;
  *v50 = 0;
  *((_QWORD *)v48 + 1049) = a2;
  *((_QWORD *)v48 + 1052) = a3;
  *((_QWORD *)v48 + 1050) = a4;
  *((_QWORD *)v48 + 1051) = a5;
  *((_QWORD *)v48 + 1053) = a6;
  *((_QWORD *)v48 + 1055) = a7;
  v51 = (unsigned int)v50[9];
  if ( *v48 < (unsigned int)v51 )
  {
    v52 = *v37;
    if ( v50[6] )
    {
      v53 = 0;
      v54 = 0;
      while ( 1 )
      {
        v55 = (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                              (unsigned int)(v51 + 5),
                              (void **)&v52[v53 + 2122],
                              &v52[v53 + 2]);
        v56 = *(_QWORD **)&(*v37)[v53 + 2];
        *v56 = 0;
        v56[1] = 0;
        *(_QWORD *)&(*v37)[v53 + 2] += 16LL;
        if ( !v55 )
          break;
        v52 = a1[1];
        ++v54;
        v53 += 2;
        if ( v54 >= (unsigned int)(*a1)[6] )
          goto LABEL_109;
      }
    }
    else
    {
LABEL_109:
      v57 = (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                            (unsigned int)(v51 + 5),
                            (void **)v52 + 1069,
                            (_QWORD *)v52 + 9);
      v58 = (_QWORD *)*((_QWORD *)*v37 + 9);
      *v58 = 0;
      v58[1] = 0;
      *((_QWORD *)*v37 + 9) += 16LL;
      if ( v57 )
      {
        v59 = (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                              (unsigned int)(v51 + 5),
                              (void **)*v37 + 1070,
                              (_QWORD *)*v37 + 10);
        v60 = (_QWORD *)*((_QWORD *)*v37 + 10);
        *v60 = 0;
        v60[1] = 0;
        *((_QWORD *)*v37 + 10) += 16LL;
        if ( v59 )
        {
          v61 = 0;
          v62 = -1;
          while ( ++v62 < (unsigned __int64)(unsigned int)(*a1)[6] )
          {
            if ( (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                                 v51,
                                 (void **)&(*v37)[v61 + 2142],
                                 &(*v37)[v61 + 32]) )
            {
              v63 = (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                                    v51,
                                    (void **)&(*v37)[v61 + 2144],
                                    &(*v37)[v61 + 34]);
              v61 += 4;
              if ( v63 )
                continue;
            }
            goto LABEL_132;
          }
          v64 = 0;
          do
          {
            if ( !(unsigned int)FLAC__memory_alloc_aligned_int32_array(
                                  v51,
                                  (void **)&(*v37)[4 * v64 + 2174],
                                  &(*v37)[4 * v64 + 64]) )
              goto LABEL_132;
            v65 = (unsigned int)FLAC__memory_alloc_aligned_int32_array(
                                  v51,
                                  (void **)&(*v37)[4 * v64 + 2176],
                                  &(*v37)[4 * v64 + 66]);
            if ( (unsigned __int64)(v64 + 1) > 1 )
              break;
            v64 = 1;
          }
          while ( v65 );
          if ( !v65 )
            goto LABEL_132;
          v66 = (unsigned int)FLAC__memory_alloc_aligned_uint64_array(
                                (unsigned int)(2 * v51),
                                (void **)a1[1] + 1091,
                                (_QWORD *)a1[1] + 994);
          v67 = *a1;
          v68 = (*a1)[14];
          if ( v68 && v66 )
          {
            if ( !(unsigned int)FLAC__memory_alloc_aligned_unsigned_array(
                                  (unsigned int)(2 * v51),
                                  (void **)*v37 + 1092,
                                  (_QWORD *)*v37 + 995) )
              goto LABEL_132;
          }
          else if ( !v66 || v68 )
          {
            goto LABEL_146;
          }
          v48 = *v37;
          **v37 = v51;
          goto LABEL_139;
        }
      }
    }
LABEL_132:
    v67 = *a1;
LABEL_146:
    v75 = 8;
LABEL_147:
    *v67 = v75;
    return 1;
  }
LABEL_139:
  v69 = FLAC__bitwriter_init(*((_QWORD *)v48 + 996));
  v67 = *a1;
  if ( !v69 )
    goto LABEL_146;
  if ( v67[1] )
  {
    v70 = *v37;
    v71 = v67[9] + 1;
    (*v37)[2218] = v71;
    if ( v67[6] )
    {
      v72 = safe_malloc_mul_2op_p(4u, v71);
      *((_QWORD *)a1[1] + 1101) = v72;
      v67 = *a1;
      if ( !v72 )
        goto LABEL_146;
      v73 = 1102;
      while ( 1 )
      {
        v70 = *v37;
        if ( v73 - 1101 >= (unsigned __int64)(unsigned int)v67[6] )
          break;
        v74 = safe_malloc_mul_2op_p(4u, (unsigned int)v70[2218]);
        *(_QWORD *)&a1[1][2 * v73] = v74;
        v67 = *a1;
        ++v73;
        if ( !v74 )
          goto LABEL_146;
      }
    }
    v77 = (int **)*((_QWORD *)v70 + 1099);
    v70[2219] = 0;
    if ( v77 || (v77 = (int **)FLAC__stream_decoder_new(), (*((_QWORD *)*v37 + 1099) = v77) != 0) )
    {
      inited = FLAC__stream_decoder_init_stream(
                 v77,
                 (__int64)sub_306FC,
                 0,
                 0,
                 0,
                 0,
                 (__int64)sub_307B8,
                 (__int64)nullsub_4,
                 (__int64)sub_30948,
                 (__int64)a1);
      v67 = *a1;
      if ( !inited )
      {
        v76 = v67[1] == 0;
        goto LABEL_154;
      }
    }
    else
    {
      v67 = *a1;
    }
    v75 = 3;
    goto LABEL_147;
  }
  v76 = 1;
LABEL_154:
  v79 = *v37;
  v79[2112] = 0;
  *((_QWORD *)v79 + 1059) = 0;
  v79[2230] = 0;
  *((_QWORD *)v79 + 1114) = 0;
  *((_QWORD *)v79 + 1113) = 0;
  *((_QWORD *)v79 + 1112) = 0;
  *((_QWORD *)v67 + 13) = 0;
  *((_QWORD *)v67 + 14) = 0;
  *((_QWORD *)v67 + 12) = 0;
  if ( !v76 )
    v79[2200] = 0;
  if ( !(unsigned int)FLAC__bitwriter_write_raw_uint32(*((_QWORD *)v79 + 996), 0x664C6143u, 0x20u) )
    goto LABEL_178;
  if ( !(unsigned int)sub_30958(a1, 0) )
    return 1;
  v80 = *a1;
  v81 = a1[1];
  if ( (*a1)[1] )
    v81[2200] = 1;
  *((_QWORD *)v81 + 999) = 0;
  v81[2000] = 34;
  v81[2002] = v80[9];
  a1[1][2003] = (*a1)[9];
  a1[1][2004] = 0;
  a1[1][2005] = 0;
  a1[1][2006] = (*a1)[8];
  a1[1][2007] = (*a1)[6];
  a1[1][2008] = (*a1)[7];
  *((_QWORD *)a1[1] + 1005) = *((_QWORD *)*a1 + 9);
  v82 = a1[1];
  *((_QWORD *)v82 + 1007) = 0;
  *((_QWORD *)v82 + 1006) = 0;
  if ( (*a1)[3] )
    FLAC__MD5Init((__int64)(*v37 + 2046));
  if ( !(unsigned int)FLAC__add_metadata_block((__int64)(*v37 + 1998), *((_DWORD **)*v37 + 996)) )
    goto LABEL_178;
  v83 = (unsigned int)sub_30958(a1, 0);
  result = 1;
  if ( v83 )
  {
    (*v37)[2004] = 0xFFFFFF;
    *((_QWORD *)*v37 + 1005) = 0;
    if ( !HIDWORD(v93) )
    {
      v94[0] = 4;
      v89 = (*a1)[22];
      v94[4] = 0;
      v95 = 0;
      v96 = 0;
      v94[1] = v89 == 0;
      v94[2] = 8;
      v97 = 0;
      if ( !(unsigned int)FLAC__add_metadata_block((__int64)v94, *((_DWORD **)a1[1] + 996)) )
      {
LABEL_178:
        v67 = *a1;
        v75 = 7;
        goto LABEL_147;
      }
      if ( !(unsigned int)sub_30958(a1, 0) )
        return 1;
    }
    v84 = *a1;
    LODWORD(v85) = (*a1)[22];
    if ( (_DWORD)v85 )
    {
      v86 = 0;
      do
      {
        v87 = *(_QWORD *)(*((_QWORD *)v84 + 10) + 8 * v86);
        *(_DWORD *)(v87 + 4) = v86 == (_DWORD)v85 - 1;
        if ( !(unsigned int)FLAC__add_metadata_block(v87, *((_DWORD **)*v37 + 996)) )
          goto LABEL_178;
        if ( !(unsigned int)sub_30958(a1, 0) )
          return 1;
        v84 = *a1;
        ++v86;
        v85 = (unsigned int)(*a1)[22];
      }
      while ( v86 < v85 );
    }
    v88 = (__int64 (__fastcall *)(int **, int *, _QWORD))*((_QWORD *)*v37 + 1051);
    if ( v88 && (result = v88(a1, v84 + 28, *((_QWORD *)*v37 + 1055)), v84 = *a1, (_DWORD)result == 1) )
    {
      *v84 = 5;
    }
    else
    {
      result = 0;
      if ( v84[1] )
        (*v37)[2200] = 2;
    }
  }
  return result;
}
// 2E420: conditional instruction was optimized away because w10.4!=0
// 30944: using guessed type __int64 __fastcall nullsub_4();

//----- (000000000002ED70) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_ogg_stream(_DWORD **a1)
{
  if ( **a1 == 1 )
    return 2;
  else
    return 13;
}

//----- (000000000002ED8C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_FILE(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  __int64 v6; // x9
  __int64 (__fastcall *v7)(__int64, __off_t); // x3
  __int64 (__fastcall *v8)(__int64, __off_t *); // x4
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 1 )
    return 13;
  if ( a2 )
  {
    v6 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(v6 + 8432) = a3;
    if ( a2 == (char *)&_sF + 152 )
      v7 = 0;
    else
      v7 = sub_30CD8;
    if ( a2 == (char *)&_sF + 152 )
      v8 = 0;
    else
      v8 = sub_30CFC;
    *(_QWORD *)(v6 + 8456) = a2;
    *(_OWORD *)(v6 + 8464) = 0u;
    *(_DWORD *)(v6 + 8480) = 0;
    result = sub_2E074((int **)a1, 0, (__int64)sub_30C44, (__int64)v7, (__int64)v8, 0, a4, 0);
    if ( !(_DWORD)result )
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8484LL) = ((unsigned __int64)*(unsigned int *)(*(_QWORD *)a1 + 36LL)
                                                 + *(_QWORD *)(*(_QWORD *)a1 + 72LL)
                                                 - 1)
                                                / *(unsigned int *)(*(_QWORD *)a1 + 36LL);
  }
  else
  {
    **(_DWORD **)a1 = 6;
    return 1;
  }
  return result;
}

//----- (000000000002EE74) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_ogg_FILE(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v3; // x8
  __int64 v4; // x8
  __int64 result; // x0

  v3 = *(_DWORD **)a1;
  if ( **(_DWORD **)a1 != 1 )
    return 13;
  if ( a2 )
  {
    v4 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(v4 + 8456) = a2;
    *(_QWORD *)(v4 + 8432) = a3;
    *(_DWORD *)(v4 + 8480) = 0;
    *(_OWORD *)(v4 + 8464) = 0u;
    if ( **(_DWORD **)a1 == 1 )
      return 2;
    else
      return 13;
  }
  else
  {
    result = 1;
    *v3 = 6;
  }
  return result;
}

//----- (000000000002EED4) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_file(__int64 a1, const char *a2, __int64 a3, __int64 a4)
{
  FILE *v7; // x22
  FILE *v8; // x0
  _DWORD *v9; // x8
  __int64 result; // x0
  __int64 v11; // x8
  __int64 (__fastcall *v12)(__int64, __off_t); // x3
  __int64 (__fastcall *v13)(__int64, __off_t *); // x4

  if ( **(_DWORD **)a1 != 1 )
    return 13;
  v7 = (FILE *)((char *)&_sF + 152);
  if ( a2 )
  {
    v8 = fopen(a2, "w+b");
    v9 = *(_DWORD **)a1;
    if ( !v8 )
    {
      *v9 = 6;
      return 1;
    }
    if ( *v9 != 1 )
      return 13;
  }
  else
  {
    v8 = (FILE *)((char *)&_sF + 152);
  }
  v11 = *(_QWORD *)(a1 + 8);
  if ( v8 == v7 )
    v12 = 0;
  else
    v12 = sub_30CD8;
  if ( v8 == v7 )
    v13 = 0;
  else
    v13 = sub_30CFC;
  *(_QWORD *)(v11 + 8456) = v8;
  *(_QWORD *)(v11 + 8432) = a3;
  *(_OWORD *)(v11 + 8464) = 0u;
  *(_DWORD *)(v11 + 8480) = 0;
  result = sub_2E074((int **)a1, 0, (__int64)sub_30C44, (__int64)v12, (__int64)v13, 0, a4, 0);
  if ( !(_DWORD)result )
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8484LL) = ((unsigned __int64)*(unsigned int *)(*(_QWORD *)a1 + 36LL)
                                               + *(_QWORD *)(*(_QWORD *)a1 + 72LL)
                                               - 1)
                                              / *(unsigned int *)(*(_QWORD *)a1 + 36LL);
  return result;
}

//----- (000000000002F000) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_init_ogg_file(__int64 a1, const char *a2, __int64 a3)
{
  FILE *v5; // x0
  _DWORD *v6; // x8
  __int64 v8; // x8

  if ( **(_DWORD **)a1 != 1 )
    return 13;
  if ( a2 )
  {
    v5 = fopen(a2, "w+b");
    v6 = *(_DWORD **)a1;
    if ( !v5 )
    {
      *v6 = 6;
      return 1;
    }
    if ( *v6 != 1 )
      return 13;
  }
  else
  {
    v5 = (FILE *)((char *)&_sF + 152);
  }
  v8 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v8 + 8456) = v5;
  *(_QWORD *)(v8 + 8432) = a3;
  *(_DWORD *)(v8 + 8480) = 0;
  *(_OWORD *)(v8 + 8464) = 0u;
  if ( **(_DWORD **)a1 == 1 )
    return 2;
  else
    return 13;
}

//----- (000000000002F0C0) ----------------------------------------------------
void *__fastcall sub_2F0C0(_QWORD *a1, int a2)
{
  _DWORD *v4; // x9
  void *result; // x0
  unsigned int v6; // w21
  unsigned int v7; // w20
  unsigned int max_rice_partition_order_from_blocksize; // w0
  unsigned int v9; // w8
  unsigned int v10; // w12
  __int64 v11; // x8
  int v12; // w10
  _BOOL4 v13; // w23
  int v14; // w10
  __int64 v15; // x24
  unsigned __int64 v16; // x25
  __int64 v17; // x26
  unsigned __int64 v18; // x10
  int32x4_t *v19; // x14
  int v20; // w15
  unsigned int v21; // w13
  unsigned int v22; // w13
  char v23; // w16
  __int64 v24; // x15
  int32x4_t v25; // q0
  int32x4_t *v26; // x16
  __int64 v27; // x17
  int32x4_t v28; // q3
  int32x4_t v29; // q2
  __int64 v30; // x12
  int *v31; // x14
  unsigned int v32; // w12
  __int64 v33; // x14
  __int64 v34; // x11
  int32x4_t *v35; // x12
  int v36; // w14
  unsigned int v37; // w13
  unsigned int v38; // w13
  char v39; // w15
  __int64 v40; // x14
  int32x4_t *v41; // x15
  int32x4_t v42; // q0
  __int64 v43; // x16
  int32x4_t v44; // q2
  __int64 v45; // x11
  int *v46; // x12
  unsigned int v47; // w11
  unsigned int v48; // w12
  __int64 v49; // x11
  int32x4_t *v50; // x13
  int v51; // w14
  unsigned int v52; // w12
  unsigned int v53; // w12
  char v54; // w15
  __int64 v55; // x14
  int32x4_t *v56; // x15
  int32x4_t v57; // q0
  __int64 v58; // x16
  int32x4_t v59; // q2
  __int64 v60; // x11
  int *v61; // x13
  unsigned int v62; // w11
  unsigned int v63; // w13
  __int64 v64; // x8
  __int64 v65; // x8
  int v66; // w20
  int v67; // w9
  int v68; // w10
  int v69; // w11
  unsigned int v70; // w13
  unsigned int v71; // w9
  unsigned int v72; // w10
  int v73; // w13
  unsigned int v74; // w11
  int v75; // w12
  __int64 v76; // x8
  unsigned int *v77; // x9
  _DWORD *v78; // x3
  _DWORD *v79; // x20
  unsigned int *v80; // x10
  unsigned int v81; // w0
  _DWORD *v82; // x8
  unsigned __int64 v83; // x20
  __int64 v84; // x21
  unsigned int v85; // w2
  unsigned int v86; // w21
  __int64 v87; // x8
  int v88; // w9
  int v89; // w9
  __int64 v90; // x8
  __int64 v91; // x0
  __int64 v92; // x8
  int v93; // w9
  __int64 v94; // x10
  unsigned int v95[3]; // [xsp+20h] [xbp-80h] BYREF
  int v96; // [xsp+2Ch] [xbp-74h]
  int v97; // [xsp+30h] [xbp-70h]
  int v98; // [xsp+34h] [xbp-6Ch]
  int v99; // [xsp+38h] [xbp-68h]
  __int64 v100; // [xsp+48h] [xbp-58h]

  v100 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = (_DWORD *)*a1;
  if ( *(_DWORD *)(*a1 + 12LL) )
  {
    result = FLAC__MD5Accumulate(
               a1[1] + 8184LL,
               (int32x4_t **)(a1[1] + 8LL),
               v4[6],
               v4[9],
               (unsigned int)(v4[7] + 7) >> 3);
    v4 = (_DWORD *)*a1;
    if ( !(_DWORD)result )
    {
      *v4 = 8;
      return result;
    }
  }
  v6 = v4[15];
  if ( a2 )
  {
    v7 = 0;
  }
  else
  {
    max_rice_partition_order_from_blocksize = FLAC__format_get_max_rice_partition_order_from_blocksize(v4[9]);
    v4 = (_DWORD *)*a1;
    if ( max_rice_partition_order_from_blocksize >= *(_DWORD *)(*a1 + 64LL) )
      v7 = *(_DWORD *)(*a1 + 64LL);
    else
      v7 = max_rice_partition_order_from_blocksize;
  }
  v9 = v4[8];
  v10 = v4[9];
  if ( v6 >= v7 )
    v6 = v7;
  v95[0] = v4[9];
  v95[1] = v9;
  v95[2] = v4[6];
  v96 = 0;
  v97 = v4[7];
  v98 = 0;
  v11 = a1[1];
  v99 = *(_DWORD *)(v11 + 8180);
  if ( v4[4] )
  {
    if ( !v4[5] || !*(_DWORD *)(v11 + 7980) )
    {
      v13 = 1;
      if ( !v4[6] )
        goto LABEL_47;
      goto LABEL_21;
    }
    v12 = *(_DWORD *)(v11 + 7984);
    v13 = v12 != 0;
    if ( v12 )
    {
      v14 = 0;
      if ( !v13 )
        goto LABEL_15;
      goto LABEL_48;
    }
  }
  else
  {
    v13 = 0;
  }
  if ( v4[6] )
  {
LABEL_21:
    v18 = 0;
    if ( v10 )
      goto LABEL_24;
LABEL_40:
    v22 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v32 = v4[7];
        v33 = v11 + 640 * v18;
        if ( v22 > v32 )
          v22 = v4[7];
        *(_DWORD *)(v33 + 920) = v22;
        *(_DWORD *)(v33 + 600) = v22;
        *(_DWORD *)(v11 + 4 * v18++ + 88) = v32 - v22;
        if ( v18 >= (unsigned int)v4[6] )
          goto LABEL_47;
        v10 = v4[9];
        if ( !v10 )
          goto LABEL_40;
LABEL_24:
        v19 = *(int32x4_t **)(v11 + 8 * v18 + 8);
        v20 = 0;
        v21 = 1;
        do
        {
          v20 |= v19->n128_u32[v21 - 1];
          if ( v21 >= v10 )
            break;
          ++v21;
        }
        while ( (v20 & 1) == 0 );
        v22 = 0;
        if ( v20 )
        {
          if ( (v20 & 1) == 0 )
          {
            v22 = 0;
            do
            {
              v23 = v20;
              v20 >>= 1;
              ++v22;
            }
            while ( (v23 & 2) == 0 );
            if ( v22 )
              break;
          }
        }
      }
      if ( v10 < 8 )
        break;
      v24 = v10 & 0xFFFFFFF8;
      v25 = vdupq_n_s32(v22);
      v26 = v19 + 1;
      v27 = v24;
      do
      {
        v28 = vnegq_s32(v25);
        v27 -= 8;
        v29 = vshlq_s32(*v26, v28);
        v26[-1] = vshlq_s32(v26[-1], v28);
        *v26 = v29;
        v26 += 2;
      }
      while ( v27 );
      if ( v24 != v10 )
      {
LABEL_37:
        v30 = v10 - v24;
        v31 = (int *)v19 + v24;
        do
        {
          --v30;
          *v31++ >>= v22;
        }
        while ( v30 );
      }
    }
    v24 = 0;
    goto LABEL_37;
  }
LABEL_47:
  v14 = 1;
  if ( !v13 )
  {
LABEL_15:
    if ( !v14 )
      goto LABEL_89;
    goto LABEL_16;
  }
LABEL_48:
  v34 = (unsigned int)v4[9];
  if ( (_DWORD)v34 )
  {
    v35 = *(int32x4_t **)(v11 + 72);
    v36 = 0;
    v37 = 1;
    do
    {
      v36 |= v35->n128_u32[v37 - 1];
      if ( v37 >= (unsigned int)v34 )
        break;
      ++v37;
    }
    while ( (v36 & 1) == 0 );
    v38 = 0;
    if ( v36 )
    {
      if ( (v36 & 1) == 0 )
      {
        v38 = 0;
        do
        {
          v39 = v36;
          v36 >>= 1;
          ++v38;
        }
        while ( (v39 & 2) == 0 );
        if ( v38 )
        {
          if ( (unsigned int)v34 >= 8 )
          {
            v40 = (unsigned int)v34 & 0xFFFFFFF8;
            v41 = v35 + 1;
            v42 = vnegq_s32(vdupq_n_s32(v38));
            v43 = v40;
            do
            {
              v43 -= 8;
              v44 = vshlq_s32(*v41, v42);
              v41[-1] = vshlq_s32(v41[-1], v42);
              *v41 = v44;
              v41 += 2;
            }
            while ( v43 );
            if ( v40 == v34 )
              goto LABEL_66;
          }
          else
          {
            v40 = 0;
          }
          v45 = v34 - v40;
          v46 = (int *)v35 + v40;
          do
          {
            --v45;
            *v46++ >>= v38;
          }
          while ( v45 );
        }
      }
    }
  }
  else
  {
    v38 = 0;
  }
LABEL_66:
  v47 = v4[7];
  if ( v38 <= v47 )
    v48 = v38;
  else
    v48 = v4[7];
  *(_DWORD *)(v11 + 6040) = v48;
  *(_DWORD *)(v11 + 5720) = v48;
  *(_DWORD *)(v11 + 120) = v47 - v48;
  v49 = (unsigned int)v4[9];
  if ( !(_DWORD)v49 )
  {
    v53 = 0;
    goto LABEL_86;
  }
  v50 = *(int32x4_t **)(v11 + 80);
  v51 = 0;
  v52 = 1;
  do
  {
    v51 |= v50->n128_u32[v52 - 1];
    if ( v52 >= (unsigned int)v49 )
      break;
    ++v52;
  }
  while ( (v51 & 1) == 0 );
  v53 = 0;
  if ( v51 )
  {
    if ( (v51 & 1) == 0 )
    {
      v53 = 0;
      do
      {
        v54 = v51;
        v51 >>= 1;
        ++v53;
      }
      while ( (v54 & 2) == 0 );
      if ( v53 )
      {
        if ( (unsigned int)v49 < 8 )
        {
          v55 = 0;
LABEL_84:
          v60 = v49 - v55;
          v61 = (int *)v50 + v55;
          do
          {
            --v60;
            *v61++ >>= v53;
          }
          while ( v60 );
          goto LABEL_86;
        }
        v55 = (unsigned int)v49 & 0xFFFFFFF8;
        v56 = v50 + 1;
        v57 = vnegq_s32(vdupq_n_s32(v53));
        v58 = v55;
        do
        {
          v58 -= 8;
          v59 = vshlq_s32(*v56, v57);
          v56[-1] = vshlq_s32(v56[-1], v57);
          *v56 = v59;
          v56 += 2;
        }
        while ( v58 );
        if ( v55 != v49 )
          goto LABEL_84;
      }
    }
  }
LABEL_86:
  v62 = v4[7];
  v63 = v62 + 1;
  if ( v53 <= v62 )
    v62 = v53;
  *(_DWORD *)(v11 + 6680) = v62;
  *(_DWORD *)(v11 + 6360) = v62;
  *(_DWORD *)(v11 + 124) = v63 - v62;
  if ( v14 )
  {
LABEL_16:
    if ( v4[6] )
    {
      v15 = 0;
      v16 = 0;
      v17 = 7912;
      do
      {
        sub_30D44(
          a1,
          v6,
          v7,
          v95,
          *(_DWORD *)(v11 + 4 * v16 + 88),
          *(_DWORD **)(v11 + 8 * v16 + 8),
          (__int64 *)(v11 + v15 + 6688),
          v11 + v15 + 7616,
          v11 + v15 + 128,
          (_BOOL4 *)(v11 + v17 - 40),
          (unsigned int *)(v11 + v17));
        v11 = a1[1];
        ++v16;
        v17 += 4;
        v15 += 16;
      }
      while ( v16 < *(unsigned int *)(*a1 + 24LL) );
    }
  }
LABEL_89:
  if ( !v13 )
  {
    v81 = (unsigned int)FLAC__frame_add_header((__int64)v95, *(_QWORD *)(v11 + 7968));
    v82 = (_DWORD *)*a1;
    if ( v81 )
    {
      if ( !v82[6] )
        goto LABEL_123;
      v83 = 0;
      v84 = 288;
      while ( (unsigned int)sub_3197C(
                              (_DWORD **)a1,
                              v95[0],
                              *(_DWORD *)(a1[1] + 4 * v83 + 88),
                              (_DWORD *)(a1[1] + 320LL * *(unsigned int *)(a1[1] + 4 * v83 + 7872) + v84),
                              *(_QWORD *)(a1[1] + 7968LL)) )
      {
        v82 = (_DWORD *)*a1;
        ++v83;
        v84 += 640;
        if ( v83 >= *(unsigned int *)(*a1 + 24LL) )
          goto LABEL_123;
      }
      return 0;
    }
LABEL_114:
    *v82 = 7;
    return 0;
  }
  sub_30D44(
    a1,
    v6,
    v7,
    v95,
    *(_DWORD *)(v11 + 120),
    *(_DWORD **)(v11 + 72),
    (__int64 *)(v11 + 6816),
    v11 + 7744,
    v11 + 256,
    (_BOOL4 *)(v11 + 7904),
    (unsigned int *)(v11 + 7944));
  v64 = a1[1];
  sub_30D44(
    a1,
    v6,
    v7,
    v95,
    *(_DWORD *)(v64 + 124),
    *(_DWORD **)(v64 + 80),
    (__int64 *)(v64 + 6832),
    v64 + 7760,
    v64 + 272,
    (_BOOL4 *)(v64 + 7908),
    (unsigned int *)(v64 + 7948));
  v65 = a1[1];
  if ( *(_DWORD *)(*a1 + 20LL) && *(_DWORD *)(v65 + 7980) )
  {
    if ( *(_DWORD *)(v65 + 7984) )
      v66 = 3;
    else
      v66 = 0;
  }
  else
  {
    v67 = *(_DWORD *)(v65 + 7912);
    v68 = *(_DWORD *)(v65 + 7916);
    v69 = *(_DWORD *)(v65 + 7948);
    v70 = v68 + v67;
    v71 = v69 + v67;
    v72 = v69 + v68;
    if ( v71 < v70 )
    {
      v73 = 1;
    }
    else
    {
      v71 = v70;
      v73 = 0;
    }
    v74 = *(_DWORD *)(v65 + 7944) + v69;
    if ( v72 >= v71 )
    {
      v75 = v73;
    }
    else
    {
      v71 = v72;
      v75 = 2;
    }
    if ( v74 >= v71 )
      v66 = v75;
    else
      v66 = 3;
  }
  v96 = v66;
  if ( !(unsigned int)FLAC__frame_add_header((__int64)v95, *(_QWORD *)(v65 + 7968)) )
  {
    v82 = (_DWORD *)*a1;
    goto LABEL_114;
  }
  switch ( v66 )
  {
    case 0:
      v76 = a1[1];
      v77 = (unsigned int *)(v76 + 88);
      v78 = (_DWORD *)(v76 + 288 + 320LL * *(unsigned int *)(v76 + 7872));
      v79 = (_DWORD *)(v76 + 288 + 320LL * *(unsigned int *)(v76 + 7876) + 640);
      v80 = (unsigned int *)(v76 + 92);
      goto LABEL_119;
    case 1:
      v76 = a1[1];
      v77 = (unsigned int *)(v76 + 88);
      v78 = (_DWORD *)(v76 + 320LL * *(unsigned int *)(v76 + 7872) + 288);
      v79 = (_DWORD *)(v76 + 320LL * *(unsigned int *)(v76 + 7908) + 6048);
      goto LABEL_118;
    case 2:
      v76 = a1[1];
      v77 = (unsigned int *)(v76 + 124);
      v78 = (_DWORD *)(v76 + 320LL * *(unsigned int *)(v76 + 7908) + 6048);
      v79 = (_DWORD *)(v76 + 320LL * *(unsigned int *)(v76 + 7876) + 928);
      v80 = (unsigned int *)(v76 + 92);
      goto LABEL_119;
    case 3:
      v76 = a1[1];
      v77 = (unsigned int *)(v76 + 120);
      v78 = (_DWORD *)(v76 + 5408 + 320LL * *(unsigned int *)(v76 + 7904));
      v79 = (_DWORD *)(v76 + 5408 + 320LL * *(unsigned int *)(v76 + 7908) + 640);
LABEL_118:
      v80 = (unsigned int *)(v76 + 124);
LABEL_119:
      v85 = *v77;
      v86 = *v80;
      break;
    default:
      v76 = a1[1];
      v79 = 0;
      v78 = 0;
      v85 = 0;
      v86 = 0;
      break;
  }
  if ( !(unsigned int)sub_3197C((_DWORD **)a1, v95[0], v85, v78, *(_QWORD *)(v76 + 7968))
    || !(unsigned int)sub_3197C((_DWORD **)a1, v95[0], v86, v79, *(_QWORD *)(a1[1] + 7968LL)) )
  {
    return 0;
  }
  v82 = (_DWORD *)*a1;
LABEL_123:
  if ( v82[5] )
  {
    v87 = a1[1];
    v88 = *(_DWORD *)(v87 + 7980);
    if ( (unsigned int)(v88 + 1) < *(_DWORD *)(v87 + 7976) )
      v89 = v88 + 1;
    else
      v89 = 0;
    *(_DWORD *)(v87 + 7980) = v89;
  }
  v90 = a1[1];
  v91 = *(_QWORD *)(v90 + 7968);
  *(_DWORD *)(v90 + 7984) = v96;
  result = FLAC__bitwriter_zero_pad_to_byte_boundary(v91);
  if ( !(_DWORD)result )
    goto LABEL_136;
  if ( !(unsigned int)FLAC__bitwriter_get_write_crc16(*(_QWORD *)(a1[1] + 7968LL), v95)
    || !(unsigned int)FLAC__bitwriter_write_raw_uint32(*(_QWORD *)(a1[1] + 7968LL), LOWORD(v95[0]), 0x10u) )
  {
    result = 0;
LABEL_136:
    *(_DWORD *)*a1 = 8;
    return result;
  }
  result = sub_30958((int **)a1, *(_DWORD *)(*a1 + 36LL));
  if ( (_DWORD)result )
  {
    v92 = a1[1];
    result = &dword_0 + 1;
    v93 = *(_DWORD *)(v92 + 8180);
    *(_DWORD *)(v92 + 8176) = 0;
    v94 = *(_QWORD *)(v92 + 8040);
    *(_DWORD *)(v92 + 8180) = v93 + 1;
    *(_QWORD *)(v92 + 8040) = v94 + *(unsigned int *)(*a1 + 36LL);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000002F948) ----------------------------------------------------
__int64 FLAC__stream_encoder_set_ogg_serial_number()
{
  return 0;
}

//----- (000000000002F950) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_verify(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[1] = a2;
  return result;
}

//----- (000000000002F974) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_streamable_subset(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[2] = a2;
  return result;
}

//----- (000000000002F998) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_do_md5(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[3] = a2;
  return result;
}

//----- (000000000002F9BC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_channels(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[6] = a2;
  return result;
}

//----- (000000000002F9E0) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_bits_per_sample(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[7] = a2;
  return result;
}

//----- (000000000002FA04) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_sample_rate(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[8] = a2;
  return result;
}

//----- (000000000002FA28) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_compression_level(_QWORD *a1, unsigned int a2)
{
  _DWORD *v2; // x8
  unsigned int v3; // w9
  char *v4; // x9
  __int64 v5; // x11
  int v6; // w12
  __int64 result; // x0
  int v8; // w10
  __int64 v9; // x9

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  if ( a2 >= 8 )
    v3 = 8;
  else
    v3 = a2;
  v4 = (char *)&unk_7E438 + 48 * v3;
  v5 = *((_QWORD *)v4 + 1);
  v6 = *((_DWORD *)v4 + 4);
  result = 1;
  *((_QWORD *)v2 + 2) = *(_QWORD *)v4;
  v8 = *((_DWORD *)v4 + 6);
  v9 = *(_QWORD *)(v4 + 28);
  *((_QWORD *)v2 + 5) = v5;
  v2[12] = v6;
  v2[13] = v8;
  *(_QWORD *)(v2 + 15) = v9;
  return result;
}

//----- (000000000002FA84) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_do_mid_side_stereo(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[4] = a2;
  return result;
}

//----- (000000000002FAA8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_loose_mid_side_stereo(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[5] = a2;
  return result;
}

//----- (000000000002FACC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_max_lpc_order(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[10] = a2;
  return result;
}

//----- (000000000002FAF0) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_qlp_coeff_precision(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[11] = a2;
  return result;
}

//----- (000000000002FB14) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_do_qlp_coeff_prec_search(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[12] = a2;
  return result;
}

//----- (000000000002FB38) ----------------------------------------------------
bool __fastcall FLAC__stream_encoder_set_do_escape_coding(_DWORD **a1)
{
  return **a1 == 1;
}

//----- (000000000002FB4C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_do_exhaustive_model_search(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[13] = a2;
  return result;
}

//----- (000000000002FB70) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_min_residual_partition_order(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[15] = a2;
  return result;
}

//----- (000000000002FB94) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_max_residual_partition_order(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[16] = a2;
  return result;
}

//----- (000000000002FBB8) ----------------------------------------------------
bool __fastcall FLAC__stream_encoder_set_rice_parameter_search_dist(_DWORD **a1)
{
  return **a1 == 1;
}

//----- (000000000002FBCC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_blocksize(_QWORD *a1, int a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v2[9] = a2;
  return result;
}

//----- (000000000002FBF0) ----------------------------------------------------
bool __fastcall FLAC__stream_encoder_set_apodization(_DWORD **a1)
{
  return **a1 == 1;
}

//----- (000000000002FC04) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_set_total_samples_estimate(_QWORD *a1, unsigned __int64 a2)
{
  _DWORD *v2; // x8
  __int64 result; // x0
  __int64 v4; // x9

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  result = 1;
  v4 = 0xFFFFFFFFFLL;
  if ( a2 < 0xFFFFFFFFFLL )
    v4 = a2;
  *((_QWORD *)v2 + 9) = v4;
  return result;
}

//----- (000000000002FC44) ----------------------------------------------------
void *__fastcall FLAC__stream_encoder_set_metadata(__int64 *a1, const void *a2, unsigned int a3)
{
  void *v5; // x0
  unsigned int v6; // w23
  __int64 v7; // x8
  void *result; // x0
  void *v9; // x22
  __int64 v10; // x8

  if ( *(_DWORD *)*a1 != 1 )
    return 0;
  v5 = *(void **)(*a1 + 80);
  if ( a2 )
    v6 = a3;
  else
    v6 = 0;
  if ( v5 )
  {
    free(v5);
    v7 = *a1;
    *(_QWORD *)(v7 + 80) = 0;
    *(_DWORD *)(v7 + 88) = 0;
  }
  if ( v6 )
  {
    result = safe_malloc_mul_2op_p(8u, v6);
    v9 = result;
    if ( !result )
      return result;
    memcpy(result, a2, 8LL * v6);
    v10 = *a1;
    *(_QWORD *)(v10 + 80) = v9;
    *(_DWORD *)(v10 + 88) = v6;
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (000000000002FCE8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_disable_constant_subframes(__int64 a1, int a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 1 )
    return 0;
  v2 = *(_QWORD *)(a1 + 8);
  result = 1;
  *(_DWORD *)(v2 + 8376) = a2;
  return result;
}

//----- (000000000002FD10) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_disable_fixed_subframes(__int64 a1, int a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 1 )
    return 0;
  v2 = *(_QWORD *)(a1 + 8);
  result = 1;
  *(_DWORD *)(v2 + 8380) = a2;
  return result;
}

//----- (000000000002FD38) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_disable_verbatim_subframes(__int64 a1, int a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  if ( **(_DWORD **)a1 != 1 )
    return 0;
  v2 = *(_QWORD *)(a1 + 8);
  result = 1;
  *(_DWORD *)(v2 + 8384) = a2;
  return result;
}

//----- (000000000002FD60) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_state(unsigned int **a1)
{
  return **a1;
}

//----- (000000000002FD6C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_verify_decoder_state(_QWORD *a1)
{
  if ( *(_DWORD *)(*a1 + 4LL) )
    return FLAC__stream_decoder_get_state(*(unsigned int ***)(a1[1] + 8792LL));
  else
    return 9;
}

//----- (000000000002FD8C) ----------------------------------------------------
char *__fastcall FLAC__stream_encoder_get_resolved_state_string(unsigned int **a1)
{
  __int64 v1; // x8

  v1 = **a1;
  if ( (_DWORD)v1 == 3 )
    return FLAC__stream_decoder_get_resolved_state_string(*((unsigned int ***)a1[1] + 1099));
  else
    return FLAC__StreamEncoderStateString[v1];
}
// 7E320: using guessed type char *FLAC__StreamEncoderStateString[35];

//----- (000000000002FDB8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_verify_decoder_error_stats(
        __int64 result,
        _QWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  if ( a2 )
    *a2 = *(_QWORD *)(*(_QWORD *)(result + 8) + 8896LL);
  if ( a3 )
    *a3 = *(_DWORD *)(*(_QWORD *)(result + 8) + 8904LL);
  if ( a4 )
    *a4 = *(_DWORD *)(*(_QWORD *)(result + 8) + 8908LL);
  if ( a5 )
    *a5 = *(_DWORD *)(*(_QWORD *)(result + 8) + 8912LL);
  if ( a6 )
    *a6 = *(_DWORD *)(*(_QWORD *)(result + 8) + 8916LL);
  if ( a7 )
    *a7 = *(_DWORD *)(*(_QWORD *)(result + 8) + 8920LL);
  return result;
}

//----- (000000000002FE1C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_verify(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 4LL);
}

//----- (000000000002FE28) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_streamable_subset(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 8LL);
}

//----- (000000000002FE34) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_do_md5(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 12LL);
}

//----- (000000000002FE40) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_channels(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 24LL);
}

//----- (000000000002FE4C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_bits_per_sample(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 28LL);
}

//----- (000000000002FE58) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_sample_rate(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 32LL);
}

//----- (000000000002FE64) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_blocksize(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 36LL);
}

//----- (000000000002FE70) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_do_mid_side_stereo(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 16LL);
}

//----- (000000000002FE7C) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_loose_mid_side_stereo(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 20LL);
}

//----- (000000000002FE88) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_max_lpc_order(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 40LL);
}

//----- (000000000002FE94) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_qlp_coeff_precision(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 44LL);
}

//----- (000000000002FEA0) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_do_qlp_coeff_prec_search(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 48LL);
}

//----- (000000000002FEAC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_do_escape_coding(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 56LL);
}

//----- (000000000002FEB8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_do_exhaustive_model_search(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 52LL);
}

//----- (000000000002FEC4) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_min_residual_partition_order(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 60LL);
}

//----- (000000000002FED0) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_max_residual_partition_order(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 64LL);
}

//----- (000000000002FEDC) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_rice_parameter_search_dist(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 68LL);
}

//----- (000000000002FEE8) ----------------------------------------------------
__int64 __fastcall FLAC__stream_encoder_get_total_samples_estimate(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 72LL);
}

//----- (000000000002FEF4) ----------------------------------------------------
void *__fastcall FLAC__stream_encoder_process(_QWORD *a1, __int64 *a2, unsigned int a3)
{
  __int64 v4; // x8
  __int64 v5; // x26
  unsigned int v6; // w20
  __int64 *v7; // x27
  unsigned __int64 v8; // x23
  __int64 v9; // x25
  __int64 v10; // x24
  unsigned __int64 v11; // x28
  int v12; // w10
  int v13; // w8
  unsigned int v14; // w9
  __int64 *v15; // x20
  __int64 v16; // x27
  size_t v17; // x22
  __int64 *v18; // x28
  __int64 v19; // x8
  __int64 v20; // t1
  __int64 v21; // t1
  __int64 v22; // x19
  __int64 v23; // x8
  unsigned int *v24; // x9
  unsigned int v25; // w10
  __int64 v26; // x11
  __int64 v27; // x12
  __int64 v28; // x13
  __int64 v29; // x14
  __int64 v30; // x15
  int v31; // w16
  int v32; // w17
  __int64 v33; // x18
  unsigned int v34; // w11
  unsigned int v35; // w10
  void *result; // x0
  __int64 v37; // x9
  _DWORD **v38; // x8
  _DWORD *v39; // t1
  unsigned __int64 v40; // [xsp+0h] [xbp-70h]
  unsigned int v43; // [xsp+1Ch] [xbp-54h]

  v4 = *a1;
  v5 = a1[1];
  v6 = a3;
  v7 = a2;
  LODWORD(v8) = 0;
  v9 = *(unsigned int *)(*a1 + 36LL);
  v10 = *(unsigned int *)(*a1 + 24LL);
  v11 = a3;
  v12 = v9 + 1;
  v40 = a3;
  while ( 1 )
  {
    v13 = *(_DWORD *)(v4 + 4);
    v14 = v12 - *(_DWORD *)(v5 + 8176);
    if ( v14 >= v6 - (unsigned int)v8 )
      v14 = v6 - v8;
    v43 = v14;
    if ( v13 )
    {
      if ( (_DWORD)v10 )
      {
        v15 = a2;
        v16 = v10;
        v17 = 4LL * v14;
        v18 = (__int64 *)(v5 + 8808);
        do
        {
          v20 = *v18++;
          v19 = v20;
          v21 = *v15++;
          memcpy((void *)(v19 + 4LL * *(unsigned int *)(v5 + 8876)), (const void *)(v21 + 4LL * (unsigned int)v8), v17);
          --v16;
        }
        while ( v16 );
      }
      v6 = a3;
      v7 = a2;
      v11 = v40;
      *(_DWORD *)(v5 + 8876) += v43;
    }
    if ( (_DWORD)v10 )
      break;
LABEL_13:
    v4 = *a1;
    if ( *(_DWORD *)(*a1 + 16LL) )
    {
      v5 = a1[1];
      v24 = (unsigned int *)(v5 + 8176);
      if ( (unsigned int)v8 < v6 )
      {
        v25 = *(_DWORD *)(v5 + 8176);
        if ( v25 <= (unsigned int)v9 )
        {
          v26 = *v7;
          v27 = v7[1];
          v28 = *(_QWORD *)(v5 + 72);
          v29 = *(_QWORD *)(v5 + 80);
          v8 = (unsigned int)v8;
          do
          {
            v30 = 4 * v8;
            v31 = *(_DWORD *)(v26 + 4 * v8);
            v32 = *(_DWORD *)(v27 + 4 * v8);
            v33 = 4LL * v25;
            ++v8;
            *(_DWORD *)(v29 + v33) = v31 - v32;
            *(_DWORD *)(v28 + v33) = (*(_DWORD *)(v27 + v30) + *(_DWORD *)(v26 + v30)) >> 1;
            if ( v8 >= v11 )
              break;
            ++v25;
          }
          while ( v25 <= (unsigned int)v9 );
        }
      }
      v34 = v43;
    }
    else
    {
      v5 = a1[1];
      v34 = v43;
      v24 = (unsigned int *)(v5 + 8176);
      LODWORD(v8) = v43 + v8;
    }
    v35 = *v24 + v34;
    *v24 = v35;
    if ( v35 > (unsigned int)v9 )
    {
      result = sub_2F0C0(a1, 0);
      if ( !(_DWORD)result )
        return result;
      if ( (_DWORD)v10 )
      {
        v37 = v10;
        v38 = (_DWORD **)(a1[1] + 8LL);
        do
        {
          v39 = *v38++;
          --v37;
          *v39 = v39[v9];
        }
        while ( v37 );
      }
      v4 = *a1;
      v5 = a1[1];
      if ( *(_DWORD *)(*a1 + 16LL) )
      {
        **(_DWORD **)(v5 + 72) = *(_DWORD *)(*(_QWORD *)(v5 + 72) + 4 * v9);
        **(_DWORD **)(v5 + 80) = *(_DWORD *)(*(_QWORD *)(v5 + 80) + 4 * v9);
      }
      *(_DWORD *)(v5 + 8176) = 1;
    }
    v12 = v9 + 1;
    if ( (unsigned int)v8 >= v6 )
      return &dword_0 + 1;
  }
  v22 = 0;
  while ( 1 )
  {
    v23 = v7[v22];
    if ( !v23 )
      return 0;
    memcpy(
      (void *)(*(_QWORD *)(a1[1] + 8 * v22++ + 8) + 4LL * *(unsigned int *)(a1[1] + 8176LL)),
      (const void *)(v23 + 4LL * (unsigned int)v8),
      4LL * v43);
    if ( (unsigned int)v22 >= (unsigned int)v10 )
      goto LABEL_13;
  }
}
// 0: using guessed type int dword_0;

//----- (0000000000030160) ----------------------------------------------------
void *__fastcall FLAC__stream_encoder_process_interleaved(_QWORD *a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // x8
  __int64 v7; // x24
  __int64 v8; // x22
  int v9; // w23
  unsigned int v10; // w24
  unsigned int v11; // w25
  int v12; // w9
  __int64 v13; // x8
  unsigned int v14; // w10
  int v15; // w9
  __int64 v16; // x11
  __int64 v17; // x12
  unsigned int v18; // w13
  unsigned int v19; // w14
  unsigned int v20; // w15
  __int64 v21; // x17
  int v22; // w16
  unsigned int v23; // w9
  _BOOL4 v24; // w28
  __int64 v25; // x10
  __int64 v26; // x11
  __int64 v27; // x12
  __int64 v28; // x13
  int v29; // w15
  __int64 v30; // x16
  int v31; // w14
  void *result; // x0
  __int64 v33; // x8
  unsigned int v34; // w25
  unsigned int v35; // w26
  int v36; // w9
  __int64 v37; // x8
  unsigned int v38; // w10
  int v39; // w9
  int v40; // w11
  unsigned int v41; // w12
  unsigned int v42; // w14
  __int64 v43; // x15
  __int64 *v44; // x16
  unsigned int v45; // w17
  int v46; // w18
  __int64 v47; // t1
  unsigned int v48; // w9
  _BOOL4 v49; // w27
  __int64 v50; // x11
  __int64 *v51; // x12
  unsigned int v52; // w13
  int v53; // w14
  __int64 v54; // t1
  __int64 v55; // x8
  __int64 v56; // x10
  _DWORD **v57; // x9
  _DWORD *v58; // t1

  v4 = *a1;
  v7 = *(unsigned int *)(*a1 + 24LL);
  v8 = *(unsigned int *)(*a1 + 36LL);
  v9 = v8 + 1;
  if ( (_DWORD)v7 == 2 && *(_DWORD *)(v4 + 16) )
  {
    v10 = 0;
    v11 = 0;
    v12 = *(_DWORD *)(v4 + 4);
    v13 = a1[1];
    if ( v12 )
      goto LABEL_6;
    while ( 1 )
    {
      v23 = *(_DWORD *)(v13 + 8176);
      v24 = v11 < a3;
      if ( v11 < a3 && v23 <= (unsigned int)v8 )
      {
        v25 = *(_QWORD *)(v13 + 8);
        v26 = *(_QWORD *)(v13 + 16);
        v27 = *(_QWORD *)(v13 + 72);
        v28 = *(_QWORD *)(v13 + 80);
        do
        {
          v29 = *(_DWORD *)(a2 + 4LL * v10);
          v30 = 4LL * v23;
          *(_DWORD *)(v25 + v30) = v29;
          v31 = *(_DWORD *)(a2 + 4LL * (v10 + 1));
          ++v11;
          v10 += 2;
          ++v23;
          *(_DWORD *)(v26 + v30) = v31;
          v24 = v11 < a3;
          *(_DWORD *)(v28 + v30) = v29 - v31;
          *(_DWORD *)(v27 + v30) = (v31 + v29) >> 1;
        }
        while ( v11 < a3 && v23 <= (unsigned int)v8 );
      }
      *(_DWORD *)(v13 + 8176) = v23;
      if ( v23 > (unsigned int)v8 )
      {
        result = sub_2F0C0(a1, 0);
        if ( !(_DWORD)result )
          return result;
        v33 = a1[1];
        **(_DWORD **)(v33 + 8) = *(_DWORD *)(*(_QWORD *)(v33 + 8) + 4 * v8);
        **(_DWORD **)(v33 + 16) = *(_DWORD *)(*(_QWORD *)(v33 + 16) + 4 * v8);
        **(_DWORD **)(v33 + 72) = *(_DWORD *)(*(_QWORD *)(v33 + 72) + 4 * v8);
        **(_DWORD **)(v33 + 80) = *(_DWORD *)(*(_QWORD *)(v33 + 80) + 4 * v8);
        *(_DWORD *)(v33 + 8176) = 1;
      }
      if ( !v24 )
        break;
      v13 = a1[1];
      if ( *(_DWORD *)(*a1 + 4LL) )
      {
LABEL_6:
        v14 = a3 - v11;
        v15 = *(_DWORD *)(v13 + 8876);
        if ( v9 - *(_DWORD *)(v13 + 8176) < a3 - v11 )
          v14 = v9 - *(_DWORD *)(v13 + 8176);
        if ( v14 )
        {
          v16 = *(_QWORD *)(v13 + 8808);
          v17 = *(_QWORD *)(v13 + 8816);
          v18 = (2 * v11) | 1;
          v19 = v14;
          v20 = *(_DWORD *)(v13 + 8876);
          do
          {
            v21 = 4LL * v20++;
            *(_DWORD *)(v16 + v21) = *(_DWORD *)(a2 + 4LL * (v18 - 1));
            v22 = *(_DWORD *)(a2 + 4LL * v18);
            --v19;
            v18 += 2;
            *(_DWORD *)(v17 + v21) = v22;
          }
          while ( v19 );
          v15 += v14;
        }
        *(_DWORD *)(v13 + 8876) = v15;
      }
    }
  }
  else
  {
    v34 = 0;
    v35 = 0;
    v36 = *(_DWORD *)(v4 + 4);
    v37 = a1[1];
    if ( v36 )
      goto LABEL_26;
    while ( 1 )
    {
      v48 = *(_DWORD *)(v37 + 8176);
      v49 = v35 < a3;
      if ( v35 < a3 && v48 <= (unsigned int)v8 )
      {
        if ( (_DWORD)v7 )
        {
          do
          {
            v50 = v7;
            v51 = (__int64 *)(v37 + 8);
            v52 = v34;
            do
            {
              v53 = *(_DWORD *)(a2 + 4LL * v52);
              v54 = *v51++;
              ++v52;
              --v50;
              *(_DWORD *)(v54 + 4LL * v48) = v53;
            }
            while ( v50 );
            ++v35;
            v34 += v7;
            ++v48;
            v49 = v35 < a3;
          }
          while ( v35 < a3 && v48 <= (unsigned int)v8 );
        }
        else
        {
          do
          {
            ++v35;
            ++v48;
            v49 = v35 < a3;
          }
          while ( v35 < a3 && v48 <= (unsigned int)v8 );
        }
      }
      *(_DWORD *)(v37 + 8176) = v48;
      if ( v48 > (unsigned int)v8 )
      {
        result = sub_2F0C0(a1, 0);
        if ( !(_DWORD)result )
          return result;
        v55 = a1[1];
        if ( (_DWORD)v7 )
        {
          **(_DWORD **)(v55 + 8) = *(_DWORD *)(*(_QWORD *)(v55 + 8) + 4 * v8);
          if ( (_DWORD)v7 != 1 )
          {
            v56 = v7 - 1;
            v57 = (_DWORD **)(v55 + 16);
            do
            {
              v58 = *v57++;
              --v56;
              *v58 = v58[v8];
            }
            while ( v56 );
          }
        }
        *(_DWORD *)(v55 + 8176) = 1;
      }
      if ( !v49 )
        break;
      v37 = a1[1];
      if ( *(_DWORD *)(*a1 + 4LL) )
      {
LABEL_26:
        v38 = a3 - v35;
        v39 = *(_DWORD *)(v37 + 8876);
        if ( v9 - *(_DWORD *)(v37 + 8176) < a3 - v35 )
          v38 = v9 - *(_DWORD *)(v37 + 8176);
        if ( v38 )
        {
          if ( (_DWORD)v7 )
          {
            v40 = 0;
            v41 = v35 * v7;
            v42 = *(_DWORD *)(v37 + 8876);
            do
            {
              v43 = v7;
              v44 = (__int64 *)(v37 + 8808);
              v45 = v41;
              do
              {
                v46 = *(_DWORD *)(a2 + 4LL * v45);
                v47 = *v44++;
                ++v45;
                --v43;
                *(_DWORD *)(v47 + 4LL * v42) = v46;
              }
              while ( v43 );
              ++v40;
              v41 += v7;
              ++v42;
            }
            while ( v40 != v38 );
          }
          v39 += v38;
        }
        *(_DWORD *)(v37 + 8876) = v39;
      }
    }
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (00000000000304C4) ----------------------------------------------------
__int64 __fastcall sub_304C4(__int64 result, __int64 a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v7; // w9
  unsigned __int64 v8; // x8
  int v9; // w10
  unsigned int v10; // w11
  unsigned int v11; // w14
  unsigned __int64 v12; // x12
  unsigned int v13; // w15
  __int64 v14; // x17
  unsigned __int64 v15; // x15
  unsigned int v16; // w16
  __int64 v17; // x2
  int32x4_t *v18; // x18
  int32x4_t v19; // q0
  unsigned __int64 v20; // x2
  int32x4_t v21; // q1
  int32x4_t v22; // q2
  int32x4_t v23; // q3
  bool v24; // zf
  int *v25; // x15
  __int64 v26; // x17
  int v27; // w18
  int v28; // t1
  __int64 v29; // x17
  unsigned __int64 v30; // x15
  __int64 v31; // x16
  __int64 v32; // x2
  unsigned __int64 *v33; // x18
  int64x2_t v34; // q0
  unsigned __int64 v35; // x2
  int64x2_t v36; // q1
  int32x2_t v37; // d2
  int32x2_t v38; // d3
  int *v39; // x15
  __int64 v40; // x17
  int v41; // w18
  int v42; // t1
  unsigned int v43; // w9
  unsigned int v44; // w11
  unsigned int v45; // w10
  unsigned int v46; // w11
  unsigned int v47; // w12
  unsigned int v48; // w14
  unsigned int v49; // w13
  __int64 v50; // x15
  __int64 v51; // x16

  v7 = (unsigned int)(a4 + a3) >> a6;
  v8 = (unsigned int)(1 << a6);
  v9 = v7 - a4;
  v10 = -a4;
  v11 = v7 - a4;
  v12 = 0;
  v13 = 0;
  if ( a7 + 4 < 32 - (__clz(v7) ^ 0x1F) )
  {
    while ( 1 )
    {
      v10 += v7;
      if ( v13 >= v10 )
      {
        v16 = 0;
      }
      else
      {
        v14 = v13;
        v15 = v9 + (unsigned int)v12 * v7 - (unsigned __int64)v13;
        if ( v15 < 8 )
        {
          v16 = 0;
LABEL_9:
          v25 = (int *)(result + 4 * v14);
          v26 = v11 - v14;
          do
          {
            v28 = *v25++;
            v27 = v28;
            if ( v28 < 0 )
              v27 = -v27;
            --v26;
            v16 += v27;
          }
          while ( v26 );
          v13 = v10;
          goto LABEL_14;
        }
        v17 = v11 - v14;
        v18 = (int32x4_t *)(result + 16 + 4 * v14);
        v19 = 0u;
        v14 += v15 & 0xFFFFFFFFFFFFFFF8LL;
        v20 = v17 & 0xFFFFFFFFFFFFFFF8LL;
        v21 = 0u;
        do
        {
          v22 = v18[-1];
          v23 = *v18;
          v20 -= 8LL;
          v18 += 2;
          v19 = vaddq_s32(vabsq_s32(v22), v19);
          v21 = vaddq_s32(vabsq_s32(v23), v21);
        }
        while ( v20 );
        v24 = v15 == (v15 & 0xFFFFFFFFFFFFFFF8LL);
        v16 = vaddvq_s32(vaddq_s32(v21, v19));
        v13 = v10;
        if ( !v24 )
          goto LABEL_9;
      }
LABEL_14:
      *(_QWORD *)(a2 + 8 * v12++) = v16;
      v11 += v7;
      if ( v12 >= v8 )
        goto LABEL_29;
    }
  }
  do
  {
    v10 += v7;
    if ( v13 >= v10 )
    {
      v31 = 0;
      goto LABEL_28;
    }
    v29 = v13;
    v30 = v9 + (unsigned int)v12 * v7 - (unsigned __int64)v13;
    if ( v30 >= 4 )
    {
      v32 = v11 - v29;
      v33 = (unsigned __int64 *)(result + 8 + 4 * v29);
      v34 = 0u;
      v29 += v30 & 0xFFFFFFFFFFFFFFFCLL;
      v35 = v32 & 0xFFFFFFFFFFFFFFFCLL;
      v36 = 0u;
      do
      {
        v37.n64_u64[0] = *(v33 - 1);
        v38.n64_u64[0] = *v33;
        v35 -= 4LL;
        v33 += 2;
        v34 = vaddw_s32(v34, vabs_s32(v37));
        v36 = vaddw_s32(v36, vabs_s32(v38));
      }
      while ( v35 );
      v24 = v30 == (v30 & 0xFFFFFFFFFFFFFFFCLL);
      v31 = vaddvq_s64(vaddq_s64(v36, v34));
      v13 = v10;
      if ( v24 )
        goto LABEL_28;
    }
    else
    {
      v31 = 0;
    }
    v39 = (int *)(result + 4 * v29);
    v40 = v11 - v29;
    do
    {
      v42 = *v39++;
      v41 = v42;
      if ( v42 < 0 )
        v41 = -v41;
      --v40;
      v31 += v41;
    }
    while ( v40 );
    v13 = v10;
LABEL_28:
    *(_QWORD *)(a2 + 8 * v12++) = v31;
    v11 += v7;
  }
  while ( v12 < v8 );
LABEL_29:
  if ( a6 > a5 )
  {
    v43 = 0;
    v44 = 1 << a6;
    do
    {
      v45 = v44 >> 1;
      --a6;
      if ( v44 >> 1 )
      {
        v46 = v44 & 0xFFFFFFFE;
        v47 = v45;
        v48 = v8;
        v49 = v43;
        do
        {
          v50 = *(_QWORD *)(a2 + 8LL * v49);
          v51 = *(_QWORD *)(a2 + 8LL * (v49 + 1));
          --v47;
          v49 += 2;
          *(_QWORD *)(a2 + 8LL * v48++) = v51 + v50;
        }
        while ( v47 );
        LODWORD(v8) = v8 + v45;
        v43 += v46;
      }
      v44 = v45;
    }
    while ( a6 > a5 );
  }
  return result;
}

//----- (00000000000306FC) ----------------------------------------------------
__int64 __fastcall sub_306FC(__int64 a1, _DWORD *a2, size_t *a3, __int64 a4)
{
  __int64 v5; // x8
  __int64 result; // x0
  size_t v8; // x9
  size_t v9; // x2
  __int64 v10; // x8
  int v11; // w9

  v5 = *(_QWORD *)(a4 + 8);
  if ( *(_DWORD *)(v5 + 8804) )
  {
    result = 0;
    *a3 = 4;
    *a2 = 1130450022;
    *(_DWORD *)(*(_QWORD *)(a4 + 8) + 8804LL) = 0;
  }
  else
  {
    v8 = *(unsigned int *)(v5 + 8892);
    if ( (_DWORD)v8 )
    {
      v9 = *a3;
      if ( *a3 > v8 )
      {
        v9 = *(unsigned int *)(v5 + 8892);
        *a3 = v8;
      }
      memcpy(a2, *(const void **)(v5 + 8880), v9);
      v10 = *(_QWORD *)(a4 + 8);
      result = 0;
      v11 = *(_DWORD *)(v10 + 8892) - *a3;
      *(_QWORD *)(v10 + 8880) += *a3;
      *(_DWORD *)(v10 + 8892) = v11;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

//----- (00000000000307B8) ----------------------------------------------------
__int64 __fastcall sub_307B8(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v5; // x28
  unsigned __int64 v6; // x25
  __int64 v8; // x26
  __int64 v9; // x27
  const void *v10; // x22
  const void *v11; // x23
  unsigned int v12; // w8
  __int64 v13; // x20
  __int64 result; // x0
  __int64 v15; // x8
  int v16; // w10
  int v17; // w9
  unsigned __int64 v18; // x11

  v5 = a2[2];
  v6 = *a2;
  if ( (_DWORD)v5 )
  {
    v8 = *(_QWORD *)(a4 + 8);
    v9 = 0;
    while ( 1 )
    {
      v10 = *(const void **)(a3 + 8 * v9);
      v11 = *(const void **)(v8 + 8808 + 8 * v9);
      if ( memcmp(v10, v11, (unsigned int)(4 * v6)) )
        break;
      if ( ++v9 >= v5 )
      {
        v12 = *(_DWORD *)(v8 + 8876) - v6;
        *(_DWORD *)(v8 + 8876) = v12;
        memmove(*(void **)(v8 + 8808), (const void *)(*(_QWORD *)(v8 + 8808) + 4 * v6), 4LL * v12);
        if ( (_DWORD)v5 != 1 )
        {
          v13 = 1102;
          do
          {
            memmove(
              *(void **)(*(_QWORD *)(a4 + 8) + 8 * v13),
              (const void *)(*(_QWORD *)(*(_QWORD *)(a4 + 8) + 8 * v13) + 4 * v6),
              4LL * *(unsigned int *)(*(_QWORD *)(a4 + 8) + 8876LL));
            ++v13;
          }
          while ( 1 - v5 + v13 != 1102 );
        }
        return 0;
      }
    }
    if ( (_DWORD)v6 )
    {
      v15 = 0;
      while ( 1 )
      {
        v16 = *((_DWORD *)v10 + v15);
        v17 = *((_DWORD *)v11 + v15);
        if ( v16 != v17 )
          break;
        if ( (unsigned int)++v15 >= (unsigned int)v6 )
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      LODWORD(v15) = 0;
      v17 = 0;
      v16 = 0;
    }
    result = 1;
    *(_QWORD *)(v8 + 8896) = *((_QWORD *)a2 + 3) + (unsigned int)v15;
    v18 = *((_QWORD *)a2 + 3);
    *(_DWORD *)(v8 + 8912) = v15;
    *(_DWORD *)(v8 + 8908) = v9;
    *(_DWORD *)(v8 + 8916) = v17;
    *(_DWORD *)(v8 + 8920) = v16;
    *(_DWORD *)(v8 + 8904) = v18 / v6;
    **(_DWORD **)a4 = 4;
  }
  else
  {
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a4 + 8) + 8876LL) -= v6;
  }
  return result;
}
// 3083C: conditional instruction was optimized away because w28.4!=0

//----- (0000000000030948) ----------------------------------------------------
void __fastcall sub_30948(__int64 a1, __int64 a2, _DWORD **a3)
{
  **a3 = 3;
}

//----- (0000000000030958) ----------------------------------------------------
void *__fastcall sub_30958(int **a1, unsigned int a2)
{
  void *result; // x0
  int *v5; // x8
  int *v6; // x8
  int v7; // w10
  int v8; // w9
  int *v9; // x9
  unsigned __int64 v10; // x21
  _BYTE *v11; // x22
  unsigned int (__fastcall *v12)(int **, _QWORD *, _QWORD); // x8
  int *v13; // x8
  __int64 v14; // x14
  __int64 v15; // x9
  unsigned int v16; // w10
  __int64 v17; // x11
  __int64 v18; // x12
  unsigned __int64 v19; // x13
  __int64 v20; // x15
  __int64 v21; // x16
  int *v22; // x8
  int v23; // w12
  unsigned int v24; // w11
  __int64 v25; // x10
  unsigned int v26; // w9
  int *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // x10
  int *v30; // x8
  unsigned __int64 v31; // [xsp+0h] [xbp-50h] BYREF
  _BYTE *v32; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v33[2]; // [xsp+10h] [xbp-40h] BYREF

  v33[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitwriter_get_buffer(*((_QWORD *)a1[1] + 996), &v32, &v31);
  v5 = *a1;
  if ( !(_DWORD)result )
  {
    v8 = 8;
LABEL_30:
    *v5 = v8;
    return result;
  }
  if ( v5[1] )
  {
    v6 = a1[1];
    *((_QWORD *)v6 + 1110) = v32;
    v7 = v6[2200];
    v6[2223] = v31;
    if ( v7 )
    {
      if ( !(unsigned int)FLAC__stream_decoder_process_single(*((_DWORD ***)v6 + 1099)) )
      {
        FLAC__bitwriter_release_buffer();
        FLAC__bitwriter_clear(*((_QWORD *)a1[1] + 996));
        v5 = *a1;
        if ( **a1 == 4 )
          return 0;
        result = 0;
        v8 = 3;
        goto LABEL_30;
      }
    }
    else
    {
      v6[2201] = 1;
    }
  }
  v33[0] = 0;
  v9 = a1[1];
  v10 = v31;
  v11 = v32;
  v12 = (unsigned int (__fastcall *)(int **, _QWORD *, _QWORD))*((_QWORD *)v9 + 1051);
  if ( v12 && v12(a1, v33, *((_QWORD *)v9 + 1055)) == 1 )
  {
LABEL_29:
    **a1 = 5;
    FLAC__bitwriter_release_buffer();
    FLAC__bitwriter_clear(*((_QWORD *)a1[1] + 996));
    v5 = *a1;
    result = 0;
    v8 = 5;
    goto LABEL_30;
  }
  if ( !a2 )
  {
    if ( (*v11 & 0x7F) == 3 )
    {
      if ( !*((_QWORD *)*a1 + 13) )
      {
        *((_QWORD *)*a1 + 13) = v33[0];
        v13 = a1[1];
        v14 = *((_QWORD *)v13 + 1021);
        if ( !v14 )
          goto LABEL_28;
        goto LABEL_13;
      }
    }
    else if ( (*v11 & 0x7F) == 0 )
    {
      *((_QWORD *)*a1 + 12) = v33[0];
      v13 = a1[1];
      v14 = *((_QWORD *)v13 + 1021);
      if ( !v14 )
        goto LABEL_28;
      goto LABEL_13;
    }
  }
  v13 = a1[1];
  v14 = *((_QWORD *)v13 + 1021);
  if ( !v14 )
    goto LABEL_28;
LABEL_13:
  v15 = *((_QWORD *)*a1 + 14);
  if ( v15 )
  {
    v16 = *(_DWORD *)v14;
    if ( *(_DWORD *)v14 )
    {
      v17 = (unsigned int)v13[2112];
      if ( (unsigned int)v17 < v16 )
      {
        v18 = (unsigned int)(*a1)[9];
        v19 = *((_QWORD *)v13 + 1059);
        v20 = *(_QWORD *)(v14 + 8) + 24 * v17;
        do
        {
          if ( *(_QWORD *)v20 > v18 + v19 - 1 )
            break;
          if ( *(_QWORD *)v20 >= v19 )
          {
            *(_QWORD *)v20 = v19;
            v21 = v33[0];
            *(_DWORD *)(v20 + 16) = v18;
            *(_QWORD *)(v20 + 8) = v21 - v15;
          }
          LODWORD(v17) = v17 + 1;
          v20 += 24;
          v13[2112] = v17;
        }
        while ( (unsigned int)v17 < v16 );
      }
    }
  }
LABEL_28:
  if ( (*((unsigned int (__fastcall **)(int **, _BYTE *, unsigned __int64, _QWORD, _QWORD, _QWORD))v13 + 1052))(
         a1,
         v11,
         v10,
         a2,
         (unsigned int)v13[2045],
         *((_QWORD *)v13 + 1055)) )
  {
    goto LABEL_29;
  }
  v22 = a1[1];
  v23 = v22[2045];
  v24 = v22[2120];
  v25 = *((_QWORD *)v22 + 1059) + a2;
  *((_QWORD *)v22 + 1058) += v10;
  if ( v24 <= v23 + 1 )
    v26 = v23 + 1;
  else
    v26 = v24;
  *((_QWORD *)v22 + 1059) = v25;
  v22[2120] = v26;
  FLAC__bitwriter_release_buffer();
  FLAC__bitwriter_clear(*((_QWORD *)a1[1] + 996));
  if ( a2 )
  {
    v27 = a1[1];
    v28 = v31;
    v29 = (unsigned int)v27[2004];
    if ( v31 < v29 )
      LODWORD(v29) = v31;
    v27[2004] = v29;
    v30 = a1[1];
    if ( v28 <= (unsigned int)v30[2005] )
      LODWORD(v28) = v30[2005];
    v30[2005] = v28;
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000030C44) ----------------------------------------------------
__int64 __fastcall sub_30C44(__int64 a1, const void *a2, size_t a3, unsigned int a4)
{
  unsigned int v7; // w22
  __int64 v8; // x9
  void (__fastcall *v9)(__int64, size_t, _QWORD, _QWORD, _QWORD, _QWORD); // x8

  v7 = 1;
  if ( fwrite(a2, 1u, a3, *(FILE **)(*(_QWORD *)(a1 + 8) + 8456LL)) == a3 )
  {
    v7 = 0;
    if ( a4 )
    {
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(void (__fastcall **)(__int64, size_t, _QWORD, _QWORD, _QWORD, _QWORD))(v8 + 8432);
      if ( v9 )
      {
        v9(
          a1,
          *(_QWORD *)(v8 + 8464) + a3,
          *(_QWORD *)(v8 + 8472) + a4,
          (unsigned int)(*(_DWORD *)(v8 + 8480) + 1),
          *(unsigned int *)(v8 + 8484),
          *(_QWORD *)(v8 + 8440));
        return 0;
      }
    }
  }
  return v7;
}

//----- (0000000000030CD8) ----------------------------------------------------
__int64 __fastcall sub_30CD8(__int64 a1, __off_t a2)
{
  return (unsigned int)fseeko(*(FILE **)(*(_QWORD *)(a1 + 8) + 8456LL), a2, 0) >> 31;
}

//----- (0000000000030CFC) ----------------------------------------------------
__int64 __fastcall sub_30CFC(__int64 a1, __off_t *a2)
{
  __off_t v3; // x8
  __int64 result; // x0

  v3 = ftello(*(FILE **)(*(_QWORD *)(a1 + 8) + 8456LL));
  if ( v3 < 0 )
    return 1;
  result = 0;
  *a2 = v3;
  return result;
}

//----- (0000000000030D44) ----------------------------------------------------
_QWORD *__fastcall sub_30D44(
        _QWORD *result,
        unsigned int a2,
        int a3,
        unsigned int *a4,
        int a5,
        _DWORD *a6,
        __int64 *a7,
        __int64 a8,
        __int64 a9,
        _BOOL4 *a10,
        unsigned int *a11)
{
  unsigned int v11; // w8
  int v12; // w21
  unsigned int v13; // w26
  unsigned int v14; // w19
  __int64 v15; // x9
  int v16; // w11
  unsigned int v17; // w9
  __int64 v18; // x8
  __int64 (__fastcall *v19)(_DWORD *); // x8
  _DWORD *v20; // x20
  __int64 v21; // x8
  int v22; // w9
  __int64 v23; // x11
  _DWORD *v24; // x8
  unsigned int v25; // w8
  _BOOL4 v26; // w18
  int v27; // w9
  __int64 v28; // x8
  int v29; // w8
  unsigned int v30; // w10
  bool v31; // zf
  unsigned int v32; // w8
  unsigned int v33; // w27
  unsigned int v34; // w1
  int v35; // w2
  int v36; // w8
  __int64 v37; // x10
  unsigned int v38; // w9
  unsigned int v39; // w23
  __int64 v40; // x8
  int32x4_t *v41; // x25
  __int64 v42; // x21
  unsigned int v43; // w19
  __int64 v44; // x22
  __int64 v45; // x22
  unsigned int max_rice_partition_order_from_blocksize_limited_max_and_predictor_order; // w0
  void (__fastcall *v47)(int32x4_t *, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // x8
  int v48; // w22
  int v49; // w23
  unsigned __int64 v50; // x9
  unsigned int v51; // w10
  unsigned __int64 v52; // x8
  unsigned int v53; // w11
  unsigned int v54; // w16
  unsigned int v55; // w15
  int8x16_t *v56; // x0
  unsigned int v57; // w18
  unsigned int v58; // w17
  int8x16_t v59; // q0
  int8x16_t v60; // q1
  int8x16_t v61; // q0
  int8x16_t v62; // q0
  unsigned int v63; // w17
  unsigned int v64; // w13
  unsigned int v65; // w14
  unsigned int v66; // w14
  int v67; // w16
  unsigned int v68; // w9
  int v69; // w10
  unsigned int v70; // w11
  unsigned int v71; // w13
  unsigned int v72; // w14
  unsigned int v73; // w15
  _DWORD *v74; // x9
  char v75; // w22
  _BOOL4 v76; // w24
  unsigned int v77; // w1
  unsigned int v78; // w25
  _QWORD *v79; // x19
  int *v80; // x23
  __int64 v81; // x24
  unsigned int v82; // w1
  unsigned int *v83; // x8
  _DWORD *v84; // x12
  unsigned int v85; // w10
  unsigned __int64 v86; // x9
  unsigned int v87; // w11
  unsigned __int64 v88; // x13
  unsigned int v89; // w14
  unsigned __int64 v90; // x16
  unsigned int v91; // w15
  unsigned int v92; // w15
  unsigned int v93; // w17
  unsigned int v94; // w0
  unsigned int v95; // w18
  __int64 v96; // x0
  unsigned __int64 v97; // x18
  int v98; // w18
  __int64 v99; // x1
  unsigned __int64 v100; // x16
  int v101; // w2
  unsigned int v102; // w16
  unsigned int v103; // w15
  bool v104; // cc
  int v105; // w17
  int v106; // w23
  int v107; // w9
  unsigned int v108; // w9
  unsigned int v109; // w10
  int v110; // w11
  unsigned int v111; // w13
  unsigned __int64 v112; // x12
  unsigned int v113; // w13
  unsigned __int64 v114; // x14
  unsigned int v115; // w15
  unsigned int v116; // w15
  unsigned int v117; // w16
  unsigned int v118; // w18
  unsigned int v119; // w17
  __int64 v120; // x18
  unsigned __int64 v121; // x17
  int v122; // w15
  int v123; // w17
  unsigned __int64 v124; // x14
  int v125; // w14
  unsigned int v126; // w10
  bool v127; // cf
  unsigned int v128; // w8
  void **v129; // x21
  __int64 v130; // x23
  int v131; // w25
  unsigned int v132; // w9
  _DWORD *v133; // x12
  __int64 v134; // x8
  __int64 v135; // x10
  __int64 v136; // x9
  _DWORD *v137; // x8
  int *v138; // x10
  int v139; // t1
  __int128 *v140; // x10
  _OWORD *v141; // x9
  __int128 v142; // q0
  __int128 v143; // q1
  __int64 v144; // x8
  unsigned int v145; // w9
  unsigned int v146; // [xsp+50h] [xbp-130h]
  unsigned int v147; // [xsp+54h] [xbp-12Ch]
  _QWORD *v153; // [xsp+88h] [xbp-F8h]
  _BOOL4 v154; // [xsp+94h] [xbp-ECh]
  unsigned int v155; // [xsp+98h] [xbp-E8h]
  unsigned int v156; // [xsp+9Ch] [xbp-E4h]
  int v157; // [xsp+ACh] [xbp-D4h]
  _DWORD *v158; // [xsp+B0h] [xbp-D0h]
  unsigned int v159; // [xsp+B8h] [xbp-C8h]
  int v160; // [xsp+BCh] [xbp-C4h]
  unsigned int v161; // [xsp+CCh] [xbp-B4h]
  unsigned int v162; // [xsp+D0h] [xbp-B0h]
  int v163; // [xsp+DCh] [xbp-A4h]
  __int64 v164; // [xsp+E0h] [xbp-A0h]
  __int64 v165; // [xsp+E8h] [xbp-98h]
  int v166; // [xsp+F4h] [xbp-8Ch]
  _BOOL4 v167; // [xsp+F8h] [xbp-88h]
  _BOOL4 v168; // [xsp+FCh] [xbp-84h]
  unsigned int v169; // [xsp+100h] [xbp-80h]
  __int64 v170; // [xsp+100h] [xbp-80h]
  __int64 v171; // [xsp+108h] [xbp-78h]
  unsigned int v172; // [xsp+108h] [xbp-78h]
  _BYTE v173[4]; // [xsp+114h] [xbp-6Ch]
  int v174; // [xsp+118h] [xbp-68h]
  __int64 v175; // [xsp+128h] [xbp-58h]

  v175 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v153 = result;
  v11 = *a4;
  v12 = a5;
  if ( *(_DWORD *)(*result + 28LL) <= 0x10u )
    v13 = 15;
  else
    v13 = 31;
  if ( *(_DWORD *)(result[1] + 8384LL) && v11 > 3 )
  {
    v14 = -1;
  }
  else
  {
    v15 = *a7;
    *(_DWORD *)v15 = 1;
    v16 = v11 * a5 + 1;
    *(_QWORD *)(v15 + 8) = a6;
    v11 = *a4;
    v14 = v16 + 7 + *(_DWORD *)(v15 + 312);
    if ( *a4 < 4 )
    {
      v26 = 0;
      if ( v14 != -1 )
        goto LABEL_200;
      goto LABEL_199;
    }
  }
  v17 = a5 + (__clz((v11 - 4) | 1) ^ 0x1F) + 4;
  v18 = result[1];
  if ( v17 > 0x20 )
    v19 = *(__int64 (__fastcall **)(_DWORD *))(v18 + 8368);
  else
    v19 = *(__int64 (__fastcall **)(_DWORD *))(v18 + 8360);
  v20 = a6;
  result = (_QWORD *)v19(a6 + 4);
  a6 = v20;
  v21 = v153[1];
  if ( *(_DWORD *)(v21 + 8376) || v174 )
  {
LABEL_21:
    v27 = *(_DWORD *)(v21 + 8380);
    v28 = *v153;
    if ( !v27 || (v26 = 0, v14 == -1) && !*(_DWORD *)(v28 + 40) )
    {
      v29 = *(_DWORD *)(v28 + 52);
      v26 = 0;
      v30 = *a4;
      v31 = v29 == 0;
      v32 = v29 ? 4 : (unsigned int)result;
      v33 = v31 ? (unsigned int)result : 0;
      v34 = v32 >= v30 ? v30 - 1 : v32;
      if ( v33 <= v34 )
      {
        v35 = 0;
        v26 = 0;
        v146 = v34;
        v147 = v33;
        v156 = v12;
        while ( 1 )
        {
          v36 = *(_DWORD *)&v173[4 * v33];
          if ( v36 >> 16 < v12 )
            break;
LABEL_197:
          ++v33;
          ++v35;
          if ( v33 > v34 )
            goto LABEL_198;
        }
        v157 = v35;
        v155 = v14;
        v37 = v153[1];
        if ( v36 > 0 )
          v38 = ((v36 + 0x8000) >> 16) + 1;
        else
          v38 = 1;
        if ( v38 >= v13 )
          v38 = v13 - 1;
        v161 = v38;
        v39 = *a4;
        v164 = *(_QWORD *)(v37 + 7952);
        v166 = *(_DWORD *)(*v153 + 56LL);
        v40 = 8LL * !v26;
        v41 = *(int32x4_t **)(a9 + v40);
        v42 = *(_QWORD *)(v37 + 7960);
        v43 = *a4 - v33;
        v44 = a7[(unsigned __int64)v40 / 8];
        v154 = v26;
        v171 = *(_QWORD *)(a8 + v40);
        FLAC__fixed_compute_residual((char *)&a6[v33], v43, v33, v41);
        *(_DWORD *)v44 = 2;
        *(_DWORD *)(v44 + 8) = 0;
        *(_QWORD *)(v44 + 56) = v41;
        *(_QWORD *)(v44 + 24) = v171;
        v158 = (_DWORD *)v44;
        v45 = v153[1];
        v162 = v39;
        max_rice_partition_order_from_blocksize_limited_max_and_predictor_order = FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(
                                                                                    a3,
                                                                                    v39,
                                                                                    v33);
        v165 = v45;
        v47 = *(void (__fastcall **)(int32x4_t *, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v45 + 8352);
        v48 = max_rice_partition_order_from_blocksize_limited_max_and_predictor_order;
        if ( max_rice_partition_order_from_blocksize_limited_max_and_predictor_order <= a2 )
          v49 = max_rice_partition_order_from_blocksize_limited_max_and_predictor_order;
        else
          v49 = a2;
        v159 = v43;
        v47(
          v41,
          v164,
          v43,
          v33,
          (unsigned int)v49,
          max_rice_partition_order_from_blocksize_limited_max_and_predictor_order,
          v156);
        if ( !v166 )
          goto LABEL_75;
        if ( (v48 & 0x80000000) == 0 )
        {
          v50 = 0;
          v51 = 0;
          v52 = (unsigned int)(1 << v48);
          v53 = v162 >> v48;
          while ( 1 )
          {
            while ( 1 )
            {
              v64 = v50 ? 0 : v33;
              v65 = v53 - v64;
              if ( v53 != v64 )
                break;
              *(_DWORD *)(v42 + 4 * v50++) = 1;
              if ( v50 >= v52 )
              {
LABEL_66:
                if ( v48 > v49 )
                  goto LABEL_69;
                goto LABEL_75;
              }
            }
            if ( v65 < 8 || __CFADD__(v51, (v162 >> v48) - 1 - v64) )
            {
              v63 = 0;
              v54 = 0;
              v55 = v51;
            }
            else
            {
              v54 = v65 & 0xFFFFFFF8;
              v59 = 0u;
              v58 = v51;
              v55 = v51 + (v65 & 0xFFFFFFF8);
              v57 = v65 & 0xFFFFFFF8;
              v60 = 0u;
              do
              {
                v56 = (int32x4_t *)((char *)v41 + 4 * v58);
                v57 -= 8;
                v58 += 8;
                v59 = vorrq_s8(veorq_s8(vshrq_n_s32(*v56, 0x1Fu), *v56), v59);
                v60 = vorrq_s8(veorq_s8(vshrq_n_s32(v56[1], 0x1Fu), v56[1]), v60);
              }
              while ( v57 );
              v61 = vorrq_s8(v60, v59);
              v62 = vorrq_s8(v61, vextq_s8(v61, v61, 8u));
              v63 = vorrq_s8(v62, vdupq_lane_s32((int32x2_t)v62.n128_u64[0], 1)).n128_u32[0];
              if ( v65 == v54 )
                goto LABEL_62;
            }
            v66 = v65 - v54;
            do
            {
              v67 = v41->n128_i32[v55++];
              --v66;
              v63 |= v67 ^ (v67 >> 31);
            }
            while ( v66 );
LABEL_62:
            v51 = v51 + v53 - v64;
            if ( v63 )
            {
              *(_DWORD *)(v42 + 4 * v50++) = (__clz(v63) ^ 0x1F) + 2;
              if ( v50 >= v52 )
                goto LABEL_66;
            }
            else
            {
              *(_DWORD *)(v42 + 4 * v50++) = 1;
              if ( v50 >= v52 )
                goto LABEL_66;
            }
          }
        }
        LODWORD(v52) = 0;
        if ( v48 > v49 )
        {
LABEL_69:
          v68 = 0;
          v69 = v48;
          do
          {
            --v69;
            v70 = 0;
            do
            {
              v71 = *(_DWORD *)(v42 + 4LL * v68);
              v72 = *(_DWORD *)(v42 + 4LL * (v68 + 1));
              v73 = v52 + v70++;
              v68 += 2;
              if ( v71 <= v72 )
                v71 = v72;
              *(_DWORD *)(v42 + 4LL * v73) = v71;
            }
            while ( v70 < 1 << v69 );
            LODWORD(v52) = v52 + v70;
          }
          while ( v69 > v49 );
        }
LABEL_75:
        if ( v48 < v49 )
        {
          v74 = v158;
          v75 = 0;
          v76 = 0;
          v172 = 0;
          v158[4] = 0;
          v77 = 6;
          goto LABEL_177;
        }
        v78 = 0;
        v76 = 0;
        v160 = v43 * (v161 + 1) - (v43 >> 1) + 4;
        v169 = 0;
        v172 = 0;
        v163 = v49;
        while ( 1 )
        {
          v167 = !v76;
          v168 = v76;
          v79 = (_QWORD *)(v164 + 8LL * v78);
          v80 = (int *)(v42 + 4LL * v78);
          v81 = v165 + 24LL * !v76;
          v82 = (unsigned int)v48 <= 6 ? 6 : v48;
          FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(v81 + 8744, v82);
          v83 = *(unsigned int **)(v81 + 8744);
          v84 = *(_DWORD **)(v81 + 8752);
          if ( v48 )
            break;
          v107 = 2 * *v79;
          if ( v161 )
            v107 = *v79 >> ((unsigned __int8)v161 - 1);
          v108 = v160 + v107;
          if ( v108 == -1 )
            v109 = 0;
          else
            v109 = v161;
          if ( v166 )
          {
            v110 = *v80;
            v111 = *v80 * v159 + 10;
            if ( v111 <= v108 )
              v109 = 0;
            else
              v110 = 0;
            if ( v111 <= v108 )
              v108 = *v80 * v159 + 10;
            *v84 = v110;
          }
          *v83 = v109;
          v106 = v163;
          v87 = v108 + 6;
          LODWORD(v86) = 1;
LABEL_163:
          v126 = v172;
          v78 += v86;
          v127 = v172 - 1 >= v87;
          v76 = v168;
          if ( v172 - 1 >= v87 )
            v126 = v87;
          v172 = v126;
          if ( v127 )
            v76 = v167;
          v128 = v169;
          if ( v127 )
            v128 = v48;
          v169 = v128;
          v104 = v48-- <= v106;
          if ( v104 )
            goto LABEL_173;
        }
        v85 = v162 >> v48;
        if ( v162 >> v48 <= v33 )
        {
          v76 = v168;
LABEL_173:
          v75 = v169;
          v74 = v158;
          if ( v169 <= 6 )
            v77 = 6;
          else
            v77 = v169;
          v158[4] = v169;
LABEL_177:
          v129 = (void **)*((_QWORD *)v74 + 3);
          v130 = v33 & 0xFFFFFFF8;
          v170 = v147 + v157;
          FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size((__int64)v129, v77);
          v131 = 1 << v75;
          result = memcpy(*v129, *(const void **)(v165 + 24LL * v76 + 8744), 4LL * (1 << v75));
          if ( v166 )
            result = memcpy(v129[1], *(const void **)(v165 + 24LL * v76 + 8752), 4LL * v131);
          a6 = v20;
          v26 = v154;
          v34 = v146;
          v132 = 0;
          while ( *((_DWORD *)*v129 + v132) < 0xFu )
          {
            if ( ++v132 >= v131 )
            {
              v133 = v158;
              v12 = v156;
              v158[8] = v33;
              if ( !v33 )
                goto LABEL_195;
              goto LABEL_183;
            }
          }
          v158[2] = 1;
          v133 = v158;
          v12 = v156;
          v158[8] = v33;
          if ( !v33 )
            goto LABEL_195;
LABEL_183:
          if ( (unsigned int)v170 >= 8 && (v133 + 9 >= &v20[(unsigned int)v170] || &v133[v170 + 9] <= v20) )
          {
            v140 = (__int128 *)(v20 + 4);
            v134 = (unsigned int)v170 & 0xFFFFFFF8;
            v141 = v133 + 13;
            do
            {
              v142 = *(v140 - 1);
              v143 = *v140;
              v140 += 2;
              v130 -= 8;
              *(v141 - 1) = v142;
              *v141 = v143;
              v141 += 2;
            }
            while ( v130 );
            if ( v134 == v170 )
            {
LABEL_195:
              v14 = v155;
              v35 = v157;
              if ( v172 + v33 * v12 + 8 + v133[78] < v155 )
              {
                v14 = v172 + v33 * v12 + 8 + v133[78];
                v26 = !v154;
              }
              goto LABEL_197;
            }
          }
          else
          {
            v134 = 0;
          }
          v135 = v134;
          v136 = v33 - v134;
          v137 = &v133[v134 + 9];
          v138 = &v20[v135];
          do
          {
            v139 = *v138++;
            --v136;
            *v137++ = v139;
          }
          while ( v136 );
          goto LABEL_195;
        }
        v86 = (unsigned int)(1 << v48);
        if ( v166 )
        {
          v87 = 6;
          v88 = 0;
          v89 = 0;
          while ( 1 )
          {
            v90 = v79[v88];
            if ( v88 )
              v91 = 0;
            else
              v91 = v33;
            v92 = v85 - v91;
            if ( v90 >= 0x10000001 )
            {
              v93 = 0;
              v96 = v92;
              if ( v90 < 0x100000000000001LL && (unsigned __int64)v92 << 7 < v90 )
              {
                v93 = 0;
                do
                {
                  v97 = v96 << 8;
                  v127 = v96 << 15 >= v90;
                  v93 += 8;
                  v96 <<= 8;
                }
                while ( !v127 );
                if ( v97 >= v90 )
                  goto LABEL_107;
                do
                {
LABEL_103:
                  v97 *= 2LL;
                  ++v93;
                }
                while ( v97 < v90 );
                goto LABEL_107;
              }
              v97 = v92;
              if ( v92 < v90 )
                goto LABEL_103;
            }
            else
            {
              if ( 8 * v92 < (unsigned int)v90 )
              {
                v93 = 0;
                v94 = v92;
                do
                {
                  v95 = 16 * v94;
                  v127 = v94 << 7 >= (unsigned int)v90;
                  v93 += 4;
                  v94 *= 16;
                }
                while ( !v127 );
                if ( v95 >= (unsigned int)v90 )
                  goto LABEL_107;
                do
                {
LABEL_106:
                  v95 *= 2;
                  ++v93;
                }
                while ( v95 < (unsigned int)v90 );
                goto LABEL_107;
              }
              v93 = 0;
              v95 = v92;
              if ( v92 < (unsigned int)v90 )
                goto LABEL_106;
            }
LABEL_107:
            if ( v93 >= v13 )
              v93 = v13 - 1;
            v98 = 2 * v90;
            v99 = v88;
            v100 = v90 >> ((unsigned __int8)v93 - 1);
            v101 = v80[v88];
            if ( !v93 )
              LODWORD(v100) = v98;
            v102 = 4 - (v92 >> 1) + (v93 + 1) * v92 + v100;
            v103 = v101 * v92 + 10;
            if ( v102 != -1 )
              v89 = v93;
            v104 = v103 > v102;
            ++v88;
            if ( v103 <= v102 )
            {
              v105 = v101;
            }
            else
            {
              v103 = v102;
              v105 = 0;
            }
            if ( !v104 )
              v89 = 0;
            v87 += v103;
            v84[v99] = v105;
            v83[v99] = v89;
            if ( v88 >= v86 )
            {
              v106 = v163;
              goto LABEL_163;
            }
          }
        }
        v87 = 6;
        v106 = v163;
        v112 = 0;
        v113 = 0;
        while ( 1 )
        {
          v114 = v79[v112];
          if ( v112 )
            v115 = 0;
          else
            v115 = v33;
          v116 = v85 - v115;
          if ( v114 >= 0x10000001 )
          {
            v117 = 0;
            v120 = v116;
            if ( v114 < 0x100000000000001LL && (unsigned __int64)v116 << 7 < v114 )
            {
              v117 = 0;
              do
              {
                v121 = v120 << 8;
                v127 = v120 << 15 >= v114;
                v117 += 8;
                v120 <<= 8;
              }
              while ( !v127 );
              if ( v121 >= v114 )
                goto LABEL_156;
              do
              {
LABEL_152:
                v121 *= 2LL;
                ++v117;
              }
              while ( v121 < v114 );
              goto LABEL_156;
            }
            v121 = v116;
            if ( v116 < v114 )
              goto LABEL_152;
          }
          else
          {
            if ( 8 * v116 < (unsigned int)v114 )
            {
              v117 = 0;
              v118 = v116;
              do
              {
                v119 = 16 * v118;
                v127 = v118 << 7 >= (unsigned int)v114;
                v117 += 4;
                v118 *= 16;
              }
              while ( !v127 );
              if ( v119 >= (unsigned int)v114 )
                goto LABEL_156;
              do
              {
LABEL_155:
                v119 *= 2;
                ++v117;
              }
              while ( v119 < (unsigned int)v114 );
              goto LABEL_156;
            }
            v117 = 0;
            v119 = v116;
            if ( v116 < (unsigned int)v114 )
              goto LABEL_155;
          }
LABEL_156:
          if ( v117 >= v13 )
            v117 = v13 - 1;
          v122 = 4 - (v116 >> 1) + (v117 + 1) * v116;
          v123 = 2 * v114;
          v124 = v114 >> ((unsigned __int8)v117 - 1);
          if ( !v117 )
            LODWORD(v124) = v123;
          v125 = v122 + v124;
          if ( v125 != -1 )
            v113 = v117;
          v83[v112++] = v113;
          v87 += v125;
          if ( v112 >= v86 )
            goto LABEL_163;
        }
      }
    }
LABEL_198:
    if ( v14 == -1 )
      goto LABEL_199;
    goto LABEL_200;
  }
  v22 = *v20;
  if ( *a4 >= 2 )
  {
    v23 = 1;
    while ( v22 == v20[v23] )
    {
      if ( (unsigned int)++v23 >= *a4 )
        goto LABEL_17;
    }
    goto LABEL_21;
  }
LABEL_17:
  v24 = (_DWORD *)a7[1];
  v24[2] = v22;
  *v24 = 0;
  v25 = v12 + 8 + v24[78];
  v26 = v25 < v14;
  if ( v25 < v14 )
    v14 = v25;
  if ( v14 == -1 )
  {
LABEL_199:
    v144 = a7[v26];
    v145 = *a4;
    *(_DWORD *)v144 = 1;
    *(_QWORD *)(v144 + 8) = a6;
    v14 = v145 * v12 + 8 + *(_DWORD *)(v144 + 312);
  }
LABEL_200:
  *a10 = v26;
  *a11 = v14;
  return result;
}
// 61B14: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
// 61B18: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
// 61B20: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
// 61B24: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;

//----- (000000000003197C) ----------------------------------------------------
void *__fastcall sub_3197C(_DWORD **a1, unsigned int a2, unsigned int a3, _DWORD *a4, __int64 a5)
{
  void *result; // x0

  switch ( *a4 )
  {
    case 0:
      result = FLAC__subframe_add_constant(a4 + 2, a3, a4[78], a5);
      if ( !(_DWORD)result )
        goto LABEL_11;
      result = &dword_0 + 1;
      break;
    case 1:
      result = FLAC__subframe_add_verbatim((__int64 *)a4 + 1, a2, a3, a4[78], a5);
      if ( !(_DWORD)result )
        goto LABEL_11;
      result = &dword_0 + 1;
      break;
    case 2:
      result = FLAC__subframe_add_fixed((__int64)(a4 + 2), a2 - a4[8], a3, a4[78], a5);
      if ( !(_DWORD)result )
        goto LABEL_11;
      result = &dword_0 + 1;
      break;
    case 3:
      result = FLAC__subframe_add_lpc((__int64)(a4 + 2), a2 - a4[8], a3, a4[78], a5);
      if ( (_DWORD)result )
        result = &dword_0 + 1;
      else
LABEL_11:
        **a1 = 7;
      break;
    default:
      result = &dword_0 + 1;
      break;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000031A7C) ----------------------------------------------------
void *__fastcall FLAC__add_metadata_block(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // w21
  void *result; // x0
  unsigned int v6; // w1
  __int64 v7; // x24
  unsigned __int64 v8; // x25
  __int64 v9; // x21
  unsigned __int64 v10; // x22
  unsigned int v11; // w25
  unsigned int v12; // w22
  __int64 v13; // x24
  __int64 v14; // x23
  __int64 v15; // x21
  __int64 v16; // x21
  unsigned __int8 *v17; // x21
  char v18; // t1
  unsigned int v19; // w28
  __int64 v20; // x22
  _BYTE *v21; // x22
  unsigned int v22; // t1
  unsigned int v23; // w27
  __int64 v24; // x25
  unsigned __int64 v25; // x21
  __int64 *v26; // x23
  __int64 v27; // x26
  unsigned int v28; // w21
  unsigned int v29; // w21

  v4 = strlen(FLAC__VENDOR_STRING);
  result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 4), 1u);
  if ( (_DWORD)result )
  {
    result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)a1, 7u);
    if ( (_DWORD)result )
    {
      v6 = *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)a1 == 4 )
        v6 = v6 + v4 - *(_DWORD *)(a1 + 16);
      if ( v6 >= 0x1000000 )
      {
        return 0;
      }
      else
      {
        result = FLAC__bitwriter_write_raw_uint32((__int64)a2, v6, 0x18u);
        if ( (_DWORD)result )
        {
          switch ( *(_DWORD *)a1 )
          {
            case 0:
              result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 16), 0x10u);
              if ( (_DWORD)result )
              {
                result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 20), 0x10u);
                if ( (_DWORD)result )
                {
                  result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 24), 0x18u);
                  if ( (_DWORD)result )
                  {
                    result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 28), 0x18u);
                    if ( (_DWORD)result )
                    {
                      result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 32), 0x14u);
                      if ( (_DWORD)result )
                      {
                        result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 36) - 1, 3u);
                        if ( (_DWORD)result )
                        {
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 40) - 1, 5u);
                          if ( (_DWORD)result )
                          {
                            result = FLAC__bitwriter_write_raw_uint64((__int64)a2, *(_QWORD *)(a1 + 48), 0x24u);
                            if ( (_DWORD)result )
                            {
                              result = FLAC__bitwriter_write_byte_block((__int64)a2, a1 + 56, 0x10u);
                              if ( (_DWORD)result )
                                goto LABEL_76;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;
            case 1:
              result = FLAC__bitwriter_write_zeroes((__int64)a2, 8 * *(_DWORD *)(a1 + 8));
              if ( (_DWORD)result )
                goto LABEL_76;
              break;
            case 2:
              result = FLAC__bitwriter_write_byte_block((__int64)a2, a1 + 16, 4u);
              if ( (_DWORD)result )
              {
                result = FLAC__bitwriter_write_byte_block((__int64)a2, *(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 8) - 4);
                if ( (_DWORD)result )
                  goto LABEL_76;
              }
              break;
            case 3:
              if ( !*(_DWORD *)(a1 + 16) )
                goto LABEL_76;
              v7 = 0;
              v8 = 0;
              while ( 1 )
              {
                result = FLAC__bitwriter_write_raw_uint64((__int64)a2, *(_QWORD *)(*(_QWORD *)(a1 + 24) + v7), 0x40u);
                if ( !(_DWORD)result )
                  break;
                result = FLAC__bitwriter_write_raw_uint64(
                           (__int64)a2,
                           *(_QWORD *)(*(_QWORD *)(a1 + 24) + v7 + 8),
                           0x40u);
                if ( !(_DWORD)result )
                  break;
                result = FLAC__bitwriter_write_raw_uint32(
                           (__int64)a2,
                           *(_DWORD *)(*(_QWORD *)(a1 + 24) + v7 + 16),
                           0x10u);
                if ( !(_DWORD)result )
                  break;
                ++v8;
                v7 += 24;
                if ( v8 >= *(unsigned int *)(a1 + 16) )
                  goto LABEL_76;
              }
              break;
            case 4:
              result = FLAC__bitwriter_write_raw_uint32_little_endian(a2, v4);
              if ( (_DWORD)result )
              {
                result = FLAC__bitwriter_write_byte_block((__int64)a2, (__int64)FLAC__VENDOR_STRING, v4);
                if ( (_DWORD)result )
                {
                  result = FLAC__bitwriter_write_raw_uint32_little_endian(a2, *(_DWORD *)(a1 + 32));
                  if ( (_DWORD)result )
                  {
                    if ( !*(_DWORD *)(a1 + 32) )
                      goto LABEL_76;
                    v9 = 0;
                    v10 = 0;
                    while ( 1 )
                    {
                      result = FLAC__bitwriter_write_raw_uint32_little_endian(
                                 a2,
                                 *(_DWORD *)(*(_QWORD *)(a1 + 40) + v9));
                      if ( !(_DWORD)result )
                        break;
                      result = FLAC__bitwriter_write_byte_block(
                                 (__int64)a2,
                                 *(_QWORD *)(*(_QWORD *)(a1 + 40) + v9 + 8),
                                 *(_DWORD *)(*(_QWORD *)(a1 + 40) + v9));
                      if ( !(_DWORD)result )
                        break;
                      ++v10;
                      v9 += 16;
                      if ( v10 >= *(unsigned int *)(a1 + 32) )
                        goto LABEL_76;
                    }
                  }
                }
              }
              break;
            case 5:
              result = FLAC__bitwriter_write_byte_block((__int64)a2, a1 + 16, 0x80u);
              if ( (_DWORD)result )
              {
                result = FLAC__bitwriter_write_raw_uint64((__int64)a2, *(_QWORD *)(a1 + 152), 0x40u);
                if ( (_DWORD)result )
                {
                  result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 160) != 0, 1u);
                  if ( (_DWORD)result )
                  {
                    result = FLAC__bitwriter_write_zeroes((__int64)a2, 0x817u);
                    if ( (_DWORD)result )
                    {
                      result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 164), 8u);
                      if ( (_DWORD)result )
                      {
                        if ( !*(_DWORD *)(a1 + 164) )
                          goto LABEL_76;
                        v11 = 8;
                        v12 = 64;
                        v13 = 0;
                        while ( 1 )
                        {
                          v14 = *(_QWORD *)(a1 + 168);
                          result = FLAC__bitwriter_write_raw_uint64((__int64)a2, *(_QWORD *)(v14 + 32 * v13), v12);
                          if ( !(_DWORD)result )
                            break;
                          v15 = v14 + 32 * v13;
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(unsigned __int8 *)(v15 + 8), v11);
                          if ( !(_DWORD)result )
                            break;
                          result = FLAC__bitwriter_write_byte_block((__int64)a2, v15 + 9, 0xCu);
                          if ( !(_DWORD)result )
                            break;
                          v16 = v14 + 32 * v13;
                          v18 = *(_BYTE *)(v16 + 22);
                          v17 = (unsigned __int8 *)(v16 + 22);
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, v18 & 1, 1u);
                          if ( !(_DWORD)result )
                            break;
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, (*v17 >> 1) & 1, 1u);
                          if ( !(_DWORD)result )
                            break;
                          result = FLAC__bitwriter_write_zeroes((__int64)a2, 0x6Eu);
                          if ( !(_DWORD)result )
                            break;
                          v19 = v12;
                          v20 = v14 + 32 * v13;
                          v22 = *(unsigned __int8 *)(v20 + 23);
                          v21 = (_BYTE *)(v20 + 23);
                          v23 = v11;
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, v22, 8u);
                          if ( !(_DWORD)result )
                            break;
                          if ( *v21 )
                          {
                            v24 = 0;
                            v25 = 0;
                            v26 = (__int64 *)(v14 + 32 * v13 + 24);
                            do
                            {
                              v27 = *v26;
                              result = FLAC__bitwriter_write_raw_uint64((__int64)a2, *(_QWORD *)(*v26 + v24), 0x40u);
                              if ( !(_DWORD)result )
                                return result;
                              result = FLAC__bitwriter_write_raw_uint32(
                                         (__int64)a2,
                                         *(unsigned __int8 *)(v27 + v24 + 8),
                                         8u);
                              if ( !(_DWORD)result )
                                return result;
                              result = FLAC__bitwriter_write_zeroes((__int64)a2, 0x18u);
                              if ( !(_DWORD)result )
                                return result;
                              ++v25;
                              v24 += 16;
                            }
                            while ( v25 < (unsigned __int8)*v21 );
                          }
                          v12 = v19;
                          v11 = v23;
                          if ( ++v13 >= (unsigned __int64)*(unsigned int *)(a1 + 164) )
                            goto LABEL_76;
                        }
                      }
                    }
                  }
                }
              }
              break;
            case 6:
              result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 16), 0x20u);
              if ( (_DWORD)result )
              {
                v28 = strlen(*(const char **)(a1 + 24));
                result = FLAC__bitwriter_write_raw_uint32((__int64)a2, v28, 0x20u);
                if ( (_DWORD)result )
                {
                  result = FLAC__bitwriter_write_byte_block((__int64)a2, *(_QWORD *)(a1 + 24), v28);
                  if ( (_DWORD)result )
                  {
                    v29 = strlen(*(const char **)(a1 + 32));
                    result = FLAC__bitwriter_write_raw_uint32((__int64)a2, v29, 0x20u);
                    if ( (_DWORD)result )
                    {
                      result = FLAC__bitwriter_write_byte_block((__int64)a2, *(_QWORD *)(a1 + 32), v29);
                      if ( (_DWORD)result )
                      {
                        result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 40), 0x20u);
                        if ( (_DWORD)result )
                        {
                          result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 44), 0x20u);
                          if ( (_DWORD)result )
                          {
                            result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 48), 0x20u);
                            if ( (_DWORD)result )
                            {
                              result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 52), 0x20u);
                              if ( (_DWORD)result )
                              {
                                result = FLAC__bitwriter_write_raw_uint32((__int64)a2, *(_DWORD *)(a1 + 56), 0x20u);
                                if ( (_DWORD)result )
                                {
                                  result = FLAC__bitwriter_write_byte_block(
                                             (__int64)a2,
                                             *(_QWORD *)(a1 + 64),
                                             *(_DWORD *)(a1 + 56));
                                  if ( (_DWORD)result )
                                    goto LABEL_76;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;
            default:
              result = FLAC__bitwriter_write_byte_block((__int64)a2, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 8));
              if ( (_DWORD)result )
LABEL_76:
                result = &dword_0 + 1;
              break;
          }
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 80010: using guessed type char *FLAC__VENDOR_STRING;

//----- (00000000000321C0) ----------------------------------------------------
void *__fastcall FLAC__frame_add_header(__int64 a1, __int64 a2)
{
  void *result; // x0
  int v5; // w8
  unsigned int v6; // w23
  unsigned int v7; // w1
  int v8; // w8
  char v9; // w24
  unsigned int v10; // w21
  unsigned int v11; // w8
  unsigned __int64 v12; // t2
  unsigned int v13; // w1
  unsigned int v14; // w2
  int v15; // w8
  unsigned int v16; // w2
  unsigned int v17; // w1
  _BYTE v18[4]; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v19; // [xsp+8h] [xbp-38h]

  v19 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  result = FLAC__bitwriter_write_raw_uint32(a2, 0x3FFEu, 0xEu);
  if ( !(_DWORD)result )
    return result;
  result = FLAC__bitwriter_write_raw_uint32(a2, 0, 1u);
  if ( !(_DWORD)result )
    return result;
  result = FLAC__bitwriter_write_raw_uint32(a2, *(_DWORD *)(a1 + 20) != 0, 1u);
  if ( !(_DWORD)result )
    return result;
  v5 = *(_DWORD *)a1;
  if ( *(int *)a1 <= 2047 )
  {
    if ( v5 > 575 )
    {
      switch ( v5 )
      {
        case 576:
          v6 = 0;
          v7 = 2;
          goto LABEL_38;
        case 1024:
          v6 = 0;
          v7 = 10;
          goto LABEL_38;
        case 1152:
          v6 = 0;
          v7 = 3;
          goto LABEL_38;
      }
    }
    else
    {
      switch ( v5 )
      {
        case 192:
          v6 = 0;
          v7 = 1;
          goto LABEL_38;
        case 256:
          v6 = 0;
          v7 = 8;
          goto LABEL_38;
        case 512:
          v6 = 0;
          v7 = 9;
          goto LABEL_38;
      }
    }
  }
  else if ( v5 <= 4607 )
  {
    switch ( v5 )
    {
      case 2048:
        v6 = 0;
        v7 = 11;
        goto LABEL_38;
      case 2304:
        v6 = 0;
        v7 = 4;
        goto LABEL_38;
      case 4096:
        v6 = 0;
        v7 = 12;
        goto LABEL_38;
    }
  }
  else if ( v5 >= 0x4000 )
  {
    if ( v5 == 0x4000 )
    {
      v6 = 0;
      v7 = 14;
      goto LABEL_38;
    }
    if ( v5 == 0x8000 )
    {
      v6 = 0;
      v7 = 15;
      goto LABEL_38;
    }
  }
  else
  {
    if ( v5 == 4608 )
    {
      v6 = 0;
      v7 = 5;
      goto LABEL_38;
    }
    if ( v5 == 0x2000 )
    {
      v6 = 0;
      v7 = 13;
      goto LABEL_38;
    }
  }
  if ( (unsigned int)v5 < 0x101 )
    v7 = 6;
  else
    v7 = 7;
  v6 = v7;
LABEL_38:
  result = FLAC__bitwriter_write_raw_uint32(a2, v7, 4u);
  if ( !(_DWORD)result )
    return result;
  v8 = *(_DWORD *)(a1 + 4);
  if ( v8 <= 44099 )
  {
    if ( v8 <= 22049 )
    {
      if ( v8 == 8000 )
      {
        v9 = 0;
        v10 = 4;
        goto LABEL_73;
      }
      if ( v8 == 16000 )
      {
        v9 = 0;
        v10 = 5;
        goto LABEL_73;
      }
    }
    else
    {
      switch ( v8 )
      {
        case 22050:
          v9 = 0;
          v10 = 6;
          goto LABEL_73;
        case 24000:
          v9 = 0;
          v10 = 7;
          goto LABEL_73;
        case 32000:
          v9 = 0;
          v10 = 8;
          goto LABEL_73;
      }
    }
  }
  else if ( v8 > 95999 )
  {
    switch ( v8 )
    {
      case 96000:
        v9 = 0;
        v10 = 11;
        goto LABEL_73;
      case 192000:
        v9 = 0;
        v10 = 3;
        goto LABEL_73;
      case 176400:
        v9 = 0;
        v10 = 2;
        goto LABEL_73;
    }
  }
  else
  {
    switch ( v8 )
    {
      case 44100:
        v9 = 0;
        v10 = 9;
        goto LABEL_73;
      case 48000:
        v9 = 0;
        v10 = 10;
        goto LABEL_73;
      case 88200:
        v9 = 0;
        v10 = 1;
        goto LABEL_73;
    }
  }
  if ( (unsigned int)v8 > 0x3E418 || v8 % 0x3E8u )
  {
    if ( v8 % 0xAu )
    {
      if ( (unsigned int)v8 >= 0x10000 )
        v10 = 0;
      else
        v10 = 13;
      v9 = v10;
    }
    else
    {
      v10 = 14;
      v9 = 14;
    }
  }
  else
  {
    v10 = 12;
    v9 = 12;
  }
LABEL_73:
  result = FLAC__bitwriter_write_raw_uint32(a2, v10, 4u);
  if ( (_DWORD)result )
  {
    switch ( *(_DWORD *)(a1 + 12) )
    {
      case 0:
        v10 = *(_DWORD *)(a1 + 8) - 1;
        break;
      case 1:
        v10 = 8;
        break;
      case 2:
        v10 = 9;
        break;
      case 3:
        v10 = 10;
        break;
      default:
        break;
    }
    result = FLAC__bitwriter_write_raw_uint32(a2, v10, 4u);
    if ( (_DWORD)result )
    {
      HIDWORD(v12) = *(_DWORD *)(a1 + 16) - 8;
      LODWORD(v12) = HIDWORD(v12);
      v11 = v12 >> 2;
      v13 = v11 > 4 ? 0 : dword_631E0[v11];
      result = FLAC__bitwriter_write_raw_uint32(a2, v13, 3u);
      if ( (_DWORD)result )
      {
        result = FLAC__bitwriter_write_raw_uint32(a2, 0, 1u);
        if ( (_DWORD)result )
        {
          if ( *(_DWORD *)(a1 + 20) )
          {
            result = FLAC__bitwriter_write_utf8_uint64(a2, *(_QWORD *)(a1 + 24));
            if ( !(_DWORD)result )
              return result;
          }
          else
          {
            result = FLAC__bitwriter_write_utf8_uint32(a2, *(_DWORD *)(a1 + 24));
            if ( !(_DWORD)result )
              return result;
          }
          if ( !v6
            || (v6 != 6 ? (v14 = 16) : (v14 = 8),
                result = FLAC__bitwriter_write_raw_uint32(a2, *(_DWORD *)a1 - 1, v14),
                (_DWORD)result) )
          {
            v15 = v9 & 0xF;
            if ( v15 != 14 )
            {
              if ( v15 == 13 )
              {
                result = FLAC__bitwriter_write_raw_uint32(a2, *(_DWORD *)(a1 + 4), 0x10u);
                if ( !(_DWORD)result )
                  return result;
              }
              else if ( v15 == 12 )
              {
                v16 = 8;
                v17 = *(_DWORD *)(a1 + 4) / 0x3E8u;
                goto LABEL_99;
              }
LABEL_102:
              result = FLAC__bitwriter_get_write_crc8(a2, v18);
              if ( (_DWORD)result )
                return (void *)((unsigned int)FLAC__bitwriter_write_raw_uint32(a2, v18[0], 8u) != 0);
              return result;
            }
            v16 = 16;
            v17 = *(_DWORD *)(a1 + 4) / 0xAu;
LABEL_99:
            result = FLAC__bitwriter_write_raw_uint32(a2, v17, v16);
            if ( !(_DWORD)result )
              return result;
            goto LABEL_102;
          }
        }
      }
    }
  }
  return result;
}
// 631E0: using guessed type _DWORD dword_631E0[8];

//----- (0000000000032750) ----------------------------------------------------
void *__fastcall FLAC__subframe_add_constant(unsigned int *a1, unsigned int a2, int a3, __int64 a4)
{
  void *result; // x0

  result = FLAC__bitwriter_write_raw_uint32(a4, a3 != 0, 8u);
  if ( (_DWORD)result )
  {
    if ( !a3 )
      return (void *)((unsigned int)FLAC__bitwriter_write_raw_int32(a4, *a1, a2) != 0);
    result = FLAC__bitwriter_write_unary_unsigned(a4, a3 - 1);
    if ( (_DWORD)result )
      return (void *)((unsigned int)FLAC__bitwriter_write_raw_int32(a4, *a1, a2) != 0);
  }
  return result;
}

//----- (00000000000327FC) ----------------------------------------------------
void *__fastcall FLAC__subframe_add_fixed(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  void *result; // x0
  __int64 v11; // x23

  result = FLAC__bitwriter_write_raw_uint32(a5, (a4 != 0) | 0x10 | (unsigned int)(2 * *(_DWORD *)(a1 + 24)), 8u);
  if ( (_DWORD)result )
  {
    if ( !a4 || (result = FLAC__bitwriter_write_unary_unsigned(a5, a4 - 1), (_DWORD)result) )
    {
      if ( *(_DWORD *)(a1 + 24) )
      {
        v11 = 0;
        while ( 1 )
        {
          result = FLAC__bitwriter_write_raw_int32(a5, *(_DWORD *)(a1 + 28 + 4 * v11), a3);
          if ( !(_DWORD)result )
            break;
          if ( ++v11 >= (unsigned __int64)*(unsigned int *)(a1 + 24) )
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        result = FLAC__bitwriter_write_raw_uint32(a5, *(_DWORD *)a1, 2u);
        if ( (_DWORD)result )
        {
          if ( *(_DWORD *)a1 > 1u )
            return &dword_0 + 1;
          result = FLAC__bitwriter_write_raw_uint32(a5, *(_DWORD *)(a1 + 8), 4u);
          if ( (_DWORD)result )
          {
            if ( *(_DWORD *)a1 > 1u )
              return &dword_0 + 1;
            result = sub_32958(
                       a5,
                       *(int **)(a1 + 48),
                       a2,
                       *(_DWORD *)(a1 + 24),
                       **(unsigned int ***)(a1 + 16),
                       *(unsigned int **)(*(_QWORD *)(a1 + 16) + 8LL),
                       *(_DWORD *)(a1 + 8),
                       *(_DWORD *)a1 == 1);
            if ( (_DWORD)result )
              return &dword_0 + 1;
          }
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000032958) ----------------------------------------------------
void *__fastcall sub_32958(
        __int64 a1,
        int *a2,
        unsigned int a3,
        int a4,
        unsigned int *a5,
        unsigned int *a6,
        int a7,
        int a8)
{
  int *v8; // x8
  int *v9; // x9
  unsigned int v10; // w23
  unsigned int v17; // w22
  __int64 v18; // x28
  __int64 v19; // x25
  int v20; // w9
  int v21; // w27
  void *result; // x0
  unsigned __int64 v23; // x22
  unsigned int v24; // [xsp+4h] [xbp-6Ch]
  unsigned __int64 v26; // [xsp+10h] [xbp-60h]
  unsigned int v27; // [xsp+18h] [xbp-58h]
  unsigned int v28; // [xsp+1Ch] [xbp-54h]

  v8 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
  if ( !a8 )
    v8 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
  v9 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
  v10 = *v8;
  if ( a8 )
    v9 = &FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;
  v27 = *v9;
  if ( !a7 )
  {
    if ( *a6 )
    {
      result = FLAC__bitwriter_write_raw_uint32(a1, v27, v10);
      if ( !(_DWORD)result )
        return result;
      result = FLAC__bitwriter_write_raw_uint32(a1, *a6, 5u);
      if ( !(_DWORD)result )
        return result;
      if ( a3 )
      {
        v23 = 0;
        do
        {
          result = FLAC__bitwriter_write_raw_int32(a1, a2[v23], *a6);
          if ( !(_DWORD)result )
            return result;
          ++v23;
        }
        while ( v23 < a3 );
      }
    }
    else
    {
      result = FLAC__bitwriter_write_raw_uint32(a1, *a5, v10);
      if ( !(_DWORD)result )
        return result;
      result = FLAC__bitwriter_write_rice_signed_block(a1, a2, a3, *a5);
      if ( !(_DWORD)result )
        return result;
    }
    return &dword_0 + 1;
  }
  v17 = (a4 + a3) >> a7;
  v18 = 0;
  LODWORD(v19) = 0;
  v26 = (unsigned int)(1 << a7);
  v24 = v17;
  while ( 1 )
  {
    v20 = v18 ? 0 : a4;
    v21 = v17 - v20;
    v28 = v17 - v20 + v19;
    if ( a6[v18] )
      break;
    result = FLAC__bitwriter_write_raw_uint32(a1, a5[v18], v10);
    if ( !(_DWORD)result )
      return result;
    result = FLAC__bitwriter_write_rice_signed_block(a1, &a2[(unsigned int)v19], v21, a5[v18]);
    v17 = v24;
    if ( !(_DWORD)result )
      return result;
LABEL_20:
    LODWORD(v19) = v28;
    if ( ++v18 >= v26 )
      return &dword_0 + 1;
  }
  result = FLAC__bitwriter_write_raw_uint32(a1, v27, v10);
  if ( !(_DWORD)result )
    return result;
  result = FLAC__bitwriter_write_raw_uint32(a1, a6[v18], 5u);
  if ( !(_DWORD)result )
    return result;
  if ( (unsigned int)v19 >= v28 )
    goto LABEL_20;
  v19 = (unsigned int)v19;
  while ( 1 )
  {
    result = FLAC__bitwriter_write_raw_int32(a1, a2[v19], a6[v18]);
    if ( !(_DWORD)result )
      return result;
    if ( ++v19 >= (unsigned __int64)v28 )
      goto LABEL_20;
  }
}
// 0: using guessed type int dword_0;
// 61B14: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
// 61B18: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
// 61B20: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
// 61B24: using guessed type int FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;

//----- (0000000000032B98) ----------------------------------------------------
void *__fastcall FLAC__subframe_add_lpc(__int64 a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  void *result; // x0
  __int64 v11; // x23
  __int64 v12; // x22

  result = FLAC__bitwriter_write_raw_uint32(a5, (a4 != 0) | 0x40 | (unsigned int)(2 * *(_DWORD *)(a1 + 24) - 2), 8u);
  if ( (_DWORD)result )
  {
    if ( !a4 || (result = FLAC__bitwriter_write_unary_unsigned(a5, a4 - 1), (_DWORD)result) )
    {
      if ( *(_DWORD *)(a1 + 24) )
      {
        v11 = 0;
        while ( 1 )
        {
          result = FLAC__bitwriter_write_raw_int32(a5, *(_DWORD *)(a1 + 164 + 4 * v11), a3);
          if ( !(_DWORD)result )
            break;
          if ( ++v11 >= (unsigned __int64)*(unsigned int *)(a1 + 24) )
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        result = FLAC__bitwriter_write_raw_uint32(a5, *(_DWORD *)(a1 + 28) - 1, 4u);
        if ( (_DWORD)result )
        {
          result = FLAC__bitwriter_write_raw_int32(a5, *(_DWORD *)(a1 + 32), 5u);
          if ( (_DWORD)result )
          {
            if ( *(_DWORD *)(a1 + 24) )
            {
              v12 = 0;
              while ( 1 )
              {
                result = FLAC__bitwriter_write_raw_int32(a5, *(_DWORD *)(a1 + 36 + 4 * v12), *(_DWORD *)(a1 + 28));
                if ( !(_DWORD)result )
                  break;
                if ( ++v12 >= (unsigned __int64)*(unsigned int *)(a1 + 24) )
                  goto LABEL_14;
              }
            }
            else
            {
LABEL_14:
              result = FLAC__bitwriter_write_raw_uint32(a5, *(_DWORD *)a1, 2u);
              if ( (_DWORD)result )
              {
                if ( *(_DWORD *)a1 > 1u )
                  return &dword_0 + 1;
                result = FLAC__bitwriter_write_raw_uint32(a5, *(_DWORD *)(a1 + 8), 4u);
                if ( (_DWORD)result )
                {
                  if ( *(_DWORD *)a1 > 1u )
                    return &dword_0 + 1;
                  result = sub_32958(
                             a5,
                             *(int **)(a1 + 296),
                             a2,
                             *(_DWORD *)(a1 + 24),
                             **(unsigned int ***)(a1 + 16),
                             *(unsigned int **)(*(_QWORD *)(a1 + 16) + 8LL),
                             *(_DWORD *)(a1 + 8),
                             *(_DWORD *)a1 == 1);
                  if ( (_DWORD)result )
                    return &dword_0 + 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000032D6C) ----------------------------------------------------
void *__fastcall FLAC__subframe_add_verbatim(__int64 *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  __int64 v5; // x23
  void *result; // x0
  __int64 v11; // x22

  v5 = *a1;
  result = FLAC__bitwriter_write_raw_uint32(a5, (a4 != 0) | 2u, 8u);
  if ( (_DWORD)result )
  {
    if ( !a4 || (result = FLAC__bitwriter_write_unary_unsigned(a5, a4 - 1), (_DWORD)result) )
    {
      if ( a2 )
      {
        v11 = 0;
        while ( 1 )
        {
          result = FLAC__bitwriter_write_raw_int32(a5, *(_DWORD *)(v5 + 4 * v11), a3);
          if ( !(_DWORD)result )
            break;
          if ( ++v11 >= (unsigned __int64)a2 )
            return &dword_0 + 1;
        }
      }
      else
      {
        return &dword_0 + 1;
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000032E4C) ----------------------------------------------------
void __fastcall sub_32E4C(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032E70) ----------------------------------------------------
void __fastcall sub_32E70(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032E94) ----------------------------------------------------
void __fastcall sub_32E94(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032EB8) ----------------------------------------------------
void __fastcall sub_32EB8(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032EDC) ----------------------------------------------------
void __fastcall sub_32EDC(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032F00) ----------------------------------------------------
void __fastcall sub_32F00(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032F24) ----------------------------------------------------
void __fastcall sub_32F24(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032F48) ----------------------------------------------------
void __fastcall sub_32F48(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032F6C) ----------------------------------------------------
void __fastcall sub_32F6C(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032F90) ----------------------------------------------------
void __fastcall sub_32F90(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (0000000000032FB4) ----------------------------------------------------
bool __fastcall sub_32FB4(__int64 a1, __int64 a2)
{
  return a1 == a2;
}

//----- (0000000000032FC0) ----------------------------------------------------
__int64 sub_32FC0()
{
  return 0;
}

//----- (0000000000032FC8) ----------------------------------------------------
__int64 sub_32FC8()
{
  return 0;
}

//----- (0000000000032FD0) ----------------------------------------------------
bool __fastcall sub_32FD0(__int64 a1, __int64 a2)
{
  return a1 == a2;
}

//----- (0000000000032FDC) ----------------------------------------------------
void *__fastcall sub_32FDC(const void *a1, const void *a2, _QWORD *a3)
{
  void *result; // x0
  _QWORD v6[4]; // [xsp+8h] [xbp-78h] BYREF
  __int64 v7; // [xsp+28h] [xbp-58h]
  __int64 v8; // [xsp+30h] [xbp-50h]
  __int64 v9; // [xsp+38h] [xbp-48h]
  __int64 v10; // [xsp+40h] [xbp-40h]
  __int64 v11; // [xsp+48h] [xbp-38h]
  _BYTE v12[7]; // [xsp+50h] [xbp-30h]
  __int64 v13; // [xsp+58h] [xbp-28h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 == a2 )
    return &dword_0 + 1;
  if ( a2 )
  {
    result = __dynamic_cast(
               a2,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
               0);
    if ( !result )
      return result;
    v6[0] = result;
    v6[1] = 0;
    v6[2] = a1;
    v6[3] = -1;
    *(_DWORD *)&v12[3] = 0;
    v7 = 0;
    v8 = 0;
    v10 = 0;
    v11 = 0;
    v9 = 0;
    *(_DWORD *)v12 = 1;
    (*(void (__fastcall **)(void *, _QWORD *, _QWORD, __int64))(*(_QWORD *)result + 56LL))(result, v6, *a3, 1);
    if ( (_DWORD)v9 == 1 )
    {
      *a3 = v7;
      return &dword_0 + 1;
    }
  }
  return 0;
}
// 0: using guessed type int dword_0;
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E610: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;

//----- (00000000000330B8) ----------------------------------------------------
void __fastcall sub_330B8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    if ( v4 == a3 )
    {
      if ( *(_DWORD *)(a2 + 48) == 2 )
        *(_DWORD *)(a2 + 48) = a4;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 48) = 2;
      *(_DWORD *)(a2 + 60) = v5 + 1;
      *(_BYTE *)(a2 + 78) = 1;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a4;
    *(_DWORD *)(a2 + 60) = 1;
  }
}

//----- (0000000000033114) ----------------------------------------------------
__int64 __fastcall sub_33114(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( result == *(_QWORD *)(a2 + 16) )
  {
    v4 = *(_QWORD *)(a2 + 32);
    if ( v4 )
    {
      if ( v4 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 60);
        *(_DWORD *)(a2 + 48) = 2;
        *(_DWORD *)(a2 + 60) = v5 + 1;
        *(_BYTE *)(a2 + 78) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  return result;
}

//----- (000000000003317C) ----------------------------------------------------
__int64 __fastcall sub_3317C(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( result != *(_QWORD *)(a2 + 16) )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(result + 16) + 56LL))(*(_QWORD *)(result + 16));
  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    if ( v4 == a3 )
    {
      if ( *(_DWORD *)(a2 + 48) == 2 )
        *(_DWORD *)(a2 + 48) = a4;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 48) = 2;
      *(_DWORD *)(a2 + 60) = v5 + 1;
      *(_BYTE *)(a2 + 78) = 1;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a4;
    *(_DWORD *)(a2 + 60) = 1;
  }
  return result;
}

//----- (00000000000331F4) ----------------------------------------------------
__int64 __fastcall sub_331F4(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x9
  __int64 v6; // x0
  char *v7; // x2

  v4 = a1[1];
  if ( a3 )
  {
    v5 = v4 >> 8;
    if ( (v4 & 1) != 0 )
      v5 = *(_QWORD *)(*a3 + v5);
  }
  else
  {
    v5 = 0;
  }
  v6 = *a1;
  v7 = (char *)a3 + v5;
  if ( (v4 & 2) != 0 )
    a4 = (unsigned int)a4;
  else
    a4 = 2;
  return (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v6 + 56LL))(v6, a2, v7, a4);
}

//----- (0000000000033234) ----------------------------------------------------
__int64 __fastcall sub_33234(__int64 result, __int64 a2, char *a3, __int64 a4)
{
  __int64 v5; // x22
  unsigned int v6; // w20
  __int64 v8; // x24
  __int64 v9; // x8
  __int64 v10; // x9
  char *v11; // x8
  int v12; // w8
  __int64 v13; // x0
  char *v14; // x2
  unsigned __int64 v15; // x24
  _QWORD *v16; // x22
  __int64 v17; // x8
  __int64 v18; // x9
  __int64 v19; // x3

  v5 = result;
  v6 = a4;
  if ( result == *(_QWORD *)(a2 + 16) )
  {
    v11 = *(char **)(a2 + 32);
    if ( v11 )
    {
      if ( v11 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v12 = *(_DWORD *)(a2 + 60);
        *(_DWORD *)(a2 + 48) = 2;
        *(_DWORD *)(a2 + 60) = v12 + 1;
        *(_BYTE *)(a2 + 78) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  else
  {
    v8 = *(unsigned int *)(result + 20);
    v9 = *(_QWORD *)(result + 32);
    if ( a3 )
    {
      v10 = v9 >> 8;
      if ( (v9 & 1) != 0 )
        v10 = *(_QWORD *)(*(_QWORD *)a3 + v10);
    }
    else
    {
      v10 = 0;
    }
    v13 = *(_QWORD *)(result + 24);
    v14 = &a3[v10];
    if ( (v9 & 2) != 0 )
      a4 = (unsigned int)a4;
    else
      a4 = 2;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v13 + 56LL))(v13, a2, v14, a4);
    if ( (unsigned int)v8 >= 2 )
    {
      v15 = v5 + 16 * v8 + 24;
      v16 = (_QWORD *)(v5 + 40);
      do
      {
        v17 = v16[1];
        if ( a3 )
        {
          v18 = v17 >> 8;
          if ( (v17 & 1) != 0 )
            v18 = *(_QWORD *)(*(_QWORD *)a3 + v18);
        }
        else
        {
          v18 = 0;
        }
        if ( (v17 & 2) != 0 )
          v19 = v6;
        else
          v19 = 2;
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64))(*(_QWORD *)*v16 + 56LL))(
                   *v16,
                   a2,
                   &a3[v18],
                   v19);
        if ( *(_BYTE *)(a2 + 78) )
          break;
        v16 += 2;
      }
      while ( (unsigned __int64)v16 < v15 );
    }
  }
  return result;
}

//----- (0000000000033380) ----------------------------------------------------
_BYTE *__fastcall sub_33380(const char **a1, const char **a2)
{
  _BYTE *result; // x0

  if ( ((_BYTE)a1[2] & 0x18) != 0 )
    return (_BYTE *)(strcmp(a1[1], a2[1]) == 0);
  if ( !a2 )
    return 0;
  result = __dynamic_cast(
             a2,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
             0);
  if ( result )
  {
    if ( (result[16] & 0x18) == 0 )
      return (_BYTE *)(a1 == a2);
    return (_BYTE *)(strcmp(a1[1], a2[1]) == 0);
  }
  return result;
}
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E630: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;

//----- (0000000000033400) ----------------------------------------------------
void (__fastcall **__fastcall sub_33400(__int64 a1, __int64 a2, _QWORD **a3))(std::type_info *__hidden this)
{
  void (__fastcall **result)(std::type_info *__hidden); // x0
  void (__fastcall **v7)(std::type_info *__hidden); // x21
  int v8; // w8
  int v9; // w9
  void (__fastcall **v10)(std::type_info *__hidden); // x8
  void *v11; // x0
  _BYTE *v12; // x0
  _QWORD *v13; // x8
  _QWORD *v14; // x22
  void (__fastcall **v15)(std::type_info *__hidden); // x20
  _QWORD v16[4]; // [xsp+8h] [xbp-88h] BYREF
  _QWORD *v17; // [xsp+28h] [xbp-68h]
  __int64 v18; // [xsp+30h] [xbp-60h]
  __int64 v19; // [xsp+38h] [xbp-58h]
  __int64 v20; // [xsp+40h] [xbp-50h]
  __int64 v21; // [xsp+48h] [xbp-48h]
  _BYTE v22[7]; // [xsp+50h] [xbp-40h]
  __int64 v23; // [xsp+58h] [xbp-38h]

  v23 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (void (__fastcall **)(std::type_info *__hidden))a2 == &`typeinfo for'decltype(nullptr) )
  {
    *a3 = 0;
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x18) != 0 )
  {
LABEL_3:
    if ( strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8)) )
      goto LABEL_4;
LABEL_20:
    if ( *a3 )
    {
      v13 = (_QWORD *)**a3;
LABEL_22:
      *a3 = v13;
    }
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( !a2 )
    return 0;
  v12 = __dynamic_cast(
          (const void *)a2,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
          0);
  if ( v12 )
  {
    if ( (v12[16] & 0x18) != 0 )
      goto LABEL_3;
    if ( a1 == a2 )
      goto LABEL_20;
  }
LABEL_4:
  result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                             (const void *)a2,
                                                             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
                                                             0);
  v7 = result;
  if ( !result )
    return result;
  if ( *a3 )
    *a3 = (_QWORD *)**a3;
  v8 = *((_DWORD *)result + 4);
  v9 = *(_DWORD *)(a1 + 16);
  if ( ((unsigned __int8)v8 & (unsigned __int8)~(_BYTE)v9 & 7) != 0
    || ((unsigned __int8)v9 & (unsigned __int8)~(_BYTE)v8 & 0x60) != 0 )
  {
    return 0;
  }
  result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
  v10 = (void (__fastcall **)(std::type_info *__hidden))v7[3];
  if ( result == v10 )
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  if ( result == &`typeinfo for'void )
  {
    if ( v10 )
      return (void (__fastcall **)(std::type_info *__hidden))(__dynamic_cast(
                                                                v7[3],
                                                                (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                                (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
                                                                0) == 0);
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( !result )
    return result;
  v11 = __dynamic_cast(
          result,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
          0);
  if ( v11 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
      return (void (__fastcall **)(std::type_info *__hidden))((unsigned __int64)sub_336F8(v11, v7[3]) & 1);
    return 0;
  }
  result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
  if ( !result )
    return result;
  v14 = __dynamic_cast(
          result,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
          0);
  if ( !v14 )
  {
    result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                                                               0);
    v15 = result;
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))v7[3];
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                                                               0);
    if ( !result )
      return result;
    v16[0] = result;
    v16[1] = 0;
    v16[2] = v15;
    v16[3] = -1;
    *(_DWORD *)&v22[3] = 0;
    v17 = 0;
    v18 = 0;
    v20 = 0;
    v21 = 0;
    v19 = 0;
    *(_DWORD *)v22 = 1;
    (*((void (__fastcall **)(void (__fastcall **)(std::type_info *__hidden), _QWORD *, _QWORD, __int64))*result + 7))(
      result,
      v16,
      *a3,
      1);
    if ( (_DWORD)v19 != 1 )
      return 0;
    if ( *a3 )
    {
      v13 = v17;
      goto LABEL_22;
    }
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( (*(_BYTE *)(a1 + 16) & 1) == 0 )
    return 0;
  result = (void (__fastcall **)(std::type_info *__hidden))v7[3];
  if ( result )
  {
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                                                               0);
    if ( result )
    {
      if ( ((_DWORD)result[2] & ~*((_DWORD *)v14 + 4)) == 0
        && (void (__fastcall *)(std::type_info *__hidden))v14[3] == result[3] )
      {
        return (void (__fastcall **)(std::type_info *__hidden))(v14[4] == (_QWORD)result[4]);
      }
      return 0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E610: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;
// 7E630: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 7E650: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_type_info;
// 7E670: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 7E690: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;
// 7E738: using guessed type void (__fastcall *`typeinfo for'void)(std::type_info *__hidden this);
// 7E790: using guessed type void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this);

//----- (00000000000336F8) ----------------------------------------------------
_DWORD *__fastcall sub_336F8(void *a1, const void *a2)
{
  const void *v2; // x8
  _DWORD *result; // x0
  _DWORD *v5; // x21
  int v6; // w9
  __int64 v7; // x8
  void *v8; // x0
  _DWORD *v9; // x19

  v2 = a2;
  if ( !a2 )
    return 0;
  while ( 1 )
  {
    result = __dynamic_cast(
               v2,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
               0);
    v5 = result;
    if ( !result )
      break;
    v6 = *((_DWORD *)a1 + 4);
    if ( (result[4] & ~v6) != 0 )
      return 0;
    v7 = *((_QWORD *)a1 + 3);
    if ( v7 == *((_QWORD *)result + 3) )
      return &dword_0 + 1;
    result = 0;
    if ( (v6 & 1) == 0 || !v7 )
      return result;
    v8 = __dynamic_cast(
           *((const void **)a1 + 3),
           (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
           (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
           0);
    if ( !v8 )
    {
      result = (_DWORD *)*((_QWORD *)a1 + 3);
      if ( !result )
        return result;
      result = __dynamic_cast(
                 result,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                 0);
      v9 = result;
      if ( !result )
        return result;
      result = (_DWORD *)*((_QWORD *)v5 + 3);
      if ( !result )
        return result;
      result = __dynamic_cast(
                 result,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                 0);
      if ( !result )
        return result;
      if ( (result[4] & ~v9[4]) == 0 && *((_QWORD *)v9 + 3) == *((_QWORD *)result + 3) )
        return (_DWORD *)(*((_QWORD *)v9 + 4) == *((_QWORD *)result + 4));
      return 0;
    }
    v2 = (const void *)*((_QWORD *)v5 + 3);
    a1 = v8;
    if ( !v2 )
      return 0;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E650: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_type_info;
// 7E690: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (000000000003382C) ----------------------------------------------------
_QWORD *__fastcall sub_3382C(__int64 a1, const void *a2)
{
  _QWORD *result; // x0

  if ( a2 )
  {
    result = __dynamic_cast(
               a2,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
               0);
    if ( !result )
      return result;
    if ( ((_DWORD)result[2] & ~*(_DWORD *)(a1 + 16)) == 0 && *(_QWORD *)(a1 + 24) == result[3] )
      return (_QWORD *)(*(_QWORD *)(a1 + 32) == result[4]);
  }
  return 0;
}
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E690: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (00000000000338A8) ----------------------------------------------------
_DWORD *__fastcall sub_338A8(__int64 a1, const char **a2, _QWORD *a3)
{
  _DWORD *result; // x0
  int v7; // w8
  int v8; // w9
  const void *v9; // x0
  void *v10; // x19
  _BYTE *v11; // x0

  if ( a2 != (const char **)&`typeinfo for'decltype(nullptr) )
  {
    if ( (*(_BYTE *)(a1 + 16) & 0x18) != 0 )
      goto LABEL_3;
    if ( !a2 )
      return 0;
    v11 = __dynamic_cast(
            a2,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
            0);
    if ( v11 )
    {
      if ( (v11[16] & 0x18) != 0 )
      {
LABEL_3:
        if ( strcmp(*(const char **)(a1 + 8), a2[1]) )
          goto LABEL_4;
        return &dword_0 + 1;
      }
      if ( (const char **)a1 == a2 )
        return &dword_0 + 1;
    }
LABEL_4:
    result = __dynamic_cast(
               a2,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
               0);
    if ( !result )
      return result;
    v7 = result[4];
    v8 = *(_DWORD *)(a1 + 16);
    if ( ((unsigned __int8)v7 & (unsigned __int8)~(_BYTE)v8 & 7) == 0
      && ((unsigned __int8)v8 & (unsigned __int8)~(_BYTE)v7 & 0x60) == 0
      && *(_QWORD *)(a1 + 24) == *((_QWORD *)result + 3) )
    {
      return (_DWORD *)(*(_QWORD *)(a1 + 32) == *((_QWORD *)result + 4));
    }
    return 0;
  }
  v9 = *(const void **)(a1 + 24);
  v10 = &unk_63330;
  if ( v9
    && __dynamic_cast(
         v9,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
         0) )
  {
    v10 = &unk_63320;
  }
  *a3 = v10;
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;
// 7E5F0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 7E630: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 7E670: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 7E690: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;
// 7E790: using guessed type void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this);

//----- (00000000000339EC) ----------------------------------------------------
void *_dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  const struct __class_type_info *v5; // x0
  __int64 v6; // x10
  char *v7; // x19
  void *result; // x0
  _QWORD v11[4]; // [xsp+8h] [xbp-68h] BYREF
  void *v12; // [xsp+28h] [xbp-48h]
  void *v13; // [xsp+30h] [xbp-40h]
  __int128 v14; // [xsp+38h] [xbp-38h]
  _QWORD v15[3]; // [xsp+48h] [xbp-28h] BYREF

  v15[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = *(_QWORD *)(*(_QWORD *)lpsrc - 16LL);
  v5 = *(const struct __class_type_info **)(*(_QWORD *)lpsrc - 8LL);
  v11[0] = lpdtype;
  v11[1] = lpsrc;
  v11[2] = lpstype;
  v11[3] = s2d;
  memset(v15, 0, 15);
  v7 = (char *)lpsrc + v6;
  v13 = 0;
  v14 = 0u;
  v12 = 0;
  if ( v5 == lpdtype )
  {
    LODWORD(v15[1]) = 1;
    (*(void (__fastcall **)(const struct __class_type_info *, _QWORD *, char *, char *, __int64, _QWORD))(*(_QWORD *)lpdtype + 40LL))(
      lpdtype,
      v11,
      v7,
      v7,
      1,
      0);
    if ( (_DWORD)v14 == 1 )
      return v7;
    else
      return 0;
  }
  else
  {
    (*(void (__fastcall **)(const struct __class_type_info *, _QWORD *, char *, __int64, _QWORD))(*(_QWORD *)v5 + 48LL))(
      v5,
      v11,
      (char *)lpsrc + v6,
      1,
      0);
    if ( HIDWORD(v14) == 1 )
    {
      if ( (_DWORD)v14 == 1 )
        return v12;
      result = 0;
      if ( !LODWORD(v15[0]) && *(_QWORD *)((char *)&v14 + 4) == 0x100000001LL )
        return v12;
    }
    else if ( HIDWORD(v14) )
    {
      return 0;
    }
    else if ( DWORD2(v14) == 1 && DWORD1(v14) == 1 && LODWORD(v15[0]) == 1 )
    {
      return v13;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0000000000033B20) ----------------------------------------------------
void __fastcall sub_33B20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // x9
  __int64 v6; // x9
  int v7; // w8
  int v8; // w8

  v5 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v5 == a4 )
  {
    v6 = *(_QWORD *)(a2 + 32);
    *(_BYTE *)(a2 + 76) = 1;
    if ( v6 )
    {
      if ( v6 == a3 )
      {
        v8 = *(_DWORD *)(a2 + 48);
        if ( v8 == 2 )
        {
          v8 = a5;
          *(_DWORD *)(a2 + 48) = a5;
        }
        if ( *(_DWORD *)(a2 + 72) == 1 && v8 == 1 )
          *(_BYTE *)(a2 + 78) = 1;
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 60);
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v7 + 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a5;
      *(_DWORD *)(a2 + 60) = 1;
      if ( a5 == 1 && *(_DWORD *)(a2 + 72) == 1 )
        *(_BYTE *)(a2 + 78) = 1;
    }
  }
}

//----- (0000000000033BC0) ----------------------------------------------------
void __fastcall sub_33BC0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
    *(_DWORD *)(a2 + 52) = a4;
}

//----- (0000000000033BE0) ----------------------------------------------------
__int64 __fastcall sub_33BE0(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5)
{
  __int64 v6; // x8
  __int64 v10; // x23
  const char *v11; // x24
  __int64 v12; // x8
  __int64 v13; // x24
  __int64 v14; // x9
  __int64 v15; // x3
  int v16; // w8
  unsigned __int64 v17; // x24
  __int64 *v18; // x23
  __int64 v19; // x8
  __int64 v20; // x9
  __int64 v21; // x0
  __int64 v22; // t1
  __int64 v23; // x3
  int v24; // w8
  __int64 v25; // x8
  char v26; // w22
  char v27; // w24
  _QWORD *v28; // x25
  unsigned __int64 v29; // x26
  __int64 v30; // x8
  __int64 v31; // x9
  __int64 v32; // x8
  __int64 v33; // x9
  __int64 v34; // x0
  __int64 v35; // t1
  __int64 v36; // x3
  __int64 v37; // x8
  __int64 v38; // x9
  __int64 v39; // x0
  __int64 v40; // t1
  __int64 v41; // x3
  int v42; // w8
  int v43; // w9
  int v44; // w8

  v6 = *(_QWORD *)(a2 + 16);
  v10 = result;
  if ( (a5 & 1) != 0 )
  {
    v11 = *(const char **)(result + 8);
    result = strcmp(v11, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
      {
LABEL_4:
        v12 = *(_QWORD *)(v10 + 32);
        v13 = *(unsigned int *)(v10 + 20);
        v14 = v12 >> 8;
        if ( (v12 & 1) != 0 )
          v14 = *(_QWORD *)(*(_QWORD *)a3 + v14);
        if ( (v12 & 2) != 0 )
          v15 = a4;
        else
          v15 = 2;
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v10 + 24) + 48LL))(
                   *(_QWORD *)(v10 + 24),
                   a2,
                   &a3[v14],
                   v15,
                   a5 & 1);
        if ( (unsigned int)v13 >= 2 )
        {
          v16 = *(_DWORD *)(v10 + 16);
          v17 = v10 + 16 * v13 + 24;
          v18 = (__int64 *)(v10 + 40);
          if ( (v16 & 2) != 0 || *(_DWORD *)(a2 + 60) == 1 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) )
                break;
              v19 = v18[1];
              v20 = v19 >> 8;
              if ( (v19 & 1) != 0 )
                v20 = *(_QWORD *)(*(_QWORD *)a3 + v20);
              v22 = *v18;
              v18 += 2;
              v21 = v22;
              v23 = (v19 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v21 + 48LL))(
                         v21,
                         a2,
                         &a3[v20],
                         v23,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
          else if ( (v16 & 1) != 0 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 && *(_DWORD *)(a2 + 48) == 1 )
                break;
              v37 = v18[1];
              v38 = v37 >> 8;
              if ( (v37 & 1) != 0 )
                v38 = *(_QWORD *)(*(_QWORD *)a3 + v38);
              v40 = *v18;
              v18 += 2;
              v39 = v40;
              v41 = (v37 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v39 + 48LL))(
                         v39,
                         a2,
                         &a3[v38],
                         v41,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
          else
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 )
                break;
              v32 = v18[1];
              v33 = v32 >> 8;
              if ( (v32 & 1) != 0 )
                v33 = *(_QWORD *)(*(_QWORD *)a3 + v33);
              v35 = *v18;
              v18 += 2;
              v34 = v35;
              v36 = (v32 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v34 + 48LL))(
                         v34,
                         a2,
                         &a3[v33],
                         v36,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
        }
        return result;
      }
      goto LABEL_22;
    }
LABEL_39:
    if ( *(char **)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  if ( result == v6 )
    goto LABEL_39;
  if ( result != *(_QWORD *)a2 )
    goto LABEL_4;
LABEL_22:
  if ( *(char **)(a2 + 32) != a3 && *(char **)(a2 + 40) != a3 )
  {
    v24 = *(_DWORD *)(a2 + 68);
    *(_DWORD *)(a2 + 56) = a4;
    if ( v24 == 4 )
      return result;
    v25 = *(unsigned int *)(v10 + 20);
    if ( (_DWORD)v25 )
    {
      v26 = 0;
      v27 = 0;
      v28 = (_QWORD *)(v10 + 24);
      v29 = v10 + 16 * v25 + 24;
      do
      {
        *(_WORD *)(a2 + 76) = 0;
        v30 = v28[1];
        v31 = v30 >> 8;
        if ( (v30 & 1) != 0 )
          v31 = *(_QWORD *)(*(_QWORD *)a3 + v31);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, char *, _QWORD, _QWORD))(*(_QWORD *)*v28 + 40LL))(
                   *v28,
                   a2,
                   a3,
                   &a3[v31],
                   2 - (((unsigned int)v30 >> 1) & 1),
                   a5 & 1);
        if ( *(_BYTE *)(a2 + 78) )
          break;
        if ( *(_BYTE *)(a2 + 77) )
        {
          if ( *(_BYTE *)(a2 + 76) )
          {
            if ( *(_DWORD *)(a2 + 48) == 1 || (*(_BYTE *)(v10 + 16) & 2) == 0 )
              goto LABEL_70;
            v27 = 1;
            v26 = 1;
          }
          else
          {
            v26 = 1;
            if ( (*(_BYTE *)(v10 + 16) & 1) == 0 )
              break;
          }
        }
        v28 += 2;
      }
      while ( (unsigned __int64)v28 < v29 );
      if ( (v27 & 1) != 0 )
        goto LABEL_69;
    }
    else
    {
      v26 = 0;
    }
    v43 = *(_DWORD *)(a2 + 60);
    v42 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v42 + 1;
    if ( v43 == 1 && *(_DWORD *)(a2 + 48) == 2 )
    {
      *(_BYTE *)(a2 + 78) = 1;
      if ( (v26 & 1) != 0 )
      {
LABEL_70:
        v44 = 3;
        goto LABEL_71;
      }
LABEL_68:
      v44 = 4;
LABEL_71:
      *(_DWORD *)(a2 + 68) = v44;
      return result;
    }
LABEL_69:
    if ( (v26 & 1) != 0 )
      goto LABEL_70;
    goto LABEL_68;
  }
  if ( a4 == 1 )
    *(_DWORD *)(a2 + 56) = 1;
  return result;
}

//----- (0000000000033F4C) ----------------------------------------------------
__int64 __fastcall sub_33F4C(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, char a6)
{
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 v8; // x0
  char *v9; // x3

  v6 = a1[1];
  v7 = v6 >> 8;
  if ( (v6 & 1) != 0 )
    v7 = *(_QWORD *)(*a4 + v7);
  v8 = *a1;
  v9 = (char *)a4 + v7;
  if ( (v6 & 2) != 0 )
    a5 = (unsigned int)a5;
  else
    a5 = 2;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v8 + 40LL))(
           v8,
           a2,
           a3,
           v9,
           a5,
           a6 & 1);
}

//----- (0000000000033F84) ----------------------------------------------------
__int64 __fastcall sub_33F84(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, char a5)
{
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x0
  char *v8; // x2

  v5 = a1[1];
  v6 = v5 >> 8;
  if ( (v5 & 1) != 0 )
    v6 = *(_QWORD *)(*a3 + v6);
  v7 = *a1;
  v8 = (char *)a3 + v6;
  if ( (v5 & 2) != 0 )
    a4 = (unsigned int)a4;
  else
    a4 = 2;
  return (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v7 + 48LL))(
           v7,
           a2,
           v8,
           a4,
           a5 & 1);
}

//----- (0000000000033FBC) ----------------------------------------------------
__int64 __fastcall sub_33FBC(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v6; // x8
  __int64 v10; // x23
  const char *v11; // x24
  int v12; // w8
  int v13; // w8
  int v14; // w9
  int v15; // w10

  v6 = *(_QWORD *)(a2 + 16);
  v10 = result;
  if ( (a5 & 1) != 0 )
  {
    v11 = *(const char **)(result + 8);
    result = strcmp(v11, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
        return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v10 + 16) + 48LL))(
                 *(_QWORD *)(v10 + 16),
                 a2,
                 a3,
                 a4,
                 a5 & 1);
      goto LABEL_7;
    }
LABEL_13:
    if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  if ( result == v6 )
    goto LABEL_13;
  if ( result != *(_QWORD *)a2 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v10 + 16) + 48LL))(
             *(_QWORD *)(v10 + 16),
             a2,
             a3,
             a4,
             a5 & 1);
LABEL_7:
  if ( *(_QWORD *)(a2 + 32) != a3 && *(_QWORD *)(a2 + 40) != a3 )
  {
    v12 = *(_DWORD *)(a2 + 68);
    *(_DWORD *)(a2 + 56) = a4;
    if ( v12 == 4 )
      return result;
    *(_WORD *)(a2 + 76) = 0;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, __int64, _QWORD))(**(_QWORD **)(v10 + 16)
                                                                                           + 40LL))(
               *(_QWORD *)(v10 + 16),
               a2,
               a3,
               a3,
               1,
               a5 & 1);
    if ( *(_BYTE *)(a2 + 77) )
    {
      v13 = 3;
      if ( *(_BYTE *)(a2 + 76) )
      {
LABEL_22:
        *(_DWORD *)(a2 + 68) = v13;
        return result;
      }
    }
    else
    {
      v13 = 4;
    }
    v15 = *(_DWORD *)(a2 + 60);
    v14 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v14 + 1;
    if ( v15 == 1 && *(_DWORD *)(a2 + 48) == 2 )
      *(_BYTE *)(a2 + 78) = 1;
    goto LABEL_22;
  }
  if ( a4 == 1 )
    *(_DWORD *)(a2 + 56) = 1;
  return result;
}

//----- (000000000003413C) ----------------------------------------------------
__int64 __fastcall sub_3413C(__int64 result, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 v6; // x8
  const char *v9; // x22
  int v10; // w8
  int v11; // w9

  v6 = *(_QWORD *)(a2 + 16);
  if ( (a5 & 1) != 0 )
  {
    v9 = *(const char **)(result + 8);
    result = strcmp(v9, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v9, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
        return result;
LABEL_7:
      if ( *(_QWORD *)(a2 + 32) == a3 || *(_QWORD *)(a2 + 40) == a3 )
      {
        if ( a4 == 1 )
          *(_DWORD *)(a2 + 56) = 1;
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 60);
        v10 = *(_DWORD *)(a2 + 64);
        *(_DWORD *)(a2 + 56) = a4;
        *(_QWORD *)(a2 + 40) = a3;
        *(_DWORD *)(a2 + 64) = v10 + 1;
        if ( v11 == 1 && *(_DWORD *)(a2 + 48) == 2 )
          *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 68) = 4;
      }
      return result;
    }
  }
  else if ( result != v6 )
  {
    if ( result != *(_QWORD *)a2 )
      return result;
    goto LABEL_7;
  }
  if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
    *(_DWORD *)(a2 + 52) = a4;
  return result;
}

//----- (0000000000034234) ----------------------------------------------------
__int64 __fastcall sub_34234(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6)
{
  __int64 v7; // x8
  __int64 v12; // x24
  char v13; // w26
  char v14; // w10
  __int64 v15; // x25
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x4
  unsigned __int64 v19; // x28
  __int64 *v20; // x25
  __int64 v21; // x8
  __int64 v22; // x9
  __int64 v23; // x0
  __int64 v24; // t1
  __int64 v25; // x4
  char *v26; // x9
  __int64 v27; // x9
  int v28; // w8
  unsigned int v29; // w8
  char v30; // [xsp+Ch] [xbp-54h]

  v7 = *(_QWORD *)(a2 + 16);
  v12 = result;
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
    {
LABEL_3:
      v13 = *(_BYTE *)(a2 + 76);
      v14 = *(_BYTE *)(a2 + 77);
      v15 = *(unsigned int *)(v12 + 20);
      *(_WORD *)(a2 + 76) = 0;
      v16 = *(_QWORD *)(v12 + 32);
      v30 = v14;
      v17 = v16 >> 8;
      if ( (v16 & 1) != 0 )
        v17 = *(_QWORD *)(*(_QWORD *)a4 + v17);
      if ( (v16 & 2) != 0 )
        v18 = a5;
      else
        v18 = 2;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v12 + 24)
                                                                                            + 40LL))(
                 *(_QWORD *)(v12 + 24),
                 a2,
                 a3,
                 &a4[v17],
                 v18,
                 a6 & 1);
      if ( (unsigned int)v15 >= 2 )
      {
        v19 = v12 + 16 * v15 + 24;
        v20 = (__int64 *)(v12 + 40);
        do
        {
          if ( *(_BYTE *)(a2 + 78) )
            break;
          if ( *(_BYTE *)(a2 + 76) )
          {
            if ( *(_DWORD *)(a2 + 48) == 1 || (*(_BYTE *)(v12 + 16) & 2) == 0 )
              break;
          }
          else if ( *(_BYTE *)(a2 + 77) && (*(_BYTE *)(v12 + 16) & 1) == 0 )
          {
            break;
          }
          *(_WORD *)(a2 + 76) = 0;
          v21 = v20[1];
          v22 = v21 >> 8;
          if ( (v21 & 1) != 0 )
            v22 = *(_QWORD *)(*(_QWORD *)a4 + v22);
          v24 = *v20;
          v20 += 2;
          v23 = v24;
          v25 = (v21 & 2) != 0 ? a5 : 2LL;
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v23 + 40LL))(
                     v23,
                     a2,
                     a3,
                     &a4[v22],
                     v25,
                     a6 & 1);
        }
        while ( (unsigned __int64)v20 < v19 );
      }
      *(_BYTE *)(a2 + 76) = v13;
      *(_BYTE *)(a2 + 77) = v30;
      return result;
    }
  }
  else if ( result != v7 )
  {
    goto LABEL_3;
  }
  v26 = *(char **)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v26 != a4 )
    return result;
  v27 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v27 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    goto LABEL_35;
  }
  if ( v27 != a3 )
  {
    v28 = *(_DWORD *)(a2 + 60);
    *(_BYTE *)(a2 + 78) = 1;
    *(_DWORD *)(a2 + 60) = v28 + 1;
    return result;
  }
  v29 = *(_DWORD *)(a2 + 48);
  if ( v29 == 2 )
  {
    v29 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( v29 == 1 )
  {
LABEL_35:
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (0000000000034430) ----------------------------------------------------
__int64 __fastcall sub_34430(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  __int64 v7; // x8
  __int64 v12; // x24
  __int64 v13; // x9
  __int64 v14; // x9
  int v15; // w8
  unsigned int v16; // w8

  v7 = *(_QWORD *)(a2 + 16);
  v12 = result;
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v12 + 16)
                                                                                          + 40LL))(
               *(_QWORD *)(v12 + 16),
               a2,
               a3,
               a4,
               a5,
               a6 & 1);
  }
  else if ( result != v7 )
  {
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v12 + 16) + 40LL))(
             *(_QWORD *)(v12 + 16),
             a2,
             a3,
             a4,
             a5,
             a6 & 1);
  }
  v13 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v13 != a4 )
    return result;
  v14 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v14 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    goto LABEL_15;
  }
  if ( v14 != a3 )
  {
    v15 = *(_DWORD *)(a2 + 60);
    *(_BYTE *)(a2 + 78) = 1;
    *(_DWORD *)(a2 + 60) = v15 + 1;
    return result;
  }
  v16 = *(_DWORD *)(a2 + 48);
  if ( v16 == 2 )
  {
    v16 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( v16 == 1 )
  {
LABEL_15:
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (0000000000034550) ----------------------------------------------------
__int64 __fastcall sub_34550(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v7; // x8
  __int64 v11; // x9
  __int64 v12; // x9
  int v13; // w8
  int v14; // w8

  v7 = *(_QWORD *)(a2 + 16);
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
      return result;
  }
  else if ( result != v7 )
  {
    return result;
  }
  v11 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v11 == a4 )
  {
    v12 = *(_QWORD *)(a2 + 32);
    *(_BYTE *)(a2 + 76) = 1;
    if ( v12 )
    {
      if ( v12 != a3 )
      {
        v13 = *(_DWORD *)(a2 + 60);
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v13 + 1;
        return result;
      }
      v14 = *(_DWORD *)(a2 + 48);
      if ( v14 == 2 )
      {
        v14 = a5;
        *(_DWORD *)(a2 + 48) = a5;
      }
      if ( v14 != 1 )
        return result;
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a5;
      *(_DWORD *)(a2 + 60) = 1;
      if ( a5 != 1 )
        return result;
    }
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (0000000000034630) ----------------------------------------------------
void *__fastcall operator new(size_t a1)
{
  size_t v1; // x19
  void *result; // x0
  void (*new_handler)(void); // x0
  _QWORD *exception; // x19

  if ( a1 )
    v1 = a1;
  else
    v1 = 1;
  while ( 1 )
  {
    result = malloc(v1);
    if ( result )
      break;
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = __cxa_allocate_exception(8u);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return result;
}
// 36204: using guessed type void std::exception::~exception(std::exception *__hidden this);
// 7F340: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (0000000000034694) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new(size_t a1)
{
  return operator new(a1);
}
// 346B8: positive sp value 10 has been found

//----- (00000000000346C0) ----------------------------------------------------
void __fastcall __noreturn sub_346C0(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (00000000000346D0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 operator new[]()
{
  return operator new[]();
}
// 346F4: positive sp value 10 has been found

//----- (00000000000346FC) ----------------------------------------------------
void __fastcall operator delete(void *p)
{
  if ( p )
    free(p);
}

//----- (000000000003471C) ----------------------------------------------------
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  unsigned __int64 StatusReg; // x21
  size_t v3; // x19
  size_t v4; // x20
  void (*new_handler)(void); // x0
  _QWORD *exception; // x19
  void *v8[2]; // [xsp+0h] [xbp-30h] BYREF

  StatusReg = _ReadStatusReg(TPIDR_EL0);
  if ( a1 )
    v3 = a1;
  else
    v3 = 1;
  if ( a2 <= 8 )
    v4 = 8;
  else
    v4 = a2;
  v8[1] = *(void **)(StatusReg + 40);
  while ( posix_memalign(v8, v4, v3) )
  {
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = __cxa_allocate_exception(8u);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return v8[0];
}
// 36204: using guessed type void std::exception::~exception(std::exception *__hidden this);
// 7F340: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (00000000000347C8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  return operator new(a1, a2);
}
// 347EC: positive sp value 10 has been found

//----- (00000000000347F8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 operator new[]()
{
  return operator new[]();
}
// 3481C: positive sp value 10 has been found

//----- (0000000000034824) ----------------------------------------------------
void __fastcall operator delete(void *p)
{
  if ( p )
    free(p);
}

//----- (0000000000034834) ----------------------------------------------------
void __fastcall operator delete(void *p)
{
  operator delete(p);
}

//----- (0000000000034844) ----------------------------------------------------
__int64 operator delete[]()
{
  return operator delete[]();
}

//----- (0000000000034854) ----------------------------------------------------
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *result)
{
  *result = off_7F190;
  return result;
}
// 7F190: using guessed type void (__fastcall *[2])(std::bad_cast *__hidden this);

//----- (000000000003486C) ----------------------------------------------------
void __fastcall std::bad_cast::~bad_cast(std::exception *a1)
{
  std::exception::~exception(a1);
  operator delete(a1);
}
// 11EF0: using guessed type void __fastcall std::exception::~exception(std::exception *a1);

//----- (0000000000034890) ----------------------------------------------------
const char *std::bad_cast::what()
{
  return "std::bad_cast";
}

//----- (000000000003489C) ----------------------------------------------------
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *result)
{
  *result = off_7F1B8;
  return result;
}
// 7F1B8: using guessed type void (__fastcall *[2])(std::bad_typeid *__hidden this);

//----- (00000000000348B4) ----------------------------------------------------
void __fastcall std::bad_typeid::~bad_typeid(std::exception *a1)
{
  std::exception::~exception(a1);
  operator delete(a1);
}
// 11EF0: using guessed type void __fastcall std::exception::~exception(std::exception *a1);

//----- (00000000000348D8) ----------------------------------------------------
const char *std::bad_typeid::what()
{
  return "std::bad_typeid";
}

//----- (00000000000348E4) ----------------------------------------------------
void *_cxa_allocate_exception(size_t thrown_size)
{
  size_t v1; // x19
  char *v2; // x0
  char *v3; // x20

  v1 = (thrown_size + 143) & 0xFFFFFFFFFFFFFFF0LL;
  v2 = (char *)sub_35F0C(v1);
  v3 = v2;
  if ( !v2 )
    std::terminate();
  memset(v2, 0, v1);
  return v3 + 128;
}
// 11D60: using guessed type _QWORD std::terminate(void);

//----- (0000000000034930) ----------------------------------------------------
void _cxa_free_exception(void *a1)
{
  _cxa_free_dependent_exception_0((int *)a1 - 32);
}

//----- (000000000003494C) ----------------------------------------------------
void *_cxa_allocate_dependent_exception()
{
  void *v0; // x0

  v0 = sub_35F0C(0x80u);
  if ( !v0 )
    std::terminate();
  return memset(v0, 0, 0x80u);
}

//----- (0000000000034978) ----------------------------------------------------
void __noreturn _cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  _DWORD *globals; // x22
  unsigned __int64 terminate; // x0
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x3
  __int64 v11; // x4
  __int64 v12; // x5
  __int64 v13; // x6
  __int64 v14; // x7
  char v15; // [xsp+20h] [xbp-20h]

  globals = __cxa_get_globals();
  *((_QWORD *)a1 - 13) = std::get_unexpected();
  terminate = std::get_terminate();
  *((_QWORD *)a1 - 16) = 1;
  a1 = (char *)a1 - 128;
  *((_QWORD *)a1 + 4) = terminate;
  *((_QWORD *)a1 + 1) = lptinfo;
  *((_QWORD *)a1 + 2) = a3;
  *((_QWORD *)a1 + 12) = 0x434C4E47432B2B00LL;
  ++globals[2];
  *((_QWORD *)a1 + 13) = &loc_349F4;
  sub_5DD9C((_QWORD *)a1 + 12, v8, v9, v10, v11, v12, v13, v14, v15);
  sub_34A54((__int64)a1);
}
// 349E8: variable 'v8' is possibly undefined
// 349E8: variable 'v9' is possibly undefined
// 349E8: variable 'v10' is possibly undefined
// 349E8: variable 'v11' is possibly undefined
// 349E8: variable 'v12' is possibly undefined
// 349E8: variable 'v13' is possibly undefined
// 349E8: variable 'v14' is possibly undefined
// 349E8: variable 'v15' is possibly undefined

//----- (0000000000034A54) ----------------------------------------------------
void __fastcall __noreturn sub_34A54(__int64 a1)
{
  __cxa_begin_catch((void *)(a1 + 96));
  sub_3518C(*(void (**)(void))(a1 + 32));
}

//----- (0000000000034A74) ----------------------------------------------------
void *_cxa_get_exception_ptr(void *a1)
{
  return (void *)*((_QWORD *)a1 - 2);
}

//----- (0000000000034A7C) ----------------------------------------------------
void *_cxa_begin_catch(void *a1)
{
  unsigned __int64 v2; // x20
  __int64 globals; // x0
  char *v4; // x8
  int v5; // w9

  v2 = *(_QWORD *)a1;
  globals = __cxa_get_globals(a1);
  v4 = (char *)a1 - 96;
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    v5 = *((_DWORD *)a1 - 12);
    if ( v5 < 0 )
      v5 = -v5;
    *((_DWORD *)a1 - 12) = v5 + 1;
    if ( *(char **)globals != v4 )
    {
      *((_QWORD *)a1 - 7) = *(_QWORD *)globals;
      *(_QWORD *)globals = v4;
    }
    --*(_DWORD *)(globals + 8);
    return (void *)*((_QWORD *)a1 - 2);
  }
  else
  {
    if ( *(_QWORD *)globals )
      std::terminate();
    *(_QWORD *)globals = v4;
    return (char *)a1 + 32;
  }
}
// 11BA0: using guessed type __int64 __fastcall __cxa_get_globals(_QWORD);
// 11D60: using guessed type _QWORD std::terminate(void);

//----- (0000000000034B14) ----------------------------------------------------
void _cxa_end_catch(void)
{
  __int64 *globals_fast; // x20
  __int64 v1; // x19
  unsigned __int64 v2; // x8
  int v3; // w9
  int v4; // w9
  __int64 v5; // x20
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  void (__fastcall *v8)(__int64); // x8

  globals_fast = (__int64 *)__cxa_get_globals_fast();
  v1 = *globals_fast;
  if ( *globals_fast )
  {
    v2 = *(_QWORD *)(v1 + 96);
    if ( v2 >> 8 == 0x434C4E47432B2BLL )
    {
      v3 = *(_DWORD *)(v1 + 48);
      if ( v3 < 0 )
      {
        *(_DWORD *)(v1 + 48) = v3 + 1;
        if ( v3 == -1 )
          *globals_fast = *(_QWORD *)(v1 + 40);
      }
      else
      {
        v4 = v3 - 1;
        *(_DWORD *)(v1 + 48) = v4;
        if ( !v4 )
        {
          *globals_fast = *(_QWORD *)(v1 + 40);
          if ( (unsigned __int8)v2 == 1 )
          {
            v5 = *(_QWORD *)v1 - 128LL;
            _cxa_free_dependent_exception_0((int *)v1);
            v1 = v5;
          }
          do
          {
            v6 = __ldaxr((unsigned __int64 *)v1);
            v7 = v6 - 1;
          }
          while ( __stlxr(v7, (unsigned __int64 *)v1) );
          if ( !v7 )
          {
            v8 = *(void (__fastcall **)(__int64))(v1 + 16);
            if ( v8 )
              v8(v1 + 128);
            _cxa_free_dependent_exception_0((int *)v1);
          }
        }
      }
    }
    else
    {
      sub_5E1FC(v1 + 96);
      *globals_fast = 0;
    }
  }
}

//----- (0000000000034BF4) ----------------------------------------------------
void __fastcall _cxa_decrement_exception_refcount(__int64 a1)
{
  unsigned __int64 *v1; // x19
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x8
  void (*v4)(void); // x8

  if ( a1 )
  {
    v1 = (unsigned __int64 *)(a1 - 128);
    do
    {
      v2 = __ldaxr(v1);
      v3 = v2 - 1;
    }
    while ( __stlxr(v3, v1) );
    if ( !v3 )
    {
      v4 = *(void (**)(void))(a1 - 112);
      if ( v4 )
        v4();
      _cxa_free_dependent_exception_0((int *)v1);
    }
  }
}

//----- (0000000000034C44) ----------------------------------------------------
struct type_info *_cxa_current_exception_type(void)
{
  struct type_info *result; // x0
  __int64 v1; // x8

  result = (struct type_info *)__cxa_get_globals_fast();
  if ( result )
  {
    v1 = *(_QWORD *)result;
    if ( *(_QWORD *)result )
    {
      if ( *(_QWORD *)(v1 + 96) >> 8 == 0x434C4E47432B2BLL )
        return *(struct type_info **)(v1 + 8);
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0000000000034CA0) ----------------------------------------------------
void __noreturn _cxa_rethrow(void)
{
  __int64 v0; // x0
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  __int64 v8; // x20
  unsigned __int64 v9; // x22
  _QWORD *v10; // x0
  __int64 v11; // x23
  __int64 globals; // x0
  int v13; // w9
  char v14; // [xsp+0h] [xbp-30h]

  v0 = ((__int64 (*)(void))__cxa_get_globals)();
  v8 = *(_QWORD *)v0;
  if ( *(_QWORD *)v0 )
  {
    v9 = *(_QWORD *)(v8 + 96) & 0xFFFFFFFFFFFFFF00LL;
    if ( v9 == 0x434C4E47432B2B00LL )
    {
      *(_DWORD *)(v8 + 48) = -*(_DWORD *)(v8 + 48);
      ++*(_DWORD *)(v0 + 8);
    }
    else
    {
      *(_QWORD *)v0 = 0;
    }
    v10 = sub_5DD9C((_QWORD *)(v8 + 96), v1, v2, v3, v4, v5, v6, v7, v14);
    v11 = *(_QWORD *)(v8 + 96);
    globals = __cxa_get_globals(v10);
    if ( (v11 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
    {
      v13 = *(_DWORD *)(v8 + 48);
      if ( v13 < 0 )
        v13 = -v13;
      *(_DWORD *)(v8 + 48) = v13 + 1;
      if ( *(_QWORD *)globals != v8 )
      {
        *(_QWORD *)(v8 + 40) = *(_QWORD *)globals;
        *(_QWORD *)globals = v8;
      }
      --*(_DWORD *)(globals + 8);
      if ( v9 == 0x434C4E47432B2B00LL )
LABEL_11:
        sub_3518C(*(_QWORD *)(v8 + 32));
    }
    else if ( !*(_QWORD *)globals )
    {
      *(_QWORD *)globals = v8;
      if ( v9 == 0x434C4E47432B2B00LL )
        goto LABEL_11;
    }
  }
  std::terminate();
}
// 34D08: variable 'v1' is possibly undefined
// 34D08: variable 'v2' is possibly undefined
// 34D08: variable 'v3' is possibly undefined
// 34D08: variable 'v4' is possibly undefined
// 34D08: variable 'v5' is possibly undefined
// 34D08: variable 'v6' is possibly undefined
// 34D08: variable 'v7' is possibly undefined
// 34D08: variable 'v14' is possibly undefined
// 11BA0: using guessed type __int64 __fastcall __cxa_get_globals(_QWORD);
// 11D60: using guessed type _QWORD std::terminate(void);
// 3518C: using guessed type void __fastcall __noreturn sub_3518C(_QWORD);

//----- (0000000000034D84) ----------------------------------------------------
__int64 __fastcall _cxa_increment_exception_refcount(__int64 result)
{
  unsigned __int64 *v1; // x8
  unsigned __int64 v2; // x9

  if ( result )
  {
    v1 = (unsigned __int64 *)(result - 128);
    do
      v2 = __ldaxr(v1);
    while ( __stlxr(v2 + 1, v1) );
  }
  return result;
}

//----- (0000000000034DA0) ----------------------------------------------------
unsigned __int64 **_cxa_current_primary_exception()
{
  unsigned __int64 **result; // x0
  unsigned __int64 *v1; // x8
  unsigned __int64 v2; // x9

  result = (unsigned __int64 **)__cxa_get_globals_fast();
  if ( result )
  {
    v1 = *result;
    if ( *result )
    {
      if ( v1[12] >> 8 == 0x434C4E47432B2BLL )
      {
        if ( (unsigned __int8)v1[12] == 1 )
          v1 = (unsigned __int64 *)(*v1 - 128);
        result = (unsigned __int64 **)(v1 + 16);
        do
          v2 = __ldaxr(v1);
        while ( __stlxr(v2 + 1, v1) );
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0000000000034E24) ----------------------------------------------------
_DWORD *__fastcall _cxa_rethrow_primary_exception(_DWORD *result)
{
  _DWORD *v1; // x20
  char *v2; // x0
  char *v3; // x19
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x8
  unsigned __int64 terminate; // x0
  _DWORD *globals; // x0
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x3
  __int64 v11; // x4
  __int64 v12; // x5
  __int64 v13; // x6
  __int64 v14; // x7
  __int64 v15; // x20
  int v16; // w8
  char v17; // [xsp+0h] [xbp-20h]

  v1 = result;
  if ( !result )
    return result;
  v2 = (char *)sub_35F0C(0x80u);
  v3 = v2;
  if ( !v2 )
LABEL_14:
    std::terminate();
  v4 = (unsigned __int64 *)(v1 - 32);
  memset(v2 + 8, 0, 0x78u);
  *(_QWORD *)v3 = v1;
  do
    v5 = __ldaxr(v4);
  while ( __stlxr(v5 + 1, v4) );
  *((_QWORD *)v3 + 1) = *((_QWORD *)v1 - 15);
  *((_QWORD *)v3 + 3) = std::get_unexpected();
  terminate = std::get_terminate();
  *((_QWORD *)v3 + 12) = 0x434C4E47432B2B01LL;
  *((_QWORD *)v3 + 4) = terminate;
  globals = __cxa_get_globals();
  ++globals[2];
  *((_QWORD *)v3 + 13) = sub_34F3C;
  sub_5DD9C((_QWORD *)v3 + 12, v8, v9, v10, v11, v12, v13, v14, v17);
  v15 = *((_QWORD *)v3 + 12);
  result = __cxa_get_globals();
  if ( (v15 & 0xFFFFFFFFFFFFFF00LL) != 0x434C4E47432B2B00LL )
  {
    if ( !*(_QWORD *)result )
    {
      *(_QWORD *)result = v3;
      return result;
    }
    goto LABEL_14;
  }
  v16 = *((_DWORD *)v3 + 12);
  if ( v16 < 0 )
    v16 = -v16;
  *((_DWORD *)v3 + 12) = v16 + 1;
  if ( *(char **)result != v3 )
  {
    *((_QWORD *)v3 + 5) = *(_QWORD *)result;
    *(_QWORD *)result = v3;
  }
  --result[2];
  return result;
}
// 34EC8: variable 'v8' is possibly undefined
// 34EC8: variable 'v9' is possibly undefined
// 34EC8: variable 'v10' is possibly undefined
// 34EC8: variable 'v11' is possibly undefined
// 34EC8: variable 'v12' is possibly undefined
// 34EC8: variable 'v13' is possibly undefined
// 34EC8: variable 'v14' is possibly undefined
// 34EC8: variable 'v17' is possibly undefined

//----- (0000000000034F3C) ----------------------------------------------------
void __fastcall sub_34F3C(int a1, __int64 a2)
{
  int *v2; // x19
  __int64 v3; // x0
  unsigned __int64 *v4; // x20
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  void (*v7)(void); // x8

  if ( a1 != 1 )
    sub_3518C(*(void (**)(void))(a2 - 64));
  v2 = (int *)(a2 - 96);
  v3 = *(_QWORD *)(a2 - 96);
  if ( v3 )
  {
    v4 = (unsigned __int64 *)(v3 - 128);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while ( __stlxr(v6, v4) );
    if ( !v6 )
    {
      v7 = *(void (**)(void))(v3 - 112);
      if ( v7 )
        v7();
      _cxa_free_dependent_exception_0((int *)v4);
    }
  }
  _cxa_free_dependent_exception_0(v2);
}

//----- (0000000000034FA8) ----------------------------------------------------
_DWORD *_cxa_uncaught_exception()
{
  _DWORD *result; // x0

  result = __cxa_get_globals_fast();
  if ( result )
    return (_DWORD *)(result[2] != 0);
  return result;
}

//----- (0000000000034FD0) ----------------------------------------------------
unsigned int *_cxa_uncaught_exceptions()
{
  unsigned int *result; // x0

  result = (unsigned int *)__cxa_get_globals_fast();
  if ( result )
    return (unsigned int *)result[2];
  return result;
}

//----- (0000000000034FF0) ----------------------------------------------------
void *_cxa_get_globals()
{
  void *v0; // x19

  if ( pthread_once(dword_80048, (void (*)(void))sub_350BC) )
    sub_36294("execute once failure in __cxa_get_globals_fast()");
  v0 = pthread_getspecific(dword_80044);
  if ( !v0 )
  {
    v0 = sub_3606C(1u, 0x10u);
    if ( !v0 )
      sub_36294("cannot allocate __cxa_eh_globals");
    if ( pthread_setspecific(dword_80044, v0) )
      sub_36294("std::__libcpp_tls_set failure in __cxa_get_globals()");
  }
  return v0;
}
// 80044: using guessed type int dword_80044;
// 80048: using guessed type pthread_once_t dword_80048[2];

//----- (0000000000035080) ----------------------------------------------------
void *_cxa_get_globals_fast()
{
  if ( pthread_once(dword_80048, (void (*)(void))sub_350BC) )
    sub_36294("execute once failure in __cxa_get_globals_fast()");
  return pthread_getspecific(dword_80044);
}
// 80044: using guessed type int dword_80044;
// 80048: using guessed type pthread_once_t dword_80048[2];

//----- (00000000000350BC) ----------------------------------------------------
__int64 sub_350BC()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_80044, (void (*)(void *))sub_350F0);
  if ( (_DWORD)result )
    sub_36294("cannot create thread specific key for __cxa_get_globals()");
  return result;
}
// 80044: using guessed type int dword_80044;

//----- (00000000000350F0) ----------------------------------------------------
__int64 __fastcall sub_350F0(void *a1)
{
  __int64 result; // x0

  sub_361E0(a1);
  result = pthread_setspecific(dword_80044, 0);
  if ( (_DWORD)result )
    sub_36294("cannot zero out thread value for __cxa_get_globals()");
  return result;
}
// 80044: using guessed type int dword_80044;

//----- (0000000000035124) ----------------------------------------------------
unsigned __int64 std::get_unexpected()
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr(result, (unsigned __int64 *)&_cxa_unexpected_handler) );
  return result;
}
// 80028: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000003513C) ----------------------------------------------------
void __fastcall __noreturn sub_3513C(void (*a1)(void))
{
  a1();
  sub_36294("unexpected_handler unexpectedly returned");
}

//----- (0000000000035154) ----------------------------------------------------
void __noreturn std::unexpected()
{
  void (*v0)(void); // x0

  do
    v0 = (void (*)(void))__ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr((unsigned __int64)v0, (unsigned __int64 *)&_cxa_unexpected_handler) );
  sub_3513C(v0);
}
// 80028: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (0000000000035174) ----------------------------------------------------
unsigned __int64 std::get_terminate()
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr((unsigned __int64 *)&_cxa_terminate_handler);
  while ( __stlxr(result, (unsigned __int64 *)&_cxa_terminate_handler) );
  return result;
}
// 80020: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (000000000003518C) ----------------------------------------------------
void __fastcall __noreturn sub_3518C(void (*a1)(void))
{
  a1();
  sub_36294("terminate_handler unexpectedly returned");
}
// 346C0: using guessed type void __fastcall __noreturn sub_346C0(_QWORD);

//----- (00000000000351CC) ----------------------------------------------------
void __noreturn std::terminate()
{
  __int64 *globals_fast; // x0
  __int64 v1; // x8
  void (*v2)(void); // x0

  globals_fast = (__int64 *)__cxa_get_globals_fast();
  if ( !globals_fast || (v1 = *globals_fast) == 0 || *(_QWORD *)(v1 + 96) >> 8 != 0x434C4E47432B2BLL )
  {
    do
      v2 = (void (*)(void))__ldaxr((unsigned __int64 *)&_cxa_terminate_handler);
    while ( __stlxr((unsigned __int64)v2, (unsigned __int64 *)&_cxa_terminate_handler) );
    sub_3518C(v2);
  }
  sub_3518C(*(void (**)(void))(v1 + 32));
}
// 346C0: using guessed type void __fastcall __noreturn sub_346C0(_QWORD);
// 80020: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (0000000000035224) ----------------------------------------------------
unsigned __int64 __fastcall std::set_new_handler(unsigned __int64 a1)
{
  unsigned __int64 v1; // x8

  do
    v1 = __ldaxr((unsigned __int64 *)&_cxa_new_handler);
  while ( __stlxr(a1, (unsigned __int64 *)&_cxa_new_handler) );
  return v1;
}
// 80050: using guessed type __int64 _cxa_new_handler;

//----- (0000000000035240) ----------------------------------------------------
unsigned __int64 std::get_new_handler()
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr((unsigned __int64 *)&_cxa_new_handler);
  while ( __stlxr(result, (unsigned __int64 *)&_cxa_new_handler) );
  return result;
}
// 80050: using guessed type __int64 _cxa_new_handler;

//----- (0000000000035258) ----------------------------------------------------
__int64 __fastcall _gxx_personality_v0(int a1, char a2, __int64 a3, unsigned __int16 *a4, _QWORD *a5)
{
  bool v7; // zf
  __int64 result; // x0
  unsigned __int64 v9; // x21
  __int64 v10; // x1
  __int64 v11; // x0
  __int64 v12; // x21
  __int64 v13; // x22
  __int64 v14; // [xsp+8h] [xbp-68h] BYREF
  __int128 v15; // [xsp+10h] [xbp-60h]
  __int128 v16; // [xsp+20h] [xbp-50h]
  unsigned int v17; // [xsp+30h] [xbp-40h]
  __int64 v18; // [xsp+38h] [xbp-38h]

  v7 = a1 == 1;
  result = 3;
  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( v7 && a4 && a5 )
  {
    v9 = a3 & 0xFFFFFFFFFFFFFF00LL;
    if ( (a2 & 1) != 0 )
    {
      sub_35434((__int64)&v14, a2, v9 == 0x434C4E47432B2B00LL, a4, (__int64)a5);
      result = v17;
      if ( v17 == 6 && v9 == 0x434C4E47432B2B00LL )
      {
        result = 6;
        *((_DWORD *)a4 - 11) = v14;
        *(_OWORD *)(a4 - 20) = v15;
        *(_OWORD *)(a4 - 12) = v16;
      }
    }
    else
    {
      if ( (a2 & 2) == 0 )
        return 3;
      if ( (a2 & 4) != 0 )
      {
        if ( v9 == 0x434C4E47432B2B00LL )
        {
          v12 = *((int *)a4 - 11);
          v14 = v12;
          v15 = *(_OWORD *)(a4 - 20);
          v16 = *(_OWORD *)(a4 - 12);
          v13 = v16;
        }
        else
        {
          sub_35434((__int64)&v14, a2, 0, a4, (__int64)a5);
          if ( v17 != 6 )
            sub_359E4(0, a4);
          v12 = v14;
          v13 = v16;
        }
        sub_5C7B8(a5, 0, (__int64)a4);
        sub_5C7B8(a5, 1, v12);
        v11 = (__int64)a5;
        v10 = v13;
      }
      else
      {
        sub_35434((__int64)&v14, a2, v9 == 0x434C4E47432B2B00LL, a4, (__int64)a5);
        result = v17;
        if ( v17 != 6 )
          return result;
        sub_5C7B8(a5, 0, (__int64)a4);
        sub_5C7B8(a5, 1, v14);
        v10 = v16;
        v11 = (__int64)a5;
      }
      sub_5C82C(v11, v10);
      return 7;
    }
  }
  return result;
}

//----- (0000000000035434) ----------------------------------------------------
__int64 __fastcall sub_35434(__int64 result, char a2, char a3, unsigned __int16 *a4, __int64 a5)
{
  __int64 v7; // x19
  unsigned __int8 *v8; // x24
  __int64 v9; // x26
  __int64 v10; // x25
  unsigned __int64 v11; // x0
  unsigned __int16 *v12; // x9
  unsigned __int64 v13; // x22
  unsigned __int16 *v14; // x8
  __int64 v15; // x10
  __int64 v16; // x9
  char v17; // t1
  unsigned __int16 *v18; // x28
  unsigned __int16 *v19; // x21
  unsigned int v20; // w24
  __int64 v21; // x10
  __int64 v22; // x9
  unsigned __int64 v23; // x27
  char v24; // t1
  __int64 v25; // x23
  unsigned __int64 v26; // x25
  unsigned __int64 v27; // x26
  unsigned __int16 *v28; // x9
  __int64 v29; // x10
  __int64 v30; // x8
  char v31; // t1
  __int64 v32; // x25
  __int64 v33; // x27
  unsigned int v34; // w21
  unsigned __int64 v35; // x9
  __int64 v36; // x8
  char *v37; // x20
  char v38; // w10
  char v39; // t1
  bool v40; // w11
  __int64 v41; // x9
  __int64 v42; // x26
  unsigned __int16 *v43; // x8
  __int64 v44; // x1
  char v45; // w8
  unsigned __int16 *v46; // x23
  __int64 v47; // x24
  __int64 v48; // x9
  __int64 v49; // x8
  char *v50; // x22
  char v51; // t1
  unsigned __int64 v52; // x0
  __int64 v53; // x10
  unsigned __int64 v54; // x9
  __int64 v55; // x8
  char v56; // w11
  unsigned int v57; // w10
  _BOOL4 v58; // w11
  __int64 v59; // x9
  __int64 v60; // x8
  int v61; // w8
  unsigned __int16 *v62; // x8
  unsigned __int64 v63; // [xsp+0h] [xbp-B0h]
  _QWORD *v64; // [xsp+18h] [xbp-98h]
  char v66; // [xsp+34h] [xbp-7Ch]
  unsigned int v68; // [xsp+3Ch] [xbp-74h]
  unsigned __int16 *v69; // [xsp+40h] [xbp-70h] BYREF
  unsigned __int16 *v70; // [xsp+48h] [xbp-68h] BYREF
  unsigned __int16 *v71[2]; // [xsp+50h] [xbp-60h] BYREF

  v7 = result;
  v71[1] = *(unsigned __int16 **)(_ReadStatusReg(TPIDR_EL0) + 40);
  *(_QWORD *)(result + 32) = 0;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_DWORD *)(result + 40) = 3;
  if ( (a2 & 1) != 0 )
  {
    if ( (a2 & 0xE) == 0 )
      goto LABEL_8;
LABEL_5:
    *(_DWORD *)(result + 40) = 3;
    return result;
  }
  if ( (a2 & 2) == 0 )
    goto LABEL_5;
  if ( (~a2 & 0xC) == 0 )
  {
    *(_DWORD *)(result + 40) = 2;
    return result;
  }
LABEL_8:
  result = sub_5C834(a5);
  v8 = (unsigned __int8 *)result;
  v70 = (unsigned __int16 *)result;
  if ( !result )
  {
    *(_DWORD *)(v7 + 40) = 8;
    return result;
  }
  *(_QWORD *)(v7 + 16) = result;
  v9 = sub_5C810(a5) - 1;
  v70 = (unsigned __int16 *)(v8 + 1);
  v10 = sub_5C83C(a5);
  v11 = sub_35D90(&v70, *v8);
  v12 = v70;
  if ( v11 )
    v13 = v11;
  else
    v13 = v10;
  v14 = (unsigned __int16 *)((char *)v70 + 1);
  v70 = (unsigned __int16 *)((char *)v70 + 1);
  v66 = a3;
  v68 = *(unsigned __int8 *)v12;
  if ( v68 == 255 )
  {
    v18 = 0;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    do
    {
      v17 = *(_BYTE *)v14;
      v14 = (unsigned __int16 *)((char *)v14 + 1);
      v16 |= (unsigned __int64)(v17 & 0x7F) << v15;
      v15 += 7;
    }
    while ( v17 < 0 );
    v18 = (unsigned __int16 *)((char *)v14 + v16);
    v70 = v14;
  }
  v19 = (unsigned __int16 *)((char *)v14 + 1);
  v70 = (unsigned __int16 *)((char *)v14 + 1);
  v20 = *(unsigned __int8 *)v14;
  v21 = 0;
  v22 = 0;
  v23 = v9 - v10;
  do
  {
    v24 = *(_BYTE *)v19;
    v19 = (unsigned __int16 *)((char *)v19 + 1);
    v22 |= (unsigned __int64)(v24 & 0x7F) << v21;
    v21 += 7;
  }
  while ( v24 < 0 );
  v25 = (unsigned int)v22;
  v69 = v19;
  v70 = v19;
  if ( !(_DWORD)v22 )
LABEL_27:
    sub_359E4(v66 & 1, a4);
  while ( 1 )
  {
    v26 = sub_35D90(&v69, v20);
    v27 = sub_35D90(&v69, v20);
    result = sub_35D90(&v69, v20);
    v28 = v69;
    v29 = 0;
    v30 = 0;
    do
    {
      v31 = *(_BYTE *)v28;
      v28 = (unsigned __int16 *)((char *)v28 + 1);
      v30 |= (unsigned __int64)(v31 & 0x7F) << v29;
      v29 += 7;
    }
    while ( v31 < 0 );
    v69 = v28;
    if ( v26 <= v23 && v23 < v27 + v26 )
      break;
    if ( v23 < v26 || v28 >= (unsigned __int16 *)((char *)v19 + v25) )
      goto LABEL_27;
  }
  if ( !result )
  {
LABEL_81:
    v61 = 8;
    goto LABEL_86;
  }
  if ( !v30 )
  {
    if ( (a2 & 6) == 2 )
    {
      *(_QWORD *)v7 = 0;
      *(_QWORD *)(v7 + 24) = result + v13;
      goto LABEL_85;
    }
    goto LABEL_81;
  }
  v63 = result + v13;
  v64 = a4 + 16;
  v32 = (v68 + 6) & 0xFLL;
  v33 = (__int64)v19 + v25 + v30 - 1;
  v34 = (0x747u >> v32) & 1;
  while ( 1 )
  {
    v35 = 0;
    v36 = 0;
    v37 = (char *)v33;
    do
    {
      v39 = *v37++;
      v38 = v39;
      v36 |= (unsigned __int64)(v39 & 0x7F) << v35;
      v35 += 7LL;
    }
    while ( v39 < 0 );
    v40 = v35 < 0x40;
    v41 = -1LL << v35;
    if ( (*(_DWORD *)&v40 & ((unsigned __int8)(v38 & 0x40) >> 6)) == 0 )
      v41 = 0;
    v42 = v36 | v41;
    if ( (v36 | v41) < 1 )
      break;
    v71[0] = v18;
    if ( !v18 || ((v68 + 6) & 0xF) > 0xA || !v34 )
      goto LABEL_27;
    v71[0] = (unsigned __int16 *)((char *)v18 - (v42 << qword_63750[v32]));
    result = sub_35D90(v71, v68);
    if ( result )
    {
      if ( (v66 & 1) == 0 )
        goto LABEL_73;
      v43 = a4 + 16;
      if ( *(_QWORD *)a4 == 0x434C4E47432B2B01LL )
        v43 = (unsigned __int16 *)*((_QWORD *)a4 - 12);
      v71[0] = v43;
      if ( !v43 || (v44 = *((_QWORD *)a4 - 11)) == 0 )
        sub_359E4(1, a4);
      result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int16 **))(*(_QWORD *)result + 32LL))(
                 result,
                 v44,
                 v71);
      if ( (result & 1) == 0 )
        goto LABEL_73;
      v45 = a2;
      if ( (a2 & 1) != 0 )
      {
        *(_QWORD *)v7 = v42;
        *(_QWORD *)(v7 + 8) = v33;
        *(_QWORD *)(v7 + 24) = v63;
        v62 = v71[0];
        *(_DWORD *)(v7 + 40) = 6;
        *(_QWORD *)(v7 + 32) = v62;
        return result;
      }
      goto LABEL_72;
    }
    if ( (a2 & 5) != 0 )
      goto LABEL_82;
    if ( (a2 & 8) == 0 )
      goto LABEL_27;
LABEL_73:
    v53 = 0;
    v54 = 0;
    v55 = 0;
    do
    {
      v56 = v37[v53++];
      v55 |= (unsigned __int64)(v56 & 0x7F) << v54;
      v54 += 7LL;
    }
    while ( v56 < 0 );
    v57 = v56 & 0x40;
    v58 = v54 < 0x40;
    v59 = -1LL << v54;
    if ( (v58 & (v57 >> 6)) == 0 )
      v59 = 0;
    v60 = v55 | v59;
    if ( !v60 )
      goto LABEL_81;
    v33 = (__int64)&v37[v60];
  }
  if ( (v42 & 0x8000000000000000LL) == 0 )
  {
    if ( (a2 & 6) == 2 )
      goto LABEL_82;
    goto LABEL_73;
  }
  if ( (v66 & 1) != 0 )
  {
    v46 = a4 + 16;
    if ( *(_QWORD *)a4 == 0x434C4E47432B2B01LL )
      v46 = (unsigned __int16 *)*((_QWORD *)a4 - 12);
    if ( !v46 || (v47 = *((_QWORD *)a4 - 11)) == 0 )
      sub_359E4(1, a4);
    if ( !v18 )
LABEL_91:
      sub_359E4(0, a4);
    v48 = 0;
    v49 = 0;
    v50 = (char *)v18 + ~v42;
    while ( 1 )
    {
      do
      {
        v51 = *v50++;
        v49 |= (unsigned __int64)(v51 & 0x7F) << v48;
        v48 += 7;
      }
      while ( v51 < 0 );
      if ( !v49 )
        break;
      v71[0] = v18;
      if ( ((v68 + 6) & 0xF) > 0xA || !v34 )
        goto LABEL_88;
      v71[0] = (unsigned __int16 *)((char *)v18 - (v49 << qword_63750[v32]));
      v52 = sub_35D90(v71, v68);
      v71[0] = v46;
      result = (*(__int64 (__fastcall **)(unsigned __int64, __int64, unsigned __int16 **))(*(_QWORD *)v52 + 32LL))(
                 v52,
                 v47,
                 v71);
      v48 = 0;
      v49 = 0;
      if ( (result & 1) != 0 )
        goto LABEL_73;
    }
    v45 = a2;
    if ( (a2 & 1) != 0 )
    {
      *(_QWORD *)v7 = v42;
      *(_QWORD *)(v7 + 8) = v33;
      *(_QWORD *)(v7 + 24) = v63;
      *(_QWORD *)(v7 + 32) = v46;
      goto LABEL_85;
    }
LABEL_72:
    if ( (v45 & 8) == 0 )
LABEL_88:
      sub_359E4(1, a4);
    goto LABEL_73;
  }
  if ( (a2 & 5) == 0 )
  {
    if ( (a2 & 8) == 0 )
      goto LABEL_91;
    goto LABEL_73;
  }
LABEL_82:
  *(_QWORD *)v7 = v42;
  *(_QWORD *)(v7 + 8) = v33;
  *(_QWORD *)(v7 + 24) = v63;
  if ( *(_QWORD *)a4 == 0x434C4E47432B2B01LL )
    v64 = (_QWORD *)*((_QWORD *)a4 - 12);
  *(_QWORD *)(v7 + 32) = v64;
LABEL_85:
  v61 = 6;
LABEL_86:
  *(_DWORD *)(v7 + 40) = v61;
  return result;
}
// 63750: using guessed type _QWORD qword_63750[11];

//----- (00000000000359E4) ----------------------------------------------------
void __fastcall __noreturn sub_359E4(char a1, void *a2)
{
  __cxa_begin_catch(a2);
  if ( (a1 & 1) != 0 )
    sub_3518C(*((_QWORD *)a2 - 8));
  std::terminate();
}
// 11D60: using guessed type _QWORD std::terminate(void);
// 3518C: using guessed type void __fastcall __noreturn sub_3518C(_QWORD);

//----- (0000000000035A10) ----------------------------------------------------
void __noreturn _cxa_call_unexpected(void *a1)
{
  void (*unexpected)(void); // x0
  __int64 v3; // [xsp+30h] [xbp-60h]

  if ( !a1 )
    sub_359E4(0, 0);
  __cxa_begin_catch(a1);
  if ( (*(_QWORD *)a1 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
  {
    unexpected = (void (*)(void))*((_QWORD *)a1 - 9);
    v3 = *((_QWORD *)a1 - 4);
  }
  else
  {
    std::get_terminate();
    unexpected = (void (*)(void))std::get_unexpected();
  }
  sub_3513C(unexpected);
}
// 3518C: using guessed type void __fastcall __noreturn sub_3518C(_QWORD);

//----- (0000000000035D90) ----------------------------------------------------
unsigned __int64 __fastcall sub_35D90(unsigned __int16 **a1, unsigned int a2)
{
  unsigned __int16 *v2; // x10
  unsigned __int64 v3; // x8
  unsigned __int16 *v4; // x9
  int v5; // w11
  __int64 v6; // x11
  char v7; // t1
  unsigned __int64 v9; // x11
  __int64 v10; // x8
  char v11; // w12
  char v12; // t1
  bool v13; // w14
  __int64 v14; // x11

  if ( (_BYTE)a2 == 0xFF )
    return 0;
  v2 = *a1;
  switch ( a2 & 0xF )
  {
    case 0u:
    case 4u:
    case 0xCu:
      v4 = v2 + 4;
      v3 = *(_QWORD *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 1u:
      v6 = 0;
      v3 = 0;
      v4 = *a1;
      do
      {
        v7 = *(_BYTE *)v4;
        v4 = (unsigned __int16 *)((char *)v4 + 1);
        v3 |= (unsigned __int64)(v7 & 0x7F) << v6;
        v6 += 7;
      }
      while ( v7 < 0 );
      v5 = (a2 >> 4) & 7;
      if ( v5 )
        goto LABEL_9;
      goto LABEL_12;
    case 2u:
      v4 = v2 + 1;
      v3 = *v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 3u:
      v4 = v2 + 2;
      v3 = *(unsigned int *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 9u:
      v9 = 0;
      v10 = 0;
      v4 = *a1;
      do
      {
        v12 = *(_BYTE *)v4;
        v4 = (unsigned __int16 *)((char *)v4 + 1);
        v11 = v12;
        v10 |= (unsigned __int64)(v12 & 0x7F) << v9;
        v9 += 7LL;
      }
      while ( v12 < 0 );
      v13 = v9 < 0x40;
      v14 = -1LL << v9;
      if ( (*(_DWORD *)&v13 & ((unsigned __int8)(v11 & 0x40) >> 6)) == 0 )
        v14 = 0;
      v3 = v10 | v14;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 0xAu:
      v4 = v2 + 1;
      v3 = (__int16)*v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 0xBu:
      v4 = v2 + 2;
      v3 = *(int *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
LABEL_9:
      if ( v5 != 1 )
        goto LABEL_31;
      if ( v3 )
      {
        v3 += (unsigned __int64)v2;
LABEL_12:
        if ( (char)a2 < 0 && v3 )
          v3 = *(_QWORD *)v3;
      }
      *a1 = v4;
      break;
    default:
LABEL_31:
      abort();
  }
  return v3;
}

//----- (0000000000035EE4) ----------------------------------------------------
void __noreturn _cxa_pure_virtual(void)
{
  sub_36294("Pure virtual function called!");
}

//----- (0000000000035EF8) ----------------------------------------------------
void __noreturn _cxa_deleted_virtual(void)
{
  sub_36294("Deleted virtual function called!");
}

//----- (0000000000035F0C) ----------------------------------------------------
void *__fastcall sub_35F0C(size_t a1)
{
  unsigned __int64 StatusReg; // x20
  size_t v2; // x19
  void *v4[2]; // [xsp+0h] [xbp-20h] BYREF

  StatusReg = _ReadStatusReg(TPIDR_EL0);
  if ( a1 )
    v2 = a1;
  else
    v2 = 1;
  v4[1] = *(void **)(StatusReg + 40);
  if ( posix_memalign(v4, 0x10u, v2) )
    return (void *)sub_35F78(v2);
  else
    return v4[0];
}
// 35F78: using guessed type __int64 __fastcall sub_35F78(_QWORD);

//----- (0000000000035F78) ----------------------------------------------------
unsigned __int16 *__fastcall sub_35F78(__int64 a1)
{
  int *v2; // x10
  unsigned __int16 *v3; // x19
  int *v4; // x12
  unsigned __int64 v5; // x11
  int *v6; // x19
  unsigned __int64 v7; // x10
  __int64 v8; // x10
  bool v9; // zf
  unsigned __int16 *v10; // x8
  __int64 v11; // x10

  pthread_mutex_lock(&stru_80060);
  v2 = (int *)qword_80088;
  if ( !qword_80088 )
  {
    v2 = dword_80090;
    qword_80088 = (__int64)dword_80090;
    dword_80090[0] = 8388736;
  }
  v3 = 0;
  if ( v2 && v2 != (int *)byte_80290 )
  {
    v4 = 0;
    v5 = ((unsigned __int64)(a1 + 3) >> 2) + 1;
    while ( 1 )
    {
      v6 = v2;
      v7 = *((unsigned __int16 *)v2 + 1);
      if ( v5 < v7 )
      {
        *((_WORD *)v6 + 1) = v7 - v5;
        v10 = (unsigned __int16 *)&v6[(unsigned __int16)(v7 - v5)];
        *v10 = 0;
        v10[1] = v5;
        v3 = v10 + 2;
        goto LABEL_16;
      }
      if ( v5 == v7 )
        break;
      v4 = v6;
      v8 = *(unsigned __int16 *)v6;
      v9 = v8 == 128;
      v2 = &dword_80090[v8];
      if ( v9 )
      {
        v3 = 0;
        goto LABEL_16;
      }
    }
    v11 = *(unsigned __int16 *)v6;
    if ( v4 )
      *(_WORD *)v4 = v11;
    else
      qword_80088 = (__int64)&dword_80090[v11];
    *(_WORD *)v6 = 0;
    v3 = (unsigned __int16 *)(v6 + 1);
  }
LABEL_16:
  pthread_mutex_unlock(&stru_80060);
  return v3;
}
// 80060: using guessed type pthread_mutex_t stru_80060;
// 80088: using guessed type __int64 qword_80088;
// 80090: using guessed type int dword_80090[128];

//----- (000000000003606C) ----------------------------------------------------
void *__fastcall sub_3606C(size_t a1, size_t a2)
{
  void *v4; // x19
  size_t v5; // x20
  unsigned __int16 *v6; // x0

  v4 = calloc(a1, a2);
  if ( !v4 )
  {
    v5 = a2 * a1;
    v6 = sub_35F78(v5);
    v4 = v6;
    if ( v6 )
      memset(v6, 0, v5);
  }
  return v4;
}

//----- (00000000000360C8) ----------------------------------------------------
void __fastcall _cxa_free_dependent_exception_0(int *a1)
{
  char *v2; // x20
  int *v3; // x12
  int *v4; // x11
  __int64 v5; // x13
  __int64 v6; // x14
  __int64 v7; // x12
  int *v8; // x13
  bool v9; // zf

  if ( a1 >= (int *)byte_80290 || a1 < dword_80090 )
  {
    free(a1);
  }
  else
  {
    v2 = (char *)(a1 - 1);
    pthread_mutex_lock(&stru_80060);
    if ( !qword_80088 || (char *)qword_80088 == byte_80290 )
    {
LABEL_12:
      *(_WORD *)v2 = ((unsigned int)qword_80088 - (unsigned int)dword_80090) >> 2;
      qword_80088 = (__int64)(a1 - 1);
    }
    else
    {
      v3 = 0;
      v4 = (int *)qword_80088;
      while ( 1 )
      {
        v5 = *((unsigned __int16 *)v4 + 1);
        if ( &v4[v5] == (int *)v2 )
        {
          *((_WORD *)v4 + 1) = *((_WORD *)a1 - 1) + v5;
          goto LABEL_17;
        }
        v6 = *((unsigned __int16 *)a1 - 1);
        if ( &v2[4 * v6] == (char *)v4 )
          break;
        v7 = *(unsigned __int16 *)v4;
        v8 = &dword_80090[v7];
        v9 = v7 == 128;
        v3 = v4;
        v4 = v8;
        if ( v9 )
          goto LABEL_12;
      }
      *((_WORD *)a1 - 1) = v6 + v5;
      if ( v3 )
      {
        *(_WORD *)v3 = (unsigned __int64)(v2 - (char *)dword_80090) >> 2;
      }
      else
      {
        qword_80088 = (__int64)(a1 - 1);
        *(_WORD *)v2 = *(_WORD *)v4;
      }
    }
LABEL_17:
    pthread_mutex_unlock(&stru_80060);
  }
}
// 346C0: using guessed type void __noreturn sub_346C0(void);
// 80060: using guessed type pthread_mutex_t stru_80060;
// 80088: using guessed type __int64 qword_80088;
// 80090: using guessed type int dword_80090[];

//----- (00000000000361E0) ----------------------------------------------------
void __fastcall sub_361E0(void *p)
{
  if ( p < &byte_80290 && p >= &dword_80090 )
    JUMPOUT(0x360EC);
  free(p);
}
// 361FC: control flows out of bounds to 360EC
// 80090: using guessed type int dword_80090;
// 80290: using guessed type char byte_80290;

//----- (000000000003620C) ----------------------------------------------------
const char *std::exception::what()
{
  return "std::exception";
}

//----- (000000000003621C) ----------------------------------------------------
const char *std::bad_exception::what()
{
  return "std::bad_exception";
}

//----- (0000000000036228) ----------------------------------------------------
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *result)
{
  *result = off_7F250;
  return result;
}
// 7F250: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (0000000000036240) ----------------------------------------------------
const char *std::bad_alloc::what()
{
  return "std::bad_alloc";
}

//----- (000000000003624C) ----------------------------------------------------
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *result)
{
  *result = off_7F278;
  return result;
}
// 7F278: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (0000000000036264) ----------------------------------------------------
const char *std::bad_array_new_length::what()
{
  return "bad_array_new_length";
}

//----- (0000000000036270) ----------------------------------------------------
_QWORD *__fastcall std::bad_array_length::bad_array_length(_QWORD *result)
{
  *result = off_7F2A0;
  return result;
}
// 7F2A0: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (0000000000036288) ----------------------------------------------------
const char *std::bad_array_length::what()
{
  return "bad_array_length";
}

//----- (0000000000036294) ----------------------------------------------------
void __noreturn sub_36294(const char *a1, ...)
{
  gcc_va_list va2; // [xsp+C0h] [xbp-E0h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-B8h] BYREF
  char *ptr; // [xsp+108h] [xbp-98h] BYREF
  gcc_va_list arg; // [xsp+110h] [xbp-90h] BYREF
  gcc_va_list va1; // [xsp+130h] [xbp-70h] BYREF

  va_start(va, a1);
  va_start(va1, a1);
  va_copy(arg, va1);
  vfprintf((FILE *)((char *)&_sF + 304), a1, arg);
  fputc(10, (FILE *)((char *)&_sF + 304));
  va_copy(va2, va);
  vasprintf(&ptr, a1, va2);
  android_set_abort_message(ptr);
  openlog("libc++abi", 0, 0);
  syslog(2, "%s", ptr);
  closelog();
  abort();
}
// 11900: using guessed type __int64 __fastcall android_set_abort_message(_QWORD);

//----- (0000000000036390) ----------------------------------------------------
unsigned __int64 __fastcall std::set_unexpected(void (__noreturn *a1)())
{
  void (__noreturn *v1)(); // x8
  unsigned __int64 result; // x0

  v1 = sub_36508;
  if ( a1 )
    v1 = a1;
  do
    result = __ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr((unsigned __int64)v1, (unsigned __int64 *)&_cxa_unexpected_handler) );
  return result;
}
// 80028: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (00000000000363B8) ----------------------------------------------------
unsigned __int64 __fastcall std::set_terminate(void (__noreturn *a1)())
{
  void (__noreturn *v1)(); // x8
  unsigned __int64 result; // x0

  v1 = sub_363E0;
  if ( a1 )
    v1 = a1;
  do
    result = __ldaxr((unsigned __int64 *)&_cxa_terminate_handler);
  while ( __stlxr((unsigned __int64)v1, (unsigned __int64 *)&_cxa_terminate_handler) );
  return result;
}
// 80020: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (00000000000363E0) ----------------------------------------------------
void __noreturn sub_363E0()
{
  _QWORD **globals_fast; // x0
  _QWORD *v1; // x8
  unsigned __int64 v2; // x9
  _QWORD *v3; // x9
  const char **v4; // x20
  char *v5; // x19
  const char *v6; // x20
  const char *v7; // x0
  size_t v8; // [xsp+0h] [xbp-430h] BYREF
  char out[1024]; // [xsp+Ch] [xbp-424h] BYREF
  int status; // [xsp+40Ch] [xbp-24h] BYREF
  _QWORD *v11; // [xsp+418h] [xbp-18h] BYREF

  globals_fast = (_QWORD **)__cxa_get_globals_fast();
  if ( !globals_fast || (v1 = *globals_fast) == 0 )
    sub_36294("terminating");
  v2 = v1[12];
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    if ( v2 == 0x434C4E47432B2B01LL )
      v3 = (_QWORD *)*v1;
    else
      v3 = v1 + 16;
    v11 = v3;
    v4 = (const char **)v1[1];
    v8 = 1024;
    v5 = __cxa_demangle(v4[1], out, &v8, &status);
    if ( status )
      v5 = (char *)v4[1];
    if ( ((unsigned __int8)sub_32FDC(&`typeinfo for'std::exception, v4, &v11) & 1) != 0 )
    {
      v6 = off_80030;
      v7 = (const char *)(*(__int64 (__fastcall **)(_QWORD *))(*v11 + 16LL))(v11);
      sub_36294("terminating with %s exception of type %s: %s", v6, v5, v7);
    }
    sub_36294("terminating with %s exception of type %s", off_80030, v5);
  }
  sub_36294("terminating with %s foreign exception", off_80030);
}
// 7F2E0: using guessed type __int64 *`typeinfo for'std::exception;
// 80030: using guessed type char *off_80030;

//----- (0000000000036508) ----------------------------------------------------
void __noreturn sub_36508()
{
  off_80030 = "unexpected";
  std::terminate();
}
// 11D60: using guessed type _QWORD std::terminate(void);
// 80030: using guessed type char *off_80030;

//----- (0000000000036524) ----------------------------------------------------
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  char *v6; // x19
  size_t v8; // x26
  size_t v9; // x0
  unsigned __int8 *v10; // x23
  int v11; // w8
  void **v12; // x21
  void **v13; // x20
  _QWORD *v14; // x0
  _QWORD *v15; // x20
  _QWORD *v16; // x24
  _QWORD *v17; // x27
  _QWORD *v18; // x28
  void **v19; // x24
  void **v20; // x27
  _QWORD *v21; // x21
  _QWORD *v22; // x0
  _QWORD *v23; // x22
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x9
  size_t v29; // x22
  size_t v30; // x23
  unsigned __int64 v31; // x9
  char *v32; // x1
  size_t v33; // x2
  char *v34; // x1
  void *v35; // [xsp+8h] [xbp-1108h] BYREF
  _QWORD *v36; // [xsp+10h] [xbp-1100h]
  __int64 v37; // [xsp+18h] [xbp-10F8h]
  _QWORD *v38; // [xsp+20h] [xbp-10F0h]
  void *p; // [xsp+28h] [xbp-10E8h]
  void **v40; // [xsp+30h] [xbp-10E0h]
  __int64 v41; // [xsp+38h] [xbp-10D8h]
  _QWORD *v42; // [xsp+40h] [xbp-10D0h]
  _QWORD *v43; // [xsp+48h] [xbp-10C8h] BYREF
  _QWORD *v44; // [xsp+50h] [xbp-10C0h]
  _QWORD *v45; // [xsp+58h] [xbp-10B8h]
  _BYTE v46[21]; // [xsp+60h] [xbp-10B0h] BYREF
  __int16 v47; // [xsp+75h] [xbp-109Bh]
  char v48; // [xsp+77h] [xbp-1099h]
  _QWORD v49[5]; // [xsp+78h] [xbp-1098h] BYREF
  _QWORD v50[4]; // [xsp+A0h] [xbp-1070h] BYREF
  _QWORD v51[512]; // [xsp+C0h] [xbp-1050h] BYREF

  v6 = lpout;
  v51[511] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !lpmangled || lpout && !lpoutlen )
  {
    v6 = 0;
    if ( lpstatus )
      *lpstatus = -3;
    return v6;
  }
  if ( lpout )
    v8 = *lpoutlen;
  else
    v8 = 0;
  v49[4] = v46;
  memset(v50, 0, 24);
  v47 = 1;
  v48 = 1;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = v50;
  v40 = 0;
  v41 = 0;
  p = 0;
  v42 = v50;
  *(_QWORD *)v46 = v50;
  memset(&v46[8], 0, 13);
  v51[508] = v51;
  v50[3] = v50;
  v43 = v50;
  v44 = v51;
  memset(v49, 0, 32);
  v45 = v51;
  sub_5859C((__int64)v49);
  LODWORD(v49[0]) = 0;
  v9 = strlen(lpmangled);
  v10 = (unsigned __int8 *)&lpmangled[v9];
  sub_36AA4((unsigned __int8 *)lpmangled, (unsigned __int8 *)&lpmangled[v9], &v35, v49);
  v11 = v49[0];
  if ( LODWORD(v49[0]) )
  {
LABEL_11:
    v6 = 0;
    if ( !lpstatus )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( HIBYTE(v47) && v43 != v44 && *v43 != v43[1] )
  {
    v16 = v35;
    v17 = v36;
    v47 = 0;
    if ( v36 != v35 )
    {
      do
      {
        if ( (*(_BYTE *)(v17 - 3) & 1) != 0 )
          free((void *)*(v17 - 1));
        v18 = v17 - 6;
        if ( (*(_BYTE *)(v17 - 6) & 1) != 0 )
          free((void *)*(v17 - 4));
        v17 -= 6;
      }
      while ( v16 != v18 );
    }
    v36 = v16;
    v20 = (void **)p;
    v19 = v40;
    if ( v40 != p )
    {
      do
      {
        v19 -= 4;
        sub_42F30(v19);
      }
      while ( v20 != v19 );
    }
    v40 = v20;
    sub_36AA4((unsigned __int8 *)lpmangled, v10, &v35, v49);
    if ( HIBYTE(v47) )
    {
      v11 = -2;
      v6 = 0;
      LODWORD(v49[0]) = -2;
      if ( !lpstatus )
        goto LABEL_13;
LABEL_12:
      *lpstatus = v11;
      goto LABEL_13;
    }
    v11 = v49[0];
    if ( LODWORD(v49[0]) )
      goto LABEL_11;
  }
  v25 = *((unsigned __int8 *)v36 - 48);
  if ( (v25 & 1) != 0 )
  {
    v26 = *(v36 - 5);
    v27 = *((unsigned __int8 *)v36 - 24);
    if ( (v27 & 1) != 0 )
      goto LABEL_54;
  }
  else
  {
    v26 = v25 >> 1;
    v27 = *((unsigned __int8 *)v36 - 24);
    if ( (v27 & 1) != 0 )
    {
LABEL_54:
      v28 = *(v36 - 2);
      goto LABEL_57;
    }
  }
  v28 = v27 >> 1;
LABEL_57:
  v29 = v28 + v26;
  v30 = v28 + v26 + 1;
  if ( v30 <= v8 )
  {
    if ( v6 )
      goto LABEL_62;
    v11 = 0;
    if ( lpstatus )
      goto LABEL_12;
  }
  else
  {
    v6 = (char *)realloc(v6, v28 + v26 + 1);
    if ( v6 )
    {
      if ( lpoutlen )
        *lpoutlen = v30;
LABEL_62:
      v31 = *((unsigned __int8 *)v36 - 24);
      if ( (v31 & 1) != 0 )
        v32 = (char *)*(v36 - 1);
      else
        v32 = (char *)v36 - 23;
      if ( (v31 & 1) != 0 )
        v33 = *(v36 - 2);
      else
        v33 = v31 >> 1;
      sub_42BE4(v36 - 6, v32, v33);
      if ( (*(_BYTE *)(v36 - 6) & 1) != 0 )
        v34 = (char *)*(v36 - 4);
      else
        v34 = (char *)v36 - 47;
      memcpy(v6, v34, v29);
      v11 = 0;
      v6[v29] = 0;
      if ( lpstatus )
        goto LABEL_12;
      goto LABEL_13;
    }
    v11 = -1;
    LODWORD(v49[0]) = -1;
    if ( lpstatus )
      goto LABEL_12;
  }
LABEL_13:
  ((void (__fastcall *)(_QWORD **))loc_5C290)(&v43);
  v12 = (void **)p;
  if ( !p )
    goto LABEL_37;
  v13 = v40;
  v14 = p;
  if ( v40 != p )
  {
    do
    {
      v13 -= 4;
      sub_42F30(v13);
    }
    while ( v12 != v13 );
    v14 = p;
  }
  v40 = v12;
  if ( v42 + 512 < v14 || v42 > v14 )
  {
    free(v14);
LABEL_37:
    v15 = v35;
    if ( !v35 )
      return v6;
    goto LABEL_38;
  }
  if ( v42[512] != v41 )
    goto LABEL_37;
  v42[512] = v14;
  v15 = v35;
  if ( !v35 )
    return v6;
LABEL_38:
  v21 = v36;
  v22 = v15;
  if ( v36 != v15 )
  {
    do
    {
      if ( (*(_BYTE *)(v21 - 3) & 1) != 0 )
        free((void *)*(v21 - 1));
      v23 = v21 - 6;
      if ( (*(_BYTE *)(v21 - 6) & 1) != 0 )
        free((void *)*(v21 - 4));
      v21 -= 6;
    }
    while ( v15 != v23 );
    v22 = v35;
  }
  v36 = v15;
  if ( v38 + 512 < v22 || v38 > v22 )
  {
    free(v22);
  }
  else if ( v38[512] == v37 )
  {
    v38[512] = v22;
  }
  return v6;
}

//----- (0000000000036AA4) ----------------------------------------------------
void __fastcall sub_36AA4(unsigned __int8 *a1, unsigned __int8 *a2, _QWORD *a3, _DWORD *a4)
{
  int v7; // w8
  unsigned __int8 *v8; // x23
  unsigned __int8 *v9; // x0
  unsigned __int8 *v10; // x22
  unsigned __int64 v11; // x25
  _BYTE *v12; // x0
  unsigned __int8 *v13; // x0
  unsigned __int8 *v14; // x22
  unsigned __int8 *v15; // x8
  unsigned __int8 *v16; // x22
  unsigned __int8 *v17; // x8
  unsigned __int64 v18; // x9
  _BYTE *v19; // x10
  _OWORD *v20; // x12
  __int128 *v21; // x13
  unsigned __int64 v22; // x14
  __int128 v23; // q0
  __int128 v24; // q1
  _BYTE *v25; // x9
  char v26; // t1
  void *v27; // x8
  __int128 v28; // q0
  __int128 v29; // q0
  char *v30; // x8
  char v31; // w22
  void *v32; // x21
  char *v33; // x1
  size_t v34; // x2
  __int64 v35; // x8
  __int128 v36; // [xsp+8h] [xbp-98h] BYREF
  void *v37; // [xsp+18h] [xbp-88h]
  __int128 v38; // [xsp+20h] [xbp-80h] BYREF
  void *p; // [xsp+30h] [xbp-70h]
  __int128 v40; // [xsp+40h] [xbp-60h] BYREF
  char *v41; // [xsp+50h] [xbp-50h]
  __int64 v42; // [xsp+58h] [xbp-48h]

  v42 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 >= a2 )
    goto LABEL_15;
  if ( *a1 != 95 )
  {
    v13 = sub_38008(a1, a2, (__int64)a3);
    goto LABEL_14;
  }
  if ( a2 - a1 < 4 )
    goto LABEL_15;
  v7 = a1[1];
  if ( v7 == 95 )
  {
    if ( a1[2] != 95 )
      goto LABEL_15;
    if ( a1[3] != 90 )
      goto LABEL_15;
    v14 = a1 + 4;
    v13 = sub_36F74(a1 + 4, a2, (__int64)a3);
    if ( v13 == v14 || v13 == a2 )
      goto LABEL_15;
    if ( a2 - v13 >= 13
      && *v13 == 95
      && v13[1] == 98
      && v13[2] == 108
      && v13[3] == 111
      && v13[4] == 99
      && v13[5] == 107
      && v13[6] == 95
      && v13[7] == 105
      && v13[8] == 110
      && v13[9] == 118
      && v13[10] == 111
      && v13[11] == 107
      && v13[12] == 101 )
    {
      v15 = v13 + 13;
      v16 = a2;
      if ( v13 + 13 != a2 )
      {
        if ( *v15 == 95 )
        {
          if ( v13 + 14 == a2 || (unsigned int)v13[14] - 48 > 9 )
            goto LABEL_14;
          v15 = v13 + 15;
        }
        v16 = a2;
        if ( v15 != a2 )
        {
          while ( (unsigned int)*v15 - 48 <= 9 )
          {
            if ( a2 == ++v15 )
            {
              v16 = a2;
              goto LABEL_74;
            }
          }
          v16 = v15;
        }
      }
LABEL_74:
      v35 = a3[1];
      if ( *a3 != v35 )
      {
        sub_429F4((size_t *)(v35 - 48), 0, "invocation function for block in ", 0x21u);
        if ( v16 == a2 )
          goto LABEL_45;
LABEL_15:
        *a4 = -2;
        return;
      }
    }
LABEL_14:
    if ( v13 == a2 )
      goto LABEL_45;
    goto LABEL_15;
  }
  if ( v7 != 90 )
    goto LABEL_15;
  v8 = a1 + 2;
  v9 = sub_36F74(a1 + 2, a2, (__int64)a3);
  v10 = v9;
  if ( v9 == v8 || v9 == a2 || *v9 != 46 || *a3 == a3[1] )
  {
    if ( v9 == a2 )
      goto LABEL_45;
    goto LABEL_15;
  }
  v11 = a2 - v9;
  v36 = 0u;
  v37 = 0;
  if ( (unsigned __int64)(a2 - v9) >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v11 > 0x16 )
  {
    v12 = malloc((v11 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *((_QWORD *)&v36 + 1) = a2 - v10;
    v37 = v12;
    *(_QWORD *)&v36 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    LOBYTE(v36) = 2 * v11;
    v12 = (char *)&v36 + 1;
  }
  v17 = v10 + 1;
  *v12 = 46;
  if ( v10 + 1 != a2 )
  {
    v18 = (unsigned __int64)&a2[~(unsigned __int64)v10];
    if ( v18 < 0x20 )
    {
      v19 = v12;
LABEL_57:
      v25 = v19 + 1;
      do
      {
        v26 = *v17++;
        *v25++ = v26;
      }
      while ( a2 != v17 );
      goto LABEL_59;
    }
    if ( v12 + 1 < a2 )
    {
      v19 = v12;
      if ( v17 < &v12[v11] )
        goto LABEL_57;
    }
    v20 = v12 + 17;
    v17 += v18 & 0xFFFFFFFFFFFFFFE0LL;
    v19 = &v12[v18 & 0xFFFFFFFFFFFFFFE0LL];
    v21 = (__int128 *)(v10 + 17);
    v22 = v18 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v23 = *(v21 - 1);
      v24 = *v21;
      v22 -= 32LL;
      v21 += 2;
      *(v20 - 1) = v23;
      *v20 = v24;
      v20 += 2;
    }
    while ( v22 );
    if ( (v18 & 0xFFFFFFFFFFFFFFE0LL) != v18 )
      goto LABEL_57;
  }
LABEL_59:
  v12[v11] = 0;
  sub_429F4((size_t *)&v36, 0, " (", 2u);
  v27 = v37;
  v28 = v36;
  v36 = 0u;
  v37 = 0;
  p = v27;
  v38 = v28;
  sub_42BE4((size_t *)&v38, ")", 1u);
  v29 = v38;
  v30 = (char *)p;
  p = 0;
  v38 = 0u;
  v40 = v29;
  v41 = v30;
  v31 = v29;
  v32 = v30;
  if ( (v29 & 1) != 0 )
    v33 = v30;
  else
    v33 = (char *)&v40 + 1;
  if ( (v29 & 1) != 0 )
    v34 = *((_QWORD *)&v29 + 1);
  else
    v34 = (unsigned __int64)(unsigned __int8)v29 >> 1;
  sub_42BE4((size_t *)(a3[1] - 48LL), v33, v34);
  if ( (v31 & 1) == 0 )
  {
    if ( (v38 & 1) == 0 )
      goto LABEL_67;
LABEL_70:
    free(p);
    if ( (v36 & 1) != 0 )
      goto LABEL_71;
    goto LABEL_45;
  }
  free(v32);
  if ( (v38 & 1) != 0 )
    goto LABEL_70;
LABEL_67:
  if ( (v36 & 1) != 0 )
  {
LABEL_71:
    free(v37);
    if ( *a4 )
      return;
    goto LABEL_46;
  }
LABEL_45:
  if ( *a4 )
    return;
LABEL_46:
  if ( *a3 == a3[1] )
    goto LABEL_15;
}

//----- (0000000000036F74) ----------------------------------------------------
unsigned __int8 *__fastcall sub_36F74(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x20
  int v6; // w28
  char v7; // w25
  int v8; // w27
  int v9; // w8
  unsigned __int8 *v10; // x22
  unsigned __int8 *v11; // x22
  unsigned __int8 *v12; // x0
  unsigned __int8 *v13; // x8
  int v14; // w9
  unsigned __int8 *v15; // x8
  unsigned __int8 *v16; // x22
  unsigned __int8 *v17; // x21
  __int64 v18; // x8
  unsigned __int64 v19; // x9
  size_t v20; // x10
  const void *v21; // x11
  size_t *v22; // x0
  const void *v23; // x8
  const void *v24; // x1
  size_t v25; // x2
  size_t *v26; // x0
  __int64 v27; // x23
  size_t *v28; // x22
  size_t *v29; // x8
  void *v30; // x8
  __int128 v31; // q0
  void *v32; // x8
  __int128 v33; // q0
  __int64 v34; // x8
  unsigned __int64 v35; // x9
  size_t v36; // x10
  const void *v37; // x11
  size_t *v38; // x0
  const void *v39; // x8
  const void *v40; // x1
  size_t v41; // x2
  size_t *v42; // x0
  char v43; // w25
  void *v44; // x27
  char *v45; // x1
  size_t v46; // x2
  __int64 v47; // x9
  void *v48; // x10
  __int64 v49; // x8
  __int64 v50; // x22
  size_t *v51; // x23
  unsigned __int8 *v52; // x0
  unsigned __int8 *v53; // x22
  int v54; // w8
  unsigned __int8 *v55; // x24
  int v56; // w8
  unsigned __int8 *v57; // x22
  __int64 v58; // x8
  int v59; // w11
  int v60; // w23
  char v61; // w10
  __int64 v62; // x8
  size_t *v63; // x0
  unsigned __int64 v64; // x9
  unsigned __int8 *v65; // x22
  __int64 v66; // x8
  unsigned __int8 *v67; // x24
  __int64 v68; // x8
  __int64 v69; // x23
  unsigned __int8 *v70; // x0
  unsigned __int8 *v71; // x23
  __int64 v72; // x8
  size_t *v73; // x0
  unsigned __int8 *v74; // x22
  __int64 v75; // x8
  unsigned __int8 *v76; // x22
  __int64 v77; // x8
  unsigned __int8 *v78; // x22
  __int64 v79; // x8
  unsigned __int8 *v80; // x22
  unsigned __int8 *v81; // x0
  unsigned __int8 *v82; // x23
  unsigned __int8 *v83; // x0
  unsigned __int8 *v84; // x22
  __int64 v85; // x8
  unsigned __int8 *v86; // x22
  __int64 v87; // x8
  unsigned __int8 *v88; // x22
  __int64 v89; // x8
  unsigned __int8 *v90; // x22
  __int64 v91; // x8
  int v92; // w8
  unsigned __int64 v94; // x8
  unsigned __int64 v95; // x12
  unsigned __int64 v96; // x11
  char *v97; // x23
  unsigned __int64 v98; // x8
  size_t v99; // x8
  char *v100; // x10
  __int64 v101; // x23
  char v102; // w27
  size_t *v103; // x25
  size_t *v104; // x8
  char *v105; // x2
  size_t v106; // x3
  int v107; // w23
  int v108; // w23
  char v109; // w21
  size_t *v110; // x8
  char *v111; // x1
  size_t v112; // x2
  int v113; // w24
  __int64 v114; // x10
  size_t v115; // x8
  int v116; // w11
  unsigned __int64 v117; // x9
  size_t v118; // x2
  char *v119; // x1
  size_t *v120; // x23
  __int64 v121; // x25
  unsigned __int8 *v122; // x0
  size_t *v123; // x9
  unsigned __int64 v124; // x23
  unsigned __int64 v125; // x25
  unsigned __int64 v126; // x9
  unsigned __int8 v127; // w8
  size_t v128; // x24
  unsigned __int64 v129; // x8
  __int64 v130; // x0
  unsigned __int64 v131; // x8
  const void *v132; // x1
  size_t v133; // x2
  size_t *v134; // x0
  char v135; // w27
  void *v136; // x24
  char *v137; // x1
  size_t v138; // x2
  __int64 v139; // x24
  unsigned __int64 v140; // x10
  int v141; // w22
  unsigned __int64 v142; // x8
  void *v143; // x0
  void *v144; // x24
  _BYTE *v145; // x0
  char p; // [xsp+18h] [xbp-128h]
  int v147; // [xsp+24h] [xbp-11Ch]
  int v148; // [xsp+24h] [xbp-11Ch]
  char v149; // [xsp+28h] [xbp-118h]
  size_t v150; // [xsp+28h] [xbp-118h]
  char v151; // [xsp+28h] [xbp-118h]
  char *v152; // [xsp+30h] [xbp-110h]
  size_t v153; // [xsp+30h] [xbp-110h]
  char v154; // [xsp+38h] [xbp-108h]
  char v155; // [xsp+44h] [xbp-FCh]
  int v156; // [xsp+44h] [xbp-FCh]
  int v157; // [xsp+44h] [xbp-FCh]
  char v158; // [xsp+48h] [xbp-F8h]
  unsigned __int64 v159; // [xsp+48h] [xbp-F8h]
  size_t v160; // [xsp+50h] [xbp-F0h]
  size_t v161; // [xsp+50h] [xbp-F0h]
  size_t v162; // [xsp+50h] [xbp-F0h]
  char v163; // [xsp+58h] [xbp-E8h]
  unsigned __int64 v164; // [xsp+58h] [xbp-E8h]
  __int64 v165; // [xsp+58h] [xbp-E8h]
  __int128 v166; // [xsp+60h] [xbp-E0h] BYREF
  char *v167; // [xsp+70h] [xbp-D0h]
  __int128 v168; // [xsp+80h] [xbp-C0h] BYREF
  void *v169; // [xsp+90h] [xbp-B0h]
  __int128 v170; // [xsp+A0h] [xbp-A0h] BYREF
  void *v171; // [xsp+B0h] [xbp-90h]
  __int128 v172; // [xsp+C0h] [xbp-80h] BYREF
  char *v173; // [xsp+D0h] [xbp-70h]
  _QWORD v174[3]; // [xsp+D8h] [xbp-68h] BYREF

  v4 = a1;
  v174[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 != a2 )
  {
    v6 = *(_DWORD *)(a3 + 104);
    v7 = *(_BYTE *)(a3 + 109);
    *(_DWORD *)(a3 + 104) = v6 + 1;
    if ( (unsigned int)(v6 + 1) >= 2 )
      *(_BYTE *)(a3 + 109) = 1;
    v8 = *(unsigned __int8 *)(a3 + 108);
    *(_BYTE *)(a3 + 108) = 0;
    v9 = *a1;
    if ( v9 == 84 || v9 == 71 )
    {
      if ( a2 - a1 >= 3 )
      {
        if ( v9 == 71 )
        {
          v56 = a1[1];
          if ( v56 == 82 )
          {
            v65 = a1 + 2;
            v17 = sub_401BC(a1 + 2, a2, a3, 0);
            if ( v17 == v65 )
              goto LABEL_107;
            v66 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v66 )
              goto LABEL_107;
            sub_429F4((size_t *)(v66 - 48), 0, "reference temporary for ", 0x18u);
          }
          else
          {
            if ( v56 != 86 )
              goto LABEL_107;
            v57 = a1 + 2;
            v17 = sub_401BC(a1 + 2, a2, a3, 0);
            if ( v17 == v57 )
              goto LABEL_107;
            v58 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v58 )
              goto LABEL_107;
            sub_429F4((size_t *)(v58 - 48), 0, "guard variable for ", 0x13u);
          }
LABEL_115:
          v4 = v17;
        }
        else
        {
          v10 = a1 + 1;
          switch ( a1[1] )
          {
            case 'C':
              v11 = a1 + 2;
              v12 = sub_38008(a1 + 2, a2, a3);
              if ( v12 == v11 || v12 == a2 )
                break;
              v13 = v12 + 1;
              if ( *v12 != 110 )
                v13 = v12;
              if ( v13 == a2 )
                break;
              v14 = *v13;
              if ( v14 == 48 )
              {
                v15 = v13 + 1;
              }
              else
              {
                if ( (unsigned int)(v14 - 49) > 8 )
                  break;
                v15 = v13 + 1;
                if ( v15 == a2 )
                  break;
                while ( (unsigned int)*v15 - 48 < 0xA )
                {
                  if ( a2 == ++v15 )
                    goto LABEL_107;
                }
              }
              if ( v15 != v12 && v15 != a2 && *v15 == 95 )
              {
                v16 = v15 + 1;
                v17 = sub_38008(v15 + 1, a2, a3);
                if ( v17 != v16 )
                {
                  v18 = *(_QWORD *)(a3 + 8);
                  if ( 0xAAAAAAAAAAAAAAABLL * ((v18 - *(_QWORD *)a3) >> 4) >= 2 )
                  {
                    v19 = *(unsigned __int8 *)(v18 - 24);
                    v20 = *(_QWORD *)(v18 - 16);
                    v21 = *(const void **)(v18 - 8);
                    v22 = (size_t *)(v18 - 48);
                    v23 = (const void *)(v18 - 23);
                    if ( (v19 & 1) != 0 )
                      v24 = v21;
                    else
                      v24 = v23;
                    if ( (v19 & 1) != 0 )
                      v25 = v20;
                    else
                      v25 = v19 >> 1;
                    v26 = sub_42BE4(v22, v24, v25);
                    v155 = v8;
                    v149 = v7;
                    v173 = (char *)v26[2];
                    v172 = *(_OWORD *)v26;
                    v26[1] = 0;
                    v26[2] = 0;
                    *v26 = 0;
                    v27 = *(_QWORD *)(a3 + 8);
                    v28 = (size_t *)(v27 - 48);
                    if ( (*(_BYTE *)(v27 - 24) & 1) != 0 )
                      free(*(void **)(v27 - 8));
                    if ( (*(_BYTE *)v28 & 1) != 0 )
                      free(*(void **)(v27 - 32));
                    v29 = *(size_t **)a3;
                    *(_QWORD *)(a3 + 8) = v28;
                    if ( v29 == v28 )
                    {
                      v141 = 1;
                      v17 = v4;
                      if ( (v172 & 1) == 0 )
                      {
LABEL_258:
                        v7 = v149;
                        LOBYTE(v8) = v155;
                        if ( !v141 )
                          goto LABEL_115;
                        break;
                      }
LABEL_257:
                      free(v173);
                      goto LABEL_258;
                    }
                    sub_429F4((size_t *)&v172, 0, "construction vtable for ", 0x18u);
                    v30 = v173;
                    v31 = v172;
                    v172 = 0u;
                    v173 = 0;
                    v169 = v30;
                    v168 = v31;
                    sub_42BE4((size_t *)&v168, "-in-", 4u);
                    v32 = v169;
                    v33 = v168;
                    v168 = 0u;
                    v169 = 0;
                    v171 = v32;
                    v170 = v33;
                    v34 = *(_QWORD *)(a3 + 8);
                    v35 = *(unsigned __int8 *)(v34 - 24);
                    v36 = *(_QWORD *)(v34 - 16);
                    v37 = *(const void **)(v34 - 8);
                    v38 = (size_t *)(v34 - 48);
                    v39 = (const void *)(v34 - 23);
                    if ( (v35 & 1) != 0 )
                      v40 = v37;
                    else
                      v40 = v39;
                    if ( (v35 & 1) != 0 )
                      v41 = v36;
                    else
                      v41 = v35 >> 1;
                    v42 = sub_42BE4(v38, v40, v41);
                    v167 = (char *)v42[2];
                    v166 = *(_OWORD *)v42;
                    v42[1] = 0;
                    v42[2] = 0;
                    *v42 = 0;
                    v43 = v166;
                    v44 = v167;
                    if ( (v166 & 1) != 0 )
                      v45 = v167;
                    else
                      v45 = (char *)&v166 + 1;
                    if ( (v166 & 1) != 0 )
                      v46 = *((_QWORD *)&v166 + 1);
                    else
                      v46 = (unsigned __int64)(unsigned __int8)v166 >> 1;
                    sub_42BE4((size_t *)&v170, v45, v46);
                    v47 = *((_QWORD *)&v170 + 1);
                    v48 = v171;
                    v171 = 0;
                    v163 = v170;
                    v49 = *(_QWORD *)((char *)&v170 + 1);
                    v170 = 0u;
                    *(_QWORD *)((char *)v174 + 7) = v47;
                    v160 = (size_t)v48;
                    v174[0] = v49;
                    v50 = *(_QWORD *)(a3 + 8);
                    if ( (*(_BYTE *)(v50 - 48) & 1) != 0 )
                    {
                      v51 = (size_t *)(v50 - 32);
                      **(_BYTE **)(v50 - 32) = 0;
                      v142 = *(unsigned __int8 *)(v50 - 48);
                      *(_QWORD *)(v50 - 40) = 0;
                      if ( (v142 & 1) != 0 )
                      {
                        v145 = (_BYTE *)*v51;
                        *(_BYTE *)(v50 - 47) = *(_BYTE *)*v51;
                        free(v145);
                        *(_BYTE *)(v50 - 48) = 0;
                      }
                      else if ( (unsigned int)v142 >= 0x2E )
                      {
                        v159 = v142 >> 1;
                        v153 = (unsigned __int8)((v142 >> 1) + 16) & 0xF0;
                        v143 = malloc(v153);
                        if ( v153 - 1 > 0x16 || v143 )
                        {
                          v144 = v143;
                          memcpy(v143, (const void *)(v50 - 47), v159 + 1);
                          *(_QWORD *)(v50 - 48) = v153 | 1;
                          *(_QWORD *)(v50 - 40) = v159;
                          *(_QWORD *)(v50 - 32) = v144;
                        }
                      }
                    }
                    else
                    {
                      *(_WORD *)(v50 - 48) = 0;
                      v51 = (size_t *)(v50 - 32);
                    }
                    *(_BYTE *)(v50 - 48) = v163;
                    *(_QWORD *)(v50 - 47) = v174[0];
                    *(_QWORD *)(v50 - 40) = *(_QWORD *)((char *)v174 + 7);
                    *v51 = v160;
                    memset(v174, 0, 15);
                    if ( (v43 & 1) != 0 )
                    {
                      free(v44);
                      if ( (v170 & 1) == 0 )
                      {
LABEL_254:
                        if ( (v168 & 1) == 0 )
                          goto LABEL_256;
                        goto LABEL_255;
                      }
                    }
                    else if ( (v170 & 1) == 0 )
                    {
                      goto LABEL_254;
                    }
                    free(v171);
                    if ( (v168 & 1) == 0 )
                    {
LABEL_256:
                      v141 = 0;
                      if ( (v172 & 1) == 0 )
                        goto LABEL_258;
                      goto LABEL_257;
                    }
LABEL_255:
                    free(v169);
                    goto LABEL_256;
                  }
                }
              }
              break;
            case 'H':
              v76 = a1 + 2;
              v17 = sub_401BC(a1 + 2, a2, a3, 0);
              if ( v17 != v76 )
              {
                v77 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v77 )
                {
                  sub_429F4((size_t *)(v77 - 48), 0, "thread-local initialization routine for ", 0x28u);
                  goto LABEL_115;
                }
              }
              break;
            case 'I':
              v86 = a1 + 2;
              v17 = sub_38008(a1 + 2, a2, a3);
              if ( v17 != v86 )
              {
                v87 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v87 )
                {
                  sub_429F4((size_t *)(v87 - 48), 0, "typeinfo for ", 0xDu);
                  goto LABEL_115;
                }
              }
              break;
            case 'S':
              v88 = a1 + 2;
              v17 = sub_38008(a1 + 2, a2, a3);
              if ( v17 != v88 )
              {
                v89 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v89 )
                {
                  sub_429F4((size_t *)(v89 - 48), 0, "typeinfo name for ", 0x12u);
                  goto LABEL_115;
                }
              }
              break;
            case 'T':
              v90 = a1 + 2;
              v17 = sub_38008(a1 + 2, a2, a3);
              if ( v17 != v90 )
              {
                v91 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v91 )
                {
                  sub_429F4((size_t *)(v91 - 48), 0, "VTT for ", 8u);
                  goto LABEL_115;
                }
              }
              break;
            case 'V':
              v74 = a1 + 2;
              v17 = sub_38008(a1 + 2, a2, a3);
              if ( v17 != v74 )
              {
                v75 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v75 )
                {
                  sub_429F4((size_t *)(v75 - 48), 0, "vtable for ", 0xBu);
                  goto LABEL_115;
                }
              }
              break;
            case 'W':
              v78 = a1 + 2;
              v17 = sub_401BC(a1 + 2, a2, a3, 0);
              if ( v17 != v78 )
              {
                v79 = *(_QWORD *)(a3 + 8);
                if ( *(_QWORD *)a3 != v79 )
                {
                  sub_429F4((size_t *)(v79 - 48), 0, "thread-local wrapper routine for ", 0x21u);
                  goto LABEL_115;
                }
              }
              break;
            case 'c':
              v80 = a1 + 2;
              v81 = sub_42838(a1 + 2, a2);
              v82 = v81;
              if ( v81 != v80 )
              {
                v83 = sub_42838(v81, a2);
                v84 = v83;
                if ( v83 != v82 )
                {
                  v17 = (unsigned __int8 *)sub_36F74(v83, a2, a3);
                  if ( v17 != v84 )
                  {
                    v85 = *(_QWORD *)(a3 + 8);
                    if ( *(_QWORD *)a3 != v85 )
                    {
                      sub_429F4((size_t *)(v85 - 48), 0, "covariant return thunk to ", 0x1Au);
                      goto LABEL_115;
                    }
                  }
                }
              }
              break;
            default:
              v70 = sub_42838(a1 + 1, a2);
              v71 = v70;
              if ( v70 == v10 )
              {
                v92 = 3;
              }
              else
              {
                v17 = (unsigned __int8 *)sub_36F74(v70, a2, a3);
                if ( v17 == v71 )
                {
                  v92 = 0;
                }
                else
                {
                  v72 = *(_QWORD *)(a3 + 8);
                  if ( *(_QWORD *)a3 != v72 )
                  {
                    v73 = (size_t *)(v72 - 48);
                    if ( *v10 == 118 )
                      sub_429F4(v73, 0, "virtual thunk to ", 0x11u);
                    else
                      sub_429F4(v73, 0, "non-virtual thunk to ", 0x15u);
                    goto LABEL_115;
                  }
                  v92 = 1;
                }
              }
              v17 = v4;
              if ( (v92 & 3) == 0 || (v92 & 3) == 3 || !v92 )
                goto LABEL_115;
              break;
          }
        }
      }
LABEL_107:
      *(_BYTE *)(a3 + 108) = v8;
      *(_BYTE *)(a3 + 109) = v7;
      *(_DWORD *)(a3 + 104) = v6;
      return v4;
    }
    LOBYTE(v166) = 0;
    v52 = sub_401BC(a1, a2, a3, &v166);
    v53 = v52;
    if ( v52 == v4 )
      goto LABEL_107;
    if ( v52 == a2 )
    {
      v55 = a2;
      goto LABEL_58;
    }
    v54 = *v52;
    if ( v54 == 46 || v54 == 69 )
    {
      v55 = v52;
LABEL_58:
      v4 = v55;
      goto LABEL_107;
    }
    v59 = *(_DWORD *)(a3 + 96);
    v60 = *(_DWORD *)(a3 + 100);
    v61 = *(_BYTE *)(a3 + 109);
    *(_BYTE *)(a3 + 109) = 0;
    v172 = 0u;
    v173 = 0;
    v62 = *(_QWORD *)(a3 + 8);
    if ( *(_QWORD *)a3 == v62 )
    {
LABEL_160:
      v108 = 1;
      v55 = v4;
      if ( (v172 & 1) == 0 )
        goto LABEL_162;
      goto LABEL_161;
    }
    v63 = (size_t *)(v62 - 48);
    v64 = *(unsigned __int8 *)(v62 - 48);
    if ( (v64 & 1) != 0 )
    {
      if ( !*(_QWORD *)(v62 - 40) )
        goto LABEL_160;
    }
    else if ( !(v64 >> 1) )
    {
      goto LABEL_160;
    }
    v158 = v61;
    v154 = v59;
    if ( *(_BYTE *)(a3 + 108) || !(_BYTE)v166 )
    {
LABEL_165:
      sub_57F64(v63, 40);
      if ( v53 == a2 || *v53 != 118 )
      {
        v148 = v60;
        v151 = v7;
        p = 1;
LABEL_197:
        v55 = v53;
        while ( 1 )
        {
          v120 = *(size_t **)a3;
          v121 = *(_QWORD *)(a3 + 8);
          v122 = sub_38008(v55, a2, a3);
          v53 = v122;
          v123 = *(size_t **)a3;
          v110 = *(size_t **)(a3 + 8);
          if ( v122 == v55 )
            break;
          v124 = 0xAAAAAAAAAAAAAAABLL * ((v121 - (__int64)v120) >> 4);
          v125 = 0xAAAAAAAAAAAAAAABLL * (((char *)v110 - (char *)v123) >> 4);
          v55 = v122;
          if ( v125 > v124 )
          {
            v126 = 0;
            v127 = 0;
            v128 = v124 + 1;
            v170 = 0u;
            v171 = 0;
            v165 = 48 * v124;
            v157 = v8;
            while ( 1 )
            {
              if ( (v127 & 1) != 0 )
                v129 = v126;
              else
                v129 = (unsigned __int64)(v127 & 0xFE) >> 1;
              if ( v129 )
                sub_42BE4((size_t *)&v170, ", ", 2u);
              v130 = *(_QWORD *)a3 + v165;
              v131 = *(unsigned __int8 *)(v130 + 24);
              if ( (v131 & 1) != 0 )
                v132 = *(const void **)(v130 + 40);
              else
                v132 = (const void *)(v130 + 25);
              if ( (v131 & 1) != 0 )
                v133 = *(_QWORD *)(v130 + 32);
              else
                v133 = v131 >> 1;
              v134 = sub_42BE4((size_t *)v130, v132, v133);
              v162 = v128;
              v169 = (void *)v134[2];
              v168 = *(_OWORD *)v134;
              v134[1] = 0;
              v134[2] = 0;
              *v134 = 0;
              v135 = v168;
              v136 = v169;
              if ( (v168 & 1) != 0 )
                v137 = (char *)v169;
              else
                v137 = (char *)&v168 + 1;
              if ( (v168 & 1) != 0 )
                v138 = *((_QWORD *)&v168 + 1);
              else
                v138 = (unsigned __int64)(unsigned __int8)v168 >> 1;
              sub_42BE4((size_t *)&v170, v137, v138);
              if ( (v135 & 1) != 0 )
                free(v136);
              if ( v162 >= v125 )
                break;
              v127 = v170;
              v126 = *((_QWORD *)&v170 + 1);
              v128 = v162 + 1;
              v165 += 48;
            }
            v139 = *(_QWORD *)(a3 + 8);
            v8 = v157;
            do
            {
              if ( v139 == *(_QWORD *)a3 )
                goto LABEL_236;
              if ( (*(_BYTE *)(v139 - 24) & 1) != 0 )
                free(*(void **)(v139 - 8));
              if ( (*(_BYTE *)(v139 - 48) & 1) != 0 )
                free(*(void **)(v139 - 32));
              ++v124;
              v139 -= 48;
              *(_QWORD *)(a3 + 8) = v139;
            }
            while ( v124 < v125 );
            v115 = *((_QWORD *)&v170 + 1);
            v117 = (unsigned __int64)(unsigned __int8)v170 >> 1;
            if ( (v170 & 1) != 0 )
              v140 = *((_QWORD *)&v170 + 1);
            else
              v140 = (unsigned __int64)(unsigned __int8)v170 >> 1;
            if ( !v140 )
            {
              v113 = 0;
              if ( (v170 & 1) == 0 )
                goto LABEL_238;
              goto LABEL_237;
            }
            v114 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v114 )
            {
LABEL_236:
              v113 = 1;
              if ( (v170 & 1) == 0 )
                goto LABEL_238;
              goto LABEL_237;
            }
            if ( (p & 1) != 0 )
            {
              v116 = v170 & 1;
            }
            else
            {
              sub_42BE4((size_t *)(v114 - 48), ", ", 2u);
              v114 = *(_QWORD *)(a3 + 8);
              v115 = *((_QWORD *)&v170 + 1);
              v116 = v170 & 1;
              v117 = (unsigned __int64)(unsigned __int8)v170 >> 1;
            }
            if ( v116 )
              v118 = v115;
            else
              v118 = v117;
            if ( v116 )
              v119 = (char *)v171;
            else
              v119 = (char *)&v170 + 1;
            sub_42BE4((size_t *)(v114 - 48), v119, v118);
            v8 = v157;
            v113 = 0;
            p = 0;
            if ( (v170 & 1) != 0 )
LABEL_237:
              free(v171);
LABEL_238:
            v108 = 1;
            if ( v113 )
            {
              v7 = v151;
              v55 = v4;
              goto LABEL_242;
            }
            goto LABEL_197;
          }
        }
        v60 = v148;
        v7 = v151;
        if ( v123 != v110 )
          goto LABEL_168;
      }
      else
      {
        v110 = *(size_t **)(a3 + 8);
        v55 = v53 + 1;
        if ( *(size_t **)a3 != v110 )
        {
LABEL_168:
          sub_57F64(v110 - 6, 41);
          if ( (v154 & 1) != 0 )
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), " const", 6u);
          if ( (v154 & 2) != 0 )
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), " volatile", 9u);
          if ( (v154 & 4) != 0 )
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), " restrict", 9u);
          if ( v60 == 2 )
          {
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), " &&", 3u);
          }
          else if ( v60 == 1 )
          {
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), " &", 2u);
          }
          if ( (v172 & 1) != 0 )
            v111 = v173;
          else
            v111 = (char *)&v172 + 1;
          if ( (v172 & 1) != 0 )
            v112 = *((_QWORD *)&v172 + 1);
          else
            v112 = (unsigned __int64)(unsigned __int8)v172 >> 1;
          sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v111, v112);
          v108 = 0;
LABEL_242:
          v61 = v158;
          if ( (v172 & 1) == 0 )
          {
LABEL_162:
            *(_BYTE *)(a3 + 109) = v61;
            if ( v108 )
              goto LABEL_107;
            goto LABEL_58;
          }
LABEL_161:
          v109 = v61;
          free(v173);
          v61 = v109;
          goto LABEL_162;
        }
      }
LABEL_241:
      v108 = 1;
      v55 = v4;
      goto LABEL_242;
    }
    v67 = sub_38008(v53, a2, a3);
    if ( v67 == v53 )
      goto LABEL_241;
    v68 = *(_QWORD *)(a3 + 8);
    if ( 0xAAAAAAAAAAAAAAABLL * ((v68 - *(_QWORD *)a3) >> 4) < 2 )
      goto LABEL_241;
    v147 = v60;
    v171 = *(void **)(v68 - 32);
    v170 = *(_OWORD *)(v68 - 48);
    *(_QWORD *)(v68 - 40) = 0;
    *(_QWORD *)(v68 - 32) = 0;
    *(_QWORD *)(v68 - 48) = 0;
    v69 = *(_QWORD *)(a3 + 8) - 24LL;
    if ( (v172 & 1) != 0 )
    {
      *((_QWORD *)&v172 + 1) = 0;
      BYTE1(v172) = 0;
      free(v173);
    }
    else
    {
      BYTE1(v172) = 0;
    }
    v173 = *(char **)(v69 + 16);
    v172 = *(_OWORD *)v69;
    *(_QWORD *)(v69 + 8) = 0;
    *(_QWORD *)(v69 + 16) = 0;
    *(_QWORD *)v69 = 0;
    v156 = v8;
    if ( (v172 & 1) != 0 )
      v94 = *((_QWORD *)&v172 + 1);
    else
      v94 = (unsigned __int64)(unsigned __int8)v172 >> 1;
    if ( v94 )
    {
LABEL_144:
      v101 = *(_QWORD *)(a3 + 8);
      v102 = v7;
      v103 = (size_t *)(v101 - 48);
      if ( (*(_BYTE *)(v101 - 24) & 1) != 0 )
        free(*(void **)(v101 - 8));
      if ( (*(_BYTE *)v103 & 1) != 0 )
        free(*(void **)(v101 - 32));
      v104 = *(size_t **)a3;
      *(_QWORD *)(a3 + 8) = v103;
      if ( v104 == v103 )
      {
        v107 = 1;
        v7 = v102;
      }
      else
      {
        if ( (v170 & 1) != 0 )
          v105 = (char *)v171;
        else
          v105 = (char *)&v170 + 1;
        if ( (v170 & 1) != 0 )
          v106 = *((_QWORD *)&v170 + 1);
        else
          v106 = (unsigned __int64)(unsigned __int8)v170 >> 1;
        v7 = v102;
        sub_429F4((size_t *)(v101 - 96), 0, v105, v106);
        v107 = 0;
        v53 = v67;
      }
      v8 = v156;
      if ( (v170 & 1) != 0 )
        free(v171);
      v61 = v158;
      if ( v107 )
        goto LABEL_160;
      v60 = v147;
      v63 = (size_t *)(*(_QWORD *)(a3 + 8) - 48LL);
      goto LABEL_165;
    }
    if ( (v170 & 1) != 0 )
    {
      v95 = *((_QWORD *)&v170 + 1);
      v96 = (v170 & 0xFFFFFFFFFFFFFFFELL) - 1;
      if ( *((_QWORD *)&v170 + 1) == v96 )
      {
LABEL_123:
        if ( v96 == -17 )
          abort();
        if ( (v170 & 1) != 0 )
          v97 = (char *)v171;
        else
          v97 = (char *)&v170 + 1;
        v161 = v96;
        v164 = v95;
        if ( v96 > 0x7FFFFFFFFFFFFFE6LL )
        {
          v99 = -17;
        }
        else
        {
          if ( v96 + 1 >= 2 * v96 )
            v98 = v96 + 1;
          else
            v98 = 2 * v96;
          if ( v98 >= 0x17 )
            v99 = (v98 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          else
            v99 = 23;
        }
        v150 = v99;
        v152 = (char *)malloc(v99);
        memcpy(v152, v97, v161);
        if ( v161 != 22 )
          free(v97);
        v100 = v152;
        v95 = v164;
        v171 = v152;
        *(_QWORD *)&v170 = v150 | 1;
        goto LABEL_142;
      }
    }
    else
    {
      v95 = (unsigned __int64)(unsigned __int8)v170 >> 1;
      v96 = 22;
      if ( v95 == 22 )
        goto LABEL_123;
    }
    if ( (v170 & 1) == 0 )
    {
      v100 = (char *)&v170 + 1;
      LOBYTE(v170) = 2 * v95 + 2;
LABEL_143:
      *(_WORD *)&v100[v95] = 32;
      goto LABEL_144;
    }
    v100 = (char *)v171;
LABEL_142:
    *((_QWORD *)&v170 + 1) = v95 + 1;
    goto LABEL_143;
  }
  return v4;
}
// 37008: conditional instruction was optimized away because w8.4==54

//----- (0000000000038008) ----------------------------------------------------
unsigned __int8 *__fastcall sub_38008(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x20
  int v6; // w24
  unsigned __int8 *v7; // x8
  int v8; // t1
  unsigned __int8 *v9; // x22
  int v10; // w25
  void **v11; // x19
  __int64 v12; // x21
  __int64 v13; // x0
  __int64 *v14; // x8
  unsigned __int8 *v15; // x28
  void **v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x20
  __int64 *v19; // x28
  unsigned __int64 v20; // x8
  __int64 v21; // x22
  char v22; // w27
  char *v23; // x22
  int v24; // w8
  _QWORD *v25; // x25
  unsigned __int8 *v26; // x21
  __int64 v27; // x8
  unsigned __int64 v28; // x9
  const void *v29; // x10
  const void *v30; // x8
  unsigned __int64 v31; // x11
  bool v32; // zf
  unsigned __int64 v33; // x9
  const void *v34; // x23
  size_t v35; // x22
  __int64 v36; // x10
  __int64 v37; // x25
  __int64 v38; // x8
  unsigned __int64 v39; // x8
  __int64 v40; // x26
  char *v41; // x0
  __int64 v42; // x9
  char *v43; // x12
  void **v44; // x11
  void **v45; // x20
  _QWORD *v46; // x9
  unsigned __int64 v47; // x10
  char *v48; // x12
  __int128 v49; // t1
  void **v50; // x22
  __int64 v51; // x25
  unsigned __int64 v52; // x8
  unsigned __int64 v53; // x22
  int v54; // w25
  char *v55; // x24
  size_t *v56; // x21
  char *v57; // x11
  __int64 v58; // x8
  size_t v59; // x25
  const void *v60; // x26
  void *v61; // x27
  char *v62; // x8
  char *v63; // x25
  char *v64; // x25
  __int64 v65; // x8
  __int64 v66; // x8
  char v67; // t1
  __int64 v68; // x8
  size_t v69; // x26
  const void *v70; // x19
  void *v71; // x25
  void *v72; // x0
  char *v73; // x8
  void **v74; // x9
  void **v75; // x19
  _QWORD *v76; // x8
  size_t v77; // x10
  void **v78; // x24
  __int64 v79; // x23
  void **v80; // x21
  unsigned __int64 v81; // x8
  __int64 v82; // x9
  __int64 v83; // x0
  size_t *v84; // x0
  unsigned __int64 v85; // x10
  unsigned int v86; // t1
  unsigned __int64 v87; // x8
  char *v88; // x11
  __int64 v89; // x11
  size_t v90; // x24
  char *v91; // x12
  char *v92; // x9
  unsigned __int64 v93; // x10
  __int64 v94; // x9
  __int64 v95; // x20
  __int64 v96; // x19
  size_t *v97; // x9
  size_t *v98; // x21
  __int64 v99; // x25
  __int64 v100; // x10
  unsigned __int64 v101; // x23
  unsigned __int64 v102; // x9
  __int64 v103; // x26
  unsigned __int64 v104; // x9
  __int64 v105; // x8
  size_t v106; // x0
  __int64 v107; // x8
  size_t v108; // x24
  const void *v109; // x25
  void *v110; // x26
  _BYTE *v111; // x24
  __int64 v112; // x8
  __int64 v113; // x8
  char v114; // t1
  __int64 v115; // x8
  size_t v116; // x25
  const void *v117; // x26
  void *v118; // x24
  __int64 v119; // x26
  void **v120; // x19
  __int64 v121; // x21
  __int64 v122; // x0
  _QWORD *v123; // x8
  unsigned __int64 v124; // x9
  void **v125; // x22
  __int64 v126; // x24
  __int64 v127; // x20
  unsigned __int8 *v128; // x22
  __int64 v129; // x8
  unsigned __int64 v130; // x8
  unsigned __int64 v131; // x9
  void **v132; // x19
  __int64 v133; // x0
  __int64 v134; // x22
  __int64 v135; // x25
  __int64 v136; // x8
  void *v137; // x9
  __int64 v138; // x19
  _BYTE *v139; // x21
  char *v140; // x8
  unsigned __int64 v141; // x8
  _BYTE *v142; // x8
  __int128 v143; // q0
  char *v144; // x1
  size_t v145; // x2
  __int128 v146; // q0
  char *v147; // x8
  char v148; // w19
  char *v149; // x1
  size_t v150; // x2
  __int128 v151; // q0
  __int64 v152; // x8
  __int64 v153; // x9
  _BYTE *v154; // x28
  char v155; // w27
  __int64 v156; // x24
  _BYTE **v157; // x25
  _QWORD *v158; // x24
  unsigned __int8 *v159; // x0
  unsigned __int8 *v160; // x23
  __int64 v161; // x19
  unsigned __int64 v162; // x8
  const void *v163; // x1
  size_t v164; // x2
  __int64 v165; // x19
  _BYTE *v166; // x20
  unsigned __int64 v167; // x8
  bool v168; // zf
  unsigned __int64 v169; // x8
  const void *v170; // x22
  size_t v171; // x20
  __int64 v172; // x8
  __int64 v173; // x1
  unsigned __int64 v174; // x8
  unsigned __int64 v175; // x9
  void **v176; // x19
  void **v177; // x19
  __int64 v178; // x21
  __int64 v179; // x0
  _QWORD *v180; // x8
  unsigned __int64 v181; // x9
  void **v182; // x23
  __int64 v183; // x24
  __int64 v184; // x20
  __int64 *v185; // x28
  void **v186; // x19
  __int64 v187; // x21
  __int64 v188; // x0
  _QWORD *v189; // x8
  unsigned __int64 v190; // x9
  void **v191; // x22
  __int64 v192; // x24
  __int64 v193; // x20
  __int64 *v194; // x27
  unsigned __int8 *v195; // x22
  _QWORD *v196; // x23
  unsigned __int8 *v197; // x0
  __int64 *v198; // x26
  unsigned __int8 *v199; // x24
  unsigned int v200; // w8
  unsigned __int8 *v201; // x23
  void **v202; // x22
  __int64 v203; // x25
  __int64 v204; // x0
  int v205; // w21
  unsigned __int64 v206; // x22
  unsigned __int64 v207; // x25
  __int64 v208; // x26
  unsigned __int64 v209; // x21
  void *v210; // x8
  __int64 v211; // x0
  unsigned __int64 v212; // x8
  const void *v213; // x1
  size_t v214; // x2
  size_t *v215; // x0
  char v216; // w19
  void *v217; // x24
  char *v218; // x1
  size_t v219; // x2
  unsigned __int64 v220; // x22
  __int64 v221; // x21
  char v222; // w8
  __int64 v223; // x8
  __int64 v224; // x1
  unsigned __int64 v225; // x8
  unsigned __int64 v226; // x9
  __int64 v227; // x8
  unsigned __int64 v228; // x8
  unsigned __int64 v229; // x9
  void **v230; // x19
  __int64 v231; // x21
  __int64 v232; // x0
  _QWORD *v233; // x8
  unsigned __int64 v234; // x9
  void **v235; // x23
  __int64 v236; // x24
  __int64 v237; // x20
  __int64 *v238; // x28
  unsigned __int8 *v239; // x0
  __int64 v240; // x19
  unsigned __int64 v241; // x8
  const void *v242; // x1
  size_t v243; // x2
  __int64 v244; // x19
  _BYTE *v245; // x21
  char *v246; // x1
  size_t v247; // x2
  __int64 v248; // x1
  unsigned __int64 v249; // x8
  unsigned __int64 v250; // x9
  void **v251; // x19
  __int64 v252; // x10
  __int64 v253; // x25
  __int64 v254; // x9
  unsigned __int64 v255; // x9
  __int64 v256; // x23
  char *v257; // x0
  unsigned __int8 *v258; // x19
  char v259; // w26
  __int64 v260; // x10
  __int64 v261; // x25
  __int64 v262; // x9
  unsigned __int64 v263; // x9
  __int64 v264; // x22
  char *v265; // x0
  __int64 v266; // x10
  __int64 v267; // x25
  __int64 v268; // x9
  unsigned __int64 v269; // x9
  __int64 v270; // x23
  char *v271; // x0
  __int64 v272; // x10
  __int64 v273; // x25
  __int64 v274; // x9
  unsigned __int64 v275; // x9
  __int64 v276; // x22
  char *v277; // x0
  __int64 v278; // x10
  __int64 v279; // x19
  __int64 v280; // x9
  unsigned __int64 v281; // x9
  __int64 v282; // x22
  char *v283; // x0
  __int64 v284; // x10
  __int64 v285; // x19
  __int64 v286; // x9
  unsigned __int64 v287; // x9
  __int64 v288; // x22
  char *v289; // x0
  __int64 v290; // x9
  unsigned __int8 *v291; // x0
  unsigned __int8 *v292; // x22
  __int64 v293; // x8
  void *v294; // x9
  __int64 v295; // x19
  _BYTE *v296; // x23
  char *v297; // x8
  __int64 v298; // x25
  _WORD *v299; // x24
  __int64 v300; // x9
  __int64 v301; // x9
  __int64 v302; // x9
  __int128 v303; // q0
  char *v304; // x1
  size_t v305; // x2
  __int128 v306; // q0
  char *v307; // x8
  char v308; // w19
  void *v309; // x23
  char *v310; // x1
  size_t v311; // x2
  unsigned __int16 *v312; // x8
  __int128 v313; // q0
  __int64 v314; // x8
  __int64 v315; // x9
  _BYTE *v316; // x27
  char v317; // w26
  __int64 v318; // x28
  _BYTE **v319; // x24
  char *v320; // x12
  void **v321; // x11
  void **v322; // x20
  char *v323; // x8
  _QWORD *v324; // x9
  unsigned __int64 v325; // x10
  char *v326; // x12
  __int128 v327; // t1
  void **v328; // x23
  char *v329; // x12
  void **v330; // x11
  void **v331; // x20
  char *v332; // x8
  _QWORD *v333; // x9
  unsigned __int64 v334; // x10
  char *v335; // x12
  __int128 v336; // t1
  void **v337; // x22
  char *v338; // x12
  void **v339; // x11
  void **v340; // x20
  char *v341; // x8
  _QWORD *v342; // x9
  unsigned __int64 v343; // x10
  char *v344; // x12
  __int128 v345; // t1
  void **v346; // x23
  char *v347; // x12
  void **v348; // x11
  void **v349; // x20
  char *v350; // x8
  _QWORD *v351; // x9
  unsigned __int64 v352; // x10
  char *v353; // x12
  __int128 v354; // t1
  void **v355; // x22
  int v356; // w10
  unsigned __int8 *v357; // x24
  __int64 v358; // x19
  __int64 v359; // x9
  unsigned __int8 *v360; // x10
  void **v361; // x19
  __int64 v362; // x23
  _QWORD *v363; // x8
  unsigned __int64 v364; // x9
  void **v365; // x22
  __int64 v366; // x24
  __int64 v367; // x20
  __int64 v368; // x19
  _BYTE *v369; // x21
  __int64 v370; // x8
  unsigned __int64 v371; // x8
  unsigned __int64 v372; // x9
  __int64 v373; // x25
  unsigned __int64 v374; // x8
  __int64 v375; // x25
  unsigned __int64 v376; // x8
  __int64 v377; // x25
  unsigned __int64 v378; // x8
  __int64 v379; // x25
  unsigned __int64 v380; // x8
  unsigned __int64 j; // x22
  char *v382; // x20
  size_t *v383; // x21
  char *v384; // x24
  __int64 v385; // x8
  size_t v386; // x23
  const void *v387; // x1
  void *v388; // x25
  const void *v389; // x25
  void *v390; // x0
  char *v391; // x8
  char *v392; // x23
  char *v393; // x23
  __int64 v394; // x8
  __int64 v395; // x8
  char v396; // t1
  __int64 v397; // x8
  size_t v398; // x24
  const void *v399; // x25
  void *v400; // x23
  void *v401; // x0
  char *v402; // x8
  void **v403; // x9
  void **v404; // x19
  _QWORD *v405; // x8
  size_t v406; // x10
  void **v407; // x20
  __int64 v408; // x23
  void **v409; // x21
  unsigned __int64 v410; // x8
  __int64 v411; // x28
  __int64 v412; // x19
  size_t *v413; // x9
  size_t *v414; // x21
  __int64 v415; // x23
  __int64 v416; // x10
  unsigned __int64 v417; // x26
  unsigned __int64 v418; // x9
  __int64 v419; // x24
  unsigned __int64 v420; // x9
  __int64 v421; // x8
  size_t v422; // x0
  __int64 v423; // x8
  size_t v424; // x20
  const void *v425; // x23
  void *v426; // x24
  _BYTE *v427; // x20
  __int64 v428; // x8
  __int64 v429; // x8
  char v430; // t1
  __int64 v431; // x8
  size_t v432; // x23
  const void *v433; // x24
  void *v434; // x20
  __int64 v435; // x19
  unsigned __int64 v436; // x8
  const void *v437; // x1
  size_t v438; // x2
  __int64 v439; // x19
  _BYTE *v440; // x21
  char *v441; // x1
  size_t v442; // x2
  __int64 v443; // x1
  unsigned __int64 v444; // x8
  unsigned __int64 v445; // x9
  unsigned __int64 v446; // x19
  char *v447; // x25
  size_t *v448; // x22
  char *v449; // x11
  __int64 v450; // x8
  size_t v451; // x26
  const void *v452; // x27
  void *v453; // x28
  char *v454; // x8
  char *v455; // x26
  char *v456; // x26
  __int64 v457; // x8
  __int64 v458; // x8
  char v459; // t1
  __int64 v460; // x8
  size_t v461; // x27
  const void *v462; // x28
  char *v463; // x21
  void *v464; // x26
  void *v465; // x0
  char *v466; // x8
  void **v467; // x9
  void **v468; // x20
  _QWORD *v469; // x8
  size_t v470; // x10
  void **v471; // x25
  __int64 v472; // x21
  void **v473; // x22
  unsigned __int64 v474; // x8
  __int64 v475; // x8
  __int64 v476; // x8
  unsigned __int64 v477; // x9
  unsigned __int64 v478; // x10
  const void *v479; // x11
  const void *v480; // x8
  bool v481; // zf
  unsigned __int64 v482; // x9
  const void *v483; // x26
  size_t v484; // x25
  char *v485; // x9
  _BOOL4 v486; // w20
  unsigned __int16 *v487; // x9
  __int64 v488; // x8
  size_t v489; // x2
  char *v490; // x1
  __int64 v491; // x9
  __int64 v492; // x9
  unsigned __int64 v493; // x10
  unsigned int v494; // t1
  _BYTE *v495; // x8
  __int64 v496; // x23
  __int64 v497; // x21
  size_t *v498; // x9
  size_t *v499; // x20
  __int64 v500; // x24
  __int64 v501; // x10
  unsigned __int64 v502; // x20
  unsigned __int64 v503; // x9
  __int64 v504; // x26
  unsigned __int64 v505; // x9
  __int64 v506; // x8
  size_t v507; // x0
  __int64 v508; // x8
  size_t v509; // x25
  const void *v510; // x26
  void *v511; // x27
  _BYTE *v512; // x25
  __int64 v513; // x8
  __int64 v514; // x8
  char v515; // t1
  __int64 v516; // x8
  size_t v517; // x26
  const void *v518; // x27
  void *v519; // x25
  unsigned __int64 v520; // x26
  char *v521; // x27
  size_t *v522; // x22
  char *v523; // x23
  __int64 v524; // x8
  size_t v525; // x24
  const void *v526; // x25
  void *v527; // x21
  char *v528; // x8
  char *v529; // x25
  char *v530; // x25
  __int64 v531; // x8
  __int64 v532; // x8
  char v533; // t1
  __int64 v534; // x8
  size_t v535; // x24
  const void *v536; // x19
  void *v537; // x25
  void *v538; // x0
  char *v539; // x8
  void **v540; // x9
  void **v541; // x19
  _QWORD *v542; // x8
  size_t v543; // x10
  void **v544; // x25
  __int64 v545; // x20
  void **v546; // x21
  unsigned __int64 v547; // x8
  size_t v548; // x27
  __int64 v549; // x8
  __int64 v550; // x8
  unsigned __int64 v551; // x9
  unsigned __int64 v552; // x10
  const void *v553; // x11
  const void *v554; // x8
  bool v555; // zf
  unsigned __int64 v556; // x9
  const void *v557; // x20
  size_t v558; // x21
  char *v559; // x9
  _BOOL4 v560; // w19
  unsigned __int16 *v561; // x9
  __int64 v562; // x8
  size_t v563; // x2
  char *v564; // x1
  __int64 v565; // x9
  __int64 v566; // x9
  unsigned __int64 v567; // x10
  unsigned int v568; // t1
  _BYTE *v569; // x8
  __int64 v570; // x8
  unsigned __int8 *v571; // x8
  unsigned __int64 v572; // x9
  bool v573; // zf
  unsigned __int64 v574; // x9
  const void *v575; // x21
  size_t v576; // x20
  size_t *v577; // x28
  char *v578; // x8
  char *v579; // x0
  _BOOL4 v580; // w20
  __int64 v581; // x19
  __int64 *v582; // x9
  unsigned __int64 v583; // x8
  unsigned __int64 v584; // x22
  unsigned __int64 v585; // x23
  size_t v586; // x24
  unsigned __int64 v587; // x22
  char *v588; // x25
  char *v589; // x25
  size_t v590; // x8
  char *v591; // x21
  size_t v592; // x23
  __int64 v593; // x9
  unsigned __int64 v594; // x8
  size_t v595; // x20
  _WORD *v596; // x0
  _WORD *v597; // x21
  __int64 v598; // x8
  char *v599; // x8
  char *v600; // x1
  size_t v601; // x8
  __int64 v602; // x28
  __int64 v603; // x19
  size_t *v604; // x9
  size_t *v605; // x22
  __int64 v606; // x21
  __int64 v607; // x10
  unsigned __int64 v608; // x20
  unsigned __int64 v609; // x9
  __int64 v610; // x23
  unsigned __int64 v611; // x9
  __int64 v612; // x8
  size_t v613; // x0
  __int64 v614; // x8
  size_t v615; // x24
  const void *v616; // x20
  void *v617; // x21
  _BYTE *v618; // x24
  __int64 v619; // x8
  __int64 v620; // x8
  char v621; // t1
  __int64 v622; // x8
  size_t v623; // x25
  const void *v624; // x20
  void *v625; // x24
  __int64 v626; // x9
  __int64 v627; // x9
  unsigned __int64 v628; // x19
  char *v629; // x25
  size_t *v630; // x22
  char *v631; // x11
  __int64 v632; // x8
  size_t v633; // x26
  const void *v634; // x27
  void *v635; // x28
  char *v636; // x8
  char *v637; // x26
  char *v638; // x26
  __int64 v639; // x8
  __int64 v640; // x8
  char v641; // t1
  __int64 v642; // x8
  size_t v643; // x27
  const void *v644; // x28
  char *v645; // x21
  void *v646; // x26
  void *v647; // x0
  char *v648; // x8
  void **v649; // x9
  void **v650; // x20
  _QWORD *v651; // x8
  size_t v652; // x10
  void **v653; // x25
  __int64 v654; // x21
  void **v655; // x22
  unsigned __int64 v656; // x8
  __int64 v657; // x8
  __int64 v658; // x8
  unsigned __int64 v659; // x9
  unsigned __int64 v660; // x10
  const void *v661; // x11
  const void *v662; // x8
  bool v663; // zf
  unsigned __int64 v664; // x9
  const void *v665; // x26
  size_t v666; // x25
  char *v667; // x9
  _BOOL4 v668; // w20
  unsigned __int16 *v669; // x9
  __int64 v670; // x8
  size_t v671; // x2
  char *v672; // x1
  __int64 v673; // x9
  __int64 v674; // x9
  unsigned __int64 v675; // x10
  unsigned int v676; // t1
  _BYTE *v677; // x8
  __int64 v678; // x23
  __int64 v679; // x21
  size_t *v680; // x9
  size_t *v681; // x20
  __int64 v682; // x24
  __int64 v683; // x10
  unsigned __int64 v684; // x20
  unsigned __int64 v685; // x9
  __int64 v686; // x26
  unsigned __int64 v687; // x9
  __int64 v688; // x8
  size_t v689; // x0
  __int64 v690; // x8
  size_t v691; // x25
  const void *v692; // x26
  void *v693; // x27
  _BYTE *v694; // x25
  __int64 v695; // x8
  __int64 v696; // x8
  char v697; // t1
  __int64 v698; // x8
  size_t v699; // x26
  const void *v700; // x27
  void *v701; // x25
  __int64 v702; // x10
  __int64 v703; // x23
  __int64 v704; // x9
  unsigned __int64 v705; // x9
  __int64 v706; // x19
  char *v707; // x0
  char *v708; // x10
  char *v709; // x9
  void **v710; // x12
  void **v711; // x20
  char *v712; // x8
  unsigned __int64 v713; // x11
  char *v714; // x10
  __int128 v715; // t1
  void **v716; // x22
  char *v717; // x10
  char *v718; // x9
  void **v719; // x12
  void **v720; // x20
  char *v721; // x8
  unsigned __int64 v722; // x11
  char *v723; // x10
  __int128 v724; // t1
  void **v725; // x22
  __int64 v726; // x19
  unsigned __int64 v727; // x8
  __int64 v728; // x19
  unsigned __int64 v729; // x8
  unsigned __int64 v730; // x8
  void *v731; // x0
  void *v732; // x21
  char *v733; // x8
  char *v734; // x0
  _BOOL4 v735; // w20
  __int64 v736; // x8
  unsigned __int64 v737; // x9
  size_t v738; // x10
  const void *v739; // x11
  size_t *v740; // x0
  const void *v741; // x8
  const void *v742; // x1
  size_t v743; // x2
  size_t *v744; // x0
  char v745; // w19
  void *v746; // x20
  char *v747; // x1
  size_t v748; // x2
  void *v749; // x9
  __int64 v750; // x10
  void *v751; // x11
  char v752; // w8
  void *v753; // x8
  void *v754; // x9
  __int64 v755; // x8
  unsigned __int64 v756; // x9
  size_t v757; // x10
  const void *v758; // x11
  size_t *v759; // x0
  const void *v760; // x8
  const void *v761; // x1
  size_t v762; // x2
  size_t *v763; // x0
  __int64 v764; // x20
  _BYTE *v765; // x19
  unsigned __int64 v766; // x8
  unsigned __int8 *v767; // x9
  unsigned __int8 *v768; // x0
  char *v769; // x8
  __int64 v770; // x8
  unsigned __int64 v771; // x9
  size_t v772; // x10
  const void *v773; // x11
  size_t *v774; // x0
  const void *v775; // x8
  const void *v776; // x1
  size_t v777; // x2
  size_t *v778; // x0
  char v779; // w19
  void *v780; // x20
  char *v781; // x1
  size_t v782; // x2
  char *v783; // x8
  __int128 v784; // q0
  void *v785; // x9
  __int64 v786; // x10
  void *v787; // x11
  char v788; // w8
  void *v789; // x8
  void *v790; // x9
  void **v791; // x20
  void **v792; // x22
  char *v793; // x9
  _BOOL4 v794; // w19
  unsigned __int16 *v795; // x9
  __int64 v796; // x19
  unsigned __int64 v797; // x8
  _BYTE *v798; // x24
  unsigned __int64 v799; // x9
  char *v800; // x22
  __int64 v801; // x10
  __int64 v802; // x19
  __int64 v803; // x9
  unsigned __int64 v804; // x9
  __int64 v805; // x22
  char *v806; // x0
  void **v807; // x20
  void **v808; // x22
  __int64 v809; // x8
  unsigned __int64 v810; // x9
  const void *v811; // x10
  const void *v812; // x8
  unsigned __int64 v813; // x11
  bool v814; // zf
  unsigned __int64 v815; // x9
  const void *v816; // x24
  size_t v817; // x23
  __int64 v818; // x10
  __int64 v819; // x19
  __int64 v820; // x9
  unsigned __int64 v821; // x9
  __int64 v822; // x21
  char *v823; // x0
  __int64 v824; // x9
  __int64 v825; // x10
  __int64 v826; // x23
  __int64 v827; // x9
  unsigned __int64 v828; // x9
  __int64 v829; // x19
  char *v830; // x0
  char *v831; // x10
  char *v832; // x9
  void **v833; // x12
  void **v834; // x21
  char *v835; // x8
  unsigned __int64 v836; // x11
  char *v837; // x10
  __int128 v838; // t1
  void **v839; // x22
  __int64 v840; // x10
  __int64 v841; // x25
  __int64 v842; // x9
  unsigned __int64 v843; // x9
  __int64 v844; // x21
  char *v845; // x0
  __int64 v846; // x19
  unsigned __int64 v847; // x8
  _BYTE *v848; // x0
  _QWORD *v849; // x26
  unsigned __int8 *v850; // x27
  __int64 v851; // x25
  _WORD *v852; // x19
  unsigned __int64 v853; // x8
  unsigned __int64 v854; // x21
  size_t v855; // x24
  void *v856; // x0
  void *v857; // x23
  _BYTE *v858; // x0
  __int64 v859; // x8
  unsigned __int64 v860; // x8
  unsigned __int64 v861; // x9
  void **v862; // x19
  __int64 v863; // x10
  __int64 v864; // x19
  __int64 v865; // x9
  unsigned __int64 v866; // x9
  __int64 v867; // x22
  char *v868; // x0
  unsigned __int8 *v869; // x22
  __int64 v870; // x8
  unsigned __int64 v871; // x9
  size_t v872; // x10
  const void *v873; // x11
  size_t *v874; // x0
  const void *v875; // x8
  const void *v876; // x1
  size_t v877; // x2
  size_t *v878; // x0
  unsigned __int64 v879; // x21
  char *v880; // x23
  __int64 v881; // x24
  char v882; // w10
  _BYTE *v883; // x19
  __int64 v884; // x10
  __int64 v885; // x23
  __int64 v886; // x8
  unsigned __int64 v887; // x8
  unsigned __int64 v888; // x9
  __int64 v889; // x9
  void **v890; // x21
  void **v891; // x22
  __int64 v892; // x8
  void *v893; // x0
  unsigned __int64 v894; // x8
  size_t v895; // x0
  unsigned __int64 v896; // x21
  void *v897; // x0
  void *v898; // x21
  __int64 v899; // x10
  __int64 v900; // x19
  __int64 v901; // x9
  unsigned __int64 v902; // x9
  __int64 v903; // x22
  char *v904; // x0
  __int64 v905; // x10
  __int64 v906; // x19
  __int64 v907; // x9
  unsigned __int64 v908; // x9
  __int64 v909; // x21
  char *v910; // x0
  char *v911; // x10
  char *v912; // x9
  void **v913; // x12
  void **v914; // x20
  char *v915; // x8
  unsigned __int64 v916; // x11
  char *v917; // x10
  __int128 v918; // t1
  void **v919; // x22
  __int64 v920; // x9
  __int64 v921; // x19
  unsigned __int64 v922; // x8
  char *v923; // x1
  size_t v924; // x2
  __int64 v925; // x8
  void *v926; // x9
  void *v927; // x20
  char v928; // w19
  __int64 v929; // x8
  __int64 v930; // x9
  unsigned __int64 v931; // x8
  unsigned __int64 v932; // x9
  unsigned __int8 *v933; // x24
  void *v934; // x24
  char *v935; // x0
  int v936; // w19
  __int64 v937; // x8
  unsigned __int64 v938; // x8
  unsigned __int64 v939; // x9
  __int64 v940; // x10
  __int64 v941; // x19
  __int64 v942; // x9
  unsigned __int64 v943; // x9
  __int64 v944; // x22
  char *v945; // x0
  __int64 v946; // x9
  char *v947; // x10
  char *v948; // x9
  void **v949; // x12
  void **v950; // x20
  char *v951; // x8
  unsigned __int64 v952; // x11
  char *v953; // x10
  __int128 v954; // t1
  void **v955; // x22
  __int64 v956; // x19
  unsigned __int64 v957; // x8
  void **v958; // x20
  void **v959; // x22
  __int64 v960; // x9
  char *v961; // x10
  char *v962; // x9
  void **v963; // x12
  void **v964; // x20
  char *v965; // x8
  unsigned __int64 v966; // x11
  char *v967; // x10
  __int128 v968; // t1
  void **v969; // x21
  __int64 v970; // x9
  void **v971; // x20
  void **v972; // x22
  __int64 v973; // x9
  __int64 v974; // x19
  unsigned __int64 v975; // x8
  int v976; // w8
  char *v977; // x10
  char *v978; // x9
  void **v979; // x12
  void **v980; // x21
  char *v981; // x8
  unsigned __int64 v982; // x11
  char *v983; // x10
  __int128 v984; // t1
  void **v985; // x22
  char *v986; // x12
  _QWORD *v987; // x9
  void **v988; // x11
  void **v989; // x20
  char *v990; // x8
  unsigned __int64 v991; // x10
  char *v992; // x12
  __int128 v993; // t1
  _QWORD *v994; // x13
  void **v995; // x21
  __int64 v996; // x19
  unsigned __int64 v997; // x8
  char *v998; // x10
  char *v999; // x9
  void **v1000; // x12
  void **v1001; // x20
  char *v1002; // x8
  unsigned __int64 v1003; // x11
  char *v1004; // x10
  __int128 v1005; // t1
  void **v1006; // x22
  void **v1007; // x20
  void **v1008; // x21
  _BYTE *v1009; // x0
  __int64 v1010; // x21
  __int64 v1011; // x8
  __int64 v1012; // x9
  _BYTE *v1013; // x24
  char v1014; // w19
  __int64 v1015; // x25
  _BYTE **v1016; // x27
  unsigned __int64 v1017; // x8
  unsigned __int64 v1018; // x21
  size_t v1019; // x23
  void *v1020; // x0
  void *v1021; // x22
  _BYTE *v1022; // x0
  __int64 v1023; // x25
  unsigned __int64 v1024; // x8
  __int64 v1025; // x19
  unsigned __int64 v1026; // x8
  __int64 v1027; // x9
  void **v1028; // x21
  void **v1029; // x22
  __int64 v1031; // x9
  unsigned __int64 v1032; // x19
  unsigned __int64 v1033; // x27
  char *v1034; // x20
  size_t *v1035; // x27
  char *v1036; // x11
  void **v1037; // x8
  size_t v1038; // x21
  const void *v1039; // x1
  void *v1040; // x24
  const void *v1041; // x24
  void *v1042; // x0
  char *v1043; // x8
  char *v1044; // x21
  char *v1045; // x21
  void **v1046; // x8
  void **v1047; // x8
  char v1048; // t1
  void **v1049; // x8
  size_t v1050; // x22
  const void *v1051; // x24
  void *v1052; // x21
  void *v1053; // x0
  char *v1054; // x8
  void **v1055; // x9
  void **v1056; // x21
  _QWORD *v1057; // x8
  size_t v1058; // x10
  void **v1059; // x20
  __int64 v1060; // x22
  void **v1061; // x23
  unsigned __int64 v1062; // x8
  __int64 v1063; // x26
  void **v1064; // x23
  size_t *v1065; // x9
  size_t *v1066; // x25
  __int64 v1067; // x21
  __int64 v1068; // x10
  unsigned __int64 v1069; // x25
  unsigned __int64 v1070; // x9
  __int64 v1071; // x22
  unsigned __int64 v1072; // x9
  __int64 v1073; // x8
  size_t v1074; // x0
  void **v1075; // x8
  size_t v1076; // x20
  const void *v1077; // x21
  void *v1078; // x22
  _BYTE *v1079; // x20
  void **v1080; // x8
  void **v1081; // x8
  char v1082; // t1
  void **v1083; // x8
  size_t v1084; // x21
  const void *v1085; // x22
  void *v1086; // x20
  void **v1087; // x20
  void **v1088; // x21
  unsigned __int64 v1089; // x23
  __int64 v1090; // x22
  unsigned __int64 v1091; // x9
  unsigned __int64 v1092; // x9
  __int64 v1093; // x9
  char *v1094; // x0
  char *v1095; // x10
  char *v1096; // x9
  void **v1097; // x12
  void **v1098; // x20
  char *v1099; // x8
  unsigned __int64 v1100; // x11
  char *v1101; // x10
  __int128 v1102; // t1
  void **v1103; // x22
  char *v1104; // x10
  char *v1105; // x9
  void **v1106; // x12
  void **v1107; // x20
  char *v1108; // x8
  unsigned __int64 v1109; // x11
  char *v1110; // x10
  __int128 v1111; // t1
  void **v1112; // x21
  __int64 v1113; // x19
  unsigned __int64 v1114; // x8
  __int64 v1115; // x19
  unsigned __int64 v1116; // x8
  void **v1117; // x20
  void **v1118; // x22
  void **v1119; // x0
  void **v1120; // x20
  void **v1121; // x21
  size_t v1122; // x23
  char *v1123; // x22
  unsigned __int64 v1124; // x8
  unsigned __int64 v1125; // x26
  size_t v1126; // x23
  void *v1127; // x0
  void *v1128; // x22
  __int64 v1129; // x8
  void *v1130; // x3
  char *v1131; // x2
  _BYTE *v1132; // x0
  unsigned __int64 v1133; // x8
  char *v1134; // x23
  size_t v1135; // x22
  unsigned __int64 v1136; // x9
  _BOOL4 v1137; // w22
  unsigned __int16 *v1138; // x9
  unsigned __int64 v1139; // x10
  char *v1140; // x22
  __int64 v1141; // x8
  __int64 v1142; // x23
  char *v1143; // x1
  size_t v1144; // x2
  void *v1145; // x8
  __int128 v1146; // q0
  char *v1147; // x8
  __int128 v1148; // q0
  unsigned __int16 *v1149; // x8
  __int128 v1150; // q0
  char v1151; // w19
  void *v1152; // x22
  char *v1153; // x1
  size_t v1154; // x2
  __int64 v1155; // x8
  __int64 v1156; // x9
  _BYTE *v1157; // x26
  char v1158; // w25
  __int64 v1159; // x27
  _BYTE **v1160; // x28
  unsigned __int64 v1161; // x8
  size_t v1162; // x24
  void *v1163; // x0
  void *v1164; // x23
  _BYTE *v1165; // x0
  void *v1166; // x0
  char *v1167; // x9
  _BOOL4 v1168; // w23
  unsigned __int16 *v1169; // x9
  __int64 v1170; // x25
  unsigned __int64 v1171; // x8
  _BYTE *v1172; // x27
  unsigned __int64 v1173; // x9
  char *v1174; // x23
  char *v1175; // x8
  char *v1176; // x9
  void **v1177; // x11
  void **v1178; // x19
  char *v1179; // x10
  __int64 v1180; // x12
  void **v1181; // x20
  __int64 v1182; // x22
  void **v1183; // x23
  unsigned __int64 v1184; // x8
  __int64 v1185; // x1
  unsigned __int64 v1186; // x8
  unsigned __int64 v1187; // x9
  void **v1188; // x19
  __int64 v1189; // x10
  __int64 v1190; // x19
  __int64 v1191; // x9
  unsigned __int64 v1192; // x9
  __int64 v1193; // x22
  char *v1194; // x0
  __int64 v1195; // x9
  char *v1196; // x10
  char *v1197; // x9
  void **v1198; // x12
  void **v1199; // x20
  char *v1200; // x8
  unsigned __int64 v1201; // x11
  char *v1202; // x10
  __int128 v1203; // t1
  void **v1204; // x22
  __int64 v1205; // x19
  unsigned __int64 v1206; // x8
  void **v1207; // x20
  void **v1208; // x22
  __int64 v1209; // x10
  __int64 v1210; // x24
  __int64 v1211; // x24
  char *v1212; // x0
  unsigned __int8 *v1213; // x9
  char *v1214; // x8
  _OWORD *v1215; // x11
  __int128 *v1216; // x12
  unsigned __int64 v1217; // x13
  __int128 v1218; // q0
  __int128 v1219; // q1
  __int64 v1220; // x9
  char v1221; // t1
  char *v1222; // x8
  __int128 v1223; // q0
  void *v1224; // x8
  unsigned __int64 v1225; // x10
  size_t v1226; // x11
  char *v1227; // x2
  size_t v1228; // x3
  char *v1229; // x1
  char *v1230; // x8
  __int128 v1231; // q0
  char v1232; // w19
  char *v1233; // x24
  char *v1234; // x1
  size_t v1235; // x2
  char *v1236; // x25
  void *v1237; // x8
  __int128 v1238; // q0
  __int64 v1239; // x8
  void *v1240; // x9
  void *v1241; // x21
  char v1242; // w22
  unsigned __int64 v1243; // x8
  unsigned __int64 v1244; // x9
  __int64 v1245; // x23
  unsigned __int64 v1246; // x24
  unsigned __int64 v1247; // x9
  unsigned __int64 v1248; // x9
  __int64 v1249; // x9
  char *v1250; // x0
  char *v1251; // x8
  __int128 v1252; // q0
  char *v1253; // x8
  __int128 v1254; // q0
  char v1255; // w19
  void *v1256; // x23
  char *v1257; // x1
  size_t v1258; // x2
  char *v1259; // x8
  char *v1260; // x9
  void **v1261; // x11
  void **v1262; // x21
  char *v1263; // x10
  __int64 v1264; // x12
  void **v1265; // x22
  __int64 v1266; // x23
  void **v1267; // x24
  unsigned __int64 v1268; // x8
  unsigned __int8 *v1269; // x19
  __int64 v1270; // x8
  unsigned __int64 v1271; // x8
  unsigned __int64 v1272; // x9
  __int64 v1273; // x10
  __int64 v1274; // x19
  __int64 v1275; // x9
  unsigned __int64 v1276; // x9
  __int64 v1277; // x21
  char *v1278; // x0
  __int64 v1279; // x9
  char *v1280; // x10
  char *v1281; // x9
  void **v1282; // x12
  void **v1283; // x20
  char *v1284; // x8
  unsigned __int64 v1285; // x11
  char *v1286; // x10
  __int128 v1287; // t1
  void **v1288; // x21
  __int64 v1289; // x19
  unsigned __int64 v1290; // x8
  void **v1291; // x20
  void **v1292; // x21
  __int64 v1293; // [xsp+8h] [xbp-1A8h]
  char *v1295; // [xsp+20h] [xbp-190h]
  __int64 v1296; // [xsp+20h] [xbp-190h]
  unsigned __int64 v1297; // [xsp+28h] [xbp-188h]
  unsigned __int8 *v1298; // [xsp+28h] [xbp-188h]
  size_t v1299; // [xsp+28h] [xbp-188h]
  int v1300; // [xsp+30h] [xbp-180h]
  unsigned __int64 v1301; // [xsp+30h] [xbp-180h]
  char *v1302; // [xsp+30h] [xbp-180h]
  unsigned __int64 v1303; // [xsp+30h] [xbp-180h]
  char *v1304; // [xsp+30h] [xbp-180h]
  size_t v1305; // [xsp+30h] [xbp-180h]
  unsigned __int64 v1306; // [xsp+30h] [xbp-180h]
  int v1307; // [xsp+38h] [xbp-178h]
  void *v1308; // [xsp+38h] [xbp-178h]
  _BYTE *v1309; // [xsp+38h] [xbp-178h]
  char v1310; // [xsp+38h] [xbp-178h]
  char *v1311; // [xsp+38h] [xbp-178h]
  unsigned __int64 v1312; // [xsp+38h] [xbp-178h]
  void *v1313; // [xsp+38h] [xbp-178h]
  char v1314; // [xsp+40h] [xbp-170h]
  unsigned __int8 *v1315; // [xsp+40h] [xbp-170h]
  __int64 *v1316; // [xsp+40h] [xbp-170h]
  unsigned __int64 v1317; // [xsp+40h] [xbp-170h]
  unsigned __int64 i; // [xsp+40h] [xbp-170h]
  unsigned __int64 v1319; // [xsp+40h] [xbp-170h]
  void *v1320; // [xsp+40h] [xbp-170h]
  char *v1321; // [xsp+40h] [xbp-170h]
  void *v1322[2]; // [xsp+50h] [xbp-160h] BYREF
  void *p; // [xsp+60h] [xbp-150h]
  __int128 v1324; // [xsp+68h] [xbp-148h] BYREF
  void *v1325; // [xsp+78h] [xbp-138h]
  _QWORD v1326[2]; // [xsp+80h] [xbp-130h] BYREF
  __int128 v1327; // [xsp+90h] [xbp-120h] BYREF
  char *v1328; // [xsp+A0h] [xbp-110h]
  _BYTE v1329[32]; // [xsp+B0h] [xbp-100h] BYREF
  __int128 v1330; // [xsp+D0h] [xbp-E0h] BYREF
  void *v1331; // [xsp+E0h] [xbp-D0h]
  __int128 v1332; // [xsp+F0h] [xbp-C0h] BYREF
  char *v1333; // [xsp+100h] [xbp-B0h]
  __int128 v1334; // [xsp+110h] [xbp-A0h] BYREF
  char *v1335; // [xsp+120h] [xbp-90h]
  __int128 v1336; // [xsp+128h] [xbp-88h] BYREF
  char *v1337; // [xsp+138h] [xbp-78h]
  __int128 v1338; // [xsp+140h] [xbp-70h] BYREF
  unsigned __int16 *v1339; // [xsp+150h] [xbp-60h]

  v4 = a1;
  _ReadStatusReg(TPIDR_EL0);
  if ( a1 == a2 )
    return v4;
  v6 = *a1;
  v1314 = 0;
  if ( v6 == 75 )
  {
    v7 = a1;
    goto LABEL_8;
  }
  v7 = a1;
  if ( v6 != 86 )
  {
    if ( v6 == 114 )
    {
      v7 = a1 + 1;
      v6 = a1[1];
      v1314 = 4;
      goto LABEL_6;
    }
    v15 = sub_58698(a1, a2, a3);
    if ( v15 != v4 )
      return v15;
    switch ( *v4 )
    {
      case 'A':
        v23 = (char *)(v4 + 1);
        if ( v4 + 1 == a2 )
          return v4;
        v24 = (unsigned __int8)*v23;
        if ( v24 == 95 )
        {
          v25 = (_QWORD *)a3;
          v26 = (unsigned __int8 *)sub_38008(v4 + 2, a2, a3);
          if ( v26 == v4 + 2 )
            return v4;
          v27 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v27 )
            return v4;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          v28 = *(unsigned __int8 *)(v27 - 24);
          v29 = (const void *)(v27 - 23);
          v31 = *(_QWORD *)(v27 - 16);
          v30 = *(const void **)(v27 - 8);
          v32 = (v28 & 1) == 0;
          if ( (v28 & 1) != 0 )
            v33 = v31;
          else
            v33 = v28 >> 1;
          if ( v32 )
            v34 = v29;
          else
            v34 = v30;
          if ( v33 >= 2 )
            v35 = 2;
          else
            v35 = v33;
          LOBYTE(v1322[0]) = 2 * v35;
          if ( v35 )
            memcpy((char *)v1322 + 1, v34, v35);
          *((_BYTE *)v1322 + v35 + 1) = 0;
          v793 = (char *)v1322[1];
          v794 = 0;
          if ( ((__int64)v1322[0] & 1) == 0 )
            v793 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v793 == (_BYTE *)&dword_0 + 2 )
          {
            v795 = (unsigned __int16 *)p;
            if ( ((__int64)v1322[0] & 1) == 0 )
              v795 = (unsigned __int16 *)((char *)v1322 + 1);
            v794 = *v795 == 23328;
            if ( ((__int64)v1322[0] & 1) != 0 )
            {
LABEL_1079:
              free(p);
              if ( !v794 )
                goto LABEL_1212;
LABEL_1083:
              v796 = *(_QWORD *)(a3 + 8);
              v798 = (_BYTE *)(v796 - 24);
              v797 = *(unsigned __int8 *)(v796 - 24);
              if ( (*(_BYTE *)(v796 - 24) & 1) != 0 )
              {
                v799 = *(_QWORD *)(v796 - 16);
                v800 = *(char **)(v796 - 8);
              }
              else
              {
                v799 = v797 >> 1;
                v800 = (char *)(v796 - 23);
              }
              v884 = v799 != 0;
              v885 = v799 - v884;
              if ( v799 != v884 )
              {
                memmove(v800, &v800[v884], v799 - v884);
                LOBYTE(v797) = *v798;
              }
              if ( (v797 & 1) != 0 )
                *(_QWORD *)(v796 - 16) = v885;
              else
                *v798 = 2 * v885;
              v800[v885] = 0;
LABEL_1212:
              sub_429F4((size_t *)(*(_QWORD *)(a3 + 8) - 24LL), 0, " []", 3u);
              if ( v26 != v4 )
                goto LABEL_1213;
              return v4;
            }
          }
          else if ( ((__int64)v1322[0] & 1) != 0 )
          {
            goto LABEL_1079;
          }
          if ( !v794 )
            goto LABEL_1212;
          goto LABEL_1083;
        }
        if ( (unsigned int)(v24 - 49) <= 8 )
        {
          if ( v4 + 2 == a2 )
            return v4;
          v258 = 0;
          v259 = 2;
          while ( (unsigned int)v258[(_QWORD)v4 + 2] - 48 < 0xA )
          {
            ++v258;
            v259 += 2;
            if ( &a2[-2LL - (_QWORD)v4] == v258 )
              return v4;
          }
          if ( &a2[-2LL - (_QWORD)v4] == v258 )
            return v4;
          if ( v258[(_QWORD)v4 + 2] != 95 )
            return v4;
          v26 = (unsigned __int8 *)sub_38008(&v258[(_QWORD)v4 + 3], a2, a3);
          if ( (unsigned __int8 *)(v26 - v4 - 3) == v258 )
            return v4;
          v809 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v809 )
            return v4;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          v810 = *(unsigned __int8 *)(v809 - 24);
          v811 = (const void *)(v809 - 23);
          v813 = *(_QWORD *)(v809 - 16);
          v812 = *(const void **)(v809 - 8);
          v814 = (v810 & 1) == 0;
          if ( (v810 & 1) != 0 )
            v815 = v813;
          else
            v815 = v810 >> 1;
          if ( v814 )
            v816 = v811;
          else
            v816 = v812;
          if ( v815 >= 2 )
            v817 = 2;
          else
            v817 = v815;
          LOBYTE(v1322[0]) = 2 * v817;
          if ( v817 )
            memcpy((char *)v1322 + 1, v816, v817);
          *((_BYTE *)v1322 + v817 + 1) = 0;
          v1167 = (char *)v1322[1];
          v1168 = 0;
          if ( ((__int64)v1322[0] & 1) == 0 )
            v1167 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v1167 == (_BYTE *)&dword_0 + 2 )
          {
            v1169 = (unsigned __int16 *)p;
            if ( ((__int64)v1322[0] & 1) == 0 )
              v1169 = (unsigned __int16 *)((char *)v1322 + 1);
            v1168 = *v1169 == 23328;
            if ( ((__int64)v1322[0] & 1) != 0 )
            {
LABEL_1712:
              free(p);
              if ( !v1168 )
                goto LABEL_1791;
LABEL_1716:
              v1170 = *(_QWORD *)(a3 + 8);
              v1172 = (_BYTE *)(v1170 - 24);
              v1171 = *(unsigned __int8 *)(v1170 - 24);
              if ( (*(_BYTE *)(v1170 - 24) & 1) != 0 )
              {
                v1173 = *(_QWORD *)(v1170 - 16);
                v1174 = *(char **)(v1170 - 8);
              }
              else
              {
                v1173 = v1171 >> 1;
                v1174 = (char *)(v1170 - 23);
              }
              v1209 = v1173 != 0;
              v1210 = v1173 - v1209;
              if ( v1173 != v1209 )
              {
                memmove(v1174, &v1174[v1209], v1173 - v1209);
                LOBYTE(v1171) = *v1172;
              }
              if ( (v1171 & 1) != 0 )
                *(_QWORD *)(v1170 - 16) = v1210;
              else
                *v1172 = 2 * v1210;
              v1174[v1210] = 0;
LABEL_1791:
              v1211 = *(_QWORD *)(a3 + 8);
              v1338 = 0u;
              v1339 = 0;
              if ( (unsigned __int64)(v258 + 1) >= 0xFFFFFFFFFFFFFFF0LL )
                goto LABEL_1929;
              if ( (unsigned __int64)(v258 + 1) >= 0x17 )
              {
                v1212 = (char *)malloc((unsigned __int64)(v258 + 17) & 0xFFFFFFFFFFFFFFF0LL);
                *((_QWORD *)&v1338 + 1) = v258 + 1;
                v1339 = (unsigned __int16 *)v1212;
                *(_QWORD *)&v1338 = (unsigned __int64)(v258 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
              }
              else
              {
                v1212 = (char *)&v1338 + 1;
                LOBYTE(v1338) = v259;
              }
              v1213 = v258 + 1;
              v1214 = v1212;
              if ( (unsigned __int64)(v258 + 1) < 0x20 )
                goto LABEL_1799;
              v1215 = v1212 + 16;
              v1216 = (__int128 *)(v4 + 17);
              v23 += (unsigned __int64)v1213 & 0xFFFFFFFFFFFFFFE0LL;
              v1214 = &v1212[(unsigned __int64)v1213 & 0xFFFFFFFFFFFFFFE0LL];
              v1217 = (unsigned __int64)(v258 + 1) & 0xFFFFFFFFFFFFFFE0LL;
              do
              {
                v1218 = *(v1216 - 1);
                v1219 = *v1216;
                v1217 -= 32LL;
                v1216 += 2;
                *(v1215 - 1) = v1218;
                *v1215 = v1219;
                v1215 += 2;
              }
              while ( v1217 );
              if ( v1213 != (unsigned __int8 *)((unsigned __int64)v1213 & 0xFFFFFFFFFFFFFFE0LL) )
              {
LABEL_1799:
                v1220 = (__int64)&v258[v4 - (unsigned __int8 *)v23 + 2];
                do
                {
                  v1221 = *v23++;
                  --v1220;
                  *v1214++ = v1221;
                }
                while ( v1220 );
              }
              v258[(_QWORD)v1212 + 1] = 0;
              sub_429F4((size_t *)&v1338, 0, " [", 2u);
              v1222 = (char *)v1339;
              v1223 = v1338;
              v1338 = 0u;
              v1339 = 0;
              v1335 = v1222;
              v1334 = v1223;
              sub_42BE4((size_t *)&v1334, "]", 1u);
              v1224 = v1335;
              *(_OWORD *)v1322 = v1334;
              v1225 = (unsigned __int8)v1334;
              v1226 = *((_QWORD *)&v1334 + 1);
              v1335 = 0;
              v1334 = 0u;
              p = v1224;
              if ( (v1225 & 1) != 0 )
                v1227 = (char *)v1224;
              else
                v1227 = (char *)v1322 + 1;
              if ( (v1225 & 1) != 0 )
                v1228 = v1226;
              else
                v1228 = v1225 >> 1;
              sub_429F4((size_t *)(v1211 - 24), 0, v1227, v1228);
              if ( ((__int64)v1322[0] & 1) != 0 )
              {
                free(p);
                if ( (v1334 & 1) == 0 )
                {
LABEL_1809:
                  if ( (v1338 & 1) == 0 )
                  {
LABEL_1815:
                    v25 = (_QWORD *)a3;
                    if ( v26 != v4 )
                    {
LABEL_1213:
                      v886 = v25[1];
                      v15 = v4;
                      if ( *v25 == v886 )
                        return v15;
                      *(_QWORD *)&v1334 = v25[3];
                      sub_42D60(v1322, v886 - 48, (__int64 *)&v1334);
                      v887 = v25[5];
                      v888 = v25[6];
                      if ( v887 < v888 )
                      {
                        *(_QWORD *)(v887 + 24) = v1324;
                        *(_OWORD *)v887 = *(_OWORD *)v1322;
                        *(_QWORD *)(v887 + 16) = p;
                        v1322[1] = 0;
                        p = 0;
                        v1322[0] = 0;
                        v25[5] += 32LL;
                        v176 = (void **)v1322[0];
                        if ( !v1322[0] )
                          return v26;
                        goto LABEL_1589;
                      }
                      v899 = v25[4];
                      v900 = (__int64)(v887 - v899) >> 5;
                      if ( (unsigned __int64)(v900 + 1) >> 59 )
                        abort();
                      v901 = v888 - v899;
                      if ( (unsigned __int64)(v901 >> 5) > 0x3FFFFFFFFFFFFFELL )
                      {
                        v903 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      else
                      {
                        v902 = v901 >> 4;
                        if ( v902 >= v900 + 1 )
                          v903 = v902;
                        else
                          v903 = v900 + 1;
                        if ( !v903 )
                        {
                          v904 = 0;
                          goto LABEL_1560;
                        }
                      }
                      v1027 = v25[7];
                      v904 = *(char **)(v1027 + 4096);
                      if ( v1027 + 4096 - (__int64)v904 >= (unsigned __int64)(32 * v903) )
                        *(_QWORD *)(v1027 + 4096) = &v904[32 * v903];
                      else
                        v904 = (char *)malloc(32 * v903);
                      v25 = (_QWORD *)a3;
LABEL_1560:
                      v1095 = &v904[32 * v900];
                      *((_QWORD *)v1095 + 1) = 0;
                      *((_QWORD *)v1095 + 2) = 0;
                      v1096 = v1095 + 32;
                      *((_QWORD *)v1095 + 3) = v1324;
                      *(_OWORD *)v1095 = *(_OWORD *)v1322;
                      *((_QWORD *)v1095 + 2) = p;
                      v1322[1] = 0;
                      p = 0;
                      v1322[0] = 0;
                      v1098 = (void **)v25[4];
                      v1097 = (void **)v25[5];
                      v1099 = &v904[32 * v903];
                      if ( v1097 == v1098 )
                      {
                        v1103 = (void **)v25[4];
                      }
                      else
                      {
                        v1100 = (char *)(v1097 - 4) - (char *)v1098;
                        v1101 = v1095 - 32;
                        do
                        {
                          *((_QWORD *)v1101 + 1) = 0;
                          *((_QWORD *)v1101 + 2) = 0;
                          *(_QWORD *)v1101 = 0;
                          *((_QWORD *)v1101 + 3) = *(v1097 - 1);
                          v1102 = *((_OWORD *)v1097 - 2);
                          v1097 -= 4;
                          *(_OWORD *)v1101 = v1102;
                          *((_QWORD *)v1101 + 2) = v1097[2];
                          v1101 -= 32;
                          *v1097 = 0;
                          v1097[1] = 0;
                          v1097[2] = 0;
                        }
                        while ( v1098 != v1097 );
                        v1103 = (void **)v25[4];
                        v1098 = (void **)v25[5];
                        v1095 = &v904[32 * (v900 - 1 - (v1100 >> 5))];
                      }
                      v1113 = v25[6];
                      v25[4] = v1095;
                      v25[5] = v1096;
                      v25[6] = v1099;
                      while ( v1103 != v1098 )
                      {
                        v1098 -= 4;
                        sub_42F30(v1098);
                      }
                      if ( v1103 )
                      {
                        v1114 = v25[7];
                        if ( v1114 + 4096 < (unsigned __int64)v1103 || v1114 > (unsigned __int64)v1103 )
                        {
                          free(v1103);
                        }
                        else if ( *(_QWORD *)(v1114 + 4096) == v1113 )
                        {
                          *(_QWORD *)(v1114 + 4096) = v1103;
                          v176 = (void **)v1322[0];
                          if ( !v1322[0] )
                            return v26;
LABEL_1589:
                          v1117 = (void **)v1322[1];
                          if ( v1322[1] != v176 )
                          {
                            do
                            {
                              if ( (*(_BYTE *)(v1117 - 3) & 1) != 0 )
                                free(*(v1117 - 1));
                              v1118 = v1117 - 6;
                              if ( (*(_BYTE *)(v1117 - 6) & 1) != 0 )
                                free(*(v1117 - 4));
                              v1117 -= 6;
                            }
                            while ( v176 != v1118 );
                          }
LABEL_1595:
                          v1322[1] = v176;
                          if ( (__int64)v1324 + 4096 >= (unsigned __int64)v176
                            && (unsigned __int64)v1324 <= (unsigned __int64)v176 )
                          {
                            if ( *(void **)(v1324 + 4096) == p )
                            {
                              *(_QWORD *)(v1324 + 4096) = v176;
                              return v26;
                            }
                            return v26;
                          }
                          v1119 = v176;
LABEL_1600:
                          free(v1119);
                          return v26;
                        }
                      }
                      v176 = (void **)v1322[0];
                      if ( !v1322[0] )
                        return v26;
                      goto LABEL_1589;
                    }
                    return v4;
                  }
                  goto LABEL_1813;
                }
              }
              else if ( (v1334 & 1) == 0 )
              {
                goto LABEL_1809;
              }
              free(v1335);
              if ( (v1338 & 1) == 0 )
                goto LABEL_1815;
LABEL_1813:
              v1166 = v1339;
              goto LABEL_1814;
            }
          }
          else if ( ((__int64)v1322[0] & 1) != 0 )
          {
            goto LABEL_1712;
          }
          if ( !v1168 )
            goto LABEL_1791;
          goto LABEL_1716;
        }
        v291 = sub_47B84(v4 + 1, a2, a3);
        if ( v291 == (unsigned __int8 *)v23 )
          return v4;
        if ( v291 == a2 )
          return v4;
        if ( *v291 != 95 )
          return v4;
        v292 = v291 + 1;
        v26 = (unsigned __int8 *)sub_38008(v291 + 1, a2, a3);
        if ( v26 == v292 )
          return v4;
        v293 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v293 - *(_QWORD *)a3) >> 4) < 2 )
          return v4;
        p = *(void **)(v293 - 32);
        *(_OWORD *)v1322 = *(_OWORD *)(v293 - 48);
        v294 = *(void **)(v293 - 8);
        *(_QWORD *)(v293 - 40) = 0;
        *(_QWORD *)(v293 - 32) = 0;
        *(_QWORD *)(v293 - 48) = 0;
        v1325 = v294;
        v1324 = *(_OWORD *)(v293 - 24);
        *(_QWORD *)(v293 - 16) = 0;
        *(_QWORD *)(v293 - 8) = 0;
        *(_QWORD *)(v293 - 24) = 0;
        v295 = *(_QWORD *)(a3 + 8);
        v296 = (_BYTE *)(v295 - 48);
        if ( (*(_BYTE *)(v295 - 24) & 1) != 0 )
          free(*(void **)(v295 - 8));
        if ( (*v296 & 1) != 0 )
          free(*(void **)(v295 - 32));
        *(_QWORD *)(a3 + 8) = v296;
        v1335 = *(char **)(v295 - 80);
        v1334 = *(_OWORD *)(v295 - 96);
        v297 = *(char **)(v295 - 56);
        *(_QWORD *)(v295 - 88) = 0;
        *(_QWORD *)(v295 - 80) = 0;
        *(_QWORD *)(v295 - 96) = 0;
        v1337 = v297;
        v1336 = *(_OWORD *)(v295 - 72);
        *(_QWORD *)(v295 - 64) = 0;
        *(_QWORD *)(v295 - 56) = 0;
        *(_QWORD *)(v295 - 72) = 0;
        v298 = *(_QWORD *)(a3 + 8);
        v299 = (_WORD *)(v298 - 48);
        if ( (*(_BYTE *)(v298 - 48) & 1) != 0 )
        {
          **(_BYTE **)(v298 - 32) = 0;
          v1124 = *(unsigned __int8 *)(v298 - 48);
          *(_QWORD *)(v298 - 40) = 0;
          if ( (v1124 & 1) != 0 )
          {
            v1132 = *(_BYTE **)(v298 - 32);
            *(_BYTE *)(v298 - 47) = *v1132;
            free(v1132);
            *(_BYTE *)(v298 - 48) = 0;
          }
          else if ( (unsigned int)v1124 >= 0x2E )
          {
            v1125 = v1124 >> 1;
            v1126 = (unsigned __int8)((v1124 >> 1) + 16) & 0xF0;
            v1127 = malloc(v1126);
            v1128 = v1127;
            if ( v1126 - 1 > 0x16 || v1127 )
            {
              memcpy(v1127, (const void *)(v298 - 47), v1125 + 1);
              *(_QWORD *)(v298 - 48) = v1126 | 1;
              *(_QWORD *)(v298 - 40) = v1125;
              *(_QWORD *)(v298 - 32) = v1128;
            }
          }
        }
        else
        {
          *v299 = 0;
        }
        *(_QWORD *)(v298 - 32) = p;
        *(_OWORD *)v299 = *(_OWORD *)v1322;
        v1322[0] = 0;
        v1322[1] = 0;
        p = 0;
        if ( (v1324 & 1) != 0 )
          v1133 = *((_QWORD *)&v1324 + 1);
        else
          v1133 = (unsigned __int64)(unsigned __int8)v1324 >> 1;
        if ( (v1324 & 1) != 0 )
          v1134 = (char *)v1325;
        else
          v1134 = (char *)&v1324 + 1;
        if ( v1133 >= 2 )
          v1135 = 2;
        else
          v1135 = v1133;
        v1338 = 0u;
        v1339 = 0;
        LOBYTE(v1338) = 2 * v1135;
        if ( v1135 )
          memcpy((char *)&v1338 + 1, v1134, v1135);
        *((_BYTE *)&v1338 + v1135 + 1) = 0;
        v1136 = *((_QWORD *)&v1338 + 1);
        v1137 = 0;
        if ( (v1338 & 1) == 0 )
          v1136 = (unsigned __int64)(unsigned __int8)v1338 >> 1;
        if ( v1136 == 2 )
        {
          v1138 = v1339;
          if ( (v1338 & 1) == 0 )
            v1138 = (unsigned __int16 *)((char *)&v1338 + 1);
          v1137 = *v1138 == 23328;
        }
        if ( (v1338 & 1) != 0 )
          free(v1339);
        if ( v1137 )
        {
          v1139 = (unsigned __int64)(unsigned __int8)v1324 >> 1;
          if ( (v1324 & 1) != 0 )
          {
            v1139 = *((_QWORD *)&v1324 + 1);
            v1140 = (char *)v1325;
          }
          else
          {
            v1140 = (char *)&v1324 + 1;
          }
          v1141 = v1139 != 0;
          v1142 = v1139 - v1141;
          if ( v1139 != v1141 )
            memmove(v1140, &v1140[v1141], v1139 - v1141);
          if ( (v1324 & 1) != 0 )
            *((_QWORD *)&v1324 + 1) = v1142;
          else
            LOBYTE(v1324) = 2 * v1142;
          v1140[v1142] = 0;
        }
        if ( (v1336 & 1) != 0 )
          v1143 = v1337;
        else
          v1143 = (char *)&v1336 + 1;
        if ( (v1336 & 1) != 0 )
          v1144 = *((_QWORD *)&v1336 + 1);
        else
          v1144 = (unsigned __int64)(unsigned __int8)v1336 >> 1;
        sub_42BE4((size_t *)&v1334, v1143, v1144);
        v1145 = v1335;
        v1146 = v1334;
        v1334 = 0u;
        v1335 = 0;
        v1331 = v1145;
        v1330 = v1146;
        sub_429F4((size_t *)&v1330, 0, " [", 2u);
        v1147 = (char *)v1331;
        v1148 = v1330;
        v1330 = 0u;
        v1331 = 0;
        v1333 = v1147;
        v1332 = v1148;
        sub_42BE4((size_t *)&v1332, "]", 1u);
        v1149 = (unsigned __int16 *)v1333;
        v1150 = v1332;
        v1333 = 0;
        v1332 = 0u;
        v1151 = v1324;
        v1152 = v1325;
        v1339 = v1149;
        v1338 = v1150;
        if ( (v1324 & 1) != 0 )
          v1153 = (char *)v1325;
        else
          v1153 = (char *)&v1324 + 1;
        if ( (v1324 & 1) != 0 )
          v1154 = *((_QWORD *)&v1324 + 1);
        else
          v1154 = (unsigned __int64)(unsigned __int8)v1324 >> 1;
        sub_42BE4((size_t *)&v1338, v1153, v1154);
        v1155 = *(_QWORD *)((char *)&v1338 + 1);
        v1156 = *((_QWORD *)&v1338 + 1);
        v1157 = v1339;
        v1158 = v1338;
        v1338 = 0u;
        v1339 = 0;
        *(_QWORD *)((char *)&v1327 + 7) = v1156;
        *(_QWORD *)&v1327 = v1155;
        v1159 = *(_QWORD *)(a3 + 8);
        if ( (*(_BYTE *)(v1159 - 24) & 1) != 0 )
        {
          v1160 = (_BYTE **)(v1159 - 8);
          **(_BYTE **)(v1159 - 8) = 0;
          v1161 = *(unsigned __int8 *)(v1159 - 24);
          *(_QWORD *)(v1159 - 16) = 0;
          if ( (v1161 & 1) != 0 )
          {
            v1165 = *v1160;
            *(_BYTE *)(v1159 - 23) = **v1160;
            free(v1165);
            *(_BYTE *)(v1159 - 24) = 0;
          }
          else if ( (unsigned int)v1161 >= 0x2E )
          {
            v1313 = (void *)(v1161 >> 1);
            v1162 = (unsigned __int8)((v1161 >> 1) + 16) & 0xF0;
            v1163 = malloc(v1162);
            if ( v1162 - 1 > 0x16 || v1163 )
            {
              v1164 = v1163;
              memcpy(v1163, (const void *)(v1159 - 23), (size_t)v1313 + 1);
              *(_QWORD *)(v1159 - 8) = v1164;
              *(_QWORD *)(v1159 - 24) = v1162 | 1;
              *(_QWORD *)(v1159 - 16) = v1313;
            }
          }
        }
        else
        {
          *(_WORD *)(v1159 - 24) = 0;
          v1160 = (_BYTE **)(v1159 - 8);
        }
        *(_BYTE *)(v1159 - 24) = v1158;
        *(_QWORD *)(v1159 - 23) = v1327;
        *(_QWORD *)(v1159 - 16) = *(_QWORD *)((char *)&v1327 + 7);
        *v1160 = v1157;
        *(_QWORD *)((char *)&v1327 + 7) = 0;
        *(_QWORD *)&v1327 = 0;
        if ( (v1338 & 1) != 0 )
        {
          free(v1339);
          if ( (v1332 & 1) == 0 )
          {
LABEL_1692:
            if ( (v1330 & 1) == 0 )
              goto LABEL_1693;
            goto LABEL_1700;
          }
        }
        else if ( (v1332 & 1) == 0 )
        {
          goto LABEL_1692;
        }
        free(v1333);
        if ( (v1330 & 1) == 0 )
        {
LABEL_1693:
          if ( (v1336 & 1) == 0 )
            goto LABEL_1694;
          goto LABEL_1701;
        }
LABEL_1700:
        free(v1331);
        if ( (v1336 & 1) == 0 )
        {
LABEL_1694:
          if ( (v1334 & 1) == 0 )
            goto LABEL_1695;
          goto LABEL_1702;
        }
LABEL_1701:
        free(v1337);
        if ( (v1334 & 1) == 0 )
        {
LABEL_1695:
          if ( (v1151 & 1) == 0 )
            goto LABEL_1696;
          goto LABEL_1703;
        }
LABEL_1702:
        free(v1335);
        if ( (v1151 & 1) == 0 )
        {
LABEL_1696:
          if ( ((__int64)v1322[0] & 1) == 0 )
            goto LABEL_1815;
          goto LABEL_1704;
        }
LABEL_1703:
        free(v1152);
        if ( ((__int64)v1322[0] & 1) == 0 )
          goto LABEL_1815;
LABEL_1704:
        v1166 = p;
LABEL_1814:
        free(v1166);
        goto LABEL_1815;
      case 'C':
        v26 = (unsigned __int8 *)sub_38008(v4 + 1, a2, a3);
        if ( v26 == v4 + 1 )
          return v4;
        v172 = *(_QWORD *)(a3 + 8);
        v15 = v4;
        if ( *(_QWORD *)a3 == v172 )
          return v15;
        sub_42BE4((size_t *)(v172 - 48), " complex", 8u);
        v173 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
        sub_42D60(v1322, v173, (__int64 *)&v1334);
        v174 = *(_QWORD *)(a3 + 40);
        v175 = *(_QWORD *)(a3 + 48);
        if ( v174 < v175 )
        {
          *(_QWORD *)(v174 + 24) = v1324;
          *(_OWORD *)v174 = *(_OWORD *)v1322;
          *(_QWORD *)(v174 + 16) = p;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          *(_QWORD *)(a3 + 40) += 32LL;
          v176 = (void **)v1322[0];
          if ( !v1322[0] )
            return v26;
          goto LABEL_1065;
        }
        v278 = *(_QWORD *)(a3 + 32);
        v279 = (__int64)(v174 - v278) >> 5;
        if ( (unsigned __int64)(v279 + 1) >> 59 )
          abort();
        v280 = v175 - v278;
        if ( (unsigned __int64)(v280 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v282 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v281 = v280 >> 4;
          if ( v281 >= v279 + 1 )
            v282 = v281;
          else
            v282 = v279 + 1;
          if ( !v282 )
          {
            v283 = 0;
            goto LABEL_966;
          }
        }
        v626 = *(_QWORD *)(a3 + 56);
        v283 = *(char **)(v626 + 4096);
        if ( v626 + 4096 - (__int64)v283 >= (unsigned __int64)(32 * v282) )
          *(_QWORD *)(v626 + 4096) = &v283[32 * v282];
        else
          v283 = (char *)malloc(32 * v282);
LABEL_966:
        v708 = &v283[32 * v279];
        *((_QWORD *)v708 + 1) = 0;
        *((_QWORD *)v708 + 2) = 0;
        v709 = v708 + 32;
        *((_QWORD *)v708 + 3) = v1324;
        *(_OWORD *)v708 = *(_OWORD *)v1322;
        *((_QWORD *)v708 + 2) = p;
        v1322[1] = 0;
        p = 0;
        v1322[0] = 0;
        v711 = *(void ***)(a3 + 32);
        v710 = *(void ***)(a3 + 40);
        v712 = &v283[32 * v282];
        if ( v710 == v711 )
        {
          v716 = *(void ***)(a3 + 32);
        }
        else
        {
          v713 = (char *)(v710 - 4) - (char *)v711;
          v714 = v708 - 32;
          do
          {
            *((_QWORD *)v714 + 1) = 0;
            *((_QWORD *)v714 + 2) = 0;
            *(_QWORD *)v714 = 0;
            *((_QWORD *)v714 + 3) = *(v710 - 1);
            v715 = *((_OWORD *)v710 - 2);
            v710 -= 4;
            *(_OWORD *)v714 = v715;
            *((_QWORD *)v714 + 2) = v710[2];
            v714 -= 32;
            *v710 = 0;
            v710[1] = 0;
            v710[2] = 0;
          }
          while ( v711 != v710 );
          v716 = *(void ***)(a3 + 32);
          v711 = *(void ***)(a3 + 40);
          v708 = &v283[32 * (v279 - 1 - (v713 >> 5))];
        }
        v726 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v708;
        *(_QWORD *)(a3 + 40) = v709;
        *(_QWORD *)(a3 + 48) = v712;
        while ( v716 != v711 )
        {
          v711 -= 4;
          sub_42F30(v711);
        }
        if ( !v716 )
          goto LABEL_1064;
        v727 = *(_QWORD *)(a3 + 56);
        if ( v727 + 4096 < (unsigned __int64)v716 || v727 > (unsigned __int64)v716 )
        {
          free(v716);
        }
        else if ( *(_QWORD *)(v727 + 4096) == v726 )
        {
          *(_QWORD *)(v727 + 4096) = v716;
          v176 = (void **)v1322[0];
          if ( !v1322[0] )
            return v26;
          goto LABEL_1065;
        }
LABEL_1064:
        v176 = (void **)v1322[0];
        if ( !v1322[0] )
          return v26;
LABEL_1065:
        v791 = (void **)v1322[1];
        if ( v1322[1] != v176 )
        {
          do
          {
            if ( (*(_BYTE *)(v791 - 3) & 1) != 0 )
              free(*(v791 - 1));
            v792 = v791 - 6;
            if ( (*(_BYTE *)(v791 - 6) & 1) != 0 )
              free(*(v791 - 4));
            v791 -= 6;
          }
          while ( v176 != v792 );
        }
        goto LABEL_1595;
      case 'D':
        if ( v4 + 1 == a2 )
          goto LABEL_1293;
        switch ( v4[1] )
        {
          case 'T':
          case 't':
            v128 = sub_46514(v4, a2, (_QWORD *)a3);
            if ( v128 == v4 )
              goto LABEL_1293;
            v15 = v4;
            v129 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v129 )
              return v15;
            *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
            sub_42D60(v1322, v129 - 48, (__int64 *)&v1334);
            v130 = *(_QWORD *)(a3 + 40);
            v131 = *(_QWORD *)(a3 + 48);
            if ( v130 < v131 )
            {
              *(_QWORD *)(v130 + 24) = v1324;
              *(_OWORD *)v130 = *(_OWORD *)v1322;
              *(_QWORD *)(v130 + 16) = p;
              v1322[1] = 0;
              p = 0;
              v1322[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v132 = (void **)v1322[0];
              if ( !v1322[0] )
                return v128;
              goto LABEL_1400;
            }
            v818 = *(_QWORD *)(a3 + 32);
            v819 = (__int64)(v130 - v818) >> 5;
            if ( (unsigned __int64)(v819 + 1) >> 59 )
              abort();
            v820 = v131 - v818;
            if ( (unsigned __int64)(v820 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v822 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v821 = v820 >> 4;
              if ( v821 >= v819 + 1 )
                v822 = v821;
              else
                v822 = v819 + 1;
              if ( !v822 )
              {
                v823 = 0;
                goto LABEL_1336;
              }
            }
            v920 = *(_QWORD *)(a3 + 56);
            v823 = *(char **)(v920 + 4096);
            if ( v920 + 4096 - (__int64)v823 >= (unsigned __int64)(32 * v822) )
              *(_QWORD *)(v920 + 4096) = &v823[32 * v822];
            else
              v823 = (char *)malloc(32 * v822);
LABEL_1336:
            v961 = &v823[32 * v819];
            *((_QWORD *)v961 + 1) = 0;
            *((_QWORD *)v961 + 2) = 0;
            v962 = v961 + 32;
            *((_QWORD *)v961 + 3) = v1324;
            *(_OWORD *)v961 = *(_OWORD *)v1322;
            *((_QWORD *)v961 + 2) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            v964 = *(void ***)(a3 + 32);
            v963 = *(void ***)(a3 + 40);
            v965 = &v823[32 * v822];
            if ( v963 == v964 )
            {
              v969 = *(void ***)(a3 + 32);
            }
            else
            {
              v966 = (char *)(v963 - 4) - (char *)v964;
              v967 = v961 - 32;
              do
              {
                *((_QWORD *)v967 + 1) = 0;
                *((_QWORD *)v967 + 2) = 0;
                *(_QWORD *)v967 = 0;
                *((_QWORD *)v967 + 3) = *(v963 - 1);
                v968 = *((_OWORD *)v963 - 2);
                v963 -= 4;
                *(_OWORD *)v967 = v968;
                *((_QWORD *)v967 + 2) = v963[2];
                v967 -= 32;
                *v963 = 0;
                v963[1] = 0;
                v963[2] = 0;
              }
              while ( v964 != v963 );
              v969 = *(void ***)(a3 + 32);
              v964 = *(void ***)(a3 + 40);
              v961 = &v823[32 * (v819 - 1 - (v966 >> 5))];
            }
            v974 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v961;
            *(_QWORD *)(a3 + 40) = v962;
            *(_QWORD *)(a3 + 48) = v965;
            while ( v969 != v964 )
            {
              v964 -= 4;
              sub_42F30(v964);
            }
            if ( !v969 )
              goto LABEL_1399;
            v975 = *(_QWORD *)(a3 + 56);
            if ( v975 + 4096 < (unsigned __int64)v969 || v975 > (unsigned __int64)v969 )
            {
              free(v969);
            }
            else if ( *(_QWORD *)(v975 + 4096) == v974 )
            {
              *(_QWORD *)(v975 + 4096) = v969;
              v132 = (void **)v1322[0];
              if ( !v1322[0] )
                return v128;
              goto LABEL_1400;
            }
LABEL_1399:
            v132 = (void **)v1322[0];
            if ( !v1322[0] )
              return v128;
LABEL_1400:
            v1007 = (void **)v1322[1];
            if ( v1322[1] != v132 )
            {
              do
              {
                if ( (*(_BYTE *)(v1007 - 3) & 1) != 0 )
                  free(*(v1007 - 1));
                v1008 = v1007 - 6;
                if ( (*(_BYTE *)(v1007 - 6) & 1) != 0 )
                  free(*(v1007 - 4));
                v1007 -= 6;
              }
              while ( v132 != v1008 );
            }
            goto LABEL_1610;
          case 'p':
            v361 = *(void ***)a3;
            v362 = *(_QWORD *)(a3 + 8);
            v15 = (unsigned __int8 *)sub_38008(v4 + 2, a2, a3);
            if ( v15 == v4 + 2 )
              goto LABEL_1293;
            v363 = *(_QWORD **)(a3 + 40);
            v364 = *(_QWORD *)(a3 + 48);
            v365 = *(void ***)a3;
            v366 = *(_QWORD *)(a3 + 8);
            v367 = *(_QWORD *)(a3 + 24);
            if ( (unsigned __int64)v363 < v364 )
            {
              *v363 = 0;
              v363[1] = 0;
              v363[2] = 0;
              v363[3] = v367;
              *(_QWORD *)(a3 + 40) += 32LL;
LABEL_1468:
              v1032 = 0xAAAAAAAAAAAAAAABLL * ((v362 - (__int64)v361) >> 4);
              v1033 = 0xAAAAAAAAAAAAAAABLL * ((v366 - (__int64)v365) >> 4);
              if ( v1032 >= v1033 )
                return v15;
              v1312 = 0xAAAAAAAAAAAAAAABLL * ((v366 - (__int64)v365) >> 4);
              while ( 1 )
              {
                v1063 = *(_QWORD *)(a3 + 40);
                v1064 = *(void ***)a3;
                v1066 = *(size_t **)(v1063 - 24);
                v1065 = *(size_t **)(v1063 - 16);
                v1067 = *(_QWORD *)a3 + 48 * v1032;
                if ( v1066 == v1065 )
                {
                  v1068 = *(_QWORD *)(v1063 - 32);
                  v1069 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v1066 - v1068) >> 4);
                  if ( v1069 + 1 > 0x555555555555555LL )
                    goto LABEL_1929;
                  v1070 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v1065 - v1068) >> 4);
                  v1071 = 0x555555555555555LL;
                  if ( v1070 >= 0x2AAAAAAAAAAAAAALL
                    || ((v1072 = 2 * v1070, v1072 >= v1069 + 1) ? (v1071 = v1072) : (v1071 = v1069 + 1), v1071) )
                  {
                    v1073 = *(_QWORD *)(v1063 - 8);
                    v1074 = 48 * v1071;
                    v1034 = *(char **)(v1073 + 4096);
                    if ( v1073 + 4096 - (__int64)v1034 >= (unsigned __int64)(48 * v1071) )
                      *(_QWORD *)(v1073 + 4096) = &v1034[v1074];
                    else
                      v1034 = (char *)malloc(v1074);
                  }
                  else
                  {
                    v1034 = 0;
                  }
                  v1035 = (size_t *)&v1034[48 * v1069];
                  v1035[1] = 0;
                  v1035[2] = 0;
                  *v1035 = 0;
                  v1036 = &v1034[48 * v1071];
                  v1321 = v1036;
                  if ( (*(_BYTE *)v1067 & 1) == 0 )
                  {
                    v1035[2] = *(_QWORD *)(v1067 + 16);
                    *(_OWORD *)v1035 = *(_OWORD *)v1067;
                    goto LABEL_1481;
                  }
                  v1037 = &v1064[6 * v1032];
                  v1038 = (size_t)v1037[1];
                  if ( v1038 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v1039 = v1037[2];
                  if ( v1038 >= 0x17 )
                  {
                    v1041 = v1037[2];
                    v1042 = malloc((v1038 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v1039 = v1041;
                    v1040 = v1042;
                    v1043 = &v1034[48 * v1069];
                    *((_QWORD *)v1043 + 1) = v1038;
                    *((_QWORD *)v1043 + 2) = v1042;
                    *v1035 = (v1038 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  }
                  else
                  {
                    *(_BYTE *)v1035 = 2 * v1038;
                    v1040 = (char *)v1035 + 1;
                    if ( !v1038 )
                      goto LABEL_1480;
                  }
                  memcpy(v1040, v1039, v1038);
LABEL_1480:
                  v1036 = &v1034[48 * v1071];
                  *((_BYTE *)v1040 + v1038) = 0;
LABEL_1481:
                  v1044 = &v1034[48 * v1069];
                  *((_QWORD *)v1044 + 3) = 0;
                  v1045 = v1044 + 24;
                  v1046 = &v1064[6 * v1032];
                  *((_QWORD *)v1045 + 1) = 0;
                  *((_QWORD *)v1045 + 2) = 0;
                  v1048 = *((_BYTE *)v1046 + 24);
                  v1047 = v1046 + 3;
                  if ( (v1048 & 1) == 0 )
                  {
                    *((_QWORD *)v1045 + 2) = v1047[2];
                    *(_OWORD *)v1045 = *(_OWORD *)v1047;
LABEL_1490:
                    v1056 = *(void ***)(v1063 - 32);
                    v1055 = *(void ***)(v1063 - 24);
                    v1057 = v1035 + 6;
                    if ( v1055 == v1056 )
                    {
                      v1059 = *(void ***)(v1063 - 32);
                    }
                    else
                    {
                      do
                      {
                        *(v1035 - 4) = (size_t)*(v1055 - 4);
                        *((_OWORD *)v1035 - 3) = *((_OWORD *)v1055 - 3);
                        v1058 = (size_t)*(v1055 - 1);
                        *(v1055 - 5) = 0;
                        *(v1055 - 4) = 0;
                        *(v1055 - 6) = 0;
                        *(v1035 - 1) = v1058;
                        *(_OWORD *)(v1035 - 3) = *(_OWORD *)(v1055 - 3);
                        *(v1055 - 3) = 0;
                        *(v1055 - 2) = 0;
                        *(v1055 - 1) = 0;
                        v1055 -= 6;
                        v1035 -= 6;
                      }
                      while ( v1056 != v1055 );
                      v1059 = *(void ***)(v1063 - 32);
                      v1056 = *(void ***)(v1063 - 24);
                    }
                    *(_QWORD *)(v1063 - 32) = v1035;
                    *(_QWORD *)(v1063 - 24) = v1057;
                    v1060 = *(_QWORD *)(v1063 - 16);
                    v1033 = v1312;
                    *(_QWORD *)(v1063 - 16) = v1036;
                    if ( v1056 != v1059 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v1056 - 3) & 1) != 0 )
                          free(*(v1056 - 1));
                        v1061 = v1056 - 6;
                        if ( (*(_BYTE *)(v1056 - 6) & 1) != 0 )
                          free(*(v1056 - 4));
                        v1056 -= 6;
                      }
                      while ( v1059 != v1061 );
                    }
                    if ( v1059 )
                    {
                      v1062 = *(_QWORD *)(v1063 - 8);
                      if ( v1062 + 4096 < (unsigned __int64)v1059 || v1062 > (unsigned __int64)v1059 )
                      {
                        free(v1059);
                      }
                      else if ( *(_QWORD *)(v1062 + 4096) == v1060 )
                      {
                        *(_QWORD *)(v1062 + 4096) = v1059;
                      }
                    }
                    goto LABEL_1534;
                  }
                  v1049 = &v1064[6 * v1032];
                  v1050 = (size_t)v1049[4];
                  if ( v1050 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v1051 = v1049[5];
                  if ( v1050 >= 0x17 )
                  {
                    v1053 = malloc((v1050 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v1054 = &v1034[48 * v1069];
                    *((_QWORD *)v1054 + 4) = v1050;
                    *((_QWORD *)v1054 + 5) = v1053;
                    *(_QWORD *)v1045 = (v1050 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    v1052 = v1053;
                  }
                  else
                  {
                    *v1045 = 2 * v1050;
                    v1052 = v1045 + 1;
                    if ( !v1050 )
                      goto LABEL_1489;
                  }
                  memcpy(v1052, v1051, v1050);
LABEL_1489:
                  v1036 = v1321;
                  *((_BYTE *)v1052 + v1050) = 0;
                  goto LABEL_1490;
                }
                v1066[1] = 0;
                v1066[2] = 0;
                *v1066 = 0;
                if ( (*(_BYTE *)v1067 & 1) == 0 )
                {
                  v1066[2] = *(_QWORD *)(v1067 + 16);
                  *(_OWORD *)v1066 = *(_OWORD *)v1067;
                  goto LABEL_1524;
                }
                v1075 = &v1064[6 * v1032];
                v1076 = (size_t)v1075[1];
                if ( v1076 >= 0xFFFFFFFFFFFFFFF0LL )
                  goto LABEL_1929;
                v1077 = v1075[2];
                if ( v1076 >= 0x17 )
                {
                  v1078 = malloc((v1076 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v1066[1] = v1076;
                  v1066[2] = (size_t)v1078;
                  *v1066 = (v1076 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                }
                else
                {
                  *(_BYTE *)v1066 = 2 * v1076;
                  v1078 = (char *)v1066 + 1;
                  if ( !v1076 )
                    goto LABEL_1523;
                }
                memcpy(v1078, v1077, v1076);
LABEL_1523:
                *((_BYTE *)v1078 + v1076) = 0;
LABEL_1524:
                v1066[3] = 0;
                v1079 = v1066 + 3;
                v1080 = &v1064[6 * v1032];
                v1066[4] = 0;
                v1066[5] = 0;
                v1082 = *((_BYTE *)v1080 + 24);
                v1081 = v1080 + 3;
                if ( (v1082 & 1) != 0 )
                {
                  v1083 = &v1064[6 * v1032];
                  v1084 = (size_t)v1083[4];
                  if ( v1084 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v1085 = v1083[5];
                  if ( v1084 >= 0x17 )
                  {
                    v1086 = malloc((v1084 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v1066[4] = v1084;
                    v1066[5] = (size_t)v1086;
                    v1066[3] = (v1084 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  }
                  else
                  {
                    *v1079 = 2 * v1084;
                    v1086 = (char *)v1066 + 25;
                    if ( !v1084 )
                      goto LABEL_1532;
                  }
                  memcpy(v1086, v1085, v1084);
LABEL_1532:
                  *((_BYTE *)v1086 + v1084) = 0;
                  goto LABEL_1533;
                }
                v1066[5] = (size_t)v1081[2];
                *(_OWORD *)v1079 = *(_OWORD *)v1081;
LABEL_1533:
                *(_QWORD *)(v1063 - 24) += 48LL;
LABEL_1534:
                if ( ++v1032 >= v1033 )
                  return v15;
              }
            }
            v840 = *(_QWORD *)(a3 + 32);
            v841 = ((__int64)v363 - v840) >> 5;
            if ( (unsigned __int64)(v841 + 1) >> 59 )
              goto LABEL_1929;
            v842 = v364 - v840;
            if ( (unsigned __int64)(v842 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v844 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v843 = v842 >> 4;
              if ( v843 >= v841 + 1 )
                v844 = v843;
              else
                v844 = v841 + 1;
              if ( !v844 )
              {
                v845 = 0;
                goto LABEL_1380;
              }
            }
            v970 = *(_QWORD *)(a3 + 56);
            v845 = *(char **)(v970 + 4096);
            if ( v970 + 4096 - (__int64)v845 >= (unsigned __int64)(32 * v844) )
              *(_QWORD *)(v970 + 4096) = &v845[32 * v844];
            else
              v845 = (char *)malloc(32 * v844);
LABEL_1380:
            v986 = &v845[32 * v841];
            *(_QWORD *)v986 = 0;
            *((_QWORD *)v986 + 1) = 0;
            *((_QWORD *)v986 + 2) = 0;
            *((_QWORD *)v986 + 3) = v367;
            v987 = v986 + 32;
            v989 = *(void ***)(a3 + 32);
            v988 = *(void ***)(a3 + 40);
            v990 = &v845[32 * v844];
            if ( v988 == v989 )
            {
              v994 = (_QWORD *)a3;
              v995 = *(void ***)(a3 + 32);
            }
            else
            {
              v991 = (char *)(v988 - 4) - (char *)v989;
              v992 = v986 - 32;
              do
              {
                *((_QWORD *)v992 + 1) = 0;
                *((_QWORD *)v992 + 2) = 0;
                *(_QWORD *)v992 = 0;
                *((_QWORD *)v992 + 3) = *(v988 - 1);
                v993 = *((_OWORD *)v988 - 2);
                v988 -= 4;
                *(_OWORD *)v992 = v993;
                *((_QWORD *)v992 + 2) = v988[2];
                v992 -= 32;
                *v988 = 0;
                v988[1] = 0;
                v988[2] = 0;
              }
              while ( v989 != v988 );
              v994 = (_QWORD *)a3;
              v986 = &v845[32 * (v841 - 1 - (v991 >> 5))];
              v995 = *(void ***)(a3 + 32);
              v989 = *(void ***)(a3 + 40);
            }
            v1023 = v994[6];
            v994[4] = v986;
            v994[5] = v987;
            v994[6] = v990;
            while ( v995 != v989 )
            {
              v989 -= 4;
              sub_42F30(v989);
            }
            if ( v995 )
            {
              v1024 = *(_QWORD *)(a3 + 56);
              if ( v1024 + 4096 < (unsigned __int64)v995 || v1024 > (unsigned __int64)v995 )
              {
                free(v995);
              }
              else if ( *(_QWORD *)(v1024 + 4096) == v1023 )
              {
                *(_QWORD *)(v1024 + 4096) = v995;
              }
            }
            goto LABEL_1468;
          case 'v':
            if ( a2 - v4 < 4 )
              goto LABEL_1293;
            v357 = v4 + 2;
            v356 = v4[2];
            if ( (unsigned int)(v356 - 49) <= 8 )
            {
              if ( v357 == a2 || v4 + 3 == a2 )
                goto LABEL_1293;
              v358 = 0;
              v359 = a2 - v4 - 3;
              while ( 1 )
              {
                v360 = &v4[v358];
                if ( (unsigned int)v4[v358 + 3] - 48 >= 0xA )
                  break;
                if ( v359 == ++v358 )
                  goto LABEL_1293;
              }
              if ( v359 == v358 || v360[3] != 95 || a2 - v4 - 4 == v358 )
                goto LABEL_1293;
              v1122 = v360 + 3 - v357;
              if ( v4[v358 + 4] == 112 )
              {
                v1334 = 0u;
                v1335 = 0;
                if ( v1122 >= 0xFFFFFFFFFFFFFFF0LL )
                  goto LABEL_1929;
                if ( v1122 >= 0x17 )
                {
                  v1123 = (char *)malloc((v1122 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  *((_QWORD *)&v1334 + 1) = v1122;
                  v1335 = v1123;
                  *(_QWORD *)&v1334 = (v1122 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                }
                else
                {
                  v1123 = (char *)&v1334 + 1;
                  LOBYTE(v1334) = 2 * v1122;
                  if ( !v1122 )
                    goto LABEL_1843;
                }
                memcpy(v1123, v4 + 2, v1122);
LABEL_1843:
                v1123[v1122] = 0;
                sub_429F4((size_t *)&v1334, 0, "pixel vector[", 0xDu);
                v1237 = v1335;
                v1238 = v1334;
                v1334 = 0u;
                v1335 = 0;
                p = v1237;
                *(_OWORD *)v1322 = v1238;
                sub_42BE4((size_t *)v1322, "]", 1u);
                v1239 = *(__int64 *)((char *)v1322 + 1);
                v1240 = v1322[1];
                v1241 = p;
                v1242 = (char)v1322[0];
                v1322[0] = 0;
                v1322[1] = 0;
                p = 0;
                *(_QWORD *)((char *)&v1330 + 7) = v1240;
                BYTE7(v1330) = HIBYTE(v1239);
                *(_QWORD *)((char *)&v1332 + 7) = 0;
                *(_QWORD *)&v1332 = 0;
                *(_QWORD *)((char *)&v1338 + 7) = *(_QWORD *)((char *)&v1330 + 7);
                *(_QWORD *)&v1338 = v1239;
                *(_QWORD *)((char *)&v1330 + 7) = 0;
                *(_QWORD *)&v1330 = 0;
                v1243 = *(_QWORD *)(a3 + 8);
                v1244 = *(_QWORD *)(a3 + 16);
                if ( v1243 >= v1244 )
                {
                  v1245 = 0x555555555555555LL;
                  v1246 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v1243 - *(_QWORD *)a3) >> 4);
                  if ( v1246 + 1 > 0x555555555555555LL )
                    abort();
                  v1247 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v1244 - *(_QWORD *)a3) >> 4);
                  if ( v1247 >= 0x2AAAAAAAAAAAAAALL
                    || ((v1248 = 2 * v1247, v1248 >= v1246 + 1) ? (v1245 = v1248) : (v1245 = v1246 + 1), v1245) )
                  {
                    v1249 = *(_QWORD *)(a3 + 24);
                    v1250 = *(char **)(v1249 + 4096);
                    if ( v1249 + 4096 - (__int64)v1250 >= (unsigned __int64)(48 * v1245) )
                      *(_QWORD *)(v1249 + 4096) = &v1250[48 * v1245];
                    else
                      v1250 = (char *)malloc(48 * v1245);
                  }
                  else
                  {
                    v1250 = 0;
                  }
                  v1259 = &v1250[48 * v1246];
                  *v1259 = v1242;
                  v1260 = &v1250[48 * v1245];
                  *((_QWORD *)v1259 + 1) = *(_QWORD *)((char *)&v1338 + 7);
                  *((_QWORD *)v1259 + 2) = v1241;
                  *(_QWORD *)(v1259 + 1) = v1338;
                  *(_QWORD *)((char *)&v1338 + 7) = 0;
                  *(_QWORD *)&v1338 = 0;
                  v1259[24] = 0;
                  *((_QWORD *)v1259 + 4) = *(_QWORD *)((char *)&v1332 + 7);
                  *((_QWORD *)v1259 + 5) = 0;
                  *(_QWORD *)(v1259 + 25) = v1332;
                  *(_QWORD *)((char *)&v1332 + 7) = 0;
                  *(_QWORD *)&v1332 = 0;
                  v1262 = *(void ***)a3;
                  v1261 = *(void ***)(a3 + 8);
                  v1263 = v1259 + 48;
                  if ( v1261 == *(void ***)a3 )
                  {
                    v1265 = *(void ***)a3;
                  }
                  else
                  {
                    do
                    {
                      *((_QWORD *)v1259 - 4) = *(v1261 - 4);
                      *((_OWORD *)v1259 - 3) = *((_OWORD *)v1261 - 3);
                      v1264 = (__int64)*(v1261 - 1);
                      *(v1261 - 5) = 0;
                      *(v1261 - 4) = 0;
                      *(v1261 - 6) = 0;
                      *((_QWORD *)v1259 - 1) = v1264;
                      *(_OWORD *)(v1259 - 24) = *(_OWORD *)(v1261 - 3);
                      *(v1261 - 3) = 0;
                      *(v1261 - 2) = 0;
                      *(v1261 - 1) = 0;
                      v1261 -= 6;
                      v1259 -= 48;
                    }
                    while ( v1262 != v1261 );
                    v1265 = *(void ***)a3;
                    v1262 = *(void ***)(a3 + 8);
                  }
                  v1266 = *(_QWORD *)(a3 + 16);
                  *(_QWORD *)a3 = v1259;
                  *(_QWORD *)(a3 + 8) = v1263;
                  *(_QWORD *)(a3 + 16) = v1260;
                  if ( v1262 != v1265 )
                  {
                    do
                    {
                      if ( (*(_BYTE *)(v1262 - 3) & 1) != 0 )
                        free(*(v1262 - 1));
                      v1267 = v1262 - 6;
                      if ( (*(_BYTE *)(v1262 - 6) & 1) != 0 )
                        free(*(v1262 - 4));
                      v1262 -= 6;
                    }
                    while ( v1265 != v1267 );
                  }
                  if ( v1265 )
                  {
                    v1268 = *(_QWORD *)(a3 + 24);
                    if ( v1268 + 4096 < (unsigned __int64)v1265 || v1268 > (unsigned __int64)v1265 )
                    {
                      free(v1265);
                    }
                    else if ( *(_QWORD *)(v1268 + 4096) == v1266 )
                    {
                      *(_QWORD *)(v1268 + 4096) = v1265;
                    }
                  }
                }
                else
                {
                  *(_BYTE *)v1243 = v1242;
                  *(_QWORD *)(v1243 + 8) = *(_QWORD *)((char *)&v1338 + 7);
                  *(_QWORD *)(v1243 + 16) = v1241;
                  *(_QWORD *)(v1243 + 1) = v1338;
                  *(_QWORD *)((char *)&v1338 + 7) = 0;
                  *(_QWORD *)&v1338 = 0;
                  *(_BYTE *)(v1243 + 24) = 0;
                  *(_QWORD *)(v1243 + 32) = *(_QWORD *)((char *)&v1332 + 7);
                  *(_QWORD *)(v1243 + 40) = 0;
                  *(_QWORD *)(v1243 + 25) = v1332;
                  *(_QWORD *)((char *)&v1332 + 7) = 0;
                  *(_QWORD *)&v1332 = 0;
                  *(_QWORD *)(a3 + 8) += 48LL;
                }
                v1269 = &v4[v358];
                if ( ((__int64)v1322[0] & 1) != 0 )
                  free(p);
                v128 = v1269 + 5;
                if ( (v1334 & 1) != 0 )
                  free(v1335);
LABEL_1891:
                if ( v128 != v4 )
                {
LABEL_1892:
                  v15 = v4;
                  v1270 = *(_QWORD *)(a3 + 8);
                  if ( *(_QWORD *)a3 == v1270 )
                    return v15;
                  *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
                  sub_42D60(v1322, v1270 - 48, (__int64 *)&v1334);
                  v1271 = *(_QWORD *)(a3 + 40);
                  v1272 = *(_QWORD *)(a3 + 48);
                  if ( v1271 < v1272 )
                  {
                    *(_QWORD *)(v1271 + 24) = v1324;
                    *(_OWORD *)v1271 = *(_OWORD *)v1322;
                    *(_QWORD *)(v1271 + 16) = p;
                    v1322[1] = 0;
                    p = 0;
                    v1322[0] = 0;
                    *(_QWORD *)(a3 + 40) += 32LL;
                    v132 = (void **)v1322[0];
                    if ( !v1322[0] )
                      return v128;
                    goto LABEL_1922;
                  }
                  v1273 = *(_QWORD *)(a3 + 32);
                  v1274 = (__int64)(v1271 - v1273) >> 5;
                  if ( (unsigned __int64)(v1274 + 1) >> 59 )
                    abort();
                  v1275 = v1272 - v1273;
                  if ( (unsigned __int64)(v1275 >> 5) > 0x3FFFFFFFFFFFFFELL )
                  {
                    v1277 = 0x7FFFFFFFFFFFFFFLL;
                  }
                  else
                  {
                    v1276 = v1275 >> 4;
                    if ( v1276 >= v1274 + 1 )
                      v1277 = v1276;
                    else
                      v1277 = v1274 + 1;
                    if ( !v1277 )
                    {
                      v1278 = 0;
                      goto LABEL_1907;
                    }
                  }
                  v1279 = *(_QWORD *)(a3 + 56);
                  v1278 = *(char **)(v1279 + 4096);
                  if ( v1279 + 4096 - (__int64)v1278 >= (unsigned __int64)(32 * v1277) )
                    *(_QWORD *)(v1279 + 4096) = &v1278[32 * v1277];
                  else
                    v1278 = (char *)malloc(32 * v1277);
LABEL_1907:
                  v1280 = &v1278[32 * v1274];
                  *((_QWORD *)v1280 + 1) = 0;
                  *((_QWORD *)v1280 + 2) = 0;
                  v1281 = v1280 + 32;
                  *((_QWORD *)v1280 + 3) = v1324;
                  *(_OWORD *)v1280 = *(_OWORD *)v1322;
                  *((_QWORD *)v1280 + 2) = p;
                  v1322[1] = 0;
                  p = 0;
                  v1322[0] = 0;
                  v1283 = *(void ***)(a3 + 32);
                  v1282 = *(void ***)(a3 + 40);
                  v1284 = &v1278[32 * v1277];
                  if ( v1282 == v1283 )
                  {
                    v1288 = *(void ***)(a3 + 32);
                  }
                  else
                  {
                    v1285 = (char *)(v1282 - 4) - (char *)v1283;
                    v1286 = v1280 - 32;
                    do
                    {
                      *((_QWORD *)v1286 + 1) = 0;
                      *((_QWORD *)v1286 + 2) = 0;
                      *(_QWORD *)v1286 = 0;
                      *((_QWORD *)v1286 + 3) = *(v1282 - 1);
                      v1287 = *((_OWORD *)v1282 - 2);
                      v1282 -= 4;
                      *(_OWORD *)v1286 = v1287;
                      *((_QWORD *)v1286 + 2) = v1282[2];
                      v1286 -= 32;
                      *v1282 = 0;
                      v1282[1] = 0;
                      v1282[2] = 0;
                    }
                    while ( v1283 != v1282 );
                    v1288 = *(void ***)(a3 + 32);
                    v1283 = *(void ***)(a3 + 40);
                    v1280 = &v1278[32 * (v1274 - 1 - (v1285 >> 5))];
                  }
                  v1289 = *(_QWORD *)(a3 + 48);
                  *(_QWORD *)(a3 + 32) = v1280;
                  *(_QWORD *)(a3 + 40) = v1281;
                  *(_QWORD *)(a3 + 48) = v1284;
                  while ( v1288 != v1283 )
                  {
                    v1283 -= 4;
                    sub_42F30(v1283);
                  }
                  if ( v1288 )
                  {
                    v1290 = *(_QWORD *)(a3 + 56);
                    if ( v1290 + 4096 < (unsigned __int64)v1288 || v1290 > (unsigned __int64)v1288 )
                    {
                      free(v1288);
                    }
                    else if ( *(_QWORD *)(v1290 + 4096) == v1289 )
                    {
                      *(_QWORD *)(v1290 + 4096) = v1288;
                      v132 = (void **)v1322[0];
                      if ( !v1322[0] )
                        return v128;
                      goto LABEL_1922;
                    }
                  }
                  v132 = (void **)v1322[0];
                  if ( v1322[0] )
                  {
LABEL_1922:
                    v1291 = (void **)v1322[1];
                    if ( v1322[1] != v132 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v1291 - 3) & 1) != 0 )
                          free(*(v1291 - 1));
                        v1292 = v1291 - 6;
                        if ( (*(_BYTE *)(v1291 - 6) & 1) != 0 )
                          free(*(v1291 - 4));
                        v1291 -= 6;
                      }
                      while ( v132 != v1292 );
                    }
LABEL_1610:
                    v1322[1] = v132;
                    if ( (__int64)v1324 + 4096 < (unsigned __int64)v132
                      || (unsigned __int64)v1324 > (unsigned __int64)v132 )
                    {
                      free(v132);
                    }
                    else if ( *(void **)(v1324 + 4096) == p )
                    {
                      *(_QWORD *)(v1324 + 4096) = v132;
                    }
                  }
                  return v128;
                }
LABEL_1293:
                v15 = sub_58698(v4, a2, a3);
                if ( v15 != v4 )
                  return v15;
                v26 = sub_401BC(v4, a2, a3, 0);
                if ( v26 == v4 )
                  return v4;
                v937 = *(_QWORD *)(a3 + 8);
                v15 = v4;
                if ( *(_QWORD *)a3 == v937 )
                  return v15;
                *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
                sub_42D60(v1322, v937 - 48, (__int64 *)&v1334);
                v938 = *(_QWORD *)(a3 + 40);
                v939 = *(_QWORD *)(a3 + 48);
                if ( v938 < v939 )
                {
                  *(_QWORD *)(v938 + 24) = v1324;
                  *(_OWORD *)v938 = *(_OWORD *)v1322;
                  *(_QWORD *)(v938 + 16) = p;
                  v1322[1] = 0;
                  p = 0;
                  v1322[0] = 0;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v176 = (void **)v1322[0];
                  if ( !v1322[0] )
                    return v26;
                  goto LABEL_1325;
                }
                v940 = *(_QWORD *)(a3 + 32);
                v941 = (__int64)(v938 - v940) >> 5;
                if ( (unsigned __int64)(v941 + 1) >> 59 )
                  abort();
                v942 = v939 - v940;
                if ( (unsigned __int64)(v942 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v944 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v943 = v942 >> 4;
                  if ( v943 >= v941 + 1 )
                    v944 = v943;
                  else
                    v944 = v941 + 1;
                  if ( !v944 )
                  {
                    v945 = 0;
LABEL_1310:
                    v947 = &v945[32 * v941];
                    *((_QWORD *)v947 + 1) = 0;
                    *((_QWORD *)v947 + 2) = 0;
                    v948 = v947 + 32;
                    *((_QWORD *)v947 + 3) = v1324;
                    *(_OWORD *)v947 = *(_OWORD *)v1322;
                    *((_QWORD *)v947 + 2) = p;
                    v1322[1] = 0;
                    p = 0;
                    v1322[0] = 0;
                    v950 = *(void ***)(a3 + 32);
                    v949 = *(void ***)(a3 + 40);
                    v951 = &v945[32 * v944];
                    if ( v949 == v950 )
                    {
                      v955 = *(void ***)(a3 + 32);
                    }
                    else
                    {
                      v952 = (char *)(v949 - 4) - (char *)v950;
                      v953 = v947 - 32;
                      do
                      {
                        *((_QWORD *)v953 + 1) = 0;
                        *((_QWORD *)v953 + 2) = 0;
                        *(_QWORD *)v953 = 0;
                        *((_QWORD *)v953 + 3) = *(v949 - 1);
                        v954 = *((_OWORD *)v949 - 2);
                        v949 -= 4;
                        *(_OWORD *)v953 = v954;
                        *((_QWORD *)v953 + 2) = v949[2];
                        v953 -= 32;
                        *v949 = 0;
                        v949[1] = 0;
                        v949[2] = 0;
                      }
                      while ( v950 != v949 );
                      v955 = *(void ***)(a3 + 32);
                      v950 = *(void ***)(a3 + 40);
                      v947 = &v945[32 * (v941 - 1 - (v952 >> 5))];
                    }
                    v956 = *(_QWORD *)(a3 + 48);
                    *(_QWORD *)(a3 + 32) = v947;
                    *(_QWORD *)(a3 + 40) = v948;
                    *(_QWORD *)(a3 + 48) = v951;
                    while ( v955 != v950 )
                    {
                      v950 -= 4;
                      sub_42F30(v950);
                    }
                    if ( v955 )
                    {
                      v957 = *(_QWORD *)(a3 + 56);
                      if ( v957 + 4096 < (unsigned __int64)v955 || v957 > (unsigned __int64)v955 )
                      {
                        free(v955);
                      }
                      else if ( *(_QWORD *)(v957 + 4096) == v956 )
                      {
                        *(_QWORD *)(v957 + 4096) = v955;
                        v176 = (void **)v1322[0];
                        if ( !v1322[0] )
                          return v26;
LABEL_1325:
                        v958 = (void **)v1322[1];
                        if ( v1322[1] != v176 )
                        {
                          do
                          {
                            if ( (*(_BYTE *)(v958 - 3) & 1) != 0 )
                              free(*(v958 - 1));
                            v959 = v958 - 6;
                            if ( (*(_BYTE *)(v958 - 6) & 1) != 0 )
                              free(*(v958 - 4));
                            v958 -= 6;
                          }
                          while ( v176 != v959 );
                        }
                        goto LABEL_1595;
                      }
                    }
                    v176 = (void **)v1322[0];
                    if ( !v1322[0] )
                      return v26;
                    goto LABEL_1325;
                  }
                }
                v946 = *(_QWORD *)(a3 + 56);
                v945 = *(char **)(v946 + 4096);
                if ( v946 + 4096 - (__int64)v945 >= (unsigned __int64)(32 * v944) )
                  *(_QWORD *)(v946 + 4096) = &v945[32 * v944];
                else
                  v945 = (char *)malloc(32 * v944);
                goto LABEL_1310;
              }
              v128 = (unsigned __int8 *)sub_38008(&v4[v358 + 4], a2, a3);
              if ( v128 - v4 - 4 == v358 || *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
                goto LABEL_1293;
              v1338 = 0u;
              v1339 = 0;
              if ( v1122 >= 0xFFFFFFFFFFFFFFF0LL )
                goto LABEL_1929;
              if ( v1122 >= 0x17 )
              {
                v1236 = (char *)malloc((v1122 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                *((_QWORD *)&v1338 + 1) = v1122;
                v1339 = (unsigned __int16 *)v1236;
                *(_QWORD *)&v1338 = (v1122 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              }
              else
              {
                v1236 = (char *)&v1338 + 1;
                LOBYTE(v1338) = 2 * v1122;
                if ( !v1122 )
                {
LABEL_1856:
                  v1236[v1122] = 0;
                  sub_429F4((size_t *)&v1338, 0, " vector[", 8u);
                  v1251 = (char *)v1339;
                  v1252 = v1338;
                  v1338 = 0u;
                  v1339 = 0;
                  v1335 = v1251;
                  v1334 = v1252;
                  sub_42BE4((size_t *)&v1334, "]", 1u);
                  v1253 = v1335;
                  v1254 = v1334;
                  v1335 = 0;
                  v1334 = 0u;
                  p = v1253;
                  *(_OWORD *)v1322 = v1254;
                  v1255 = v1254;
                  v1256 = v1253;
                  if ( (v1254 & 1) != 0 )
                    v1257 = v1253;
                  else
                    v1257 = (char *)v1322 + 1;
                  if ( (v1254 & 1) != 0 )
                    v1258 = *((_QWORD *)&v1254 + 1);
                  else
                    v1258 = (unsigned __int64)(unsigned __int8)v1254 >> 1;
                  sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v1257, v1258);
                  if ( (v1255 & 1) != 0 )
                  {
                    free(v1256);
                    if ( (v1334 & 1) == 0 )
                    {
LABEL_1864:
                      if ( (v1338 & 1) == 0 )
                        goto LABEL_1891;
LABEL_1868:
                      free(v1339);
                      if ( v128 != v4 )
                        goto LABEL_1892;
                      goto LABEL_1293;
                    }
                  }
                  else if ( (v1334 & 1) == 0 )
                  {
                    goto LABEL_1864;
                  }
                  free(v1335);
                  if ( (v1338 & 1) == 0 )
                    goto LABEL_1891;
                  goto LABEL_1868;
                }
              }
              memcpy(v1236, v4 + 2, v1122);
              goto LABEL_1856;
            }
            v1322[0] = 0;
            v1322[1] = 0;
            p = 0;
            if ( v356 == 95 || (v869 = sub_47B84(v4 + 2, a2, a3), v869 == v357) )
            {
              v880 = 0;
              v879 = 0;
              if ( v357 == a2 )
                goto LABEL_1290;
            }
            else
            {
              v870 = *(_QWORD *)(a3 + 8);
              if ( *(_QWORD *)a3 == v870 )
                goto LABEL_1293;
              v871 = *(unsigned __int8 *)(v870 - 24);
              v872 = *(_QWORD *)(v870 - 16);
              v873 = *(const void **)(v870 - 8);
              v874 = (size_t *)(v870 - 48);
              v875 = (const void *)(v870 - 23);
              if ( (v871 & 1) != 0 )
                v876 = v873;
              else
                v876 = v875;
              if ( (v871 & 1) != 0 )
                v877 = v872;
              else
                v877 = v871 >> 1;
              v878 = sub_42BE4(v874, v876, v877);
              v879 = *(unsigned __int8 *)v878;
              *(_QWORD *)((char *)&v1334 + 7) = v878[1];
              *(_QWORD *)&v1334 = *(size_t *)((char *)v878 + 1);
              *v878 = 0;
              v878[1] = 0;
              v880 = (char *)v878[2];
              v878[2] = 0;
              v881 = *(_QWORD *)(a3 + 8);
              v882 = *(_BYTE *)(v881 - 24);
              v883 = (_BYTE *)(v881 - 48);
              LOBYTE(v1322[0]) = v879;
              *(void **)((char *)v1322 + 1) = (void *)v1334;
              v1322[1] = *(void **)((char *)&v1334 + 7);
              p = v880;
              if ( (v882 & 1) != 0 )
                free(*(void **)(v881 - 8));
              if ( (*v883 & 1) != 0 )
                free(*(void **)(v881 - 32));
              v357 = v869;
              *(_QWORD *)(a3 + 8) = v883;
              if ( v869 == a2 )
              {
LABEL_1290:
                v936 = 0;
                v128 = v4;
                if ( (v879 & 1) == 0 )
                  goto LABEL_1292;
                goto LABEL_1291;
              }
            }
            if ( *v357 != 95 )
              goto LABEL_1290;
            v933 = v357 + 1;
            if ( v933 == a2 )
              goto LABEL_1290;
            v128 = (unsigned __int8 *)sub_38008(v933, a2, a3);
            if ( v128 == v933 )
              goto LABEL_1290;
            if ( *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            {
              v936 = 1;
              v128 = v4;
              if ( (v879 & 1) == 0 )
                goto LABEL_1292;
            }
            else
            {
              v1338 = 0u;
              if ( (v879 & 1) != 0 )
                v934 = v1322[1];
              else
                v934 = (void *)(v879 >> 1);
              v1339 = 0;
              if ( (unsigned __int64)v934 + 8 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              if ( (unsigned __int64)v934 + 8 > 0x16 )
              {
                v935 = (char *)malloc(((unsigned __int64)v934 + 24) & 0xFFFFFFFFFFFFFFF0LL);
                *(_QWORD *)&v1338 = ((unsigned __int64)v934 + 24) & 0xFFFFFFFFFFFFFFF0LL | 1;
                *((_QWORD *)&v1338 + 1) = 8;
                v1339 = (unsigned __int16 *)v935;
              }
              else
              {
                LOBYTE(v1338) = 16;
                v935 = (char *)&v1338 + 1;
              }
              *(_QWORD *)v935 = 0x5B726F7463657620LL;
              if ( (v879 & 1) != 0 )
                v1229 = v880;
              else
                v1229 = (char *)v1322 + 1;
              v935[8] = 0;
              sub_42BE4((size_t *)&v1338, v1229, (size_t)v934);
              sub_42BE4((size_t *)&v1338, "]", 1u);
              v1230 = (char *)v1339;
              v1231 = v1338;
              v1339 = 0;
              v1338 = 0u;
              v1335 = v1230;
              v1334 = v1231;
              v1232 = v1231;
              v1233 = v1230;
              if ( (v1231 & 1) != 0 )
                v1234 = v1335;
              else
                v1234 = (char *)&v1334 + 1;
              if ( (v1231 & 1) != 0 )
                v1235 = *((_QWORD *)&v1334 + 1);
              else
                v1235 = (unsigned __int64)(unsigned __int8)v1231 >> 1;
              sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v1234, v1235);
              if ( (v1232 & 1) != 0 )
                free(v1233);
              if ( (v1338 & 1) != 0 )
                free(v1339);
              v936 = 0;
              if ( (v879 & 1) == 0 )
              {
LABEL_1292:
                if ( v936 )
                  goto LABEL_1293;
                goto LABEL_1891;
              }
            }
LABEL_1291:
            free(v880);
            goto LABEL_1292;
          default:
            goto LABEL_1293;
        }
      case 'F':
        v195 = v4 + 1;
        if ( v4 + 1 == a2 )
          return v4;
        if ( *v195 == 89 )
        {
          v195 = v4 + 2;
          if ( v4 + 2 == a2 )
            return v4;
        }
        v196 = (_QWORD *)a3;
        v197 = (unsigned __int8 *)sub_38008(v195, a2, a3);
        if ( v197 == v195 )
          return v4;
        v1322[1] = 0;
        p = 0;
        v1322[0] = &stru_2800 + 2;
        if ( v197 == a2 )
        {
          v198 = (__int64 *)(a3 + 8);
          goto LABEL_437;
        }
        v198 = (__int64 *)(a3 + 8);
        v1310 = 0;
        while ( 2 )
        {
          v199 = v197;
LABEL_235:
          v200 = *v199;
          if ( v200 > 0x51 )
          {
            if ( v200 == 82 )
            {
              v197 = v199 + 1;
              if ( v199 + 1 != a2 && *v197 == 69 )
              {
                v222 = 1;
LABEL_280:
                v1310 = v222;
                if ( v197 == a2 )
                {
LABEL_281:
                  v196 = (_QWORD *)a3;
LABEL_437:
                  v368 = v196[1];
                  if ( *v196 != v368 )
                  {
                    v369 = (_BYTE *)(v368 - 48);
                    if ( (*(_BYTE *)(v368 - 24) & 1) != 0 )
                      free(*(void **)(v368 - 8));
                    if ( (*v369 & 1) != 0 )
                      free(*(void **)(v368 - 32));
                    *v198 = (__int64)v369;
                  }
LABEL_443:
                  v205 = 1;
LABEL_444:
                  v128 = v4;
                  if ( ((__int64)v1322[0] & 1) == 0 )
                    goto LABEL_446;
LABEL_445:
                  free(p);
                  goto LABEL_446;
                }
                continue;
              }
            }
            else if ( v200 == 118 )
            {
              v201 = v199 + 1;
LABEL_278:
              v199 = v201;
              if ( v201 == a2 )
                goto LABEL_281;
              goto LABEL_235;
            }
            goto LABEL_247;
          }
          break;
        }
        if ( v200 == 79 )
        {
          v197 = v199 + 1;
          if ( v199 + 1 != a2 && *v197 == 69 )
          {
            v222 = 2;
            goto LABEL_280;
          }
          goto LABEL_247;
        }
        if ( v200 != 69 )
        {
LABEL_247:
          v202 = *(void ***)a3;
          v203 = *(_QWORD *)(a3 + 8);
          v204 = sub_38008(v199, a2, a3);
          v201 = (unsigned __int8 *)v204;
          v205 = 1;
          if ( (unsigned __int8 *)v204 == v199 || (unsigned __int8 *)v204 == a2 )
          {
            v196 = (_QWORD *)a3;
            goto LABEL_444;
          }
          v206 = 0xAAAAAAAAAAAAAAABLL * ((v203 - (__int64)v202) >> 4);
          v207 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 4);
          if ( v206 < v207 )
          {
            v1316 = v198;
            v208 = 48 * v206;
            v209 = v206;
            do
            {
              if ( ((__int64)v1322[0] & 1) != 0 )
                v210 = v1322[1];
              else
                v210 = (void *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
              if ( (unsigned __int64)v210 >= 2 )
                sub_42BE4((size_t *)v1322, ", ", 2u);
              v211 = *(_QWORD *)a3 + v208;
              v212 = *(unsigned __int8 *)(v211 + 24);
              if ( (v212 & 1) != 0 )
                v213 = *(const void **)(v211 + 40);
              else
                v213 = (const void *)(v211 + 25);
              if ( (v212 & 1) != 0 )
                v214 = *(_QWORD *)(v211 + 32);
              else
                v214 = v212 >> 1;
              v215 = sub_42BE4((size_t *)v211, v213, v214);
              v1335 = (char *)v215[2];
              v1334 = *(_OWORD *)v215;
              v215[1] = 0;
              v215[2] = 0;
              *v215 = 0;
              v216 = v1334;
              v217 = v1335;
              if ( (v1334 & 1) != 0 )
                v218 = v1335;
              else
                v218 = (char *)&v1334 + 1;
              if ( (v1334 & 1) != 0 )
                v219 = *((_QWORD *)&v1334 + 1);
              else
                v219 = (unsigned __int64)(unsigned __int8)v1334 >> 1;
              sub_42BE4((size_t *)v1322, v218, v219);
              if ( (v216 & 1) != 0 )
                free(v217);
              ++v209;
              v208 += 48;
            }
            while ( v209 < v207 );
            v198 = v1316;
            if ( v206 < v207 )
            {
              v220 = v207 - v206;
              v221 = *v1316 - 48;
              do
              {
                if ( (*(_BYTE *)(v221 + 24) & 1) != 0 )
                  free(*(void **)(v221 + 40));
                if ( (*(_BYTE *)v221 & 1) != 0 )
                  free(*(void **)(v221 + 16));
                *v1316 = v221;
                --v220;
                v221 -= 48;
              }
              while ( v220 );
            }
          }
          goto LABEL_278;
        }
        sub_42BE4((size_t *)v1322, ")", 1u);
        v196 = (_QWORD *)a3;
        v976 = v1310 & 3;
        if ( v976 == 1 )
        {
          sub_42BE4((size_t *)v1322, " &", 2u);
        }
        else if ( v976 == 2 )
        {
          sub_42BE4((size_t *)v1322, " &&", 3u);
        }
        v1129 = *(_QWORD *)(a3 + 8);
        if ( *(_QWORD *)a3 == v1129 )
          goto LABEL_443;
        sub_42BE4((size_t *)(v1129 - 48), " ", 1u);
        if ( ((__int64)v1322[0] & 1) != 0 )
          v1130 = v1322[1];
        else
          v1130 = (void *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
        if ( ((__int64)v1322[0] & 1) != 0 )
          v1131 = (char *)p;
        else
          v1131 = (char *)v1322 + 1;
        sub_429F4((size_t *)(*v198 - 24), 0, v1131, (size_t)v1130);
        v205 = 0;
        v128 = v199 + 1;
        if ( ((__int64)v1322[0] & 1) != 0 )
          goto LABEL_445;
LABEL_446:
        if ( v205 || v128 == v4 )
          return v4;
        v370 = v196[1];
        v15 = v4;
        if ( *v196 == v370 )
          return v15;
        *(_QWORD *)&v1334 = v196[3];
        sub_42D60(v1322, v370 - 48, (__int64 *)&v1334);
        v371 = v196[5];
        v372 = v196[6];
        if ( v371 < v372 )
        {
          *(_QWORD *)(v371 + 24) = v1324;
          *(_OWORD *)v371 = *(_OWORD *)v1322;
          *(_QWORD *)(v371 + 16) = p;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          v196[5] += 32LL;
          v132 = (void **)v1322[0];
          if ( !v1322[0] )
            return v128;
          goto LABEL_1604;
        }
        v905 = v196[4];
        v906 = (__int64)(v371 - v905) >> 5;
        if ( (unsigned __int64)(v906 + 1) >> 59 )
          abort();
        v907 = v372 - v905;
        if ( (unsigned __int64)(v907 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v909 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v908 = v907 >> 4;
          if ( v908 >= v906 + 1 )
            v909 = v908;
          else
            v909 = v906 + 1;
          if ( !v909 )
          {
            v910 = 0;
            goto LABEL_1565;
          }
        }
        v1031 = *(_QWORD *)(a3 + 56);
        v910 = *(char **)(v1031 + 4096);
        if ( v1031 + 4096 - (__int64)v910 >= (unsigned __int64)(32 * v909) )
          *(_QWORD *)(v1031 + 4096) = &v910[32 * v909];
        else
          v910 = (char *)malloc(32 * v909);
LABEL_1565:
        v1104 = &v910[32 * v906];
        *((_QWORD *)v1104 + 1) = 0;
        *((_QWORD *)v1104 + 2) = 0;
        v1105 = v1104 + 32;
        *((_QWORD *)v1104 + 3) = v1324;
        *(_OWORD *)v1104 = *(_OWORD *)v1322;
        *((_QWORD *)v1104 + 2) = p;
        v1322[1] = 0;
        p = 0;
        v1322[0] = 0;
        v1107 = *(void ***)(a3 + 32);
        v1106 = *(void ***)(a3 + 40);
        v1108 = &v910[32 * v909];
        if ( v1106 == v1107 )
        {
          v1112 = *(void ***)(a3 + 32);
        }
        else
        {
          v1109 = (char *)(v1106 - 4) - (char *)v1107;
          v1110 = v1104 - 32;
          do
          {
            *((_QWORD *)v1110 + 1) = 0;
            *((_QWORD *)v1110 + 2) = 0;
            *(_QWORD *)v1110 = 0;
            *((_QWORD *)v1110 + 3) = *(v1106 - 1);
            v1111 = *((_OWORD *)v1106 - 2);
            v1106 -= 4;
            *(_OWORD *)v1110 = v1111;
            *((_QWORD *)v1110 + 2) = v1106[2];
            v1110 -= 32;
            *v1106 = 0;
            v1106[1] = 0;
            v1106[2] = 0;
          }
          while ( v1107 != v1106 );
          v1112 = *(void ***)(a3 + 32);
          v1107 = *(void ***)(a3 + 40);
          v1104 = &v910[32 * (v906 - 1 - (v1109 >> 5))];
        }
        v1115 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v1104;
        *(_QWORD *)(a3 + 40) = v1105;
        *(_QWORD *)(a3 + 48) = v1108;
        while ( v1112 != v1107 )
        {
          v1107 -= 4;
          sub_42F30(v1107);
        }
        if ( v1112 )
        {
          v1116 = *(_QWORD *)(a3 + 56);
          if ( v1116 + 4096 < (unsigned __int64)v1112 || v1116 > (unsigned __int64)v1112 )
          {
            free(v1112);
          }
          else if ( *(_QWORD *)(v1116 + 4096) == v1115 )
          {
            *(_QWORD *)(v1116 + 4096) = v1112;
            v132 = (void **)v1322[0];
            if ( !v1322[0] )
              return v128;
            goto LABEL_1604;
          }
        }
        v132 = (void **)v1322[0];
        if ( !v1322[0] )
          return v128;
LABEL_1604:
        v1120 = (void **)v1322[1];
        if ( v1322[1] != v132 )
        {
          do
          {
            if ( (*(_BYTE *)(v1120 - 3) & 1) != 0 )
              free(*(v1120 - 1));
            v1121 = v1120 - 6;
            if ( (*(_BYTE *)(v1120 - 6) & 1) != 0 )
              free(*(v1120 - 4));
            v1120 -= 6;
          }
          while ( v132 != v1121 );
        }
        goto LABEL_1610;
      case 'G':
        v26 = (unsigned __int8 *)sub_38008(v4 + 1, a2, a3);
        if ( v26 == v4 + 1 )
          return v4;
        v223 = *(_QWORD *)(a3 + 8);
        v15 = v4;
        if ( *(_QWORD *)a3 == v223 )
          return v15;
        sub_42BE4((size_t *)(v223 - 48), " imaginary", 0xAu);
        v224 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
        sub_42D60(v1322, v224, (__int64 *)&v1334);
        v225 = *(_QWORD *)(a3 + 40);
        v226 = *(_QWORD *)(a3 + 48);
        if ( v225 < v226 )
        {
          *(_QWORD *)(v225 + 24) = v1324;
          *(_OWORD *)v225 = *(_OWORD *)v1322;
          *(_QWORD *)(v225 + 16) = p;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          *(_QWORD *)(a3 + 40) += 32LL;
          v176 = (void **)v1322[0];
          if ( !v1322[0] )
            return v26;
          goto LABEL_1094;
        }
        v284 = *(_QWORD *)(a3 + 32);
        v285 = (__int64)(v225 - v284) >> 5;
        if ( (unsigned __int64)(v285 + 1) >> 59 )
          abort();
        v286 = v226 - v284;
        if ( (unsigned __int64)(v286 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v288 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v287 = v286 >> 4;
          if ( v287 >= v285 + 1 )
            v288 = v287;
          else
            v288 = v285 + 1;
          if ( !v288 )
          {
            v289 = 0;
            goto LABEL_971;
          }
        }
        v627 = *(_QWORD *)(a3 + 56);
        v289 = *(char **)(v627 + 4096);
        if ( v627 + 4096 - (__int64)v289 >= (unsigned __int64)(32 * v288) )
          *(_QWORD *)(v627 + 4096) = &v289[32 * v288];
        else
          v289 = (char *)malloc(32 * v288);
LABEL_971:
        v717 = &v289[32 * v285];
        *((_QWORD *)v717 + 1) = 0;
        *((_QWORD *)v717 + 2) = 0;
        v718 = v717 + 32;
        *((_QWORD *)v717 + 3) = v1324;
        *(_OWORD *)v717 = *(_OWORD *)v1322;
        *((_QWORD *)v717 + 2) = p;
        v1322[1] = 0;
        p = 0;
        v1322[0] = 0;
        v720 = *(void ***)(a3 + 32);
        v719 = *(void ***)(a3 + 40);
        v721 = &v289[32 * v288];
        if ( v719 == v720 )
        {
          v725 = *(void ***)(a3 + 32);
        }
        else
        {
          v722 = (char *)(v719 - 4) - (char *)v720;
          v723 = v717 - 32;
          do
          {
            *((_QWORD *)v723 + 1) = 0;
            *((_QWORD *)v723 + 2) = 0;
            *(_QWORD *)v723 = 0;
            *((_QWORD *)v723 + 3) = *(v719 - 1);
            v724 = *((_OWORD *)v719 - 2);
            v719 -= 4;
            *(_OWORD *)v723 = v724;
            *((_QWORD *)v723 + 2) = v719[2];
            v723 -= 32;
            *v719 = 0;
            v719[1] = 0;
            v719[2] = 0;
          }
          while ( v720 != v719 );
          v725 = *(void ***)(a3 + 32);
          v720 = *(void ***)(a3 + 40);
          v717 = &v289[32 * (v285 - 1 - (v722 >> 5))];
        }
        v728 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v717;
        *(_QWORD *)(a3 + 40) = v718;
        *(_QWORD *)(a3 + 48) = v721;
        while ( v725 != v720 )
        {
          v720 -= 4;
          sub_42F30(v720);
        }
        if ( !v725 )
          goto LABEL_1093;
        v729 = *(_QWORD *)(a3 + 56);
        if ( v729 + 4096 < (unsigned __int64)v725 || v729 > (unsigned __int64)v725 )
        {
          free(v725);
        }
        else if ( *(_QWORD *)(v729 + 4096) == v728 )
        {
          *(_QWORD *)(v729 + 4096) = v725;
          v176 = (void **)v1322[0];
          if ( !v1322[0] )
            return v26;
          goto LABEL_1094;
        }
LABEL_1093:
        v176 = (void **)v1322[0];
        if ( !v1322[0] )
          return v26;
LABEL_1094:
        v807 = (void **)v1322[1];
        if ( v1322[1] != v176 )
        {
          do
          {
            if ( (*(_BYTE *)(v807 - 3) & 1) != 0 )
              free(*(v807 - 1));
            v808 = v807 - 6;
            if ( (*(_BYTE *)(v807 - 6) & 1) != 0 )
              free(*(v807 - 4));
            v807 -= 6;
          }
          while ( v176 != v808 );
        }
        goto LABEL_1595;
      case 'M':
        v133 = sub_38008(v4 + 1, a2, a3);
        v134 = v133;
        if ( (unsigned __int8 *)v133 == v4 + 1 )
          return v4;
        v135 = sub_38008(v133, a2, a3);
        if ( v135 == v134 )
          return v4;
        v136 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v136 - *(_QWORD *)a3) >> 4) < 2 )
          return v4;
        p = *(void **)(v136 - 32);
        *(_OWORD *)v1322 = *(_OWORD *)(v136 - 48);
        v137 = *(void **)(v136 - 8);
        *(_QWORD *)(v136 - 40) = 0;
        *(_QWORD *)(v136 - 32) = 0;
        *(_QWORD *)(v136 - 48) = 0;
        v1325 = v137;
        v1324 = *(_OWORD *)(v136 - 24);
        *(_QWORD *)(v136 - 16) = 0;
        *(_QWORD *)(v136 - 8) = 0;
        *(_QWORD *)(v136 - 24) = 0;
        v138 = *(_QWORD *)(a3 + 8);
        v139 = (_BYTE *)(v138 - 48);
        if ( (*(_BYTE *)(v138 - 24) & 1) != 0 )
          free(*(void **)(v138 - 8));
        if ( (*v139 & 1) != 0 )
          free(*(void **)(v138 - 32));
        *(_QWORD *)(a3 + 8) = v139;
        v1335 = *(char **)(v138 - 80);
        v1334 = *(_OWORD *)(v138 - 96);
        v140 = *(char **)(v138 - 56);
        *(_QWORD *)(v138 - 88) = 0;
        *(_QWORD *)(v138 - 80) = 0;
        *(_QWORD *)(v138 - 96) = 0;
        v1337 = v140;
        v1336 = *(_OWORD *)(v138 - 72);
        *(_QWORD *)(v138 - 64) = 0;
        *(_QWORD *)(v138 - 56) = 0;
        *(_QWORD *)(v138 - 72) = 0;
        if ( (v1324 & 1) != 0 )
          v141 = *((_QWORD *)&v1324 + 1);
        else
          v141 = (unsigned __int64)(unsigned __int8)v1324 >> 1;
        if ( !v141 )
          goto LABEL_391;
        v142 = v1325;
        if ( (v1324 & 1) == 0 )
          v142 = (char *)&v1324 + 1;
        if ( *v142 != 40 )
        {
LABEL_391:
          sub_42BE4((size_t *)v1322, " ", 1u);
          v303 = *(_OWORD *)v1322;
          v1333 = (char *)p;
          if ( (v1336 & 1) != 0 )
            v304 = v1337;
          else
            v304 = (char *)&v1336 + 1;
          v1322[0] = 0;
          v1322[1] = 0;
          p = 0;
          v1332 = v303;
          if ( (v1336 & 1) != 0 )
            v305 = *((_QWORD *)&v1336 + 1);
          else
            v305 = (unsigned __int64)(unsigned __int8)v1336 >> 1;
          sub_42BE4((size_t *)&v1334, v304, v305);
          v306 = v1334;
          v307 = v1335;
          v1335 = 0;
          v1334 = 0u;
          v1330 = v306;
          v308 = v306;
          v1331 = v307;
          v309 = v307;
          if ( (v306 & 1) != 0 )
            v310 = v307;
          else
            v310 = (char *)&v1330 + 1;
          if ( (v306 & 1) != 0 )
            v311 = *((_QWORD *)&v306 + 1);
          else
            v311 = (unsigned __int64)(unsigned __int8)v306 >> 1;
          sub_42BE4((size_t *)&v1332, v310, v311);
          v312 = (unsigned __int16 *)v1333;
          v313 = v1332;
          v1332 = 0u;
          v1333 = 0;
          v1339 = v312;
          v1338 = v313;
          sub_42BE4((size_t *)&v1338, "::*", 3u);
          v314 = *(_QWORD *)((char *)&v1338 + 1);
          v315 = *((_QWORD *)&v1338 + 1);
          v316 = v1339;
          v317 = v1338;
          v1338 = 0u;
          v1339 = 0;
          *(_QWORD *)((char *)&v1327 + 7) = v315;
          *(_QWORD *)&v1327 = v314;
          v318 = *(_QWORD *)(a3 + 8);
          if ( (*(_BYTE *)(v318 - 48) & 1) != 0 )
          {
            v319 = (_BYTE **)(v318 - 32);
            **(_BYTE **)(v318 - 32) = 0;
            v730 = *(unsigned __int8 *)(v318 - 48);
            *(_QWORD *)(v318 - 40) = 0;
            if ( (v730 & 1) != 0 )
            {
              v848 = *v319;
              *(_BYTE *)(v318 - 47) = **v319;
              free(v848);
              *(_BYTE *)(v318 - 48) = 0;
            }
            else if ( (unsigned int)v730 >= 0x2E )
            {
              v1320 = (void *)(v730 >> 1);
              v1305 = (unsigned __int8)((v730 >> 1) + 16) & 0xF0;
              v731 = malloc(v1305);
              if ( v1305 - 1 > 0x16 || v731 )
              {
                v732 = v731;
                memcpy(v731, (const void *)(v318 - 47), (size_t)v1320 + 1);
                *(_QWORD *)(v318 - 48) = v1305 | 1;
                *(_QWORD *)(v318 - 40) = v1320;
                *(_QWORD *)(v318 - 32) = v732;
              }
            }
          }
          else
          {
            *(_WORD *)(v318 - 48) = 0;
            v319 = (_BYTE **)(v318 - 32);
          }
          *(_BYTE *)(v318 - 48) = v317;
          *(_QWORD *)(v318 - 47) = v1327;
          *(_QWORD *)(v318 - 40) = *(_QWORD *)((char *)&v1327 + 7);
          *v319 = v316;
          *(_QWORD *)((char *)&v1327 + 7) = 0;
          *(_QWORD *)&v1327 = 0;
          if ( (v1338 & 1) != 0 )
            free(v1339);
          v849 = (_QWORD *)a3;
          v850 = (unsigned __int8 *)v135;
          if ( (v308 & 1) != 0 )
            free(v309);
          if ( (v1332 & 1) != 0 )
            free(v1333);
          v851 = *(_QWORD *)(a3 + 8);
          v852 = (_WORD *)(v851 - 24);
          if ( (*(_BYTE *)(v851 - 24) & 1) != 0 )
          {
            **(_BYTE **)(v851 - 8) = 0;
            v853 = *(unsigned __int8 *)(v851 - 24);
            *(_QWORD *)(v851 - 16) = 0;
            if ( (v853 & 1) != 0 )
            {
              v858 = *(_BYTE **)(v851 - 8);
              *(_BYTE *)(v851 - 23) = *v858;
              free(v858);
              *(_BYTE *)(v851 - 24) = 0;
            }
            else if ( (unsigned int)v853 >= 0x2E )
            {
              v854 = v853 >> 1;
              v855 = (unsigned __int8)((v853 >> 1) + 16) & 0xF0;
              v856 = malloc(v855);
              v857 = v856;
              if ( v855 - 1 > 0x16 || v856 )
              {
                memcpy(v856, (const void *)(v851 - 23), v854 + 1);
                *(_QWORD *)(v851 - 24) = v855 | 1;
                *(_QWORD *)(v851 - 16) = v854;
                *(_QWORD *)(v851 - 8) = v857;
              }
            }
          }
          else
          {
            *v852 = 0;
          }
          *(_QWORD *)(v851 - 8) = v1325;
          *(_OWORD *)v852 = v1324;
          v1324 = 0u;
          v1325 = 0;
          if ( (v1336 & 1) != 0 )
            goto LABEL_1170;
          goto LABEL_1171;
        }
        sub_42BE4((size_t *)v1322, "(", 1u);
        v143 = *(_OWORD *)v1322;
        v1333 = (char *)p;
        if ( (v1336 & 1) != 0 )
          v144 = v1337;
        else
          v144 = (char *)&v1336 + 1;
        v1322[0] = 0;
        v1322[1] = 0;
        p = 0;
        v1332 = v143;
        if ( (v1336 & 1) != 0 )
          v145 = *((_QWORD *)&v1336 + 1);
        else
          v145 = (unsigned __int64)(unsigned __int8)v1336 >> 1;
        sub_42BE4((size_t *)&v1334, v144, v145);
        v146 = v1334;
        v147 = v1335;
        v1335 = 0;
        v1334 = 0u;
        v1330 = v146;
        v148 = v146;
        v1331 = v147;
        if ( (v146 & 1) != 0 )
          v149 = v147;
        else
          v149 = (char *)&v1330 + 1;
        v1308 = v147;
        if ( (v146 & 1) != 0 )
          v150 = *((_QWORD *)&v146 + 1);
        else
          v150 = (unsigned __int64)(unsigned __int8)v146 >> 1;
        sub_42BE4((size_t *)&v1332, v149, v150);
        v151 = v1332;
        v1315 = (unsigned __int8 *)v135;
        v1332 = 0u;
        v1339 = (unsigned __int16 *)v1333;
        v1338 = v151;
        v1333 = 0;
        sub_42BE4((size_t *)&v1338, "::*", 3u);
        v152 = *(_QWORD *)((char *)&v1338 + 1);
        v153 = *((_QWORD *)&v1338 + 1);
        v154 = v1339;
        v155 = v1338;
        v1338 = 0u;
        v1339 = 0;
        *(_QWORD *)((char *)&v1327 + 7) = v153;
        *(_QWORD *)&v1327 = v152;
        v156 = *(_QWORD *)(a3 + 8);
        if ( (*(_BYTE *)(v156 - 48) & 1) != 0 )
        {
          v157 = (_BYTE **)(v156 - 32);
          **(_BYTE **)(v156 - 32) = 0;
          v894 = *(unsigned __int8 *)(v156 - 48);
          *(_QWORD *)(v156 - 40) = 0;
          if ( (v894 & 1) != 0 )
          {
            v1009 = *v157;
            *(_BYTE *)(v156 - 47) = **v157;
            free(v1009);
            *(_BYTE *)(v156 - 48) = 0;
          }
          else if ( (unsigned int)v894 >= 0x2E )
          {
            v1306 = v894 >> 1;
            v895 = (unsigned __int8)((v894 >> 1) + 16) & 0xF0;
            v896 = v895 - 1;
            v1299 = v895;
            v897 = malloc(v895);
            if ( v896 > 0x16 || v897 )
            {
              v898 = v897;
              memcpy(v897, (const void *)(v156 - 47), v1306 + 1);
              *(_QWORD *)(v156 - 32) = v898;
              *(_QWORD *)(v156 - 48) = v1299 | 1;
              *(_QWORD *)(v156 - 40) = v1306;
            }
          }
        }
        else
        {
          *(_WORD *)(v156 - 48) = 0;
          v157 = (_BYTE **)(v156 - 32);
        }
        *(_BYTE *)(v156 - 48) = v155;
        *(_QWORD *)(v156 - 47) = v1327;
        *(_QWORD *)(v156 - 40) = *(_QWORD *)((char *)&v1327 + 7);
        *v157 = v154;
        *(_QWORD *)((char *)&v1327 + 7) = 0;
        *(_QWORD *)&v1327 = 0;
        if ( (v1338 & 1) != 0 )
        {
          free(v1339);
          v1010 = a3;
          if ( (v148 & 1) == 0 )
          {
LABEL_1410:
            if ( (v1332 & 1) == 0 )
              goto LABEL_1412;
            goto LABEL_1411;
          }
        }
        else
        {
          v1010 = a3;
          if ( (v148 & 1) == 0 )
            goto LABEL_1410;
        }
        free(v1308);
        if ( (v1332 & 1) == 0 )
        {
LABEL_1412:
          sub_429F4((size_t *)&v1324, 0, ")", 1u);
          v1011 = *(_QWORD *)((char *)&v1324 + 1);
          v1012 = *((_QWORD *)&v1324 + 1);
          v1013 = v1325;
          v1014 = v1324;
          v1324 = 0u;
          v1325 = 0;
          *(_QWORD *)((char *)&v1338 + 7) = v1012;
          *(_QWORD *)&v1338 = v1011;
          v1015 = *(_QWORD *)(v1010 + 8);
          if ( (*(_BYTE *)(v1015 - 24) & 1) != 0 )
          {
            v1016 = (_BYTE **)(v1015 - 8);
            **(_BYTE **)(v1015 - 8) = 0;
            v1017 = *(unsigned __int8 *)(v1015 - 24);
            *(_QWORD *)(v1015 - 16) = 0;
            if ( (v1017 & 1) != 0 )
            {
              v1022 = *v1016;
              *(_BYTE *)(v1015 - 23) = **v1016;
              free(v1022);
              *(_BYTE *)(v1015 - 24) = 0;
            }
            else if ( (unsigned int)v1017 >= 0x2E )
            {
              v1018 = v1017 >> 1;
              v1019 = (unsigned __int8)((v1017 >> 1) + 16) & 0xF0;
              v1020 = malloc(v1019);
              v1021 = v1020;
              if ( v1019 - 1 > 0x16 || v1020 )
              {
                memcpy(v1020, (const void *)(v1015 - 23), v1018 + 1);
                *(_QWORD *)(v1015 - 24) = v1019 | 1;
                *(_QWORD *)(v1015 - 16) = v1018;
                *(_QWORD *)(v1015 - 8) = v1021;
              }
            }
          }
          else
          {
            *(_WORD *)(v1015 - 24) = 0;
            v1016 = (_BYTE **)(v1015 - 8);
          }
          *(_BYTE *)(v1015 - 24) = v1014;
          v849 = (_QWORD *)a3;
          *(_QWORD *)(v1015 - 16) = *(_QWORD *)((char *)&v1338 + 7);
          *(_QWORD *)(v1015 - 23) = v1338;
          *v1016 = v1013;
          v850 = v1315;
          if ( (v1336 & 1) != 0 )
LABEL_1170:
            free(v1337);
LABEL_1171:
          if ( (v1334 & 1) != 0 )
          {
            free(v1335);
            if ( (v1324 & 1) == 0 )
            {
LABEL_1173:
              if ( ((__int64)v1322[0] & 1) == 0 )
                goto LABEL_1174;
              goto LABEL_1178;
            }
          }
          else if ( (v1324 & 1) == 0 )
          {
            goto LABEL_1173;
          }
          free(v1325);
          if ( ((__int64)v1322[0] & 1) == 0 )
          {
LABEL_1174:
            if ( v850 == v4 )
              return v4;
            goto LABEL_1179;
          }
LABEL_1178:
          free(p);
          if ( v850 == v4 )
            return v4;
LABEL_1179:
          v859 = v849[1];
          v15 = v4;
          if ( *v849 == v859 )
            return v15;
          *(_QWORD *)&v1334 = v849[3];
          sub_42D60(v1322, v859 - 48, (__int64 *)&v1334);
          v860 = v849[5];
          v861 = v849[6];
          if ( v860 < v861 )
          {
            *(_QWORD *)(v860 + 24) = v1324;
            *(_OWORD *)v860 = *(_OWORD *)v1322;
            *(_QWORD *)(v860 + 16) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            v849[5] += 32LL;
            v862 = (void **)v1322[0];
            if ( !v1322[0] )
              return v850;
            goto LABEL_1538;
          }
          v863 = v849[4];
          v864 = (__int64)(v860 - v863) >> 5;
          if ( (unsigned __int64)(v864 + 1) >> 59 )
            abort();
          v865 = v861 - v863;
          if ( (unsigned __int64)(v865 >> 5) > 0x3FFFFFFFFFFFFFELL )
          {
            v867 = 0x7FFFFFFFFFFFFFFLL;
          }
          else
          {
            v866 = v865 >> 4;
            if ( v866 >= v864 + 1 )
              v867 = v866;
            else
              v867 = v864 + 1;
            if ( !v867 )
            {
              v868 = 0;
LABEL_1394:
              v998 = &v868[32 * v864];
              *((_QWORD *)v998 + 1) = 0;
              *((_QWORD *)v998 + 2) = 0;
              v999 = v998 + 32;
              *((_QWORD *)v998 + 3) = v1324;
              *(_OWORD *)v998 = *(_OWORD *)v1322;
              *((_QWORD *)v998 + 2) = p;
              v1322[1] = 0;
              p = 0;
              v1322[0] = 0;
              v1001 = (void **)v849[4];
              v1000 = (void **)v849[5];
              v1002 = &v868[32 * v867];
              if ( v1000 == v1001 )
              {
                v1006 = (void **)v849[4];
              }
              else
              {
                v1003 = (char *)(v1000 - 4) - (char *)v1001;
                v1004 = v998 - 32;
                do
                {
                  *((_QWORD *)v1004 + 1) = 0;
                  *((_QWORD *)v1004 + 2) = 0;
                  *(_QWORD *)v1004 = 0;
                  *((_QWORD *)v1004 + 3) = *(v1000 - 1);
                  v1005 = *((_OWORD *)v1000 - 2);
                  v1000 -= 4;
                  *(_OWORD *)v1004 = v1005;
                  *((_QWORD *)v1004 + 2) = v1000[2];
                  v1004 -= 32;
                  *v1000 = 0;
                  v1000[1] = 0;
                  v1000[2] = 0;
                }
                while ( v1001 != v1000 );
                v1006 = (void **)v849[4];
                v1001 = (void **)v849[5];
                v998 = &v868[32 * (v864 - 1 - (v1003 >> 5))];
              }
              v1025 = v849[6];
              v849[4] = v998;
              v849[5] = v999;
              v849[6] = v1002;
              while ( v1006 != v1001 )
              {
                v1001 -= 4;
                sub_42F30(v1001);
              }
              if ( v1006 )
              {
                v1026 = v849[7];
                if ( v1026 + 4096 < (unsigned __int64)v1006 || v1026 > (unsigned __int64)v1006 )
                {
                  free(v1006);
                }
                else if ( *(_QWORD *)(v1026 + 4096) == v1025 )
                {
                  *(_QWORD *)(v1026 + 4096) = v1006;
                  v862 = (void **)v1322[0];
                  if ( !v1322[0] )
                    return v850;
LABEL_1538:
                  v1087 = (void **)v1322[1];
                  if ( v1322[1] != v862 )
                  {
                    do
                    {
                      if ( (*(_BYTE *)(v1087 - 3) & 1) != 0 )
                        free(*(v1087 - 1));
                      v1088 = v1087 - 6;
                      if ( (*(_BYTE *)(v1087 - 6) & 1) != 0 )
                        free(*(v1087 - 4));
                      v1087 -= 6;
                    }
                    while ( v862 != v1088 );
                  }
                  v1322[1] = v862;
                  if ( (__int64)v1324 + 4096 < (unsigned __int64)v862
                    || (unsigned __int64)v1324 > (unsigned __int64)v862 )
                  {
                    free(v862);
                  }
                  else if ( *(void **)(v1324 + 4096) == p )
                  {
                    *(_QWORD *)(v1324 + 4096) = v862;
                    return v850;
                  }
                  return v850;
                }
              }
              v862 = (void **)v1322[0];
              if ( !v1322[0] )
                return v850;
              goto LABEL_1538;
            }
          }
          v973 = v849[7];
          v868 = *(char **)(v973 + 4096);
          if ( v973 + 4096 - (__int64)v868 >= (unsigned __int64)(32 * v867) )
            *(_QWORD *)(v973 + 4096) = &v868[32 * v867];
          else
            v868 = (char *)malloc(32 * v867);
          goto LABEL_1394;
        }
LABEL_1411:
        free(v1333);
        goto LABEL_1412;
      case 'O':
        v177 = *(void ***)a3;
        v178 = *(_QWORD *)(a3 + 8);
        v179 = sub_38008(v4 + 1, a2, a3);
        v15 = v4;
        if ( (unsigned __int8 *)v179 == v4 + 1 )
          return v15;
        v1298 = (unsigned __int8 *)v179;
        v180 = *(_QWORD **)(a3 + 40);
        v181 = *(_QWORD *)(a3 + 48);
        v182 = *(void ***)a3;
        v183 = *(_QWORD *)(a3 + 8);
        v184 = *(_QWORD *)(a3 + 24);
        v185 = (__int64 *)a3;
        if ( (unsigned __int64)v180 < v181 )
        {
          *v180 = 0;
          v180[1] = 0;
          v180[2] = 0;
          v180[3] = v184;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_575;
        }
        v260 = *(_QWORD *)(a3 + 32);
        v261 = ((__int64)v180 - v260) >> 5;
        if ( (unsigned __int64)(v261 + 1) >> 59 )
          goto LABEL_1929;
        v262 = v181 - v260;
        if ( (unsigned __int64)(v262 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v264 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v263 = v262 >> 4;
          if ( v263 >= v261 + 1 )
            v264 = v263;
          else
            v264 = v261 + 1;
          if ( !v264 )
          {
            v265 = 0;
            goto LABEL_411;
          }
        }
        v300 = *(_QWORD *)(a3 + 56);
        v265 = *(char **)(v300 + 4096);
        if ( v300 + 4096 - (__int64)v265 >= (unsigned __int64)(32 * v264) )
          *(_QWORD *)(v300 + 4096) = &v265[32 * v264];
        else
          v265 = (char *)malloc(32 * v264);
LABEL_411:
        v329 = &v265[32 * v261];
        *(_QWORD *)v329 = 0;
        *((_QWORD *)v329 + 1) = 0;
        *((_QWORD *)v329 + 2) = 0;
        *((_QWORD *)v329 + 3) = v184;
        v331 = *(void ***)(a3 + 32);
        v330 = *(void ***)(a3 + 40);
        v332 = &v265[32 * v264];
        v333 = v329 + 32;
        if ( v330 == v331 )
        {
          v337 = *(void ***)(a3 + 32);
        }
        else
        {
          v334 = (char *)(v330 - 4) - (char *)v331;
          v335 = v329 - 32;
          do
          {
            *((_QWORD *)v335 + 1) = 0;
            *((_QWORD *)v335 + 2) = 0;
            *(_QWORD *)v335 = 0;
            *((_QWORD *)v335 + 3) = *(v330 - 1);
            v336 = *((_OWORD *)v330 - 2);
            v330 -= 4;
            *(_OWORD *)v335 = v336;
            *((_QWORD *)v335 + 2) = v330[2];
            v335 -= 32;
            *v330 = 0;
            v330[1] = 0;
            v330[2] = 0;
          }
          while ( v331 != v330 );
          v337 = *(void ***)(a3 + 32);
          v331 = *(void ***)(a3 + 40);
          v329 = &v265[32 * (v261 - 1 - (v334 >> 5))];
        }
        v375 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v329;
        *(_QWORD *)(a3 + 40) = v333;
        *(_QWORD *)(a3 + 48) = v332;
        while ( v337 != v331 )
        {
          v331 -= 4;
          sub_42F30(v331);
        }
        if ( v337 )
        {
          v376 = *(_QWORD *)(a3 + 56);
          if ( v376 + 4096 < (unsigned __int64)v337 || v376 > (unsigned __int64)v337 )
          {
            free(v337);
          }
          else if ( *(_QWORD *)(v376 + 4096) == v375 )
          {
            *(_QWORD *)(v376 + 4096) = v337;
          }
        }
LABEL_575:
        v446 = 0xAAAAAAAAAAAAAAABLL * ((v178 - (__int64)v177) >> 4);
        for ( i = 0xAAAAAAAAAAAAAAABLL * ((v183 - (__int64)v182) >> 4); v446 < i; ++v446 )
        {
          v475 = *v185;
          v1322[0] = 0;
          v1322[1] = 0;
          p = 0;
          v476 = v475 + 48 * v446;
          v477 = *(unsigned __int8 *)(v476 + 24);
          v478 = *(_QWORD *)(v476 + 32);
          v479 = *(const void **)(v476 + 40);
          v480 = (const void *)(v476 + 25);
          v481 = (v477 & 1) == 0;
          if ( (v477 & 1) != 0 )
            v482 = v478;
          else
            v482 = v477 >> 1;
          if ( v481 )
            v483 = v480;
          else
            v483 = v479;
          if ( v482 >= 2 )
            v484 = 2;
          else
            v484 = v482;
          LOBYTE(v1322[0]) = 2 * v484;
          if ( v484 )
            memcpy((char *)v1322 + 1, v483, v484);
          *((_BYTE *)v1322 + v484 + 1) = 0;
          v485 = (char *)v1322[1];
          v486 = 0;
          if ( ((__int64)v1322[0] & 1) == 0 )
            v485 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v485 == (_BYTE *)&dword_0 + 2 )
          {
            v487 = (unsigned __int16 *)p;
            if ( ((__int64)v1322[0] & 1) == 0 )
              v487 = (unsigned __int16 *)((char *)v1322 + 1);
            v486 = *v487 == 23328;
          }
          if ( ((__int64)v1322[0] & 1) != 0 )
            free(p);
          v488 = *v185;
          if ( v486 )
          {
            v489 = 2;
            v490 = " (";
LABEL_643:
            sub_42BE4((size_t *)(*v185 + 48 * v446), v490, v489);
            sub_429F4((size_t *)(*v185 + 48 * v446 + 24), 0, ")", 1u);
            goto LABEL_644;
          }
          v491 = v488 + 48 * v446;
          v494 = *(unsigned __int8 *)(v491 + 24);
          v492 = v491 + 24;
          v493 = v494;
          if ( (v494 & 1) != 0 )
          {
            if ( !*(_QWORD *)(v488 + 48 * v446 + 32) )
              goto LABEL_644;
          }
          else if ( !(v493 >> 1) )
          {
            goto LABEL_644;
          }
          if ( (v493 & 1) != 0 )
            v495 = *(_BYTE **)(v488 + 48 * v446 + 40);
          else
            v495 = (_BYTE *)(v492 + 1);
          if ( *v495 == 40 )
          {
            v489 = 1;
            v490 = "(";
            goto LABEL_643;
          }
LABEL_644:
          sub_42BE4((size_t *)(*v185 + 48 * v446), "&&", 2u);
          v496 = v185[5];
          v497 = *v185;
          v499 = *(size_t **)(v496 - 24);
          v498 = *(size_t **)(v496 - 16);
          v500 = *v185 + 48 * v446;
          if ( v499 == v498 )
          {
            v501 = *(_QWORD *)(v496 - 32);
            v502 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v499 - v501) >> 4);
            if ( v502 + 1 > 0x555555555555555LL )
              goto LABEL_1929;
            v503 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v498 - v501) >> 4);
            v504 = 0x555555555555555LL;
            if ( v503 >= 0x2AAAAAAAAAAAAAALL
              || ((v505 = 2 * v503, v505 >= v502 + 1) ? (v504 = v505) : (v504 = v502 + 1), v504) )
            {
              v506 = *(_QWORD *)(v496 - 8);
              v507 = 48 * v504;
              v447 = *(char **)(v506 + 4096);
              if ( v506 + 4096 - (__int64)v447 >= (unsigned __int64)(48 * v504) )
                *(_QWORD *)(v506 + 4096) = &v447[v507];
              else
                v447 = (char *)malloc(v507);
            }
            else
            {
              v447 = 0;
            }
            v448 = (size_t *)&v447[48 * v502];
            v448[1] = 0;
            v448[2] = 0;
            *v448 = 0;
            v449 = &v447[48 * v504];
            if ( (*(_BYTE *)v500 & 1) == 0 )
            {
              v448[2] = *(_QWORD *)(v500 + 16);
              *(_OWORD *)v448 = *(_OWORD *)v500;
              goto LABEL_588;
            }
            v450 = v497 + 48 * v446;
            v451 = *(_QWORD *)(v450 + 8);
            if ( v451 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v452 = *(const void **)(v450 + 16);
            v1302 = v449;
            if ( v451 >= 0x17 )
            {
              v453 = malloc((v451 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v454 = &v447[48 * v502];
              *((_QWORD *)v454 + 1) = v451;
              *((_QWORD *)v454 + 2) = v453;
              *v448 = (v451 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v448 = 2 * v451;
              v453 = (char *)v448 + 1;
              if ( !v451 )
                goto LABEL_587;
            }
            memcpy(v453, v452, v451);
LABEL_587:
            *((_BYTE *)v453 + v451) = 0;
            v185 = (__int64 *)a3;
            v449 = v1302;
LABEL_588:
            v455 = &v447[48 * v502];
            *((_QWORD *)v455 + 3) = 0;
            v456 = v455 + 24;
            v457 = v497 + 48 * v446;
            *((_QWORD *)v456 + 1) = 0;
            *((_QWORD *)v456 + 2) = 0;
            v459 = *(_BYTE *)(v457 + 24);
            v458 = v457 + 24;
            if ( (v459 & 1) == 0 )
            {
              *((_QWORD *)v456 + 2) = *(_QWORD *)(v458 + 16);
              *(_OWORD *)v456 = *(_OWORD *)v458;
LABEL_597:
              v468 = *(void ***)(v496 - 32);
              v467 = *(void ***)(v496 - 24);
              v469 = v448 + 6;
              if ( v467 == v468 )
              {
                v471 = *(void ***)(v496 - 32);
              }
              else
              {
                do
                {
                  *(v448 - 4) = (size_t)*(v467 - 4);
                  *((_OWORD *)v448 - 3) = *((_OWORD *)v467 - 3);
                  v470 = (size_t)*(v467 - 1);
                  *(v467 - 5) = 0;
                  *(v467 - 4) = 0;
                  *(v467 - 6) = 0;
                  *(v448 - 1) = v470;
                  *(_OWORD *)(v448 - 3) = *(_OWORD *)(v467 - 3);
                  *(v467 - 3) = 0;
                  *(v467 - 2) = 0;
                  *(v467 - 1) = 0;
                  v467 -= 6;
                  v448 -= 6;
                }
                while ( v468 != v467 );
                v471 = *(void ***)(v496 - 32);
                v468 = *(void ***)(v496 - 24);
              }
              v472 = *(_QWORD *)(v496 - 16);
              *(_QWORD *)(v496 - 32) = v448;
              *(_QWORD *)(v496 - 24) = v469;
              *(_QWORD *)(v496 - 16) = v449;
              if ( v468 != v471 )
              {
                do
                {
                  if ( (*(_BYTE *)(v468 - 3) & 1) != 0 )
                    free(*(v468 - 1));
                  v473 = v468 - 6;
                  if ( (*(_BYTE *)(v468 - 6) & 1) != 0 )
                    free(*(v468 - 4));
                  v468 -= 6;
                }
                while ( v471 != v473 );
              }
              if ( v471 )
              {
                v474 = *(_QWORD *)(v496 - 8);
                if ( v474 + 4096 < (unsigned __int64)v471 || v474 > (unsigned __int64)v471 )
                {
                  free(v471);
                }
                else if ( *(_QWORD *)(v474 + 4096) == v472 )
                {
                  *(_QWORD *)(v474 + 4096) = v471;
                }
              }
              continue;
            }
            v460 = v497 + 48 * v446;
            v461 = *(_QWORD *)(v460 + 32);
            if ( v461 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v462 = *(const void **)(v460 + 40);
            v463 = v449;
            if ( v461 >= 0x17 )
            {
              v465 = malloc((v461 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v466 = &v447[48 * v502];
              *((_QWORD *)v466 + 4) = v461;
              *((_QWORD *)v466 + 5) = v465;
              *(_QWORD *)v456 = (v461 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v464 = v465;
            }
            else
            {
              *v456 = 2 * v461;
              v464 = v456 + 1;
              if ( !v461 )
                goto LABEL_596;
            }
            memcpy(v464, v462, v461);
LABEL_596:
            v185 = (__int64 *)a3;
            v449 = v463;
            *((_BYTE *)v464 + v461) = 0;
            goto LABEL_597;
          }
          v499[1] = 0;
          v499[2] = 0;
          *v499 = 0;
          if ( (*(_BYTE *)v500 & 1) == 0 )
          {
            v499[2] = *(_QWORD *)(v500 + 16);
            *(_OWORD *)v499 = *(_OWORD *)v500;
            goto LABEL_662;
          }
          v508 = v497 + 48 * v446;
          v509 = *(_QWORD *)(v508 + 8);
          if ( v509 >= 0xFFFFFFFFFFFFFFF0LL )
            goto LABEL_1929;
          v510 = *(const void **)(v508 + 16);
          if ( v509 >= 0x17 )
          {
            v511 = malloc((v509 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v499[1] = v509;
            v499[2] = (size_t)v511;
            v185 = (__int64 *)a3;
            *v499 = (v509 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v499 = 2 * v509;
            v511 = (char *)v499 + 1;
            if ( !v509 )
              goto LABEL_661;
          }
          memcpy(v511, v510, v509);
LABEL_661:
          *((_BYTE *)v511 + v509) = 0;
LABEL_662:
          v499[3] = 0;
          v512 = v499 + 3;
          v513 = v497 + 48 * v446;
          v499[4] = 0;
          v499[5] = 0;
          v515 = *(_BYTE *)(v513 + 24);
          v514 = v513 + 24;
          if ( (v515 & 1) != 0 )
          {
            v516 = v497 + 48 * v446;
            v517 = *(_QWORD *)(v516 + 32);
            if ( v517 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v518 = *(const void **)(v516 + 40);
            if ( v517 >= 0x17 )
            {
              v519 = malloc((v517 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v499[4] = v517;
              v499[5] = (size_t)v519;
              v185 = (__int64 *)a3;
              v499[3] = (v517 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v512 = 2 * v517;
              v519 = (char *)v499 + 25;
              if ( !v517 )
                goto LABEL_670;
            }
            memcpy(v519, v518, v517);
LABEL_670:
            *((_BYTE *)v519 + v517) = 0;
            goto LABEL_671;
          }
          v499[5] = *(_QWORD *)(v514 + 16);
          *(_OWORD *)v512 = *(_OWORD *)v514;
LABEL_671:
          *(_QWORD *)(v496 - 24) += 48LL;
        }
        return v1298;
      case 'P':
        v186 = *(void ***)a3;
        v187 = *(_QWORD *)(a3 + 8);
        v188 = sub_38008(v4 + 1, a2, a3);
        v15 = v4;
        v1309 = v4 + 1;
        if ( (unsigned __int8 *)v188 == v4 + 1 )
          return v15;
        v189 = *(_QWORD **)(a3 + 40);
        v190 = *(_QWORD *)(a3 + 48);
        v191 = *(void ***)a3;
        v192 = *(_QWORD *)(a3 + 8);
        v193 = *(_QWORD *)(a3 + 24);
        v194 = (__int64 *)a3;
        v1296 = v188;
        if ( (unsigned __int64)v189 < v190 )
        {
          *v189 = 0;
          v189[1] = 0;
          v189[2] = 0;
          v189[3] = v193;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_675;
        }
        v266 = *(_QWORD *)(a3 + 32);
        v267 = ((__int64)v189 - v266) >> 5;
        if ( (unsigned __int64)(v267 + 1) >> 59 )
          goto LABEL_1929;
        v268 = v190 - v266;
        if ( (unsigned __int64)(v268 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v270 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v269 = v268 >> 4;
          if ( v269 >= v267 + 1 )
            v270 = v269;
          else
            v270 = v267 + 1;
          if ( !v270 )
          {
            v271 = 0;
            goto LABEL_416;
          }
        }
        v301 = *(_QWORD *)(a3 + 56);
        v271 = *(char **)(v301 + 4096);
        if ( v301 + 4096 - (__int64)v271 >= (unsigned __int64)(32 * v270) )
          *(_QWORD *)(v301 + 4096) = &v271[32 * v270];
        else
          v271 = (char *)malloc(32 * v270);
LABEL_416:
        v338 = &v271[32 * v267];
        *(_QWORD *)v338 = 0;
        *((_QWORD *)v338 + 1) = 0;
        *((_QWORD *)v338 + 2) = 0;
        *((_QWORD *)v338 + 3) = v193;
        v340 = *(void ***)(a3 + 32);
        v339 = *(void ***)(a3 + 40);
        v341 = &v271[32 * v270];
        v342 = v338 + 32;
        if ( v339 == v340 )
        {
          v346 = *(void ***)(a3 + 32);
        }
        else
        {
          v343 = (char *)(v339 - 4) - (char *)v340;
          v344 = v338 - 32;
          do
          {
            *((_QWORD *)v344 + 1) = 0;
            *((_QWORD *)v344 + 2) = 0;
            *(_QWORD *)v344 = 0;
            *((_QWORD *)v344 + 3) = *(v339 - 1);
            v345 = *((_OWORD *)v339 - 2);
            v339 -= 4;
            *(_OWORD *)v344 = v345;
            *((_QWORD *)v344 + 2) = v339[2];
            v344 -= 32;
            *v339 = 0;
            v339[1] = 0;
            v339[2] = 0;
          }
          while ( v340 != v339 );
          v346 = *(void ***)(a3 + 32);
          v340 = *(void ***)(a3 + 40);
          v338 = &v271[32 * (v267 - 1 - (v343 >> 5))];
        }
        v377 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v338;
        *(_QWORD *)(a3 + 40) = v342;
        *(_QWORD *)(a3 + 48) = v341;
        while ( v346 != v340 )
        {
          v340 -= 4;
          sub_42F30(v340);
        }
        if ( v346 )
        {
          v378 = *(_QWORD *)(a3 + 56);
          if ( v378 + 4096 < (unsigned __int64)v346 || v378 > (unsigned __int64)v346 )
          {
            free(v346);
          }
          else if ( *(_QWORD *)(v378 + 4096) == v377 )
          {
            *(_QWORD *)(v378 + 4096) = v346;
          }
        }
LABEL_675:
        v520 = 0xAAAAAAAAAAAAAAABLL * ((v187 - (__int64)v186) >> 4);
        v1303 = 0xAAAAAAAAAAAAAAABLL * ((v192 - (__int64)v191) >> 4);
        if ( v520 >= v1303 )
          return (unsigned __int8 *)v1296;
        while ( 1 )
        {
          v549 = *v194;
          v1322[0] = 0;
          v1322[1] = 0;
          p = 0;
          v550 = v549 + 48 * v520;
          v551 = *(unsigned __int8 *)(v550 + 24);
          v552 = *(_QWORD *)(v550 + 32);
          v553 = *(const void **)(v550 + 40);
          v554 = (const void *)(v550 + 25);
          v555 = (v551 & 1) == 0;
          if ( (v551 & 1) != 0 )
            v556 = v552;
          else
            v556 = v551 >> 1;
          if ( v555 )
            v557 = v554;
          else
            v557 = v553;
          if ( v556 >= 2 )
            v558 = 2;
          else
            v558 = v556;
          LOBYTE(v1322[0]) = 2 * v558;
          if ( v558 )
            memcpy((char *)v1322 + 1, v557, v558);
          *((_BYTE *)v1322 + v558 + 1) = 0;
          v559 = (char *)v1322[1];
          v560 = 0;
          if ( ((__int64)v1322[0] & 1) == 0 )
            v559 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v559 == (_BYTE *)&dword_0 + 2 )
          {
            v561 = (unsigned __int16 *)p;
            if ( ((__int64)v1322[0] & 1) == 0 )
              v561 = (unsigned __int16 *)((char *)v1322 + 1);
            v560 = *v561 == 23328;
          }
          if ( ((__int64)v1322[0] & 1) != 0 )
            free(p);
          v562 = *v194;
          if ( v560 )
          {
            v563 = 2;
            v564 = " (";
LABEL_744:
            sub_42BE4((size_t *)(*v194 + 48 * v520), v564, v563);
            sub_429F4((size_t *)(*v194 + 48 * v520 + 24), 0, ")", 1u);
            goto LABEL_745;
          }
          v565 = v562 + 48 * v520;
          v568 = *(unsigned __int8 *)(v565 + 24);
          v566 = v565 + 24;
          v567 = v568;
          if ( (v568 & 1) != 0 )
          {
            if ( !*(_QWORD *)(v562 + 48 * v520 + 32) )
              goto LABEL_745;
          }
          else if ( !(v567 >> 1) )
          {
            goto LABEL_745;
          }
          if ( (v567 & 1) != 0 )
            v569 = *(_BYTE **)(v562 + 48 * v520 + 40);
          else
            v569 = (_BYTE *)(v566 + 1);
          if ( *v569 == 40 )
          {
            v563 = 1;
            v564 = "(";
            goto LABEL_744;
          }
LABEL_745:
          if ( *v1309 != 85 )
          {
            v577 = (size_t *)(*v194 + 48 * v520);
LABEL_768:
            sub_42BE4(v577, "*", 1u);
            v582 = (__int64 *)a3;
            goto LABEL_822;
          }
          v570 = *v194;
          v1322[0] = 0;
          v1322[1] = 0;
          p = 0;
          v571 = (unsigned __int8 *)(v570 + 48 * v520);
          v572 = *v571;
          v573 = (v572 & 1) == 0;
          if ( (v572 & 1) != 0 )
            v574 = *((_QWORD *)v571 + 1);
          else
            v574 = v572 >> 1;
          if ( v573 )
            v575 = v571 + 1;
          else
            v575 = (const void *)*((_QWORD *)v571 + 2);
          if ( v574 >= 0xC )
            v576 = 12;
          else
            v576 = v574;
          LOBYTE(v1322[0]) = 2 * v576;
          if ( v576 )
            memcpy((char *)v1322 + 1, v575, v576);
          *((_BYTE *)v1322 + v576 + 1) = 0;
          v578 = (char *)v1322[1];
          if ( ((__int64)v1322[0] & 1) == 0 )
            v578 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v578 == &byte_9[3] )
          {
            if ( ((__int64)v1322[0] & 1) != 0 )
              v579 = (char *)p;
            else
              v579 = (char *)v1322 + 1;
            v580 = memcmp(v579, "objc_object<", 0xCu) != 0;
            if ( ((__int64)v1322[0] & 1) != 0 )
LABEL_766:
              free(p);
          }
          else
          {
            v580 = 1;
            if ( ((__int64)v1322[0] & 1) != 0 )
              goto LABEL_766;
          }
          v581 = *v194;
          v577 = (size_t *)(*v194 + 48 * v520);
          if ( v580 )
            goto LABEL_768;
          v583 = *(unsigned __int8 *)v577;
          if ( (v583 & 1) != 0 )
          {
            v584 = *(_QWORD *)(v581 + 48 * v520 + 8);
            if ( v584 >= 0xB )
              v548 = 11;
            else
              v548 = *(_QWORD *)(v581 + 48 * v520 + 8);
            v585 = (*v577 & 0xFFFFFFFFFFFFFFFELL) - 1;
          }
          else
          {
            v584 = v583 >> 1;
            if ( v583 >> 1 >= 0xB )
              v548 = 11;
            else
              v548 = v583 >> 1;
            v585 = 22;
          }
          if ( v548 - v584 + v585 < 2 )
          {
            v586 = v584 - v548;
            v587 = v584 - v548 + 2;
            if ( -18LL - v585 < v587 - v585 )
              goto LABEL_1929;
            if ( (v583 & 1) != 0 )
              v588 = *(char **)(v581 + 48 * v520 + 16);
            else
              v588 = (char *)v577 + 1;
            if ( v585 > 0x7FFFFFFFFFFFFFE6LL )
            {
              v595 = -17;
            }
            else
            {
              v594 = 2 * v585;
              if ( v587 >= 2 * v585 )
                v594 = v587;
              if ( v594 >= 0x17 )
                v595 = (v594 + 16) & 0xFFFFFFFFFFFFFFF0LL;
              else
                v595 = 23;
            }
            v596 = malloc(v595);
            v597 = v596;
            *v596 = 25705;
            if ( v586 )
              memcpy(v596 + 1, &v588[v548], v586);
            if ( v585 != 22 )
              free(v588);
            v598 = v581 + 48 * v520;
            *(_QWORD *)(v598 + 8) = v587;
            *(_QWORD *)(v598 + 16) = v597;
            *v577 = v595 | 1;
            v582 = (__int64 *)a3;
            v599 = (char *)v597 + v587;
            goto LABEL_821;
          }
          if ( (v583 & 1) != 0 )
          {
            v589 = *(char **)(v581 + 48 * v520 + 16);
            if ( v548 == 2 )
            {
LABEL_786:
              v590 = 0;
              v591 = "id";
              v592 = 2;
              goto LABEL_816;
            }
          }
          else
          {
            v589 = (char *)v577 + 1;
            if ( v548 == 2 )
              goto LABEL_786;
          }
          if ( v584 == v548 )
          {
            v590 = 0;
            v591 = "id";
            goto LABEL_815;
          }
          if ( v548 < 3 )
          {
            v600 = &v589[v548];
            if ( v589 >= "id" )
            {
              v591 = "id";
              goto LABEL_814;
            }
            v591 = "id";
            if ( &v589[v584] <= "id" )
              goto LABEL_814;
            if ( v600 <= "id" )
            {
              v591 = &aStdBadTypeid[2 - v548 + 13];
LABEL_814:
              memmove(v589 + 2, v600, v584 - v548);
              v590 = 0;
LABEL_815:
              v592 = 2;
LABEL_816:
              memmove(&v589[v590], v591, v592);
              v593 = v592;
              goto LABEL_817;
            }
            if ( v548 )
            {
              memcpy(v589, "id", v548);
              v600 = &v589[v548];
            }
            v592 = 2 - v548;
            memmove(v589 + 2, v600, v584 - v548);
            v593 = 0;
            if ( 2 != v548 )
            {
              v591 = "";
              v590 = v548;
              v548 = 0;
              goto LABEL_816;
            }
            v548 = 0;
          }
          else
          {
            *(_WORD *)v589 = 25705;
            memmove(v589 + 2, &v589[v548], v584 - v548);
            v593 = 2;
          }
LABEL_817:
          v601 = v593 - v548 + v584;
          if ( (*(_BYTE *)v577 & 1) != 0 )
            *(_QWORD *)(v581 + 48 * v520 + 8) = v601;
          else
            *(_BYTE *)v577 = 2 * v601;
          v582 = (__int64 *)a3;
          v599 = &v589[v601];
LABEL_821:
          *v599 = 0;
LABEL_822:
          v602 = v582[5];
          v603 = *v582;
          v605 = *(size_t **)(v602 - 24);
          v604 = *(size_t **)(v602 - 16);
          v606 = v603 + 48 * v520;
          if ( v605 == v604 )
          {
            v607 = *(_QWORD *)(v602 - 32);
            v608 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v605 - v607) >> 4);
            if ( v608 + 1 > 0x555555555555555LL )
              goto LABEL_1929;
            v609 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v604 - v607) >> 4);
            v610 = 0x555555555555555LL;
            if ( v609 >= 0x2AAAAAAAAAAAAAALL
              || ((v611 = 2 * v609, v611 >= v608 + 1) ? (v610 = v611) : (v610 = v608 + 1), v610) )
            {
              v612 = *(_QWORD *)(v602 - 8);
              v613 = 48 * v610;
              v521 = *(char **)(v612 + 4096);
              if ( v612 + 4096 - (__int64)v521 >= (unsigned __int64)(48 * v610) )
                *(_QWORD *)(v612 + 4096) = &v521[v613];
              else
                v521 = (char *)malloc(v613);
            }
            else
            {
              v521 = 0;
            }
            v522 = (size_t *)&v521[48 * v608];
            v522[1] = 0;
            v522[2] = 0;
            *v522 = 0;
            v523 = &v521[48 * v610];
            if ( (*(_BYTE *)v606 & 1) == 0 )
            {
              v522[2] = *(_QWORD *)(v606 + 16);
              *(_OWORD *)v522 = *(_OWORD *)v606;
              goto LABEL_688;
            }
            v524 = v603 + 48 * v520;
            v525 = *(_QWORD *)(v524 + 8);
            if ( v525 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v526 = *(const void **)(v524 + 16);
            if ( v525 >= 0x17 )
            {
              v527 = malloc((v525 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v528 = &v521[48 * v608];
              *((_QWORD *)v528 + 1) = v525;
              *((_QWORD *)v528 + 2) = v527;
              *v522 = (v525 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v522 = 2 * v525;
              v527 = (char *)v522 + 1;
              if ( !v525 )
                goto LABEL_687;
            }
            memcpy(v527, v526, v525);
LABEL_687:
            *((_BYTE *)v527 + v525) = 0;
LABEL_688:
            v529 = &v521[48 * v608];
            *((_QWORD *)v529 + 3) = 0;
            v530 = v529 + 24;
            v531 = v603 + 48 * v520;
            *((_QWORD *)v530 + 1) = 0;
            *((_QWORD *)v530 + 2) = 0;
            v533 = *(_BYTE *)(v531 + 24);
            v532 = v531 + 24;
            if ( (v533 & 1) == 0 )
            {
              *((_QWORD *)v530 + 2) = *(_QWORD *)(v532 + 16);
              *(_OWORD *)v530 = *(_OWORD *)v532;
LABEL_697:
              v541 = *(void ***)(v602 - 32);
              v540 = *(void ***)(v602 - 24);
              v542 = v522 + 6;
              if ( v540 == v541 )
              {
                v544 = *(void ***)(v602 - 32);
              }
              else
              {
                do
                {
                  *(v522 - 4) = (size_t)*(v540 - 4);
                  *((_OWORD *)v522 - 3) = *((_OWORD *)v540 - 3);
                  v543 = (size_t)*(v540 - 1);
                  *(v540 - 5) = 0;
                  *(v540 - 4) = 0;
                  *(v540 - 6) = 0;
                  *(v522 - 1) = v543;
                  *(_OWORD *)(v522 - 3) = *(_OWORD *)(v540 - 3);
                  *(v540 - 3) = 0;
                  *(v540 - 2) = 0;
                  *(v540 - 1) = 0;
                  v540 -= 6;
                  v522 -= 6;
                }
                while ( v541 != v540 );
                v544 = *(void ***)(v602 - 32);
                v541 = *(void ***)(v602 - 24);
              }
              v545 = *(_QWORD *)(v602 - 16);
              *(_QWORD *)(v602 - 32) = v522;
              *(_QWORD *)(v602 - 24) = v542;
              *(_QWORD *)(v602 - 16) = v523;
              if ( v541 != v544 )
              {
                do
                {
                  if ( (*(_BYTE *)(v541 - 3) & 1) != 0 )
                    free(*(v541 - 1));
                  v546 = v541 - 6;
                  if ( (*(_BYTE *)(v541 - 6) & 1) != 0 )
                    free(*(v541 - 4));
                  v541 -= 6;
                }
                while ( v544 != v546 );
              }
              if ( v544 )
              {
                v547 = *(_QWORD *)(v602 - 8);
                if ( v547 + 4096 < (unsigned __int64)v544 || v547 > (unsigned __int64)v544 )
                {
                  free(v544);
                }
                else if ( *(_QWORD *)(v547 + 4096) == v545 )
                {
                  *(_QWORD *)(v547 + 4096) = v544;
                }
              }
              goto LABEL_850;
            }
            v534 = v603 + 48 * v520;
            v535 = *(_QWORD *)(v534 + 32);
            if ( v535 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v536 = *(const void **)(v534 + 40);
            if ( v535 >= 0x17 )
            {
              v538 = malloc((v535 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v539 = &v521[48 * v608];
              *((_QWORD *)v539 + 4) = v535;
              *((_QWORD *)v539 + 5) = v538;
              *(_QWORD *)v530 = (v535 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v537 = v538;
            }
            else
            {
              *v530 = 2 * v535;
              v537 = v530 + 1;
              if ( !v535 )
                goto LABEL_696;
            }
            memcpy(v537, v536, v535);
LABEL_696:
            *((_BYTE *)v537 + v535) = 0;
            goto LABEL_697;
          }
          v605[1] = 0;
          v605[2] = 0;
          *v605 = 0;
          if ( (*(_BYTE *)v606 & 1) == 0 )
          {
            v605[2] = *(_QWORD *)(v606 + 16);
            *(_OWORD *)v605 = *(_OWORD *)v606;
            goto LABEL_840;
          }
          v614 = v603 + 48 * v520;
          v615 = *(_QWORD *)(v614 + 8);
          if ( v615 >= 0xFFFFFFFFFFFFFFF0LL )
            goto LABEL_1929;
          v616 = *(const void **)(v614 + 16);
          if ( v615 >= 0x17 )
          {
            v617 = malloc((v615 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v605[1] = v615;
            v605[2] = (size_t)v617;
            *v605 = (v615 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v605 = 2 * v615;
            v617 = (char *)v605 + 1;
            if ( !v615 )
              goto LABEL_839;
          }
          memcpy(v617, v616, v615);
LABEL_839:
          *((_BYTE *)v617 + v615) = 0;
LABEL_840:
          v605[3] = 0;
          v618 = v605 + 3;
          v619 = v603 + 48 * v520;
          v605[4] = 0;
          v605[5] = 0;
          v621 = *(_BYTE *)(v619 + 24);
          v620 = v619 + 24;
          if ( (v621 & 1) != 0 )
          {
            v622 = v603 + 48 * v520;
            v623 = *(_QWORD *)(v622 + 32);
            if ( v623 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v624 = *(const void **)(v622 + 40);
            if ( v623 >= 0x17 )
            {
              v625 = malloc((v623 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v605[4] = v623;
              v605[5] = (size_t)v625;
              v605[3] = (v623 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v618 = 2 * v623;
              v625 = (char *)v605 + 25;
              if ( !v623 )
                goto LABEL_848;
            }
            memcpy(v625, v624, v623);
LABEL_848:
            *((_BYTE *)v625 + v623) = 0;
            goto LABEL_849;
          }
          v605[5] = *(_QWORD *)(v620 + 16);
          *(_OWORD *)v618 = *(_OWORD *)v620;
LABEL_849:
          *(_QWORD *)(v602 - 24) += 48LL;
LABEL_850:
          v194 = (__int64 *)a3;
          if ( ++v520 >= v1303 )
            return (unsigned __int8 *)v1296;
        }
      case 'R':
        v230 = *(void ***)a3;
        v231 = *(_QWORD *)(a3 + 8);
        v232 = sub_38008(v4 + 1, a2, a3);
        v15 = v4;
        if ( (unsigned __int8 *)v232 == v4 + 1 )
          return v15;
        v1298 = (unsigned __int8 *)v232;
        v233 = *(_QWORD **)(a3 + 40);
        v234 = *(_QWORD *)(a3 + 48);
        v235 = *(void ***)a3;
        v236 = *(_QWORD *)(a3 + 8);
        v237 = *(_QWORD *)(a3 + 24);
        v238 = (__int64 *)a3;
        if ( (unsigned __int64)v233 < v234 )
        {
          *v233 = 0;
          v233[1] = 0;
          v233[2] = 0;
          v233[3] = v237;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_859;
        }
        v272 = *(_QWORD *)(a3 + 32);
        v273 = ((__int64)v233 - v272) >> 5;
        if ( (unsigned __int64)(v273 + 1) >> 59 )
          goto LABEL_1929;
        v274 = v234 - v272;
        if ( (unsigned __int64)(v274 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v276 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v275 = v274 >> 4;
          if ( v275 >= v273 + 1 )
            v276 = v275;
          else
            v276 = v273 + 1;
          if ( !v276 )
          {
            v277 = 0;
            goto LABEL_421;
          }
        }
        v302 = *(_QWORD *)(a3 + 56);
        v277 = *(char **)(v302 + 4096);
        if ( v302 + 4096 - (__int64)v277 >= (unsigned __int64)(32 * v276) )
          *(_QWORD *)(v302 + 4096) = &v277[32 * v276];
        else
          v277 = (char *)malloc(32 * v276);
LABEL_421:
        v347 = &v277[32 * v273];
        *(_QWORD *)v347 = 0;
        *((_QWORD *)v347 + 1) = 0;
        *((_QWORD *)v347 + 2) = 0;
        *((_QWORD *)v347 + 3) = v237;
        v349 = *(void ***)(a3 + 32);
        v348 = *(void ***)(a3 + 40);
        v350 = &v277[32 * v276];
        v351 = v347 + 32;
        if ( v348 == v349 )
        {
          v355 = *(void ***)(a3 + 32);
        }
        else
        {
          v352 = (char *)(v348 - 4) - (char *)v349;
          v353 = v347 - 32;
          do
          {
            *((_QWORD *)v353 + 1) = 0;
            *((_QWORD *)v353 + 2) = 0;
            *(_QWORD *)v353 = 0;
            *((_QWORD *)v353 + 3) = *(v348 - 1);
            v354 = *((_OWORD *)v348 - 2);
            v348 -= 4;
            *(_OWORD *)v353 = v354;
            *((_QWORD *)v353 + 2) = v348[2];
            v353 -= 32;
            *v348 = 0;
            v348[1] = 0;
            v348[2] = 0;
          }
          while ( v349 != v348 );
          v355 = *(void ***)(a3 + 32);
          v349 = *(void ***)(a3 + 40);
          v347 = &v277[32 * (v273 - 1 - (v352 >> 5))];
        }
        v379 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v347;
        *(_QWORD *)(a3 + 40) = v351;
        *(_QWORD *)(a3 + 48) = v350;
        while ( v355 != v349 )
        {
          v349 -= 4;
          sub_42F30(v349);
        }
        if ( v355 )
        {
          v380 = *(_QWORD *)(a3 + 56);
          if ( v380 + 4096 < (unsigned __int64)v355 || v380 > (unsigned __int64)v355 )
          {
            free(v355);
          }
          else if ( *(_QWORD *)(v380 + 4096) == v379 )
          {
            *(_QWORD *)(v380 + 4096) = v355;
          }
        }
LABEL_859:
        v628 = 0xAAAAAAAAAAAAAAABLL * ((v231 - (__int64)v230) >> 4);
        v1319 = 0xAAAAAAAAAAAAAAABLL * ((v236 - (__int64)v235) >> 4);
        if ( v628 >= v1319 )
          return v1298;
        while ( 1 )
        {
          v657 = *v238;
          v1322[0] = 0;
          v1322[1] = 0;
          p = 0;
          v658 = v657 + 48 * v628;
          v659 = *(unsigned __int8 *)(v658 + 24);
          v660 = *(_QWORD *)(v658 + 32);
          v661 = *(const void **)(v658 + 40);
          v662 = (const void *)(v658 + 25);
          v663 = (v659 & 1) == 0;
          if ( (v659 & 1) != 0 )
            v664 = v660;
          else
            v664 = v659 >> 1;
          if ( v663 )
            v665 = v662;
          else
            v665 = v661;
          if ( v664 >= 2 )
            v666 = 2;
          else
            v666 = v664;
          LOBYTE(v1322[0]) = 2 * v666;
          if ( v666 )
            memcpy((char *)v1322 + 1, v665, v666);
          *((_BYTE *)v1322 + v666 + 1) = 0;
          v667 = (char *)v1322[1];
          v668 = 0;
          if ( ((__int64)v1322[0] & 1) == 0 )
            v667 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
          if ( v667 == (_BYTE *)&dword_0 + 2 )
          {
            v669 = (unsigned __int16 *)p;
            if ( ((__int64)v1322[0] & 1) == 0 )
              v669 = (unsigned __int16 *)((char *)v1322 + 1);
            v668 = *v669 == 23328;
          }
          if ( ((__int64)v1322[0] & 1) != 0 )
            free(p);
          v670 = *v238;
          if ( v668 )
          {
            v671 = 2;
            v672 = " (";
LABEL_927:
            sub_42BE4((size_t *)(*v238 + 48 * v628), v672, v671);
            sub_429F4((size_t *)(*v238 + 48 * v628 + 24), 0, ")", 1u);
            goto LABEL_928;
          }
          v673 = v670 + 48 * v628;
          v676 = *(unsigned __int8 *)(v673 + 24);
          v674 = v673 + 24;
          v675 = v676;
          if ( (v676 & 1) != 0 )
          {
            if ( !*(_QWORD *)(v670 + 48 * v628 + 32) )
              goto LABEL_928;
          }
          else if ( !(v675 >> 1) )
          {
            goto LABEL_928;
          }
          if ( (v675 & 1) != 0 )
            v677 = *(_BYTE **)(v670 + 48 * v628 + 40);
          else
            v677 = (_BYTE *)(v674 + 1);
          if ( *v677 == 40 )
          {
            v671 = 1;
            v672 = "(";
            goto LABEL_927;
          }
LABEL_928:
          sub_42BE4((size_t *)(*v238 + 48 * v628), "&", 1u);
          v678 = v238[5];
          v679 = *v238;
          v681 = *(size_t **)(v678 - 24);
          v680 = *(size_t **)(v678 - 16);
          v682 = *v238 + 48 * v628;
          if ( v681 == v680 )
          {
            v683 = *(_QWORD *)(v678 - 32);
            v684 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v681 - v683) >> 4);
            if ( v684 + 1 > 0x555555555555555LL )
              goto LABEL_1929;
            v685 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v680 - v683) >> 4);
            v686 = 0x555555555555555LL;
            if ( v685 >= 0x2AAAAAAAAAAAAAALL
              || ((v687 = 2 * v685, v687 >= v684 + 1) ? (v686 = v687) : (v686 = v684 + 1), v686) )
            {
              v688 = *(_QWORD *)(v678 - 8);
              v689 = 48 * v686;
              v629 = *(char **)(v688 + 4096);
              if ( v688 + 4096 - (__int64)v629 >= (unsigned __int64)(48 * v686) )
                *(_QWORD *)(v688 + 4096) = &v629[v689];
              else
                v629 = (char *)malloc(v689);
            }
            else
            {
              v629 = 0;
            }
            v630 = (size_t *)&v629[48 * v684];
            v630[1] = 0;
            v630[2] = 0;
            *v630 = 0;
            v631 = &v629[48 * v686];
            if ( (*(_BYTE *)v682 & 1) == 0 )
            {
              v630[2] = *(_QWORD *)(v682 + 16);
              *(_OWORD *)v630 = *(_OWORD *)v682;
              goto LABEL_872;
            }
            v632 = v679 + 48 * v628;
            v633 = *(_QWORD *)(v632 + 8);
            if ( v633 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v634 = *(const void **)(v632 + 16);
            v1304 = v631;
            if ( v633 >= 0x17 )
            {
              v635 = malloc((v633 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v636 = &v629[48 * v684];
              *((_QWORD *)v636 + 1) = v633;
              *((_QWORD *)v636 + 2) = v635;
              *v630 = (v633 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v630 = 2 * v633;
              v635 = (char *)v630 + 1;
              if ( !v633 )
                goto LABEL_871;
            }
            memcpy(v635, v634, v633);
LABEL_871:
            *((_BYTE *)v635 + v633) = 0;
            v238 = (__int64 *)a3;
            v631 = v1304;
LABEL_872:
            v637 = &v629[48 * v684];
            *((_QWORD *)v637 + 3) = 0;
            v638 = v637 + 24;
            v639 = v679 + 48 * v628;
            *((_QWORD *)v638 + 1) = 0;
            *((_QWORD *)v638 + 2) = 0;
            v641 = *(_BYTE *)(v639 + 24);
            v640 = v639 + 24;
            if ( (v641 & 1) == 0 )
            {
              *((_QWORD *)v638 + 2) = *(_QWORD *)(v640 + 16);
              *(_OWORD *)v638 = *(_OWORD *)v640;
LABEL_881:
              v650 = *(void ***)(v678 - 32);
              v649 = *(void ***)(v678 - 24);
              v651 = v630 + 6;
              if ( v649 == v650 )
              {
                v653 = *(void ***)(v678 - 32);
              }
              else
              {
                do
                {
                  *(v630 - 4) = (size_t)*(v649 - 4);
                  *((_OWORD *)v630 - 3) = *((_OWORD *)v649 - 3);
                  v652 = (size_t)*(v649 - 1);
                  *(v649 - 5) = 0;
                  *(v649 - 4) = 0;
                  *(v649 - 6) = 0;
                  *(v630 - 1) = v652;
                  *(_OWORD *)(v630 - 3) = *(_OWORD *)(v649 - 3);
                  *(v649 - 3) = 0;
                  *(v649 - 2) = 0;
                  *(v649 - 1) = 0;
                  v649 -= 6;
                  v630 -= 6;
                }
                while ( v650 != v649 );
                v653 = *(void ***)(v678 - 32);
                v650 = *(void ***)(v678 - 24);
              }
              v654 = *(_QWORD *)(v678 - 16);
              *(_QWORD *)(v678 - 32) = v630;
              *(_QWORD *)(v678 - 24) = v651;
              *(_QWORD *)(v678 - 16) = v631;
              if ( v650 != v653 )
              {
                do
                {
                  if ( (*(_BYTE *)(v650 - 3) & 1) != 0 )
                    free(*(v650 - 1));
                  v655 = v650 - 6;
                  if ( (*(_BYTE *)(v650 - 6) & 1) != 0 )
                    free(*(v650 - 4));
                  v650 -= 6;
                }
                while ( v653 != v655 );
              }
              if ( v653 )
              {
                v656 = *(_QWORD *)(v678 - 8);
                if ( v656 + 4096 < (unsigned __int64)v653 || v656 > (unsigned __int64)v653 )
                {
                  free(v653);
                }
                else if ( *(_QWORD *)(v656 + 4096) == v654 )
                {
                  *(_QWORD *)(v656 + 4096) = v653;
                }
              }
              goto LABEL_956;
            }
            v642 = v679 + 48 * v628;
            v643 = *(_QWORD *)(v642 + 32);
            if ( v643 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v644 = *(const void **)(v642 + 40);
            v645 = v631;
            if ( v643 >= 0x17 )
            {
              v647 = malloc((v643 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v648 = &v629[48 * v684];
              *((_QWORD *)v648 + 4) = v643;
              *((_QWORD *)v648 + 5) = v647;
              *(_QWORD *)v638 = (v643 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v646 = v647;
            }
            else
            {
              *v638 = 2 * v643;
              v646 = v638 + 1;
              if ( !v643 )
                goto LABEL_880;
            }
            memcpy(v646, v644, v643);
LABEL_880:
            v238 = (__int64 *)a3;
            v631 = v645;
            *((_BYTE *)v646 + v643) = 0;
            goto LABEL_881;
          }
          v681[1] = 0;
          v681[2] = 0;
          *v681 = 0;
          if ( (*(_BYTE *)v682 & 1) == 0 )
          {
            v681[2] = *(_QWORD *)(v682 + 16);
            *(_OWORD *)v681 = *(_OWORD *)v682;
            goto LABEL_946;
          }
          v690 = v679 + 48 * v628;
          v691 = *(_QWORD *)(v690 + 8);
          if ( v691 >= 0xFFFFFFFFFFFFFFF0LL )
            goto LABEL_1929;
          v692 = *(const void **)(v690 + 16);
          if ( v691 >= 0x17 )
          {
            v693 = malloc((v691 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v681[1] = v691;
            v681[2] = (size_t)v693;
            v238 = (__int64 *)a3;
            *v681 = (v691 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v681 = 2 * v691;
            v693 = (char *)v681 + 1;
            if ( !v691 )
              goto LABEL_945;
          }
          memcpy(v693, v692, v691);
LABEL_945:
          *((_BYTE *)v693 + v691) = 0;
LABEL_946:
          v681[3] = 0;
          v694 = v681 + 3;
          v695 = v679 + 48 * v628;
          v681[4] = 0;
          v681[5] = 0;
          v697 = *(_BYTE *)(v695 + 24);
          v696 = v695 + 24;
          if ( (v697 & 1) != 0 )
          {
            v698 = v679 + 48 * v628;
            v699 = *(_QWORD *)(v698 + 32);
            if ( v699 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v700 = *(const void **)(v698 + 40);
            if ( v699 >= 0x17 )
            {
              v701 = malloc((v699 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v681[4] = v699;
              v681[5] = (size_t)v701;
              v238 = (__int64 *)a3;
              v681[3] = (v699 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v694 = 2 * v699;
              v701 = (char *)v681 + 25;
              if ( !v699 )
                goto LABEL_954;
            }
            memcpy(v701, v700, v699);
LABEL_954:
            *((_BYTE *)v701 + v699) = 0;
            goto LABEL_955;
          }
          v681[5] = *(_QWORD *)(v696 + 16);
          *(_OWORD *)v694 = *(_OWORD *)v696;
LABEL_955:
          *(_QWORD *)(v678 - 24) += 48LL;
LABEL_956:
          if ( ++v628 >= v1319 )
            return v1298;
        }
      case 'S':
        if ( v4 + 1 != a2 && v4[1] == 116 )
        {
          v26 = sub_401BC(v4, a2, a3, 0);
          if ( v26 == v4 )
            return v4;
          v227 = *(_QWORD *)(a3 + 8);
          v15 = v4;
          if ( *(_QWORD *)a3 == v227 )
            return v15;
          *(_QWORD *)&v1334 = *(_QWORD *)(a3 + 24);
          sub_42D60(v1322, v227 - 48, (__int64 *)&v1334);
          v228 = *(_QWORD *)(a3 + 40);
          v229 = *(_QWORD *)(a3 + 48);
          if ( v228 < v229 )
          {
            *(_QWORD *)(v228 + 24) = v1324;
            *(_OWORD *)v228 = *(_OWORD *)v1322;
            *(_QWORD *)(v228 + 16) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            *(_QWORD *)(a3 + 40) += 32LL;
            v176 = (void **)v1322[0];
            if ( !v1322[0] )
              return v26;
LABEL_1345:
            v971 = (void **)v1322[1];
            if ( v1322[1] != v176 )
            {
              do
              {
                if ( (*(_BYTE *)(v971 - 3) & 1) != 0 )
                  free(*(v971 - 1));
                v972 = v971 - 6;
                if ( (*(_BYTE *)(v971 - 6) & 1) != 0 )
                  free(*(v971 - 4));
                v971 -= 6;
              }
              while ( v176 != v972 );
            }
            goto LABEL_1595;
          }
          v801 = *(_QWORD *)(a3 + 32);
          v802 = (__int64)(v228 - v801) >> 5;
          if ( (unsigned __int64)(v802 + 1) >> 59 )
            abort();
          v803 = v229 - v801;
          if ( (unsigned __int64)(v803 >> 5) > 0x3FFFFFFFFFFFFFELL )
          {
            v805 = 0x7FFFFFFFFFFFFFFLL;
          }
          else
          {
            v804 = v803 >> 4;
            if ( v804 >= v802 + 1 )
              v805 = v804;
            else
              v805 = v802 + 1;
            if ( !v805 )
            {
              v806 = 0;
LABEL_1254:
              v911 = &v806[32 * v802];
              *((_QWORD *)v911 + 1) = 0;
              *((_QWORD *)v911 + 2) = 0;
              v912 = v911 + 32;
              *((_QWORD *)v911 + 3) = v1324;
              *(_OWORD *)v911 = *(_OWORD *)v1322;
              *((_QWORD *)v911 + 2) = p;
              v1322[1] = 0;
              p = 0;
              v1322[0] = 0;
              v914 = *(void ***)(a3 + 32);
              v913 = *(void ***)(a3 + 40);
              v915 = &v806[32 * v805];
              if ( v913 == v914 )
              {
                v919 = *(void ***)(a3 + 32);
              }
              else
              {
                v916 = (char *)(v913 - 4) - (char *)v914;
                v917 = v911 - 32;
                do
                {
                  *((_QWORD *)v917 + 1) = 0;
                  *((_QWORD *)v917 + 2) = 0;
                  *(_QWORD *)v917 = 0;
                  *((_QWORD *)v917 + 3) = *(v913 - 1);
                  v918 = *((_OWORD *)v913 - 2);
                  v913 -= 4;
                  *(_OWORD *)v917 = v918;
                  *((_QWORD *)v917 + 2) = v913[2];
                  v917 -= 32;
                  *v913 = 0;
                  v913[1] = 0;
                  v913[2] = 0;
                }
                while ( v914 != v913 );
                v919 = *(void ***)(a3 + 32);
                v914 = *(void ***)(a3 + 40);
                v911 = &v806[32 * (v802 - 1 - (v916 >> 5))];
              }
              v921 = *(_QWORD *)(a3 + 48);
              *(_QWORD *)(a3 + 32) = v911;
              *(_QWORD *)(a3 + 40) = v912;
              *(_QWORD *)(a3 + 48) = v915;
              while ( v919 != v914 )
              {
                v914 -= 4;
                sub_42F30(v914);
              }
              if ( v919 )
              {
                v922 = *(_QWORD *)(a3 + 56);
                if ( v922 + 4096 < (unsigned __int64)v919 || v922 > (unsigned __int64)v919 )
                {
                  free(v919);
                }
                else if ( *(_QWORD *)(v922 + 4096) == v921 )
                {
                  *(_QWORD *)(v922 + 4096) = v919;
                  v176 = (void **)v1322[0];
                  if ( !v1322[0] )
                    return v26;
                  goto LABEL_1345;
                }
              }
              v176 = (void **)v1322[0];
              if ( !v1322[0] )
                return v26;
              goto LABEL_1345;
            }
          }
          v889 = *(_QWORD *)(a3 + 56);
          v806 = *(char **)(v889 + 4096);
          if ( v889 + 4096 - (__int64)v806 >= (unsigned __int64)(32 * v805) )
            *(_QWORD *)(v889 + 4096) = &v806[32 * v805];
          else
            v806 = (char *)malloc(32 * v805);
          goto LABEL_1254;
        }
        v239 = sub_43E00(v4, a2, (void **)a3);
        v128 = v239;
        v15 = v4;
        if ( v239 == v4 )
          return v15;
        if ( !*(_BYTE *)(a3 + 111) )
          return v128;
        v4 = sub_42FE0(v239, a2, a3);
        if ( v4 == v128 )
          return v128;
        v240 = *(_QWORD *)(a3 + 8);
        v15 = v128;
        if ( 0xAAAAAAAAAAAAAAABLL * ((v240 - *(_QWORD *)a3) >> 4) < 2 )
          return v15;
        v241 = *(unsigned __int8 *)(v240 - 24);
        if ( (v241 & 1) != 0 )
          v242 = *(const void **)(v240 - 8);
        else
          v242 = (const void *)(v240 - 23);
        if ( (v241 & 1) != 0 )
          v243 = *(_QWORD *)(v240 - 16);
        else
          v243 = v241 >> 1;
        sub_42BE4((size_t *)(v240 - 48), v242, v243);
        v1335 = *(char **)(v240 - 32);
        v1334 = *(_OWORD *)(v240 - 48);
        *(_QWORD *)(v240 - 40) = 0;
        *(_QWORD *)(v240 - 32) = 0;
        *(_QWORD *)(v240 - 48) = 0;
        v244 = *(_QWORD *)(a3 + 8);
        v245 = (_BYTE *)(v244 - 48);
        if ( (*(_BYTE *)(v244 - 24) & 1) != 0 )
          free(*(void **)(v244 - 8));
        if ( (*v245 & 1) != 0 )
          free(*(void **)(v244 - 32));
        *(_QWORD *)(a3 + 8) = v245;
        if ( (v1334 & 1) != 0 )
          v246 = v1335;
        else
          v246 = (char *)&v1334 + 1;
        if ( (v1334 & 1) != 0 )
          v247 = *((_QWORD *)&v1334 + 1);
        else
          v247 = (unsigned __int64)(unsigned __int8)v1334 >> 1;
        sub_42BE4((size_t *)(v244 - 96), v246, v247);
        v248 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1338 = *(_QWORD *)(a3 + 24);
        sub_42D60(v1322, v248, (__int64 *)&v1338);
        v249 = *(_QWORD *)(a3 + 40);
        v250 = *(_QWORD *)(a3 + 48);
        if ( v249 < v250 )
        {
          *(_QWORD *)(v249 + 24) = v1324;
          *(_OWORD *)v249 = *(_OWORD *)v1322;
          *(_QWORD *)(v249 + 16) = p;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          *(_QWORD *)(a3 + 40) += 32LL;
          v251 = (void **)v1322[0];
          if ( !v1322[0] )
            goto LABEL_1459;
          goto LABEL_1447;
        }
        v825 = *(_QWORD *)(a3 + 32);
        v826 = (__int64)(v249 - v825) >> 5;
        if ( (unsigned __int64)(v826 + 1) >> 59 )
          abort();
        v827 = v250 - v825;
        if ( (unsigned __int64)(v827 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v829 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v828 = v827 >> 4;
          if ( v828 >= v826 + 1 )
            v829 = v828;
          else
            v829 = v826 + 1;
          if ( !v829 )
          {
            v830 = 0;
LABEL_1375:
            v977 = &v830[32 * v826];
            *((_QWORD *)v977 + 1) = 0;
            *((_QWORD *)v977 + 2) = 0;
            v978 = v977 + 32;
            *((_QWORD *)v977 + 3) = v1324;
            *(_OWORD *)v977 = *(_OWORD *)v1322;
            *((_QWORD *)v977 + 2) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            v980 = *(void ***)(a3 + 32);
            v979 = *(void ***)(a3 + 40);
            v981 = &v830[32 * v829];
            if ( v979 == v980 )
            {
              v985 = *(void ***)(a3 + 32);
            }
            else
            {
              v982 = (char *)(v979 - 4) - (char *)v980;
              v983 = v977 - 32;
              do
              {
                *((_QWORD *)v983 + 1) = 0;
                *((_QWORD *)v983 + 2) = 0;
                *(_QWORD *)v983 = 0;
                *((_QWORD *)v983 + 3) = *(v979 - 1);
                v984 = *((_OWORD *)v979 - 2);
                v979 -= 4;
                *(_OWORD *)v983 = v984;
                *((_QWORD *)v983 + 2) = v979[2];
                v983 -= 32;
                *v979 = 0;
                v979[1] = 0;
                v979[2] = 0;
              }
              while ( v980 != v979 );
              v985 = *(void ***)(a3 + 32);
              v980 = *(void ***)(a3 + 40);
              v977 = &v830[32 * (v826 - 1 - (v982 >> 5))];
            }
            v996 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v977;
            *(_QWORD *)(a3 + 40) = v978;
            *(_QWORD *)(a3 + 48) = v981;
            while ( v985 != v980 )
            {
              v980 -= 4;
              sub_42F30(v980);
            }
            if ( v985 )
            {
              v997 = *(_QWORD *)(a3 + 56);
              if ( v997 + 4096 < (unsigned __int64)v985 || v997 > (unsigned __int64)v985 )
              {
                free(v985);
              }
              else if ( *(_QWORD *)(v997 + 4096) == v996 )
              {
                *(_QWORD *)(v997 + 4096) = v985;
                v251 = (void **)v1322[0];
                if ( !v1322[0] )
                  goto LABEL_1459;
                goto LABEL_1447;
              }
            }
            v251 = (void **)v1322[0];
            if ( !v1322[0] )
              goto LABEL_1459;
LABEL_1447:
            v1028 = (void **)v1322[1];
            if ( v1322[1] != v251 )
            {
              do
              {
                if ( (*(_BYTE *)(v1028 - 3) & 1) != 0 )
                  free(*(v1028 - 1));
                v1029 = v1028 - 6;
                if ( (*(_BYTE *)(v1028 - 6) & 1) != 0 )
                  free(*(v1028 - 4));
                v1028 -= 6;
              }
              while ( v251 != v1029 );
            }
            v892 = v1324;
            v1322[1] = v251;
            if ( (__int64)v1324 + 4096 >= (unsigned __int64)v251 && (unsigned __int64)v1324 <= (unsigned __int64)v251 )
              goto LABEL_1455;
            goto LABEL_1458;
          }
        }
        v960 = *(_QWORD *)(a3 + 56);
        v830 = *(char **)(v960 + 4096);
        if ( v960 + 4096 - (__int64)v830 >= (unsigned __int64)(32 * v829) )
          *(_QWORD *)(v960 + 4096) = &v830[32 * v829];
        else
          v830 = (char *)malloc(32 * v829);
        goto LABEL_1375;
      case 'T':
        v119 = a3;
        v120 = *(void ***)a3;
        v121 = *(_QWORD *)(a3 + 8);
        v122 = sub_454F4(v4, a2, a3);
        v15 = v4;
        if ( (unsigned __int8 *)v122 == v4 )
          return v15;
        v1298 = (unsigned __int8 *)v122;
        v123 = *(_QWORD **)(a3 + 40);
        v124 = *(_QWORD *)(a3 + 48);
        v125 = *(void ***)a3;
        v126 = *(_QWORD *)(a3 + 8);
        v127 = *(_QWORD *)(a3 + 24);
        if ( (unsigned __int64)v123 < v124 )
        {
          *v123 = 0;
          v123[1] = 0;
          v123[2] = 0;
          v123[3] = v127;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_485;
        }
        v252 = *(_QWORD *)(a3 + 32);
        v253 = ((__int64)v123 - v252) >> 5;
        if ( (unsigned __int64)(v253 + 1) >> 59 )
          goto LABEL_1929;
        v254 = v124 - v252;
        if ( (unsigned __int64)(v254 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v256 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v255 = v254 >> 4;
          if ( v255 >= v253 + 1 )
            v256 = v255;
          else
            v256 = v253 + 1;
          if ( !v256 )
          {
            v257 = 0;
            goto LABEL_406;
          }
        }
        v290 = *(_QWORD *)(a3 + 56);
        v257 = *(char **)(v290 + 4096);
        if ( v290 + 4096 - (__int64)v257 >= (unsigned __int64)(32 * v256) )
          *(_QWORD *)(v290 + 4096) = &v257[32 * v256];
        else
          v257 = (char *)malloc(32 * v256);
LABEL_406:
        v320 = &v257[32 * v253];
        *(_QWORD *)v320 = 0;
        *((_QWORD *)v320 + 1) = 0;
        *((_QWORD *)v320 + 2) = 0;
        *((_QWORD *)v320 + 3) = v127;
        v322 = *(void ***)(a3 + 32);
        v321 = *(void ***)(a3 + 40);
        v323 = &v257[32 * v256];
        v324 = v320 + 32;
        if ( v321 == v322 )
        {
          v328 = *(void ***)(a3 + 32);
        }
        else
        {
          v325 = (char *)(v321 - 4) - (char *)v322;
          v326 = v320 - 32;
          do
          {
            *((_QWORD *)v326 + 1) = 0;
            *((_QWORD *)v326 + 2) = 0;
            *(_QWORD *)v326 = 0;
            *((_QWORD *)v326 + 3) = *(v321 - 1);
            v327 = *((_OWORD *)v321 - 2);
            v321 -= 4;
            *(_OWORD *)v326 = v327;
            *((_QWORD *)v326 + 2) = v321[2];
            v326 -= 32;
            *v321 = 0;
            v321[1] = 0;
            v321[2] = 0;
          }
          while ( v322 != v321 );
          v328 = *(void ***)(a3 + 32);
          v322 = *(void ***)(a3 + 40);
          v320 = &v257[32 * (v253 - 1 - (v325 >> 5))];
        }
        v373 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v320;
        *(_QWORD *)(a3 + 40) = v324;
        *(_QWORD *)(a3 + 48) = v323;
        while ( v328 != v322 )
        {
          v322 -= 4;
          sub_42F30(v322);
        }
        if ( v328 )
        {
          v374 = *(_QWORD *)(a3 + 56);
          if ( v374 + 4096 < (unsigned __int64)v328 || v374 > (unsigned __int64)v328 )
          {
            free(v328);
          }
          else if ( *(_QWORD *)(v374 + 4096) == v373 )
          {
            *(_QWORD *)(v374 + 4096) = v328;
          }
        }
LABEL_485:
        v1317 = 0xAAAAAAAAAAAAAAABLL * ((v126 - (__int64)v125) >> 4);
        v1301 = 0xAAAAAAAAAAAAAAABLL * ((v121 - (__int64)v120) >> 4);
        if ( v1301 < v1317 )
        {
          for ( j = 0xAAAAAAAAAAAAAAABLL * ((v121 - (__int64)v120) >> 4); j < v1317; ++j )
          {
            v411 = *(_QWORD *)(v119 + 40);
            v412 = *(_QWORD *)v119;
            v414 = *(size_t **)(v411 - 24);
            v413 = *(size_t **)(v411 - 16);
            v415 = *(_QWORD *)v119 + 48 * j;
            if ( v414 == v413 )
            {
              v416 = *(_QWORD *)(v411 - 32);
              v417 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v414 - v416) >> 4);
              if ( v417 + 1 > 0x555555555555555LL )
                goto LABEL_1929;
              v418 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v413 - v416) >> 4);
              v419 = 0x555555555555555LL;
              if ( v418 >= 0x2AAAAAAAAAAAAAALL
                || ((v420 = 2 * v418, v420 >= v417 + 1) ? (v419 = v420) : (v419 = v417 + 1), v419) )
              {
                v421 = *(_QWORD *)(v411 - 8);
                v422 = 48 * v419;
                v382 = *(char **)(v421 + 4096);
                if ( v421 + 4096 - (__int64)v382 >= (unsigned __int64)(48 * v419) )
                  *(_QWORD *)(v421 + 4096) = &v382[v422];
                else
                  v382 = (char *)malloc(v422);
              }
              else
              {
                v382 = 0;
              }
              v383 = (size_t *)&v382[48 * v417];
              v383[1] = 0;
              v383[2] = 0;
              *v383 = 0;
              v384 = &v382[48 * v419];
              if ( (*(_BYTE *)v415 & 1) == 0 )
              {
                v383[2] = *(_QWORD *)(v415 + 16);
                *(_OWORD *)v383 = *(_OWORD *)v415;
                goto LABEL_498;
              }
              v385 = v412 + 48 * j;
              v386 = *(_QWORD *)(v385 + 8);
              if ( v386 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v387 = *(const void **)(v385 + 16);
              if ( v386 >= 0x17 )
              {
                v389 = *(const void **)(v385 + 16);
                v390 = malloc((v386 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v387 = v389;
                v388 = v390;
                v391 = &v382[48 * v417];
                *((_QWORD *)v391 + 1) = v386;
                *((_QWORD *)v391 + 2) = v390;
                *v383 = (v386 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              }
              else
              {
                *(_BYTE *)v383 = 2 * v386;
                v388 = (char *)v383 + 1;
                if ( !v386 )
                  goto LABEL_497;
              }
              memcpy(v388, v387, v386);
LABEL_497:
              *((_BYTE *)v388 + v386) = 0;
LABEL_498:
              v392 = &v382[48 * v417];
              *((_QWORD *)v392 + 3) = 0;
              v393 = v392 + 24;
              v394 = v412 + 48 * j;
              *((_QWORD *)v393 + 1) = 0;
              *((_QWORD *)v393 + 2) = 0;
              v396 = *(_BYTE *)(v394 + 24);
              v395 = v394 + 24;
              if ( (v396 & 1) == 0 )
              {
                *((_QWORD *)v393 + 2) = *(_QWORD *)(v395 + 16);
                *(_OWORD *)v393 = *(_OWORD *)v395;
LABEL_507:
                v404 = *(void ***)(v411 - 32);
                v403 = *(void ***)(v411 - 24);
                v405 = v383 + 6;
                if ( v403 == v404 )
                {
                  v407 = *(void ***)(v411 - 32);
                }
                else
                {
                  do
                  {
                    *(v383 - 4) = (size_t)*(v403 - 4);
                    *((_OWORD *)v383 - 3) = *((_OWORD *)v403 - 3);
                    v406 = (size_t)*(v403 - 1);
                    *(v403 - 5) = 0;
                    *(v403 - 4) = 0;
                    *(v403 - 6) = 0;
                    *(v383 - 1) = v406;
                    *(_OWORD *)(v383 - 3) = *(_OWORD *)(v403 - 3);
                    *(v403 - 3) = 0;
                    *(v403 - 2) = 0;
                    *(v403 - 1) = 0;
                    v403 -= 6;
                    v383 -= 6;
                  }
                  while ( v404 != v403 );
                  v407 = *(void ***)(v411 - 32);
                  v404 = *(void ***)(v411 - 24);
                }
                v408 = *(_QWORD *)(v411 - 16);
                *(_QWORD *)(v411 - 32) = v383;
                *(_QWORD *)(v411 - 24) = v405;
                *(_QWORD *)(v411 - 16) = v384;
                if ( v404 != v407 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v404 - 3) & 1) != 0 )
                      free(*(v404 - 1));
                    v409 = v404 - 6;
                    if ( (*(_BYTE *)(v404 - 6) & 1) != 0 )
                      free(*(v404 - 4));
                    v404 -= 6;
                  }
                  while ( v407 != v409 );
                }
                if ( v407 )
                {
                  v410 = *(_QWORD *)(v411 - 8);
                  if ( v410 + 4096 < (unsigned __int64)v407 || v410 > (unsigned __int64)v407 )
                  {
                    free(v407);
                  }
                  else if ( *(_QWORD *)(v410 + 4096) == v408 )
                  {
                    *(_QWORD *)(v410 + 4096) = v407;
                  }
                }
                goto LABEL_551;
              }
              v397 = v412 + 48 * j;
              v1311 = v384;
              v398 = *(_QWORD *)(v397 + 32);
              if ( v398 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v399 = *(const void **)(v397 + 40);
              if ( v398 >= 0x17 )
              {
                v401 = malloc((v398 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v402 = &v382[48 * v417];
                *((_QWORD *)v402 + 4) = v398;
                *((_QWORD *)v402 + 5) = v401;
                *(_QWORD *)v393 = (v398 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                v400 = v401;
              }
              else
              {
                *v393 = 2 * v398;
                v400 = v393 + 1;
                if ( !v398 )
                  goto LABEL_506;
              }
              memcpy(v400, v399, v398);
LABEL_506:
              *((_BYTE *)v400 + v398) = 0;
              v384 = v1311;
              goto LABEL_507;
            }
            v414[1] = 0;
            v414[2] = 0;
            *v414 = 0;
            if ( (*(_BYTE *)v415 & 1) == 0 )
            {
              v414[2] = *(_QWORD *)(v415 + 16);
              *(_OWORD *)v414 = *(_OWORD *)v415;
              goto LABEL_541;
            }
            v423 = v412 + 48 * j;
            v424 = *(_QWORD *)(v423 + 8);
            if ( v424 >= 0xFFFFFFFFFFFFFFF0LL )
              goto LABEL_1929;
            v425 = *(const void **)(v423 + 16);
            if ( v424 >= 0x17 )
            {
              v426 = malloc((v424 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v414[1] = v424;
              v414[2] = (size_t)v426;
              *v414 = (v424 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v414 = 2 * v424;
              v426 = (char *)v414 + 1;
              if ( !v424 )
                goto LABEL_540;
            }
            memcpy(v426, v425, v424);
LABEL_540:
            *((_BYTE *)v426 + v424) = 0;
LABEL_541:
            v414[3] = 0;
            v427 = v414 + 3;
            v428 = v412 + 48 * j;
            v414[4] = 0;
            v414[5] = 0;
            v430 = *(_BYTE *)(v428 + 24);
            v429 = v428 + 24;
            if ( (v430 & 1) != 0 )
            {
              v431 = v412 + 48 * j;
              v432 = *(_QWORD *)(v431 + 32);
              if ( v432 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v433 = *(const void **)(v431 + 40);
              if ( v432 >= 0x17 )
              {
                v434 = malloc((v432 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v414[4] = v432;
                v414[5] = (size_t)v434;
                v414[3] = (v432 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              }
              else
              {
                *v427 = 2 * v432;
                v434 = (char *)v414 + 25;
                if ( !v432 )
                  goto LABEL_549;
              }
              memcpy(v434, v433, v432);
LABEL_549:
              *((_BYTE *)v434 + v432) = 0;
              goto LABEL_550;
            }
            v414[5] = *(_QWORD *)(v429 + 16);
            *(_OWORD *)v427 = *(_OWORD *)v429;
LABEL_550:
            *(_QWORD *)(v411 - 24) += 48LL;
LABEL_551:
            v119 = a3;
          }
        }
        if ( v1317 != v1301 + 1 )
          return v1298;
        v15 = v1298;
        if ( !*(_BYTE *)(v119 + 111) )
          return v15;
        v4 = sub_42FE0(v1298, a2, v119);
        if ( v4 == v1298 )
          return v15;
        v435 = *(_QWORD *)(v119 + 8);
        v436 = *(unsigned __int8 *)(v435 - 24);
        if ( (v436 & 1) != 0 )
          v437 = *(const void **)(v435 - 8);
        else
          v437 = (const void *)(v435 - 23);
        if ( (v436 & 1) != 0 )
          v438 = *(_QWORD *)(v435 - 16);
        else
          v438 = v436 >> 1;
        sub_42BE4((size_t *)(v435 - 48), v437, v438);
        v1335 = *(char **)(v435 - 32);
        v1334 = *(_OWORD *)(v435 - 48);
        *(_QWORD *)(v435 - 40) = 0;
        *(_QWORD *)(v435 - 32) = 0;
        *(_QWORD *)(v435 - 48) = 0;
        v439 = *(_QWORD *)(v119 + 8);
        v440 = (_BYTE *)(v439 - 48);
        if ( (*(_BYTE *)(v439 - 24) & 1) != 0 )
          free(*(void **)(v439 - 8));
        if ( (*v440 & 1) != 0 )
          free(*(void **)(v439 - 32));
        *(_QWORD *)(v119 + 8) = v440;
        if ( (v1334 & 1) != 0 )
          v441 = v1335;
        else
          v441 = (char *)&v1334 + 1;
        if ( (v1334 & 1) != 0 )
          v442 = *((_QWORD *)&v1334 + 1);
        else
          v442 = (unsigned __int64)(unsigned __int8)v1334 >> 1;
        sub_42BE4((size_t *)(v439 - 96), v441, v442);
        v443 = *(_QWORD *)(v119 + 8) - 48LL;
        *(_QWORD *)&v1338 = *(_QWORD *)(v119 + 24);
        sub_42D60(v1322, v443, (__int64 *)&v1338);
        v444 = *(_QWORD *)(v119 + 40);
        v445 = *(_QWORD *)(v119 + 48);
        if ( v444 < v445 )
        {
          *(_QWORD *)(v444 + 24) = v1324;
          *(_OWORD *)v444 = *(_OWORD *)v1322;
          *(_QWORD *)(v444 + 16) = p;
          v1322[1] = 0;
          p = 0;
          v1322[0] = 0;
          *(_QWORD *)(v119 + 40) += 32LL;
          v251 = (void **)v1322[0];
          if ( !v1322[0] )
            goto LABEL_1459;
          goto LABEL_1222;
        }
        v702 = *(_QWORD *)(v119 + 32);
        v703 = (__int64)(v444 - v702) >> 5;
        if ( (unsigned __int64)(v703 + 1) >> 59 )
          abort();
        v704 = v445 - v702;
        if ( (unsigned __int64)(v704 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v706 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v705 = v704 >> 4;
          if ( v705 >= v703 + 1 )
            v706 = v705;
          else
            v706 = v703 + 1;
          if ( !v706 )
          {
            v707 = 0;
LABEL_1134:
            v831 = &v707[32 * v703];
            *((_QWORD *)v831 + 1) = 0;
            *((_QWORD *)v831 + 2) = 0;
            v832 = v831 + 32;
            *((_QWORD *)v831 + 3) = v1324;
            *(_OWORD *)v831 = *(_OWORD *)v1322;
            *((_QWORD *)v831 + 2) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            v834 = *(void ***)(v119 + 32);
            v833 = *(void ***)(v119 + 40);
            v835 = &v707[32 * v706];
            if ( v833 == v834 )
            {
              v839 = *(void ***)(v119 + 32);
            }
            else
            {
              v836 = (char *)(v833 - 4) - (char *)v834;
              v837 = v831 - 32;
              do
              {
                *((_QWORD *)v837 + 1) = 0;
                *((_QWORD *)v837 + 2) = 0;
                *(_QWORD *)v837 = 0;
                *((_QWORD *)v837 + 3) = *(v833 - 1);
                v838 = *((_OWORD *)v833 - 2);
                v833 -= 4;
                *(_OWORD *)v837 = v838;
                *((_QWORD *)v837 + 2) = v833[2];
                v837 -= 32;
                *v833 = 0;
                v833[1] = 0;
                v833[2] = 0;
              }
              while ( v834 != v833 );
              v839 = *(void ***)(v119 + 32);
              v834 = *(void ***)(v119 + 40);
              v831 = &v707[32 * (v703 - 1 - (v836 >> 5))];
            }
            v846 = *(_QWORD *)(v119 + 48);
            *(_QWORD *)(v119 + 32) = v831;
            *(_QWORD *)(v119 + 40) = v832;
            *(_QWORD *)(v119 + 48) = v835;
            while ( v839 != v834 )
            {
              v834 -= 4;
              sub_42F30(v834);
            }
            if ( v839 )
            {
              v847 = *(_QWORD *)(v119 + 56);
              if ( v847 + 4096 < (unsigned __int64)v839 || v847 > (unsigned __int64)v839 )
              {
                free(v839);
              }
              else if ( *(_QWORD *)(v847 + 4096) == v846 )
              {
                *(_QWORD *)(v847 + 4096) = v839;
                v251 = (void **)v1322[0];
                if ( !v1322[0] )
                  goto LABEL_1459;
LABEL_1222:
                v890 = (void **)v1322[1];
                if ( v1322[1] != v251 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v890 - 3) & 1) != 0 )
                      free(*(v890 - 1));
                    v891 = v890 - 6;
                    if ( (*(_BYTE *)(v890 - 6) & 1) != 0 )
                      free(*(v890 - 4));
                    v890 -= 6;
                  }
                  while ( v251 != v891 );
                }
                v892 = v1324;
                v1322[1] = v251;
                if ( (__int64)v1324 + 4096 >= (unsigned __int64)v251
                  && (unsigned __int64)v1324 <= (unsigned __int64)v251 )
                {
LABEL_1455:
                  if ( *(void **)(v892 + 4096) == p )
                  {
                    *(_QWORD *)(v892 + 4096) = v251;
                    if ( (v1334 & 1) == 0 )
                      return v4;
                    goto LABEL_1460;
                  }
LABEL_1459:
                  if ( (v1334 & 1) == 0 )
                    return v4;
LABEL_1460:
                  free(v1335);
                  return v4;
                }
LABEL_1458:
                free(v251);
                goto LABEL_1459;
              }
            }
            v251 = (void **)v1322[0];
            if ( !v1322[0] )
              goto LABEL_1459;
            goto LABEL_1222;
          }
        }
        v824 = *(_QWORD *)(v119 + 56);
        v707 = *(char **)(v824 + 4096);
        if ( v824 + 4096 - (__int64)v707 >= (unsigned __int64)(32 * v706) )
          *(_QWORD *)(v824 + 4096) = &v707[32 * v706];
        else
          v707 = (char *)malloc(32 * v706);
        goto LABEL_1134;
      case 'U':
        if ( v4 + 1 == a2 )
          return v4;
        v158 = (_QWORD *)a3;
        v159 = sub_57438(v4 + 1, a2, (void **)a3);
        v160 = v159;
        if ( v159 == v4 + 1 )
          return v4;
        v26 = (unsigned __int8 *)sub_38008(v159, a2, a3);
        if ( v26 == v160 )
          return v4;
        v161 = *(_QWORD *)(a3 + 8);
        v15 = v4;
        if ( 0xAAAAAAAAAAAAAAABLL * ((v161 - *(_QWORD *)a3) >> 4) < 2 )
          return v15;
        v162 = *(unsigned __int8 *)(v161 - 24);
        if ( (v162 & 1) != 0 )
          v163 = *(const void **)(v161 - 8);
        else
          v163 = (const void *)(v161 - 23);
        if ( (v162 & 1) != 0 )
          v164 = *(_QWORD *)(v161 - 16);
        else
          v164 = v162 >> 1;
        sub_42BE4((size_t *)(v161 - 48), v163, v164);
        v1335 = *(char **)(v161 - 32);
        v1334 = *(_OWORD *)(v161 - 48);
        *(_QWORD *)(v161 - 40) = 0;
        *(_QWORD *)(v161 - 32) = 0;
        *(_QWORD *)(v161 - 48) = 0;
        v165 = *(_QWORD *)(a3 + 8);
        v166 = (_BYTE *)(v165 - 48);
        if ( (*(_BYTE *)(v165 - 24) & 1) != 0 )
          free(*(void **)(v165 - 8));
        if ( (*v166 & 1) != 0 )
          free(*(void **)(v165 - 32));
        *(_QWORD *)(a3 + 8) = v166;
        v1322[0] = 0;
        v1322[1] = 0;
        p = 0;
        v167 = *(unsigned __int8 *)(v165 - 96);
        v168 = (v167 & 1) == 0;
        if ( (v167 & 1) != 0 )
          v169 = *(_QWORD *)(v165 - 88);
        else
          v169 = v167 >> 1;
        if ( v168 )
          v170 = (const void *)(v165 - 95);
        else
          v170 = *(const void **)(v165 - 80);
        if ( v169 >= 9 )
          v171 = 9;
        else
          v171 = v169;
        LOBYTE(v1322[0]) = 2 * v171;
        if ( v171 )
          memcpy((char *)v1322 + 1, v170, v171);
        *((_BYTE *)v1322 + v171 + 1) = 0;
        v733 = (char *)v1322[1];
        if ( ((__int64)v1322[0] & 1) == 0 )
          v733 = (char *)((unsigned __int64)LOBYTE(v1322[0]) >> 1);
        if ( v733 == byte_9 )
        {
          if ( ((__int64)v1322[0] & 1) != 0 )
            v734 = (char *)p;
          else
            v734 = (char *)v1322 + 1;
          v735 = memcmp(v734, "objcproto", 9u) != 0;
          if ( ((__int64)v1322[0] & 1) != 0 )
            goto LABEL_1006;
        }
        else
        {
          v735 = 1;
          if ( ((__int64)v1322[0] & 1) != 0 )
LABEL_1006:
            free(p);
        }
        if ( v735 )
        {
          sub_50A9C((unsigned __int8 *)&v1334, " ", (size_t *)&v1338);
          v736 = *(_QWORD *)(a3 + 8);
          v737 = *(unsigned __int8 *)(v736 - 24);
          v738 = *(_QWORD *)(v736 - 16);
          v739 = *(const void **)(v736 - 8);
          v740 = (size_t *)(v736 - 48);
          v741 = (const void *)(v736 - 23);
          if ( (v737 & 1) != 0 )
            v742 = v739;
          else
            v742 = v741;
          if ( (v737 & 1) != 0 )
            v743 = v738;
          else
            v743 = v737 >> 1;
          v744 = sub_42BE4(v740, v742, v743);
          v1333 = (char *)v744[2];
          v1332 = *(_OWORD *)v744;
          v744[1] = 0;
          v744[2] = 0;
          *v744 = 0;
          v745 = v1332;
          v746 = v1333;
          if ( (v1332 & 1) != 0 )
            v747 = v1333;
          else
            v747 = (char *)&v1332 + 1;
          if ( (v1332 & 1) != 0 )
            v748 = *((_QWORD *)&v1332 + 1);
          else
            v748 = (unsigned __int64)(unsigned __int8)v1332 >> 1;
          sub_42BE4((size_t *)&v1338, v747, v748);
          v749 = *(void **)((char *)&v1338 + 1);
          v750 = *((_QWORD *)&v1338 + 1);
          v751 = v1339;
          v752 = v1338;
          v1338 = 0u;
          v1339 = 0;
          *(_QWORD *)&v1329[23] = v750;
          v1329[23] = HIBYTE(v749);
          LOBYTE(v1322[0]) = v752;
          v753 = v749;
          v754 = *(void **)&v1329[23];
          memset(&v1329[16], 0, 15);
          *(void **)((char *)v1322 + 1) = v753;
          v1322[1] = v754;
          p = v751;
          v1325 = 0;
          v1324 = 0u;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)v1322);
          if ( (v1324 & 1) != 0 )
          {
            free(v1325);
            if ( ((__int64)v1322[0] & 1) == 0 )
            {
LABEL_1022:
              if ( (v745 & 1) == 0 )
                goto LABEL_1739;
              goto LABEL_1233;
            }
          }
          else if ( ((__int64)v1322[0] & 1) == 0 )
          {
            goto LABEL_1022;
          }
          free(p);
          if ( (v745 & 1) == 0 )
            goto LABEL_1739;
LABEL_1233:
          v893 = v746;
          goto LABEL_1360;
        }
        v755 = *(_QWORD *)(a3 + 8);
        v756 = *(unsigned __int8 *)(v755 - 24);
        v757 = *(_QWORD *)(v755 - 16);
        v758 = *(const void **)(v755 - 8);
        v759 = (size_t *)(v755 - 48);
        v760 = (const void *)(v755 - 23);
        if ( (v756 & 1) != 0 )
          v761 = v758;
        else
          v761 = v760;
        if ( (v756 & 1) != 0 )
          v762 = v757;
        else
          v762 = v756 >> 1;
        v763 = sub_42BE4(v759, v761, v762);
        v1339 = (unsigned __int16 *)v763[2];
        v1338 = *(_OWORD *)v763;
        v763[1] = 0;
        v763[2] = 0;
        *v763 = 0;
        v764 = *(_QWORD *)(a3 + 8);
        v765 = (_BYTE *)(v764 - 48);
        if ( (*(_BYTE *)(v764 - 24) & 1) != 0 )
          free(*(void **)(v764 - 8));
        if ( (*v765 & 1) != 0 )
          free(*(void **)(v764 - 32));
        *(_QWORD *)(a3 + 8) = v765;
        v766 = (unsigned __int64)(unsigned __int8)v1338 >> 1;
        if ( (v1338 & 1) != 0 )
          v767 = (unsigned __int8 *)v1339;
        else
          v767 = (unsigned __int8 *)&v1338 + 1;
        if ( (v1338 & 1) != 0 )
          v766 = *((_QWORD *)&v1338 + 1);
        v768 = sub_57438(v767 + 9, &v767[v766], (void **)a3);
        if ( (v1338 & 1) != 0 )
          v769 = (char *)v1339;
        else
          v769 = (char *)&v1338 + 1;
        if ( v768 != (unsigned __int8 *)(v769 + 9) )
        {
          sub_50A9C((unsigned __int8 *)&v1334, "<", (size_t *)&v1330);
          v770 = *(_QWORD *)(a3 + 8);
          v771 = *(unsigned __int8 *)(v770 - 24);
          v772 = *(_QWORD *)(v770 - 16);
          v773 = *(const void **)(v770 - 8);
          v774 = (size_t *)(v770 - 48);
          v775 = (const void *)(v770 - 23);
          if ( (v771 & 1) != 0 )
            v776 = v773;
          else
            v776 = v775;
          if ( (v771 & 1) != 0 )
            v777 = v772;
          else
            v777 = v771 >> 1;
          v778 = sub_42BE4(v774, v776, v777);
          v1328 = (char *)v778[2];
          v1327 = *(_OWORD *)v778;
          v778[1] = 0;
          v778[2] = 0;
          *v778 = 0;
          v779 = v1327;
          v780 = v1328;
          if ( (v1327 & 1) != 0 )
            v781 = v1328;
          else
            v781 = (char *)&v1327 + 1;
          if ( (v1327 & 1) != 0 )
            v782 = *((_QWORD *)&v1327 + 1);
          else
            v782 = (unsigned __int64)(unsigned __int8)v1327 >> 1;
          sub_42BE4((size_t *)&v1330, v781, v782);
          v783 = (char *)v1331;
          v784 = v1330;
          v1330 = 0u;
          v1331 = 0;
          v1333 = v783;
          v1332 = v784;
          sub_42BE4((size_t *)&v1332, ">", 1u);
          v785 = *(void **)((char *)&v1332 + 1);
          v786 = *((_QWORD *)&v1332 + 1);
          v787 = v1333;
          v788 = v1332;
          v1332 = 0u;
          v1333 = 0;
          *(_QWORD *)&v1329[7] = v786;
          v1329[7] = HIBYTE(v785);
          LOBYTE(v1322[0]) = v788;
          v789 = v785;
          v790 = *(void **)&v1329[7];
          memset(v1329, 0, 15);
          *(void **)((char *)v1322 + 1) = v789;
          v1322[1] = v790;
          p = v787;
          v1325 = 0;
          v1324 = 0u;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)v1322);
          if ( (v1324 & 1) != 0 )
          {
            free(v1325);
            if ( ((__int64)v1322[0] & 1) == 0 )
            {
LABEL_1059:
              if ( (v1332 & 1) == 0 )
                goto LABEL_1060;
              goto LABEL_1357;
            }
          }
          else if ( ((__int64)v1322[0] & 1) == 0 )
          {
            goto LABEL_1059;
          }
          free(p);
          if ( (v1332 & 1) == 0 )
          {
LABEL_1060:
            if ( (v779 & 1) == 0 )
              goto LABEL_1061;
            goto LABEL_1358;
          }
LABEL_1357:
          free(v1333);
          if ( (v779 & 1) == 0 )
          {
LABEL_1061:
            if ( (v1330 & 1) == 0 )
            {
LABEL_1739:
              if ( (v1338 & 1) == 0 )
                goto LABEL_1741;
              goto LABEL_1740;
            }
            goto LABEL_1359;
          }
LABEL_1358:
          free(v780);
          if ( (v1330 & 1) == 0 )
            goto LABEL_1739;
LABEL_1359:
          v893 = v1331;
LABEL_1360:
          free(v893);
          if ( (v1338 & 1) == 0 )
          {
LABEL_1741:
            v1185 = v158[1] - 48LL;
            *(_QWORD *)&v1338 = v158[3];
            sub_42D60(v1322, v1185, (__int64 *)&v1338);
            v1186 = v158[5];
            v1187 = v158[6];
            if ( v1186 < v1187 )
            {
              *(_QWORD *)(v1186 + 24) = v1324;
              *(_OWORD *)v1186 = *(_OWORD *)v1322;
              *(_QWORD *)(v1186 + 16) = p;
              v1322[1] = 0;
              p = 0;
              v1322[0] = 0;
              v158[5] += 32LL;
              v1188 = (void **)v1322[0];
              if ( !v1322[0] )
                goto LABEL_1782;
              goto LABEL_1770;
            }
            v1189 = v158[4];
            v1190 = (__int64)(v1186 - v1189) >> 5;
            if ( (unsigned __int64)(v1190 + 1) >> 59 )
              abort();
            v1191 = v1187 - v1189;
            if ( (unsigned __int64)(v1191 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v1193 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v1192 = v1191 >> 4;
              if ( v1192 >= v1190 + 1 )
                v1193 = v1192;
              else
                v1193 = v1190 + 1;
              if ( !v1193 )
              {
                v1194 = 0;
                goto LABEL_1755;
              }
            }
            v1195 = v158[7];
            v1194 = *(char **)(v1195 + 4096);
            if ( v1195 + 4096 - (__int64)v1194 >= (unsigned __int64)(32 * v1193) )
              *(_QWORD *)(v1195 + 4096) = &v1194[32 * v1193];
            else
              v1194 = (char *)malloc(32 * v1193);
LABEL_1755:
            v1196 = &v1194[32 * v1190];
            *((_QWORD *)v1196 + 1) = 0;
            *((_QWORD *)v1196 + 2) = 0;
            v1197 = v1196 + 32;
            *((_QWORD *)v1196 + 3) = v1324;
            *(_OWORD *)v1196 = *(_OWORD *)v1322;
            *((_QWORD *)v1196 + 2) = p;
            v1322[1] = 0;
            p = 0;
            v1322[0] = 0;
            v1199 = (void **)v158[4];
            v1198 = (void **)v158[5];
            v1200 = &v1194[32 * v1193];
            if ( v1198 == v1199 )
            {
              v1204 = (void **)v158[4];
            }
            else
            {
              v1201 = (char *)(v1198 - 4) - (char *)v1199;
              v1202 = v1196 - 32;
              do
              {
                *((_QWORD *)v1202 + 1) = 0;
                *((_QWORD *)v1202 + 2) = 0;
                *(_QWORD *)v1202 = 0;
                *((_QWORD *)v1202 + 3) = *(v1198 - 1);
                v1203 = *((_OWORD *)v1198 - 2);
                v1198 -= 4;
                *(_OWORD *)v1202 = v1203;
                *((_QWORD *)v1202 + 2) = v1198[2];
                v1202 -= 32;
                *v1198 = 0;
                v1198[1] = 0;
                v1198[2] = 0;
              }
              while ( v1199 != v1198 );
              v1204 = (void **)v158[4];
              v1199 = (void **)v158[5];
              v1196 = &v1194[32 * (v1190 - 1 - (v1201 >> 5))];
            }
            v1205 = v158[6];
            v158[4] = v1196;
            v158[5] = v1197;
            v158[6] = v1200;
            while ( v1204 != v1199 )
            {
              v1199 -= 4;
              sub_42F30(v1199);
            }
            if ( v1204 )
            {
              v1206 = v158[7];
              if ( v1206 + 4096 < (unsigned __int64)v1204 || v1206 > (unsigned __int64)v1204 )
              {
                free(v1204);
              }
              else if ( *(_QWORD *)(v1206 + 4096) == v1205 )
              {
                *(_QWORD *)(v1206 + 4096) = v1204;
                v1188 = (void **)v1322[0];
                if ( !v1322[0] )
                  goto LABEL_1782;
                goto LABEL_1770;
              }
            }
            v1188 = (void **)v1322[0];
            if ( !v1322[0] )
              goto LABEL_1782;
LABEL_1770:
            v1207 = (void **)v1322[1];
            if ( v1322[1] != v1188 )
            {
              do
              {
                if ( (*(_BYTE *)(v1207 - 3) & 1) != 0 )
                  free(*(v1207 - 1));
                v1208 = v1207 - 6;
                if ( (*(_BYTE *)(v1207 - 6) & 1) != 0 )
                  free(*(v1207 - 4));
                v1207 -= 6;
              }
              while ( v1188 != v1208 );
            }
            v1322[1] = v1188;
            if ( (__int64)v1324 + 4096 < (unsigned __int64)v1188 || (unsigned __int64)v1324 > (unsigned __int64)v1188 )
            {
              free(v1188);
            }
            else if ( *(void **)(v1324 + 4096) == p )
            {
              *(_QWORD *)(v1324 + 4096) = v1188;
              if ( (v1334 & 1) == 0 )
                return v26;
              goto LABEL_1783;
            }
LABEL_1782:
            if ( (v1334 & 1) == 0 )
              return v26;
LABEL_1783:
            v1119 = (void **)v1335;
            goto LABEL_1600;
          }
LABEL_1740:
          free(v1339);
          goto LABEL_1741;
        }
        sub_50A9C((unsigned __int8 *)&v1334, " ", (size_t *)v1322);
        if ( (v1338 & 1) != 0 )
          v923 = (char *)v1339;
        else
          v923 = (char *)&v1338 + 1;
        if ( (v1338 & 1) != 0 )
          v924 = *((_QWORD *)&v1338 + 1);
        else
          v924 = (unsigned __int64)(unsigned __int8)v1338 >> 1;
        sub_42BE4((size_t *)v1322, v923, v924);
        v925 = *(__int64 *)((char *)v1322 + 1);
        v926 = v1322[1];
        v927 = p;
        v928 = (char)v1322[0];
        v1322[0] = 0;
        v1322[1] = 0;
        *(_QWORD *)((char *)v1326 + 7) = v926;
        v1326[0] = v925;
        v929 = *(_QWORD *)((char *)v1326 + 7);
        v930 = v1326[0];
        p = 0;
        *(_QWORD *)((char *)&v1330 + 7) = 0;
        *(_QWORD *)&v1330 = 0;
        memset(v1326, 0, 15);
        *(_QWORD *)((char *)&v1332 + 7) = v929;
        *(_QWORD *)&v1332 = v930;
        v931 = *(_QWORD *)(a3 + 8);
        v932 = *(_QWORD *)(a3 + 16);
        if ( v931 < v932 )
        {
          *(_BYTE *)v931 = v928;
          *(_QWORD *)(v931 + 8) = *(_QWORD *)((char *)&v1332 + 7);
          *(_QWORD *)(v931 + 16) = v927;
          *(_QWORD *)(v931 + 1) = v1332;
          *(_QWORD *)((char *)&v1332 + 7) = 0;
          *(_QWORD *)&v1332 = 0;
          *(_BYTE *)(v931 + 24) = 0;
          *(_QWORD *)(v931 + 32) = *(_QWORD *)((char *)&v1330 + 7);
          *(_QWORD *)(v931 + 40) = 0;
          *(_QWORD *)(v931 + 25) = v1330;
          *(_QWORD *)((char *)&v1330 + 7) = 0;
          *(_QWORD *)&v1330 = 0;
          *(_QWORD *)(a3 + 8) += 48LL;
          if ( ((__int64)v1322[0] & 1) == 0 )
            goto LABEL_1738;
          goto LABEL_1737;
        }
        v1089 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v931 - *(_QWORD *)a3) >> 4);
        v1090 = 0x555555555555555LL;
        if ( v1089 + 1 > 0x555555555555555LL )
          abort();
        v1091 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v932 - *(_QWORD *)a3) >> 4);
        if ( v1091 >= 0x2AAAAAAAAAAAAAALL
          || ((v1092 = 2 * v1091, v1092 >= v1089 + 1) ? (v1090 = v1092) : (v1090 = v1089 + 1), v1090) )
        {
          v1093 = *(_QWORD *)(a3 + 24);
          v1094 = *(char **)(v1093 + 4096);
          if ( v1093 + 4096 - (__int64)v1094 >= (unsigned __int64)(48 * v1090) )
            *(_QWORD *)(v1093 + 4096) = &v1094[48 * v1090];
          else
            v1094 = (char *)malloc(48 * v1090);
        }
        else
        {
          v1094 = 0;
        }
        v1175 = &v1094[48 * v1089];
        *v1175 = v928;
        v1176 = &v1094[48 * v1090];
        *((_QWORD *)v1175 + 1) = *(_QWORD *)((char *)&v1332 + 7);
        *((_QWORD *)v1175 + 2) = v927;
        *(_QWORD *)(v1175 + 1) = v1332;
        *(_QWORD *)((char *)&v1332 + 7) = 0;
        *(_QWORD *)&v1332 = 0;
        v1175[24] = 0;
        *((_QWORD *)v1175 + 4) = *(_QWORD *)((char *)&v1330 + 7);
        *((_QWORD *)v1175 + 5) = 0;
        *(_QWORD *)(v1175 + 25) = v1330;
        *(_QWORD *)((char *)&v1330 + 7) = 0;
        *(_QWORD *)&v1330 = 0;
        v1178 = *(void ***)a3;
        v1177 = *(void ***)(a3 + 8);
        v1179 = v1175 + 48;
        if ( v1177 == *(void ***)a3 )
        {
          v1181 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v1175 - 4) = *(v1177 - 4);
            *((_OWORD *)v1175 - 3) = *((_OWORD *)v1177 - 3);
            v1180 = (__int64)*(v1177 - 1);
            *(v1177 - 5) = 0;
            *(v1177 - 4) = 0;
            *(v1177 - 6) = 0;
            *((_QWORD *)v1175 - 1) = v1180;
            *(_OWORD *)(v1175 - 24) = *(_OWORD *)(v1177 - 3);
            *(v1177 - 3) = 0;
            *(v1177 - 2) = 0;
            *(v1177 - 1) = 0;
            v1177 -= 6;
            v1175 -= 48;
          }
          while ( v1178 != v1177 );
          v1181 = *(void ***)a3;
          v1178 = *(void ***)(a3 + 8);
        }
        v1182 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v1175;
        *(_QWORD *)(a3 + 8) = v1179;
        *(_QWORD *)(a3 + 16) = v1176;
        if ( v1178 != v1181 )
        {
          do
          {
            if ( (*(_BYTE *)(v1178 - 3) & 1) != 0 )
              free(*(v1178 - 1));
            v1183 = v1178 - 6;
            if ( (*(_BYTE *)(v1178 - 6) & 1) != 0 )
              free(*(v1178 - 4));
            v1178 -= 6;
          }
          while ( v1181 != v1183 );
        }
        if ( !v1181 )
          goto LABEL_1736;
        v1184 = *(_QWORD *)(a3 + 24);
        if ( v1184 + 4096 < (unsigned __int64)v1181 || v1184 > (unsigned __int64)v1181 )
        {
          free(v1181);
        }
        else if ( *(_QWORD *)(v1184 + 4096) == v1182 )
        {
          *(_QWORD *)(v1184 + 4096) = v1181;
          if ( ((__int64)v1322[0] & 1) == 0 )
            goto LABEL_1738;
          goto LABEL_1737;
        }
LABEL_1736:
        if ( ((__int64)v1322[0] & 1) == 0 )
        {
LABEL_1738:
          v158 = (_QWORD *)a3;
          goto LABEL_1739;
        }
LABEL_1737:
        free(p);
        goto LABEL_1738;
      default:
        goto LABEL_1293;
    }
  }
LABEL_6:
  if ( v6 == 86 )
  {
    v8 = *++v7;
    v6 = v8;
    v1314 |= 2u;
  }
LABEL_8:
  if ( v6 == 75 )
    v9 = v7 + 1;
  else
    v9 = v7;
  if ( v9 == a1 )
    return v4;
  v10 = *v9;
  v11 = *(void ***)a3;
  v12 = *(_QWORD *)(a3 + 8);
  v13 = sub_38008(v9, a2, a3);
  v14 = (__int64 *)a3;
  v15 = v4;
  if ( (unsigned __int8 *)v13 == v9 )
    return v15;
  v1293 = v13;
  v1300 = v6;
  v16 = *(void ***)a3;
  v17 = v14[1];
  v18 = v14[5];
  v19 = v14;
  if ( v10 == 70 )
  {
    v18 -= 32LL;
    sub_42F30((void **)v18);
    v19[5] = v18;
  }
  v20 = v19[6];
  v21 = v19[3];
  v22 = v1314;
  v1307 = v10;
  if ( v18 >= v20 )
  {
    v36 = v19[4];
    v37 = (__int64)(v18 - v36) >> 5;
    if ( !((unsigned __int64)(v37 + 1) >> 59) )
    {
      v38 = v20 - v36;
      if ( (unsigned __int64)(v38 >> 5) > 0x3FFFFFFFFFFFFFELL )
      {
        v40 = 0x7FFFFFFFFFFFFFFLL;
      }
      else
      {
        v39 = v38 >> 4;
        if ( v39 >= v37 + 1 )
          v40 = v39;
        else
          v40 = v37 + 1;
        if ( !v40 )
        {
          v41 = 0;
          goto LABEL_46;
        }
      }
      v42 = v19[7];
      v41 = *(char **)(v42 + 4096);
      if ( v42 + 4096 - (__int64)v41 >= (unsigned __int64)(32 * v40) )
        *(_QWORD *)(v42 + 4096) = &v41[32 * v40];
      else
        v41 = (char *)malloc(32 * v40);
LABEL_46:
      v43 = &v41[32 * v37];
      *(_QWORD *)v43 = 0;
      *((_QWORD *)v43 + 1) = 0;
      *((_QWORD *)v43 + 2) = 0;
      *((_QWORD *)v43 + 3) = v21;
      v45 = (void **)v19[4];
      v44 = (void **)v19[5];
      v46 = v43 + 32;
      if ( v44 == v45 )
      {
        v50 = (void **)v19[4];
      }
      else
      {
        v47 = (char *)(v44 - 4) - (char *)v45;
        v48 = v43 - 32;
        do
        {
          *((_QWORD *)v48 + 1) = 0;
          *((_QWORD *)v48 + 2) = 0;
          *(_QWORD *)v48 = 0;
          *((_QWORD *)v48 + 3) = *(v44 - 1);
          v49 = *((_OWORD *)v44 - 2);
          v44 -= 4;
          *(_OWORD *)v48 = v49;
          *((_QWORD *)v48 + 2) = v44[2];
          v48 -= 32;
          *v44 = 0;
          v44[1] = 0;
          v44[2] = 0;
        }
        while ( v45 != v44 );
        v50 = (void **)v19[4];
        v45 = (void **)v19[5];
        v43 = &v41[32 * (v37 - 1 - (v47 >> 5))];
      }
      v51 = v19[6];
      v19[4] = (__int64)v43;
      v19[5] = (__int64)v46;
      v19[6] = (__int64)&v41[32 * v40];
      while ( v50 != v45 )
      {
        v45 -= 4;
        sub_42F30(v45);
      }
      if ( v50 )
      {
        v52 = v19[7];
        if ( v52 + 4096 < (unsigned __int64)v50 || v52 > (unsigned __int64)v50 )
        {
          free(v50);
        }
        else if ( *(_QWORD *)(v52 + 4096) == v51 )
        {
          *(_QWORD *)(v52 + 4096) = v50;
        }
      }
      goto LABEL_59;
    }
LABEL_1929:
    abort();
  }
  *(_QWORD *)v18 = 0;
  *(_QWORD *)(v18 + 8) = 0;
  *(_QWORD *)(v18 + 16) = 0;
  *(_QWORD *)(v18 + 24) = v21;
  v19[5] += 32;
LABEL_59:
  v53 = 0xAAAAAAAAAAAAAAABLL * ((v12 - (__int64)v11) >> 4);
  v1297 = 0xAAAAAAAAAAAAAAABLL * ((v17 - (__int64)v16) >> 4);
  if ( v53 < v1297 )
  {
    v54 = v1307;
    do
    {
      if ( v54 != 70 )
      {
        if ( v1300 == 75 )
        {
          sub_42BE4((size_t *)(*v19 + 48 * v53), " const", 6u);
          if ( (v22 & 2) != 0 )
          {
LABEL_102:
            sub_42BE4((size_t *)(*v19 + 48 * v53), " volatile", 9u);
            if ( (v22 & 4) == 0 )
              goto LABEL_124;
LABEL_106:
            sub_42BE4((size_t *)(*v19 + 48 * v53), " restrict", 9u);
            goto LABEL_124;
          }
        }
        else if ( (v22 & 2) != 0 )
        {
          goto LABEL_102;
        }
        if ( (v22 & 4) == 0 )
          goto LABEL_124;
        goto LABEL_106;
      }
      v82 = *v19;
      v83 = *v19 + 48 * v53;
      v86 = *(unsigned __int8 *)(v83 + 24);
      v84 = (size_t *)(v83 + 24);
      v85 = v86;
      if ( (v86 & 1) != 0 )
      {
        v89 = v82 + 48 * v53;
        v87 = *(_QWORD *)(v89 + 32);
        v88 = *(char **)(v89 + 40);
      }
      else
      {
        v87 = v85 >> 1;
        v88 = (char *)v84 + 1;
      }
      v90 = v87 - 2;
      if ( v88[v87 - 2] != 38
        || ((v85 & 1) != 0 ? (v91 = *(char **)(v82 + 48 * v53 + 40)) : (v91 = (char *)v84 + 1), v91[v87 - 1] != 38) )
      {
        if ( (v85 & 1) != 0 )
        {
          v94 = v82 + 48 * v53;
          v93 = *(_QWORD *)(v94 + 32);
          v92 = *(char **)(v94 + 40);
        }
        else
        {
          v92 = (char *)v84 + 1;
          v93 = v85 >> 1;
        }
        v90 = v87 - (v92[v93 - 1] == 38);
      }
      if ( v1300 == 75 )
      {
        sub_429F4(v84, v90, " const", 6u);
        v90 += 6LL;
        if ( (v22 & 2) == 0 )
          goto LABEL_122;
      }
      else if ( (v22 & 2) == 0 )
      {
LABEL_122:
        if ( (v22 & 4) == 0 )
          goto LABEL_124;
LABEL_123:
        sub_429F4((size_t *)(*v19 + 48 * v53 + 24), v90, " restrict", 9u);
        goto LABEL_124;
      }
      sub_429F4((size_t *)(*v19 + 48 * v53 + 24), v90, " volatile", 9u);
      v90 += 9LL;
      if ( (v22 & 4) != 0 )
        goto LABEL_123;
LABEL_124:
      v95 = v19[5];
      v96 = *v19;
      v98 = *(size_t **)(v95 - 24);
      v97 = *(size_t **)(v95 - 16);
      v99 = *v19 + 48 * v53;
      if ( v98 == v97 )
      {
        v100 = *(_QWORD *)(v95 - 32);
        v101 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v98 - v100) >> 4);
        if ( v101 + 1 > 0x555555555555555LL )
          goto LABEL_1929;
        v102 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v97 - v100) >> 4);
        v103 = 0x555555555555555LL;
        if ( v102 >= 0x2AAAAAAAAAAAAAALL
          || ((v104 = 2 * v102, v104 >= v101 + 1) ? (v103 = v104) : (v103 = v101 + 1), v103) )
        {
          v105 = *(_QWORD *)(v95 - 8);
          v106 = 48 * v103;
          v55 = *(char **)(v105 + 4096);
          if ( v105 + 4096 - (__int64)v55 >= (unsigned __int64)(48 * v103) )
            *(_QWORD *)(v105 + 4096) = &v55[v106];
          else
            v55 = (char *)malloc(v106);
        }
        else
        {
          v55 = 0;
        }
        v56 = (size_t *)&v55[48 * v101];
        v56[1] = 0;
        v56[2] = 0;
        *v56 = 0;
        v57 = &v55[48 * v103];
        v1295 = v57;
        if ( (*(_BYTE *)v99 & 1) == 0 )
        {
          v56[2] = *(_QWORD *)(v99 + 16);
          *(_OWORD *)v56 = *(_OWORD *)v99;
          goto LABEL_72;
        }
        v58 = v96 + 48 * v53;
        v59 = *(_QWORD *)(v58 + 8);
        if ( v59 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v60 = *(const void **)(v58 + 16);
        if ( v59 >= 0x17 )
        {
          v19 = (__int64 *)a3;
          v61 = malloc((v59 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v62 = &v55[48 * v101];
          *((_QWORD *)v62 + 1) = v59;
          *((_QWORD *)v62 + 2) = v61;
          *v56 = (v59 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v56 = 2 * v59;
          v61 = (char *)v56 + 1;
          if ( !v59 )
            goto LABEL_71;
        }
        memcpy(v61, v60, v59);
LABEL_71:
        *((_BYTE *)v61 + v59) = 0;
        v22 = v1314;
        v57 = v1295;
LABEL_72:
        v63 = &v55[48 * v101];
        *((_QWORD *)v63 + 3) = 0;
        v64 = v63 + 24;
        v65 = v96 + 48 * v53;
        *((_QWORD *)v64 + 1) = 0;
        *((_QWORD *)v64 + 2) = 0;
        v67 = *(_BYTE *)(v65 + 24);
        v66 = v65 + 24;
        if ( (v67 & 1) == 0 )
        {
          *((_QWORD *)v64 + 2) = *(_QWORD *)(v66 + 16);
          *(_OWORD *)v64 = *(_OWORD *)v66;
LABEL_81:
          v75 = *(void ***)(v95 - 32);
          v74 = *(void ***)(v95 - 24);
          v54 = v1307;
          v76 = v56 + 6;
          if ( v74 == v75 )
          {
            v78 = *(void ***)(v95 - 32);
          }
          else
          {
            do
            {
              *(v56 - 4) = (size_t)*(v74 - 4);
              *((_OWORD *)v56 - 3) = *((_OWORD *)v74 - 3);
              v77 = (size_t)*(v74 - 1);
              *(v74 - 5) = 0;
              *(v74 - 4) = 0;
              *(v74 - 6) = 0;
              *(v56 - 1) = v77;
              *(_OWORD *)(v56 - 3) = *(_OWORD *)(v74 - 3);
              *(v74 - 3) = 0;
              *(v74 - 2) = 0;
              *(v74 - 1) = 0;
              v74 -= 6;
              v56 -= 6;
            }
            while ( v75 != v74 );
            v78 = *(void ***)(v95 - 32);
            v75 = *(void ***)(v95 - 24);
          }
          v79 = *(_QWORD *)(v95 - 16);
          *(_QWORD *)(v95 - 32) = v56;
          *(_QWORD *)(v95 - 24) = v76;
          *(_QWORD *)(v95 - 16) = v57;
          if ( v75 != v78 )
          {
            do
            {
              if ( (*(_BYTE *)(v75 - 3) & 1) != 0 )
                free(*(v75 - 1));
              v80 = v75 - 6;
              if ( (*(_BYTE *)(v75 - 6) & 1) != 0 )
                free(*(v75 - 4));
              v75 -= 6;
            }
            while ( v78 != v80 );
          }
          if ( v78 )
          {
            v81 = *(_QWORD *)(v95 - 8);
            if ( v81 + 4096 < (unsigned __int64)v78 || v81 > (unsigned __int64)v78 )
            {
              free(v78);
            }
            else if ( *(_QWORD *)(v81 + 4096) == v79 )
            {
              *(_QWORD *)(v81 + 4096) = v78;
            }
          }
          goto LABEL_152;
        }
        v68 = v96 + 48 * v53;
        v69 = *(_QWORD *)(v68 + 32);
        if ( v69 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v70 = *(const void **)(v68 + 40);
        if ( v69 >= 0x17 )
        {
          v72 = malloc((v69 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v19 = (__int64 *)a3;
          v73 = &v55[48 * v101];
          *((_QWORD *)v73 + 4) = v69;
          *((_QWORD *)v73 + 5) = v72;
          *(_QWORD *)v64 = (v69 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v71 = v72;
        }
        else
        {
          *v64 = 2 * v69;
          v71 = v64 + 1;
          if ( !v69 )
            goto LABEL_80;
        }
        memcpy(v71, v70, v69);
LABEL_80:
        v22 = v1314;
        v57 = v1295;
        *((_BYTE *)v71 + v69) = 0;
        goto LABEL_81;
      }
      v98[1] = 0;
      v98[2] = 0;
      *v98 = 0;
      if ( (*(_BYTE *)v99 & 1) == 0 )
      {
        v98[2] = *(_QWORD *)(v99 + 16);
        *(_OWORD *)v98 = *(_OWORD *)v99;
        goto LABEL_142;
      }
      v107 = v96 + 48 * v53;
      v108 = *(_QWORD *)(v107 + 8);
      if ( v108 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_1929;
      v109 = *(const void **)(v107 + 16);
      if ( v108 >= 0x17 )
      {
        v110 = malloc((v108 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v98[1] = v108;
        v98[2] = (size_t)v110;
        v22 = v1314;
        *v98 = (v108 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        *(_BYTE *)v98 = 2 * v108;
        v110 = (char *)v98 + 1;
        if ( !v108 )
          goto LABEL_141;
      }
      memcpy(v110, v109, v108);
LABEL_141:
      *((_BYTE *)v110 + v108) = 0;
LABEL_142:
      v98[3] = 0;
      v111 = v98 + 3;
      v112 = v96 + 48 * v53;
      v98[4] = 0;
      v98[5] = 0;
      v114 = *(_BYTE *)(v112 + 24);
      v113 = v112 + 24;
      if ( (v114 & 1) != 0 )
      {
        v115 = v96 + 48 * v53;
        v116 = *(_QWORD *)(v115 + 32);
        if ( v116 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v117 = *(const void **)(v115 + 40);
        if ( v116 >= 0x17 )
        {
          v118 = malloc((v116 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v98[4] = v116;
          v98[5] = (size_t)v118;
          v22 = v1314;
          v98[3] = (v116 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *v111 = 2 * v116;
          v118 = (char *)v98 + 25;
          if ( !v116 )
            goto LABEL_150;
        }
        memcpy(v118, v117, v116);
LABEL_150:
        *((_BYTE *)v118 + v116) = 0;
        v54 = v1307;
        goto LABEL_151;
      }
      v54 = v1307;
      v98[5] = *(_QWORD *)(v113 + 16);
      *(_OWORD *)v111 = *(_OWORD *)v113;
LABEL_151:
      *(_QWORD *)(v95 - 24) += 48LL;
LABEL_152:
      ++v53;
    }
    while ( v53 < v1297 );
  }
  return (unsigned __int8 *)v1293;
}
// 38200: conditional instruction was optimized away because x22.8<3u
// 38208: conditional instruction was optimized away because x22.8<3u
// 38DC8: conditional instruction was optimized away because x20.8<Au
// 38DD0: conditional instruction was optimized away because x20.8<Au
// 3A6F4: conditional instruction was optimized away because x25.8<3u
// 3A6FC: conditional instruction was optimized away because x25.8<3u
// 3AD14: conditional instruction was optimized away because x21.8<3u
// 3AD1C: conditional instruction was optimized away because x21.8<3u
// 3AE8C: conditional instruction was optimized away because x20.8<Du
// 3AE94: conditional instruction was optimized away because x20.8<Du
// 3B734: conditional instruction was optimized away because x25.8<3u
// 3B73C: conditional instruction was optimized away because x25.8<3u
// 3C29C: conditional instruction was optimized away because x23.8<3u
// 3C2A4: conditional instruction was optimized away because x23.8<3u
// 3E1E4: conditional instruction was optimized away because x22.8<3u
// 3E1EC: conditional instruction was optimized away because x22.8<3u
// 0: using guessed type int dword_0;
// 2800: using guessed type Elf64_Sym;

//----- (00000000000401BC) ----------------------------------------------------
unsigned __int8 *__fastcall sub_401BC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4)
{
  unsigned __int8 *v4; // x20
  unsigned __int8 *v5; // x19
  unsigned __int8 *v8; // x28
  int v9; // w8
  unsigned __int8 *v10; // x23
  unsigned __int8 *v11; // x8
  int v12; // w9
  int v13; // w26
  unsigned __int8 *v14; // x0
  unsigned __int8 *v15; // x24
  int v16; // w8
  int v17; // w9
  int v18; // w9
  char v20; // w22
  unsigned __int8 *v21; // x24
  unsigned __int8 *v22; // x0
  unsigned __int8 *v23; // x25
  bool v24; // zf
  unsigned __int8 *v25; // x24
  __int64 v26; // x8
  __int64 v27; // x8
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x9
  void **v30; // x23
  unsigned __int8 *v31; // x0
  unsigned __int8 *v32; // x23
  __int64 v33; // x22
  unsigned __int64 v34; // x8
  const void *v35; // x1
  size_t v36; // x2
  __int64 v37; // x22
  _BYTE *v38; // x23
  void **v39; // x8
  size_t *v40; // x0
  int v41; // w22
  char *v42; // x1
  void *v43; // x2
  int v44; // w21
  int v45; // t1
  unsigned __int8 *v46; // x25
  _BOOL4 v47; // w9
  int v48; // w8
  int v49; // w8
  unsigned __int64 v50; // x8
  _OWORD *v51; // x9
  unsigned __int64 v52; // x22
  __int64 v53; // x24
  unsigned __int64 v54; // x8
  unsigned __int64 v55; // x8
  __int64 v56; // x9
  char *v57; // x0
  unsigned __int8 *v58; // x8
  unsigned __int8 *v59; // x9
  int v60; // w10
  unsigned __int8 *v61; // x0
  int v62; // w8
  int v63; // w8
  __int64 v64; // x10
  __int64 v65; // x22
  __int64 v66; // x9
  unsigned __int64 v67; // x9
  __int64 v68; // x25
  char *v69; // x0
  char *v70; // x10
  void **v71; // x11
  void **v72; // x26
  char *v73; // x8
  _OWORD *v74; // x9
  __int64 v75; // x12
  void **v76; // x24
  __int64 v77; // x11
  void **v78; // x22
  unsigned __int64 v79; // x8
  _BOOL4 v80; // w24
  __int64 v81; // x22
  _BYTE *v82; // x20
  int v83; // w22
  unsigned __int8 *v84; // x0
  unsigned __int8 *v85; // x24
  __int64 v86; // x22
  unsigned __int64 v87; // x8
  const void *v88; // x1
  size_t v89; // x2
  __int64 v90; // x22
  _BYTE *v91; // x26
  void **v92; // x8
  size_t *v93; // x0
  unsigned __int64 v94; // x8
  size_t v95; // x2
  char *v96; // x1
  unsigned __int8 *v97; // x0
  unsigned __int8 *v98; // x24
  __int64 v99; // x22
  unsigned __int64 v100; // x8
  const void *v101; // x1
  size_t v102; // x2
  __int64 v103; // x22
  _BYTE *v104; // x26
  void **v105; // x8
  size_t *v106; // x0
  unsigned __int64 v107; // x8
  size_t v108; // x2
  char *v109; // x1
  unsigned __int8 *v110; // x0
  unsigned __int8 *v111; // x24
  __int64 v112; // x22
  unsigned __int64 v113; // x8
  const void *v114; // x1
  size_t v115; // x2
  __int64 v116; // x26
  _BYTE *v117; // x22
  void **v118; // x8
  char *v119; // x1
  size_t v120; // x2
  __int64 v121; // x1
  unsigned __int64 v122; // x8
  unsigned __int64 v123; // x9
  void **v124; // x25
  __int64 v125; // x0
  unsigned __int8 *v126; // x24
  __int64 v127; // x22
  unsigned __int64 v128; // x8
  const void *v129; // x1
  size_t v130; // x2
  __int64 v131; // x22
  _BYTE *v132; // x26
  void **v133; // x8
  size_t *v134; // x0
  unsigned __int64 v135; // x8
  size_t v136; // x2
  char *v137; // x1
  unsigned __int8 *v138; // x0
  __int64 v139; // x22
  unsigned __int64 v140; // x8
  const void *v141; // x1
  size_t v142; // x2
  __int64 v143; // x22
  _BYTE *v144; // x26
  void **v145; // x8
  size_t *v146; // x0
  unsigned __int64 v147; // x8
  size_t v148; // x2
  char *v149; // x1
  char v150; // w22
  size_t v151; // x25
  char *v152; // x0
  int v153; // w26
  char v154; // w22
  size_t v155; // x25
  char *v156; // x0
  char *v157; // x8
  char *v158; // x1
  void *v159; // x2
  char *v160; // x1
  __int64 v161; // x1
  unsigned __int64 v162; // x8
  unsigned __int64 v163; // x9
  void **v164; // x25
  __int64 v165; // x10
  __int64 v166; // x22
  __int64 v167; // x9
  unsigned __int64 v168; // x9
  __int64 v169; // x26
  char *v170; // x0
  __int64 v171; // x10
  __int64 v172; // x14
  __int64 v173; // x9
  unsigned __int64 v174; // x9
  __int64 v175; // x22
  char *v176; // x0
  char v177; // w22
  size_t v178; // x25
  char *v179; // x0
  __int64 v180; // x9
  char v181; // w22
  size_t v182; // x25
  char *v183; // x0
  char *v184; // x8
  char *v185; // x1
  void *v186; // x2
  char *v187; // x1
  __int64 v188; // x1
  unsigned __int64 v189; // x8
  unsigned __int64 v190; // x9
  void **v191; // x25
  __int64 v192; // x10
  __int64 v193; // x22
  __int64 v194; // x9
  unsigned __int64 v195; // x9
  __int64 v196; // x26
  char *v197; // x0
  char *v198; // x10
  char *v199; // x9
  void **v200; // x12
  void **v201; // x25
  char *v202; // x8
  unsigned __int64 v203; // x11
  char *v204; // x10
  __int128 v205; // t1
  void **v206; // x26
  __int64 v207; // x22
  unsigned __int64 v208; // x8
  char *v209; // x8
  char *v210; // x1
  void *v211; // x2
  char *v212; // x1
  __int64 v213; // x1
  unsigned __int64 v214; // x8
  unsigned __int64 v215; // x9
  void **v216; // x25
  __int64 v217; // x10
  __int64 v218; // x22
  __int64 v219; // x9
  unsigned __int64 v220; // x9
  __int64 v221; // x26
  char *v222; // x0
  __int64 v223; // x9
  __int64 v224; // x25
  __int64 v225; // x9
  void **v226; // x22
  void **v227; // x26
  char *v228; // x8
  char *v229; // x1
  void *v230; // x2
  char *v231; // x1
  __int64 v232; // x1
  unsigned __int64 v233; // x8
  unsigned __int64 v234; // x9
  void **v235; // x25
  __int64 v236; // x10
  __int64 v237; // x22
  __int64 v238; // x9
  unsigned __int64 v239; // x9
  __int64 v240; // x26
  char *v241; // x0
  char *v242; // x10
  char *v243; // x9
  void **v244; // x12
  void **v245; // x25
  char *v246; // x8
  unsigned __int64 v247; // x11
  char *v248; // x10
  __int128 v249; // t1
  void **v250; // x26
  char *v251; // x10
  char *v252; // x9
  void **v253; // x12
  void **v254; // x25
  char *v255; // x8
  unsigned __int64 v256; // x11
  char *v257; // x10
  __int128 v258; // t1
  void **v259; // x26
  __int64 v260; // x9
  __int64 v261; // x22
  unsigned __int64 v262; // x8
  __int64 v263; // x22
  unsigned __int64 v264; // x8
  char *v265; // x10
  char *v266; // x9
  void **v267; // x12
  void **v268; // x25
  char *v269; // x8
  unsigned __int64 v270; // x11
  char *v271; // x10
  __int128 v272; // t1
  void **v273; // x26
  void **v274; // x22
  void **v275; // x26
  void **v276; // x22
  void **v277; // x26
  __int64 v278; // x22
  unsigned __int64 v279; // x8
  void **v280; // x22
  void **v281; // x26
  __int64 v282; // x9
  char *v283; // x10
  char *v284; // x9
  void **v285; // x12
  void **v286; // x25
  char *v287; // x8
  unsigned __int64 v288; // x11
  char *v289; // x10
  __int128 v290; // t1
  void **v291; // x26
  __int64 v292; // x22
  unsigned __int64 v293; // x8
  void **v294; // x22
  void **v295; // x26
  __int64 v296; // x8
  __int64 v297; // x20
  __int64 v298; // x9
  unsigned __int8 *v299; // x9
  char *v300; // x10
  char *v301; // x9
  void **v302; // x12
  void **v303; // x23
  char *v304; // x8
  unsigned __int64 v305; // x11
  char *v306; // x10
  __int128 v307; // t1
  void **v308; // x25
  __int64 v309; // x22
  unsigned __int64 v310; // x8
  void **v311; // x22
  void **v312; // x25
  __int64 v313; // x22
  unsigned __int64 v314; // x8
  const void *v315; // x1
  size_t v316; // x2
  __int64 v317; // x22
  _BYTE *v318; // x23
  void **v319; // x8
  size_t *v320; // x0
  char *v321; // x1
  void *v322; // x2
  unsigned __int8 *v323; // x24
  __int64 v324; // x22
  unsigned __int64 v325; // x8
  const void *v326; // x1
  size_t v327; // x2
  __int64 v328; // x22
  _BYTE *v329; // x24
  void **v330; // x8
  char *v331; // x1
  void *v332; // x2
  int v333; // w21
  __int64 v334; // x20
  _BYTE *v335; // x22
  unsigned __int8 *v337; // x8
  unsigned __int8 *v338; // x9
  int v339; // w10
  __int64 v340; // x8
  unsigned __int8 *v341; // x8
  int v342; // w9
  __int64 v343; // x22
  unsigned __int64 v344; // x8
  const void *v345; // x1
  size_t v346; // x2
  __int64 v347; // x22
  _BYTE *v348; // x23
  void **v349; // x8
  char *v350; // x1
  void *v351; // x2
  int v352; // w21
  int v353; // [xsp+4h] [xbp-BCh]
  int v355; // [xsp+10h] [xbp-B0h]
  __int64 v356; // [xsp+18h] [xbp-A8h]
  char v357; // [xsp+18h] [xbp-A8h]
  _BOOL4 v358; // [xsp+20h] [xbp-A0h]
  __int64 v359; // [xsp+28h] [xbp-98h] BYREF
  void *v360[2]; // [xsp+30h] [xbp-90h] BYREF
  void *p; // [xsp+40h] [xbp-80h]
  unsigned __int64 v362; // [xsp+48h] [xbp-78h]
  __int128 v363; // [xsp+50h] [xbp-70h] BYREF
  void *v364; // [xsp+60h] [xbp-60h]
  __int64 v365; // [xsp+68h] [xbp-58h]

  v4 = a2;
  v5 = a1;
  v365 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 2 )
    return v5;
  if ( *a1 == 76 )
    v8 = a1 + 1;
  else
    v8 = a1;
  v9 = *v8;
  v10 = v8;
  if ( v9 == 90 )
  {
    if ( v8 == a2 )
      goto LABEL_673;
    v14 = (unsigned __int8 *)sub_36F74(v8 + 1, a2, a3);
    if ( v14 != v8 + 1 && v14 != v4 && *v14 == 69 )
    {
      v15 = v14 + 1;
      if ( v14 + 1 != v4 )
      {
        v16 = *v15;
        if ( v16 != 100 )
        {
          if ( v16 == 115 )
          {
            if ( v14 + 2 == v4 )
              goto LABEL_689;
            v17 = v14[2];
            if ( v17 == 95 )
            {
              if ( v14 + 3 != v4 )
              {
                v18 = v14[3];
                if ( (unsigned int)(v18 - 48) <= 9 )
                {
                  v4 = v14 + 4;
                  goto LABEL_689;
                }
                if ( v18 == 95 )
                {
                  v338 = v14 + 4;
                  if ( v14 + 4 != v4 )
                  {
                    while ( 1 )
                    {
                      v339 = *v338;
                      if ( (unsigned int)(v339 - 48) > 9 )
                        break;
                      if ( v4 == ++v338 )
                        goto LABEL_688;
                    }
                    if ( v339 == 95 )
                      v4 = v338 + 1;
                    else
                      v4 = v14 + 2;
                    goto LABEL_689;
                  }
                }
              }
            }
            else if ( (unsigned int)(v17 - 48) <= 9 )
            {
              v299 = v14 + 3;
              if ( v14 + 3 == v4 )
                goto LABEL_689;
              while ( (unsigned int)*v299 - 48 < 0xA )
              {
                if ( v4 == ++v299 )
                  goto LABEL_689;
              }
            }
LABEL_688:
            v4 = v14 + 2;
LABEL_689:
            v340 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 != v340 )
              sub_42BE4((size_t *)(v340 - 48), "::string literal", 0x10u);
            goto LABEL_673;
          }
          v61 = (unsigned __int8 *)sub_401BC(v14 + 1, v4, a3, a4);
          if ( v61 != v15 )
          {
            if ( v61 == v4 )
              goto LABEL_696;
            v62 = *v61;
            if ( v62 == 95 )
            {
              if ( v61 + 1 != v4 )
              {
                v63 = v61[1];
                if ( (unsigned int)(v63 - 48) <= 9 )
                {
                  v4 = v61 + 2;
                  goto LABEL_696;
                }
                if ( v63 == 95 )
                {
                  v341 = v61 + 2;
                  if ( v61 + 2 != v4 )
                  {
                    while ( 1 )
                    {
                      v342 = *v341;
                      if ( (unsigned int)(v342 - 48) > 9 )
                        break;
                      if ( v4 == ++v341 )
                        goto LABEL_695;
                    }
                    if ( v342 == 95 )
                      v4 = v341 + 1;
                    else
                      v4 = v61;
LABEL_696:
                    v343 = *(_QWORD *)(a3 + 8);
                    if ( 0xAAAAAAAAAAAAAAABLL * ((v343 - *(_QWORD *)a3) >> 4) < 2 )
                      goto LABEL_673;
                    v344 = *(unsigned __int8 *)(v343 - 24);
                    if ( (v344 & 1) != 0 )
                      v345 = *(const void **)(v343 - 8);
                    else
                      v345 = (const void *)(v343 - 23);
                    if ( (v344 & 1) != 0 )
                      v346 = *(_QWORD *)(v343 - 16);
                    else
                      v346 = v344 >> 1;
                    sub_42BE4((size_t *)(v343 - 48), v345, v346);
                    p = *(void **)(v343 - 32);
                    *(_OWORD *)v360 = *(_OWORD *)(v343 - 48);
                    *(_QWORD *)(v343 - 40) = 0;
                    *(_QWORD *)(v343 - 32) = 0;
                    *(_QWORD *)(v343 - 48) = 0;
                    v347 = *(_QWORD *)(a3 + 8);
                    v348 = (_BYTE *)(v347 - 48);
                    if ( (*(_BYTE *)(v347 - 24) & 1) != 0 )
                      free(*(void **)(v347 - 8));
                    if ( (*v348 & 1) != 0 )
                      free(*(void **)(v347 - 32));
                    v349 = *(void ***)a3;
                    *(_QWORD *)(a3 + 8) = v348;
                    if ( v349 == (void **)v348 )
                    {
                      v352 = 1;
                      if ( ((__int64)v360[0] & 1) != 0 )
LABEL_715:
                        free(p);
                    }
                    else
                    {
                      sub_42BE4((size_t *)(v347 - 96), "::", 2u);
                      if ( ((__int64)v360[0] & 1) != 0 )
                        v350 = (char *)p;
                      else
                        v350 = (char *)v360 + 1;
                      if ( ((__int64)v360[0] & 1) != 0 )
                        v351 = v360[1];
                      else
                        v351 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
                      sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v350, (size_t)v351);
                      v352 = 0;
                      if ( ((__int64)v360[0] & 1) != 0 )
                        goto LABEL_715;
                    }
                    v10 = v4;
                    if ( v352 )
                    {
LABEL_674:
                      if ( v10 == v8 )
                        return v5;
                      else
                        return v10;
                    }
LABEL_673:
                    v10 = v4;
                    goto LABEL_674;
                  }
                }
              }
            }
            else if ( (unsigned int)(v62 - 48) <= 9 )
            {
              v337 = v61 + 1;
              if ( v61 + 1 == v4 )
                goto LABEL_696;
              while ( (unsigned int)*v337 - 48 < 0xA )
              {
                if ( v4 == ++v337 )
                  goto LABEL_696;
              }
            }
LABEL_695:
            v4 = v61;
            goto LABEL_696;
          }
          goto LABEL_666;
        }
        v58 = v14 + 2;
        if ( v14 + 2 != v4 )
        {
          if ( v14[2] == 110 )
            v59 = v14 + 3;
          else
            v59 = v14 + 2;
          if ( v59 != v4 )
          {
            v60 = *v59;
            if ( v60 == 48 )
            {
              v58 = v59 + 1;
            }
            else if ( (unsigned int)(v60 - 49) <= 8 )
            {
              v58 = v59 + 1;
              if ( v59 + 1 == v4 )
                goto LABEL_672;
              while ( (unsigned int)*v58 - 48 < 0xA )
              {
                if ( v4 == ++v58 )
                  goto LABEL_672;
              }
            }
          }
          if ( v58 != v4 && *v58 == 95 )
          {
            v323 = v58 + 1;
            v4 = (unsigned __int8 *)sub_401BC(v58 + 1, v4, a3, a4);
            if ( v4 == v323 )
            {
LABEL_666:
              v334 = *(_QWORD *)(a3 + 8);
              if ( *(_QWORD *)a3 != v334 )
              {
                v335 = (_BYTE *)(v334 - 48);
                if ( (*(_BYTE *)(v334 - 24) & 1) != 0 )
                  free(*(void **)(v334 - 8));
                if ( (*v335 & 1) != 0 )
                  free(*(void **)(v334 - 32));
                *(_QWORD *)(a3 + 8) = v335;
              }
              goto LABEL_672;
            }
            v324 = *(_QWORD *)(a3 + 8);
            if ( 0xAAAAAAAAAAAAAAABLL * ((v324 - *(_QWORD *)a3) >> 4) < 2 )
              goto LABEL_674;
            v325 = *(unsigned __int8 *)(v324 - 24);
            if ( (v325 & 1) != 0 )
              v326 = *(const void **)(v324 - 8);
            else
              v326 = (const void *)(v324 - 23);
            if ( (v325 & 1) != 0 )
              v327 = *(_QWORD *)(v324 - 16);
            else
              v327 = v325 >> 1;
            sub_42BE4((size_t *)(v324 - 48), v326, v327);
            p = *(void **)(v324 - 32);
            *(_OWORD *)v360 = *(_OWORD *)(v324 - 48);
            *(_QWORD *)(v324 - 40) = 0;
            *(_QWORD *)(v324 - 32) = 0;
            *(_QWORD *)(v324 - 48) = 0;
            v328 = *(_QWORD *)(a3 + 8);
            v329 = (_BYTE *)(v328 - 48);
            if ( (*(_BYTE *)(v328 - 24) & 1) != 0 )
              free(*(void **)(v328 - 8));
            if ( (*v329 & 1) != 0 )
              free(*(void **)(v328 - 32));
            v330 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v329;
            if ( v330 == (void **)v329 )
            {
              v333 = 1;
              v4 = v8;
              if ( ((__int64)v360[0] & 1) != 0 )
LABEL_663:
                free(p);
            }
            else
            {
              sub_42BE4((size_t *)(v328 - 96), "::", 2u);
              if ( ((__int64)v360[0] & 1) != 0 )
                v331 = (char *)p;
              else
                v331 = (char *)v360 + 1;
              if ( ((__int64)v360[0] & 1) != 0 )
                v332 = v360[1];
              else
                v332 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
              sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v331, (size_t)v332);
              v333 = 0;
              if ( ((__int64)v360[0] & 1) != 0 )
                goto LABEL_663;
            }
            if ( v333 )
              goto LABEL_674;
            goto LABEL_673;
          }
        }
      }
    }
LABEL_672:
    v4 = v8;
    goto LABEL_673;
  }
  if ( v9 == 78 )
  {
    if ( v8 != a2 )
    {
      v11 = v8 + 1;
      if ( v8 + 1 == a2 )
        goto LABEL_674;
      v12 = *v11;
      if ( v12 == 114 )
      {
        v11 = v8 + 2;
        v12 = v8[2];
        v13 = 4;
      }
      else
      {
        v13 = 0;
      }
      if ( v12 == 86 )
      {
        v45 = *++v11;
        v12 = v45;
        v13 |= 2u;
      }
      v46 = v12 == 75 ? v11 + 1 : v11;
      v47 = v12 == 75;
      if ( v46 == a2 )
        goto LABEL_674;
      *(_DWORD *)(a3 + 100) = 0;
      v48 = *v46;
      if ( v48 == 79 )
      {
        v49 = 2;
      }
      else
      {
        if ( v48 != 82 )
          goto LABEL_84;
        v49 = 1;
      }
      ++v46;
      *(_DWORD *)(a3 + 100) = v49;
LABEL_84:
      v358 = v47;
      v51 = *(_OWORD **)(a3 + 8);
      v50 = *(_QWORD *)(a3 + 16);
      if ( (unsigned __int64)v51 >= v50 )
      {
        v52 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v51 - *(_QWORD *)a3) >> 4);
        v53 = 0x555555555555555LL;
        if ( v52 + 1 > 0x555555555555555LL )
          abort();
        v54 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v50 - *(_QWORD *)a3) >> 4);
        v355 = v13;
        if ( v54 > 0x2AAAAAAAAAAAAA9LL || ((v55 = 2 * v54, v55 >= v52 + 1) ? (v53 = v55) : (v53 = v52 + 1), v53) )
        {
          v56 = *(_QWORD *)(a3 + 24);
          v57 = *(char **)(v56 + 4096);
          if ( v56 + 4096 - (__int64)v57 >= (unsigned __int64)(48 * v53) )
            *(_QWORD *)(v56 + 4096) = &v57[48 * v53];
          else
            v57 = (char *)malloc(48 * v53);
        }
        else
        {
          v57 = 0;
        }
        v70 = &v57[48 * v52];
        *((_OWORD *)v70 + 1) = 0u;
        *((_OWORD *)v70 + 2) = 0u;
        *(_OWORD *)v70 = 0u;
        v72 = *(void ***)a3;
        v71 = *(void ***)(a3 + 8);
        v73 = &v57[48 * v53];
        v74 = v70 + 48;
        if ( v71 == *(void ***)a3 )
        {
          v76 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v70 - 4) = *(v71 - 4);
            *((_OWORD *)v70 - 3) = *((_OWORD *)v71 - 3);
            v75 = (__int64)*(v71 - 1);
            *(v71 - 5) = 0;
            *(v71 - 4) = 0;
            *(v71 - 6) = 0;
            *((_QWORD *)v70 - 1) = v75;
            *(_OWORD *)(v70 - 24) = *(_OWORD *)(v71 - 3);
            *(v71 - 3) = 0;
            *(v71 - 2) = 0;
            *(v71 - 1) = 0;
            v71 -= 6;
            v70 -= 48;
          }
          while ( v72 != v71 );
          v76 = *(void ***)a3;
          v72 = *(void ***)(a3 + 8);
        }
        v77 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)(a3 + 16) = v73;
        v356 = v77;
        *(_QWORD *)a3 = v70;
        *(_QWORD *)(a3 + 8) = v74;
        if ( v72 != v76 )
        {
          do
          {
            if ( (*(_BYTE *)(v72 - 3) & 1) != 0 )
              free(*(v72 - 1));
            v78 = v72 - 6;
            if ( (*(_BYTE *)(v72 - 6) & 1) != 0 )
              free(*(v72 - 4));
            v72 -= 6;
          }
          while ( v76 != v78 );
        }
        v13 = v355;
        if ( v76 )
        {
          v79 = *(_QWORD *)(a3 + 24);
          if ( v79 + 4096 < (unsigned __int64)v76 || v79 > (unsigned __int64)v76 )
          {
            free(v76);
          }
          else if ( *(_QWORD *)(v79 + 4096) == v356 )
          {
            *(_QWORD *)(v79 + 4096) = v76;
          }
        }
      }
      else
      {
        v51[1] = 0u;
        v51[2] = 0u;
        *v51 = 0u;
        *(_QWORD *)(a3 + 8) += 48LL;
      }
      if ( v4 - v46 < 2 )
      {
        v80 = v358;
      }
      else
      {
        v80 = v358;
        if ( *v46 == 83 && v46[1] == 116 )
        {
          v46 += 2;
          sub_47A3C((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), "std", 3u);
          if ( v46 == v4 )
          {
LABEL_138:
            v81 = *(_QWORD *)(a3 + 8);
            v82 = (_BYTE *)(v81 - 48);
            if ( (*(_BYTE *)(v81 - 24) & 1) != 0 )
              free(*(void **)(v81 - 8));
            if ( (*v82 & 1) != 0 )
              free(*(void **)(v81 - 32));
            *(_QWORD *)(a3 + 8) = v82;
            goto LABEL_674;
          }
          goto LABEL_145;
        }
      }
      if ( v46 == v4 )
        goto LABEL_138;
LABEL_145:
      v353 = v13 | v80;
      LOBYTE(v83) = 0;
      v357 = 0;
      while ( 2 )
      {
        switch ( *v46 )
        {
          case 'D':
            if ( v46 + 1 != v4 && (v46[1] | 0x20) != 0x74 )
              goto LABEL_175;
            v84 = sub_46514(v46, v4, (_QWORD *)a3);
            v85 = v84;
            if ( v84 == v46 || v84 == v4 )
              goto LABEL_674;
            v86 = *(_QWORD *)(a3 + 8);
            v87 = *(unsigned __int8 *)(v86 - 24);
            if ( (v87 & 1) != 0 )
              v88 = *(const void **)(v86 - 8);
            else
              v88 = (const void *)(v86 - 23);
            if ( (v87 & 1) != 0 )
              v89 = *(_QWORD *)(v86 - 16);
            else
              v89 = v87 >> 1;
            sub_42BE4((size_t *)(v86 - 48), v88, v89);
            v364 = *(void **)(v86 - 32);
            v363 = *(_OWORD *)(v86 - 48);
            *(_QWORD *)(v86 - 40) = 0;
            *(_QWORD *)(v86 - 32) = 0;
            *(_QWORD *)(v86 - 48) = 0;
            v90 = *(_QWORD *)(a3 + 8);
            v91 = (_BYTE *)(v90 - 48);
            if ( (*(_BYTE *)(v90 - 24) & 1) != 0 )
              free(*(void **)(v90 - 8));
            if ( (*v91 & 1) != 0 )
              free(*(void **)(v90 - 32));
            v92 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v91;
            if ( v92 == (void **)v91 )
            {
              v83 = 1;
              if ( (v363 & 1) == 0 )
              {
LABEL_535:
                if ( !v83 )
                  continue;
                goto LABEL_674;
              }
LABEL_534:
              free(v364);
              goto LABEL_535;
            }
            v93 = (size_t *)(v90 - 96);
            v94 = *(unsigned __int8 *)(v90 - 96);
            if ( (v94 & 1) != 0 )
            {
              if ( !*(_QWORD *)(v90 - 88) )
              {
LABEL_165:
                if ( v93 != (size_t *)&v363 )
                {
                  if ( (v363 & 1) != 0 )
                    v95 = *((_QWORD *)&v363 + 1);
                  else
                    v95 = (unsigned __int64)(unsigned __int8)v363 >> 1;
                  if ( (v363 & 1) != 0 )
                    v96 = (char *)v364;
                  else
                    v96 = (char *)&v363 + 1;
                  sub_47A3C(v93, v96, v95);
                }
                goto LABEL_386;
              }
            }
            else if ( !(v94 >> 1) )
            {
              goto LABEL_165;
            }
            v177 = v363;
            v360[0] = 0;
            v360[1] = 0;
            p = 0;
            if ( (v363 & 1) != 0 )
              v178 = *((_QWORD *)&v363 + 1);
            else
              v178 = (unsigned __int64)(unsigned __int8)v363 >> 1;
            if ( v178 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v178 + 2 > 0x16 )
            {
              v179 = (char *)malloc((v178 + 18) & 0xFFFFFFFFFFFFFFF0LL);
              v360[0] = (void *)((v178 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1);
              v360[1] = &dword_0 + 2;
              p = v179;
            }
            else
            {
              v179 = (char *)v360 + 1;
              LOBYTE(v360[0]) = 4;
            }
            v209 = (char *)v364;
            strcpy(v179, "::");
            if ( (v177 & 1) != 0 )
              v210 = v209;
            else
              v210 = (char *)&v363 + 1;
            sub_42BE4((size_t *)v360, v210, v178);
            if ( ((__int64)v360[0] & 1) != 0 )
              v211 = v360[1];
            else
              v211 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
            if ( ((__int64)v360[0] & 1) != 0 )
              v212 = (char *)p;
            else
              v212 = (char *)v360 + 1;
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v212, (size_t)v211);
            if ( ((__int64)v360[0] & 1) != 0 )
              free(p);
LABEL_386:
            v213 = *(_QWORD *)(a3 + 8) - 48LL;
            v359 = *(_QWORD *)(a3 + 24);
            sub_42D60(v360, v213, &v359);
            v214 = *(_QWORD *)(a3 + 40);
            v215 = *(_QWORD *)(a3 + 48);
            if ( v214 < v215 )
            {
              *(_QWORD *)(v214 + 24) = v362;
              *(_OWORD *)v214 = *(_OWORD *)v360;
              *(_QWORD *)(v214 + 16) = p;
              v360[1] = 0;
              p = 0;
              v360[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v216 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_533;
              goto LABEL_522;
            }
            v217 = *(_QWORD *)(a3 + 32);
            v218 = (__int64)(v214 - v217) >> 5;
            if ( (unsigned __int64)(v218 + 1) >> 59 )
              abort();
            v219 = v215 - v217;
            if ( (unsigned __int64)(v219 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v221 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v220 = v219 >> 4;
              if ( v220 >= v218 + 1 )
                v221 = v220;
              else
                v221 = v218 + 1;
              if ( !v221 )
              {
                v222 = 0;
                goto LABEL_473;
              }
            }
            v260 = *(_QWORD *)(a3 + 56);
            v222 = *(char **)(v260 + 4096);
            if ( v260 + 4096 - (__int64)v222 >= (unsigned __int64)(32 * v221) )
              *(_QWORD *)(v260 + 4096) = &v222[32 * v221];
            else
              v222 = (char *)malloc(32 * v221);
LABEL_473:
            v265 = &v222[32 * v218];
            *((_QWORD *)v265 + 1) = 0;
            *((_QWORD *)v265 + 2) = 0;
            v266 = v265 + 32;
            *((_QWORD *)v265 + 3) = v362;
            *(_OWORD *)v265 = *(_OWORD *)v360;
            *((_QWORD *)v265 + 2) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            v268 = *(void ***)(a3 + 32);
            v267 = *(void ***)(a3 + 40);
            v269 = &v222[32 * v221];
            if ( v267 == v268 )
            {
              v273 = *(void ***)(a3 + 32);
            }
            else
            {
              v270 = (char *)(v267 - 4) - (char *)v268;
              v271 = v265 - 32;
              do
              {
                *((_QWORD *)v271 + 1) = 0;
                *((_QWORD *)v271 + 2) = 0;
                *(_QWORD *)v271 = 0;
                *((_QWORD *)v271 + 3) = *(v267 - 1);
                v272 = *((_OWORD *)v267 - 2);
                v267 -= 4;
                *(_OWORD *)v271 = v272;
                *((_QWORD *)v271 + 2) = v267[2];
                v271 -= 32;
                *v267 = 0;
                v267[1] = 0;
                v267[2] = 0;
              }
              while ( v268 != v267 );
              v273 = *(void ***)(a3 + 32);
              v268 = *(void ***)(a3 + 40);
              v265 = &v222[32 * (v218 - 1 - (v270 >> 5))];
            }
            v278 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v265;
            *(_QWORD *)(a3 + 40) = v266;
            *(_QWORD *)(a3 + 48) = v269;
            while ( v273 != v268 )
            {
              v268 -= 4;
              sub_42F30(v268);
            }
            if ( v273 )
            {
              v279 = *(_QWORD *)(a3 + 56);
              if ( v279 + 4096 < (unsigned __int64)v273 || v279 > (unsigned __int64)v273 )
              {
                free(v273);
              }
              else if ( *(_QWORD *)(v279 + 4096) == v278 )
              {
                *(_QWORD *)(v279 + 4096) = v273;
                v216 = (void **)v360[0];
                if ( !v360[0] )
                  goto LABEL_533;
                goto LABEL_522;
              }
            }
            v216 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_533;
LABEL_522:
            v280 = (void **)v360[1];
            if ( v360[1] != v216 )
            {
              do
              {
                if ( (*(_BYTE *)(v280 - 3) & 1) != 0 )
                  free(*(v280 - 1));
                v281 = v280 - 6;
                if ( (*(_BYTE *)(v280 - 6) & 1) != 0 )
                  free(*(v280 - 4));
                v280 -= 6;
              }
              while ( v216 != v281 );
            }
            v360[1] = v216;
            if ( v362 + 4096 < (unsigned __int64)v216 || v362 > (unsigned __int64)v216 )
            {
              free(v216);
            }
            else if ( *(void **)(v362 + 4096) == p )
            {
              *(_QWORD *)(v362 + 4096) = v216;
            }
LABEL_533:
            v83 = 0;
            v46 = v85;
            v357 = 1;
            if ( (v363 & 1) == 0 )
              goto LABEL_535;
            goto LABEL_534;
          case 'E':
            v10 = v46 + 1;
            *(_DWORD *)(a3 + 96) = v353;
            if ( (v357 & 1) != 0 )
            {
              v296 = *(_QWORD *)(a3 + 40);
              if ( *(_QWORD *)(a3 + 32) != v296 )
              {
                v297 = v296 - 32;
                sub_42F30((void **)(v296 - 32));
                *(_QWORD *)(a3 + 40) = v297;
              }
            }
            if ( a4 )
              *a4 = v83;
            goto LABEL_674;
          case 'I':
            v110 = sub_42FE0(v46, v4, a3);
            v111 = v110;
            if ( v110 == v46 || v110 == v4 )
              goto LABEL_674;
            v112 = *(_QWORD *)(a3 + 8);
            v113 = *(unsigned __int8 *)(v112 - 24);
            if ( (v113 & 1) != 0 )
              v114 = *(const void **)(v112 - 8);
            else
              v114 = (const void *)(v112 - 23);
            if ( (v113 & 1) != 0 )
              v115 = *(_QWORD *)(v112 - 16);
            else
              v115 = v113 >> 1;
            sub_42BE4((size_t *)(v112 - 48), v114, v115);
            v364 = *(void **)(v112 - 32);
            v363 = *(_OWORD *)(v112 - 48);
            *(_QWORD *)(v112 - 40) = 0;
            *(_QWORD *)(v112 - 32) = 0;
            *(_QWORD *)(v112 - 48) = 0;
            v116 = *(_QWORD *)(a3 + 8);
            v117 = (_BYTE *)(v116 - 48);
            if ( (*(_BYTE *)(v116 - 24) & 1) != 0 )
              free(*(void **)(v116 - 8));
            if ( (*v117 & 1) != 0 )
              free(*(void **)(v116 - 32));
            v118 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v117;
            if ( v118 == (void **)v117 )
            {
              LOBYTE(v83) = 0;
              v153 = 1;
              v111 = v46;
              if ( (v363 & 1) == 0 )
              {
LABEL_492:
                if ( !v153 )
                  goto LABEL_146;
                goto LABEL_674;
              }
LABEL_491:
              free(v364);
              goto LABEL_492;
            }
            if ( (v363 & 1) != 0 )
              v119 = (char *)v364;
            else
              v119 = (char *)&v363 + 1;
            if ( (v363 & 1) != 0 )
              v120 = *((_QWORD *)&v363 + 1);
            else
              v120 = (unsigned __int64)(unsigned __int8)v363 >> 1;
            sub_42BE4((size_t *)(v116 - 96), v119, v120);
            v121 = *(_QWORD *)(a3 + 8) - 48LL;
            v359 = *(_QWORD *)(a3 + 24);
            sub_42D60(v360, v121, &v359);
            v122 = *(_QWORD *)(a3 + 40);
            v123 = *(_QWORD *)(a3 + 48);
            if ( v122 < v123 )
            {
              *(_QWORD *)(v122 + 24) = v362;
              *(_OWORD *)v122 = *(_OWORD *)v360;
              *(_QWORD *)(v122 + 16) = p;
              v360[1] = 0;
              p = 0;
              v360[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v124 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_490;
              goto LABEL_479;
            }
            v171 = *(_QWORD *)(a3 + 32);
            v172 = (__int64)(v122 - v171) >> 5;
            if ( (unsigned __int64)(v172 + 1) >> 59 )
              abort();
            v173 = v123 - v171;
            if ( (unsigned __int64)(v173 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v175 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v174 = v173 >> 4;
              if ( v174 >= v172 + 1 )
                v175 = v174;
              else
                v175 = v172 + 1;
              if ( !v175 )
              {
                v176 = 0;
                goto LABEL_442;
              }
            }
            v223 = *(_QWORD *)(a3 + 56);
            v176 = *(char **)(v223 + 4096);
            if ( v223 + 4096 - (__int64)v176 >= (unsigned __int64)(32 * v175) )
            {
              *(_QWORD *)(v223 + 4096) = &v176[32 * v175];
            }
            else
            {
              v224 = (__int64)(v122 - v171) >> 5;
              v176 = (char *)malloc(32 * v175);
              v172 = v224;
            }
LABEL_442:
            v242 = &v176[32 * v172];
            *((_QWORD *)v242 + 1) = 0;
            *((_QWORD *)v242 + 2) = 0;
            v243 = v242 + 32;
            *((_QWORD *)v242 + 3) = v362;
            *(_OWORD *)v242 = *(_OWORD *)v360;
            *((_QWORD *)v242 + 2) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            v245 = *(void ***)(a3 + 32);
            v244 = *(void ***)(a3 + 40);
            v246 = &v176[32 * v175];
            if ( v244 == v245 )
            {
              v250 = *(void ***)(a3 + 32);
            }
            else
            {
              v247 = (char *)(v244 - 4) - (char *)v245;
              v248 = v242 - 32;
              do
              {
                *((_QWORD *)v248 + 1) = 0;
                *((_QWORD *)v248 + 2) = 0;
                *(_QWORD *)v248 = 0;
                *((_QWORD *)v248 + 3) = *(v244 - 1);
                v249 = *((_OWORD *)v244 - 2);
                v244 -= 4;
                *(_OWORD *)v248 = v249;
                *((_QWORD *)v248 + 2) = v244[2];
                v248 -= 32;
                *v244 = 0;
                v244[1] = 0;
                v244[2] = 0;
              }
              while ( v245 != v244 );
              v250 = *(void ***)(a3 + 32);
              v245 = *(void ***)(a3 + 40);
              v242 = &v176[32 * (v172 - 1 - (v247 >> 5))];
            }
            v261 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v242;
            *(_QWORD *)(a3 + 40) = v243;
            *(_QWORD *)(a3 + 48) = v246;
            while ( v250 != v245 )
            {
              v245 -= 4;
              sub_42F30(v245);
            }
            if ( v250 )
            {
              v262 = *(_QWORD *)(a3 + 56);
              if ( v262 + 4096 < (unsigned __int64)v250 || v262 > (unsigned __int64)v250 )
              {
                free(v250);
              }
              else if ( *(_QWORD *)(v262 + 4096) == v261 )
              {
                *(_QWORD *)(v262 + 4096) = v250;
                v124 = (void **)v360[0];
                if ( !v360[0] )
                  goto LABEL_490;
                goto LABEL_479;
              }
            }
            v124 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_490;
LABEL_479:
            v274 = (void **)v360[1];
            if ( v360[1] != v124 )
            {
              do
              {
                if ( (*(_BYTE *)(v274 - 3) & 1) != 0 )
                  free(*(v274 - 1));
                v275 = v274 - 6;
                if ( (*(_BYTE *)(v274 - 6) & 1) != 0 )
                  free(*(v274 - 4));
                v274 -= 6;
              }
              while ( v124 != v275 );
            }
            v360[1] = v124;
            if ( v362 + 4096 < (unsigned __int64)v124 || v362 > (unsigned __int64)v124 )
            {
              free(v124);
            }
            else if ( *(void **)(v362 + 4096) == p )
            {
              *(_QWORD *)(v362 + 4096) = v124;
            }
LABEL_490:
            v153 = 0;
            LOBYTE(v83) = 1;
            if ( (v363 & 1) == 0 )
              goto LABEL_492;
            goto LABEL_491;
          case 'L':
            if ( v46 + 1 != v4 )
            {
              LOBYTE(v83) = 0;
              ++v46;
              continue;
            }
            goto LABEL_674;
          case 'S':
            if ( v46 + 1 != v4 && v46[1] == 116 )
              goto LABEL_175;
            v138 = sub_43E00(v46, v4, (void **)a3);
            v111 = v138;
            if ( v138 == v46 || v138 == v4 )
              goto LABEL_674;
            v139 = *(_QWORD *)(a3 + 8);
            v140 = *(unsigned __int8 *)(v139 - 24);
            if ( (v140 & 1) != 0 )
              v141 = *(const void **)(v139 - 8);
            else
              v141 = (const void *)(v139 - 23);
            if ( (v140 & 1) != 0 )
              v142 = *(_QWORD *)(v139 - 16);
            else
              v142 = v140 >> 1;
            sub_42BE4((size_t *)(v139 - 48), v141, v142);
            v364 = *(void **)(v139 - 32);
            v363 = *(_OWORD *)(v139 - 48);
            *(_QWORD *)(v139 - 40) = 0;
            *(_QWORD *)(v139 - 32) = 0;
            *(_QWORD *)(v139 - 48) = 0;
            v143 = *(_QWORD *)(a3 + 8);
            v144 = (_BYTE *)(v143 - 48);
            if ( (*(_BYTE *)(v143 - 24) & 1) != 0 )
              free(*(void **)(v143 - 8));
            if ( (*v144 & 1) != 0 )
              free(*(void **)(v143 - 32));
            v145 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v144;
            if ( v145 == (void **)v144 )
            {
              v83 = 1;
              v111 = v46;
              if ( (v363 & 1) == 0 )
              {
LABEL_569:
                if ( !v83 )
                {
LABEL_146:
                  v46 = v111;
                  continue;
                }
                goto LABEL_674;
              }
LABEL_568:
              free(v364);
              goto LABEL_569;
            }
            v146 = (size_t *)(v143 - 96);
            v147 = *(unsigned __int8 *)(v143 - 96);
            if ( (v147 & 1) != 0 )
            {
              if ( !*(_QWORD *)(v143 - 88) )
              {
LABEL_260:
                if ( v146 != (size_t *)&v363 )
                {
                  if ( (v363 & 1) != 0 )
                    v148 = *((_QWORD *)&v363 + 1);
                  else
                    v148 = (unsigned __int64)(unsigned __int8)v363 >> 1;
                  if ( (v363 & 1) != 0 )
                    v149 = (char *)v364;
                  else
                    v149 = (char *)&v363 + 1;
                  sub_47A3C(v146, v149, v148);
                }
                goto LABEL_567;
              }
            }
            else if ( !(v147 >> 1) )
            {
              goto LABEL_260;
            }
            v181 = v363;
            v360[0] = 0;
            v360[1] = 0;
            p = 0;
            if ( (v363 & 1) != 0 )
              v182 = *((_QWORD *)&v363 + 1);
            else
              v182 = (unsigned __int64)(unsigned __int8)v363 >> 1;
            if ( v182 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v182 + 2 > 0x16 )
            {
              v183 = (char *)malloc((v182 + 18) & 0xFFFFFFFFFFFFFFF0LL);
              v360[0] = (void *)((v182 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1);
              v360[1] = &dword_0 + 2;
              p = v183;
            }
            else
            {
              v183 = (char *)v360 + 1;
              LOBYTE(v360[0]) = 4;
            }
            v228 = (char *)v364;
            strcpy(v183, "::");
            if ( (v181 & 1) != 0 )
              v229 = v228;
            else
              v229 = (char *)&v363 + 1;
            sub_42BE4((size_t *)v360, v229, v182);
            if ( ((__int64)v360[0] & 1) != 0 )
              v230 = v360[1];
            else
              v230 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
            if ( ((__int64)v360[0] & 1) != 0 )
              v231 = (char *)p;
            else
              v231 = (char *)v360 + 1;
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v231, (size_t)v230);
            if ( ((__int64)v360[0] & 1) != 0 )
              free(p);
            v232 = *(_QWORD *)(a3 + 8) - 48LL;
            v359 = *(_QWORD *)(a3 + 24);
            sub_42D60(v360, v232, &v359);
            v233 = *(_QWORD *)(a3 + 40);
            v234 = *(_QWORD *)(a3 + 48);
            if ( v233 < v234 )
            {
              *(_QWORD *)(v233 + 24) = v362;
              *(_OWORD *)v233 = *(_OWORD *)v360;
              *(_QWORD *)(v233 + 16) = p;
              v360[1] = 0;
              p = 0;
              v360[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v235 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_567;
              goto LABEL_556;
            }
            v236 = *(_QWORD *)(a3 + 32);
            v237 = (__int64)(v233 - v236) >> 5;
            if ( (unsigned __int64)(v237 + 1) >> 59 )
              abort();
            v238 = v234 - v236;
            if ( (unsigned __int64)(v238 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v240 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v239 = v238 >> 4;
              if ( v239 >= v237 + 1 )
                v240 = v239;
              else
                v240 = v237 + 1;
              if ( !v240 )
              {
                v241 = 0;
                goto LABEL_541;
              }
            }
            v282 = *(_QWORD *)(a3 + 56);
            v241 = *(char **)(v282 + 4096);
            if ( v282 + 4096 - (__int64)v241 >= (unsigned __int64)(32 * v240) )
              *(_QWORD *)(v282 + 4096) = &v241[32 * v240];
            else
              v241 = (char *)malloc(32 * v240);
LABEL_541:
            v283 = &v241[32 * v237];
            *((_QWORD *)v283 + 1) = 0;
            *((_QWORD *)v283 + 2) = 0;
            v284 = v283 + 32;
            *((_QWORD *)v283 + 3) = v362;
            *(_OWORD *)v283 = *(_OWORD *)v360;
            *((_QWORD *)v283 + 2) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            v286 = *(void ***)(a3 + 32);
            v285 = *(void ***)(a3 + 40);
            v287 = &v241[32 * v240];
            if ( v285 == v286 )
            {
              v291 = *(void ***)(a3 + 32);
            }
            else
            {
              v288 = (char *)(v285 - 4) - (char *)v286;
              v289 = v283 - 32;
              do
              {
                *((_QWORD *)v289 + 1) = 0;
                *((_QWORD *)v289 + 2) = 0;
                *(_QWORD *)v289 = 0;
                *((_QWORD *)v289 + 3) = *(v285 - 1);
                v290 = *((_OWORD *)v285 - 2);
                v285 -= 4;
                *(_OWORD *)v289 = v290;
                *((_QWORD *)v289 + 2) = v285[2];
                v289 -= 32;
                *v285 = 0;
                v285[1] = 0;
                v285[2] = 0;
              }
              while ( v286 != v285 );
              v291 = *(void ***)(a3 + 32);
              v286 = *(void ***)(a3 + 40);
              v283 = &v241[32 * (v237 - 1 - (v288 >> 5))];
            }
            v292 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v283;
            *(_QWORD *)(a3 + 40) = v284;
            *(_QWORD *)(a3 + 48) = v287;
            while ( v291 != v286 )
            {
              v286 -= 4;
              sub_42F30(v286);
            }
            if ( v291 )
            {
              v293 = *(_QWORD *)(a3 + 56);
              if ( v293 + 4096 < (unsigned __int64)v291 || v293 > (unsigned __int64)v291 )
              {
                free(v291);
              }
              else if ( *(_QWORD *)(v293 + 4096) == v292 )
              {
                *(_QWORD *)(v293 + 4096) = v291;
                v235 = (void **)v360[0];
                if ( !v360[0] )
                  goto LABEL_567;
                goto LABEL_556;
              }
            }
            v235 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_567;
LABEL_556:
            v294 = (void **)v360[1];
            if ( v360[1] != v235 )
            {
              do
              {
                if ( (*(_BYTE *)(v294 - 3) & 1) != 0 )
                  free(*(v294 - 1));
                v295 = v294 - 6;
                if ( (*(_BYTE *)(v294 - 6) & 1) != 0 )
                  free(*(v294 - 4));
                v294 -= 6;
              }
              while ( v235 != v295 );
            }
            v360[1] = v235;
            if ( v362 + 4096 < (unsigned __int64)v235 || v362 > (unsigned __int64)v235 )
            {
              free(v235);
            }
            else if ( *(void **)(v362 + 4096) == p )
            {
              *(_QWORD *)(v362 + 4096) = v235;
            }
LABEL_567:
            v83 = 0;
            v357 = 1;
            if ( (v363 & 1) == 0 )
              goto LABEL_569;
            goto LABEL_568;
          case 'T':
            v125 = sub_454F4(v46, v4, a3);
            v126 = (unsigned __int8 *)v125;
            if ( (unsigned __int8 *)v125 == v46 || (unsigned __int8 *)v125 == v4 )
              goto LABEL_674;
            v127 = *(_QWORD *)(a3 + 8);
            v128 = *(unsigned __int8 *)(v127 - 24);
            if ( (v128 & 1) != 0 )
              v129 = *(const void **)(v127 - 8);
            else
              v129 = (const void *)(v127 - 23);
            if ( (v128 & 1) != 0 )
              v130 = *(_QWORD *)(v127 - 16);
            else
              v130 = v128 >> 1;
            sub_42BE4((size_t *)(v127 - 48), v129, v130);
            v364 = *(void **)(v127 - 32);
            v363 = *(_OWORD *)(v127 - 48);
            *(_QWORD *)(v127 - 40) = 0;
            *(_QWORD *)(v127 - 32) = 0;
            *(_QWORD *)(v127 - 48) = 0;
            v131 = *(_QWORD *)(a3 + 8);
            v132 = (_BYTE *)(v131 - 48);
            if ( (*(_BYTE *)(v131 - 24) & 1) != 0 )
              free(*(void **)(v131 - 8));
            if ( (*v132 & 1) != 0 )
              free(*(void **)(v131 - 32));
            v133 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v132;
            if ( v133 == (void **)v132 )
            {
              v83 = 1;
              if ( (v363 & 1) == 0 )
              {
LABEL_509:
                if ( !v83 )
                  continue;
                goto LABEL_674;
              }
LABEL_508:
              free(v364);
              goto LABEL_509;
            }
            v134 = (size_t *)(v131 - 96);
            v135 = *(unsigned __int8 *)(v131 - 96);
            if ( (v135 & 1) != 0 )
            {
              if ( !*(_QWORD *)(v131 - 88) )
              {
LABEL_237:
                if ( v134 != (size_t *)&v363 )
                {
                  if ( (v363 & 1) != 0 )
                    v136 = *((_QWORD *)&v363 + 1);
                  else
                    v136 = (unsigned __int64)(unsigned __int8)v363 >> 1;
                  if ( (v363 & 1) != 0 )
                    v137 = (char *)v364;
                  else
                    v137 = (char *)&v363 + 1;
                  sub_47A3C(v134, v137, v136);
                }
                goto LABEL_350;
              }
            }
            else if ( !(v135 >> 1) )
            {
              goto LABEL_237;
            }
            v154 = v363;
            v360[0] = 0;
            v360[1] = 0;
            p = 0;
            if ( (v363 & 1) != 0 )
              v155 = *((_QWORD *)&v363 + 1);
            else
              v155 = (unsigned __int64)(unsigned __int8)v363 >> 1;
            if ( v155 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v155 + 2 > 0x16 )
            {
              v156 = (char *)malloc((v155 + 18) & 0xFFFFFFFFFFFFFFF0LL);
              v360[0] = (void *)((v155 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1);
              v360[1] = &dword_0 + 2;
              p = v156;
            }
            else
            {
              v156 = (char *)v360 + 1;
              LOBYTE(v360[0]) = 4;
            }
            v184 = (char *)v364;
            strcpy(v156, "::");
            if ( (v154 & 1) != 0 )
              v185 = v184;
            else
              v185 = (char *)&v363 + 1;
            sub_42BE4((size_t *)v360, v185, v155);
            if ( ((__int64)v360[0] & 1) != 0 )
              v186 = v360[1];
            else
              v186 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
            if ( ((__int64)v360[0] & 1) != 0 )
              v187 = (char *)p;
            else
              v187 = (char *)v360 + 1;
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v187, (size_t)v186);
            if ( ((__int64)v360[0] & 1) != 0 )
              free(p);
LABEL_350:
            v188 = *(_QWORD *)(a3 + 8) - 48LL;
            v359 = *(_QWORD *)(a3 + 24);
            sub_42D60(v360, v188, &v359);
            v189 = *(_QWORD *)(a3 + 40);
            v190 = *(_QWORD *)(a3 + 48);
            if ( v189 < v190 )
            {
              *(_QWORD *)(v189 + 24) = v362;
              *(_OWORD *)v189 = *(_OWORD *)v360;
              *(_QWORD *)(v189 + 16) = p;
              v360[1] = 0;
              p = 0;
              v360[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v191 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_507;
              goto LABEL_496;
            }
            v192 = *(_QWORD *)(a3 + 32);
            v193 = (__int64)(v189 - v192) >> 5;
            if ( (unsigned __int64)(v193 + 1) >> 59 )
              abort();
            v194 = v190 - v192;
            if ( (unsigned __int64)(v194 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v196 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v195 = v194 >> 4;
              if ( v195 >= v193 + 1 )
                v196 = v195;
              else
                v196 = v193 + 1;
              if ( !v196 )
              {
                v197 = 0;
                goto LABEL_447;
              }
            }
            v225 = *(_QWORD *)(a3 + 56);
            v197 = *(char **)(v225 + 4096);
            if ( v225 + 4096 - (__int64)v197 >= (unsigned __int64)(32 * v196) )
              *(_QWORD *)(v225 + 4096) = &v197[32 * v196];
            else
              v197 = (char *)malloc(32 * v196);
LABEL_447:
            v251 = &v197[32 * v193];
            *((_QWORD *)v251 + 1) = 0;
            *((_QWORD *)v251 + 2) = 0;
            v252 = v251 + 32;
            *((_QWORD *)v251 + 3) = v362;
            *(_OWORD *)v251 = *(_OWORD *)v360;
            *((_QWORD *)v251 + 2) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            v254 = *(void ***)(a3 + 32);
            v253 = *(void ***)(a3 + 40);
            v255 = &v197[32 * v196];
            if ( v253 == v254 )
            {
              v259 = *(void ***)(a3 + 32);
            }
            else
            {
              v256 = (char *)(v253 - 4) - (char *)v254;
              v257 = v251 - 32;
              do
              {
                *((_QWORD *)v257 + 1) = 0;
                *((_QWORD *)v257 + 2) = 0;
                *(_QWORD *)v257 = 0;
                *((_QWORD *)v257 + 3) = *(v253 - 1);
                v258 = *((_OWORD *)v253 - 2);
                v253 -= 4;
                *(_OWORD *)v257 = v258;
                *((_QWORD *)v257 + 2) = v253[2];
                v257 -= 32;
                *v253 = 0;
                v253[1] = 0;
                v253[2] = 0;
              }
              while ( v254 != v253 );
              v259 = *(void ***)(a3 + 32);
              v254 = *(void ***)(a3 + 40);
              v251 = &v197[32 * (v193 - 1 - (v256 >> 5))];
            }
            v263 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v251;
            *(_QWORD *)(a3 + 40) = v252;
            *(_QWORD *)(a3 + 48) = v255;
            while ( v259 != v254 )
            {
              v254 -= 4;
              sub_42F30(v254);
            }
            if ( v259 )
            {
              v264 = *(_QWORD *)(a3 + 56);
              if ( v264 + 4096 < (unsigned __int64)v259 || v264 > (unsigned __int64)v259 )
              {
                free(v259);
              }
              else if ( *(_QWORD *)(v264 + 4096) == v263 )
              {
                *(_QWORD *)(v264 + 4096) = v259;
                v191 = (void **)v360[0];
                if ( !v360[0] )
                  goto LABEL_507;
                goto LABEL_496;
              }
            }
            v191 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_507;
LABEL_496:
            v276 = (void **)v360[1];
            if ( v360[1] != v191 )
            {
              do
              {
                if ( (*(_BYTE *)(v276 - 3) & 1) != 0 )
                  free(*(v276 - 1));
                v277 = v276 - 6;
                if ( (*(_BYTE *)(v276 - 6) & 1) != 0 )
                  free(*(v276 - 4));
                v276 -= 6;
              }
              while ( v191 != v277 );
            }
            v360[1] = v191;
            if ( v362 + 4096 < (unsigned __int64)v191 || v362 > (unsigned __int64)v191 )
            {
              free(v191);
            }
            else if ( *(void **)(v362 + 4096) == p )
            {
              *(_QWORD *)(v362 + 4096) = v191;
            }
LABEL_507:
            v83 = 0;
            v46 = v126;
            v357 = 1;
            if ( (v363 & 1) == 0 )
              goto LABEL_509;
            goto LABEL_508;
          default:
LABEL_175:
            v97 = sub_46760(v46, v4, a3);
            v98 = v97;
            if ( v97 == v46 || v97 == v4 )
              goto LABEL_674;
            v99 = *(_QWORD *)(a3 + 8);
            v100 = *(unsigned __int8 *)(v99 - 24);
            if ( (v100 & 1) != 0 )
              v101 = *(const void **)(v99 - 8);
            else
              v101 = (const void *)(v99 - 23);
            if ( (v100 & 1) != 0 )
              v102 = *(_QWORD *)(v99 - 16);
            else
              v102 = v100 >> 1;
            sub_42BE4((size_t *)(v99 - 48), v101, v102);
            v364 = *(void **)(v99 - 32);
            v363 = *(_OWORD *)(v99 - 48);
            *(_QWORD *)(v99 - 40) = 0;
            *(_QWORD *)(v99 - 32) = 0;
            *(_QWORD *)(v99 - 48) = 0;
            v103 = *(_QWORD *)(a3 + 8);
            v104 = (_BYTE *)(v103 - 48);
            if ( (*(_BYTE *)(v103 - 24) & 1) != 0 )
              free(*(void **)(v103 - 8));
            if ( (*v104 & 1) != 0 )
              free(*(void **)(v103 - 32));
            v105 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v104;
            if ( v105 == (void **)v104 )
            {
              v83 = 1;
              if ( (v363 & 1) == 0 )
              {
LABEL_417:
                if ( !v83 )
                  continue;
                goto LABEL_674;
              }
LABEL_416:
              free(v364);
              goto LABEL_417;
            }
            v106 = (size_t *)(v103 - 96);
            v107 = *(unsigned __int8 *)(v103 - 96);
            if ( (v107 & 1) != 0 )
            {
              if ( !*(_QWORD *)(v103 - 88) )
              {
LABEL_190:
                if ( v106 != (size_t *)&v363 )
                {
                  if ( (v363 & 1) != 0 )
                    v108 = *((_QWORD *)&v363 + 1);
                  else
                    v108 = (unsigned __int64)(unsigned __int8)v363 >> 1;
                  if ( (v363 & 1) != 0 )
                    v109 = (char *)v364;
                  else
                    v109 = (char *)&v363 + 1;
                  sub_47A3C(v106, v109, v108);
                }
                goto LABEL_300;
              }
            }
            else if ( !(v107 >> 1) )
            {
              goto LABEL_190;
            }
            v150 = v363;
            v360[0] = 0;
            v360[1] = 0;
            p = 0;
            if ( (v363 & 1) != 0 )
              v151 = *((_QWORD *)&v363 + 1);
            else
              v151 = (unsigned __int64)(unsigned __int8)v363 >> 1;
            if ( v151 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v151 + 2 > 0x16 )
            {
              v152 = (char *)malloc((v151 + 18) & 0xFFFFFFFFFFFFFFF0LL);
              v360[0] = (void *)((v151 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1);
              v360[1] = &dword_0 + 2;
              p = v152;
            }
            else
            {
              v152 = (char *)v360 + 1;
              LOBYTE(v360[0]) = 4;
            }
            v157 = (char *)v364;
            strcpy(v152, "::");
            if ( (v150 & 1) != 0 )
              v158 = v157;
            else
              v158 = (char *)&v363 + 1;
            sub_42BE4((size_t *)v360, v158, v151);
            if ( ((__int64)v360[0] & 1) != 0 )
              v159 = v360[1];
            else
              v159 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
            if ( ((__int64)v360[0] & 1) != 0 )
              v160 = (char *)p;
            else
              v160 = (char *)v360 + 1;
            sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v160, (size_t)v159);
            if ( ((__int64)v360[0] & 1) != 0 )
              free(p);
LABEL_300:
            v161 = *(_QWORD *)(a3 + 8) - 48LL;
            v359 = *(_QWORD *)(a3 + 24);
            sub_42D60(v360, v161, &v359);
            v162 = *(_QWORD *)(a3 + 40);
            v163 = *(_QWORD *)(a3 + 48);
            if ( v162 < v163 )
            {
              *(_QWORD *)(v162 + 24) = v362;
              *(_OWORD *)v162 = *(_OWORD *)v360;
              *(_QWORD *)(v162 + 16) = p;
              v360[1] = 0;
              p = 0;
              v360[0] = 0;
              *(_QWORD *)(a3 + 40) += 32LL;
              v164 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_415;
              goto LABEL_404;
            }
            v165 = *(_QWORD *)(a3 + 32);
            v166 = (__int64)(v162 - v165) >> 5;
            if ( (unsigned __int64)(v166 + 1) >> 59 )
              abort();
            v167 = v163 - v165;
            if ( (unsigned __int64)(v167 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v169 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v168 = v167 >> 4;
              if ( v168 >= v166 + 1 )
                v169 = v168;
              else
                v169 = v166 + 1;
              if ( !v169 )
              {
                v170 = 0;
                goto LABEL_361;
              }
            }
            v180 = *(_QWORD *)(a3 + 56);
            v170 = *(char **)(v180 + 4096);
            if ( v180 + 4096 - (__int64)v170 >= (unsigned __int64)(32 * v169) )
              *(_QWORD *)(v180 + 4096) = &v170[32 * v169];
            else
              v170 = (char *)malloc(32 * v169);
LABEL_361:
            v198 = &v170[32 * v166];
            *((_QWORD *)v198 + 1) = 0;
            *((_QWORD *)v198 + 2) = 0;
            v199 = v198 + 32;
            *((_QWORD *)v198 + 3) = v362;
            *(_OWORD *)v198 = *(_OWORD *)v360;
            *((_QWORD *)v198 + 2) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            v201 = *(void ***)(a3 + 32);
            v200 = *(void ***)(a3 + 40);
            v202 = &v170[32 * v169];
            if ( v200 == v201 )
            {
              v206 = *(void ***)(a3 + 32);
            }
            else
            {
              v203 = (char *)(v200 - 4) - (char *)v201;
              v204 = v198 - 32;
              do
              {
                *((_QWORD *)v204 + 1) = 0;
                *((_QWORD *)v204 + 2) = 0;
                *(_QWORD *)v204 = 0;
                *((_QWORD *)v204 + 3) = *(v200 - 1);
                v205 = *((_OWORD *)v200 - 2);
                v200 -= 4;
                *(_OWORD *)v204 = v205;
                *((_QWORD *)v204 + 2) = v200[2];
                v204 -= 32;
                *v200 = 0;
                v200[1] = 0;
                v200[2] = 0;
              }
              while ( v201 != v200 );
              v206 = *(void ***)(a3 + 32);
              v201 = *(void ***)(a3 + 40);
              v198 = &v170[32 * (v166 - 1 - (v203 >> 5))];
            }
            v207 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v198;
            *(_QWORD *)(a3 + 40) = v199;
            *(_QWORD *)(a3 + 48) = v202;
            while ( v206 != v201 )
            {
              v201 -= 4;
              sub_42F30(v201);
            }
            if ( v206 )
            {
              v208 = *(_QWORD *)(a3 + 56);
              if ( v208 + 4096 < (unsigned __int64)v206 || v208 > (unsigned __int64)v206 )
              {
                free(v206);
              }
              else if ( *(_QWORD *)(v208 + 4096) == v207 )
              {
                *(_QWORD *)(v208 + 4096) = v206;
                v164 = (void **)v360[0];
                if ( !v360[0] )
                  goto LABEL_415;
                goto LABEL_404;
              }
            }
            v164 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_415;
LABEL_404:
            v226 = (void **)v360[1];
            if ( v360[1] != v164 )
            {
              do
              {
                if ( (*(_BYTE *)(v226 - 3) & 1) != 0 )
                  free(*(v226 - 1));
                v227 = v226 - 6;
                if ( (*(_BYTE *)(v226 - 6) & 1) != 0 )
                  free(*(v226 - 4));
                v226 -= 6;
              }
              while ( v164 != v227 );
            }
            v360[1] = v164;
            if ( v362 + 4096 < (unsigned __int64)v164 || v362 > (unsigned __int64)v164 )
            {
              free(v164);
            }
            else if ( *(void **)(v362 + 4096) == p )
            {
              *(_QWORD *)(v362 + 4096) = v164;
            }
LABEL_415:
            v83 = 0;
            v46 = v98;
            v357 = 1;
            if ( (v363 & 1) == 0 )
              goto LABEL_417;
            goto LABEL_416;
        }
      }
    }
    goto LABEL_673;
  }
  if ( a2 - v8 >= 2 )
  {
    if ( v9 == 83 && v8[1] == 116 )
    {
      if ( v8 + 2 == a2 )
      {
        v20 = 0;
        v21 = a2;
      }
      else
      {
        v20 = 0;
        if ( v8[2] == 76 )
          v21 = v8 + 3;
        else
          v21 = v8 + 2;
      }
    }
    else
    {
      v20 = 1;
      v21 = v8;
    }
    v22 = sub_46760(v21, a2, a3);
    v23 = v22;
    v24 = v22 == v21;
    if ( v22 == v21 )
      v25 = v8;
    else
      v25 = v22;
    if ( (v20 & 1) == 0 && !v24 )
    {
      v26 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 == v26 )
        goto LABEL_45;
      sub_429F4((size_t *)(v26 - 48), 0, "std::", 5u);
      v25 = v23;
    }
    if ( v25 != v8 )
    {
      if ( v25 != v4 )
      {
        if ( *v25 == 73 )
        {
          v27 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v27 )
            return v5;
          *(_QWORD *)&v363 = *(_QWORD *)(a3 + 24);
          sub_42D60(v360, v27 - 48, (__int64 *)&v363);
          v28 = *(_QWORD *)(a3 + 40);
          v29 = *(_QWORD *)(a3 + 48);
          if ( v28 < v29 )
          {
            *(_QWORD *)(v28 + 24) = v362;
            *(_OWORD *)v28 = *(_OWORD *)v360;
            *(_QWORD *)(v28 + 16) = p;
            v360[1] = 0;
            p = 0;
            v360[0] = 0;
            *(_QWORD *)(a3 + 40) += 32LL;
            v30 = (void **)v360[0];
            if ( !v360[0] )
              goto LABEL_611;
            goto LABEL_600;
          }
          v64 = *(_QWORD *)(a3 + 32);
          v65 = (__int64)(v28 - v64) >> 5;
          if ( (unsigned __int64)(v65 + 1) >> 59 )
            abort();
          v66 = v29 - v64;
          if ( (unsigned __int64)(v66 >> 5) > 0x3FFFFFFFFFFFFFELL )
          {
            v68 = 0x7FFFFFFFFFFFFFFLL;
          }
          else
          {
            v67 = v66 >> 4;
            if ( v67 >= v65 + 1 )
              v68 = v67;
            else
              v68 = v65 + 1;
            if ( !v68 )
            {
              v69 = 0;
              goto LABEL_585;
            }
          }
          v298 = *(_QWORD *)(a3 + 56);
          v69 = *(char **)(v298 + 4096);
          if ( v298 + 4096 - (__int64)v69 >= (unsigned __int64)(32 * v68) )
            *(_QWORD *)(v298 + 4096) = &v69[32 * v68];
          else
            v69 = (char *)malloc(32 * v68);
LABEL_585:
          v300 = &v69[32 * v65];
          *((_QWORD *)v300 + 1) = 0;
          *((_QWORD *)v300 + 2) = 0;
          v301 = v300 + 32;
          *((_QWORD *)v300 + 3) = v362;
          *(_OWORD *)v300 = *(_OWORD *)v360;
          *((_QWORD *)v300 + 2) = p;
          v360[1] = 0;
          p = 0;
          v360[0] = 0;
          v303 = *(void ***)(a3 + 32);
          v302 = *(void ***)(a3 + 40);
          v304 = &v69[32 * v68];
          if ( v302 == v303 )
          {
            v308 = *(void ***)(a3 + 32);
          }
          else
          {
            v305 = (char *)(v302 - 4) - (char *)v303;
            v306 = v300 - 32;
            do
            {
              *((_QWORD *)v306 + 1) = 0;
              *((_QWORD *)v306 + 2) = 0;
              *(_QWORD *)v306 = 0;
              *((_QWORD *)v306 + 3) = *(v302 - 1);
              v307 = *((_OWORD *)v302 - 2);
              v302 -= 4;
              *(_OWORD *)v306 = v307;
              *((_QWORD *)v306 + 2) = v302[2];
              v306 -= 32;
              *v302 = 0;
              v302[1] = 0;
              v302[2] = 0;
            }
            while ( v303 != v302 );
            v308 = *(void ***)(a3 + 32);
            v303 = *(void ***)(a3 + 40);
            v300 = &v69[32 * (v65 - 1 - (v305 >> 5))];
          }
          v309 = *(_QWORD *)(a3 + 48);
          *(_QWORD *)(a3 + 32) = v300;
          *(_QWORD *)(a3 + 40) = v301;
          *(_QWORD *)(a3 + 48) = v304;
          while ( v308 != v303 )
          {
            v303 -= 4;
            sub_42F30(v303);
          }
          if ( v308 )
          {
            v310 = *(_QWORD *)(a3 + 56);
            if ( v310 + 4096 < (unsigned __int64)v308 || v310 > (unsigned __int64)v308 )
            {
              free(v308);
            }
            else if ( *(_QWORD *)(v310 + 4096) == v309 )
            {
              *(_QWORD *)(v310 + 4096) = v308;
              v30 = (void **)v360[0];
              if ( !v360[0] )
                goto LABEL_611;
              goto LABEL_600;
            }
          }
          v30 = (void **)v360[0];
          if ( !v360[0] )
            goto LABEL_611;
LABEL_600:
          v311 = (void **)v360[1];
          if ( v360[1] != v30 )
          {
            do
            {
              if ( (*(_BYTE *)(v311 - 3) & 1) != 0 )
                free(*(v311 - 1));
              v312 = v311 - 6;
              if ( (*(_BYTE *)(v311 - 6) & 1) != 0 )
                free(*(v311 - 4));
              v311 -= 6;
            }
            while ( v30 != v312 );
          }
          v360[1] = v30;
          if ( v362 + 4096 < (unsigned __int64)v30 || v362 > (unsigned __int64)v30 )
          {
            free(v30);
          }
          else if ( *(void **)(v362 + 4096) == p )
          {
            *(_QWORD *)(v362 + 4096) = v30;
          }
LABEL_611:
          v4 = sub_42FE0(v25, v4, a3);
          if ( v4 != v25 )
          {
            v313 = *(_QWORD *)(a3 + 8);
            if ( 0xAAAAAAAAAAAAAAABLL * ((v313 - *(_QWORD *)a3) >> 4) < 2 )
              return v5;
            v314 = *(unsigned __int8 *)(v313 - 24);
            if ( (v314 & 1) != 0 )
              v315 = *(const void **)(v313 - 8);
            else
              v315 = (const void *)(v313 - 23);
            if ( (v314 & 1) != 0 )
              v316 = *(_QWORD *)(v313 - 16);
            else
              v316 = v314 >> 1;
            sub_42BE4((size_t *)(v313 - 48), v315, v316);
            p = *(void **)(v313 - 32);
            *(_OWORD *)v360 = *(_OWORD *)(v313 - 48);
            *(_QWORD *)(v313 - 40) = 0;
            *(_QWORD *)(v313 - 32) = 0;
            *(_QWORD *)(v313 - 48) = 0;
            v317 = *(_QWORD *)(a3 + 8);
            v318 = (_BYTE *)(v317 - 48);
            if ( (*(_BYTE *)(v317 - 24) & 1) != 0 )
              free(*(void **)(v317 - 8));
            if ( (*v318 & 1) != 0 )
              free(*(void **)(v317 - 32));
            v319 = *(void ***)a3;
            *(_QWORD *)(a3 + 8) = v318;
            if ( v319 != (void **)v318 )
            {
              v320 = (size_t *)(v317 - 96);
              v41 = (__int64)v360[0] & 1;
              if ( v41 )
                v321 = (char *)p;
              else
                v321 = (char *)v360 + 1;
              if ( ((__int64)v360[0] & 1) != 0 )
                v322 = v360[1];
              else
                v322 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
              sub_42BE4(v320, v321, (size_t)v322);
              if ( !a4 )
                goto LABEL_631;
              goto LABEL_68;
            }
            goto LABEL_634;
          }
          return v5;
        }
        return v25;
      }
      return v4;
    }
  }
LABEL_45:
  v31 = sub_43E00(v8, v4, (void **)a3);
  v32 = v31;
  if ( v31 == v8 )
    return v5;
  if ( v31 == v4 )
    return v5;
  if ( *v31 != 73 )
    return v5;
  v4 = sub_42FE0(v31, v4, a3);
  if ( v4 == v32 )
    return v5;
  v33 = *(_QWORD *)(a3 + 8);
  if ( 0xAAAAAAAAAAAAAAABLL * ((v33 - *(_QWORD *)a3) >> 4) < 2 )
    return v5;
  v34 = *(unsigned __int8 *)(v33 - 24);
  if ( (v34 & 1) != 0 )
    v35 = *(const void **)(v33 - 8);
  else
    v35 = (const void *)(v33 - 23);
  if ( (v34 & 1) != 0 )
    v36 = *(_QWORD *)(v33 - 16);
  else
    v36 = v34 >> 1;
  sub_42BE4((size_t *)(v33 - 48), v35, v36);
  p = *(void **)(v33 - 32);
  *(_OWORD *)v360 = *(_OWORD *)(v33 - 48);
  *(_QWORD *)(v33 - 40) = 0;
  *(_QWORD *)(v33 - 32) = 0;
  *(_QWORD *)(v33 - 48) = 0;
  v37 = *(_QWORD *)(a3 + 8);
  v38 = (_BYTE *)(v37 - 48);
  if ( (*(_BYTE *)(v37 - 24) & 1) != 0 )
    free(*(void **)(v37 - 8));
  if ( (*v38 & 1) != 0 )
    free(*(void **)(v37 - 32));
  v39 = *(void ***)a3;
  *(_QWORD *)(a3 + 8) = v38;
  if ( v39 != (void **)v38 )
  {
    v40 = (size_t *)(v37 - 96);
    v41 = (__int64)v360[0] & 1;
    if ( v41 )
      v42 = (char *)p;
    else
      v42 = (char *)v360 + 1;
    if ( ((__int64)v360[0] & 1) != 0 )
      v43 = v360[1];
    else
      v43 = (void *)((unsigned __int64)LOBYTE(v360[0]) >> 1);
    sub_42BE4(v40, v42, (size_t)v43);
    if ( !a4 )
    {
LABEL_631:
      v44 = 0;
      if ( !v41 )
        goto LABEL_70;
LABEL_69:
      free(p);
      goto LABEL_70;
    }
LABEL_68:
    v44 = 0;
    *a4 = 1;
    if ( !v41 )
      goto LABEL_70;
    goto LABEL_69;
  }
LABEL_634:
  v44 = 1;
  v4 = v5;
  if ( ((__int64)v360[0] & 1) != 0 )
    goto LABEL_69;
LABEL_70:
  if ( !v44 )
    return v4;
  return v5;
}
// 0: using guessed type int dword_0;
// 36F74: using guessed type __int64 __fastcall sub_36F74(_QWORD, _QWORD, _QWORD);

//----- (0000000000042838) ----------------------------------------------------
unsigned __int8 *__fastcall sub_42838(unsigned __int8 *result, unsigned __int8 *a2)
{
  int v2; // w8
  unsigned __int8 *v3; // x9
  int v4; // w10
  unsigned __int8 *v5; // x9
  unsigned __int8 *v6; // x9
  int v7; // t1
  unsigned __int8 *v8; // x9
  int v9; // w10
  unsigned __int8 *v10; // x9
  unsigned __int8 *v11; // x8
  int v12; // w10
  unsigned __int8 *v13; // x9
  int v14; // w10
  unsigned __int8 *v15; // x9
  unsigned __int8 *v16; // x9
  int v17; // t1

  if ( result != a2 )
  {
    v2 = *result;
    if ( v2 == 118 )
    {
      if ( result + 1 != a2 )
      {
        v8 = result[1] == 110 ? result + 2 : result + 1;
        if ( v8 != a2 )
        {
          v9 = *v8;
          if ( v9 == 48 )
          {
            v10 = v8 + 1;
          }
          else
          {
            if ( (unsigned int)(v9 - 49) > 8 )
              return result;
            v10 = v8 + 1;
            if ( v10 == a2 )
              return result;
            while ( (unsigned int)*v10 - 48 < 0xA )
            {
              if ( a2 == ++v10 )
                return result;
            }
          }
          if ( v10 != result + 1 && v10 != a2 && *v10 == 95 )
          {
            v11 = v10 + 1;
            if ( v10 + 1 != a2 )
            {
              v12 = v10[1];
              v13 = v10 + 2;
              if ( v12 != 110 )
                v13 = v11;
              if ( v13 != a2 )
              {
                v14 = *v13;
                if ( v14 == 48 )
                {
                  v15 = v13 + 1;
                }
                else
                {
                  if ( (unsigned int)(v14 - 49) > 8 )
                    return result;
                  v15 = v13 + 1;
                  if ( v15 == a2 )
                    return result;
                  while ( (unsigned int)*v15 - 48 < 0xA )
                  {
                    if ( a2 == ++v15 )
                      return result;
                  }
                }
                if ( v15 != v11 && v15 != a2 )
                {
                  v17 = *v15;
                  v16 = v15 + 1;
                  if ( v17 == 95 )
                    return v16;
                }
              }
            }
          }
        }
      }
    }
    else if ( v2 == 104 && result + 1 != a2 )
    {
      v3 = result[1] == 110 ? result + 2 : result + 1;
      if ( v3 != a2 )
      {
        v4 = *v3;
        if ( v4 == 48 )
        {
          v5 = v3 + 1;
        }
        else
        {
          if ( (unsigned int)(v4 - 49) > 8 )
            return result;
          v5 = v3 + 1;
          if ( v5 == a2 )
            return result;
          while ( (unsigned int)*v5 - 48 < 0xA )
          {
            if ( a2 == ++v5 )
              return result;
          }
        }
        if ( v5 != result + 1 && v5 != a2 )
        {
          v7 = *v5;
          v6 = v5 + 1;
          if ( v7 == 95 )
            return v6;
        }
      }
    }
  }
  return result;
}

//----- (00000000000429F4) ----------------------------------------------------
size_t *__fastcall sub_429F4(size_t *a1, size_t a2, char *a3, size_t a4)
{
  unsigned __int64 v5; // x8
  char *v7; // x21
  size_t v9; // x27
  unsigned __int64 v10; // x28
  unsigned __int64 v11; // x23
  char *v12; // x8
  char *v13; // x23
  unsigned __int64 v14; // x8
  size_t v15; // x24
  char *v16; // x22
  size_t v18; // x8
  char *v19; // x8
  char *v20; // x0
  char *v21; // x25
  char *p; // [xsp+8h] [xbp-58h]

  v5 = *(unsigned __int8 *)a1;
  v7 = a3;
  if ( (v5 & 1) != 0 )
  {
    v9 = a1[1];
    if ( v9 < a2 )
      goto LABEL_44;
  }
  else
  {
    v9 = v5 >> 1;
    if ( v5 >> 1 < a2 )
LABEL_44:
      abort();
  }
  if ( (v5 & 1) != 0 )
    v10 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v10 = 22;
  if ( v10 - v9 < a4 )
  {
    v11 = v9 + a4;
    if ( -18LL - v10 < v9 + a4 - v10 )
      goto LABEL_44;
    if ( (v5 & 1) != 0 )
      v12 = (char *)a1[2];
    else
      v12 = (char *)a1 + 1;
    p = v12;
    if ( v10 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v15 = -17;
    }
    else
    {
      v14 = 2 * v10;
      if ( v11 >= 2 * v10 )
        v14 = v9 + a4;
      if ( v14 >= 0x17 )
        v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v15 = 23;
    }
    v20 = (char *)malloc(v15);
    v21 = v20;
    if ( a2 )
      memcpy(v20, p, a2);
    memcpy(&v21[a2], v7, a4);
    if ( v9 != a2 )
      memcpy(&v21[a2 + a4], &p[a2], v9 - a2);
    if ( v10 != 22 )
      free(p);
    *a1 = v15 | 1;
    v19 = &v21[v11];
    a1[1] = v11;
    a1[2] = (size_t)v21;
    goto LABEL_42;
  }
  if ( a4 )
  {
    if ( (v5 & 1) != 0 )
      v13 = (char *)a1[2];
    else
      v13 = (char *)a1 + 1;
    v16 = &v13[a2];
    if ( v9 != a2 )
    {
      if ( &v13[v9] > a3 && v16 <= a3 )
        v7 = &a3[a4];
      memmove(&v16[a4], v16, v9 - a2);
    }
    memmove(v16, v7, a4);
    v18 = v9 + a4;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v18;
    else
      *(_BYTE *)a1 = 2 * v18;
    v19 = &v13[v18];
LABEL_42:
    *v19 = 0;
  }
  return a1;
}

//----- (0000000000042BE4) ----------------------------------------------------
size_t *__fastcall sub_42BE4(size_t *a1, const void *a2, size_t a3)
{
  unsigned __int64 v4; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  void *v10; // x23
  char *v11; // x23
  unsigned __int64 v12; // x8
  size_t v13; // x24
  size_t v14; // x8
  char *v15; // x8
  char *v16; // x0
  char *v17; // x25

  v4 = *(unsigned __int8 *)a1;
  if ( (v4 & 1) != 0 )
  {
    v7 = a1[1];
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v7 = v4 >> 1;
    v8 = 22;
  }
  if ( v8 - v7 < a3 )
  {
    v9 = v7 + a3;
    if ( -18LL - v8 < v7 + a3 - v8 )
      abort();
    if ( (v4 & 1) != 0 )
      v10 = (void *)a1[2];
    else
      v10 = (char *)a1 + 1;
    if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v13 = -17;
    }
    else
    {
      v12 = 2 * v8;
      if ( v9 >= 2 * v8 )
        v12 = v7 + a3;
      if ( v12 >= 0x17 )
        v13 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v13 = 23;
    }
    v16 = (char *)malloc(v13);
    v17 = v16;
    if ( v7 )
      memcpy(v16, v10, v7);
    memcpy(&v17[v7], a2, a3);
    if ( v8 != 22 )
      free(v10);
    *a1 = v13 | 1;
    v15 = &v17[v9];
    a1[1] = v9;
    a1[2] = (size_t)v17;
    goto LABEL_29;
  }
  if ( a3 )
  {
    if ( (v4 & 1) != 0 )
      v11 = (char *)a1[2];
    else
      v11 = (char *)a1 + 1;
    memcpy(&v11[v7], a2, a3);
    v14 = v7 + a3;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v14;
    else
      *(_BYTE *)a1 = 2 * v14;
    v15 = &v11[v14];
LABEL_29:
    *v15 = 0;
  }
  return a1;
}

//----- (0000000000042D60) ----------------------------------------------------
_QWORD *__fastcall sub_42D60(_QWORD *result, __int64 a2, __int64 *a3)
{
  size_t **v3; // x19
  __int64 v4; // x9
  size_t *v6; // x20
  size_t *v7; // x8
  size_t v8; // x22
  const void *v9; // x23
  void *v10; // x24
  size_t v11; // x22
  const void *v12; // x21
  void *v13; // x23

  v3 = (size_t **)result;
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  v4 = *a3;
  result[3] = *a3;
  v6 = *(size_t **)(v4 + 4096);
  if ( (unsigned __int64)(v4 + 4096 - (_QWORD)v6) >= 0x30 )
  {
    v7 = v6 + 6;
    *(_QWORD *)(v4 + 4096) = v6 + 6;
  }
  else
  {
    result = malloc(0x30u);
    v6 = result;
    v7 = result + 6;
  }
  *v3 = v6;
  v3[1] = v6;
  v3[2] = v7;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = 0;
  if ( (*(_BYTE *)a2 & 1) == 0 )
  {
    v6[2] = *(_QWORD *)(a2 + 16);
    *(_OWORD *)v6 = *(_OWORD *)a2;
    goto LABEL_13;
  }
  v8 = *(_QWORD *)(a2 + 8);
  if ( v8 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  v9 = *(const void **)(a2 + 16);
  if ( v8 >= 0x17 )
  {
    v10 = malloc((v8 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    v6[1] = v8;
    v6[2] = (size_t)v10;
    *v6 = (v8 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    *(_BYTE *)v6 = 2 * v8;
    v10 = (char *)v6 + 1;
    if ( !v8 )
      goto LABEL_12;
  }
  result = memcpy(v10, v9, v8);
LABEL_12:
  *((_BYTE *)v10 + v8) = 0;
LABEL_13:
  v6[3] = 0;
  v6[4] = 0;
  v6[5] = 0;
  if ( (*(_BYTE *)(a2 + 24) & 1) != 0 )
  {
    v11 = *(_QWORD *)(a2 + 32);
    if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    v12 = *(const void **)(a2 + 40);
    if ( v11 >= 0x17 )
    {
      v13 = malloc((v11 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      v6[4] = v11;
      v6[5] = (size_t)v13;
      v6[3] = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v13 = (char *)v6 + 25;
      *((_BYTE *)v6 + 24) = 2 * v11;
      if ( !v11 )
        goto LABEL_21;
    }
    result = memcpy(v13, v12, v11);
LABEL_21:
    *((_BYTE *)v13 + v11) = 0;
    goto LABEL_22;
  }
  v6[5] = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(v6 + 3) = *(_OWORD *)(a2 + 24);
LABEL_22:
  v3[1] += 6;
  return result;
}

//----- (0000000000042F30) ----------------------------------------------------
void __fastcall sub_42F30(void **a1)
{
  void **v2; // x20
  void **v3; // x21
  void *v4; // x0
  void **v5; // x22
  unsigned __int64 v6; // x8

  v2 = (void **)*a1;
  if ( *a1 )
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if ( v3 != v2 )
    {
      do
      {
        if ( (*(_BYTE *)(v3 - 3) & 1) != 0 )
          free(*(v3 - 1));
        v5 = v3 - 6;
        if ( (*(_BYTE *)(v3 - 6) & 1) != 0 )
          free(*(v3 - 4));
        v3 -= 6;
      }
      while ( v2 != v5 );
      v4 = *a1;
    }
    v6 = (unsigned __int64)a1[3];
    a1[1] = v2;
    if ( v6 + 4096 < (unsigned __int64)v4 || v6 > (unsigned __int64)v4 )
    {
      free(v4);
    }
    else if ( *(void **)(v6 + 4096) == a1[2] )
    {
      *(_QWORD *)(v6 + 4096) = v4;
    }
  }
}

//----- (0000000000042FE0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_42FE0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // x23
  __int64 v4; // x27
  __int64 v5; // x19
  void **v6; // x20
  void **i; // x21
  unsigned __int8 *v8; // x24
  unsigned __int64 v9; // x10
  char *v10; // x9
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x12
  bool v13; // zf
  char *v14; // x8
  unsigned __int64 v15; // x9
  unsigned __int8 *v16; // x19
  _QWORD *v18; // x8
  unsigned __int64 v19; // x9
  __int64 v20; // x19
  __int64 v21; // x10
  __int64 v22; // x20
  __int64 v23; // x9
  unsigned __int64 v24; // x9
  __int64 v25; // x21
  size_t v26; // x8
  char *v27; // x0
  char *v28; // x8
  char *v29; // x10
  _QWORD *v30; // x11
  _QWORD *v31; // x9
  _QWORD *v32; // x12
  __int128 v33; // t1
  __int64 v34; // x12
  char *v35; // x8
  unsigned __int64 v36; // x19
  __int64 v37; // x20
  unsigned __int64 v38; // x21
  __int64 v39; // x22
  __int64 v40; // x26
  void **v41; // x23
  void **v42; // x27
  void **v43; // x25
  void *v44; // x0
  unsigned __int64 v45; // x8
  int v46; // w23
  unsigned __int64 v47; // x22
  __int64 v48; // x19
  __int64 v49; // x21
  _QWORD *v50; // x8
  unsigned __int64 v51; // x9
  __int64 v52; // x10
  __int64 v53; // x20
  __int64 v54; // x9
  unsigned __int64 v55; // x23
  unsigned __int64 v56; // x9
  __int64 v57; // x22
  char *v58; // x0
  __int64 v59; // x9
  char *v60; // x12
  void **v61; // x11
  void **v62; // x24
  char *v63; // x8
  _QWORD *v64; // x9
  unsigned __int64 v65; // x10
  char *v66; // x12
  __int128 v67; // t1
  void **v68; // x25
  __int64 v69; // x20
  unsigned __int64 v70; // x8
  unsigned __int64 v71; // x19
  char *v72; // x24
  size_t *v73; // x20
  char *v74; // x28
  unsigned __int64 v75; // x8
  size_t v76; // x25
  const void *v77; // x1
  void *v78; // x27
  const void *v79; // x27
  void *v80; // x0
  char *v81; // x8
  char *v82; // x25
  char *v83; // x25
  unsigned __int64 v84; // x8
  unsigned __int64 v85; // x8
  char v86; // t1
  unsigned __int64 v87; // x8
  size_t v88; // x26
  const void *v89; // x27
  void *v90; // x25
  void *v91; // x0
  char *v92; // x8
  void **v93; // x9
  void **v94; // x22
  _QWORD *v95; // x8
  size_t v96; // x10
  void **v97; // x24
  __int64 v98; // x23
  void **v99; // x20
  unsigned __int64 v100; // x8
  unsigned __int64 v101; // x23
  __int64 v102; // x21
  __int64 v103; // x25
  size_t *v104; // x9
  size_t *v105; // x20
  __int64 v106; // x10
  unsigned __int64 v107; // x22
  unsigned __int64 v108; // x9
  __int64 v109; // x26
  unsigned __int64 v110; // x9
  __int64 v111; // x8
  size_t v112; // x0
  unsigned __int64 v113; // x8
  size_t v114; // x24
  const void *v115; // x25
  void *v116; // x26
  _BYTE *v117; // x24
  unsigned __int64 v118; // x8
  unsigned __int64 v119; // x8
  char v120; // t1
  unsigned __int64 v121; // x8
  size_t v122; // x25
  const void *v123; // x26
  void *v124; // x24
  __int64 v125; // x19
  unsigned __int64 v126; // x20
  unsigned __int64 v127; // x8
  __int64 v128; // x0
  unsigned __int64 v129; // x8
  const void *v130; // x1
  size_t v131; // x2
  size_t *v132; // x0
  char *v133; // x24
  char v134; // w21
  char *v135; // x1
  size_t v136; // x2
  __int64 v137; // x19
  _BYTE *v138; // x20
  void *v139; // x22
  char v140; // w20
  __int64 v141; // x8
  __int64 v142; // x9
  unsigned __int64 v143; // x8
  unsigned __int64 v144; // x9
  unsigned __int64 v145; // x21
  __int64 v146; // x19
  unsigned __int64 v147; // x9
  unsigned __int64 v148; // x9
  __int64 v149; // x9
  char *v150; // x0
  char *v151; // x8
  char *v152; // x9
  __int64 v153; // x11
  unsigned __int64 v154; // x20
  char *v155; // x10
  __int64 v156; // x12
  void *v157; // x22
  __int64 v158; // x19
  void *v159; // x21
  unsigned __int64 v160; // x8
  size_t byte_count; // [xsp+10h] [xbp-100h]
  unsigned __int8 *v162; // [xsp+20h] [xbp-F0h]
  unsigned __int8 *v163; // [xsp+28h] [xbp-E8h]
  unsigned __int64 v164; // [xsp+30h] [xbp-E0h]
  unsigned __int64 v165; // [xsp+40h] [xbp-D0h]
  __int64 v166; // [xsp+48h] [xbp-C8h]
  unsigned __int8 *v167; // [xsp+50h] [xbp-C0h]
  __int128 v168; // [xsp+58h] [xbp-B8h] BYREF
  void *p; // [xsp+68h] [xbp-A8h]
  _BYTE v170[15]; // [xsp+70h] [xbp-A0h] BYREF
  _QWORD v171[2]; // [xsp+80h] [xbp-90h] BYREF
  __int128 v172; // [xsp+90h] [xbp-80h] BYREF
  _QWORD *v173; // [xsp+A0h] [xbp-70h]
  char *v174; // [xsp+A8h] [xbp-68h]
  size_t v175; // [xsp+B0h] [xbp-60h]
  __int64 v176; // [xsp+B8h] [xbp-58h]

  v3 = a2;
  v4 = a3;
  v167 = a1;
  v176 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 2 || *a1 != 73 )
    return a1;
  if ( *(_BYTE *)(a3 + 109) )
  {
    v5 = *(_QWORD *)(a3 + 72);
    v6 = *(void ***)(v5 - 32);
    for ( i = *(void ***)(v5 - 24); v6 != i; sub_42F30(i) )
      i -= 4;
    *(_QWORD *)(v5 - 24) = v6;
  }
  p = 0;
  v168 = 0x3C02u;
  v8 = v167 + 1;
  if ( v167[1] != 69 )
  {
    byte_count = v4 + 88;
    v166 = v4;
    v162 = v3;
    while ( 1 )
    {
      if ( !*(_BYTE *)(v4 + 109) )
        goto LABEL_37;
      v18 = *(_QWORD **)(v4 + 72);
      v19 = *(_QWORD *)(v4 + 80);
      v20 = *(_QWORD *)(v4 + 24);
      if ( (unsigned __int64)v18 < v19 )
      {
        *v18 = 0;
        v18[1] = 0;
        v18[2] = 0;
        v18[3] = v20;
        *(_QWORD *)(v4 + 72) += 32LL;
        goto LABEL_37;
      }
      v21 = *(_QWORD *)(v4 + 64);
      v22 = ((__int64)v18 - v21) >> 5;
      if ( (unsigned __int64)(v22 + 1) >> 59 )
        abort();
      v23 = v19 - v21;
      if ( (unsigned __int64)(v23 >> 5) >= 0x3FFFFFFFFFFFFFFLL )
        break;
      v24 = v23 >> 4;
      if ( v24 >= v22 + 1 )
        v25 = v24;
      else
        v25 = v22 + 1;
      v26 = byte_count;
      v174 = 0;
      v175 = byte_count;
      if ( v25 )
        goto LABEL_29;
      v27 = 0;
LABEL_32:
      v28 = &v27[32 * v22];
      v29 = &v27[32 * v25];
      v30 = v28 + 32;
      *(_QWORD *)&v172 = v27;
      *((_QWORD *)&v172 + 1) = v28;
      *(_QWORD *)v28 = 0;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = 0;
      *((_QWORD *)v28 + 3) = v20;
      v173 = v28 + 32;
      v174 = v29;
      v31 = *(_QWORD **)(v4 + 64);
      v32 = *(_QWORD **)(v4 + 72);
      if ( v32 == v31 )
      {
        v34 = *(_QWORD *)(v4 + 64);
      }
      else
      {
        do
        {
          *((_QWORD *)v28 - 3) = 0;
          *((_QWORD *)v28 - 2) = 0;
          *((_QWORD *)v28 - 4) = 0;
          *((_QWORD *)v28 - 1) = *(v32 - 1);
          v33 = *((_OWORD *)v32 - 2);
          v32 -= 4;
          *((_OWORD *)v28 - 2) = v33;
          *((_QWORD *)v28 - 2) = v32[2];
          v32[1] = 0;
          v32[2] = 0;
          *v32 = 0;
          v28 = (char *)(*((_QWORD *)&v172 + 1) - 32LL);
          *((_QWORD *)&v172 + 1) -= 32LL;
        }
        while ( v31 != v32 );
        v34 = *(_QWORD *)(v4 + 64);
        v31 = *(_QWORD **)(v4 + 72);
        v30 = v173;
        v29 = v174;
      }
      *(_QWORD *)(v4 + 64) = v28;
      *(_QWORD *)(v4 + 72) = v30;
      *((_QWORD *)&v172 + 1) = v34;
      v173 = v31;
      v35 = *(char **)(v4 + 80);
      *(_QWORD *)(v4 + 80) = v29;
      *(_QWORD *)&v172 = v34;
      v174 = v35;
      sub_5859C((__int64)&v172);
LABEL_37:
      v36 = *(_QWORD *)v4;
      v37 = *(_QWORD *)(v4 + 8);
      v163 = sub_58458(v8, v3, (unsigned __int64 *)v4);
      v38 = *(_QWORD *)v4;
      v39 = *(_QWORD *)(v4 + 8);
      if ( *(_BYTE *)(v4 + 109) )
      {
        v40 = *(_QWORD *)(v4 + 72);
        v41 = (void **)(v40 - 32);
        v42 = *(void ***)(v40 - 32);
        if ( v42 )
        {
          v43 = *(void ***)(v40 - 24);
          v44 = *(void **)(v40 - 32);
          if ( v43 != v42 )
          {
            do
            {
              v43 -= 4;
              sub_42F30(v43);
            }
            while ( v42 != v43 );
            v44 = *v41;
          }
          v45 = *(_QWORD *)(v40 - 8);
          *(_QWORD *)(v40 - 24) = v42;
          if ( v45 + 4096 < (unsigned __int64)v44 || v45 > (unsigned __int64)v44 )
          {
            free(v44);
          }
          else if ( *(_QWORD *)(v45 + 4096) == *(_QWORD *)(v40 - 16) )
          {
            *(_QWORD *)(v45 + 4096) = v44;
          }
        }
        v4 = v166;
        *(_QWORD *)(v166 + 72) = v41;
      }
      v46 = 1;
      if ( v163 == v8 || v163 == v162 )
      {
        v16 = v167;
        goto LABEL_207;
      }
      v47 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v39 - v38) >> 4);
      v165 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v37 - v36) >> 4);
      if ( !*(_BYTE *)(v4 + 109) )
        goto LABEL_144;
      v48 = *(_QWORD *)(v4 + 72);
      v49 = *(_QWORD *)(v4 + 24);
      v50 = *(_QWORD **)(v48 - 24);
      v51 = *(_QWORD *)(v48 - 16);
      if ( (unsigned __int64)v50 < v51 )
      {
        *v50 = 0;
        v50[1] = 0;
        v50[2] = 0;
        v50[3] = v49;
        *(_QWORD *)(v48 - 24) += 32LL;
        goto LABEL_77;
      }
      v52 = *(_QWORD *)(v48 - 32);
      v53 = ((__int64)v50 - v52) >> 5;
      if ( (unsigned __int64)(v53 + 1) >> 59 )
        abort();
      v54 = v51 - v52;
      v55 = v47;
      if ( (unsigned __int64)(v54 >> 5) > 0x3FFFFFFFFFFFFFELL )
      {
        v57 = 0x7FFFFFFFFFFFFFFLL;
      }
      else
      {
        v56 = v54 >> 4;
        if ( v56 >= v53 + 1 )
          v57 = v56;
        else
          v57 = v53 + 1;
        if ( !v57 )
        {
          v58 = 0;
          goto LABEL_64;
        }
      }
      v59 = *(_QWORD *)(v48 - 8);
      v58 = *(char **)(v59 + 4096);
      if ( v59 + 4096 - (__int64)v58 >= (unsigned __int64)(32 * v57) )
        *(_QWORD *)(v59 + 4096) = &v58[32 * v57];
      else
        v58 = (char *)malloc(32 * v57);
LABEL_64:
      v60 = &v58[32 * v53];
      *(_QWORD *)v60 = 0;
      *((_QWORD *)v60 + 1) = 0;
      *((_QWORD *)v60 + 2) = 0;
      *((_QWORD *)v60 + 3) = v49;
      v62 = *(void ***)(v48 - 32);
      v61 = *(void ***)(v48 - 24);
      v63 = &v58[32 * v57];
      v64 = v60 + 32;
      if ( v61 == v62 )
      {
        v68 = *(void ***)(v48 - 32);
        v47 = v55;
      }
      else
      {
        v65 = (char *)(v61 - 4) - (char *)v62;
        v66 = v60 - 32;
        v47 = v55;
        do
        {
          *((_QWORD *)v66 + 1) = 0;
          *((_QWORD *)v66 + 2) = 0;
          *(_QWORD *)v66 = 0;
          *((_QWORD *)v66 + 3) = *(v61 - 1);
          v67 = *((_OWORD *)v61 - 2);
          v61 -= 4;
          *(_OWORD *)v66 = v67;
          *((_QWORD *)v66 + 2) = v61[2];
          v66 -= 32;
          *v61 = 0;
          v61[1] = 0;
          v61[2] = 0;
        }
        while ( v62 != v61 );
        v68 = *(void ***)(v48 - 32);
        v62 = *(void ***)(v48 - 24);
        v60 = &v58[32 * (v53 - 1 - (v65 >> 5))];
      }
      v69 = *(_QWORD *)(v48 - 16);
      *(_QWORD *)(v48 - 32) = v60;
      *(_QWORD *)(v48 - 24) = v64;
      *(_QWORD *)(v48 - 16) = v63;
      while ( v68 != v62 )
      {
        v62 -= 4;
        sub_42F30(v62);
      }
      if ( v68 )
      {
        v70 = *(_QWORD *)(v48 - 8);
        if ( v70 + 4096 < (unsigned __int64)v68 || v70 > (unsigned __int64)v68 )
        {
          free(v68);
        }
        else if ( *(_QWORD *)(v70 + 4096) == v69 )
        {
          *(_QWORD *)(v70 + 4096) = v68;
        }
      }
LABEL_77:
      if ( v165 < v47 )
      {
        v71 = v165;
        v164 = v47;
        do
        {
          v101 = *(_QWORD *)v4;
          v102 = *(_QWORD *)(*(_QWORD *)(v4 + 72) - 24LL);
          v103 = *(_QWORD *)v4 + 48 * v71;
          v105 = *(size_t **)(v102 - 24);
          v104 = *(size_t **)(v102 - 16);
          if ( v105 == v104 )
          {
            v106 = *(_QWORD *)(v102 - 32);
            v107 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v105 - v106) >> 4);
            if ( v107 + 1 > 0x555555555555555LL )
              abort();
            v108 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v104 - v106) >> 4);
            v109 = 0x555555555555555LL;
            if ( v108 >= 0x2AAAAAAAAAAAAAALL
              || ((v110 = 2 * v108, v110 >= v107 + 1) ? (v109 = v110) : (v109 = v107 + 1), v109) )
            {
              v111 = *(_QWORD *)(v102 - 8);
              v112 = 48 * v109;
              v72 = *(char **)(v111 + 4096);
              if ( v111 + 4096 - (__int64)v72 >= (unsigned __int64)(48 * v109) )
                *(_QWORD *)(v111 + 4096) = &v72[v112];
              else
                v72 = (char *)malloc(v112);
            }
            else
            {
              v72 = 0;
            }
            v73 = (size_t *)&v72[48 * v107];
            v73[1] = 0;
            v73[2] = 0;
            *v73 = 0;
            v74 = &v72[48 * v109];
            if ( (*(_BYTE *)v103 & 1) == 0 )
            {
              v73[2] = *(_QWORD *)(v103 + 16);
              *(_OWORD *)v73 = *(_OWORD *)v103;
              goto LABEL_90;
            }
            v75 = v101 + 48 * v71;
            v76 = *(_QWORD *)(v75 + 8);
            if ( v76 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v77 = *(const void **)(v75 + 16);
            if ( v76 >= 0x17 )
            {
              v79 = *(const void **)(v75 + 16);
              v80 = malloc((v76 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v77 = v79;
              v78 = v80;
              v81 = &v72[48 * v107];
              *((_QWORD *)v81 + 1) = v76;
              *((_QWORD *)v81 + 2) = v80;
              *v73 = (v76 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v73 = 2 * v76;
              v78 = (char *)v73 + 1;
              if ( !v76 )
                goto LABEL_89;
            }
            memcpy(v78, v77, v76);
LABEL_89:
            *((_BYTE *)v78 + v76) = 0;
            v4 = v166;
LABEL_90:
            v82 = &v72[48 * v107];
            *((_QWORD *)v82 + 3) = 0;
            v83 = v82 + 24;
            v84 = v101 + 48 * v71;
            *((_QWORD *)v83 + 1) = 0;
            *((_QWORD *)v83 + 2) = 0;
            v86 = *(_BYTE *)(v84 + 24);
            v85 = v84 + 24;
            if ( (v86 & 1) == 0 )
            {
              *((_QWORD *)v83 + 2) = *(_QWORD *)(v85 + 16);
              *(_OWORD *)v83 = *(_OWORD *)v85;
LABEL_99:
              v94 = *(void ***)(v102 - 32);
              v93 = *(void ***)(v102 - 24);
              v95 = v73 + 6;
              if ( v93 == v94 )
              {
                v97 = *(void ***)(v102 - 32);
              }
              else
              {
                do
                {
                  *(v73 - 4) = (size_t)*(v93 - 4);
                  *((_OWORD *)v73 - 3) = *((_OWORD *)v93 - 3);
                  v96 = (size_t)*(v93 - 1);
                  *(v93 - 5) = 0;
                  *(v93 - 4) = 0;
                  *(v93 - 6) = 0;
                  *(v73 - 1) = v96;
                  *(_OWORD *)(v73 - 3) = *(_OWORD *)(v93 - 3);
                  *(v93 - 3) = 0;
                  *(v93 - 2) = 0;
                  *(v93 - 1) = 0;
                  v93 -= 6;
                  v73 -= 6;
                }
                while ( v94 != v93 );
                v97 = *(void ***)(v102 - 32);
                v94 = *(void ***)(v102 - 24);
              }
              v98 = *(_QWORD *)(v102 - 16);
              *(_QWORD *)(v102 - 32) = v73;
              *(_QWORD *)(v102 - 24) = v95;
              *(_QWORD *)(v102 - 16) = v74;
              if ( v94 != v97 )
              {
                do
                {
                  if ( (*(_BYTE *)(v94 - 3) & 1) != 0 )
                    free(*(v94 - 1));
                  v99 = v94 - 6;
                  if ( (*(_BYTE *)(v94 - 6) & 1) != 0 )
                    free(*(v94 - 4));
                  v94 -= 6;
                }
                while ( v97 != v99 );
              }
              v47 = v164;
              if ( v97 )
              {
                v100 = *(_QWORD *)(v102 - 8);
                if ( v100 + 4096 < (unsigned __int64)v97 || v100 > (unsigned __int64)v97 )
                {
                  free(v97);
                }
                else if ( *(_QWORD *)(v100 + 4096) == v98 )
                {
                  *(_QWORD *)(v100 + 4096) = v97;
                }
              }
              goto LABEL_143;
            }
            v87 = v101 + 48 * v71;
            v88 = *(_QWORD *)(v87 + 32);
            if ( v88 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v89 = *(const void **)(v87 + 40);
            if ( v88 >= 0x17 )
            {
              v91 = malloc((v88 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v92 = &v72[48 * v107];
              *((_QWORD *)v92 + 4) = v88;
              *((_QWORD *)v92 + 5) = v91;
              *(_QWORD *)v83 = (v88 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v90 = v91;
            }
            else
            {
              *v83 = 2 * v88;
              v90 = v83 + 1;
              if ( !v88 )
                goto LABEL_98;
            }
            memcpy(v90, v89, v88);
LABEL_98:
            v4 = v166;
            *((_BYTE *)v90 + v88) = 0;
            goto LABEL_99;
          }
          v105[1] = 0;
          v105[2] = 0;
          *v105 = 0;
          if ( (*(_BYTE *)v103 & 1) == 0 )
          {
            v105[2] = *(_QWORD *)(v103 + 16);
            *(_OWORD *)v105 = *(_OWORD *)v103;
            goto LABEL_133;
          }
          v113 = v101 + 48 * v71;
          v114 = *(_QWORD *)(v113 + 8);
          if ( v114 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v115 = *(const void **)(v113 + 16);
          if ( v114 >= 0x17 )
          {
            v116 = malloc((v114 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v105[1] = v114;
            v105[2] = (size_t)v116;
            v4 = v166;
            *v105 = (v114 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v105 = 2 * v114;
            v116 = (char *)v105 + 1;
            if ( !v114 )
              goto LABEL_132;
          }
          memcpy(v116, v115, v114);
LABEL_132:
          *((_BYTE *)v116 + v114) = 0;
LABEL_133:
          v105[3] = 0;
          v117 = v105 + 3;
          v118 = v101 + 48 * v71;
          v105[4] = 0;
          v105[5] = 0;
          v120 = *(_BYTE *)(v118 + 24);
          v119 = v118 + 24;
          if ( (v120 & 1) != 0 )
          {
            v121 = v101 + 48 * v71;
            v122 = *(_QWORD *)(v121 + 32);
            if ( v122 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v123 = *(const void **)(v121 + 40);
            if ( v122 >= 0x17 )
            {
              v124 = malloc((v122 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v105[4] = v122;
              v105[5] = (size_t)v124;
              v4 = v166;
              v105[3] = (v122 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v117 = 2 * v122;
              v124 = (char *)v105 + 25;
              if ( !v122 )
                goto LABEL_141;
            }
            memcpy(v124, v123, v122);
LABEL_141:
            *((_BYTE *)v124 + v122) = 0;
            goto LABEL_142;
          }
          v105[5] = *(_QWORD *)(v119 + 16);
          *(_OWORD *)v117 = *(_OWORD *)v119;
LABEL_142:
          *(_QWORD *)(v102 - 24) += 48LL;
LABEL_143:
          ++v71;
        }
        while ( v71 < v47 );
      }
LABEL_144:
      v3 = v162;
      if ( v165 < v47 )
      {
        v125 = 48 * v165;
        v126 = v165;
        do
        {
          if ( (v168 & 1) != 0 )
            v127 = *((_QWORD *)&v168 + 1);
          else
            v127 = (unsigned __int64)(unsigned __int8)v168 >> 1;
          if ( v127 >= 2 )
            sub_42BE4((size_t *)&v168, ", ", 2u);
          v128 = *(_QWORD *)v4 + v125;
          v129 = *(unsigned __int8 *)(v128 + 24);
          if ( (v129 & 1) != 0 )
            v130 = *(const void **)(v128 + 40);
          else
            v130 = (const void *)(v128 + 25);
          if ( (v129 & 1) != 0 )
            v131 = *(_QWORD *)(v128 + 32);
          else
            v131 = v129 >> 1;
          v132 = sub_42BE4((size_t *)v128, v130, v131);
          v173 = (_QWORD *)v132[2];
          v133 = (char *)v173;
          v172 = *(_OWORD *)v132;
          v132[1] = 0;
          v132[2] = 0;
          *v132 = 0;
          v134 = v172;
          if ( (v172 & 1) != 0 )
            v135 = v133;
          else
            v135 = (char *)&v172 + 1;
          if ( (v172 & 1) != 0 )
            v136 = *((_QWORD *)&v172 + 1);
          else
            v136 = (unsigned __int64)(unsigned __int8)v172 >> 1;
          sub_42BE4((size_t *)&v168, v135, v136);
          if ( (v134 & 1) != 0 )
            free(v133);
          ++v126;
          v125 += 48;
        }
        while ( v126 < v47 );
        if ( v165 < v47 )
        {
          v137 = *(_QWORD *)(v4 + 8);
          do
          {
            if ( *(_QWORD *)v4 != v137 )
            {
              v138 = (_BYTE *)(v137 - 48);
              if ( (*(_BYTE *)(v137 - 24) & 1) != 0 )
                free(*(void **)(v137 - 8));
              if ( (*v138 & 1) != 0 )
                free(*(void **)(v137 - 32));
              v137 -= 48;
              *(_QWORD *)(v4 + 8) = v138;
            }
            --v47;
          }
          while ( v47 > v165 );
        }
      }
      v8 = v163;
      if ( *v163 == 69 )
      {
        v11 = (unsigned __int8)v168;
        v9 = *((_QWORD *)&v168 + 1);
        v10 = (char *)p;
        goto LABEL_9;
      }
    }
    v26 = byte_count;
    v25 = 0x7FFFFFFFFFFFFFFLL;
    v174 = 0;
    v175 = byte_count;
LABEL_29:
    v27 = *(char **)(*(_QWORD *)v26 + 4096LL);
    if ( *(_QWORD *)v26 + 4096LL - (__int64)v27 >= (unsigned __int64)(32 * v25) )
      *(_QWORD *)(*(_QWORD *)v26 + 4096LL) = &v27[32 * v25];
    else
      v27 = (char *)malloc(32 * v25);
    goto LABEL_32;
  }
  v9 = 0;
  v10 = 0;
  v11 = 2;
LABEL_9:
  v12 = v11 >> 1;
  v13 = (v11 & 1) == 0;
  v14 = (char *)&v168 + 1;
  if ( v13 )
  {
    v15 = v12;
  }
  else
  {
    v14 = v10;
    v15 = v9;
  }
  if ( v14[v15 - 1] == 62 )
    sub_42BE4((size_t *)&v168, " >", 2u);
  else
    sub_42BE4((size_t *)&v168, ">", 1u);
  v139 = p;
  v140 = v168;
  p = 0;
  *(_QWORD *)&v170[7] = *((_QWORD *)&v168 + 1);
  v170[7] = BYTE8(v168);
  v141 = *(_QWORD *)((char *)&v168 + 1);
  v142 = *(_QWORD *)&v170[7];
  v168 = 0u;
  memset(v171, 0, 15);
  memset(v170, 0, sizeof(v170));
  *(_QWORD *)&v172 = v141;
  *(_QWORD *)((char *)&v172 + 7) = v142;
  v143 = *(_QWORD *)(v4 + 8);
  v144 = *(_QWORD *)(v4 + 16);
  if ( v143 >= v144 )
  {
    v145 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v143 - *(_QWORD *)v4) >> 4);
    v146 = 0x555555555555555LL;
    if ( v145 + 1 > 0x555555555555555LL )
      abort();
    v147 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v144 - *(_QWORD *)v4) >> 4);
    if ( v147 >= 0x2AAAAAAAAAAAAAALL || ((v148 = 2 * v147, v148 >= v145 + 1) ? (v146 = v148) : (v146 = v145 + 1), v146) )
    {
      v149 = *(_QWORD *)(v4 + 24);
      v150 = *(char **)(v149 + 4096);
      if ( v149 + 4096 - (__int64)v150 >= (unsigned __int64)(48 * v146) )
        *(_QWORD *)(v149 + 4096) = &v150[48 * v146];
      else
        v150 = (char *)malloc(48 * v146);
    }
    else
    {
      v150 = 0;
    }
    v151 = &v150[48 * v145];
    *v151 = v140;
    v152 = &v150[48 * v146];
    *((_QWORD *)v151 + 1) = *(_QWORD *)((char *)&v172 + 7);
    *((_QWORD *)v151 + 2) = v139;
    *(_QWORD *)(v151 + 1) = v172;
    *(_QWORD *)((char *)&v172 + 7) = 0;
    *(_QWORD *)&v172 = 0;
    v151[24] = 0;
    *((_QWORD *)v151 + 4) = *(_QWORD *)((char *)v171 + 7);
    *((_QWORD *)v151 + 5) = 0;
    *(_QWORD *)(v151 + 25) = v171[0];
    memset(v171, 0, 15);
    v154 = *(_QWORD *)v4;
    v153 = *(_QWORD *)(v4 + 8);
    v155 = v151 + 48;
    if ( v153 == *(_QWORD *)v4 )
    {
      v157 = *(void **)v4;
    }
    else
    {
      do
      {
        *((_QWORD *)v151 - 4) = *(_QWORD *)(v153 - 32);
        *((_OWORD *)v151 - 3) = *(_OWORD *)(v153 - 48);
        v156 = *(_QWORD *)(v153 - 8);
        *(_QWORD *)(v153 - 40) = 0;
        *(_QWORD *)(v153 - 32) = 0;
        *(_QWORD *)(v153 - 48) = 0;
        *((_QWORD *)v151 - 1) = v156;
        *(_OWORD *)(v151 - 24) = *(_OWORD *)(v153 - 24);
        *(_QWORD *)(v153 - 24) = 0;
        *(_QWORD *)(v153 - 16) = 0;
        *(_QWORD *)(v153 - 8) = 0;
        v153 -= 48;
        v151 -= 48;
      }
      while ( v154 != v153 );
      v157 = *(void **)v4;
      v154 = *(_QWORD *)(v4 + 8);
    }
    v158 = *(_QWORD *)(v4 + 16);
    *(_QWORD *)v4 = v151;
    *(_QWORD *)(v4 + 8) = v155;
    *(_QWORD *)(v4 + 16) = v152;
    if ( (void *)v154 != v157 )
    {
      do
      {
        if ( (*(_BYTE *)(v154 - 24) & 1) != 0 )
          free(*(void **)(v154 - 8));
        v159 = (void *)(v154 - 48);
        if ( (*(_BYTE *)(v154 - 48) & 1) != 0 )
          free(*(void **)(v154 - 32));
        v154 -= 48LL;
      }
      while ( v157 != v159 );
    }
    if ( v157 )
    {
      v160 = *(_QWORD *)(v4 + 24);
      if ( v160 + 4096 < (unsigned __int64)v157 || v160 > (unsigned __int64)v157 )
      {
        free(v157);
      }
      else if ( *(_QWORD *)(v160 + 4096) == v158 )
      {
        *(_QWORD *)(v160 + 4096) = v157;
      }
    }
  }
  else
  {
    *(_BYTE *)v143 = v140;
    *(_QWORD *)(v143 + 8) = *(_QWORD *)((char *)&v172 + 7);
    *(_QWORD *)(v143 + 16) = v139;
    *(_QWORD *)(v143 + 1) = v172;
    *(_QWORD *)((char *)&v172 + 7) = 0;
    *(_QWORD *)&v172 = 0;
    *(_BYTE *)(v143 + 24) = 0;
    *(_QWORD *)(v143 + 32) = *(_QWORD *)((char *)v171 + 7);
    *(_QWORD *)(v143 + 40) = 0;
    *(_QWORD *)(v143 + 25) = v171[0];
    memset(v171, 0, 15);
    *(_QWORD *)(v4 + 8) += 48LL;
  }
  v46 = 0;
  v16 = v8 + 1;
LABEL_207:
  if ( (v168 & 1) != 0 )
    free(p);
  if ( !v46 )
    return v16;
  return v167;
}

//----- (0000000000043E00) ----------------------------------------------------
unsigned __int8 *__fastcall sub_43E00(_BYTE *a1, unsigned __int8 *a2, void **a3)
{
  _BYTE *v4; // x20
  __int64 v6; // x22
  __int64 *v7; // x8
  __int64 v8; // x26
  __int64 v9; // x27
  char *v10; // x21
  size_t *v11; // x28
  char *v12; // x20
  size_t v13; // x22
  const void *v14; // x23
  void *v15; // x24
  char *v16; // x8
  char *v17; // x22
  char *v18; // x22
  size_t v19; // x23
  const void *v20; // x24
  void *v21; // x22
  void *v22; // x0
  char *v23; // x8
  void **v24; // x9
  void **v25; // x22
  _QWORD *v26; // x8
  size_t v27; // x10
  void **v28; // x21
  void *v29; // x23
  void **v30; // x24
  unsigned __int64 v31; // x8
  char *v32; // x9
  size_t *v33; // x25
  unsigned __int64 v34; // x26
  unsigned __int64 v35; // x9
  __int64 v36; // x22
  unsigned __int64 v37; // x9
  _QWORD *v38; // x8
  size_t v39; // x0
  size_t v40; // x21
  const void *v41; // x22
  void *v42; // x23
  _BYTE *v43; // x21
  size_t v44; // x22
  const void *v45; // x23
  void *v46; // x21
  unsigned __int8 *v47; // x25
  int v48; // w8
  __int64 v49; // x23
  __int64 v50; // x22
  int v51; // w8
  char *v52; // x8
  char *v53; // x9
  unsigned __int64 v54; // x22
  __int64 v55; // x21
  unsigned __int64 v56; // x9
  unsigned __int64 v57; // x9
  _QWORD *v58; // x9
  char *v59; // x0
  char *v60; // x9
  char *v61; // x9
  _QWORD *v62; // x8
  _BYTE *v63; // x9
  char *v64; // x9
  char *v65; // x9
  unsigned __int64 v66; // x22
  __int64 v67; // x21
  unsigned __int64 v68; // x9
  unsigned __int64 v69; // x9
  _QWORD *v70; // x9
  char *v71; // x0
  unsigned __int64 v72; // x22
  __int64 v73; // x21
  unsigned __int64 v74; // x9
  unsigned __int64 v75; // x9
  _QWORD *v76; // x9
  char *v77; // x0
  unsigned __int64 v78; // x22
  __int64 v79; // x21
  unsigned __int64 v80; // x9
  unsigned __int64 v81; // x9
  _QWORD *v82; // x9
  char *v83; // x0
  unsigned __int64 v84; // x22
  __int64 v85; // x21
  unsigned __int64 v86; // x9
  unsigned __int64 v87; // x9
  _QWORD *v88; // x9
  char *v89; // x0
  unsigned __int64 v90; // x22
  __int64 v91; // x21
  unsigned __int64 v92; // x9
  unsigned __int64 v93; // x9
  _QWORD *v94; // x9
  char *v95; // x0
  _BYTE *v96; // x8
  __int64 *v97; // x8
  __int64 v98; // x26
  __int64 v99; // x27
  char *v100; // x20
  size_t *v101; // x28
  char *v102; // x24
  size_t v103; // x21
  const void *v104; // x22
  void *v105; // x23
  char *v106; // x8
  char *v107; // x21
  char *v108; // x21
  size_t v109; // x22
  const void *v110; // x23
  void *v111; // x21
  void *v112; // x0
  char *v113; // x8
  void **v114; // x9
  void **v115; // x21
  _QWORD *v116; // x8
  size_t v117; // x10
  void **v118; // x20
  void *v119; // x22
  void **v120; // x23
  unsigned __int64 v121; // x8
  char *v122; // x9
  size_t *v123; // x24
  unsigned __int64 v124; // x26
  unsigned __int64 v125; // x9
  __int64 v126; // x21
  unsigned __int64 v127; // x9
  _QWORD *v128; // x8
  size_t v129; // x0
  size_t v130; // x20
  const void *v131; // x21
  void *v132; // x22
  _BYTE *v133; // x20
  size_t v134; // x21
  const void *v135; // x22
  void *v136; // x20
  char *v137; // x8
  char *v138; // x9
  void **v139; // x11
  void **v140; // x22
  char *v141; // x10
  __int64 v142; // x12
  void **v143; // x21
  void *v144; // x23
  void **v145; // x24
  char *v146; // x8
  char *v147; // x9
  void **v148; // x11
  void **v149; // x22
  char *v150; // x10
  __int64 v151; // x12
  void **v152; // x24
  char *v153; // x8
  char *v154; // x9
  void **v155; // x11
  void **v156; // x22
  char *v157; // x10
  __int64 v158; // x12
  void **v159; // x24
  char *v160; // x8
  char *v161; // x9
  void **v162; // x11
  void **v163; // x22
  char *v164; // x10
  __int64 v165; // x12
  void **v166; // x24
  char *v167; // x8
  char *v168; // x9
  void **v169; // x11
  void **v170; // x22
  char *v171; // x10
  __int64 v172; // x12
  void **v173; // x24
  char *v174; // x8
  char *v175; // x9
  void **v176; // x11
  void **v177; // x22
  char *v178; // x10
  __int64 v179; // x12
  void **v180; // x24
  unsigned __int64 v181; // x8
  __int64 v184; // [xsp+18h] [xbp-88h]
  __int64 v185; // [xsp+18h] [xbp-88h]
  _QWORD v186[2]; // [xsp+28h] [xbp-78h] BYREF
  _QWORD v187[3]; // [xsp+38h] [xbp-68h] BYREF

  v4 = a1;
  v187[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 >= 2 && *a1 == 83 )
  {
    v6 = (unsigned __int8)a1[1];
    switch ( a1[1] )
    {
      case '_':
        v7 = (__int64 *)a3[4];
        if ( v7 == a3[5] )
          return v4;
        v9 = *v7;
        v8 = v7[1];
        if ( *v7 == v8 )
          return a1 + 2;
        v184 = v7[1];
        while ( 1 )
        {
          v33 = (size_t *)a3[1];
          v32 = (char *)a3[2];
          if ( v33 == (size_t *)v32 )
          {
            v34 = 0xAAAAAAAAAAAAAAABLL * (((char *)v33 - (_BYTE *)*a3) >> 4);
            if ( v34 + 1 > 0x555555555555555LL )
              goto LABEL_304;
            v35 = 0xAAAAAAAAAAAAAAABLL * ((v32 - (_BYTE *)*a3) >> 4);
            v36 = 0x555555555555555LL;
            if ( v35 >= 0x2AAAAAAAAAAAAAALL || ((v37 = 2 * v35, v37 >= v34 + 1) ? (v36 = v37) : (v36 = v34 + 1), v36) )
            {
              v38 = a3[3];
              v39 = 48 * v36;
              v10 = (char *)v38[512];
              if ( (char *)(v38 + 512) - v10 >= (unsigned __int64)(48 * v36) )
                v38[512] = &v10[v39];
              else
                v10 = (char *)malloc(v39);
            }
            else
            {
              v10 = 0;
            }
            v11 = (size_t *)&v10[48 * v34];
            v11[1] = 0;
            v11[2] = 0;
            *v11 = 0;
            v12 = &v10[48 * v36];
            if ( (*(_BYTE *)v9 & 1) == 0 )
            {
              v11[2] = *(_QWORD *)(v9 + 16);
              *(_OWORD *)v11 = *(_OWORD *)v9;
              goto LABEL_18;
            }
            v13 = *(_QWORD *)(v9 + 8);
            if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v14 = *(const void **)(v9 + 16);
            if ( v13 >= 0x17 )
            {
              v15 = malloc((v13 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v16 = &v10[48 * v34];
              *((_QWORD *)v16 + 1) = v13;
              *((_QWORD *)v16 + 2) = v15;
              *v11 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v11 = 2 * v13;
              v15 = (char *)v11 + 1;
              if ( !v13 )
                goto LABEL_17;
            }
            memcpy(v15, v14, v13);
LABEL_17:
            *((_BYTE *)v15 + v13) = 0;
LABEL_18:
            v17 = &v10[48 * v34];
            *((_QWORD *)v17 + 3) = 0;
            v18 = v17 + 24;
            *((_QWORD *)v18 + 1) = 0;
            *((_QWORD *)v18 + 2) = 0;
            if ( (*(_BYTE *)(v9 + 24) & 1) == 0 )
            {
              *((_QWORD *)v18 + 2) = *(_QWORD *)(v9 + 40);
              *(_OWORD *)v18 = *(_OWORD *)(v9 + 24);
LABEL_27:
              v25 = (void **)*a3;
              v24 = (void **)a3[1];
              v26 = v11 + 6;
              if ( v24 == *a3 )
              {
                v28 = (void **)*a3;
              }
              else
              {
                do
                {
                  *(v11 - 4) = (size_t)*(v24 - 4);
                  *((_OWORD *)v11 - 3) = *((_OWORD *)v24 - 3);
                  v27 = (size_t)*(v24 - 1);
                  *(v24 - 5) = 0;
                  *(v24 - 4) = 0;
                  *(v24 - 6) = 0;
                  *(v11 - 1) = v27;
                  *(_OWORD *)(v11 - 3) = *(_OWORD *)(v24 - 3);
                  *(v24 - 3) = 0;
                  *(v24 - 2) = 0;
                  *(v24 - 1) = 0;
                  v24 -= 6;
                  v11 -= 6;
                }
                while ( v25 != v24 );
                v28 = (void **)*a3;
                v25 = (void **)a3[1];
              }
              *a3 = v11;
              a3[1] = v26;
              v29 = a3[2];
              v8 = v184;
              a3[2] = v12;
              if ( v25 != v28 )
              {
                do
                {
                  if ( (*(_BYTE *)(v25 - 3) & 1) != 0 )
                    free(*(v25 - 1));
                  v30 = v25 - 6;
                  if ( (*(_BYTE *)(v25 - 6) & 1) != 0 )
                    free(*(v25 - 4));
                  v25 -= 6;
                }
                while ( v28 != v30 );
              }
              if ( v28 )
              {
                v31 = (unsigned __int64)a3[3];
                if ( v31 + 4096 < (unsigned __int64)v28 || v31 > (unsigned __int64)v28 )
                {
                  free(v28);
                }
                else if ( *(void **)(v31 + 4096) == v29 )
                {
                  *(_QWORD *)(v31 + 4096) = v28;
                }
              }
              goto LABEL_71;
            }
            v19 = *(_QWORD *)(v9 + 32);
            if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v20 = *(const void **)(v9 + 40);
            if ( v19 >= 0x17 )
            {
              v22 = malloc((v19 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v23 = &v10[48 * v34];
              *((_QWORD *)v23 + 4) = v19;
              *((_QWORD *)v23 + 5) = v22;
              *(_QWORD *)v18 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v21 = v22;
            }
            else
            {
              *v18 = 2 * v19;
              v21 = v18 + 1;
              if ( !v19 )
                goto LABEL_26;
            }
            memcpy(v21, v20, v19);
LABEL_26:
            *((_BYTE *)v21 + v19) = 0;
            goto LABEL_27;
          }
          v33[1] = 0;
          v33[2] = 0;
          *v33 = 0;
          if ( (*(_BYTE *)v9 & 1) == 0 )
          {
            v33[2] = *(_QWORD *)(v9 + 16);
            *(_OWORD *)v33 = *(_OWORD *)v9;
            goto LABEL_61;
          }
          v40 = *(_QWORD *)(v9 + 8);
          if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
            goto LABEL_304;
          v41 = *(const void **)(v9 + 16);
          if ( v40 >= 0x17 )
          {
            v42 = malloc((v40 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v33[1] = v40;
            v33[2] = (size_t)v42;
            *v33 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v33 = 2 * v40;
            v42 = (char *)v33 + 1;
            if ( !v40 )
              goto LABEL_60;
          }
          memcpy(v42, v41, v40);
LABEL_60:
          *((_BYTE *)v42 + v40) = 0;
LABEL_61:
          v33[3] = 0;
          v43 = v33 + 3;
          v33[4] = 0;
          v33[5] = 0;
          if ( (*(_BYTE *)(v9 + 24) & 1) != 0 )
          {
            v44 = *(_QWORD *)(v9 + 32);
            if ( v44 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v45 = *(const void **)(v9 + 40);
            if ( v44 >= 0x17 )
            {
              v46 = malloc((v44 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v33[4] = v44;
              v33[5] = (size_t)v46;
              v33[3] = (v44 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v43 = 2 * v44;
              v46 = (char *)v33 + 25;
              if ( !v44 )
                goto LABEL_69;
            }
            memcpy(v46, v45, v44);
LABEL_69:
            *((_BYTE *)v46 + v44) = 0;
            goto LABEL_70;
          }
          v33[5] = *(_QWORD *)(v9 + 40);
          *(_OWORD *)v43 = *(_OWORD *)(v9 + 24);
LABEL_70:
          a3[1] = (char *)a3[1] + 48;
LABEL_71:
          v9 += 48;
          if ( v9 == v8 )
            return a1 + 2;
        }
      case 'a':
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        qmemcpy(v186, "std::allocator", 14);
        v52 = (char *)a3[1];
        v60 = (char *)a3[2];
        if ( v52 < v60 )
        {
          *v52 = 28;
          v4 = a1 + 2;
          *(_QWORD *)(v52 + 7) = *(_QWORD *)((char *)v186 + 6);
          v52[15] = 0;
          *((_QWORD *)v52 + 2) = 0;
          *(_QWORD *)(v52 + 1) = v186[0];
          *(_QWORD *)((char *)v186 + 6) = 0;
          goto LABEL_106;
        }
        v66 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (_BYTE *)*a3) >> 4);
        v67 = 0x555555555555555LL;
        if ( v66 + 1 > 0x555555555555555LL )
          abort();
        v68 = 0xAAAAAAAAAAAAAAABLL * ((v60 - (_BYTE *)*a3) >> 4);
        if ( v68 >= 0x2AAAAAAAAAAAAAALL || ((v69 = 2 * v68, v69 >= v66 + 1) ? (v67 = v69) : (v67 = v66 + 1), v67) )
        {
          v70 = a3[3];
          v71 = (char *)v70[512];
          if ( (char *)(v70 + 512) - v71 >= (unsigned __int64)(48 * v67) )
            v70[512] = &v71[48 * v67];
          else
            v71 = (char *)malloc(48 * v67);
        }
        else
        {
          v71 = 0;
        }
        v146 = &v71[48 * v66];
        *v146 = 28;
        v147 = &v71[48 * v67];
        *(_QWORD *)(v146 + 7) = *(_QWORD *)((char *)v186 + 6);
        v146[15] = 0;
        *((_QWORD *)v146 + 2) = 0;
        *(_QWORD *)(v146 + 1) = v186[0];
        *(_QWORD *)((char *)v186 + 6) = 0;
        v186[0] = 0;
        v146[24] = 0;
        *((_QWORD *)v146 + 4) = *(_QWORD *)((char *)v187 + 7);
        *((_QWORD *)v146 + 5) = 0;
        *(_QWORD *)(v146 + 25) = v187[0];
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        v149 = (void **)*a3;
        v148 = (void **)a3[1];
        v150 = v146 + 48;
        if ( v148 == *a3 )
        {
          v143 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v146 - 4) = *(v148 - 4);
            *((_OWORD *)v146 - 3) = *((_OWORD *)v148 - 3);
            v151 = (__int64)*(v148 - 1);
            *(v148 - 5) = 0;
            *(v148 - 4) = 0;
            *(v148 - 6) = 0;
            *((_QWORD *)v146 - 1) = v151;
            *(_OWORD *)(v146 - 24) = *(_OWORD *)(v148 - 3);
            *(v148 - 3) = 0;
            *(v148 - 2) = 0;
            *(v148 - 1) = 0;
            v148 -= 6;
            v146 -= 48;
          }
          while ( v149 != v148 );
          v143 = (void **)*a3;
          v149 = (void **)a3[1];
        }
        v144 = a3[2];
        *a3 = v146;
        a3[1] = v150;
        a3[2] = v147;
        if ( v149 != v143 )
        {
          do
          {
            if ( (*(_BYTE *)(v149 - 3) & 1) != 0 )
              free(*(v149 - 1));
            v152 = v149 - 6;
            if ( (*(_BYTE *)(v149 - 6) & 1) != 0 )
              free(*(v149 - 4));
            v149 -= 6;
          }
          while ( v143 != v152 );
        }
        goto LABEL_296;
      case 'b':
        memset(v186, 0, 15);
        qmemcpy(v187, "std::basic_stri", 15);
        v62 = a3[1];
        v63 = a3[2];
        if ( v62 < (_QWORD *)v63 )
        {
          *(_BYTE *)v62 = 34;
          v4 = a1 + 2;
          v62[1] = *(_QWORD *)((char *)v187 + 7);
          v62[2] = 26478;
          *(_QWORD *)((char *)v62 + 1) = v187[0];
          *(_QWORD *)((char *)v187 + 7) = 0;
          v187[0] = 0;
          *((_BYTE *)v62 + 24) = 0;
          v62[4] = *(_QWORD *)((char *)v186 + 7);
          v62[5] = 0;
          *(_QWORD *)((char *)v62 + 25) = v186[0];
          memset(v186, 0, 15);
          goto LABEL_108;
        }
        v78 = 0xAAAAAAAAAAAAAAABLL * (((char *)v62 - (_BYTE *)*a3) >> 4);
        v79 = 0x555555555555555LL;
        if ( v78 + 1 > 0x555555555555555LL )
          abort();
        v80 = 0xAAAAAAAAAAAAAAABLL * ((v63 - (_BYTE *)*a3) >> 4);
        if ( v80 >= 0x2AAAAAAAAAAAAAALL || ((v81 = 2 * v80, v81 >= v78 + 1) ? (v79 = v81) : (v79 = v78 + 1), v79) )
        {
          v82 = a3[3];
          v83 = (char *)v82[512];
          if ( (char *)(v82 + 512) - v83 >= (unsigned __int64)(48 * v79) )
            v82[512] = &v83[48 * v79];
          else
            v83 = (char *)malloc(48 * v79);
        }
        else
        {
          v83 = 0;
        }
        v160 = &v83[48 * v78];
        *v160 = 34;
        v161 = &v83[48 * v79];
        *((_QWORD *)v160 + 1) = *(_QWORD *)((char *)v187 + 7);
        *((_QWORD *)v160 + 2) = 26478;
        *(_QWORD *)(v160 + 1) = v187[0];
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        v160[24] = 0;
        *((_QWORD *)v160 + 4) = *(_QWORD *)((char *)v186 + 7);
        *((_QWORD *)v160 + 5) = 0;
        *(_QWORD *)(v160 + 25) = v186[0];
        memset(v186, 0, 15);
        v163 = (void **)*a3;
        v162 = (void **)a3[1];
        v164 = v160 + 48;
        if ( v162 == *a3 )
        {
          v143 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v160 - 4) = *(v162 - 4);
            *((_OWORD *)v160 - 3) = *((_OWORD *)v162 - 3);
            v165 = (__int64)*(v162 - 1);
            *(v162 - 5) = 0;
            *(v162 - 4) = 0;
            *(v162 - 6) = 0;
            *((_QWORD *)v160 - 1) = v165;
            *(_OWORD *)(v160 - 24) = *(_OWORD *)(v162 - 3);
            *(v162 - 3) = 0;
            *(v162 - 2) = 0;
            *(v162 - 1) = 0;
            v162 -= 6;
            v160 -= 48;
          }
          while ( v163 != v162 );
          v143 = (void **)*a3;
          v163 = (void **)a3[1];
        }
        v144 = a3[2];
        *a3 = v160;
        a3[1] = v164;
        a3[2] = v161;
        if ( v163 != v143 )
        {
          do
          {
            if ( (*(_BYTE *)(v163 - 3) & 1) != 0 )
              free(*(v163 - 1));
            v166 = v163 - 6;
            if ( (*(_BYTE *)(v163 - 6) & 1) != 0 )
              free(*(v163 - 4));
            v163 -= 6;
          }
          while ( v143 != v166 );
        }
        goto LABEL_296;
      case 'd':
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        qmemcpy(v186, "std::iostream", 13);
        v52 = (char *)a3[1];
        v64 = (char *)a3[2];
        if ( v52 < v64 )
        {
          *v52 = 26;
          v4 = a1 + 2;
          *(_QWORD *)(v52 + 6) = *(_QWORD *)((char *)v186 + 5);
          *((_WORD *)v52 + 7) = 0;
          *((_QWORD *)v52 + 2) = 0;
          *(_QWORD *)(v52 + 1) = v186[0];
          *(_QWORD *)((char *)v186 + 5) = 0;
          goto LABEL_106;
        }
        v84 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (_BYTE *)*a3) >> 4);
        v85 = 0x555555555555555LL;
        if ( v84 + 1 > 0x555555555555555LL )
          abort();
        v86 = 0xAAAAAAAAAAAAAAABLL * ((v64 - (_BYTE *)*a3) >> 4);
        if ( v86 >= 0x2AAAAAAAAAAAAAALL || ((v87 = 2 * v86, v87 >= v84 + 1) ? (v85 = v87) : (v85 = v84 + 1), v85) )
        {
          v88 = a3[3];
          v89 = (char *)v88[512];
          if ( (char *)(v88 + 512) - v89 >= (unsigned __int64)(48 * v85) )
            v88[512] = &v89[48 * v85];
          else
            v89 = (char *)malloc(48 * v85);
        }
        else
        {
          v89 = 0;
        }
        v167 = &v89[48 * v84];
        *v167 = 26;
        v168 = &v89[48 * v85];
        *(_QWORD *)(v167 + 6) = *(_QWORD *)((char *)v186 + 5);
        *((_WORD *)v167 + 7) = 0;
        *((_QWORD *)v167 + 2) = 0;
        *(_QWORD *)(v167 + 1) = v186[0];
        *(_QWORD *)((char *)v186 + 5) = 0;
        v186[0] = 0;
        v167[24] = 0;
        *((_QWORD *)v167 + 4) = *(_QWORD *)((char *)v187 + 7);
        *((_QWORD *)v167 + 5) = 0;
        *(_QWORD *)(v167 + 25) = v187[0];
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        v170 = (void **)*a3;
        v169 = (void **)a3[1];
        v171 = v167 + 48;
        if ( v169 == *a3 )
        {
          v143 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v167 - 4) = *(v169 - 4);
            *((_OWORD *)v167 - 3) = *((_OWORD *)v169 - 3);
            v172 = (__int64)*(v169 - 1);
            *(v169 - 5) = 0;
            *(v169 - 4) = 0;
            *(v169 - 6) = 0;
            *((_QWORD *)v167 - 1) = v172;
            *(_OWORD *)(v167 - 24) = *(_OWORD *)(v169 - 3);
            *(v169 - 3) = 0;
            *(v169 - 2) = 0;
            *(v169 - 1) = 0;
            v169 -= 6;
            v167 -= 48;
          }
          while ( v170 != v169 );
          v143 = (void **)*a3;
          v170 = (void **)a3[1];
        }
        v144 = a3[2];
        *a3 = v167;
        a3[1] = v171;
        a3[2] = v168;
        if ( v170 != v143 )
        {
          do
          {
            if ( (*(_BYTE *)(v170 - 3) & 1) != 0 )
              free(*(v170 - 1));
            v173 = v170 - 6;
            if ( (*(_BYTE *)(v170 - 6) & 1) != 0 )
              free(*(v170 - 4));
            v170 -= 6;
          }
          while ( v143 != v173 );
        }
        goto LABEL_296;
      case 'i':
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        qmemcpy(v186, "std::istream", 12);
        v52 = (char *)a3[1];
        v65 = (char *)a3[2];
        if ( v52 < v65 )
          goto LABEL_105;
        v90 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (_BYTE *)*a3) >> 4);
        v91 = 0x555555555555555LL;
        if ( v90 + 1 > 0x555555555555555LL )
          abort();
        v92 = 0xAAAAAAAAAAAAAAABLL * ((v65 - (_BYTE *)*a3) >> 4);
        if ( v92 >= 0x2AAAAAAAAAAAAAALL || ((v93 = 2 * v92, v93 >= v90 + 1) ? (v91 = v93) : (v91 = v90 + 1), v91) )
        {
          v94 = a3[3];
          v95 = (char *)v94[512];
          if ( (char *)(v94 + 512) - v95 >= (unsigned __int64)(48 * v91) )
            v94[512] = &v95[48 * v91];
          else
            v95 = (char *)malloc(48 * v91);
        }
        else
        {
          v95 = 0;
        }
        v174 = &v95[48 * v90];
        *v174 = 24;
        v175 = &v95[48 * v91];
        *(_DWORD *)(v174 + 9) = v186[1];
        v174[13] = 0;
        *((_WORD *)v174 + 7) = 0;
        *((_QWORD *)v174 + 2) = 0;
        *(_QWORD *)(v174 + 1) = v186[0];
        LODWORD(v186[1]) = 0;
        v186[0] = 0;
        v174[24] = 0;
        *((_QWORD *)v174 + 4) = *(_QWORD *)((char *)v187 + 7);
        *((_QWORD *)v174 + 5) = 0;
        *(_QWORD *)(v174 + 25) = v187[0];
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        v177 = (void **)*a3;
        v176 = (void **)a3[1];
        v178 = v174 + 48;
        if ( v176 == *a3 )
        {
          v143 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v174 - 4) = *(v176 - 4);
            *((_OWORD *)v174 - 3) = *((_OWORD *)v176 - 3);
            v179 = (__int64)*(v176 - 1);
            *(v176 - 5) = 0;
            *(v176 - 4) = 0;
            *(v176 - 6) = 0;
            *((_QWORD *)v174 - 1) = v179;
            *(_OWORD *)(v174 - 24) = *(_OWORD *)(v176 - 3);
            *(v176 - 3) = 0;
            *(v176 - 2) = 0;
            *(v176 - 1) = 0;
            v176 -= 6;
            v174 -= 48;
          }
          while ( v177 != v176 );
          v143 = (void **)*a3;
          v177 = (void **)a3[1];
        }
        v144 = a3[2];
        *a3 = v174;
        a3[1] = v178;
        a3[2] = v175;
        if ( v177 != v143 )
        {
          do
          {
            if ( (*(_BYTE *)(v177 - 3) & 1) != 0 )
              free(*(v177 - 1));
            v180 = v177 - 6;
            if ( (*(_BYTE *)(v177 - 6) & 1) != 0 )
              free(*(v177 - 4));
            v177 -= 6;
          }
          while ( v143 != v180 );
        }
        goto LABEL_296;
      case 'o':
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        qmemcpy(v186, "std::ostream", 12);
        v52 = (char *)a3[1];
        v53 = (char *)a3[2];
        if ( v52 >= v53 )
        {
          v54 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (_BYTE *)*a3) >> 4);
          v55 = 0x555555555555555LL;
          if ( v54 + 1 > 0x555555555555555LL )
            abort();
          v56 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
          if ( v56 >= 0x2AAAAAAAAAAAAAALL || ((v57 = 2 * v56, v57 >= v54 + 1) ? (v55 = v57) : (v55 = v54 + 1), v55) )
          {
            v58 = a3[3];
            v59 = (char *)v58[512];
            if ( (char *)(v58 + 512) - v59 >= (unsigned __int64)(48 * v55) )
              v58[512] = &v59[48 * v55];
            else
              v59 = (char *)malloc(48 * v55);
          }
          else
          {
            v59 = 0;
          }
          v137 = &v59[48 * v54];
          *v137 = 24;
          v138 = &v59[48 * v55];
          *(_DWORD *)(v137 + 9) = v186[1];
          v137[13] = 0;
          *((_WORD *)v137 + 7) = 0;
          *((_QWORD *)v137 + 2) = 0;
          *(_QWORD *)(v137 + 1) = v186[0];
          LODWORD(v186[1]) = 0;
          v186[0] = 0;
          v137[24] = 0;
          *((_QWORD *)v137 + 4) = *(_QWORD *)((char *)v187 + 7);
          *((_QWORD *)v137 + 5) = 0;
          *(_QWORD *)(v137 + 25) = v187[0];
          *(_QWORD *)((char *)v187 + 7) = 0;
          v187[0] = 0;
          v140 = (void **)*a3;
          v139 = (void **)a3[1];
          v141 = v137 + 48;
          if ( v139 == *a3 )
          {
            v143 = (void **)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v137 - 4) = *(v139 - 4);
              *((_OWORD *)v137 - 3) = *((_OWORD *)v139 - 3);
              v142 = (__int64)*(v139 - 1);
              *(v139 - 5) = 0;
              *(v139 - 4) = 0;
              *(v139 - 6) = 0;
              *((_QWORD *)v137 - 1) = v142;
              *(_OWORD *)(v137 - 24) = *(_OWORD *)(v139 - 3);
              *(v139 - 3) = 0;
              *(v139 - 2) = 0;
              *(v139 - 1) = 0;
              v139 -= 6;
              v137 -= 48;
            }
            while ( v140 != v139 );
            v143 = (void **)*a3;
            v140 = (void **)a3[1];
          }
          v144 = a3[2];
          *a3 = v137;
          a3[1] = v141;
          a3[2] = v138;
          if ( v140 != v143 )
          {
            do
            {
              if ( (*(_BYTE *)(v140 - 3) & 1) != 0 )
                free(*(v140 - 1));
              v145 = v140 - 6;
              if ( (*(_BYTE *)(v140 - 6) & 1) != 0 )
                free(*(v140 - 4));
              v140 -= 6;
            }
            while ( v143 != v145 );
          }
          goto LABEL_296;
        }
LABEL_105:
        *v52 = 24;
        v4 = a1 + 2;
        *(_DWORD *)(v52 + 9) = v186[1];
        v52[13] = 0;
        *((_WORD *)v52 + 7) = 0;
        *((_QWORD *)v52 + 2) = 0;
        *(_QWORD *)(v52 + 1) = v186[0];
        LODWORD(v186[1]) = 0;
LABEL_106:
        v186[0] = 0;
        goto LABEL_107;
      case 's':
        *(_QWORD *)((char *)v187 + 7) = 0;
        v187[0] = 0;
        qmemcpy(v186, "std::string", 11);
        v52 = (char *)a3[1];
        v61 = (char *)a3[2];
        if ( v52 >= v61 )
        {
          v72 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (_BYTE *)*a3) >> 4);
          v73 = 0x555555555555555LL;
          if ( v72 + 1 > 0x555555555555555LL )
            abort();
          v74 = 0xAAAAAAAAAAAAAAABLL * ((v61 - (_BYTE *)*a3) >> 4);
          if ( v74 >= 0x2AAAAAAAAAAAAAALL || ((v75 = 2 * v74, v75 >= v72 + 1) ? (v73 = v75) : (v73 = v72 + 1), v73) )
          {
            v76 = a3[3];
            v77 = (char *)v76[512];
            if ( (char *)(v76 + 512) - v77 >= (unsigned __int64)(48 * v73) )
              v76[512] = &v77[48 * v73];
            else
              v77 = (char *)malloc(48 * v73);
          }
          else
          {
            v77 = 0;
          }
          v153 = &v77[48 * v72];
          *v153 = 22;
          v154 = &v77[48 * v73];
          v153[11] = BYTE2(v186[1]);
          *(_WORD *)(v153 + 9) = v186[1];
          v153[12] = 0;
          *(_QWORD *)(v153 + 1) = v186[0];
          v153[15] = 0;
          *((_QWORD *)v153 + 2) = 0;
          *(_WORD *)(v153 + 13) = 0;
          LOWORD(v186[1]) = 0;
          v186[0] = 0;
          BYTE2(v186[1]) = 0;
          v153[24] = 0;
          *((_QWORD *)v153 + 4) = *(_QWORD *)((char *)v187 + 7);
          *((_QWORD *)v153 + 5) = 0;
          *(_QWORD *)(v153 + 25) = v187[0];
          *(_QWORD *)((char *)v187 + 7) = 0;
          v187[0] = 0;
          v156 = (void **)*a3;
          v155 = (void **)a3[1];
          v157 = v153 + 48;
          if ( v155 == *a3 )
          {
            v143 = (void **)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v153 - 4) = *(v155 - 4);
              *((_OWORD *)v153 - 3) = *((_OWORD *)v155 - 3);
              v158 = (__int64)*(v155 - 1);
              *(v155 - 5) = 0;
              *(v155 - 4) = 0;
              *(v155 - 6) = 0;
              *((_QWORD *)v153 - 1) = v158;
              *(_OWORD *)(v153 - 24) = *(_OWORD *)(v155 - 3);
              *(v155 - 3) = 0;
              *(v155 - 2) = 0;
              *(v155 - 1) = 0;
              v155 -= 6;
              v153 -= 48;
            }
            while ( v156 != v155 );
            v143 = (void **)*a3;
            v156 = (void **)a3[1];
          }
          v144 = a3[2];
          *a3 = v153;
          a3[1] = v157;
          a3[2] = v154;
          if ( v156 != v143 )
          {
            do
            {
              if ( (*(_BYTE *)(v156 - 3) & 1) != 0 )
                free(*(v156 - 1));
              v159 = v156 - 6;
              if ( (*(_BYTE *)(v156 - 6) & 1) != 0 )
                free(*(v156 - 4));
              v156 -= 6;
            }
            while ( v143 != v159 );
          }
LABEL_296:
          if ( v143 )
          {
            v181 = (unsigned __int64)a3[3];
            if ( v181 + 4096 < (unsigned __int64)v143 || v181 > (unsigned __int64)v143 )
            {
              free(v143);
            }
            else if ( *(void **)(v181 + 4096) == v144 )
            {
              *(_QWORD *)(v181 + 4096) = v143;
            }
          }
          v4 += 2;
        }
        else
        {
          *v52 = 22;
          v4 = a1 + 2;
          v52[11] = BYTE2(v186[1]);
          *(_WORD *)(v52 + 9) = v186[1];
          v52[12] = 0;
          *(_QWORD *)(v52 + 1) = v186[0];
          v52[15] = 0;
          *((_QWORD *)v52 + 2) = 0;
          *(_WORD *)(v52 + 13) = 0;
          LOWORD(v186[1]) = 0;
          v186[0] = 0;
          BYTE2(v186[1]) = 0;
LABEL_107:
          v52[24] = 0;
          *((_QWORD *)v52 + 4) = *(_QWORD *)((char *)v187 + 7);
          *((_QWORD *)v52 + 5) = 0;
          *(_QWORD *)(v52 + 25) = v187[0];
          *(_QWORD *)((char *)v187 + 7) = 0;
          v187[0] = 0;
LABEL_108:
          a3[1] = (char *)a3[1] + 48;
        }
        return v4;
      default:
        if ( (unsigned int)(v6 - 48) >= 0xA && !isupper(v6) )
          return v4;
        v47 = v4 + 2;
        if ( v4 + 2 == a2 )
          return v4;
        if ( (unsigned int)(v6 - 48) >= 0xA )
          v48 = -55;
        else
          v48 = -48;
        v49 = v6 + v48;
        while ( 1 )
        {
          v50 = *v47;
          if ( (unsigned int)(v50 - 48) >= 0xA && !isupper(v50) )
            break;
          if ( (unsigned int)(v50 - 48) >= 0xA )
            v51 = -55;
          else
            v51 = -48;
          ++v47;
          v49 = v50 + v51 + 36 * v49;
          if ( a2 == v47 )
            return v4;
        }
        if ( (_DWORD)v50 != 95 )
          return v4;
        v96 = a3[4];
        if ( v49 + 1 >= (unsigned __int64)(((_BYTE *)a3[5] - v96) >> 5) )
          return v4;
        v97 = (__int64 *)&v96[32 * v49 + 32];
        v99 = *v97;
        v98 = v97[1];
        if ( *v97 == v98 )
          return v47 + 1;
        v185 = v97[1];
        break;
    }
    while ( 1 )
    {
      v123 = (size_t *)a3[1];
      v122 = (char *)a3[2];
      if ( v123 == (size_t *)v122 )
      {
        v124 = 0xAAAAAAAAAAAAAAABLL * (((char *)v123 - (_BYTE *)*a3) >> 4);
        if ( v124 + 1 > 0x555555555555555LL )
          goto LABEL_304;
        v125 = 0xAAAAAAAAAAAAAAABLL * ((v122 - (_BYTE *)*a3) >> 4);
        v126 = 0x555555555555555LL;
        if ( v125 >= 0x2AAAAAAAAAAAAAALL
          || ((v127 = 2 * v125, v127 >= v124 + 1) ? (v126 = v127) : (v126 = v124 + 1), v126) )
        {
          v128 = a3[3];
          v129 = 48 * v126;
          v100 = (char *)v128[512];
          if ( (char *)(v128 + 512) - v100 >= (unsigned __int64)(48 * v126) )
            v128[512] = &v100[v129];
          else
            v100 = (char *)malloc(v129);
        }
        else
        {
          v100 = 0;
        }
        v101 = (size_t *)&v100[48 * v124];
        v101[1] = 0;
        v101[2] = 0;
        *v101 = 0;
        v102 = &v100[48 * v126];
        if ( (*(_BYTE *)v99 & 1) == 0 )
        {
          v101[2] = *(_QWORD *)(v99 + 16);
          *(_OWORD *)v101 = *(_OWORD *)v99;
          goto LABEL_170;
        }
        v103 = *(_QWORD *)(v99 + 8);
        if ( v103 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v104 = *(const void **)(v99 + 16);
        if ( v103 >= 0x17 )
        {
          v105 = malloc((v103 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v106 = &v100[48 * v124];
          *((_QWORD *)v106 + 1) = v103;
          *((_QWORD *)v106 + 2) = v105;
          *v101 = (v103 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v101 = 2 * v103;
          v105 = (char *)v101 + 1;
          if ( !v103 )
            goto LABEL_169;
        }
        memcpy(v105, v104, v103);
LABEL_169:
        *((_BYTE *)v105 + v103) = 0;
LABEL_170:
        v107 = &v100[48 * v124];
        *((_QWORD *)v107 + 3) = 0;
        v108 = v107 + 24;
        *((_QWORD *)v108 + 1) = 0;
        *((_QWORD *)v108 + 2) = 0;
        if ( (*(_BYTE *)(v99 + 24) & 1) == 0 )
        {
          *((_QWORD *)v108 + 2) = *(_QWORD *)(v99 + 40);
          *(_OWORD *)v108 = *(_OWORD *)(v99 + 24);
LABEL_179:
          v115 = (void **)*a3;
          v114 = (void **)a3[1];
          v116 = v101 + 6;
          if ( v114 == *a3 )
          {
            v118 = (void **)*a3;
          }
          else
          {
            do
            {
              *(v101 - 4) = (size_t)*(v114 - 4);
              *((_OWORD *)v101 - 3) = *((_OWORD *)v114 - 3);
              v117 = (size_t)*(v114 - 1);
              *(v114 - 5) = 0;
              *(v114 - 4) = 0;
              *(v114 - 6) = 0;
              *(v101 - 1) = v117;
              *(_OWORD *)(v101 - 3) = *(_OWORD *)(v114 - 3);
              *(v114 - 3) = 0;
              *(v114 - 2) = 0;
              *(v114 - 1) = 0;
              v114 -= 6;
              v101 -= 6;
            }
            while ( v115 != v114 );
            v118 = (void **)*a3;
            v115 = (void **)a3[1];
          }
          *a3 = v101;
          a3[1] = v116;
          v119 = a3[2];
          v98 = v185;
          a3[2] = v102;
          if ( v115 != v118 )
          {
            do
            {
              if ( (*(_BYTE *)(v115 - 3) & 1) != 0 )
                free(*(v115 - 1));
              v120 = v115 - 6;
              if ( (*(_BYTE *)(v115 - 6) & 1) != 0 )
                free(*(v115 - 4));
              v115 -= 6;
            }
            while ( v118 != v120 );
          }
          if ( v118 )
          {
            v121 = (unsigned __int64)a3[3];
            if ( v121 + 4096 < (unsigned __int64)v118 || v121 > (unsigned __int64)v118 )
            {
              free(v118);
            }
            else if ( *(void **)(v121 + 4096) == v119 )
            {
              *(_QWORD *)(v121 + 4096) = v118;
            }
          }
          goto LABEL_223;
        }
        v109 = *(_QWORD *)(v99 + 32);
        if ( v109 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v110 = *(const void **)(v99 + 40);
        if ( v109 >= 0x17 )
        {
          v112 = malloc((v109 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v113 = &v100[48 * v124];
          *((_QWORD *)v113 + 4) = v109;
          *((_QWORD *)v113 + 5) = v112;
          *(_QWORD *)v108 = (v109 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v111 = v112;
        }
        else
        {
          *v108 = 2 * v109;
          v111 = v108 + 1;
          if ( !v109 )
            goto LABEL_178;
        }
        memcpy(v111, v110, v109);
LABEL_178:
        *((_BYTE *)v111 + v109) = 0;
        goto LABEL_179;
      }
      v123[1] = 0;
      v123[2] = 0;
      *v123 = 0;
      if ( (*(_BYTE *)v99 & 1) == 0 )
      {
        v123[2] = *(_QWORD *)(v99 + 16);
        *(_OWORD *)v123 = *(_OWORD *)v99;
        goto LABEL_213;
      }
      v130 = *(_QWORD *)(v99 + 8);
      if ( v130 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_304:
        abort();
      v131 = *(const void **)(v99 + 16);
      if ( v130 >= 0x17 )
      {
        v132 = malloc((v130 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v123[1] = v130;
        v123[2] = (size_t)v132;
        *v123 = (v130 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        *(_BYTE *)v123 = 2 * v130;
        v132 = (char *)v123 + 1;
        if ( !v130 )
          goto LABEL_212;
      }
      memcpy(v132, v131, v130);
LABEL_212:
      *((_BYTE *)v132 + v130) = 0;
LABEL_213:
      v123[3] = 0;
      v133 = v123 + 3;
      v123[4] = 0;
      v123[5] = 0;
      if ( (*(_BYTE *)(v99 + 24) & 1) != 0 )
      {
        v134 = *(_QWORD *)(v99 + 32);
        if ( v134 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v135 = *(const void **)(v99 + 40);
        if ( v134 >= 0x17 )
        {
          v136 = malloc((v134 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v123[4] = v134;
          v123[5] = (size_t)v136;
          v123[3] = (v134 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *v133 = 2 * v134;
          v136 = (char *)v123 + 25;
          if ( !v134 )
            goto LABEL_221;
        }
        memcpy(v136, v135, v134);
LABEL_221:
        *((_BYTE *)v136 + v134) = 0;
        goto LABEL_222;
      }
      v123[5] = *(_QWORD *)(v99 + 40);
      *(_OWORD *)v133 = *(_OWORD *)(v99 + 24);
LABEL_222:
      a3[1] = (char *)a3[1] + 48;
LABEL_223:
      v99 += 48;
      if ( v99 == v98 )
        return v47 + 1;
    }
  }
  return v4;
}

//----- (00000000000454F4) ----------------------------------------------------
__int64 __fastcall sub_454F4(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  _BYTE *v3; // x20
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 *v7; // x8
  __int64 v8; // x26
  __int64 v9; // x27
  char *v10; // x21
  size_t *v11; // x28
  char *v12; // x20
  size_t v13; // x22
  const void *v14; // x23
  void *v15; // x24
  char *v16; // x8
  char *v17; // x22
  char *v18; // x22
  size_t v19; // x23
  const void *v20; // x24
  void *v21; // x22
  void *v22; // x0
  char *v23; // x8
  void **v24; // x9
  void **v25; // x22
  _QWORD *v26; // x8
  size_t v27; // x10
  void **v28; // x21
  __int64 v29; // x23
  void **v30; // x24
  unsigned __int64 v31; // x8
  size_t *v32; // x9
  size_t *v33; // x25
  unsigned __int64 v34; // x26
  unsigned __int64 v35; // x9
  __int64 v36; // x22
  unsigned __int64 v37; // x9
  __int64 v38; // x8
  size_t v39; // x0
  size_t v40; // x21
  const void *v41; // x22
  void *v42; // x23
  _BYTE *v43; // x21
  size_t v44; // x22
  const void *v45; // x23
  void *v46; // x21
  __int64 v47; // x8
  _BYTE *v48; // x27
  _BYTE *v49; // x24
  __int64 v50; // x12
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x9
  __int64 v53; // x9
  __int64 v54; // x9
  __int64 v55; // x10
  unsigned __int64 v56; // x8
  __int64 *v57; // x8
  __int64 v58; // x26
  __int64 v59; // x28
  unsigned __int64 v60; // x22
  __int64 v61; // x21
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x9
  __int64 v64; // x9
  char *v65; // x0
  char *v66; // x21
  size_t *v67; // x26
  char *v68; // x20
  size_t v69; // x22
  const void *v70; // x1
  void *v71; // x24
  const void *v72; // x24
  void *v73; // x0
  char *v74; // x8
  char *v75; // x22
  char *v76; // x22
  size_t v77; // x23
  const void *v78; // x1
  void *v79; // x22
  const void *v80; // x20
  void *v81; // x0
  char *v82; // x8
  void **v83; // x9
  void **v84; // x22
  _QWORD *v85; // x8
  size_t v86; // x10
  void **v87; // x21
  __int64 v88; // x23
  void **v89; // x24
  unsigned __int64 v90; // x8
  size_t *v91; // x9
  size_t *v92; // x25
  unsigned __int64 v93; // x25
  unsigned __int64 v94; // x9
  __int64 v95; // x22
  unsigned __int64 v96; // x9
  __int64 v97; // x8
  size_t v98; // x0
  size_t v99; // x21
  const void *v100; // x22
  void *v101; // x23
  _BYTE *v102; // x21
  size_t v103; // x22
  const void *v104; // x23
  void *v105; // x21
  __int64 v106; // x22
  unsigned __int64 v107; // x23
  _BYTE *v108; // x0
  char *v109; // x8
  char *v110; // x9
  __int64 v111; // x10
  void **v112; // x11
  void **v113; // x22
  char *v114; // x10
  __int64 v115; // x12
  void **v116; // x21
  __int64 v117; // x23
  void **v118; // x24
  unsigned __int64 v119; // x8
  __int64 v121; // x9
  char *v122; // x8
  _BYTE *v123; // x10
  _OWORD *v124; // x12
  __int128 *v125; // x13
  unsigned __int64 v126; // x14
  __int128 v127; // q0
  __int128 v128; // q1
  __int64 v129; // x9
  _BYTE *v130; // x10
  char v131; // t1
  __int64 v132; // x8
  _BYTE *v133; // x21
  __int64 v134; // x9
  char v135; // w23
  unsigned __int64 v136; // x8
  unsigned __int64 v137; // x9
  unsigned __int64 v138; // x24
  __int64 v139; // x20
  unsigned __int64 v140; // x9
  unsigned __int64 v141; // x9
  __int64 v142; // x9
  char *v143; // x0
  char *v144; // x8
  char *v145; // x9
  void **v146; // x11
  void **v147; // x21
  char *v148; // x10
  __int64 v149; // x12
  void **v150; // x20
  __int64 v151; // x23
  void **v152; // x24
  unsigned __int64 v153; // x8
  char *v154; // [xsp+0h] [xbp-B0h]
  __int64 v157; // [xsp+18h] [xbp-98h]
  __int64 v158; // [xsp+18h] [xbp-98h]
  __int128 v159; // [xsp+20h] [xbp-90h] BYREF
  _BYTE *v160; // [xsp+30h] [xbp-80h]
  _QWORD v161[2]; // [xsp+38h] [xbp-78h] BYREF
  _QWORD v162[3]; // [xsp+48h] [xbp-68h] BYREF

  v3 = a1;
  v162[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 2 || *a1 != 84 )
    return (__int64)v3;
  v5 = (unsigned __int8)a1[1];
  if ( v5 != 95 )
  {
    v47 = v5 - 48;
    if ( (unsigned int)v47 > 9 || a1 + 2 == a2 )
      return (__int64)v3;
    v48 = 0;
    while ( 1 )
    {
      v49 = &v48[(_QWORD)a1];
      v50 = (unsigned __int8)v48[(_QWORD)a1 + 2];
      if ( (unsigned int)(v50 - 48) > 9 )
        break;
      ++v48;
      v47 = v50 - 48 + 10 * v47;
      if ( &a2[-2LL - (_QWORD)a1] == v48 )
        return (__int64)v3;
    }
    if ( (_DWORD)v50 != 95 )
      return (__int64)v3;
    v54 = *(_QWORD *)(a3 + 72);
    if ( *(_QWORD *)(a3 + 64) == v54 )
      return (__int64)v3;
    v55 = *(_QWORD *)(v54 - 32);
    v56 = v47 + 1;
    if ( v56 < (*(_QWORD *)(v54 - 24) - v55) >> 5 )
    {
      v57 = (__int64 *)(v55 + 32 * v56);
      v59 = *v57;
      v58 = v57[1];
      if ( *v57 == v58 )
        return (__int64)&v48[(_QWORD)a1 + 3];
      v158 = v57[1];
      while ( 1 )
      {
        v92 = *(size_t **)(a3 + 8);
        v91 = *(size_t **)(a3 + 16);
        if ( v92 == v91 )
        {
          v93 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v92 - *(_QWORD *)a3) >> 4);
          if ( v93 + 1 > 0x555555555555555LL )
            goto LABEL_228;
          v94 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v91 - *(_QWORD *)a3) >> 4);
          v95 = 0x555555555555555LL;
          if ( v94 >= 0x2AAAAAAAAAAAAAALL || ((v96 = 2 * v94, v96 >= v93 + 1) ? (v95 = v96) : (v95 = v93 + 1), v95) )
          {
            v97 = *(_QWORD *)(a3 + 24);
            v98 = 48 * v95;
            v66 = *(char **)(v97 + 4096);
            if ( v97 + 4096 - (__int64)v66 >= (unsigned __int64)(48 * v95) )
              *(_QWORD *)(v97 + 4096) = &v66[v98];
            else
              v66 = (char *)malloc(v98);
          }
          else
          {
            v66 = 0;
          }
          v67 = (size_t *)&v66[48 * v93];
          v67[1] = 0;
          v67[2] = 0;
          *v67 = 0;
          v68 = &v66[48 * v95];
          if ( (*(_BYTE *)v59 & 1) == 0 )
          {
            v67[2] = *(_QWORD *)(v59 + 16);
            *(_OWORD *)v67 = *(_OWORD *)v59;
            goto LABEL_107;
          }
          v69 = *(_QWORD *)(v59 + 8);
          if ( v69 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v70 = *(const void **)(v59 + 16);
          if ( v69 >= 0x17 )
          {
            v72 = *(const void **)(v59 + 16);
            v73 = malloc((v69 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v70 = v72;
            v71 = v73;
            v74 = &v66[48 * v93];
            *((_QWORD *)v74 + 1) = v69;
            *((_QWORD *)v74 + 2) = v73;
            *v67 = (v69 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v67 = 2 * v69;
            v71 = (char *)v67 + 1;
            if ( !v69 )
              goto LABEL_106;
          }
          memcpy(v71, v70, v69);
LABEL_106:
          *((_BYTE *)v71 + v69) = 0;
LABEL_107:
          v75 = &v66[48 * v93];
          *((_QWORD *)v75 + 3) = 0;
          v76 = v75 + 24;
          *((_QWORD *)v76 + 1) = 0;
          *((_QWORD *)v76 + 2) = 0;
          if ( (*(_BYTE *)(v59 + 24) & 1) == 0 )
          {
            *((_QWORD *)v76 + 2) = *(_QWORD *)(v59 + 40);
            *(_OWORD *)v76 = *(_OWORD *)(v59 + 24);
LABEL_116:
            v84 = *(void ***)a3;
            v83 = *(void ***)(a3 + 8);
            v85 = v67 + 6;
            if ( v83 == *(void ***)a3 )
            {
              v87 = *(void ***)a3;
            }
            else
            {
              do
              {
                *(v67 - 4) = (size_t)*(v83 - 4);
                *((_OWORD *)v67 - 3) = *((_OWORD *)v83 - 3);
                v86 = (size_t)*(v83 - 1);
                *(v83 - 5) = 0;
                *(v83 - 4) = 0;
                *(v83 - 6) = 0;
                *(v67 - 1) = v86;
                *(_OWORD *)(v67 - 3) = *(_OWORD *)(v83 - 3);
                *(v83 - 3) = 0;
                *(v83 - 2) = 0;
                *(v83 - 1) = 0;
                v83 -= 6;
                v67 -= 6;
              }
              while ( v84 != v83 );
              v87 = *(void ***)a3;
              v84 = *(void ***)(a3 + 8);
            }
            *(_QWORD *)a3 = v67;
            *(_QWORD *)(a3 + 8) = v85;
            v88 = *(_QWORD *)(a3 + 16);
            v58 = v158;
            *(_QWORD *)(a3 + 16) = v68;
            if ( v84 != v87 )
            {
              do
              {
                if ( (*(_BYTE *)(v84 - 3) & 1) != 0 )
                  free(*(v84 - 1));
                v89 = v84 - 6;
                if ( (*(_BYTE *)(v84 - 6) & 1) != 0 )
                  free(*(v84 - 4));
                v84 -= 6;
              }
              while ( v87 != v89 );
            }
            if ( v87 )
            {
              v90 = *(_QWORD *)(a3 + 24);
              if ( v90 + 4096 < (unsigned __int64)v87 || v90 > (unsigned __int64)v87 )
              {
                free(v87);
              }
              else if ( *(_QWORD *)(v90 + 4096) == v88 )
              {
                *(_QWORD *)(v90 + 4096) = v87;
              }
            }
            goto LABEL_160;
          }
          v77 = *(_QWORD *)(v59 + 32);
          if ( v77 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v78 = *(const void **)(v59 + 40);
          if ( v77 >= 0x17 )
          {
            v154 = v68;
            v80 = *(const void **)(v59 + 40);
            v81 = malloc((v77 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v78 = v80;
            v68 = v154;
            v82 = &v66[48 * v93];
            *((_QWORD *)v82 + 4) = v77;
            *((_QWORD *)v82 + 5) = v81;
            *(_QWORD *)v76 = (v77 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            v79 = v81;
          }
          else
          {
            *v76 = 2 * v77;
            v79 = v76 + 1;
            if ( !v77 )
              goto LABEL_115;
          }
          memcpy(v79, v78, v77);
LABEL_115:
          *((_BYTE *)v79 + v77) = 0;
          goto LABEL_116;
        }
        v92[1] = 0;
        v92[2] = 0;
        *v92 = 0;
        if ( (*(_BYTE *)v59 & 1) == 0 )
        {
          v92[2] = *(_QWORD *)(v59 + 16);
          *(_OWORD *)v92 = *(_OWORD *)v59;
          goto LABEL_150;
        }
        v99 = *(_QWORD *)(v59 + 8);
        if ( v99 >= 0xFFFFFFFFFFFFFFF0LL )
          goto LABEL_228;
        v100 = *(const void **)(v59 + 16);
        if ( v99 >= 0x17 )
        {
          v101 = malloc((v99 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v92[1] = v99;
          v92[2] = (size_t)v101;
          *v92 = (v99 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v92 = 2 * v99;
          v101 = (char *)v92 + 1;
          if ( !v99 )
            goto LABEL_149;
        }
        memcpy(v101, v100, v99);
LABEL_149:
        *((_BYTE *)v101 + v99) = 0;
LABEL_150:
        v92[3] = 0;
        v102 = v92 + 3;
        v92[4] = 0;
        v92[5] = 0;
        if ( (*(_BYTE *)(v59 + 24) & 1) != 0 )
        {
          v103 = *(_QWORD *)(v59 + 32);
          if ( v103 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v104 = *(const void **)(v59 + 40);
          if ( v103 >= 0x17 )
          {
            v105 = malloc((v103 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v92[4] = v103;
            v92[5] = (size_t)v105;
            v92[3] = (v103 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *v102 = 2 * v103;
            v105 = (char *)v92 + 25;
            if ( !v103 )
              goto LABEL_158;
          }
          memcpy(v105, v104, v103);
LABEL_158:
          *((_BYTE *)v105 + v103) = 0;
          goto LABEL_159;
        }
        v92[5] = *(_QWORD *)(v59 + 40);
        *(_OWORD *)v102 = *(_OWORD *)(v59 + 24);
LABEL_159:
        *(_QWORD *)(a3 + 8) += 48LL;
LABEL_160:
        v59 += 48;
        if ( v59 == v58 )
          return (__int64)&v48[(_QWORD)a1 + 3];
      }
    }
    v106 = (__int64)&v48[(_QWORD)a1 + 3];
    v107 = (unsigned __int64)(v48 + 3);
    v159 = 0u;
    v160 = 0;
    if ( (unsigned __int64)(v48 + 3) >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_228:
      abort();
    if ( v107 > 0x16 )
    {
      v108 = malloc((unsigned __int64)(v48 + 19) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v159 + 1) = v48 + 3;
      v160 = v108;
      *(_QWORD *)&v159 = (unsigned __int64)(v48 + 19) & 0xFFFFFFFFFFFFFFF0LL | 1;
      if ( v48 == (_BYTE *)-3LL )
      {
LABEL_199:
        *v108 = 0;
        v132 = *((_QWORD *)&v159 + 1);
        v133 = v160;
        v134 = *(_QWORD *)((char *)&v159 + 1);
        v135 = v159;
        v159 = 0u;
        v160 = 0;
        memset(v161, 0, 15);
        *(_QWORD *)((char *)v162 + 7) = v132;
        v162[0] = v134;
        v136 = *(_QWORD *)(a3 + 8);
        v137 = *(_QWORD *)(a3 + 16);
        if ( v136 >= v137 )
        {
          v138 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v136 - *(_QWORD *)a3) >> 4);
          v139 = 0x555555555555555LL;
          if ( v138 + 1 > 0x555555555555555LL )
            abort();
          v140 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v137 - *(_QWORD *)a3) >> 4);
          if ( v140 >= 0x2AAAAAAAAAAAAAALL
            || ((v141 = 2 * v140, v141 >= v138 + 1) ? (v139 = v141) : (v139 = v138 + 1), v139) )
          {
            v142 = *(_QWORD *)(a3 + 24);
            v143 = *(char **)(v142 + 4096);
            if ( v142 + 4096 - (__int64)v143 >= (unsigned __int64)(48 * v139) )
              *(_QWORD *)(v142 + 4096) = &v143[48 * v139];
            else
              v143 = (char *)malloc(48 * v139);
          }
          else
          {
            v143 = 0;
          }
          v144 = &v143[48 * v138];
          *v144 = v135;
          v145 = &v143[48 * v139];
          *((_QWORD *)v144 + 1) = *(_QWORD *)((char *)v162 + 7);
          *((_QWORD *)v144 + 2) = v133;
          *(_QWORD *)(v144 + 1) = v162[0];
          memset(v162, 0, 15);
          v144[24] = 0;
          *((_QWORD *)v144 + 4) = *(_QWORD *)((char *)v161 + 7);
          *((_QWORD *)v144 + 5) = 0;
          *(_QWORD *)(v144 + 25) = v161[0];
          memset(v161, 0, 15);
          v147 = *(void ***)a3;
          v146 = *(void ***)(a3 + 8);
          v148 = v144 + 48;
          if ( v146 == *(void ***)a3 )
          {
            v150 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v144 - 4) = *(v146 - 4);
              *((_OWORD *)v144 - 3) = *((_OWORD *)v146 - 3);
              v149 = (__int64)*(v146 - 1);
              *(v146 - 5) = 0;
              *(v146 - 4) = 0;
              *(v146 - 6) = 0;
              *((_QWORD *)v144 - 1) = v149;
              *(_OWORD *)(v144 - 24) = *(_OWORD *)(v146 - 3);
              *(v146 - 3) = 0;
              *(v146 - 2) = 0;
              *(v146 - 1) = 0;
              v146 -= 6;
              v144 -= 48;
            }
            while ( v147 != v146 );
            v150 = *(void ***)a3;
            v147 = *(void ***)(a3 + 8);
          }
          v151 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v144;
          *(_QWORD *)(a3 + 8) = v148;
          *(_QWORD *)(a3 + 16) = v145;
          if ( v147 != v150 )
          {
            do
            {
              if ( (*(_BYTE *)(v147 - 3) & 1) != 0 )
                free(*(v147 - 1));
              v152 = v147 - 6;
              if ( (*(_BYTE *)(v147 - 6) & 1) != 0 )
                free(*(v147 - 4));
              v147 -= 6;
            }
            while ( v150 != v152 );
          }
          if ( v150 )
          {
            v153 = *(_QWORD *)(a3 + 24);
            if ( v153 + 4096 < (unsigned __int64)v150 || v153 > (unsigned __int64)v150 )
            {
              free(v150);
            }
            else if ( *(_QWORD *)(v153 + 4096) == v151 )
            {
              *(_QWORD *)(v153 + 4096) = v150;
            }
          }
        }
        else
        {
          *(_BYTE *)v136 = v135;
          *(_QWORD *)(v136 + 8) = *(_QWORD *)((char *)v162 + 7);
          *(_QWORD *)(v136 + 16) = v133;
          *(_QWORD *)(v136 + 1) = v162[0];
          memset(v162, 0, 15);
          *(_BYTE *)(v136 + 24) = 0;
          *(_QWORD *)(v136 + 32) = *(_QWORD *)((char *)v161 + 7);
          *(_QWORD *)(v136 + 40) = 0;
          *(_QWORD *)(v136 + 25) = v161[0];
          memset(v161, 0, 15);
          *(_QWORD *)(a3 + 8) += 48LL;
        }
        v3 = (_BYTE *)v106;
        goto LABEL_185;
      }
    }
    else
    {
      LOBYTE(v159) = 2 * v107;
      v108 = (char *)&v159 + 1;
      if ( v48 == (_BYTE *)-3LL )
        goto LABEL_199;
    }
    *v108 = 84;
    if ( v48 != (_BYTE *)-2LL )
    {
      v121 = (__int64)(v48 + 2);
      v122 = v3 + 1;
      if ( (unsigned __int64)(v48 + 2) >= 0x20 )
      {
        if ( v108 >= v49 + 2 || (v123 = v108, v122 >= &v48[(_QWORD)v108 + 3]) )
        {
          v124 = v108 + 17;
          v122 += v121 & 0xFFFFFFFFFFFFFFE0LL;
          v123 = &v108[v121 & 0xFFFFFFFFFFFFFFE0LL];
          v125 = (__int128 *)(v3 + 17);
          v126 = v121 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v127 = *(v125 - 1);
            v128 = *v125;
            v126 -= 32LL;
            v125 += 2;
            *(v124 - 1) = v127;
            *v124 = v128;
            v124 += 2;
          }
          while ( v126 );
          if ( (v121 & 0xFFFFFFFFFFFFFFE0LL) == v121 )
            goto LABEL_198;
        }
      }
      else
      {
        v123 = v108;
      }
      v129 = (__int64)&v48[v3 - v122 + 3];
      v130 = v123 + 1;
      do
      {
        v131 = *v122++;
        --v129;
        *v130++ = v131;
      }
      while ( v129 );
    }
LABEL_198:
    v108 += v107;
    goto LABEL_199;
  }
  v6 = *(_QWORD *)(a3 + 72);
  if ( *(_QWORD *)(a3 + 64) == v6 )
    return (__int64)v3;
  v7 = *(__int64 **)(v6 - 32);
  if ( v7 == *(__int64 **)(v6 - 24) )
  {
    LODWORD(v161[1]) = 0;
    v161[0] = 0;
    memset(v162, 0, 15);
    v51 = *(_QWORD *)(a3 + 8);
    v52 = *(_QWORD *)(a3 + 16);
    if ( v51 >= v52 )
    {
      v60 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v51 - *(_QWORD *)a3) >> 4);
      v61 = 0x555555555555555LL;
      if ( v60 + 1 > 0x555555555555555LL )
        abort();
      v62 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v52 - *(_QWORD *)a3) >> 4);
      if ( v62 >= 0x2AAAAAAAAAAAAAALL || ((v63 = 2 * v62, v63 >= v60 + 1) ? (v61 = v63) : (v61 = v60 + 1), v61) )
      {
        v64 = *(_QWORD *)(a3 + 24);
        v65 = *(char **)(v64 + 4096);
        if ( v64 + 4096 - (__int64)v65 >= (unsigned __int64)(48 * v61) )
          *(_QWORD *)(v64 + 4096) = &v65[48 * v61];
        else
          v65 = (char *)malloc(48 * v61);
      }
      else
      {
        v65 = 0;
      }
      v109 = &v65[48 * v60];
      *v109 = 4;
      strcpy(v109 + 1, "T_");
      v110 = &v65[48 * v61];
      *((_DWORD *)v109 + 3) = v161[1];
      v111 = v161[0];
      *((_QWORD *)v109 + 2) = 0;
      *(_QWORD *)(v109 + 4) = v111;
      LODWORD(v161[1]) = 0;
      v161[0] = 0;
      v109[24] = 0;
      *((_QWORD *)v109 + 4) = *(_QWORD *)((char *)v162 + 7);
      *((_QWORD *)v109 + 5) = 0;
      *(_QWORD *)(v109 + 25) = v162[0];
      memset(v162, 0, 15);
      v113 = *(void ***)a3;
      v112 = *(void ***)(a3 + 8);
      v114 = v109 + 48;
      if ( v112 == *(void ***)a3 )
      {
        v116 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v109 - 4) = *(v112 - 4);
          *((_OWORD *)v109 - 3) = *((_OWORD *)v112 - 3);
          v115 = (__int64)*(v112 - 1);
          *(v112 - 5) = 0;
          *(v112 - 4) = 0;
          *(v112 - 6) = 0;
          *((_QWORD *)v109 - 1) = v115;
          *(_OWORD *)(v109 - 24) = *(_OWORD *)(v112 - 3);
          *(v112 - 3) = 0;
          *(v112 - 2) = 0;
          *(v112 - 1) = 0;
          v112 -= 6;
          v109 -= 48;
        }
        while ( v113 != v112 );
        v116 = *(void ***)a3;
        v113 = *(void ***)(a3 + 8);
      }
      v117 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v109;
      *(_QWORD *)(a3 + 8) = v114;
      *(_QWORD *)(a3 + 16) = v110;
      if ( v113 != v116 )
      {
        do
        {
          if ( (*(_BYTE *)(v113 - 3) & 1) != 0 )
            free(*(v113 - 1));
          v118 = v113 - 6;
          if ( (*(_BYTE *)(v113 - 6) & 1) != 0 )
            free(*(v113 - 4));
          v113 -= 6;
        }
        while ( v116 != v118 );
      }
      if ( v116 )
      {
        v119 = *(_QWORD *)(a3 + 24);
        if ( v119 + 4096 < (unsigned __int64)v116 || v119 > (unsigned __int64)v116 )
        {
          free(v116);
        }
        else if ( *(_QWORD *)(v119 + 4096) == v117 )
        {
          *(_QWORD *)(v119 + 4096) = v116;
        }
      }
    }
    else
    {
      *(_BYTE *)v51 = 4;
      strcpy((char *)(v51 + 1), "T_");
      *(_DWORD *)(v51 + 12) = v161[1];
      v53 = v161[0];
      *(_QWORD *)(v51 + 16) = 0;
      *(_QWORD *)(v51 + 4) = v53;
      LODWORD(v161[1]) = 0;
      v161[0] = 0;
      *(_BYTE *)(v51 + 24) = 0;
      *(_QWORD *)(v51 + 32) = *(_QWORD *)((char *)v162 + 7);
      *(_QWORD *)(v51 + 40) = 0;
      *(_QWORD *)(v51 + 25) = v162[0];
      memset(v162, 0, 15);
      *(_QWORD *)(a3 + 8) += 48LL;
    }
    v3 += 2;
LABEL_185:
    *(_BYTE *)(a3 + 110) = 1;
    return (__int64)v3;
  }
  v9 = *v7;
  v8 = v7[1];
  if ( *v7 != v8 )
  {
    v157 = v7[1];
    do
    {
      v33 = *(size_t **)(a3 + 8);
      v32 = *(size_t **)(a3 + 16);
      if ( v33 == v32 )
      {
        v34 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v33 - *(_QWORD *)a3) >> 4);
        if ( v34 + 1 > 0x555555555555555LL )
          goto LABEL_228;
        v35 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v32 - *(_QWORD *)a3) >> 4);
        v36 = 0x555555555555555LL;
        if ( v35 >= 0x2AAAAAAAAAAAAAALL || ((v37 = 2 * v35, v37 >= v34 + 1) ? (v36 = v37) : (v36 = v34 + 1), v36) )
        {
          v38 = *(_QWORD *)(a3 + 24);
          v39 = 48 * v36;
          v10 = *(char **)(v38 + 4096);
          if ( v38 + 4096 - (__int64)v10 >= (unsigned __int64)(48 * v36) )
            *(_QWORD *)(v38 + 4096) = &v10[v39];
          else
            v10 = (char *)malloc(v39);
        }
        else
        {
          v10 = 0;
        }
        v11 = (size_t *)&v10[48 * v34];
        v11[1] = 0;
        v11[2] = 0;
        *v11 = 0;
        v12 = &v10[48 * v36];
        if ( (*(_BYTE *)v9 & 1) == 0 )
        {
          v11[2] = *(_QWORD *)(v9 + 16);
          *(_OWORD *)v11 = *(_OWORD *)v9;
          goto LABEL_19;
        }
        v13 = *(_QWORD *)(v9 + 8);
        if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v14 = *(const void **)(v9 + 16);
        if ( v13 >= 0x17 )
        {
          v15 = malloc((v13 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v16 = &v10[48 * v34];
          *((_QWORD *)v16 + 1) = v13;
          *((_QWORD *)v16 + 2) = v15;
          *v11 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v11 = 2 * v13;
          v15 = (char *)v11 + 1;
          if ( !v13 )
            goto LABEL_18;
        }
        memcpy(v15, v14, v13);
LABEL_18:
        *((_BYTE *)v15 + v13) = 0;
LABEL_19:
        v17 = &v10[48 * v34];
        *((_QWORD *)v17 + 3) = 0;
        v18 = v17 + 24;
        *((_QWORD *)v18 + 1) = 0;
        *((_QWORD *)v18 + 2) = 0;
        if ( (*(_BYTE *)(v9 + 24) & 1) == 0 )
        {
          *((_QWORD *)v18 + 2) = *(_QWORD *)(v9 + 40);
          *(_OWORD *)v18 = *(_OWORD *)(v9 + 24);
LABEL_28:
          v25 = *(void ***)a3;
          v24 = *(void ***)(a3 + 8);
          v26 = v11 + 6;
          if ( v24 == *(void ***)a3 )
          {
            v28 = *(void ***)a3;
          }
          else
          {
            do
            {
              *(v11 - 4) = (size_t)*(v24 - 4);
              *((_OWORD *)v11 - 3) = *((_OWORD *)v24 - 3);
              v27 = (size_t)*(v24 - 1);
              *(v24 - 5) = 0;
              *(v24 - 4) = 0;
              *(v24 - 6) = 0;
              *(v11 - 1) = v27;
              *(_OWORD *)(v11 - 3) = *(_OWORD *)(v24 - 3);
              *(v24 - 3) = 0;
              *(v24 - 2) = 0;
              *(v24 - 1) = 0;
              v24 -= 6;
              v11 -= 6;
            }
            while ( v25 != v24 );
            v28 = *(void ***)a3;
            v25 = *(void ***)(a3 + 8);
          }
          *(_QWORD *)a3 = v11;
          *(_QWORD *)(a3 + 8) = v26;
          v29 = *(_QWORD *)(a3 + 16);
          v8 = v157;
          *(_QWORD *)(a3 + 16) = v12;
          if ( v25 != v28 )
          {
            do
            {
              if ( (*(_BYTE *)(v25 - 3) & 1) != 0 )
                free(*(v25 - 1));
              v30 = v25 - 6;
              if ( (*(_BYTE *)(v25 - 6) & 1) != 0 )
                free(*(v25 - 4));
              v25 -= 6;
            }
            while ( v28 != v30 );
          }
          if ( v28 )
          {
            v31 = *(_QWORD *)(a3 + 24);
            if ( v31 + 4096 < (unsigned __int64)v28 || v31 > (unsigned __int64)v28 )
            {
              free(v28);
            }
            else if ( *(_QWORD *)(v31 + 4096) == v29 )
            {
              *(_QWORD *)(v31 + 4096) = v28;
            }
          }
          goto LABEL_72;
        }
        v19 = *(_QWORD *)(v9 + 32);
        if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v20 = *(const void **)(v9 + 40);
        if ( v19 >= 0x17 )
        {
          v22 = malloc((v19 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v23 = &v10[48 * v34];
          *((_QWORD *)v23 + 4) = v19;
          *((_QWORD *)v23 + 5) = v22;
          *(_QWORD *)v18 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v21 = v22;
        }
        else
        {
          *v18 = 2 * v19;
          v21 = v18 + 1;
          if ( !v19 )
            goto LABEL_27;
        }
        memcpy(v21, v20, v19);
LABEL_27:
        *((_BYTE *)v21 + v19) = 0;
        goto LABEL_28;
      }
      v33[1] = 0;
      v33[2] = 0;
      *v33 = 0;
      if ( (*(_BYTE *)v9 & 1) == 0 )
      {
        v33[2] = *(_QWORD *)(v9 + 16);
        *(_OWORD *)v33 = *(_OWORD *)v9;
        goto LABEL_62;
      }
      v40 = *(_QWORD *)(v9 + 8);
      if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_228;
      v41 = *(const void **)(v9 + 16);
      if ( v40 >= 0x17 )
      {
        v42 = malloc((v40 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v33[1] = v40;
        v33[2] = (size_t)v42;
        *v33 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        *(_BYTE *)v33 = 2 * v40;
        v42 = (char *)v33 + 1;
        if ( !v40 )
          goto LABEL_61;
      }
      memcpy(v42, v41, v40);
LABEL_61:
      *((_BYTE *)v42 + v40) = 0;
LABEL_62:
      v33[3] = 0;
      v43 = v33 + 3;
      v33[4] = 0;
      v33[5] = 0;
      if ( (*(_BYTE *)(v9 + 24) & 1) != 0 )
      {
        v44 = *(_QWORD *)(v9 + 32);
        if ( v44 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v45 = *(const void **)(v9 + 40);
        if ( v44 >= 0x17 )
        {
          v46 = malloc((v44 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v33[4] = v44;
          v33[5] = (size_t)v46;
          v33[3] = (v44 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *v43 = 2 * v44;
          v46 = (char *)v33 + 25;
          if ( !v44 )
            goto LABEL_70;
        }
        memcpy(v46, v45, v44);
LABEL_70:
        *((_BYTE *)v46 + v44) = 0;
        goto LABEL_71;
      }
      v33[5] = *(_QWORD *)(v9 + 40);
      *(_OWORD *)v43 = *(_OWORD *)(v9 + 24);
LABEL_71:
      *(_QWORD *)(a3 + 8) += 48LL;
LABEL_72:
      v9 += 48;
    }
    while ( v9 != v8 );
  }
  return (__int64)(a1 + 2);
}

//----- (0000000000046514) ----------------------------------------------------
_BYTE *__fastcall sub_46514(_BYTE *a1, _BYTE *a2, _QWORD *a3)
{
  _BYTE *v4; // x21
  _BYTE *v6; // x23
  _BYTE *v7; // x0
  _BYTE *v8; // x19
  __int64 v9; // x22
  unsigned __int64 v10; // x8
  const void *v11; // x1
  size_t v12; // x2
  void *v13; // x8
  __int128 v14; // q0
  __int64 v15; // x9
  __int64 v16; // x10
  void *v17; // x11
  char v18; // w8
  __int64 v19; // x8
  __int64 v20; // x9
  __int128 v22; // [xsp+0h] [xbp-B0h] BYREF
  void *p; // [xsp+10h] [xbp-A0h]
  __int128 v24; // [xsp+20h] [xbp-90h] BYREF
  void *v25; // [xsp+30h] [xbp-80h]
  char v26; // [xsp+38h] [xbp-78h] BYREF
  _BYTE v27[15]; // [xsp+39h] [xbp-77h]
  void *v28; // [xsp+48h] [xbp-68h]
  __int64 v29; // [xsp+50h] [xbp-60h]
  __int64 v30; // [xsp+58h] [xbp-58h]
  void *v31; // [xsp+60h] [xbp-50h]
  _BYTE v32[15]; // [xsp+68h] [xbp-48h] BYREF
  __int64 v33; // [xsp+78h] [xbp-38h]

  v4 = a1;
  v33 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 >= 4 && *a1 == 68 && ((unsigned __int8)a1[1] | 0x20) == 0x74 )
  {
    v6 = a1 + 2;
    v7 = (_BYTE *)sub_47B84(a1 + 2, a2, a3);
    v8 = v7;
    if ( v7 != v6 && v7 != a2 && *v7 == 69 )
    {
      v9 = a3[1];
      if ( *a3 != v9 )
      {
        v10 = *(unsigned __int8 *)(v9 - 24);
        if ( (v10 & 1) != 0 )
          v11 = *(const void **)(v9 - 8);
        else
          v11 = (const void *)(v9 - 23);
        if ( (v10 & 1) != 0 )
          v12 = *(_QWORD *)(v9 - 16);
        else
          v12 = v10 >> 1;
        sub_42BE4((size_t *)(v9 - 48), v11, v12);
        p = *(void **)(v9 - 32);
        v22 = *(_OWORD *)(v9 - 48);
        *(_QWORD *)(v9 - 48) = 0;
        *(_QWORD *)(v9 - 40) = 0;
        *(_QWORD *)(v9 - 32) = 0;
        sub_429F4((size_t *)&v22, 0, "decltype(", 9u);
        v13 = p;
        v14 = v22;
        v22 = 0u;
        p = 0;
        v25 = v13;
        v24 = v14;
        sub_42BE4((size_t *)&v24, ")", 1u);
        v15 = *(_QWORD *)((char *)&v24 + 1);
        v16 = *((_QWORD *)&v24 + 1);
        v17 = v25;
        v18 = v24;
        v24 = 0u;
        v25 = 0;
        *(_QWORD *)&v32[7] = v16;
        v32[7] = HIBYTE(v15);
        v26 = v18;
        v19 = v15;
        v20 = *(_QWORD *)&v32[7];
        memset(v32, 0, sizeof(v32));
        *(_QWORD *)v27 = v19;
        *(_QWORD *)&v27[7] = v20;
        v28 = v17;
        v30 = 0;
        v31 = 0;
        v29 = 0;
        sub_4CB68((unsigned __int8 *)(a3[1] - 48LL), (__int64)&v26);
        if ( (v29 & 1) != 0 )
        {
          free(v31);
          if ( (v26 & 1) == 0 )
          {
LABEL_16:
            if ( (v24 & 1) == 0 )
              goto LABEL_17;
            goto LABEL_23;
          }
        }
        else if ( (v26 & 1) == 0 )
        {
          goto LABEL_16;
        }
        free(v28);
        if ( (v24 & 1) == 0 )
        {
LABEL_17:
          if ( (v22 & 1) == 0 )
            return v8 + 1;
LABEL_18:
          free(p);
          return v8 + 1;
        }
LABEL_23:
        free(v25);
        if ( (v22 & 1) == 0 )
          return v8 + 1;
        goto LABEL_18;
      }
    }
  }
  return v4;
}
// 47B84: using guessed type __int64 __fastcall sub_47B84(_QWORD, _QWORD, _QWORD);

//----- (0000000000046760) ----------------------------------------------------
unsigned __int8 *__fastcall sub_46760(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x19
  int v6; // w9
  __int64 v8; // x8
  unsigned int v9; // w9
  __int64 v10; // x8
  void *v11; // x21
  __int64 v12; // x9
  char v13; // w22
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x24
  __int64 v17; // x23
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x9
  __int64 v20; // x9
  char *v21; // x0
  signed __int64 v22; // x23
  int v23; // w8
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned int v26; // w9
  __int64 v27; // x8
  __int64 v28; // x9
  unsigned __int64 v29; // x9
  unsigned __int64 v30; // x8
  void **v31; // x9
  unsigned __int64 v32; // x11
  unsigned __int64 v33; // x28
  unsigned __int64 v34; // x24
  __int64 v35; // x22
  __int64 v36; // x9
  char *v37; // x0
  __int64 v38; // x22
  unsigned __int64 v39; // x9
  unsigned __int64 v40; // x9
  __int64 v41; // x9
  char *v42; // x0
  unsigned __int64 v43; // x24
  __int64 v44; // x23
  unsigned __int64 v45; // x9
  unsigned __int64 v46; // x9
  __int64 v47; // x9
  char *v48; // x0
  char *v49; // x8
  char *v50; // x9
  void **v51; // x11
  void **v52; // x22
  char *v53; // x10
  __int64 v54; // x12
  void **v55; // x21
  __int64 v56; // x23
  void **v57; // x24
  unsigned __int64 v58; // x8
  char *v59; // x8
  char *v60; // x9
  void **v61; // x11
  void **v62; // x24
  char *v63; // x10
  __int64 v64; // x12
  void **v65; // x22
  __int64 v66; // x25
  void **v67; // x26
  unsigned __int64 v68; // x8
  unsigned __int8 *v69; // x28
  int v70; // w26
  __int64 v71; // x8
  unsigned __int8 *v72; // x25
  __int64 v73; // x22
  _BYTE *v74; // x21
  void *v75; // x0
  __int64 v76; // x22
  unsigned __int64 v77; // x9
  size_t *v78; // x16
  size_t v79; // x23
  unsigned __int64 v80; // x24
  __int64 v81; // x10
  unsigned __int64 v82; // x17
  unsigned __int64 v83; // x11
  unsigned __int64 v84; // x12
  void *v85; // x0
  unsigned __int64 v86; // x8
  void *v87; // x9
  char *v88; // x8
  char *v89; // x9
  void **v90; // x11
  void **v91; // x23
  char *v92; // x10
  __int64 v93; // x12
  void **v94; // x22
  __int64 v95; // x24
  void **v96; // x25
  unsigned __int64 v97; // x8
  unsigned __int8 *v98; // x22
  unsigned __int8 *v99; // x2
  unsigned __int8 *v100; // x8
  bool v101; // zf
  unsigned __int8 *v102; // x22
  __int64 v103; // x0
  unsigned __int8 *v104; // x0
  char v105; // t1
  unsigned __int8 *v106; // x8
  __int64 v107; // x23
  char v108; // w25
  void **v109; // x26
  __int64 v110; // x0
  void **v111; // x24
  unsigned __int8 *v112; // x9
  void **v113; // x22
  signed __int64 v114; // x11
  __int64 v115; // x23
  __int64 v116; // x26
  void **v117; // x28
  unsigned __int64 v118; // x8
  void *v119; // x8
  unsigned __int64 v120; // x8
  void *v121; // x8
  size_t *v122; // x24
  unsigned __int64 v123; // x8
  char *v124; // x1
  size_t v125; // x2
  void *v126; // x25
  char *v127; // x1
  size_t v128; // x2
  __int64 v129; // x24
  __int64 v130; // x22
  __int64 v131; // x23
  int v132; // w9
  void **v133; // x8
  char *v134; // x8
  char *v135; // x9
  void **v136; // x11
  void **v137; // x22
  char *v138; // x10
  __int64 v139; // x12
  void **v140; // x24
  size_t v141; // x23
  unsigned __int64 v142; // x24
  unsigned __int8 *v143; // x8
  unsigned __int64 v144; // x9
  _BYTE *v145; // x10
  _OWORD *v146; // x12
  __int128 *v147; // x13
  unsigned __int64 v148; // x14
  __int128 v149; // q0
  __int128 v150; // q1
  _BYTE *v151; // x9
  char v152; // t1
  void *v153; // x23
  char *v154; // x1
  size_t v155; // x2
  size_t v156; // x8
  __int64 v157; // x21
  _BYTE *v158; // x22
  void *v159; // x0
  void *v160; // x26
  char *v161; // x8
  unsigned __int64 v162; // x11
  unsigned __int8 *v163; // x9
  size_t v164; // x10
  __int128 *v165; // x13
  char *v166; // x14
  unsigned __int64 v167; // x15
  __int128 v168; // q0
  __int128 v169; // q1
  unsigned __int8 v170; // t1
  size_t v171; // x8
  signed __int64 v172; // [xsp+8h] [xbp-C8h]
  size_t v173; // [xsp+8h] [xbp-C8h]
  unsigned __int8 *v174; // [xsp+10h] [xbp-C0h]
  unsigned __int64 v175; // [xsp+10h] [xbp-C0h]
  unsigned __int64 v176; // [xsp+20h] [xbp-B0h]
  void *v177; // [xsp+20h] [xbp-B0h]
  __int64 v178; // [xsp+2Fh] [xbp-A1h]
  _BYTE v179[15]; // [xsp+38h] [xbp-98h]
  __int64 v180; // [xsp+40h] [xbp-90h]
  _QWORD v181[2]; // [xsp+50h] [xbp-80h] BYREF
  __int128 v182; // [xsp+60h] [xbp-70h] BYREF
  void *p; // [xsp+70h] [xbp-60h]
  __int64 v184; // [xsp+78h] [xbp-58h]

  v4 = a1;
  v184 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 == a2 )
    return v4;
  v6 = *a1;
  if ( (unsigned int)(v6 - 49) < 9 )
    return sub_57438(a1, a2, (void **)a3);
  if ( (unsigned int)(v6 - 67) < 2 )
  {
    if ( a2 - a1 < 2 )
      return v4;
    v8 = *(_QWORD *)(a3 + 8);
    if ( *(_QWORD *)a3 == v8 )
      return v4;
    if ( v6 == 68 )
    {
      v26 = a1[1];
      if ( v26 > 0x35 || ((1LL << v26) & 0x27000000000000LL) == 0 )
        return v4;
      sub_57B54((size_t *)(v8 - 48), (__int64)&v182);
      sub_429F4((size_t *)&v182, 0, "~", 1u);
      v27 = *(_QWORD *)((char *)&v182 + 1);
      v28 = *((_QWORD *)&v182 + 1);
      v11 = p;
      v13 = v182;
      v182 = 0u;
      p = 0;
      v178 = v28;
      LOBYTE(v178) = HIBYTE(v27);
      memset(v181, 0, 15);
      *(_QWORD *)&v179[7] = v178;
      *(_QWORD *)v179 = v27;
      v14 = *(_QWORD *)(a3 + 8);
      v29 = *(_QWORD *)(a3 + 16);
      if ( v14 >= v29 )
      {
        v43 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v14 - *(_QWORD *)a3) >> 4);
        v44 = 0x555555555555555LL;
        if ( v43 + 1 > 0x555555555555555LL )
          abort();
        v45 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v29 - *(_QWORD *)a3) >> 4);
        if ( v45 >= 0x2AAAAAAAAAAAAAALL || ((v46 = 2 * v45, v46 >= v43 + 1) ? (v44 = v46) : (v44 = v43 + 1), v44) )
        {
          v47 = *(_QWORD *)(a3 + 24);
          v48 = *(char **)(v47 + 4096);
          if ( v47 + 4096 - (__int64)v48 >= (unsigned __int64)(48 * v44) )
            *(_QWORD *)(v47 + 4096) = &v48[48 * v44];
          else
            v48 = (char *)malloc(48 * v44);
        }
        else
        {
          v48 = 0;
        }
        v134 = &v48[48 * v43];
        *v134 = v13;
        v135 = &v48[48 * v44];
        *((_QWORD *)v134 + 1) = *(_QWORD *)&v179[7];
        *((_QWORD *)v134 + 2) = v11;
        *(_QWORD *)(v134 + 1) = *(_QWORD *)v179;
        v134[24] = 0;
        *((_QWORD *)v134 + 4) = *(_QWORD *)((char *)v181 + 7);
        *((_QWORD *)v134 + 5) = 0;
        *(_QWORD *)(v134 + 25) = 0;
        v137 = *(void ***)a3;
        v136 = *(void ***)(a3 + 8);
        v138 = v134 + 48;
        if ( v136 == *(void ***)a3 )
        {
          v55 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v134 - 4) = *(v136 - 4);
            *((_OWORD *)v134 - 3) = *((_OWORD *)v136 - 3);
            v139 = (__int64)*(v136 - 1);
            *(v136 - 5) = 0;
            *(v136 - 4) = 0;
            *(v136 - 6) = 0;
            *((_QWORD *)v134 - 1) = v139;
            *(_OWORD *)(v134 - 24) = *(_OWORD *)(v136 - 3);
            *(v136 - 3) = 0;
            *(v136 - 2) = 0;
            *(v136 - 1) = 0;
            v136 -= 6;
            v134 -= 48;
          }
          while ( v137 != v136 );
          v55 = *(void ***)a3;
          v137 = *(void ***)(a3 + 8);
        }
        v56 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v134;
        *(_QWORD *)(a3 + 8) = v138;
        *(_QWORD *)(a3 + 16) = v135;
        if ( v137 != v55 )
        {
          do
          {
            if ( (*(_BYTE *)(v137 - 3) & 1) != 0 )
              free(*(v137 - 1));
            v140 = v137 - 6;
            if ( (*(_BYTE *)(v137 - 6) & 1) != 0 )
              free(*(v137 - 4));
            v137 -= 6;
          }
          while ( v55 != v140 );
        }
        if ( !v55 )
          goto LABEL_225;
        v58 = *(_QWORD *)(a3 + 24);
        if ( v58 + 4096 < (unsigned __int64)v55 || v58 > (unsigned __int64)v55 )
          goto LABEL_224;
LABEL_221:
        if ( *(_QWORD *)(v58 + 4096) == v56 )
        {
          *(_QWORD *)(v58 + 4096) = v55;
          if ( (v182 & 1) == 0 )
            goto LABEL_227;
          goto LABEL_226;
        }
LABEL_225:
        if ( (v182 & 1) == 0 )
        {
LABEL_227:
          v4 += 2;
          *(_BYTE *)(a3 + 108) = 1;
          return v4;
        }
LABEL_226:
        free(p);
        goto LABEL_227;
      }
    }
    else
    {
      if ( v6 != 67 )
        return v4;
      v9 = a1[1];
      if ( v9 > 0x35 || ((1LL << v9) & 0x2E000000000000LL) == 0 )
        return v4;
      sub_57B54((size_t *)(v8 - 48), (__int64)&v182);
      v10 = *((_QWORD *)&v182 + 1);
      v11 = p;
      v12 = *(_QWORD *)((char *)&v182 + 1);
      v13 = v182;
      p = 0;
      v182 = 0u;
      memset(v181, 0, 15);
      *(_QWORD *)&v179[7] = v10;
      *(_QWORD *)v179 = v12;
      v14 = *(_QWORD *)(a3 + 8);
      v15 = *(_QWORD *)(a3 + 16);
      if ( v14 >= v15 )
      {
        v16 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v14 - *(_QWORD *)a3) >> 4);
        v17 = 0x555555555555555LL;
        if ( v16 + 1 > 0x555555555555555LL )
          abort();
        v18 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v15 - *(_QWORD *)a3) >> 4);
        if ( v18 >= 0x2AAAAAAAAAAAAAALL || ((v19 = 2 * v18, v19 >= v16 + 1) ? (v17 = v19) : (v17 = v16 + 1), v17) )
        {
          v20 = *(_QWORD *)(a3 + 24);
          v21 = *(char **)(v20 + 4096);
          if ( v20 + 4096 - (__int64)v21 >= (unsigned __int64)(48 * v17) )
            *(_QWORD *)(v20 + 4096) = &v21[48 * v17];
          else
            v21 = (char *)malloc(48 * v17);
        }
        else
        {
          v21 = 0;
        }
        v49 = &v21[48 * v16];
        *v49 = v13;
        v50 = &v21[48 * v17];
        *((_QWORD *)v49 + 1) = *(_QWORD *)&v179[7];
        *((_QWORD *)v49 + 2) = v11;
        *(_QWORD *)(v49 + 1) = *(_QWORD *)v179;
        v49[24] = 0;
        *((_QWORD *)v49 + 4) = *(_QWORD *)((char *)v181 + 7);
        *((_QWORD *)v49 + 5) = 0;
        *(_QWORD *)(v49 + 25) = 0;
        v52 = *(void ***)a3;
        v51 = *(void ***)(a3 + 8);
        v53 = v49 + 48;
        if ( v51 == *(void ***)a3 )
        {
          v55 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v49 - 4) = *(v51 - 4);
            *((_OWORD *)v49 - 3) = *((_OWORD *)v51 - 3);
            v54 = (__int64)*(v51 - 1);
            *(v51 - 5) = 0;
            *(v51 - 4) = 0;
            *(v51 - 6) = 0;
            *((_QWORD *)v49 - 1) = v54;
            *(_OWORD *)(v49 - 24) = *(_OWORD *)(v51 - 3);
            *(v51 - 3) = 0;
            *(v51 - 2) = 0;
            *(v51 - 1) = 0;
            v51 -= 6;
            v49 -= 48;
          }
          while ( v52 != v51 );
          v55 = *(void ***)a3;
          v52 = *(void ***)(a3 + 8);
        }
        v56 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v49;
        *(_QWORD *)(a3 + 8) = v53;
        *(_QWORD *)(a3 + 16) = v50;
        if ( v52 != v55 )
        {
          do
          {
            if ( (*(_BYTE *)(v52 - 3) & 1) != 0 )
              free(*(v52 - 1));
            v57 = v52 - 6;
            if ( (*(_BYTE *)(v52 - 6) & 1) != 0 )
              free(*(v52 - 4));
            v52 -= 6;
          }
          while ( v55 != v57 );
        }
        if ( !v55 )
          goto LABEL_225;
        v58 = *(_QWORD *)(a3 + 24);
        if ( v58 + 4096 < (unsigned __int64)v55 || v58 > (unsigned __int64)v55 )
        {
LABEL_224:
          free(v55);
          goto LABEL_225;
        }
        goto LABEL_221;
      }
    }
    *(_BYTE *)v14 = v13;
    *(_QWORD *)(v14 + 8) = *(_QWORD *)&v179[7];
    *(_QWORD *)(v14 + 16) = v11;
    *(_QWORD *)(v14 + 1) = *(_QWORD *)v179;
    *(_BYTE *)(v14 + 24) = 0;
    *(_QWORD *)(v14 + 32) = *(_QWORD *)((char *)v181 + 7);
    *(_QWORD *)(v14 + 40) = 0;
    *(_QWORD *)(v14 + 25) = v181[0];
    *(_QWORD *)(a3 + 8) += 48LL;
    if ( (v182 & 1) == 0 )
      goto LABEL_227;
    goto LABEL_226;
  }
  if ( v6 != 85 )
    return sub_51914(a1, a2, a3);
  v22 = a2 - a1;
  if ( a2 - a1 < 3 )
    return v4;
  v23 = a1[1];
  if ( v23 == 108 )
  {
    v31 = *(void ***)a3;
    v30 = *(_QWORD *)(a3 + 8);
    v180 = 10240;
    LOBYTE(v180) = aLambda[7];
    *(_QWORD *)&v182 = *(_QWORD *)"'lambda'(";
    *(_QWORD *)((char *)&v182 + 7) = v180;
    v32 = *(_QWORD *)(a3 + 16);
    v33 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v30 - (_QWORD)v31) >> 4);
    if ( v32 <= v30 )
    {
      v38 = 0x555555555555555LL;
      if ( v33 + 1 > 0x555555555555555LL )
        abort();
      v39 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v32 - (_QWORD)v31) >> 4);
      if ( v39 >= 0x2AAAAAAAAAAAAAALL || ((v40 = 2 * v39, v40 >= v33 + 1) ? (v38 = v40) : (v38 = v33 + 1), v38) )
      {
        v41 = *(_QWORD *)(a3 + 24);
        v42 = *(char **)(v41 + 4096);
        if ( v41 + 4096 - (__int64)v42 >= (unsigned __int64)(48 * v38) )
          *(_QWORD *)(v41 + 4096) = &v42[48 * v38];
        else
          v42 = (char *)malloc(48 * v38);
      }
      else
      {
        v42 = 0;
      }
      v88 = &v42[48 * v33];
      *v88 = 18;
      v89 = &v42[48 * v38];
      *((_QWORD *)v88 + 1) = *(_QWORD *)((char *)&v182 + 7);
      *((_QWORD *)v88 + 2) = 0;
      *(_QWORD *)(v88 + 1) = v182;
      *(_QWORD *)((char *)&v182 + 7) = 0;
      *(_QWORD *)&v182 = 0;
      v88[24] = 0;
      *((_QWORD *)v88 + 4) = 0;
      *((_QWORD *)v88 + 5) = 0;
      *(_QWORD *)(v88 + 25) = 0;
      v91 = *(void ***)a3;
      v90 = *(void ***)(a3 + 8);
      v92 = v88 + 48;
      if ( v90 == *(void ***)a3 )
      {
        v94 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v88 - 4) = *(v90 - 4);
          *((_OWORD *)v88 - 3) = *((_OWORD *)v90 - 3);
          v93 = (__int64)*(v90 - 1);
          *(v90 - 5) = 0;
          *(v90 - 4) = 0;
          *(v90 - 6) = 0;
          *((_QWORD *)v88 - 1) = v93;
          *(_OWORD *)(v88 - 24) = *(_OWORD *)(v90 - 3);
          *(v90 - 3) = 0;
          *(v90 - 2) = 0;
          *(v90 - 1) = 0;
          v90 -= 6;
          v88 -= 48;
        }
        while ( v91 != v90 );
        v94 = *(void ***)a3;
        v91 = *(void ***)(a3 + 8);
      }
      v95 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v88;
      *(_QWORD *)(a3 + 8) = v92;
      *(_QWORD *)(a3 + 16) = v89;
      if ( v91 != v94 )
      {
        do
        {
          if ( (*(_BYTE *)(v91 - 3) & 1) != 0 )
            free(*(v91 - 1));
          v96 = v91 - 6;
          if ( (*(_BYTE *)(v91 - 6) & 1) != 0 )
            free(*(v91 - 4));
          v91 -= 6;
        }
        while ( v94 != v96 );
      }
      if ( v94 )
      {
        v97 = *(_QWORD *)(a3 + 24);
        if ( v97 + 4096 < (unsigned __int64)v94 || v97 > (unsigned __int64)v94 )
        {
          free(v94);
        }
        else if ( *(_QWORD *)(v97 + 4096) == v95 )
        {
          *(_QWORD *)(v97 + 4096) = v94;
        }
      }
    }
    else
    {
      *(_BYTE *)v30 = 18;
      *(_QWORD *)(v30 + 8) = *(_QWORD *)((char *)&v182 + 7);
      *(_QWORD *)(v30 + 16) = 0;
      *(_QWORD *)(v30 + 1) = v182;
      *(_QWORD *)((char *)&v182 + 7) = 0;
      *(_QWORD *)&v182 = 0;
      *(_BYTE *)(v30 + 24) = 0;
      *(_QWORD *)(v30 + 32) = 0;
      *(_QWORD *)(v30 + 40) = 0;
      *(_QWORD *)(v30 + 25) = 0;
      *(_QWORD *)(a3 + 8) += 48LL;
    }
    v98 = v4 + 2;
    if ( v4[2] == 118 )
    {
      sub_57F64((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), 41);
      v98 = v4 + 3;
      if ( v4 + 3 == a2 )
        goto LABEL_265;
    }
    else
    {
      v107 = *(_QWORD *)(a3 + 8);
      v108 = 1;
      v176 = v33;
      while ( 1 )
      {
        v109 = *(void ***)a3;
        v110 = sub_38008(v98, a2, a3);
        v111 = *(void ***)(a3 + 8);
        if ( (unsigned __int8 *)v110 == v98 )
        {
          v131 = *(_QWORD *)(a3 + 8);
          v132 = 6;
          goto LABEL_200;
        }
        v112 = v98;
        v113 = *(void ***)a3;
        v114 = 0xAAAAAAAAAAAAAAABLL * ((v107 - (__int64)v109) >> 4);
        if ( v114 >= (__int64)(0xAAAAAAAAAAAAAAABLL * (((__int64)v111 - *(_QWORD *)a3) >> 4)) )
          break;
        v115 = 16 * ((v107 - (__int64)v109) >> 4);
        v116 = 16 * (((__int64)v111 - *(_QWORD *)a3) >> 4);
        v172 = v114;
        v174 = (unsigned __int8 *)v110;
        do
        {
          v117 = &v113[(unsigned __int64)v115 / 8];
          v118 = LOBYTE(v113[(unsigned __int64)v115 / 8]);
          if ( (v118 & 1) != 0 )
            v119 = v113[(unsigned __int64)v115 / 8 + 1];
          else
            v119 = (void *)(v118 >> 1);
          if ( v119
            || ((v120 = *((unsigned __int8 *)v117 + 24), (v120 & 1) != 0)
              ? (v121 = v117[4])
              : (v121 = (void *)(v120 >> 1)),
                v121) )
          {
            v122 = (size_t *)(*(_QWORD *)a3 + 48 * v176);
            if ( !v108 )
              sub_42BE4((size_t *)(*(_QWORD *)a3 + 48 * v176), &unk_64834, 2u);
            v123 = LOBYTE(v113[(unsigned __int64)v115 / 8 + 3]);
            if ( (v123 & 1) != 0 )
              v124 = (char *)v113[(unsigned __int64)v115 / 8 + 5];
            else
              v124 = (char *)&v113[(unsigned __int64)v115 / 8 + 3] + 1;
            if ( (v123 & 1) != 0 )
              v125 = (size_t)v113[(unsigned __int64)v115 / 8 + 4];
            else
              v125 = v123 >> 1;
            sub_42BE4((size_t *)&v113[(unsigned __int64)v115 / 8], v124, v125);
            p = v117[2];
            v182 = *(_OWORD *)v117;
            v117[1] = 0;
            v117[2] = 0;
            *v117 = 0;
            v126 = p;
            if ( (v182 & 1) != 0 )
              v127 = (char *)p;
            else
              v127 = (char *)&v182 + 1;
            if ( (v182 & 1) != 0 )
              v128 = *((_QWORD *)&v182 + 1);
            else
              v128 = (unsigned __int64)(unsigned __int8)v182 >> 1;
            sub_42BE4(v122, v127, v128);
            if ( (v182 & 1) != 0 )
              free(v126);
            v108 = 0;
          }
          v116 -= 48;
          v113 += 6;
        }
        while ( v115 != v116 );
        v107 = *(_QWORD *)(a3 + 8);
        v129 = *(_QWORD *)a3 + 48 * v172;
        if ( v129 == v107 )
        {
          v33 = v176;
        }
        else
        {
          v33 = v176;
          do
          {
            if ( (*(_BYTE *)(v107 - 24) & 1) != 0 )
              free(*(void **)(v107 - 8));
            v130 = v107 - 48;
            if ( (*(_BYTE *)(v107 - 48) & 1) != 0 )
              free(*(void **)(v107 - 32));
            v107 -= 48;
          }
          while ( v129 != v130 );
          v107 = v129;
          *(_QWORD *)(a3 + 8) = v129;
        }
        v98 = v174;
      }
      v131 = *(_QWORD *)(a3 + 8);
      v98 = v112;
      v132 = 1;
LABEL_200:
      if ( v132 != 6 )
        return v4;
      v133 = *(void ***)a3;
      if ( v108 )
      {
        if ( v133 == v111 )
          return v4;
        v74 = v111 - 6;
        if ( (*(_BYTE *)(v111 - 3) & 1) != 0 )
          free(*(v111 - 1));
        if ( (*v74 & 1) == 0 )
          goto LABEL_110;
        v75 = *(v111 - 4);
        goto LABEL_109;
      }
      if ( v133 == v111 || 0xAAAAAAAAAAAAAAABLL * ((v131 - (__int64)v133) >> 4) - 1 != v33 )
        return v4;
      sub_42BE4((size_t *)v111 - 6, ")", 1u);
      if ( v98 == a2 )
        goto LABEL_265;
    }
    if ( *v98 == 69 )
    {
      v99 = v98 + 1;
      if ( v98 + 1 != a2 )
      {
        if ( (unsigned int)*v99 - 48 > 9 )
        {
          v102 = v98 + 1;
          if ( v99 == a2 )
            goto LABEL_265;
        }
        else
        {
          v100 = v98 + 2;
          v101 = v98 + 2 == a2;
          v102 = a2;
          if ( !v101 )
          {
            v102 = v100;
            while ( (unsigned int)*v102 - 48 <= 9 )
            {
              if ( a2 == ++v102 )
              {
                v102 = a2;
                break;
              }
            }
          }
          v103 = *(_QWORD *)(a3 + 8);
          v105 = *(_BYTE *)(v103 - 48);
          v104 = (unsigned __int8 *)(v103 - 48);
          if ( (v105 & 1) != 0 )
            v106 = *(unsigned __int8 **)(*(_QWORD *)(a3 + 8) - 32LL);
          else
            v106 = v104 + 1;
          sub_5808C(v104, (__int64)(v106 + 7), (unsigned __int64)v99, v102);
          if ( v102 == a2 )
            goto LABEL_265;
        }
        if ( *v102 == 95 )
          return v102 + 1;
      }
    }
LABEL_265:
    v157 = *(_QWORD *)(a3 + 8);
    if ( *(_QWORD *)a3 != v157 )
    {
      v158 = (_BYTE *)(v157 - 48);
      if ( (*(_BYTE *)(v157 - 24) & 1) != 0 )
        free(*(void **)(v157 - 8));
      if ( (*v158 & 1) != 0 )
        free(*(void **)(v157 - 32));
      *(_QWORD *)(a3 + 8) = v158;
    }
    return v4;
  }
  if ( v23 == 116 )
  {
    *(_QWORD *)&v182 = 0x64656D616E6E7527LL;
    *(_QWORD *)((char *)&v182 + 7) = 100;
    v24 = *(_QWORD *)(a3 + 8);
    v25 = *(_QWORD *)(a3 + 16);
    if ( v24 >= v25 )
    {
      v34 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v24 - *(_QWORD *)a3) >> 4);
      v35 = 0x555555555555555LL;
      if ( v34 + 1 > 0x555555555555555LL )
        abort();
      if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(v25 - *(_QWORD *)a3) >> 4) >= 0x2AAAAAAAAAAAAAALL
        || (0x5555555555555556LL * ((__int64)(v25 - *(_QWORD *)a3) >> 4) >= v34 + 1
          ? (v35 = 0x5555555555555556LL * ((__int64)(v25 - *(_QWORD *)a3) >> 4))
          : (v35 = v34 + 1),
            v35) )
      {
        v36 = *(_QWORD *)(a3 + 24);
        v37 = *(char **)(v36 + 4096);
        if ( v36 + 4096 - (__int64)v37 >= (unsigned __int64)(48 * v35) )
          *(_QWORD *)(v36 + 4096) = &v37[48 * v35];
        else
          v37 = (char *)malloc(48 * v35);
      }
      else
      {
        v37 = 0;
      }
      v59 = &v37[48 * v34];
      *v59 = 16;
      v60 = &v37[48 * v35];
      *((_QWORD *)v59 + 1) = *(_QWORD *)((char *)&v182 + 7);
      *((_QWORD *)v59 + 2) = 0;
      *(_QWORD *)(v59 + 1) = v182;
      *(_QWORD *)((char *)&v182 + 7) = 0;
      *(_QWORD *)&v182 = 0;
      v59[24] = 0;
      *((_QWORD *)v59 + 4) = 0;
      *((_QWORD *)v59 + 5) = 0;
      *(_QWORD *)(v59 + 25) = 0;
      v62 = *(void ***)a3;
      v61 = *(void ***)(a3 + 8);
      v63 = v59 + 48;
      if ( v61 == *(void ***)a3 )
      {
        v65 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v59 - 4) = *(v61 - 4);
          *((_OWORD *)v59 - 3) = *((_OWORD *)v61 - 3);
          v64 = (__int64)*(v61 - 1);
          *(v61 - 5) = 0;
          *(v61 - 4) = 0;
          *(v61 - 6) = 0;
          *((_QWORD *)v59 - 1) = v64;
          *(_OWORD *)(v59 - 24) = *(_OWORD *)(v61 - 3);
          *(v61 - 3) = 0;
          *(v61 - 2) = 0;
          *(v61 - 1) = 0;
          v61 -= 6;
          v59 -= 48;
        }
        while ( v62 != v61 );
        v65 = *(void ***)a3;
        v62 = *(void ***)(a3 + 8);
      }
      v66 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v59;
      *(_QWORD *)(a3 + 8) = v63;
      *(_QWORD *)(a3 + 16) = v60;
      if ( v62 != v65 )
      {
        do
        {
          if ( (*(_BYTE *)(v62 - 3) & 1) != 0 )
            free(*(v62 - 1));
          v67 = v62 - 6;
          if ( (*(_BYTE *)(v62 - 6) & 1) != 0 )
            free(*(v62 - 4));
          v62 -= 6;
        }
        while ( v65 != v67 );
      }
      if ( v65 )
      {
        v68 = *(_QWORD *)(a3 + 24);
        if ( v68 + 4096 < (unsigned __int64)v65 || v68 > (unsigned __int64)v65 )
        {
          free(v65);
        }
        else if ( *(_QWORD *)(v68 + 4096) == v66 )
        {
          *(_QWORD *)(v68 + 4096) = v65;
        }
      }
    }
    else
    {
      *(_BYTE *)v24 = 16;
      *(_QWORD *)(v24 + 8) = *(_QWORD *)((char *)&v182 + 7);
      *(_QWORD *)(v24 + 16) = 0;
      *(_QWORD *)(v24 + 1) = v182;
      *(_QWORD *)((char *)&v182 + 7) = 0;
      *(_QWORD *)&v182 = 0;
      *(_BYTE *)(v24 + 24) = 0;
      *(_QWORD *)(v24 + 32) = 0;
      *(_QWORD *)(v24 + 40) = 0;
      *(_QWORD *)(v24 + 25) = 0;
      *(_QWORD *)(a3 + 8) += 48LL;
    }
    v69 = v4 + 2;
    if ( v4 + 2 == a2 )
    {
LABEL_105:
      v73 = *(_QWORD *)(a3 + 8);
      v74 = (_BYTE *)(v73 - 48);
      if ( (*(_BYTE *)(v73 - 24) & 1) != 0 )
        free(*(void **)(v73 - 8));
      if ( (*v74 & 1) == 0 )
        goto LABEL_110;
      v75 = *(void **)(v73 - 32);
LABEL_109:
      free(v75);
LABEL_110:
      *(_QWORD *)(a3 + 8) = v74;
      return v4;
    }
    v70 = *v69;
    if ( (unsigned int)(v70 - 48) > 9 )
    {
      v72 = v4 + 2;
      goto LABEL_102;
    }
    if ( v4 + 3 == a2 )
    {
      v71 = 3;
      v72 = a2;
    }
    else
    {
      v71 = 3;
      while ( (unsigned int)v4[v71] - 48 <= 9 )
      {
        if ( v22 == ++v71 )
        {
          v72 = a2;
          goto LABEL_113;
        }
      }
      v72 = &v4[v71];
    }
LABEL_113:
    v76 = *(_QWORD *)(a3 + 8);
    v78 = (size_t *)(v76 - 48);
    v77 = *(unsigned __int8 *)(v76 - 48);
    if ( (*(_BYTE *)(v76 - 48) & 1) != 0 )
    {
      v81 = *(_QWORD *)(v76 - 48);
      v79 = *(_QWORD *)(v76 - 40);
      v80 = (v81 & 0xFFFFFFFFFFFFFFFELL) - 1;
      v82 = v71 - 2;
      if ( v71 == 2 )
        goto LABEL_102;
    }
    else
    {
      v79 = v77 >> 1;
      v80 = 22;
      LOBYTE(v81) = *(_BYTE *)(v76 - 48);
      v82 = v71 - 2;
      if ( v71 == 2 )
        goto LABEL_102;
    }
    if ( (v77 & 1) != 0 )
    {
      v84 = *(_QWORD *)(v76 - 40);
      v83 = *(_QWORD *)(v76 - 32);
      if ( v83 > (unsigned __int64)v69 )
        goto LABEL_125;
    }
    else
    {
      v83 = v76 - 47;
      v84 = v77 >> 1;
      if ( v76 - 47 > (unsigned __int64)v69 )
        goto LABEL_125;
    }
    if ( v83 + v84 > (unsigned __int64)v69 )
    {
      v182 = 0u;
      p = 0;
      if ( v82 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_294;
      if ( v82 > 0x16 )
      {
        v141 = (v71 + 14) & 0xFFFFFFFFFFFFFFF0LL;
        v142 = v82;
        v85 = malloc(v141);
        v82 = v142;
        v78 = (size_t *)(v76 - 48);
        *((_QWORD *)&v182 + 1) = v142;
        p = v85;
        *(_QWORD *)&v182 = v141 | 1;
      }
      else
      {
        LOBYTE(v182) = 2 * v82;
        v85 = (char *)&v182 + 1;
      }
      v143 = v4 + 3;
      *(_BYTE *)v85 = v70;
      if ( v4 + 3 != v72 )
      {
        v144 = (unsigned __int64)&v72[-3LL - (_QWORD)v4];
        if ( v144 < 0x20 )
        {
          v145 = v85;
LABEL_241:
          v151 = v145 + 1;
          do
          {
            v152 = *v143++;
            *v151++ = v152;
          }
          while ( v72 != v143 );
          goto LABEL_243;
        }
        if ( (char *)v85 + 1 < (char *)v72 )
        {
          v145 = v85;
          if ( v143 < &v72[-2LL - (_QWORD)v4 + (_QWORD)v85] )
            goto LABEL_241;
        }
        v146 = (char *)v85 + 17;
        v143 += v144 & 0xFFFFFFFFFFFFFFE0LL;
        v145 = (char *)v85 + (v144 & 0xFFFFFFFFFFFFFFE0LL);
        v147 = (__int128 *)(v4 + 19);
        v148 = v144 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v149 = *(v147 - 1);
          v150 = *v147;
          v148 -= 32LL;
          v147 += 2;
          *(v146 - 1) = v149;
          *v146 = v150;
          v146 += 2;
        }
        while ( v148 );
        if ( (v144 & 0xFFFFFFFFFFFFFFE0LL) != v144 )
          goto LABEL_241;
      }
LABEL_243:
      *((_BYTE *)v85 + v82) = 0;
      v153 = p;
      if ( (v182 & 1) != 0 )
        v154 = (char *)p;
      else
        v154 = (char *)&v182 + 1;
      if ( (v182 & 1) != 0 )
        v155 = *((_QWORD *)&v182 + 1);
      else
        v155 = (unsigned __int64)(unsigned __int8)v182 >> 1;
      sub_42BE4(v78, v154, v155);
      if ( (v182 & 1) != 0 )
        free(v153);
LABEL_102:
      sub_57F64((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), 39);
      if ( v72 != a2 && *v72 == 95 )
        return v72 + 1;
      goto LABEL_105;
    }
LABEL_125:
    if ( v80 - v79 >= v82 )
    {
LABEL_277:
      if ( (v81 & 1) != 0 )
        v161 = *(char **)(v76 - 32);
      else
        v161 = (char *)v78 + 1;
      v162 = (unsigned __int64)&v72[-2LL - (_QWORD)v4];
      v163 = (unsigned __int8 *)&v161[v79];
      v164 = v79 - (_QWORD)v69;
      if ( v162 < 0x20 || v163 < v72 && v69 < &v72[v79 - 2 - (_QWORD)v4 + (_QWORD)v161] )
        goto LABEL_297;
      v165 = (__int128 *)(v4 + 18);
      v163 += v162 & 0xFFFFFFFFFFFFFFE0LL;
      v69 += v162 & 0xFFFFFFFFFFFFFFE0LL;
      v166 = &v161[v79 + 16];
      v167 = v162 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v168 = *(v165 - 1);
        v169 = *v165;
        v165 += 2;
        v167 -= 32LL;
        *((_OWORD *)v166 - 1) = v168;
        *(_OWORD *)v166 = v169;
        v166 += 32;
      }
      while ( v167 );
      if ( (v162 & 0xFFFFFFFFFFFFFFE0LL) != v162 )
      {
LABEL_297:
        do
        {
          v170 = *v69++;
          *v163++ = v170;
        }
        while ( v72 != v69 );
      }
      v72[v164 + (_QWORD)v161] = 0;
      v171 = v79 + v82;
      if ( (*(_BYTE *)v78 & 1) != 0 )
        *(_QWORD *)(v76 - 40) = v171;
      else
        *(_BYTE *)v78 = 2 * v171;
      goto LABEL_102;
    }
    v86 = v79 + v82;
    if ( -17LL - v80 >= v79 + v82 - v80 )
    {
      if ( (v77 & 1) != 0 )
        v87 = *(void **)(v76 - 32);
      else
        v87 = (void *)(v76 - 47);
      v177 = v87;
      v175 = v82;
      if ( v80 > 0x7FFFFFFFFFFFFFE6LL )
      {
        v156 = -17;
      }
      else
      {
        if ( v86 < 2 * v80 )
          v86 = 2 * v80;
        if ( v86 >= 0x17 )
          v156 = (v86 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        else
          v156 = 23;
      }
      v173 = v156;
      v159 = malloc(v156);
      v160 = v159;
      if ( v79 )
        memcpy(v159, v177, v79);
      if ( v80 != 22 )
        free(v177);
      *(_QWORD *)(v76 - 32) = v160;
      v82 = v175;
      v78 = (size_t *)(v76 - 48);
      LOBYTE(v81) = v173 | 1;
      *(_QWORD *)(v76 - 48) = v173 | 1;
      goto LABEL_277;
    }
LABEL_294:
    abort();
  }
  return v4;
}
// 476E8: conditional instruction was optimized away because w8.4 is in (==1|==6)
// 38008: using guessed type __int64 __fastcall sub_38008(_QWORD, _QWORD, _QWORD);

//----- (0000000000047A3C) ----------------------------------------------------
void __fastcall sub_47A3C(size_t *a1, const void *a2, size_t a3)
{
  unsigned __int64 v6; // x25
  _BYTE *v7; // x22
  void *v8; // x22
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24

  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 >= a3 )
    {
LABEL_3:
      if ( (*(_BYTE *)a1 & 1) != 0 )
      {
        v7 = (_BYTE *)a1[2];
        if ( !a3 )
          goto LABEL_12;
      }
      else
      {
        v7 = (char *)a1 + 1;
        if ( !a3 )
        {
LABEL_12:
          v7[a3] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = a3;
          else
            *(_BYTE *)a1 = 2 * a3;
          return;
        }
      }
      memmove(v7, a2, a3);
      goto LABEL_12;
    }
  }
  else
  {
    v6 = 22;
    if ( a3 <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v6 < a3 - v6 )
    abort();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v8 = (void *)a1[2];
  else
    v8 = (char *)a1 + 1;
  if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v10 = -17;
  }
  else
  {
    v9 = 2 * v6;
    if ( 2 * v6 <= a3 )
      v9 = a3;
    if ( v9 >= 0x17 )
      v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v10 = 23;
  }
  v11 = malloc(v10);
  memcpy(v11, a2, a3);
  if ( v6 != 22 )
    free(v8);
  a1[1] = a3;
  a1[2] = (size_t)v11;
  *a1 = v10 | 1;
  *((_BYTE *)v11 + a3) = 0;
}

//----- (0000000000047B84) ----------------------------------------------------
unsigned __int8 *__fastcall sub_47B84(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x20
  __int64 v5; // x8
  int v7; // w10
  int v8; // w9
  _BOOL4 v9; // w23
  unsigned __int8 *v10; // x9
  unsigned __int8 *v12; // x22
  __int64 v13; // x0
  int v14; // w8
  unsigned __int8 *v15; // x22
  unsigned __int8 *v16; // x0
  __int64 v17; // x0
  unsigned __int8 *v18; // x23
  __int64 v19; // x0
  __int64 v20; // x22
  __int64 v21; // x21
  __int64 v22; // x22
  unsigned __int64 v23; // x8
  const void *v24; // x1
  size_t v25; // x2
  __int64 v26; // x20
  _BYTE *v27; // x22
  unsigned __int64 v28; // x8
  const void *v29; // x1
  size_t v30; // x2
  size_t *v31; // x0
  char v32; // w23
  size_t v33; // x22
  _WORD *v34; // x0
  int v35; // w9
  unsigned __int8 *v36; // x8
  _BOOL4 v37; // w23
  int v38; // w8
  unsigned __int8 *v39; // x23
  __int64 v40; // x0
  __int64 v41; // x22
  __int64 v42; // x22
  unsigned __int64 v43; // x8
  const void *v44; // x1
  size_t v45; // x2
  __int64 v46; // x22
  _BYTE *v47; // x23
  unsigned __int64 v48; // x8
  unsigned __int64 v49; // x8
  const void *v50; // x1
  size_t v51; // x2
  size_t *v52; // x0
  void *v53; // x8
  __int128 v54; // q0
  char *v55; // x8
  __int128 v56; // q0
  char v57; // w22
  char *v58; // x1
  size_t v59; // x2
  char *v60; // x8
  __int128 v61; // q0
  __int64 v62; // x9
  __int64 v63; // x10
  char *v64; // x11
  char v65; // w8
  __int64 v66; // x8
  __int64 v67; // x9
  int v68; // w19
  int v69; // w22
  int v70; // w8
  int v71; // w9
  unsigned __int8 *v72; // x22
  unsigned __int64 v73; // x23
  __int64 v74; // x24
  unsigned __int64 v75; // x8
  __int64 v76; // x11
  unsigned __int64 v77; // x23
  unsigned __int64 v78; // x0
  unsigned __int64 v79; // x8
  const void *v80; // x1
  size_t v81; // x2
  size_t *v82; // x0
  char v83; // w21
  void *v84; // x20
  char *v85; // x1
  size_t v86; // x2
  unsigned __int64 v87; // x22
  unsigned __int64 v88; // x20
  unsigned __int64 v89; // x21
  unsigned __int64 v90; // x23
  void *v91; // x20
  char v92; // w21
  __int64 v93; // x8
  unsigned __int64 v94; // x9
  unsigned __int8 *v95; // x22
  __int64 v96; // x0
  __int64 v97; // x23
  __int64 v98; // x0
  __int64 v99; // x22
  __int64 v100; // x0
  __int64 v101; // x23
  unsigned __int64 v102; // x8
  unsigned __int64 v103; // x8
  const void *v104; // x1
  size_t v105; // x2
  __int64 v106; // x20
  _BYTE *v107; // x22
  unsigned __int64 v108; // x8
  const void *v109; // x1
  size_t v110; // x2
  size_t *v111; // x0
  __int64 v112; // x20
  _BYTE *v113; // x22
  unsigned __int64 v114; // x8
  const void *v115; // x1
  size_t v116; // x2
  size_t *v117; // x0
  char v118; // w24
  size_t v119; // x22
  _WORD *v120; // x0
  unsigned __int8 *v121; // x22
  __int64 v122; // x21
  __int64 v123; // x22
  unsigned __int64 v124; // x8
  const void *v125; // x1
  size_t v126; // x2
  __int64 v127; // x9
  __int64 v128; // x10
  char *v129; // x11
  char v130; // w8
  __int64 v131; // x8
  __int64 v132; // x9
  unsigned __int64 v133; // x8
  unsigned __int64 v134; // x9
  int v135; // w9
  __int64 v136; // x9
  unsigned __int8 *v137; // x23
  __int64 v138; // x0
  _BYTE *v139; // x22
  __int64 v140; // x8
  unsigned __int64 v141; // x9
  size_t v142; // x10
  const void *v143; // x11
  size_t *v144; // x0
  const void *v145; // x8
  const void *v146; // x1
  size_t v147; // x2
  __int64 v148; // x27
  char v149; // w24
  unsigned __int8 *v150; // x23
  unsigned __int8 *v151; // x0
  unsigned __int8 *v152; // x22
  unsigned __int8 *v153; // x22
  unsigned __int64 v154; // x8
  _OWORD *v155; // x9
  unsigned __int8 *v156; // x23
  __int64 v157; // x0
  __int64 v158; // x22
  __int64 v159; // x22
  unsigned __int64 v160; // x8
  const void *v161; // x1
  size_t v162; // x2
  __int64 v163; // x22
  _BYTE *v164; // x23
  unsigned __int64 v165; // x8
  unsigned __int64 v166; // x8
  const void *v167; // x1
  size_t v168; // x2
  size_t *v169; // x0
  void *v170; // x8
  __int128 v171; // q0
  char *v172; // x8
  __int128 v173; // q0
  char v174; // w22
  char *v175; // x1
  size_t v176; // x2
  char *v177; // x8
  __int128 v178; // q0
  __int64 v179; // x9
  __int64 v180; // x10
  char *v181; // x11
  char v182; // w8
  __int64 v183; // x8
  __int64 v184; // x9
  int v185; // w19
  int v186; // w22
  _BYTE *v187; // x22
  unsigned __int8 *v188; // x22
  __int64 v189; // x21
  __int64 v190; // x23
  __int64 v191; // x8
  unsigned __int64 v192; // x8
  const void *v193; // x1
  size_t v194; // x2
  char *v195; // x8
  __int128 v196; // q0
  __int64 v197; // x8
  __int64 v198; // x9
  _BYTE *v199; // x27
  char v200; // w24
  __int64 v201; // x28
  _BYTE **v202; // x19
  unsigned __int8 *v203; // x23
  __int64 v204; // x0
  __int64 v205; // x22
  __int64 v206; // x22
  unsigned __int64 v207; // x8
  const void *v208; // x1
  size_t v209; // x2
  __int64 v210; // x20
  _BYTE *v211; // x22
  unsigned __int64 v212; // x8
  const void *v213; // x1
  size_t v214; // x2
  size_t *v215; // x0
  void *v216; // x8
  __int128 v217; // q0
  char v218; // w22
  char *v219; // x8
  __int128 v220; // q0
  char *v221; // x20
  char *v222; // x1
  size_t v223; // x2
  unsigned __int8 *v224; // x22
  __int64 v225; // x22
  unsigned __int64 v226; // x8
  size_t *v227; // x0
  const void *v228; // x1
  size_t v229; // x2
  unsigned __int8 *v230; // x23
  __int64 v231; // x0
  __int64 v232; // x22
  __int64 v233; // x22
  unsigned __int64 v234; // x8
  const void *v235; // x1
  size_t v236; // x2
  __int64 v237; // x20
  _BYTE *v238; // x22
  __int64 v239; // x8
  void *v240; // x19
  char *v241; // x1
  size_t v242; // x2
  void *v243; // x0
  unsigned __int8 *v244; // x22
  unsigned __int64 v245; // x8
  char *v246; // x8
  __int128 v247; // q0
  __int64 v248; // x9
  __int64 v249; // x10
  char *v250; // x11
  char v251; // w8
  __int64 v252; // x8
  __int64 v253; // x9
  _BYTE *v254; // x22
  unsigned __int8 *v255; // x22
  __int64 v256; // x22
  unsigned __int64 v257; // x8
  size_t *v258; // x0
  const void *v259; // x1
  size_t v260; // x2
  unsigned __int8 *v261; // x22
  unsigned __int64 v262; // x8
  char *v263; // x8
  __int128 v264; // q0
  __int64 v265; // x8
  __int64 v266; // x9
  _BYTE *v267; // x23
  char v268; // w22
  __int64 v269; // x24
  _BYTE **v270; // x27
  __int64 v271; // x21
  _BYTE *v272; // x22
  __int64 v273; // x22
  unsigned __int64 v274; // x8
  const void *v275; // x1
  size_t v276; // x2
  char *v277; // x8
  __int128 v278; // q0
  __int64 v279; // x9
  __int64 v280; // x10
  char v281; // w8
  unsigned __int8 *v282; // x22
  char *v283; // x8
  __int128 v284; // q0
  __int64 v285; // x8
  unsigned __int64 v286; // x9
  size_t v287; // x10
  const void *v288; // x11
  size_t *v289; // x0
  const void *v290; // x8
  const void *v291; // x1
  size_t v292; // x2
  size_t *v293; // x0
  char v294; // w23
  void *v295; // x20
  char *v296; // x1
  size_t v297; // x2
  unsigned __int8 *v298; // x22
  char *v299; // x8
  __int128 v300; // q0
  __int64 v301; // x8
  unsigned __int64 v302; // x9
  size_t v303; // x10
  const void *v304; // x11
  size_t *v305; // x0
  const void *v306; // x8
  const void *v307; // x1
  size_t v308; // x2
  size_t *v309; // x0
  __int64 v310; // x8
  __int64 v311; // x9
  _BYTE *v312; // x27
  char v313; // w24
  __int64 v314; // x28
  _BYTE **v315; // x19
  unsigned __int64 v316; // x22
  __int64 v317; // x21
  unsigned __int64 v318; // x9
  unsigned __int64 v319; // x9
  __int64 v320; // x9
  char *v321; // x0
  unsigned __int8 *v322; // x23
  __int64 v323; // x0
  __int64 v324; // x22
  __int64 v325; // x22
  unsigned __int64 v326; // x8
  const void *v327; // x1
  size_t v328; // x2
  __int64 v329; // x22
  _BYTE *v330; // x20
  char v331; // w23
  size_t v332; // x22
  char *v333; // x0
  unsigned __int8 *v334; // x23
  unsigned __int8 *v335; // x0
  unsigned __int8 *v336; // x22
  __int64 v337; // x22
  unsigned __int64 v338; // x8
  const void *v339; // x1
  size_t v340; // x2
  __int64 v341; // x23
  _BYTE *v342; // x22
  unsigned __int64 v343; // x8
  size_t v344; // x22
  int v345; // w24
  char *v346; // x0
  unsigned __int8 *v347; // x23
  __int64 v348; // x0
  __int64 v349; // x22
  __int64 v350; // x22
  unsigned __int64 v351; // x8
  const void *v352; // x1
  size_t v353; // x2
  __int64 v354; // x22
  _BYTE *v355; // x23
  unsigned __int64 v356; // x8
  unsigned __int64 v357; // x8
  const void *v358; // x1
  size_t v359; // x2
  size_t *v360; // x0
  void *v361; // x8
  __int128 v362; // q0
  char *v363; // x8
  __int128 v364; // q0
  char v365; // w22
  char *v366; // x1
  size_t v367; // x2
  char *v368; // x8
  __int128 v369; // q0
  __int64 v370; // x9
  __int64 v371; // x10
  char *v372; // x11
  char v373; // w8
  __int64 v374; // x8
  __int64 v375; // x9
  int v376; // w19
  int v377; // w22
  __int64 v378; // x22
  unsigned __int64 v379; // x8
  const void *v380; // x1
  size_t v381; // x2
  char *v382; // x8
  __int128 v383; // q0
  __int64 v384; // x9
  __int64 v385; // x10
  char v386; // w8
  _BYTE *v387; // x21
  _BYTE *v388; // x21
  int v389; // w24
  unsigned __int8 *v390; // x0
  int v391; // w28
  unsigned __int8 *v392; // x22
  unsigned __int8 *v393; // x22
  unsigned __int8 *v394; // x0
  int v395; // w8
  unsigned __int8 *v396; // x22
  unsigned __int8 *v397; // x0
  char *v398; // x20
  char *v399; // x1
  char v400; // w24
  void *v401; // x8
  __int128 v402; // q0
  void *v403; // x22
  char *v404; // x1
  size_t v405; // x2
  char *v406; // x8
  __int128 v407; // q0
  __int64 v408; // x9
  __int64 v409; // x10
  char *v410; // x11
  char v411; // w8
  __int64 v412; // x8
  __int64 v413; // x9
  unsigned __int64 v414; // x8
  void *v415; // x0
  void *v416; // x22
  __int64 v417; // x22
  unsigned __int64 v418; // x8
  const void *v419; // x1
  size_t v420; // x2
  char *v421; // x8
  __int128 v422; // q0
  __int64 v423; // x9
  __int64 v424; // x10
  char *v425; // x11
  char v426; // w8
  __int64 v427; // x8
  __int64 v428; // x9
  char *v429; // x28
  char *v430; // x1
  char v431; // w27
  void *v432; // x22
  __int128 v433; // q0
  char *v434; // x1
  size_t v435; // x2
  __int128 v436; // q0
  char v437; // w28
  void *v438; // x23
  __int128 v439; // q0
  char *v440; // x1
  size_t v441; // x2
  void *v442; // x8
  __int128 v443; // q0
  __int64 v444; // x9
  __int64 v445; // x10
  char *v446; // x11
  char v447; // w8
  __int64 v448; // x8
  __int64 v449; // x9
  unsigned __int64 v450; // x8
  void *v451; // x0
  void *v452; // x23
  unsigned __int8 *v453; // x22
  __int64 v454; // x22
  unsigned __int64 v455; // x8
  const void *v456; // x1
  size_t v457; // x2
  char *v458; // x8
  __int128 v459; // q0
  __int64 v460; // x8
  unsigned __int64 v461; // x9
  size_t v462; // x10
  const void *v463; // x11
  size_t *v464; // x0
  const void *v465; // x8
  const void *v466; // x1
  size_t v467; // x2
  size_t *v468; // x0
  char v469; // w22
  char *v470; // x11
  char *v471; // x27
  char v472; // w10
  char *v473; // x21
  _BYTE *v474; // x0
  char *v475; // x8
  char *v476; // x9
  int v477; // w10
  __int64 v478; // x10
  __int64 v479; // x11
  unsigned __int64 v480; // x22
  char *v481; // x10
  __int64 v482; // x12
  void *v483; // x21
  __int64 v484; // x23
  void *v485; // x24
  unsigned __int64 v486; // x8
  _BYTE *v487; // x0
  void *v488; // x0
  unsigned __int64 v489; // x8
  size_t v490; // x20
  void *v491; // x0
  void *v492; // x19
  unsigned __int64 v493; // x8
  char *v494; // x1
  size_t v495; // x2
  size_t *v496; // x0
  char *v497; // x21
  char *v498; // x22
  unsigned __int64 v499; // x8
  char *v500; // x1
  size_t v501; // x2
  size_t *v502; // x0
  unsigned __int64 v503; // x27
  char *v504; // x11
  char *v505; // x21
  char v506; // w10
  char *v507; // x22
  unsigned __int64 v508; // x8
  size_t v509; // x24
  void *v510; // x0
  void *v511; // x23
  _BYTE *v512; // x0
  _BYTE *v513; // x0
  __int64 v514; // x8
  __int64 v515; // x8
  __int64 v516; // x0
  _BYTE *v517; // x23
  __int64 v518; // x24
  unsigned __int64 v519; // x8
  const void *v520; // x1
  size_t v521; // x2
  __int64 v522; // x28
  _BYTE *v523; // x24
  size_t v524; // x2
  char *v525; // x1
  int v526; // w24
  unsigned __int8 *v527; // x23
  unsigned __int8 *v528; // x0
  int v529; // w21
  unsigned __int8 *v530; // x19
  char *v531; // x1
  char *v532; // x1
  size_t v533; // x2
  size_t v534; // x22
  _WORD *v535; // x0
  int v536; // w19
  unsigned __int64 v537; // x23
  __int64 v538; // x21
  unsigned __int64 v539; // x8
  unsigned __int64 v540; // x8
  __int64 v541; // x9
  char *v542; // x0
  char *v543; // x9
  char *v544; // x1
  char *v545; // x1
  size_t v546; // x2
  char *v547; // x1
  __int128 v548; // q0
  char *v549; // x8
  char v550; // w21
  void *v551; // x22
  char *v552; // x1
  size_t v553; // x2
  char *v554; // x1
  size_t v555; // x2
  char v556; // w21
  size_t v557; // x22
  char *v558; // x0
  char *v559; // x1
  __int128 v560; // q0
  char *v561; // x8
  char v562; // w21
  void *v563; // x22
  char *v564; // x1
  size_t v565; // x2
  void *v566; // x22
  char v567; // w21
  __int64 v568; // x8
  __int64 v569; // x9
  unsigned __int64 v570; // x8
  unsigned __int64 v571; // x9
  unsigned __int64 v572; // x24
  __int64 v573; // x23
  unsigned __int64 v574; // x9
  unsigned __int64 v575; // x9
  __int64 v576; // x9
  char *v577; // x0
  unsigned __int64 v578; // x22
  __int64 v579; // x23
  unsigned __int64 v580; // x9
  unsigned __int64 v581; // x9
  __int64 v582; // x9
  char *v583; // x0
  unsigned __int64 v584; // x28
  __int64 v585; // x21
  __int64 v586; // x8
  unsigned __int64 v587; // x9
  size_t v588; // x10
  const void *v589; // x11
  size_t *v590; // x0
  const void *v591; // x8
  const void *v592; // x1
  size_t v593; // x2
  size_t *v594; // x0
  __int128 v595; // q0
  char *v596; // x8
  char v597; // w24
  void *v598; // x22
  char *v599; // x1
  size_t v600; // x2
  char *v601; // x8
  char *v602; // x9
  __int64 v603; // x11
  unsigned __int64 v604; // x22
  char *v605; // x10
  __int64 v606; // x12
  void *v607; // x21
  __int64 v608; // x23
  void *v609; // x24
  unsigned __int64 v610; // x8
  char *v611; // x10
  __int64 v612; // x11
  unsigned __int64 v613; // x23
  char *v614; // x8
  _OWORD *v615; // x9
  __int64 v616; // x12
  void *v617; // x21
  __int64 v618; // x24
  void *v619; // x27
  unsigned __int64 v620; // x8
  __int64 v621; // x22
  unsigned __int64 v622; // x8
  const void *v623; // x1
  size_t v624; // x2
  __int64 v625; // x20
  _BYTE *v626; // x22
  unsigned __int64 v627; // x8
  const void *v628; // x1
  size_t v629; // x2
  size_t *v630; // x0
  void *v631; // x8
  __int128 v632; // q0
  char *v633; // x8
  __int128 v634; // q0
  char *v635; // x8
  __int128 v636; // q0
  __int64 v637; // x9
  __int64 v638; // x10
  char *v639; // x11
  char v640; // w8
  __int64 v641; // x8
  __int64 v642; // x9
  char *v643; // x8
  __int64 v644; // x11
  unsigned __int64 v645; // x21
  char *v646; // x10
  __int64 v647; // x12
  void *v648; // x20
  __int64 v649; // x22
  void *v650; // x23
  unsigned __int64 v651; // x8
  char *v652; // [xsp+8h] [xbp-1E8h]
  char *v653; // [xsp+10h] [xbp-1E0h]
  size_t v654; // [xsp+18h] [xbp-1D8h]
  size_t v655; // [xsp+18h] [xbp-1D8h]
  int v656; // [xsp+18h] [xbp-1D8h]
  __int64 v657; // [xsp+20h] [xbp-1D0h]
  unsigned __int8 *v658; // [xsp+20h] [xbp-1D0h]
  unsigned __int64 v659; // [xsp+28h] [xbp-1C8h]
  void *v660; // [xsp+28h] [xbp-1C8h]
  void *v661; // [xsp+28h] [xbp-1C8h]
  void *v662; // [xsp+28h] [xbp-1C8h]
  char **v663; // [xsp+28h] [xbp-1C8h]
  void *v664; // [xsp+28h] [xbp-1C8h]
  void *v665; // [xsp+28h] [xbp-1C8h]
  __int128 v666; // [xsp+38h] [xbp-1B8h] BYREF
  void *v667; // [xsp+48h] [xbp-1A8h]
  __int128 v668; // [xsp+50h] [xbp-1A0h] BYREF
  void *v669; // [xsp+60h] [xbp-190h]
  __int128 v670; // [xsp+70h] [xbp-180h] BYREF
  void *v671; // [xsp+80h] [xbp-170h]
  _BYTE v672[48]; // [xsp+90h] [xbp-160h] BYREF
  _QWORD v673[2]; // [xsp+C0h] [xbp-130h]
  __int128 v674; // [xsp+D0h] [xbp-120h] BYREF
  void *v675; // [xsp+E0h] [xbp-110h]
  __int128 v676; // [xsp+F0h] [xbp-100h] BYREF
  void *p; // [xsp+100h] [xbp-F0h]
  __int128 v678; // [xsp+110h] [xbp-E0h] BYREF
  char *v679; // [xsp+120h] [xbp-D0h]
  __int128 v680; // [xsp+130h] [xbp-C0h] BYREF
  char *v681; // [xsp+140h] [xbp-B0h]
  __int128 v682; // [xsp+150h] [xbp-A0h] BYREF
  char *v683; // [xsp+160h] [xbp-90h]
  __int64 v684; // [xsp+168h] [xbp-88h]
  __int64 v685; // [xsp+170h] [xbp-80h]
  void *v686; // [xsp+178h] [xbp-78h]
  __int128 v687; // [xsp+180h] [xbp-70h] BYREF
  char *v688; // [xsp+190h] [xbp-60h]

  v4 = a1;
  v5 = a2 - a1;
  _ReadStatusReg(TPIDR_EL0);
  if ( a2 - a1 < 2 )
    return v4;
  if ( v5 < 4 )
  {
    v9 = 0;
    v10 = a1;
  }
  else
  {
    v7 = *a1;
    if ( v7 != 103 )
    {
      v9 = 0;
      v10 = a1;
      goto LABEL_10;
    }
    v8 = a1[1];
    v9 = v8 == 115;
    if ( v8 == 115 )
      v10 = a1 + 2;
    else
      v10 = a1;
  }
  v7 = *v10;
LABEL_10:
  switch ( v7 )
  {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return (unsigned __int8 *)sub_4F704(a1, a2, a3);
    case 'L':
      return sub_4CCE0(a1, a2, (unsigned __int64 *)a3);
    case 'T':
      return (unsigned __int8 *)sub_454F4(a1, a2, a3);
    case 'a':
      switch ( v10[1] )
      {
        case 'N':
          v12 = a1 + 2;
          v682 = 0x3D2604u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'S':
          v12 = a1 + 2;
          v682 = 0x3D02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'a':
          v12 = a1 + 2;
          v682 = 0x262604u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'd':
          v12 = a1 + 2;
          v682 = 0x2602u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'n':
          v12 = a1 + 2;
          v682 = 0x2602u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 't':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 97 )
            return v4;
          if ( a1[1] != 116 )
            return v4;
          v255 = a1 + 2;
          v21 = sub_38008(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v255 )
            return v4;
          v256 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v256 )
            return v4;
          v257 = *(unsigned __int8 *)(v256 - 24);
          v258 = (size_t *)(v256 - 48);
          if ( (v257 & 1) != 0 )
            v259 = *(const void **)(v256 - 8);
          else
            v259 = (const void *)(v256 - 23);
          if ( (v257 & 1) != 0 )
            v260 = *(_QWORD *)(v256 - 16);
          else
            v260 = v257 >> 1;
          break;
        case 'z':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 97 )
            return v4;
          if ( a1[1] != 122 )
            return v4;
          v261 = a1 + 2;
          v21 = sub_47B84(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v261 )
            return v4;
          v256 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v256 )
            return v4;
          v262 = *(unsigned __int8 *)(v256 - 24);
          v258 = (size_t *)(v256 - 48);
          if ( (v262 & 1) != 0 )
            v259 = *(const void **)(v256 - 8);
          else
            v259 = (const void *)(v256 - 23);
          if ( (v262 & 1) != 0 )
            v260 = *(_QWORD *)(v256 - 16);
          else
            v260 = v262 >> 1;
          break;
        default:
          return v4;
      }
      sub_42BE4(v258, v259, v260);
      v688 = *(char **)(v256 - 32);
      v687 = *(_OWORD *)(v256 - 48);
      *(_QWORD *)(v256 - 48) = 0;
      *(_QWORD *)(v256 - 40) = 0;
      *(_QWORD *)(v256 - 32) = 0;
      sub_429F4((size_t *)&v687, 0, "alignof (", 9u);
      v263 = v688;
      v264 = v687;
      v687 = 0u;
      v688 = 0;
      v683 = v263;
      v682 = v264;
      sub_42BE4((size_t *)&v682, ")", 1u);
      v265 = *(_QWORD *)((char *)&v682 + 1);
      v266 = *((_QWORD *)&v682 + 1);
      v267 = v683;
      v268 = v682;
      v682 = 0u;
      v683 = 0;
      *(_QWORD *)((char *)&v680 + 7) = v266;
      *(_QWORD *)&v680 = v265;
      v269 = *(_QWORD *)(a3 + 8);
      if ( (*(_BYTE *)(v269 - 48) & 1) != 0 )
      {
        v270 = (_BYTE **)(v269 - 32);
        **(_BYTE **)(v269 - 32) = 0;
        v489 = *(unsigned __int8 *)(v269 - 48);
        *(_QWORD *)(v269 - 40) = 0;
        if ( (v489 & 1) != 0 )
        {
          v512 = *v270;
          *(_BYTE *)(v269 - 47) = **v270;
          free(v512);
          *(_BYTE *)(v269 - 48) = 0;
        }
        else if ( (unsigned int)v489 >= 0x2E )
        {
          v664 = (void *)(v489 >> 1);
          v490 = (unsigned __int8)((v489 >> 1) + 16) & 0xF0;
          v491 = malloc(v490);
          v492 = v491;
          if ( v490 - 1 > 0x16 || v491 )
          {
            memcpy(v491, (const void *)(v269 - 47), (size_t)v664 + 1);
            *(_QWORD *)(v269 - 48) = v490 | 1;
            *(_QWORD *)(v269 - 40) = v664;
            *(_QWORD *)(v269 - 32) = v492;
          }
        }
      }
      else
      {
        *(_WORD *)(v269 - 48) = 0;
        v270 = (_BYTE **)(v269 - 32);
      }
      *(_BYTE *)(v269 - 48) = v268;
      *(_QWORD *)(v269 - 47) = v680;
      *(_QWORD *)(v269 - 40) = *(_QWORD *)((char *)&v680 + 7);
      *v270 = v267;
      *(_QWORD *)((char *)&v680 + 7) = 0;
      *(_QWORD *)&v680 = 0;
      if ( (v682 & 1) != 0 )
        free(v683);
LABEL_816:
      if ( (v687 & 1) == 0 )
        return (unsigned __int8 *)v21;
LABEL_817:
      v243 = v688;
      goto LABEL_818;
    case 'c':
      switch ( v10[1] )
      {
        case 'c':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 99 )
            return v4;
          if ( a1[1] != 99 )
            return v4;
          v39 = a1 + 2;
          v40 = sub_38008(a1 + 2, a2, a3);
          v41 = v40;
          if ( (unsigned __int8 *)v40 == v39 )
            return v4;
          v21 = sub_47B84(v40, a2, a3);
          if ( v21 == v41 )
            return v4;
          v42 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v42 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v43 = *(unsigned __int8 *)(v42 - 24);
          if ( (v43 & 1) != 0 )
            v44 = *(const void **)(v42 - 8);
          else
            v44 = (const void *)(v42 - 23);
          if ( (v43 & 1) != 0 )
            v45 = *(_QWORD *)(v42 - 16);
          else
            v45 = v43 >> 1;
          sub_42BE4((size_t *)(v42 - 48), v44, v45);
          v688 = *(char **)(v42 - 32);
          v687 = *(_OWORD *)(v42 - 48);
          *(_QWORD *)(v42 - 40) = 0;
          *(_QWORD *)(v42 - 32) = 0;
          *(_QWORD *)(v42 - 48) = 0;
          v46 = *(_QWORD *)(a3 + 8);
          v47 = (_BYTE *)(v46 - 48);
          if ( (*(_BYTE *)(v46 - 24) & 1) != 0 )
            free(*(void **)(v46 - 8));
          if ( (*v47 & 1) != 0 )
            free(*(void **)(v46 - 32));
          v48 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v47;
          if ( (_BYTE *)v48 != v47 )
          {
            v49 = *(unsigned __int8 *)(v46 - 72);
            if ( (v49 & 1) != 0 )
              v50 = *(const void **)(v46 - 56);
            else
              v50 = (const void *)(v46 - 71);
            if ( (v49 & 1) != 0 )
              v51 = *(_QWORD *)(v46 - 64);
            else
              v51 = v49 >> 1;
            v52 = sub_42BE4((size_t *)(v46 - 96), v50, v51);
            v675 = (void *)v52[2];
            v674 = *(_OWORD *)v52;
            *v52 = 0;
            v52[1] = 0;
            v52[2] = 0;
            sub_429F4((size_t *)&v674, 0, "const_cast<", 0xBu);
            v53 = v675;
            v54 = v674;
            v674 = 0u;
            v675 = 0;
            p = v53;
            v676 = v54;
            sub_42BE4((size_t *)&v676, ">(", 2u);
            v55 = (char *)p;
            v56 = v676;
            p = 0;
            v676 = 0u;
            v57 = v687;
            v679 = v55;
            if ( (v687 & 1) != 0 )
              v58 = v688;
            else
              v58 = (char *)&v687 + 1;
            v678 = v56;
            if ( (v687 & 1) != 0 )
              v59 = *((_QWORD *)&v687 + 1);
            else
              v59 = (unsigned __int64)(unsigned __int8)v687 >> 1;
            sub_42BE4((size_t *)&v678, v58, v59);
            v60 = v679;
            v61 = v678;
            v678 = 0u;
            v679 = 0;
            v681 = v60;
            v680 = v61;
            sub_42BE4((size_t *)&v680, ")", 1u);
            v62 = *(_QWORD *)((char *)&v680 + 1);
            v63 = *((_QWORD *)&v680 + 1);
            v64 = v681;
            v65 = v680;
            v680 = 0u;
            v681 = 0;
            *(_QWORD *)((char *)&v670 + 7) = v63;
            BYTE7(v670) = HIBYTE(v62);
            LOBYTE(v682) = v65;
            v66 = v62;
            v67 = *(_QWORD *)((char *)&v670 + 7);
            *(_QWORD *)((char *)&v670 + 7) = 0;
            *(_QWORD *)&v670 = 0;
            *(_QWORD *)((char *)&v682 + 1) = v66;
            *((_QWORD *)&v682 + 1) = v67;
            v683 = v64;
            v685 = 0;
            v686 = 0;
            v684 = 0;
            sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
            if ( (v684 & 1) != 0 )
            {
              free(v686);
              if ( (v682 & 1) == 0 )
              {
LABEL_91:
                if ( (v680 & 1) == 0 )
                  goto LABEL_92;
                goto LABEL_871;
              }
            }
            else if ( (v682 & 1) == 0 )
            {
              goto LABEL_91;
            }
            free(v683);
            if ( (v680 & 1) == 0 )
            {
LABEL_92:
              if ( (v678 & 1) == 0 )
                goto LABEL_93;
              goto LABEL_872;
            }
LABEL_871:
            free(v681);
            if ( (v678 & 1) == 0 )
            {
LABEL_93:
              if ( (v676 & 1) == 0 )
                goto LABEL_95;
              goto LABEL_94;
            }
LABEL_872:
            free(v679);
            if ( (v676 & 1) == 0 )
            {
LABEL_95:
              v68 = v57 & 1;
              if ( (v674 & 1) != 0 )
                free(v675);
              v69 = 0;
              if ( v68 )
                goto LABEL_98;
              goto LABEL_99;
            }
LABEL_94:
            free(p);
            goto LABEL_95;
          }
          v69 = 1;
          v21 = (__int64)v4;
          if ( (v687 & 1) != 0 )
LABEL_98:
            free(v688);
LABEL_99:
          if ( !v69 )
            return (unsigned __int8 *)v21;
          return v4;
        case 'l':
          if ( v5 < 4 )
            return v4;
          if ( *a1 != 99 )
            return v4;
          if ( a1[1] != 108 )
            return v4;
          v137 = a1 + 2;
          v138 = sub_47B84(a1 + 2, a2, a3);
          v139 = (_BYTE *)v138;
          if ( (unsigned __int8 *)v138 == v137 )
            return v4;
          if ( (unsigned __int8 *)v138 == a2 )
            return v4;
          v140 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v140 )
            return v4;
          v141 = *(unsigned __int8 *)(v140 - 24);
          v142 = *(_QWORD *)(v140 - 16);
          v143 = *(const void **)(v140 - 8);
          v144 = (size_t *)(v140 - 48);
          v145 = (const void *)(v140 - 23);
          if ( (v141 & 1) != 0 )
            v146 = v143;
          else
            v146 = v145;
          if ( (v141 & 1) != 0 )
            v147 = v142;
          else
            v147 = v141 >> 1;
          sub_42BE4(v144, v146, v147);
          *(_QWORD *)((char *)&v682 + 7) = 0;
          *(_QWORD *)&v682 = 0;
          v148 = *(_QWORD *)(a3 + 8);
          if ( (*(_BYTE *)(v148 - 24) & 1) != 0 )
          {
            **(_BYTE **)(v148 - 8) = 0;
            v508 = *(unsigned __int8 *)(v148 - 24);
            *(_QWORD *)(v148 - 16) = 0;
            if ( (v508 & 1) != 0 )
            {
              v513 = *(_BYTE **)(v148 - 8);
              *(_BYTE *)(v148 - 23) = *v513;
              free(v513);
              *(_BYTE *)(v148 - 24) = 0;
            }
            else if ( (unsigned int)v508 >= 0x2E )
            {
              v665 = (void *)(v508 >> 1);
              v509 = (unsigned __int8)((v508 >> 1) + 16) & 0xF0;
              v510 = malloc(v509);
              v511 = v510;
              if ( v509 - 1 > 0x16 || v510 )
              {
                memcpy(v510, (const void *)(v148 - 23), (size_t)v665 + 1);
                *(_QWORD *)(v148 - 24) = v509 | 1;
                *(_QWORD *)(v148 - 16) = v665;
                *(_QWORD *)(v148 - 8) = v511;
              }
            }
          }
          else
          {
            *(_WORD *)(v148 - 24) = 0;
          }
          *(_BYTE *)(v148 - 24) = 0;
          *(_QWORD *)(v148 - 16) = *(_QWORD *)((char *)&v682 + 7);
          v514 = v682;
          *(_QWORD *)(v148 - 8) = 0;
          *(_QWORD *)(v148 - 23) = v514;
          sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), "(", 1u);
          if ( *v139 == 69 )
            goto LABEL_822;
          while ( 2 )
          {
            v516 = sub_47B84(v139, a2, a3);
            v517 = (_BYTE *)v516;
            if ( (_BYTE *)v516 == v139 )
              return v4;
            if ( (unsigned __int8 *)v516 == a2 )
              return v4;
            v518 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v518 )
              return v4;
            v519 = *(unsigned __int8 *)(v518 - 24);
            if ( (v519 & 1) != 0 )
              v520 = *(const void **)(v518 - 8);
            else
              v520 = (const void *)(v518 - 23);
            if ( (v519 & 1) != 0 )
              v521 = *(_QWORD *)(v518 - 16);
            else
              v521 = v519 >> 1;
            sub_42BE4((size_t *)(v518 - 48), v520, v521);
            v683 = *(char **)(v518 - 32);
            v682 = *(_OWORD *)(v518 - 48);
            *(_QWORD *)(v518 - 40) = 0;
            *(_QWORD *)(v518 - 32) = 0;
            *(_QWORD *)(v518 - 48) = 0;
            v522 = *(_QWORD *)(a3 + 8);
            v523 = (_BYTE *)(v522 - 48);
            if ( (*(_BYTE *)(v522 - 24) & 1) != 0 )
              free(*(void **)(v522 - 8));
            if ( (*v523 & 1) != 0 )
              free(*(void **)(v522 - 32));
            *(_QWORD *)(a3 + 8) = v523;
            if ( (v682 & 1) != 0 )
              v524 = *((_QWORD *)&v682 + 1);
            else
              v524 = (unsigned __int64)(unsigned __int8)v682 >> 1;
            if ( !v524 )
              goto LABEL_846;
            if ( *(_BYTE **)a3 == v523 )
            {
              v526 = 1;
              if ( (v682 & 1) != 0 )
LABEL_847:
                free(v683);
            }
            else
            {
              if ( (v682 & 1) != 0 )
                v525 = v683;
              else
                v525 = (char *)&v682 + 1;
              sub_42BE4((size_t *)(v522 - 96), v525, v524);
LABEL_846:
              v526 = 0;
              v139 = v517;
              if ( (v682 & 1) != 0 )
                goto LABEL_847;
            }
            if ( v526 )
              return v4;
            if ( *v139 == 69 )
            {
LABEL_822:
              v515 = *(_QWORD *)(a3 + 8);
              if ( *(_QWORD *)a3 != v515 )
              {
                v4 = v139 + 1;
                sub_42BE4((size_t *)(v515 - 48), ")", 1u);
              }
              return v4;
            }
            continue;
          }
        case 'm':
          v12 = a1 + 2;
          v682 = 0x2C02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'o':
          v12 = a1 + 2;
          v682 = 0x7E02u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'v':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 99 )
            return v4;
          if ( a1[1] != 118 )
            return v4;
          v149 = *(_BYTE *)(a3 + 111);
          v150 = a1 + 2;
          *(_BYTE *)(a3 + 111) = 0;
          v151 = (unsigned __int8 *)sub_38008(a1 + 2, a2, a3);
          v152 = v151;
          *(_BYTE *)(a3 + 111) = v149;
          if ( v151 == v150 || v151 == a2 )
            return v4;
          if ( *v151 == 95 )
          {
            v153 = v151 + 1;
            if ( v151 + 1 == a2 )
              return v4;
            if ( *v153 == 69 )
            {
              v155 = *(_OWORD **)(a3 + 8);
              v154 = *(_QWORD *)(a3 + 16);
              if ( (unsigned __int64)v155 >= v154 )
              {
                v537 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v155 - *(_QWORD *)a3) >> 4);
                v538 = 0x555555555555555LL;
                if ( v537 + 1 > 0x555555555555555LL )
                  abort();
                v539 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v154 - *(_QWORD *)a3) >> 4);
                if ( v539 >= 0x2AAAAAAAAAAAAAALL
                  || ((v540 = 2 * v539, v540 >= v537 + 1) ? (v538 = v540) : (v538 = v537 + 1), v538) )
                {
                  v541 = *(_QWORD *)(a3 + 24);
                  v542 = *(char **)(v541 + 4096);
                  if ( v541 + 4096 - (__int64)v542 >= (unsigned __int64)(48 * v538) )
                    *(_QWORD *)(v541 + 4096) = &v542[48 * v538];
                  else
                    v542 = (char *)malloc(48 * v538);
                }
                else
                {
                  v542 = 0;
                }
                v611 = &v542[48 * v537];
                *((_OWORD *)v611 + 1) = 0u;
                *((_OWORD *)v611 + 2) = 0u;
                *(_OWORD *)v611 = 0u;
                v613 = *(_QWORD *)a3;
                v612 = *(_QWORD *)(a3 + 8);
                v614 = &v542[48 * v538];
                v615 = v611 + 48;
                if ( v612 == *(_QWORD *)a3 )
                {
                  v617 = *(void **)a3;
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v611 - 4) = *(_QWORD *)(v612 - 32);
                    *((_OWORD *)v611 - 3) = *(_OWORD *)(v612 - 48);
                    v616 = *(_QWORD *)(v612 - 8);
                    *(_QWORD *)(v612 - 40) = 0;
                    *(_QWORD *)(v612 - 32) = 0;
                    *(_QWORD *)(v612 - 48) = 0;
                    *((_QWORD *)v611 - 1) = v616;
                    *(_OWORD *)(v611 - 24) = *(_OWORD *)(v612 - 24);
                    *(_QWORD *)(v612 - 24) = 0;
                    *(_QWORD *)(v612 - 16) = 0;
                    *(_QWORD *)(v612 - 8) = 0;
                    v612 -= 48;
                    v611 -= 48;
                  }
                  while ( v613 != v612 );
                  v617 = *(void **)a3;
                  v613 = *(_QWORD *)(a3 + 8);
                }
                v618 = *(_QWORD *)(a3 + 16);
                *(_QWORD *)a3 = v611;
                *(_QWORD *)(a3 + 8) = v615;
                *(_QWORD *)(a3 + 16) = v614;
                if ( (void *)v613 != v617 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v613 - 24) & 1) != 0 )
                      free(*(void **)(v613 - 8));
                    v619 = (void *)(v613 - 48);
                    if ( (*(_BYTE *)(v613 - 48) & 1) != 0 )
                      free(*(void **)(v613 - 32));
                    v613 -= 48LL;
                  }
                  while ( v617 != v619 );
                }
                if ( v617 )
                {
                  v620 = *(_QWORD *)(a3 + 24);
                  if ( v620 + 4096 < (unsigned __int64)v617 || v620 > (unsigned __int64)v617 )
                  {
                    free(v617);
                  }
                  else if ( *(_QWORD *)(v620 + 4096) == v618 )
                  {
                    *(_QWORD *)(v620 + 4096) = v617;
                  }
                }
              }
              else
              {
                v155[1] = 0u;
                v155[2] = 0u;
                *v155 = 0u;
                *(_QWORD *)(a3 + 8) += 48LL;
              }
            }
            else
            {
              v527 = v151 + 1;
              do
              {
                v528 = (unsigned __int8 *)sub_47B84(v527, a2, a3);
                v153 = v528;
                if ( v528 == v527 || v528 == a2 )
                  return v4;
                v527 = v528;
              }
              while ( *v528 != 69 );
            }
            v21 = (__int64)(v153 + 1);
          }
          else
          {
            v21 = sub_47B84(v151, a2, a3);
            if ( (unsigned __int8 *)v21 == v152 )
              return v4;
          }
          v621 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v621 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v622 = *(unsigned __int8 *)(v621 - 24);
          if ( (v622 & 1) != 0 )
            v623 = *(const void **)(v621 - 8);
          else
            v623 = (const void *)(v621 - 23);
          if ( (v622 & 1) != 0 )
            v624 = *(_QWORD *)(v621 - 16);
          else
            v624 = v622 >> 1;
          sub_42BE4((size_t *)(v621 - 48), v623, v624);
          v688 = *(char **)(v621 - 32);
          v687 = *(_OWORD *)(v621 - 48);
          *(_QWORD *)(v621 - 40) = 0;
          *(_QWORD *)(v621 - 32) = 0;
          *(_QWORD *)(v621 - 48) = 0;
          v625 = *(_QWORD *)(a3 + 8);
          v626 = (_BYTE *)(v625 - 48);
          if ( (*(_BYTE *)(v625 - 24) & 1) != 0 )
            free(*(void **)(v625 - 8));
          if ( (*v626 & 1) != 0 )
            free(*(void **)(v625 - 32));
          *(_QWORD *)(a3 + 8) = v626;
          v627 = *(unsigned __int8 *)(v625 - 72);
          if ( (v627 & 1) != 0 )
            v628 = *(const void **)(v625 - 56);
          else
            v628 = (const void *)(v625 - 71);
          if ( (v627 & 1) != 0 )
            v629 = *(_QWORD *)(v625 - 64);
          else
            v629 = v627 >> 1;
          v630 = sub_42BE4((size_t *)(v625 - 96), v628, v629);
          v675 = (void *)v630[2];
          v674 = *(_OWORD *)v630;
          *v630 = 0;
          v630[1] = 0;
          v630[2] = 0;
          sub_429F4((size_t *)&v674, 0, "(", 1u);
          v631 = v675;
          v632 = v674;
          v674 = 0u;
          v675 = 0;
          p = v631;
          v676 = v632;
          sub_42BE4((size_t *)&v676, ")(", 2u);
          v218 = v687;
          v633 = (char *)p;
          v634 = v676;
          p = 0;
          v676 = 0u;
          v221 = v688;
          v679 = v633;
          if ( (v687 & 1) != 0 )
            v222 = v688;
          else
            v222 = (char *)&v687 + 1;
          v678 = v634;
          if ( (v687 & 1) != 0 )
            v223 = *((_QWORD *)&v687 + 1);
          else
            v223 = (unsigned __int64)(unsigned __int8)v687 >> 1;
          goto LABEL_1086;
        default:
          return v4;
      }
    case 'd':
      switch ( v10[1] )
      {
        case 'V':
          v12 = a1 + 2;
          v682 = 0x3D2F04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'a':
          v282 = v10 + 2;
          v21 = sub_47B84(v10 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v282 || *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            return v4;
          v687 = 0u;
          v688 = 0;
          if ( v9 )
          {
            LOBYTE(v687) = 4;
            *(_WORD *)((char *)&v687 + 1) = 14906;
            BYTE3(v687) = 0;
          }
          sub_42BE4((size_t *)&v687, "delete[] ", 9u);
          v283 = v688;
          v284 = v687;
          v687 = 0u;
          v688 = 0;
          v683 = v283;
          v682 = v284;
          v285 = *(_QWORD *)(a3 + 8);
          v286 = *(unsigned __int8 *)(v285 - 24);
          v287 = *(_QWORD *)(v285 - 16);
          v288 = *(const void **)(v285 - 8);
          v289 = (size_t *)(v285 - 48);
          v290 = (const void *)(v285 - 23);
          if ( (v286 & 1) != 0 )
            v291 = v288;
          else
            v291 = v290;
          if ( (v286 & 1) != 0 )
            v292 = v287;
          else
            v292 = v286 >> 1;
          v293 = sub_42BE4(v289, v291, v292);
          v681 = (char *)v293[2];
          v680 = *(_OWORD *)v293;
          v293[1] = 0;
          v293[2] = 0;
          *v293 = 0;
          v294 = v680;
          v295 = v681;
          if ( (v680 & 1) != 0 )
            v296 = v681;
          else
            v296 = (char *)&v680 + 1;
          if ( (v680 & 1) != 0 )
            v297 = *((_QWORD *)&v680 + 1);
          else
            v297 = (unsigned __int64)(unsigned __int8)v680 >> 1;
          goto LABEL_469;
        case 'c':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 100 )
            return v4;
          if ( a1[1] != 99 )
            return v4;
          v347 = a1 + 2;
          v348 = sub_38008(a1 + 2, a2, a3);
          v349 = v348;
          if ( (unsigned __int8 *)v348 == v347 )
            return v4;
          v21 = sub_47B84(v348, a2, a3);
          if ( v21 == v349 )
            return v4;
          v350 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v350 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v351 = *(unsigned __int8 *)(v350 - 24);
          if ( (v351 & 1) != 0 )
            v352 = *(const void **)(v350 - 8);
          else
            v352 = (const void *)(v350 - 23);
          if ( (v351 & 1) != 0 )
            v353 = *(_QWORD *)(v350 - 16);
          else
            v353 = v351 >> 1;
          sub_42BE4((size_t *)(v350 - 48), v352, v353);
          v688 = *(char **)(v350 - 32);
          v687 = *(_OWORD *)(v350 - 48);
          *(_QWORD *)(v350 - 40) = 0;
          *(_QWORD *)(v350 - 32) = 0;
          *(_QWORD *)(v350 - 48) = 0;
          v354 = *(_QWORD *)(a3 + 8);
          v355 = (_BYTE *)(v354 - 48);
          if ( (*(_BYTE *)(v354 - 24) & 1) != 0 )
            free(*(void **)(v354 - 8));
          if ( (*v355 & 1) != 0 )
            free(*(void **)(v354 - 32));
          v356 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v355;
          if ( (_BYTE *)v356 != v355 )
          {
            v357 = *(unsigned __int8 *)(v354 - 72);
            if ( (v357 & 1) != 0 )
              v358 = *(const void **)(v354 - 56);
            else
              v358 = (const void *)(v354 - 71);
            if ( (v357 & 1) != 0 )
              v359 = *(_QWORD *)(v354 - 64);
            else
              v359 = v357 >> 1;
            v360 = sub_42BE4((size_t *)(v354 - 96), v358, v359);
            v675 = (void *)v360[2];
            v674 = *(_OWORD *)v360;
            *v360 = 0;
            v360[1] = 0;
            v360[2] = 0;
            sub_429F4((size_t *)&v674, 0, "dynamic_cast<", 0xDu);
            v361 = v675;
            v362 = v674;
            v674 = 0u;
            v675 = 0;
            p = v361;
            v676 = v362;
            sub_42BE4((size_t *)&v676, ">(", 2u);
            v363 = (char *)p;
            v364 = v676;
            p = 0;
            v676 = 0u;
            v365 = v687;
            v679 = v363;
            if ( (v687 & 1) != 0 )
              v366 = v688;
            else
              v366 = (char *)&v687 + 1;
            v678 = v364;
            if ( (v687 & 1) != 0 )
              v367 = *((_QWORD *)&v687 + 1);
            else
              v367 = (unsigned __int64)(unsigned __int8)v687 >> 1;
            sub_42BE4((size_t *)&v678, v366, v367);
            v368 = v679;
            v369 = v678;
            v678 = 0u;
            v679 = 0;
            v681 = v368;
            v680 = v369;
            sub_42BE4((size_t *)&v680, ")", 1u);
            v370 = *(_QWORD *)((char *)&v680 + 1);
            v371 = *((_QWORD *)&v680 + 1);
            v372 = v681;
            v373 = v680;
            v680 = 0u;
            v681 = 0;
            *(_QWORD *)((char *)&v670 + 7) = v371;
            BYTE7(v670) = HIBYTE(v370);
            LOBYTE(v682) = v373;
            v374 = v370;
            v375 = *(_QWORD *)((char *)&v670 + 7);
            *(_QWORD *)((char *)&v670 + 7) = 0;
            *(_QWORD *)&v670 = 0;
            *(_QWORD *)((char *)&v682 + 1) = v374;
            *((_QWORD *)&v682 + 1) = v375;
            v683 = v372;
            v685 = 0;
            v686 = 0;
            v684 = 0;
            sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
            if ( (v684 & 1) != 0 )
            {
              free(v686);
              if ( (v682 & 1) == 0 )
              {
LABEL_555:
                if ( (v680 & 1) == 0 )
                  goto LABEL_556;
                goto LABEL_931;
              }
            }
            else if ( (v682 & 1) == 0 )
            {
              goto LABEL_555;
            }
            free(v683);
            if ( (v680 & 1) == 0 )
            {
LABEL_556:
              if ( (v678 & 1) == 0 )
                goto LABEL_557;
              goto LABEL_932;
            }
LABEL_931:
            free(v681);
            if ( (v678 & 1) == 0 )
            {
LABEL_557:
              if ( (v676 & 1) == 0 )
                goto LABEL_559;
              goto LABEL_558;
            }
LABEL_932:
            free(v679);
            if ( (v676 & 1) == 0 )
            {
LABEL_559:
              v376 = v365 & 1;
              if ( (v674 & 1) != 0 )
                free(v675);
              v377 = 0;
              if ( v376 )
                goto LABEL_562;
              goto LABEL_563;
            }
LABEL_558:
            free(p);
            goto LABEL_559;
          }
          v377 = 1;
          v21 = (__int64)v4;
          if ( (v687 & 1) != 0 )
LABEL_562:
            free(v688);
LABEL_563:
          if ( !v377 )
            return (unsigned __int8 *)v21;
          return v4;
        case 'e':
          v12 = a1 + 2;
          v682 = 0x2A02u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'l':
          v298 = v10 + 2;
          v21 = sub_47B84(v10 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v298 || *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            return v4;
          v687 = 0u;
          v688 = 0;
          if ( v9 )
          {
            LOBYTE(v687) = 4;
            *(_WORD *)((char *)&v687 + 1) = 14906;
            BYTE3(v687) = 0;
          }
          sub_42BE4((size_t *)&v687, "delete ", 7u);
          v299 = v688;
          v300 = v687;
          v687 = 0u;
          v688 = 0;
          v683 = v299;
          v682 = v300;
          v301 = *(_QWORD *)(a3 + 8);
          v302 = *(unsigned __int8 *)(v301 - 24);
          v303 = *(_QWORD *)(v301 - 16);
          v304 = *(const void **)(v301 - 8);
          v305 = (size_t *)(v301 - 48);
          v306 = (const void *)(v301 - 23);
          if ( (v302 & 1) != 0 )
            v307 = v304;
          else
            v307 = v306;
          if ( (v302 & 1) != 0 )
            v308 = v303;
          else
            v308 = v302 >> 1;
          v309 = sub_42BE4(v305, v307, v308);
          v681 = (char *)v309[2];
          v680 = *(_OWORD *)v309;
          v309[1] = 0;
          v309[2] = 0;
          *v309 = 0;
          v294 = v680;
          v295 = v681;
          if ( (v680 & 1) != 0 )
            v296 = v681;
          else
            v296 = (char *)&v680 + 1;
          if ( (v680 & 1) != 0 )
            v297 = *((_QWORD *)&v680 + 1);
          else
            v297 = (unsigned __int64)(unsigned __int8)v680 >> 1;
LABEL_469:
          sub_42BE4((size_t *)&v682, v296, v297);
          v310 = *(_QWORD *)((char *)&v682 + 1);
          v311 = *((_QWORD *)&v682 + 1);
          v312 = v683;
          v313 = v682;
          v682 = 0u;
          v683 = 0;
          *(_QWORD *)((char *)&v678 + 7) = v311;
          *(_QWORD *)&v678 = v310;
          v314 = *(_QWORD *)(a3 + 8);
          if ( (*(_BYTE *)(v314 - 48) & 1) != 0 )
          {
            v315 = (_BYTE **)(v314 - 32);
            **(_BYTE **)(v314 - 32) = 0;
            v414 = *(unsigned __int8 *)(v314 - 48);
            *(_QWORD *)(v314 - 40) = 0;
            if ( (v414 & 1) != 0 )
            {
              v474 = *v315;
              *(_BYTE *)(v314 - 47) = **v315;
              free(v474);
              *(_BYTE *)(v314 - 48) = 0;
            }
            else if ( (unsigned int)v414 >= 0x2E )
            {
              v660 = (void *)(v414 >> 1);
              v654 = (unsigned __int8)((v414 >> 1) + 16) & 0xF0;
              v415 = malloc(v654);
              if ( v654 - 1 > 0x16 || v415 )
              {
                v416 = v415;
                memcpy(v415, (const void *)(v314 - 47), (size_t)v660 + 1);
                *(_QWORD *)(v314 - 48) = v654 | 1;
                *(_QWORD *)(v314 - 40) = v660;
                *(_QWORD *)(v314 - 32) = v416;
              }
            }
          }
          else
          {
            *(_WORD *)(v314 - 48) = 0;
            v315 = (_BYTE **)(v314 - 32);
          }
          *(_BYTE *)(v314 - 48) = v313;
          *(_QWORD *)(v314 - 47) = v678;
          *(_QWORD *)(v314 - 40) = *(_QWORD *)((char *)&v678 + 7);
          *v315 = v312;
          *(_QWORD *)((char *)&v678 + 7) = 0;
          *(_QWORD *)&v678 = 0;
          if ( (v294 & 1) != 0 )
          {
            free(v295);
            if ( (v682 & 1) == 0 )
              goto LABEL_816;
          }
          else if ( (v682 & 1) == 0 )
          {
            goto LABEL_816;
          }
          free(v683);
          if ( (v687 & 1) == 0 )
            return (unsigned __int8 *)v21;
          goto LABEL_817;
        case 'n':
          return (unsigned __int8 *)sub_4F704(a1, a2, a3);
        case 's':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 100 )
            return v4;
          if ( a1[1] != 115 )
            return v4;
          v322 = a1 + 2;
          v323 = sub_47B84(a1 + 2, a2, a3);
          v324 = v323;
          if ( (unsigned __int8 *)v323 == v322 )
            return v4;
          v21 = sub_47B84(v323, a2, a3);
          if ( v21 == v324 )
            return v4;
          v325 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v325 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v326 = *(unsigned __int8 *)(v325 - 24);
          if ( (v326 & 1) != 0 )
            v327 = *(const void **)(v325 - 8);
          else
            v327 = (const void *)(v325 - 23);
          if ( (v326 & 1) != 0 )
            v328 = *(_QWORD *)(v325 - 16);
          else
            v328 = v326 >> 1;
          sub_42BE4((size_t *)(v325 - 48), v327, v328);
          v683 = *(char **)(v325 - 32);
          v682 = *(_OWORD *)(v325 - 48);
          *(_QWORD *)(v325 - 40) = 0;
          *(_QWORD *)(v325 - 32) = 0;
          *(_QWORD *)(v325 - 48) = 0;
          v329 = *(_QWORD *)(a3 + 8);
          v330 = (_BYTE *)(v329 - 48);
          if ( (*(_BYTE *)(v329 - 24) & 1) != 0 )
            free(*(void **)(v329 - 8));
          if ( (*v330 & 1) != 0 )
            free(*(void **)(v329 - 32));
          *(_QWORD *)(a3 + 8) = v330;
          v331 = v682;
          v687 = 0u;
          v688 = 0;
          if ( (v682 & 1) != 0 )
            v332 = *((_QWORD *)&v682 + 1);
          else
            v332 = (unsigned __int64)(unsigned __int8)v682 >> 1;
          if ( v332 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          if ( v332 + 2 > 0x16 )
          {
            v333 = (char *)malloc((v332 + 18) & 0xFFFFFFFFFFFFFFF0LL);
            *(_QWORD *)&v687 = (v332 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1;
            *((_QWORD *)&v687 + 1) = 2;
            v688 = v333;
          }
          else
          {
            LOBYTE(v687) = 4;
            v333 = (char *)&v687 + 1;
          }
          v221 = v683;
          *(_WORD *)v333 = 10798;
          if ( (v331 & 1) != 0 )
            v531 = v221;
          else
            v531 = (char *)&v682 + 1;
          v333[2] = 0;
          sub_42BE4((size_t *)&v687, v531, v332);
          if ( (v687 & 1) != 0 )
            v532 = v688;
          else
            v532 = (char *)&v687 + 1;
          if ( (v687 & 1) != 0 )
            v533 = *((_QWORD *)&v687 + 1);
          else
            v533 = (unsigned __int64)(unsigned __int8)v687 >> 1;
          sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v532, v533);
          if ( (v687 & 1) != 0 )
            free(v688);
          if ( (v331 & 1) == 0 )
            return (unsigned __int8 *)v21;
          goto LABEL_1100;
        case 't':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 100 )
            return v4;
          if ( a1[1] != 116 )
            return v4;
          v334 = a1 + 2;
          v335 = (unsigned __int8 *)sub_47B84(a1 + 2, a2, a3);
          v336 = v335;
          if ( v335 == v334 )
            return v4;
          v21 = sub_4F704(v335, a2, a3);
          if ( (unsigned __int8 *)v21 == v336 )
            return v4;
          v337 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v337 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v338 = *(unsigned __int8 *)(v337 - 24);
          if ( (v338 & 1) != 0 )
            v339 = *(const void **)(v337 - 8);
          else
            v339 = (const void *)(v337 - 23);
          if ( (v338 & 1) != 0 )
            v340 = *(_QWORD *)(v337 - 16);
          else
            v340 = v338 >> 1;
          sub_42BE4((size_t *)(v337 - 48), v339, v340);
          v683 = *(char **)(v337 - 32);
          v682 = *(_OWORD *)(v337 - 48);
          *(_QWORD *)(v337 - 40) = 0;
          *(_QWORD *)(v337 - 32) = 0;
          *(_QWORD *)(v337 - 48) = 0;
          v341 = *(_QWORD *)(a3 + 8);
          v342 = (_BYTE *)(v341 - 48);
          if ( (*(_BYTE *)(v341 - 24) & 1) != 0 )
            free(*(void **)(v341 - 8));
          if ( (*v342 & 1) != 0 )
            free(*(void **)(v341 - 32));
          v343 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v342;
          if ( (_BYTE *)v343 == v342 )
          {
            v536 = 1;
            v21 = (__int64)v4;
            if ( (v682 & 1) == 0 )
              goto LABEL_927;
            goto LABEL_926;
          }
          v687 = 0u;
          v688 = 0;
          if ( (v682 & 1) != 0 )
            v344 = *((_QWORD *)&v682 + 1);
          else
            v344 = (unsigned __int64)(unsigned __int8)v682 >> 1;
          v345 = v682 & 1;
          if ( v344 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          if ( v344 + 1 > 0x16 )
          {
            v346 = (char *)malloc((v344 + 17) & 0xFFFFFFFFFFFFFFF0LL);
            *(_QWORD *)&v687 = (v344 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
            *((_QWORD *)&v687 + 1) = 1;
            v688 = v346;
          }
          else
          {
            LOBYTE(v687) = 2;
            v346 = (char *)&v687 + 1;
          }
          v543 = v683;
          *(_WORD *)v346 = 46;
          if ( v345 )
            v544 = v543;
          else
            v544 = (char *)&v682 + 1;
          sub_42BE4((size_t *)&v687, v544, v344);
          if ( (v687 & 1) != 0 )
            v545 = v688;
          else
            v545 = (char *)&v687 + 1;
          if ( (v687 & 1) != 0 )
            v546 = *((_QWORD *)&v687 + 1);
          else
            v546 = (unsigned __int64)(unsigned __int8)v687 >> 1;
          sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v545, v546);
          if ( (v687 & 1) != 0 )
            free(v688);
          v536 = 0;
          if ( v345 )
LABEL_926:
            free(v683);
LABEL_927:
          if ( !v536 )
            return (unsigned __int8 *)v21;
          return v4;
        case 'v':
          v12 = a1 + 2;
          v682 = 0x2F02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        default:
          return v4;
      }
    case 'e':
      v70 = v10[1];
      switch ( v70 )
      {
        case 'O':
          v12 = a1 + 2;
          v682 = 0x3D5E04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          break;
        case 'q':
          v12 = a1 + 2;
          v682 = 0x3D3D04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          break;
        case 'o':
          v12 = a1 + 2;
          v682 = 0x5E02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          break;
        default:
          return v4;
      }
      goto LABEL_567;
    case 'f':
      return sub_4E518(a1, a2, (void **)a3);
    case 'g':
      v38 = v10[1];
      if ( v38 == 116 )
      {
        v12 = a1 + 2;
        v682 = 0x3E02u;
        v683 = 0;
        v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
      }
      else
      {
        if ( v38 != 101 )
          return v4;
        v12 = a1 + 2;
        v682 = 0x3D3E04u;
        v683 = 0;
        v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
      }
LABEL_567:
      if ( (unsigned __int8 *)v13 != v12 )
        return (unsigned __int8 *)v13;
      return v4;
    case 'i':
      if ( v10[1] != 120 )
        return v4;
      v18 = a1 + 2;
      v19 = sub_47B84(a1 + 2, a2, a3);
      v20 = v19;
      if ( (unsigned __int8 *)v19 == v18 )
        return v4;
      v21 = sub_47B84(v19, a2, a3);
      if ( v21 != v20 )
      {
        v22 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v22 - *(_QWORD *)a3) >> 4) < 2 )
          return v4;
        v23 = *(unsigned __int8 *)(v22 - 24);
        if ( (v23 & 1) != 0 )
          v24 = *(const void **)(v22 - 8);
        else
          v24 = (const void *)(v22 - 23);
        if ( (v23 & 1) != 0 )
          v25 = *(_QWORD *)(v22 - 16);
        else
          v25 = v23 >> 1;
        sub_42BE4((size_t *)(v22 - 48), v24, v25);
        v688 = *(char **)(v22 - 32);
        v687 = *(_OWORD *)(v22 - 48);
        *(_QWORD *)(v22 - 40) = 0;
        *(_QWORD *)(v22 - 32) = 0;
        *(_QWORD *)(v22 - 48) = 0;
        v26 = *(_QWORD *)(a3 + 8);
        v27 = (_BYTE *)(v26 - 48);
        if ( (*(_BYTE *)(v26 - 24) & 1) != 0 )
          free(*(void **)(v26 - 8));
        if ( (*v27 & 1) != 0 )
          free(*(void **)(v26 - 32));
        *(_QWORD *)(a3 + 8) = v27;
        v28 = *(unsigned __int8 *)(v26 - 72);
        if ( (v28 & 1) != 0 )
          v29 = *(const void **)(v26 - 56);
        else
          v29 = (const void *)(v26 - 71);
        if ( (v28 & 1) != 0 )
          v30 = *(_QWORD *)(v26 - 64);
        else
          v30 = v28 >> 1;
        v31 = sub_42BE4((size_t *)(v26 - 96), v29, v30);
        v681 = (char *)v31[2];
        v680 = *(_OWORD *)v31;
        *v31 = 0;
        v31[1] = 0;
        v31[2] = 0;
        v32 = v680;
        v674 = 0u;
        v675 = 0;
        if ( (v680 & 1) != 0 )
          v33 = *((_QWORD *)&v680 + 1);
        else
          v33 = (unsigned __int64)(unsigned __int8)v680 >> 1;
        if ( v33 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        if ( v33 + 1 > 0x16 )
        {
          v34 = malloc((v33 + 17) & 0xFFFFFFFFFFFFFFF0LL);
          *(_QWORD *)&v674 = (v33 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
          *((_QWORD *)&v674 + 1) = 1;
          v675 = v34;
        }
        else
        {
          LOBYTE(v674) = 2;
          v34 = (_WORD *)((char *)&v674 + 1);
        }
        v398 = v681;
        *v34 = 40;
        if ( (v32 & 1) != 0 )
          v399 = v398;
        else
          v399 = (char *)&v680 + 1;
        sub_42BE4((size_t *)&v674, v399, v33);
        sub_42BE4((size_t *)&v674, ")[", 2u);
        v400 = v687;
        v401 = v675;
        v402 = v674;
        v675 = 0;
        v674 = 0u;
        v403 = v688;
        p = v401;
        if ( (v687 & 1) != 0 )
          v404 = v688;
        else
          v404 = (char *)&v687 + 1;
        v676 = v402;
        if ( (v687 & 1) != 0 )
          v405 = *((_QWORD *)&v687 + 1);
        else
          v405 = (unsigned __int64)(unsigned __int8)v687 >> 1;
        sub_42BE4((size_t *)&v676, v404, v405);
        v406 = (char *)p;
        v407 = v676;
        v676 = 0u;
        p = 0;
        v679 = v406;
        v678 = v407;
        sub_42BE4((size_t *)&v678, "]", 1u);
        v408 = *(_QWORD *)((char *)&v678 + 1);
        v409 = *((_QWORD *)&v678 + 1);
        v410 = v679;
        v411 = v678;
        v678 = 0u;
        v679 = 0;
        *(_QWORD *)((char *)v673 + 7) = v409;
        HIBYTE(v673[0]) = HIBYTE(v408);
        LOBYTE(v682) = v411;
        v412 = v408;
        v413 = *(_QWORD *)((char *)v673 + 7);
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        *(_QWORD *)((char *)&v682 + 1) = v412;
        *((_QWORD *)&v682 + 1) = v413;
        v683 = v410;
        v685 = 0;
        v686 = 0;
        v684 = 0;
        sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
        if ( (v684 & 1) != 0 )
        {
          free(v686);
          if ( (v682 & 1) == 0 )
          {
LABEL_624:
            if ( (v678 & 1) == 0 )
              goto LABEL_625;
            goto LABEL_636;
          }
        }
        else if ( (v682 & 1) == 0 )
        {
          goto LABEL_624;
        }
        free(v683);
        if ( (v678 & 1) == 0 )
        {
LABEL_625:
          if ( (v676 & 1) == 0 )
            goto LABEL_626;
          goto LABEL_637;
        }
LABEL_636:
        free(v679);
        if ( (v676 & 1) == 0 )
        {
LABEL_626:
          if ( (v674 & 1) == 0 )
            goto LABEL_627;
          goto LABEL_638;
        }
LABEL_637:
        free(p);
        if ( (v674 & 1) == 0 )
        {
LABEL_627:
          if ( (v32 & 1) == 0 )
            goto LABEL_628;
          goto LABEL_639;
        }
LABEL_638:
        free(v675);
        if ( (v32 & 1) == 0 )
        {
LABEL_628:
          if ( (v400 & 1) == 0 )
            return (unsigned __int8 *)v21;
LABEL_640:
          v243 = v403;
          goto LABEL_818;
        }
LABEL_639:
        free(v398);
        if ( (v400 & 1) == 0 )
          return (unsigned __int8 *)v21;
        goto LABEL_640;
      }
      v271 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 != v271 )
        goto LABEL_423;
      return v4;
    case 'l':
      switch ( v10[1] )
      {
        case 'S':
          v12 = a1 + 2;
          v682 = 0x3D3C3C06u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'e':
          v12 = a1 + 2;
          v682 = 0x3D3C04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 's':
          v12 = a1 + 2;
          v682 = 0x3C3C04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 't':
          v12 = a1 + 2;
          v682 = 0x3C02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        default:
          return v4;
      }
      return v4;
    case 'm':
      switch ( v10[1] )
      {
        case 'I':
          v12 = a1 + 2;
          v682 = 0x3D2D04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'L':
          v12 = a1 + 2;
          v682 = 0x3D2A04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'i':
          v12 = a1 + 2;
          v682 = 0x2D02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'l':
          v12 = a1 + 2;
          v682 = 0x2A02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'm':
          v187 = a1 + 2;
          if ( a1 + 2 != a2 && *v187 == 95 )
          {
            v12 = a1 + 3;
            v682 = 0x2D2D04u;
            v683 = 0;
            v13 = sub_4F434((__int64)(a1 + 3), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
            goto LABEL_567;
          }
          v21 = sub_47B84(a1 + 2, a2, a3);
          if ( (_BYTE *)v21 == v187 )
            return v4;
          v273 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v273 )
            return v4;
          v274 = *(unsigned __int8 *)(v273 - 24);
          if ( (v274 & 1) != 0 )
            v275 = *(const void **)(v273 - 8);
          else
            v275 = (const void *)(v273 - 23);
          if ( (v274 & 1) != 0 )
            v276 = *(_QWORD *)(v273 - 16);
          else
            v276 = v274 >> 1;
          sub_42BE4((size_t *)(v273 - 48), v275, v276);
          v681 = *(char **)(v273 - 32);
          v680 = *(_OWORD *)(v273 - 48);
          *(_QWORD *)(v273 - 48) = 0;
          *(_QWORD *)(v273 - 40) = 0;
          *(_QWORD *)(v273 - 32) = 0;
          sub_429F4((size_t *)&v680, 0, "(", 1u);
          v277 = v681;
          v278 = v680;
          v680 = 0u;
          v681 = 0;
          v688 = v277;
          v687 = v278;
          sub_42BE4((size_t *)&v687, ")--", 3u);
          v279 = *(_QWORD *)((char *)&v687 + 1);
          v280 = *((_QWORD *)&v687 + 1);
          v250 = v688;
          v281 = v687;
          v687 = 0u;
          v688 = 0;
          *(_QWORD *)&v672[39] = v280;
          v672[39] = HIBYTE(v279);
          LOBYTE(v682) = v281;
          v252 = v279;
          v253 = *(_QWORD *)&v672[39];
          memset(&v672[32], 0, 15);
          break;
        default:
          return v4;
      }
      goto LABEL_579;
    case 'n':
      switch ( v10[1] )
      {
        case 'a':
        case 'w':
          if ( v5 < 4 )
            return v4;
          v35 = *a1;
          if ( v35 == 103 )
          {
            v36 = a1 + 2;
            if ( a1[1] != 115 )
              v36 = a1;
            v37 = a1[1] == 115;
            if ( *v36 != 110 )
              return v4;
          }
          else
          {
            v37 = 0;
            v36 = a1;
            if ( v35 != 110 )
              return v4;
          }
          v389 = v36[1];
          if ( v389 != 119 && v389 != 97 )
            return v4;
          v390 = v36 + 2;
          if ( v36 + 2 == a2 )
            return v4;
          if ( *v390 == 95 )
          {
            v391 = 0;
          }
          else
          {
            do
            {
              v392 = v390;
              v390 = (unsigned __int8 *)sub_47B84(v390, a2, a3);
              if ( v390 == v392 || v390 == a2 )
                return v4;
            }
            while ( *v390 != 95 );
            v391 = 1;
          }
          v393 = v390 + 1;
          v394 = (unsigned __int8 *)sub_38008(v390 + 1, a2, a3);
          if ( v394 == v393 || v394 == a2 )
            return v4;
          v395 = *v394;
          if ( a2 - v394 >= 3 && v395 == 112 )
          {
            if ( v394[1] != 105 )
              return v4;
            v396 = v394 + 2;
            if ( v394[2] == 69 )
            {
              v397 = v394 + 2;
            }
            else
            {
              do
              {
                v397 = (unsigned __int8 *)sub_47B84(v396, a2, a3);
                if ( v397 == v396 || v397 == a2 )
                  return v4;
                v396 = v397;
              }
              while ( *v397 != 69 );
            }
            v658 = v397;
            v683 = 0;
            v682 = 0u;
            v460 = *(_QWORD *)(a3 + 8);
            v663 = (char **)(a3 + 8);
            if ( *(_QWORD *)a3 == v460 )
              return v4;
            v461 = *(unsigned __int8 *)(v460 - 24);
            v462 = *(_QWORD *)(v460 - 16);
            v463 = *(const void **)(v460 - 8);
            v464 = (size_t *)(v460 - 48);
            v465 = (const void *)(v460 - 23);
            if ( (v461 & 1) != 0 )
              v466 = v463;
            else
              v466 = v465;
            if ( (v461 & 1) != 0 )
              v467 = v462;
            else
              v467 = v461 >> 1;
            v468 = sub_42BE4(v464, v466, v467);
            v469 = *(_BYTE *)v468;
            *(_QWORD *)((char *)&v687 + 7) = v468[1];
            *(_QWORD *)&v687 = *(size_t *)((char *)v468 + 1);
            *v468 = 0;
            v468[1] = 0;
            v470 = (char *)v468[2];
            v468[2] = 0;
            v471 = *v663;
            v653 = v470;
            v472 = *(*v663 - 24);
            v473 = *v663 - 48;
            LOBYTE(v682) = v469;
            *(_QWORD *)((char *)&v682 + 1) = v687;
            *((_QWORD *)&v682 + 1) = *(_QWORD *)((char *)&v687 + 7);
            v683 = v470;
            if ( (v472 & 1) != 0 )
              free(*((void **)v471 - 1));
            if ( (*v473 & 1) != 0 )
              free(*((void **)v471 - 4));
            *(_QWORD *)(a3 + 8) = v473;
            v656 = 1;
          }
          else
          {
            if ( v395 != 69 )
              return v4;
            v658 = v394;
            v653 = 0;
            v683 = 0;
            v682 = 0u;
            v473 = *(char **)(a3 + 8);
            v469 = 0;
            v656 = 0;
            v663 = (char **)(a3 + 8);
          }
          if ( *(char **)a3 == v473 )
          {
            v529 = 1;
            v530 = v4;
            if ( (v469 & 1) == 0 )
            {
LABEL_1041:
              if ( !v529 )
                return v530;
              return v4;
            }
LABEL_1040:
            free(v683);
            goto LABEL_1041;
          }
          v493 = (unsigned __int8)*(v473 - 24);
          if ( (v493 & 1) != 0 )
            v494 = (char *)*((_QWORD *)v473 - 1);
          else
            v494 = v473 - 23;
          if ( (v493 & 1) != 0 )
            v495 = *((_QWORD *)v473 - 2);
          else
            v495 = v493 >> 1;
          v496 = sub_42BE4((size_t *)v473 - 6, v494, v495);
          v688 = (char *)v496[2];
          v687 = *(_OWORD *)v496;
          v496[1] = 0;
          v496[2] = 0;
          *v496 = 0;
          v497 = *v663;
          v498 = *v663 - 48;
          if ( (*(*v663 - 24) & 1) != 0 )
            free(*((void **)v497 - 1));
          if ( (*v498 & 1) != 0 )
            free(*((void **)v497 - 4));
          *v663 = v498;
          v680 = 0u;
          v681 = 0;
          if ( v391 )
          {
            if ( *(char **)a3 == v498 )
            {
              v529 = 1;
              v530 = v4;
              if ( (v687 & 1) != 0 )
LABEL_1038:
                free(v688);
LABEL_1039:
              if ( (v682 & 1) == 0 )
                goto LABEL_1041;
              goto LABEL_1040;
            }
            v499 = (unsigned __int8)*(v497 - 72);
            if ( (v499 & 1) != 0 )
              v500 = (char *)*((_QWORD *)v497 - 7);
            else
              v500 = v497 - 71;
            if ( (v499 & 1) != 0 )
              v501 = *((_QWORD *)v497 - 8);
            else
              v501 = v499 >> 1;
            v502 = sub_42BE4((size_t *)v497 - 12, v500, v501);
            v503 = *(unsigned __int8 *)v502;
            *(_QWORD *)((char *)&v678 + 7) = v502[1];
            *(_QWORD *)&v678 = *(size_t *)((char *)v502 + 1);
            *v502 = 0;
            v502[1] = 0;
            v504 = (char *)v502[2];
            v502[2] = 0;
            v505 = *v663;
            v652 = v504;
            v506 = *(*v663 - 24);
            v507 = *v663 - 48;
            LOBYTE(v680) = v503;
            *(_QWORD *)((char *)&v680 + 1) = v678;
            *((_QWORD *)&v680 + 1) = *(_QWORD *)((char *)&v678 + 7);
            v681 = v504;
            if ( (v506 & 1) != 0 )
              free(*((void **)v505 - 1));
            if ( (*v507 & 1) != 0 )
              free(*((void **)v505 - 4));
            *v663 = v507;
          }
          else
          {
            v652 = 0;
            v503 = 0;
          }
          v678 = 0u;
          v679 = 0;
          if ( v37 )
            sub_47A3C((size_t *)&v678, "::", 2u);
          if ( v389 == 97 )
            sub_42BE4((size_t *)&v678, "[] ", 3u);
          else
            sub_42BE4((size_t *)&v678, " ", 1u);
          if ( v391 )
          {
            v674 = 0u;
            if ( (v503 & 1) != 0 )
              v534 = *((_QWORD *)&v680 + 1);
            else
              v534 = v503 >> 1;
            v675 = 0;
            if ( v534 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v534 + 1 > 0x16 )
            {
              v535 = malloc((v534 + 17) & 0xFFFFFFFFFFFFFFF0LL);
              *(_QWORD *)&v674 = (v534 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
              *((_QWORD *)&v674 + 1) = 1;
              v675 = v535;
            }
            else
            {
              LOBYTE(v674) = 2;
              v535 = (_WORD *)((char *)&v674 + 1);
            }
            *v535 = 40;
            if ( (v503 & 1) != 0 )
              v547 = v652;
            else
              v547 = (char *)&v680 + 1;
            sub_42BE4((size_t *)&v674, v547, v534);
            sub_42BE4((size_t *)&v674, ") ", 2u);
            v548 = v674;
            v549 = (char *)v675;
            v675 = 0;
            v674 = 0u;
            v676 = v548;
            v550 = v548;
            p = v549;
            v551 = v549;
            if ( (v548 & 1) != 0 )
              v552 = v549;
            else
              v552 = (char *)&v676 + 1;
            if ( (v676 & 1) != 0 )
              v553 = *((_QWORD *)&v676 + 1);
            else
              v553 = (unsigned __int64)(unsigned __int8)v676 >> 1;
            sub_42BE4((size_t *)&v678, v552, v553);
            if ( (v550 & 1) != 0 )
              free(v551);
            if ( (v674 & 1) != 0 )
              free(v675);
          }
          if ( (v687 & 1) != 0 )
            v554 = v688;
          else
            v554 = (char *)&v687 + 1;
          if ( (v687 & 1) != 0 )
            v555 = *((_QWORD *)&v687 + 1);
          else
            v555 = (unsigned __int64)(unsigned __int8)v687 >> 1;
          sub_42BE4((size_t *)&v678, v554, v555);
          if ( v656 )
          {
            v556 = v682;
            v674 = 0u;
            v675 = 0;
            if ( (v682 & 1) != 0 )
              v557 = *((_QWORD *)&v682 + 1);
            else
              v557 = (unsigned __int64)(unsigned __int8)v682 >> 1;
            if ( v557 + 2 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            if ( v557 + 2 > 0x16 )
            {
              v558 = (char *)malloc((v557 + 18) & 0xFFFFFFFFFFFFFFF0LL);
              *(_QWORD *)&v674 = (v557 + 18) & 0xFFFFFFFFFFFFFFF0LL | 1;
              *((_QWORD *)&v674 + 1) = 2;
              v675 = v558;
            }
            else
            {
              LOBYTE(v674) = 4;
              v558 = (char *)&v674 + 1;
            }
            strcpy(v558, " (");
            if ( (v556 & 1) != 0 )
              v559 = v653;
            else
              v559 = (char *)&v682 + 1;
            sub_42BE4((size_t *)&v674, v559, v557);
            sub_42BE4((size_t *)&v674, ")", 1u);
            v560 = v674;
            v561 = (char *)v675;
            v675 = 0;
            v674 = 0u;
            v676 = v560;
            v562 = v560;
            p = v561;
            v563 = v561;
            if ( (v560 & 1) != 0 )
              v564 = v561;
            else
              v564 = (char *)&v676 + 1;
            if ( (v676 & 1) != 0 )
              v565 = *((_QWORD *)&v676 + 1);
            else
              v565 = (unsigned __int64)(unsigned __int8)v676 >> 1;
            sub_42BE4((size_t *)&v678, v564, v565);
            if ( (v562 & 1) != 0 )
              free(v563);
            if ( (v674 & 1) != 0 )
              free(v675);
          }
          v566 = v679;
          v567 = v678;
          v679 = 0;
          *(_QWORD *)((char *)&v670 + 7) = *((_QWORD *)&v678 + 1);
          BYTE7(v670) = BYTE8(v678);
          v568 = *(_QWORD *)((char *)&v678 + 1);
          v569 = *(_QWORD *)((char *)&v670 + 7);
          v678 = 0u;
          *(_QWORD *)((char *)&v674 + 7) = 0;
          *(_QWORD *)&v674 = 0;
          *(_QWORD *)((char *)&v670 + 7) = 0;
          *(_QWORD *)&v670 = 0;
          *(_QWORD *)&v676 = v568;
          *(_QWORD *)((char *)&v676 + 7) = v569;
          v570 = *(_QWORD *)(a3 + 8);
          v571 = *(_QWORD *)(a3 + 16);
          if ( v570 >= v571 )
          {
            v572 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v570 - *(_QWORD *)a3) >> 4);
            v573 = 0x555555555555555LL;
            if ( v572 + 1 > 0x555555555555555LL )
              abort();
            v574 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v571 - *(_QWORD *)a3) >> 4);
            if ( v574 >= 0x2AAAAAAAAAAAAAALL
              || ((v575 = 2 * v574, v575 >= v572 + 1) ? (v573 = v575) : (v573 = v572 + 1), v573) )
            {
              v576 = *(_QWORD *)(a3 + 24);
              v577 = *(char **)(v576 + 4096);
              if ( v576 + 4096 - (__int64)v577 >= (unsigned __int64)(48 * v573) )
                *(_QWORD *)(v576 + 4096) = &v577[48 * v573];
              else
                v577 = (char *)malloc(48 * v573);
            }
            else
            {
              v577 = 0;
            }
            v601 = &v577[48 * v572];
            *v601 = v567;
            v602 = &v577[48 * v573];
            *((_QWORD *)v601 + 1) = *(_QWORD *)((char *)&v676 + 7);
            *((_QWORD *)v601 + 2) = v566;
            *(_QWORD *)(v601 + 1) = v676;
            *(_QWORD *)((char *)&v676 + 7) = 0;
            *(_QWORD *)&v676 = 0;
            v601[24] = 0;
            *((_QWORD *)v601 + 4) = *(_QWORD *)((char *)&v674 + 7);
            *((_QWORD *)v601 + 5) = 0;
            *(_QWORD *)(v601 + 25) = v674;
            *(_QWORD *)((char *)&v674 + 7) = 0;
            *(_QWORD *)&v674 = 0;
            v604 = *(_QWORD *)a3;
            v603 = *(_QWORD *)(a3 + 8);
            v605 = v601 + 48;
            if ( v603 == *(_QWORD *)a3 )
            {
              v607 = *(void **)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v601 - 4) = *(_QWORD *)(v603 - 32);
                *((_OWORD *)v601 - 3) = *(_OWORD *)(v603 - 48);
                v606 = *(_QWORD *)(v603 - 8);
                *(_QWORD *)(v603 - 40) = 0;
                *(_QWORD *)(v603 - 32) = 0;
                *(_QWORD *)(v603 - 48) = 0;
                *((_QWORD *)v601 - 1) = v606;
                *(_OWORD *)(v601 - 24) = *(_OWORD *)(v603 - 24);
                *(_QWORD *)(v603 - 24) = 0;
                *(_QWORD *)(v603 - 16) = 0;
                *(_QWORD *)(v603 - 8) = 0;
                v603 -= 48;
                v601 -= 48;
              }
              while ( v604 != v603 );
              v607 = *(void **)a3;
              v604 = *(_QWORD *)(a3 + 8);
            }
            *(_QWORD *)a3 = v601;
            *v663 = v605;
            v608 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)(a3 + 16) = v602;
            if ( (void *)v604 != v607 )
            {
              do
              {
                if ( (*(_BYTE *)(v604 - 24) & 1) != 0 )
                  free(*(void **)(v604 - 8));
                v609 = (void *)(v604 - 48);
                if ( (*(_BYTE *)(v604 - 48) & 1) != 0 )
                  free(*(void **)(v604 - 32));
                v604 -= 48LL;
              }
              while ( v607 != v609 );
            }
            if ( v607 )
            {
              v610 = *(_QWORD *)(a3 + 24);
              if ( v610 + 4096 < (unsigned __int64)v607 || v610 > (unsigned __int64)v607 )
              {
                free(v607);
              }
              else if ( *(_QWORD *)(v610 + 4096) == v608 )
              {
                *(_QWORD *)(v610 + 4096) = v607;
              }
            }
          }
          else
          {
            *(_BYTE *)v570 = v567;
            *(_QWORD *)(v570 + 8) = *(_QWORD *)((char *)&v676 + 7);
            *(_QWORD *)(v570 + 16) = v566;
            *(_QWORD *)(v570 + 1) = v676;
            *(_QWORD *)((char *)&v676 + 7) = 0;
            *(_QWORD *)&v676 = 0;
            *(_BYTE *)(v570 + 24) = 0;
            *(_QWORD *)(v570 + 32) = *(_QWORD *)((char *)&v674 + 7);
            *(_QWORD *)(v570 + 40) = 0;
            *(_QWORD *)(v570 + 25) = v674;
            *(_QWORD *)((char *)&v674 + 7) = 0;
            *(_QWORD *)&v674 = 0;
            *v663 += 48;
          }
          v530 = v658 + 1;
          if ( (v678 & 1) != 0 )
            free(v679);
          if ( (v680 & 1) != 0 )
            free(v681);
          v529 = 0;
          if ( (v687 & 1) != 0 )
            goto LABEL_1038;
          goto LABEL_1039;
        case 'e':
          v12 = a1 + 2;
          v682 = 0x3D2104u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'g':
          v12 = a1 + 2;
          v682 = 0x2D02u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 't':
          v12 = a1 + 2;
          v682 = 0x2102u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'x':
          v188 = a1 + 2;
          v189 = sub_47B84(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v189 == v188 )
          {
            v191 = (__int64)(v4 + 2);
          }
          else
          {
            v190 = *(_QWORD *)(a3 + 8);
            v191 = (__int64)(v4 + 2);
            if ( *(_QWORD *)a3 != v190 )
            {
              v192 = *(unsigned __int8 *)(v190 - 24);
              if ( (v192 & 1) != 0 )
                v193 = *(const void **)(v190 - 8);
              else
                v193 = (const void *)(v190 - 23);
              if ( (v192 & 1) != 0 )
                v194 = *(_QWORD *)(v190 - 16);
              else
                v194 = v192 >> 1;
              sub_42BE4((size_t *)(v190 - 48), v193, v194);
              v688 = *(char **)(v190 - 32);
              v687 = *(_OWORD *)(v190 - 48);
              *(_QWORD *)(v190 - 48) = 0;
              *(_QWORD *)(v190 - 40) = 0;
              *(_QWORD *)(v190 - 32) = 0;
              sub_429F4((size_t *)&v687, 0, "noexcept (", 0xAu);
              v195 = v688;
              v196 = v687;
              v687 = 0u;
              v688 = 0;
              v683 = v195;
              v682 = v196;
              sub_42BE4((size_t *)&v682, ")", 1u);
              v197 = *(_QWORD *)((char *)&v682 + 1);
              v198 = *((_QWORD *)&v682 + 1);
              v199 = v683;
              v200 = v682;
              v682 = 0u;
              v683 = 0;
              *(_QWORD *)((char *)&v680 + 7) = v198;
              *(_QWORD *)&v680 = v197;
              v201 = *(_QWORD *)(a3 + 8);
              if ( (*(_BYTE *)(v201 - 48) & 1) != 0 )
              {
                v202 = (_BYTE **)(v201 - 32);
                **(_BYTE **)(v201 - 32) = 0;
                v450 = *(unsigned __int8 *)(v201 - 48);
                *(_QWORD *)(v201 - 40) = 0;
                if ( (v450 & 1) != 0 )
                {
                  v487 = *v202;
                  *(_BYTE *)(v201 - 47) = **v202;
                  free(v487);
                  *(_BYTE *)(v201 - 48) = 0;
                }
                else if ( (unsigned int)v450 >= 0x2E )
                {
                  v662 = (void *)(v450 >> 1);
                  v655 = (unsigned __int8)((v450 >> 1) + 16) & 0xF0;
                  v451 = malloc(v655);
                  if ( v655 - 1 > 0x16 || v451 )
                  {
                    v452 = v451;
                    memcpy(v451, (const void *)(v201 - 47), (size_t)v662 + 1);
                    *(_QWORD *)(v201 - 48) = v655 | 1;
                    *(_QWORD *)(v201 - 40) = v662;
                    *(_QWORD *)(v201 - 32) = v452;
                  }
                }
              }
              else
              {
                *(_WORD *)(v201 - 48) = 0;
                v202 = (_BYTE **)(v201 - 32);
              }
              *(_BYTE *)(v201 - 48) = v200;
              *(_QWORD *)(v201 - 47) = v680;
              *(_QWORD *)(v201 - 40) = *(_QWORD *)((char *)&v680 + 7);
              *v202 = v199;
              *(_QWORD *)((char *)&v680 + 7) = 0;
              *(_QWORD *)&v680 = 0;
              if ( (v682 & 1) != 0 )
                free(v683);
              if ( (v687 & 1) != 0 )
                free(v688);
              v191 = v189;
            }
          }
          if ( (unsigned __int8 *)v191 != v188 )
            return (unsigned __int8 *)v191;
          return v4;
        default:
          return v4;
      }
    case 'o':
      switch ( v10[1] )
      {
        case 'R':
          v12 = a1 + 2;
          v682 = 0x3D7C04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'n':
          return (unsigned __int8 *)sub_4F704(a1, a2, a3);
        case 'o':
          v12 = a1 + 2;
          v682 = 0x7C7C04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'r':
          v12 = a1 + 2;
          v682 = 0x7C02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        default:
          return v4;
      }
    case 'p':
      switch ( v10[1] )
      {
        case 'L':
          v12 = a1 + 2;
          v682 = 0x3D2B04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'l':
          v12 = a1 + 2;
          v682 = 0x2B02u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'm':
          v12 = a1 + 2;
          v682 = 0x2A3E2D06u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'p':
          v254 = a1 + 2;
          if ( a1 + 2 != a2 && *v254 == 95 )
          {
            v12 = a1 + 3;
            v682 = 0x2B2B04u;
            v683 = 0;
            v13 = sub_4F434((__int64)(a1 + 3), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
            goto LABEL_567;
          }
          v21 = sub_47B84(a1 + 2, a2, a3);
          if ( (_BYTE *)v21 == v254 )
            return v4;
          v378 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v378 )
            return v4;
          v379 = *(unsigned __int8 *)(v378 - 24);
          if ( (v379 & 1) != 0 )
            v380 = *(const void **)(v378 - 8);
          else
            v380 = (const void *)(v378 - 23);
          if ( (v379 & 1) != 0 )
            v381 = *(_QWORD *)(v378 - 16);
          else
            v381 = v379 >> 1;
          sub_42BE4((size_t *)(v378 - 48), v380, v381);
          v681 = *(char **)(v378 - 32);
          v680 = *(_OWORD *)(v378 - 48);
          *(_QWORD *)(v378 - 48) = 0;
          *(_QWORD *)(v378 - 40) = 0;
          *(_QWORD *)(v378 - 32) = 0;
          sub_429F4((size_t *)&v680, 0, "(", 1u);
          v382 = v681;
          v383 = v680;
          v680 = 0u;
          v681 = 0;
          v688 = v382;
          v687 = v383;
          sub_42BE4((size_t *)&v687, ")++", 3u);
          v384 = *(_QWORD *)((char *)&v687 + 1);
          v385 = *((_QWORD *)&v687 + 1);
          v250 = v688;
          v386 = v687;
          v687 = 0u;
          v688 = 0;
          *(_QWORD *)&v672[23] = v385;
          v672[23] = HIBYTE(v384);
          LOBYTE(v682) = v386;
          v252 = v384;
          v253 = *(_QWORD *)&v672[23];
          memset(&v672[16], 0, 15);
          break;
        case 's':
          v12 = a1 + 2;
          v682 = 0x2B02u;
          v683 = 0;
          v13 = sub_4F434((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 't':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 112 )
            return v4;
          if ( a1[1] != 116 )
            return v4;
          v230 = a1 + 2;
          v231 = sub_47B84(a1 + 2, a2, a3);
          v232 = v231;
          if ( (unsigned __int8 *)v231 == v230 )
            return v4;
          v21 = sub_47B84(v231, a2, a3);
          if ( v21 == v232 )
            return v4;
          v233 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v233 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v234 = *(unsigned __int8 *)(v233 - 24);
          if ( (v234 & 1) != 0 )
            v235 = *(const void **)(v233 - 8);
          else
            v235 = (const void *)(v233 - 23);
          if ( (v234 & 1) != 0 )
            v236 = *(_QWORD *)(v233 - 16);
          else
            v236 = v234 >> 1;
          sub_42BE4((size_t *)(v233 - 48), v235, v236);
          v683 = *(char **)(v233 - 32);
          v682 = *(_OWORD *)(v233 - 48);
          *(_QWORD *)(v233 - 40) = 0;
          *(_QWORD *)(v233 - 32) = 0;
          *(_QWORD *)(v233 - 48) = 0;
          v237 = *(_QWORD *)(a3 + 8);
          v238 = (_BYTE *)(v237 - 48);
          if ( (*(_BYTE *)(v237 - 24) & 1) != 0 )
            free(*(void **)(v237 - 8));
          if ( (*v238 & 1) != 0 )
            free(*(void **)(v237 - 32));
          *(_QWORD *)(a3 + 8) = v238;
          sub_42BE4((size_t *)(v237 - 96), "->", 2u);
          v239 = *(_QWORD *)(a3 + 8);
          v240 = v683;
          if ( (v682 & 1) != 0 )
            v241 = v683;
          else
            v241 = (char *)&v682 + 1;
          if ( (v682 & 1) != 0 )
            v242 = *((_QWORD *)&v682 + 1);
          else
            v242 = (unsigned __int64)(unsigned __int8)v682 >> 1;
          sub_42BE4((size_t *)(v239 - 48), v241, v242);
          if ( (v682 & 1) == 0 )
            return (unsigned __int8 *)v21;
          v243 = v240;
          goto LABEL_818;
        default:
          return v4;
      }
      goto LABEL_579;
    case 'q':
      if ( v10[1] != 117 )
        return v4;
      v95 = a1 + 2;
      v96 = sub_47B84(a1 + 2, a2, a3);
      v97 = v96;
      if ( (unsigned __int8 *)v96 == v95 )
        return v4;
      v98 = sub_47B84(v96, a2, a3);
      v99 = v98;
      if ( v98 != v97 )
      {
        v100 = sub_47B84(v98, a2, a3);
        v101 = *(_QWORD *)(a3 + 8);
        v21 = v100;
        v102 = 0xAAAAAAAAAAAAAAABLL * ((v101 - *(_QWORD *)a3) >> 4);
        if ( v100 == v99 )
        {
          if ( v102 >= 2 )
          {
            v387 = (_BYTE *)(v101 - 48);
            if ( (*(_BYTE *)(v101 - 24) & 1) != 0 )
              free(*(void **)(v101 - 8));
            if ( (*v387 & 1) != 0 )
              free(*(void **)(v101 - 32));
            *(_QWORD *)(a3 + 8) = v387;
            v388 = (_BYTE *)(v101 - 96);
            if ( (*(_BYTE *)(v101 - 72) & 1) != 0 )
              free(*(void **)(v101 - 56));
            if ( (*v388 & 1) != 0 )
              free(*(void **)(v101 - 80));
            *(_QWORD *)(a3 + 8) = v388;
          }
          return v4;
        }
        if ( v102 < 3 )
          return v4;
        v103 = *(unsigned __int8 *)(v101 - 24);
        if ( (v103 & 1) != 0 )
          v104 = *(const void **)(v101 - 8);
        else
          v104 = (const void *)(v101 - 23);
        if ( (v103 & 1) != 0 )
          v105 = *(_QWORD *)(v101 - 16);
        else
          v105 = v103 >> 1;
        sub_42BE4((size_t *)(v101 - 48), v104, v105);
        v688 = *(char **)(v101 - 32);
        v687 = *(_OWORD *)(v101 - 48);
        *(_QWORD *)(v101 - 40) = 0;
        *(_QWORD *)(v101 - 32) = 0;
        *(_QWORD *)(v101 - 48) = 0;
        v106 = *(_QWORD *)(a3 + 8);
        v107 = (_BYTE *)(v106 - 48);
        if ( (*(_BYTE *)(v106 - 24) & 1) != 0 )
          free(*(void **)(v106 - 8));
        if ( (*v107 & 1) != 0 )
          free(*(void **)(v106 - 32));
        *(_QWORD *)(a3 + 8) = v107;
        v108 = *(unsigned __int8 *)(v106 - 72);
        if ( (v108 & 1) != 0 )
          v109 = *(const void **)(v106 - 56);
        else
          v109 = (const void *)(v106 - 71);
        if ( (v108 & 1) != 0 )
          v110 = *(_QWORD *)(v106 - 64);
        else
          v110 = v108 >> 1;
        v111 = sub_42BE4((size_t *)(v106 - 96), v109, v110);
        v681 = (char *)v111[2];
        v680 = *(_OWORD *)v111;
        v111[1] = 0;
        v111[2] = 0;
        *v111 = 0;
        v112 = *(_QWORD *)(a3 + 8);
        v113 = (_BYTE *)(v112 - 48);
        if ( (*(_BYTE *)(v112 - 24) & 1) != 0 )
          free(*(void **)(v112 - 8));
        if ( (*v113 & 1) != 0 )
          free(*(void **)(v112 - 32));
        *(_QWORD *)(a3 + 8) = v113;
        v114 = *(unsigned __int8 *)(v112 - 72);
        if ( (v114 & 1) != 0 )
          v115 = *(const void **)(v112 - 56);
        else
          v115 = (const void *)(v112 - 71);
        if ( (v114 & 1) != 0 )
          v116 = *(_QWORD *)(v112 - 64);
        else
          v116 = v114 >> 1;
        v117 = sub_42BE4((size_t *)(v112 - 96), v115, v116);
        v679 = (char *)v117[2];
        v678 = *(_OWORD *)v117;
        *v117 = 0;
        v117[1] = 0;
        v117[2] = 0;
        v118 = v678;
        v666 = 0u;
        v667 = 0;
        if ( (v678 & 1) != 0 )
          v119 = *((_QWORD *)&v678 + 1);
        else
          v119 = (unsigned __int64)(unsigned __int8)v678 >> 1;
        if ( v119 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        if ( v119 + 1 > 0x16 )
        {
          v120 = malloc((v119 + 17) & 0xFFFFFFFFFFFFFFF0LL);
          *(_QWORD *)&v666 = (v119 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
          *((_QWORD *)&v666 + 1) = 1;
          v667 = v120;
        }
        else
        {
          LOBYTE(v666) = 2;
          v120 = (_WORD *)((char *)&v666 + 1);
        }
        v429 = v679;
        *v120 = 40;
        if ( (v118 & 1) != 0 )
          v430 = v429;
        else
          v430 = (char *)&v678 + 1;
        sub_42BE4((size_t *)&v666, v430, v119);
        sub_42BE4((size_t *)&v666, ") ? (", 5u);
        v431 = v680;
        v432 = v681;
        v433 = v666;
        v669 = v667;
        if ( (v680 & 1) != 0 )
          v434 = v681;
        else
          v434 = (char *)&v680 + 1;
        v667 = 0;
        v666 = 0u;
        v668 = v433;
        if ( (v680 & 1) != 0 )
          v435 = *((_QWORD *)&v680 + 1);
        else
          v435 = (unsigned __int64)(unsigned __int8)v680 >> 1;
        sub_42BE4((size_t *)&v668, v434, v435);
        v436 = v668;
        v661 = v429;
        v668 = 0u;
        v671 = v669;
        v670 = v436;
        v669 = 0;
        sub_42BE4((size_t *)&v670, ") : (", 5u);
        v437 = v687;
        v438 = v688;
        v439 = v670;
        v675 = v671;
        if ( (v687 & 1) != 0 )
          v440 = v688;
        else
          v440 = (char *)&v687 + 1;
        v671 = 0;
        v670 = 0u;
        v674 = v439;
        if ( (v687 & 1) != 0 )
          v441 = *((_QWORD *)&v687 + 1);
        else
          v441 = (unsigned __int64)(unsigned __int8)v687 >> 1;
        sub_42BE4((size_t *)&v674, v440, v441);
        v442 = v675;
        v443 = v674;
        v674 = 0u;
        v675 = 0;
        p = v442;
        v676 = v443;
        sub_42BE4((size_t *)&v676, ")", 1u);
        v444 = *(_QWORD *)((char *)&v676 + 1);
        v445 = *((_QWORD *)&v676 + 1);
        v446 = (char *)p;
        v447 = v676;
        v676 = 0u;
        p = 0;
        *(_QWORD *)&v672[7] = v445;
        v672[7] = HIBYTE(v444);
        LOBYTE(v682) = v447;
        v448 = v444;
        v449 = *(_QWORD *)&v672[7];
        memset(v672, 0, 15);
        *(_QWORD *)((char *)&v682 + 1) = v448;
        *((_QWORD *)&v682 + 1) = v449;
        v683 = v446;
        v685 = 0;
        v686 = 0;
        v684 = 0;
        sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
        if ( (v684 & 1) != 0 )
        {
          free(v686);
          if ( (v682 & 1) == 0 )
          {
LABEL_680:
            if ( (v676 & 1) == 0 )
              goto LABEL_681;
            goto LABEL_691;
          }
        }
        else if ( (v682 & 1) == 0 )
        {
          goto LABEL_680;
        }
        free(v683);
        if ( (v676 & 1) == 0 )
        {
LABEL_681:
          if ( (v674 & 1) == 0 )
            goto LABEL_682;
          goto LABEL_692;
        }
LABEL_691:
        free(p);
        if ( (v674 & 1) == 0 )
        {
LABEL_682:
          if ( (v670 & 1) == 0 )
            goto LABEL_683;
          goto LABEL_693;
        }
LABEL_692:
        free(v675);
        if ( (v670 & 1) == 0 )
        {
LABEL_683:
          if ( (v668 & 1) == 0 )
            goto LABEL_684;
          goto LABEL_694;
        }
LABEL_693:
        free(v671);
        if ( (v668 & 1) == 0 )
        {
LABEL_684:
          if ( (v666 & 1) == 0 )
            goto LABEL_685;
          goto LABEL_695;
        }
LABEL_694:
        free(v669);
        if ( (v666 & 1) == 0 )
        {
LABEL_685:
          if ( (v118 & 1) == 0 )
            goto LABEL_686;
          goto LABEL_696;
        }
LABEL_695:
        free(v667);
        if ( (v118 & 1) == 0 )
        {
LABEL_686:
          if ( (v431 & 1) == 0 )
            goto LABEL_687;
          goto LABEL_697;
        }
LABEL_696:
        free(v661);
        if ( (v431 & 1) == 0 )
        {
LABEL_687:
          if ( (v437 & 1) == 0 )
            return (unsigned __int8 *)v21;
LABEL_698:
          v243 = v438;
          goto LABEL_818;
        }
LABEL_697:
        free(v432);
        if ( (v437 & 1) == 0 )
          return (unsigned __int8 *)v21;
        goto LABEL_698;
      }
      v271 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 != v271 )
      {
LABEL_423:
        v272 = (_BYTE *)(v271 - 48);
        if ( (*(_BYTE *)(v271 - 24) & 1) != 0 )
          free(*(void **)(v271 - 8));
        if ( (*v272 & 1) != 0 )
          free(*(void **)(v271 - 32));
        *(_QWORD *)(a3 + 8) = v272;
      }
      return v4;
    case 'r':
      switch ( v10[1] )
      {
        case 'M':
          v12 = a1 + 2;
          v682 = 0x3D2504u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'S':
          v12 = a1 + 2;
          v682 = 0x3D3E3E06u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 'c':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 114 )
            return v4;
          if ( a1[1] != 99 )
            return v4;
          v156 = a1 + 2;
          v157 = sub_38008(a1 + 2, a2, a3);
          v158 = v157;
          if ( (unsigned __int8 *)v157 == v156 )
            return v4;
          v21 = sub_47B84(v157, a2, a3);
          if ( v21 == v158 )
            return v4;
          v159 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v159 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v160 = *(unsigned __int8 *)(v159 - 24);
          if ( (v160 & 1) != 0 )
            v161 = *(const void **)(v159 - 8);
          else
            v161 = (const void *)(v159 - 23);
          if ( (v160 & 1) != 0 )
            v162 = *(_QWORD *)(v159 - 16);
          else
            v162 = v160 >> 1;
          sub_42BE4((size_t *)(v159 - 48), v161, v162);
          v688 = *(char **)(v159 - 32);
          v687 = *(_OWORD *)(v159 - 48);
          *(_QWORD *)(v159 - 40) = 0;
          *(_QWORD *)(v159 - 32) = 0;
          *(_QWORD *)(v159 - 48) = 0;
          v163 = *(_QWORD *)(a3 + 8);
          v164 = (_BYTE *)(v163 - 48);
          if ( (*(_BYTE *)(v163 - 24) & 1) != 0 )
            free(*(void **)(v163 - 8));
          if ( (*v164 & 1) != 0 )
            free(*(void **)(v163 - 32));
          v165 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v164;
          if ( (_BYTE *)v165 != v164 )
          {
            v166 = *(unsigned __int8 *)(v163 - 72);
            if ( (v166 & 1) != 0 )
              v167 = *(const void **)(v163 - 56);
            else
              v167 = (const void *)(v163 - 71);
            if ( (v166 & 1) != 0 )
              v168 = *(_QWORD *)(v163 - 64);
            else
              v168 = v166 >> 1;
            v169 = sub_42BE4((size_t *)(v163 - 96), v167, v168);
            v675 = (void *)v169[2];
            v674 = *(_OWORD *)v169;
            *v169 = 0;
            v169[1] = 0;
            v169[2] = 0;
            sub_429F4((size_t *)&v674, 0, "reinterpret_cast<", 0x11u);
            v170 = v675;
            v171 = v674;
            v674 = 0u;
            v675 = 0;
            p = v170;
            v676 = v171;
            sub_42BE4((size_t *)&v676, ">(", 2u);
            v172 = (char *)p;
            v173 = v676;
            p = 0;
            v676 = 0u;
            v174 = v687;
            v679 = v172;
            if ( (v687 & 1) != 0 )
              v175 = v688;
            else
              v175 = (char *)&v687 + 1;
            v678 = v173;
            if ( (v687 & 1) != 0 )
              v176 = *((_QWORD *)&v687 + 1);
            else
              v176 = (unsigned __int64)(unsigned __int8)v687 >> 1;
            sub_42BE4((size_t *)&v678, v175, v176);
            v177 = v679;
            v178 = v678;
            v678 = 0u;
            v679 = 0;
            v681 = v177;
            v680 = v178;
            sub_42BE4((size_t *)&v680, ")", 1u);
            v179 = *(_QWORD *)((char *)&v680 + 1);
            v180 = *((_QWORD *)&v680 + 1);
            v181 = v681;
            v182 = v680;
            v680 = 0u;
            v681 = 0;
            *(_QWORD *)((char *)&v670 + 7) = v180;
            BYTE7(v670) = HIBYTE(v179);
            LOBYTE(v682) = v182;
            v183 = v179;
            v184 = *(_QWORD *)((char *)&v670 + 7);
            *(_QWORD *)((char *)&v670 + 7) = 0;
            *(_QWORD *)&v670 = 0;
            *(_QWORD *)((char *)&v682 + 1) = v183;
            *((_QWORD *)&v682 + 1) = v184;
            v683 = v181;
            v685 = 0;
            v686 = 0;
            v684 = 0;
            sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
            if ( (v684 & 1) != 0 )
            {
              free(v686);
              if ( (v682 & 1) == 0 )
              {
LABEL_275:
                if ( (v680 & 1) == 0 )
                  goto LABEL_276;
                goto LABEL_876;
              }
            }
            else if ( (v682 & 1) == 0 )
            {
              goto LABEL_275;
            }
            free(v683);
            if ( (v680 & 1) == 0 )
            {
LABEL_276:
              if ( (v678 & 1) == 0 )
                goto LABEL_277;
              goto LABEL_877;
            }
LABEL_876:
            free(v681);
            if ( (v678 & 1) == 0 )
            {
LABEL_277:
              if ( (v676 & 1) == 0 )
                goto LABEL_279;
              goto LABEL_278;
            }
LABEL_877:
            free(v679);
            if ( (v676 & 1) == 0 )
            {
LABEL_279:
              v185 = v174 & 1;
              if ( (v674 & 1) != 0 )
                free(v675);
              v186 = 0;
              if ( v185 )
                goto LABEL_282;
              goto LABEL_283;
            }
LABEL_278:
            free(p);
            goto LABEL_279;
          }
          v186 = 1;
          v21 = (__int64)v4;
          if ( (v687 & 1) != 0 )
LABEL_282:
            free(v688);
LABEL_283:
          if ( !v186 )
            return (unsigned __int8 *)v21;
          return v4;
        case 'm':
          v12 = a1 + 2;
          v682 = 0x2502u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        case 's':
          v12 = a1 + 2;
          v682 = 0x3E3E04u;
          v683 = 0;
          v13 = sub_4EE40((__int64)(a1 + 2), (__int64)a2, (unsigned __int8 *)&v682, (_QWORD *)a3);
          goto LABEL_567;
        default:
          return v4;
      }
    case 's':
      switch ( v10[1] )
      {
        case 'Z':
          if ( a2 - v10 < 3 )
            return v4;
          v71 = v10[2];
          if ( v71 != 102 )
          {
            if ( v71 == 84 && v5 >= 3 && *a1 == 115 && a1[1] == 90 )
            {
              v72 = a1 + 2;
              if ( a1[2] == 84 )
              {
                v73 = *(_QWORD *)a3;
                v74 = *(_QWORD *)(a3 + 8);
                v657 = sub_454F4(a1 + 2, a2, a3);
                if ( (unsigned __int8 *)v657 != v72 )
                {
                  v75 = *(_QWORD *)a3;
                  v76 = *(_QWORD *)(a3 + 8);
                  LOBYTE(v682) = 20;
                  *((_QWORD *)&v682 + 1) = 2633216;
                  v683 = 0;
                  v77 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v74 - v73) >> 4);
                  *(_QWORD *)((char *)&v682 + 1) = *(_QWORD *)"sizeof...(";
                  v659 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v76 - v75) >> 4);
                  if ( v77 != v659 )
                  {
                    v78 = v75 + 48 * v77;
                    v79 = *(unsigned __int8 *)(v78 + 24);
                    if ( (v79 & 1) != 0 )
                      v80 = *(const void **)(v78 + 40);
                    else
                      v80 = (const void *)(v78 + 25);
                    if ( (v79 & 1) != 0 )
                      v81 = *(_QWORD *)(v78 + 32);
                    else
                      v81 = v79 >> 1;
                    v82 = sub_42BE4((size_t *)v78, v80, v81);
                    v688 = (char *)v82[2];
                    v687 = *(_OWORD *)v82;
                    v82[1] = 0;
                    v82[2] = 0;
                    *v82 = 0;
                    v83 = v687;
                    v84 = v688;
                    if ( (v687 & 1) != 0 )
                      v85 = v688;
                    else
                      v85 = (char *)&v687 + 1;
                    if ( (v687 & 1) != 0 )
                      v86 = *((_QWORD *)&v687 + 1);
                    else
                      v86 = (unsigned __int64)(unsigned __int8)v687 >> 1;
                    sub_42BE4((size_t *)&v682, v85, v86);
                    if ( (v83 & 1) != 0 )
                      free(v84);
                    if ( v77 + 1 != v659 )
                    {
                      v584 = v659 - 1 - v77;
                      v585 = 48 * v77;
                      do
                      {
                        v586 = *(_QWORD *)a3 + v585;
                        v587 = *(unsigned __int8 *)(v586 + 72);
                        v588 = *(_QWORD *)(v586 + 80);
                        v589 = *(const void **)(v586 + 88);
                        v590 = (size_t *)(v586 + 48);
                        v591 = (const void *)(v586 + 73);
                        if ( (v587 & 1) != 0 )
                          v592 = v589;
                        else
                          v592 = v591;
                        if ( (v587 & 1) != 0 )
                          v593 = v588;
                        else
                          v593 = v587 >> 1;
                        v594 = sub_42BE4(v590, v592, v593);
                        v681 = (char *)v594[2];
                        v680 = *(_OWORD *)v594;
                        *v594 = 0;
                        v594[1] = 0;
                        v594[2] = 0;
                        sub_429F4((size_t *)&v680, 0, ", ", 2u);
                        v595 = v680;
                        v596 = v681;
                        v681 = 0;
                        v680 = 0u;
                        v687 = v595;
                        v597 = v595;
                        v688 = v596;
                        v598 = v596;
                        if ( (v595 & 1) != 0 )
                          v599 = v596;
                        else
                          v599 = (char *)&v687 + 1;
                        if ( (v595 & 1) != 0 )
                          v600 = *((_QWORD *)&v687 + 1);
                        else
                          v600 = (unsigned __int64)(unsigned __int8)v595 >> 1;
                        sub_42BE4((size_t *)&v682, v599, v600);
                        if ( (v597 & 1) != 0 )
                          free(v598);
                        if ( (v680 & 1) != 0 )
                          free(v681);
                        --v584;
                        v585 += 48;
                      }
                      while ( v584 );
                    }
                  }
                  sub_42BE4((size_t *)&v682, ")", 1u);
                  v87 = *(_QWORD *)(a3 + 8);
                  v88 = v77 - v659;
                  if ( v77 != v659 )
                  {
                    v89 = v87 - 48;
                    v90 = v77 - v659;
                    do
                    {
                      if ( (*(_BYTE *)(v89 + 24) & 1) != 0 )
                        free(*(void **)(v89 + 40));
                      if ( (*(_BYTE *)v89 & 1) != 0 )
                        free(*(void **)(v89 + 16));
                      *(_QWORD *)(a3 + 8) = v89;
                      ++v90;
                      v89 -= 48LL;
                    }
                    while ( v90 );
                    v87 += 48 * v88;
                  }
                  v91 = v683;
                  v92 = v682;
                  v683 = 0;
                  *(_QWORD *)((char *)&v680 + 7) = *((_QWORD *)&v682 + 1);
                  BYTE7(v680) = BYTE8(v682);
                  *(_QWORD *)&v678 = *(_QWORD *)((char *)&v682 + 1);
                  v93 = *(_QWORD *)((char *)&v680 + 7);
                  v682 = 0u;
                  *(_QWORD *)((char *)&v687 + 7) = 0;
                  *(_QWORD *)((char *)&v680 + 7) = 0;
                  *(_QWORD *)&v680 = 0;
                  *(_QWORD *)((char *)&v678 + 7) = v93;
                  *(_QWORD *)&v687 = 0;
                  v94 = *(_QWORD *)(a3 + 16);
                  if ( v87 < v94 )
                  {
                    *(_BYTE *)v87 = v92;
                    *(_QWORD *)(v87 + 8) = *(_QWORD *)((char *)&v678 + 7);
                    *(_QWORD *)(v87 + 16) = v91;
                    *(_QWORD *)(v87 + 1) = v678;
                    *(_QWORD *)((char *)&v678 + 7) = 0;
                    *(_QWORD *)&v678 = 0;
                    *(_BYTE *)(v87 + 24) = 0;
                    *(_QWORD *)(v87 + 32) = *(_QWORD *)((char *)&v687 + 7);
                    *(_QWORD *)(v87 + 40) = 0;
                    *(_QWORD *)(v87 + 25) = v687;
                    *(_QWORD *)((char *)&v687 + 7) = 0;
                    *(_QWORD *)&v687 = 0;
                    *(_QWORD *)(a3 + 8) += 48LL;
                    if ( (v682 & 1) == 0 )
                      return (unsigned __int8 *)v657;
                    goto LABEL_1120;
                  }
                  v578 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v87 - *(_QWORD *)a3) >> 4);
                  v579 = 0x555555555555555LL;
                  if ( v578 + 1 > 0x555555555555555LL )
                    abort();
                  v580 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v94 - *(_QWORD *)a3) >> 4);
                  if ( v580 >= 0x2AAAAAAAAAAAAAALL
                    || ((v581 = 2 * v580, v581 >= v578 + 1) ? (v579 = v581) : (v579 = v578 + 1), v579) )
                  {
                    v582 = *(_QWORD *)(a3 + 24);
                    v583 = *(char **)(v582 + 4096);
                    if ( v582 + 4096 - (__int64)v583 >= (unsigned __int64)(48 * v579) )
                      *(_QWORD *)(v582 + 4096) = &v583[48 * v579];
                    else
                      v583 = (char *)malloc(48 * v579);
                  }
                  else
                  {
                    v583 = 0;
                  }
                  v643 = &v583[48 * v578];
                  *v643 = v92;
                  *((_QWORD *)v643 + 1) = *(_QWORD *)((char *)&v678 + 7);
                  *((_QWORD *)v643 + 2) = v91;
                  *(_QWORD *)(v643 + 1) = v678;
                  *(_QWORD *)((char *)&v678 + 7) = 0;
                  *(_QWORD *)&v678 = 0;
                  v643[24] = 0;
                  *((_QWORD *)v643 + 4) = *(_QWORD *)((char *)&v687 + 7);
                  *((_QWORD *)v643 + 5) = 0;
                  *(_QWORD *)(v643 + 25) = v687;
                  *(_QWORD *)((char *)&v687 + 7) = 0;
                  *(_QWORD *)&v687 = 0;
                  v645 = *(_QWORD *)a3;
                  v644 = *(_QWORD *)(a3 + 8);
                  v646 = v643 + 48;
                  if ( v644 == *(_QWORD *)a3 )
                  {
                    v648 = *(void **)a3;
                  }
                  else
                  {
                    do
                    {
                      *((_QWORD *)v643 - 4) = *(_QWORD *)(v644 - 32);
                      *((_OWORD *)v643 - 3) = *(_OWORD *)(v644 - 48);
                      v647 = *(_QWORD *)(v644 - 8);
                      *(_QWORD *)(v644 - 40) = 0;
                      *(_QWORD *)(v644 - 32) = 0;
                      *(_QWORD *)(v644 - 48) = 0;
                      *((_QWORD *)v643 - 1) = v647;
                      *(_OWORD *)(v643 - 24) = *(_OWORD *)(v644 - 24);
                      *(_QWORD *)(v644 - 24) = 0;
                      *(_QWORD *)(v644 - 16) = 0;
                      *(_QWORD *)(v644 - 8) = 0;
                      v644 -= 48;
                      v643 -= 48;
                    }
                    while ( v645 != v644 );
                    v648 = *(void **)a3;
                    v645 = *(_QWORD *)(a3 + 8);
                  }
                  v649 = *(_QWORD *)(a3 + 16);
                  *(_QWORD *)a3 = v643;
                  *(_QWORD *)(a3 + 8) = v646;
                  *(_QWORD *)(a3 + 16) = &v583[48 * v579];
                  if ( (void *)v645 != v648 )
                  {
                    do
                    {
                      if ( (*(_BYTE *)(v645 - 24) & 1) != 0 )
                        free(*(void **)(v645 - 8));
                      v650 = (void *)(v645 - 48);
                      if ( (*(_BYTE *)(v645 - 48) & 1) != 0 )
                        free(*(void **)(v645 - 32));
                      v645 -= 48LL;
                    }
                    while ( v648 != v650 );
                  }
                  if ( v648 )
                  {
                    v651 = *(_QWORD *)(a3 + 24);
                    if ( v651 + 4096 < (unsigned __int64)v648 || v651 > (unsigned __int64)v648 )
                    {
                      free(v648);
                    }
                    else if ( *(_QWORD *)(v651 + 4096) == v649 )
                    {
                      *(_QWORD *)(v651 + 4096) = v648;
                      if ( (v682 & 1) == 0 )
                        return (unsigned __int8 *)v657;
                      goto LABEL_1120;
                    }
                  }
                  if ( (v682 & 1) == 0 )
                    return (unsigned __int8 *)v657;
LABEL_1120:
                  free(v683);
                  return (unsigned __int8 *)v657;
                }
              }
            }
            return v4;
          }
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 115 )
            return v4;
          if ( a1[1] != 90 )
            return v4;
          v453 = a1 + 2;
          if ( a1[2] != 102 )
            return v4;
          v21 = (__int64)sub_4E518(a1 + 2, a2, (void **)a3);
          if ( (unsigned __int8 *)v21 == v453 )
            return v4;
          v454 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v454 )
            return v4;
          v455 = *(unsigned __int8 *)(v454 - 24);
          if ( (v455 & 1) != 0 )
            v456 = *(const void **)(v454 - 8);
          else
            v456 = (const void *)(v454 - 23);
          if ( (v455 & 1) != 0 )
            v457 = *(_QWORD *)(v454 - 16);
          else
            v457 = v455 >> 1;
          sub_42BE4((size_t *)(v454 - 48), v456, v457);
          v681 = *(char **)(v454 - 32);
          v680 = *(_OWORD *)(v454 - 48);
          *(_QWORD *)(v454 - 48) = 0;
          *(_QWORD *)(v454 - 40) = 0;
          *(_QWORD *)(v454 - 32) = 0;
          sub_429F4((size_t *)&v680, 0, "sizeof...(", 0xAu);
          v458 = v681;
          v459 = v680;
          v680 = 0u;
          v681 = 0;
          v688 = v458;
          v687 = v459;
          sub_42BE4((size_t *)&v687, ")", 1u);
LABEL_386:
          v248 = *(_QWORD *)((char *)&v687 + 1);
          v249 = *((_QWORD *)&v687 + 1);
          v250 = v688;
          v251 = v687;
          v687 = 0u;
          v688 = 0;
          *(_QWORD *)((char *)&v678 + 7) = v249;
          BYTE7(v678) = HIBYTE(v248);
          LOBYTE(v682) = v251;
          v252 = v248;
          v253 = *(_QWORD *)((char *)&v678 + 7);
          *(_QWORD *)((char *)&v678 + 7) = 0;
          *(_QWORD *)&v678 = 0;
LABEL_579:
          *(_QWORD *)((char *)&v682 + 1) = v252;
          *((_QWORD *)&v682 + 1) = v253;
          v683 = v250;
          v685 = 0;
          v686 = 0;
          v684 = 0;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
          if ( (v684 & 1) != 0 )
          {
            free(v686);
            if ( (v682 & 1) == 0 )
            {
LABEL_581:
              if ( (v687 & 1) == 0 )
                goto LABEL_582;
              goto LABEL_632;
            }
          }
          else if ( (v682 & 1) == 0 )
          {
            goto LABEL_581;
          }
          free(v683);
          if ( (v687 & 1) == 0 )
          {
LABEL_582:
            if ( (v680 & 1) == 0 )
              return (unsigned __int8 *)v21;
LABEL_633:
            v243 = v681;
            goto LABEL_818;
          }
LABEL_632:
          free(v688);
          if ( (v680 & 1) == 0 )
            return (unsigned __int8 *)v21;
          goto LABEL_633;
        case 'c':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 115 )
            return v4;
          if ( a1[1] != 99 )
            return v4;
          v203 = a1 + 2;
          v204 = sub_38008(a1 + 2, a2, a3);
          v205 = v204;
          if ( (unsigned __int8 *)v204 == v203 )
            return v4;
          v21 = sub_47B84(v204, a2, a3);
          if ( v21 == v205 )
            return v4;
          v206 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v206 - *(_QWORD *)a3) >> 4) < 2 )
            return v4;
          v207 = *(unsigned __int8 *)(v206 - 24);
          if ( (v207 & 1) != 0 )
            v208 = *(const void **)(v206 - 8);
          else
            v208 = (const void *)(v206 - 23);
          if ( (v207 & 1) != 0 )
            v209 = *(_QWORD *)(v206 - 16);
          else
            v209 = v207 >> 1;
          sub_42BE4((size_t *)(v206 - 48), v208, v209);
          v688 = *(char **)(v206 - 32);
          v687 = *(_OWORD *)(v206 - 48);
          *(_QWORD *)(v206 - 40) = 0;
          *(_QWORD *)(v206 - 32) = 0;
          *(_QWORD *)(v206 - 48) = 0;
          v210 = *(_QWORD *)(a3 + 8);
          v211 = (_BYTE *)(v210 - 48);
          if ( (*(_BYTE *)(v210 - 24) & 1) != 0 )
            free(*(void **)(v210 - 8));
          if ( (*v211 & 1) != 0 )
            free(*(void **)(v210 - 32));
          *(_QWORD *)(a3 + 8) = v211;
          v212 = *(unsigned __int8 *)(v210 - 72);
          if ( (v212 & 1) != 0 )
            v213 = *(const void **)(v210 - 56);
          else
            v213 = (const void *)(v210 - 71);
          if ( (v212 & 1) != 0 )
            v214 = *(_QWORD *)(v210 - 64);
          else
            v214 = v212 >> 1;
          v215 = sub_42BE4((size_t *)(v210 - 96), v213, v214);
          v675 = (void *)v215[2];
          v674 = *(_OWORD *)v215;
          *v215 = 0;
          v215[1] = 0;
          v215[2] = 0;
          sub_429F4((size_t *)&v674, 0, "static_cast<", 0xCu);
          v216 = v675;
          v217 = v674;
          v674 = 0u;
          v675 = 0;
          p = v216;
          v676 = v217;
          sub_42BE4((size_t *)&v676, ">(", 2u);
          v218 = v687;
          v219 = (char *)p;
          v220 = v676;
          p = 0;
          v676 = 0u;
          v221 = v688;
          v679 = v219;
          if ( (v687 & 1) != 0 )
            v222 = v688;
          else
            v222 = (char *)&v687 + 1;
          v678 = v220;
          if ( (v687 & 1) != 0 )
            v223 = *((_QWORD *)&v687 + 1);
          else
            v223 = (unsigned __int64)(unsigned __int8)v687 >> 1;
LABEL_1086:
          sub_42BE4((size_t *)&v678, v222, v223);
          v635 = v679;
          v636 = v678;
          v678 = 0u;
          v679 = 0;
          v681 = v635;
          v680 = v636;
          sub_42BE4((size_t *)&v680, ")", 1u);
          v637 = *(_QWORD *)((char *)&v680 + 1);
          v638 = *((_QWORD *)&v680 + 1);
          v639 = v681;
          v640 = v680;
          v680 = 0u;
          v681 = 0;
          *(_QWORD *)((char *)&v670 + 7) = v638;
          BYTE7(v670) = HIBYTE(v637);
          LOBYTE(v682) = v640;
          v641 = v637;
          v642 = *(_QWORD *)((char *)&v670 + 7);
          *(_QWORD *)((char *)&v670 + 7) = 0;
          *(_QWORD *)&v670 = 0;
          *(_QWORD *)((char *)&v682 + 1) = v641;
          *((_QWORD *)&v682 + 1) = v642;
          v683 = v639;
          v685 = 0;
          v686 = 0;
          v684 = 0;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
          if ( (v684 & 1) != 0 )
          {
            free(v686);
            if ( (v682 & 1) == 0 )
            {
LABEL_1088:
              if ( (v680 & 1) == 0 )
                goto LABEL_1089;
              goto LABEL_1096;
            }
          }
          else if ( (v682 & 1) == 0 )
          {
            goto LABEL_1088;
          }
          free(v683);
          if ( (v680 & 1) == 0 )
          {
LABEL_1089:
            if ( (v678 & 1) == 0 )
              goto LABEL_1090;
            goto LABEL_1097;
          }
LABEL_1096:
          free(v681);
          if ( (v678 & 1) == 0 )
          {
LABEL_1090:
            if ( (v676 & 1) == 0 )
              goto LABEL_1091;
            goto LABEL_1098;
          }
LABEL_1097:
          free(v679);
          if ( (v676 & 1) == 0 )
          {
LABEL_1091:
            if ( (v674 & 1) == 0 )
              goto LABEL_1092;
            goto LABEL_1099;
          }
LABEL_1098:
          free(p);
          if ( (v674 & 1) == 0 )
          {
LABEL_1092:
            if ( (v218 & 1) == 0 )
              return (unsigned __int8 *)v21;
            goto LABEL_1100;
          }
LABEL_1099:
          free(v675);
          if ( (v218 & 1) == 0 )
            return (unsigned __int8 *)v21;
LABEL_1100:
          v243 = v221;
LABEL_818:
          free(v243);
          return (unsigned __int8 *)v21;
        case 'p':
          if ( v5 < 3 || *a1 != 115 || a1[1] != 112 )
            return v4;
          v12 = a1 + 2;
          v13 = sub_47B84(a1 + 2, a2, a3);
          goto LABEL_567;
        case 'r':
          return (unsigned __int8 *)sub_4F704(a1, a2, a3);
        case 't':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 115 )
            return v4;
          if ( a1[1] != 116 )
            return v4;
          v244 = a1 + 2;
          v21 = sub_38008(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v244 )
            return v4;
          v225 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v225 )
            return v4;
          v245 = *(unsigned __int8 *)(v225 - 24);
          v227 = (size_t *)(v225 - 48);
          if ( (v245 & 1) != 0 )
            v228 = *(const void **)(v225 - 8);
          else
            v228 = (const void *)(v225 - 23);
          if ( (v245 & 1) != 0 )
            v229 = *(_QWORD *)(v225 - 16);
          else
            v229 = v245 >> 1;
          goto LABEL_385;
        case 'z':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 115 )
            return v4;
          if ( a1[1] != 122 )
            return v4;
          v224 = a1 + 2;
          v21 = sub_47B84(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v21 == v224 )
            return v4;
          v225 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v225 )
            return v4;
          v226 = *(unsigned __int8 *)(v225 - 24);
          v227 = (size_t *)(v225 - 48);
          if ( (v226 & 1) != 0 )
            v228 = *(const void **)(v225 - 8);
          else
            v228 = (const void *)(v225 - 23);
          if ( (v226 & 1) != 0 )
            v229 = *(_QWORD *)(v225 - 16);
          else
            v229 = v226 >> 1;
LABEL_385:
          sub_42BE4(v227, v228, v229);
          v681 = *(char **)(v225 - 32);
          v680 = *(_OWORD *)(v225 - 48);
          *(_QWORD *)(v225 - 48) = 0;
          *(_QWORD *)(v225 - 40) = 0;
          *(_QWORD *)(v225 - 32) = 0;
          sub_429F4((size_t *)&v680, 0, "sizeof (", 8u);
          v246 = v681;
          v247 = v680;
          v680 = 0u;
          v681 = 0;
          v688 = v246;
          v687 = v247;
          sub_42BE4((size_t *)&v687, ")", 1u);
          goto LABEL_386;
        default:
          return v4;
      }
    case 't':
      switch ( v10[1] )
      {
        case 'e':
        case 'i':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 116 )
            return v4;
          v14 = a1[1];
          if ( v14 != 105 && v14 != 101 )
            return v4;
          v15 = a1 + 2;
          v16 = a1 + 2;
          v17 = v14 == 101 ? sub_47B84(v16, a2, a3) : sub_38008(v16, a2, a3);
          v122 = v17;
          if ( (unsigned __int8 *)v17 == v15 )
            return v4;
          v417 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v417 )
            return v4;
          v418 = *(unsigned __int8 *)(v417 - 24);
          if ( (v418 & 1) != 0 )
            v419 = *(const void **)(v417 - 8);
          else
            v419 = (const void *)(v417 - 23);
          if ( (v418 & 1) != 0 )
            v420 = *(_QWORD *)(v417 - 16);
          else
            v420 = v418 >> 1;
          sub_42BE4((size_t *)(v417 - 48), v419, v420);
          v681 = *(char **)(v417 - 32);
          v680 = *(_OWORD *)(v417 - 48);
          *(_QWORD *)(v417 - 48) = 0;
          *(_QWORD *)(v417 - 40) = 0;
          *(_QWORD *)(v417 - 32) = 0;
          sub_429F4((size_t *)&v680, 0, "typeid(", 7u);
          v421 = v681;
          v422 = v680;
          v680 = 0u;
          v681 = 0;
          v688 = v421;
          v687 = v422;
          sub_42BE4((size_t *)&v687, ")", 1u);
          v423 = *(_QWORD *)((char *)&v687 + 1);
          v424 = *((_QWORD *)&v687 + 1);
          v425 = v688;
          v426 = v687;
          v687 = 0u;
          v688 = 0;
          *(_QWORD *)((char *)&v678 + 7) = v424;
          BYTE7(v678) = HIBYTE(v423);
          LOBYTE(v682) = v426;
          v427 = v423;
          v428 = *(_QWORD *)((char *)&v678 + 7);
          *(_QWORD *)((char *)&v678 + 7) = 0;
          *(_QWORD *)&v678 = 0;
          *(_QWORD *)((char *)&v682 + 1) = v427;
          *((_QWORD *)&v682 + 1) = v428;
          v683 = v425;
          v685 = 0;
          v686 = 0;
          v684 = 0;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
          if ( (v684 & 1) != 0 )
          {
            free(v686);
            if ( (v682 & 1) == 0 )
            {
LABEL_659:
              if ( (v687 & 1) == 0 )
                goto LABEL_660;
              goto LABEL_768;
            }
          }
          else if ( (v682 & 1) == 0 )
          {
            goto LABEL_659;
          }
          free(v683);
          if ( (v687 & 1) == 0 )
          {
LABEL_660:
            if ( (v680 & 1) == 0 )
              return (unsigned __int8 *)v122;
LABEL_769:
            v488 = v681;
            goto LABEL_806;
          }
LABEL_768:
          free(v688);
          if ( (v680 & 1) == 0 )
            return (unsigned __int8 *)v122;
          goto LABEL_769;
        case 'r':
          BYTE8(v687) = 0;
          *(_QWORD *)&v687 = 0;
          *(_QWORD *)((char *)&v682 + 7) = 0;
          *(_QWORD *)&v682 = 0;
          qmemcpy(&v680, "throw", 5);
          v133 = *(_QWORD *)(a3 + 8);
          v134 = *(_QWORD *)(a3 + 16);
          if ( v133 >= v134 )
          {
            v316 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v133 - *(_QWORD *)a3) >> 4);
            v317 = 0x555555555555555LL;
            if ( v316 + 1 > 0x555555555555555LL )
              abort();
            v318 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v134 - *(_QWORD *)a3) >> 4);
            if ( v318 >= 0x2AAAAAAAAAAAAAALL
              || ((v319 = 2 * v318, v319 >= v316 + 1) ? (v317 = v319) : (v317 = v316 + 1), v317) )
            {
              v320 = *(_QWORD *)(a3 + 24);
              v321 = *(char **)(v320 + 4096);
              if ( v320 + 4096 - (__int64)v321 >= (unsigned __int64)(48 * v317) )
                *(_QWORD *)(v320 + 4096) = &v321[48 * v317];
              else
                v321 = (char *)malloc(48 * v317);
            }
            else
            {
              v321 = 0;
            }
            v475 = &v321[48 * v316];
            *v475 = 10;
            v476 = &v321[48 * v317];
            v475[5] = BYTE4(v680);
            v477 = v680;
            v475[6] = 0;
            *(_DWORD *)(v475 + 1) = v477;
            v475[15] = BYTE8(v687);
            v478 = v687;
            *((_QWORD *)v475 + 2) = 0;
            *(_QWORD *)(v475 + 7) = v478;
            BYTE4(v680) = 0;
            LODWORD(v680) = 0;
            BYTE8(v687) = 0;
            *(_QWORD *)&v687 = 0;
            v475[24] = 0;
            *((_QWORD *)v475 + 4) = *(_QWORD *)((char *)&v682 + 7);
            *((_QWORD *)v475 + 5) = 0;
            *(_QWORD *)(v475 + 25) = v682;
            *(_QWORD *)((char *)&v682 + 7) = 0;
            *(_QWORD *)&v682 = 0;
            v480 = *(_QWORD *)a3;
            v479 = *(_QWORD *)(a3 + 8);
            v481 = v475 + 48;
            if ( v479 == *(_QWORD *)a3 )
            {
              v483 = *(void **)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v475 - 4) = *(_QWORD *)(v479 - 32);
                *((_OWORD *)v475 - 3) = *(_OWORD *)(v479 - 48);
                v482 = *(_QWORD *)(v479 - 8);
                *(_QWORD *)(v479 - 40) = 0;
                *(_QWORD *)(v479 - 32) = 0;
                *(_QWORD *)(v479 - 48) = 0;
                *((_QWORD *)v475 - 1) = v482;
                *(_OWORD *)(v475 - 24) = *(_OWORD *)(v479 - 24);
                *(_QWORD *)(v479 - 24) = 0;
                *(_QWORD *)(v479 - 16) = 0;
                *(_QWORD *)(v479 - 8) = 0;
                v479 -= 48;
                v475 -= 48;
              }
              while ( v480 != v479 );
              v483 = *(void **)a3;
              v480 = *(_QWORD *)(a3 + 8);
            }
            v484 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v475;
            *(_QWORD *)(a3 + 8) = v481;
            *(_QWORD *)(a3 + 16) = v476;
            if ( (void *)v480 != v483 )
            {
              do
              {
                if ( (*(_BYTE *)(v480 - 24) & 1) != 0 )
                  free(*(void **)(v480 - 8));
                v485 = (void *)(v480 - 48);
                if ( (*(_BYTE *)(v480 - 48) & 1) != 0 )
                  free(*(void **)(v480 - 32));
                v480 -= 48LL;
              }
              while ( v483 != v485 );
            }
            if ( v483 )
            {
              v486 = *(_QWORD *)(a3 + 24);
              if ( v486 + 4096 < (unsigned __int64)v483 || v486 > (unsigned __int64)v483 )
              {
                free(v483);
              }
              else if ( *(_QWORD *)(v486 + 4096) == v484 )
              {
                *(_QWORD *)(v486 + 4096) = v483;
              }
            }
          }
          else
          {
            *(_BYTE *)v133 = 10;
            *(_BYTE *)(v133 + 5) = BYTE4(v680);
            v135 = v680;
            *(_BYTE *)(v133 + 6) = 0;
            *(_DWORD *)(v133 + 1) = v135;
            *(_BYTE *)(v133 + 15) = BYTE8(v687);
            v136 = v687;
            *(_QWORD *)(v133 + 16) = 0;
            *(_QWORD *)(v133 + 7) = v136;
            BYTE4(v680) = 0;
            LODWORD(v680) = 0;
            BYTE8(v687) = 0;
            *(_QWORD *)&v687 = 0;
            *(_BYTE *)(v133 + 24) = 0;
            *(_QWORD *)(v133 + 32) = *(_QWORD *)((char *)&v682 + 7);
            *(_QWORD *)(v133 + 40) = 0;
            *(_QWORD *)(v133 + 25) = v682;
            *(_QWORD *)((char *)&v682 + 7) = 0;
            *(_QWORD *)&v682 = 0;
            *(_QWORD *)(a3 + 8) += 48LL;
          }
          v4 += 2;
          return v4;
        case 'w':
          if ( v5 < 3 )
            return v4;
          if ( *a1 != 116 )
            return v4;
          if ( a1[1] != 119 )
            return v4;
          v121 = a1 + 2;
          v122 = sub_47B84(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v122 == v121 )
            return v4;
          v123 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v123 )
            return v4;
          v124 = *(unsigned __int8 *)(v123 - 24);
          if ( (v124 & 1) != 0 )
            v125 = *(const void **)(v123 - 8);
          else
            v125 = (const void *)(v123 - 23);
          if ( (v124 & 1) != 0 )
            v126 = *(_QWORD *)(v123 - 16);
          else
            v126 = v124 >> 1;
          sub_42BE4((size_t *)(v123 - 48), v125, v126);
          v688 = *(char **)(v123 - 32);
          v687 = *(_OWORD *)(v123 - 48);
          *(_QWORD *)(v123 - 48) = 0;
          *(_QWORD *)(v123 - 40) = 0;
          *(_QWORD *)(v123 - 32) = 0;
          sub_429F4((size_t *)&v687, 0, "throw ", 6u);
          v127 = *(_QWORD *)((char *)&v687 + 1);
          v128 = *((_QWORD *)&v687 + 1);
          v129 = v688;
          v130 = v687;
          v687 = 0u;
          v688 = 0;
          *(_QWORD *)((char *)&v680 + 7) = v128;
          BYTE7(v680) = HIBYTE(v127);
          LOBYTE(v682) = v130;
          v131 = v127;
          v132 = *(_QWORD *)((char *)&v680 + 7);
          *(_QWORD *)((char *)&v680 + 7) = 0;
          *(_QWORD *)&v680 = 0;
          *(_QWORD *)((char *)&v682 + 1) = v131;
          *((_QWORD *)&v682 + 1) = v132;
          v683 = v129;
          v685 = 0;
          v686 = 0;
          v684 = 0;
          sub_4CB68((unsigned __int8 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)&v682);
          if ( (v684 & 1) != 0 )
          {
            free(v686);
            if ( (v682 & 1) == 0 )
            {
LABEL_208:
              if ( (v687 & 1) == 0 )
                return (unsigned __int8 *)v122;
              goto LABEL_805;
            }
          }
          else if ( (v682 & 1) == 0 )
          {
            goto LABEL_208;
          }
          free(v683);
          if ( (v687 & 1) == 0 )
            return (unsigned __int8 *)v122;
LABEL_805:
          v488 = v688;
LABEL_806:
          free(v488);
          return (unsigned __int8 *)v122;
        default:
          return v4;
      }
    default:
      return v4;
  }
}
// 38008: using guessed type __int64 __fastcall sub_38008(_QWORD, _QWORD, _QWORD);

//----- (000000000004CB68) ----------------------------------------------------
long double __fastcall sub_4CB68(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  size_t v6; // x22
  void *v7; // x0
  void *v8; // x21
  unsigned __int8 *v9; // x0
  __int64 v10; // x22
  _WORD *v11; // x23
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x24
  size_t v14; // x21
  void *v15; // x0
  void *v16; // x20
  unsigned __int8 *v17; // x0
  long double result; // q0

  if ( (*a1 & 1) != 0 )
  {
    **((_BYTE **)a1 + 2) = 0;
    v4 = *a1;
    *((_QWORD *)a1 + 1) = 0;
    if ( (v4 & 1) != 0 )
    {
      v9 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      a1[1] = *v9;
      free(v9);
      *a1 = 0;
    }
    else if ( (unsigned int)v4 >= 0x2E )
    {
      v5 = v4 >> 1;
      v6 = (unsigned __int8)((v4 >> 1) + 16) & 0xF0;
      v7 = malloc(v6);
      v8 = v7;
      if ( v6 - 1 > 0x16 || v7 )
      {
        memcpy(v7, a1 + 1, v5 + 1);
        *(_QWORD *)a1 = v6 | 1;
        *((_QWORD *)a1 + 1) = v5;
        *((_QWORD *)a1 + 2) = v8;
      }
    }
  }
  else
  {
    *(_WORD *)a1 = 0;
  }
  v10 = a2 + 24;
  *((_QWORD *)a1 + 2) = *(_QWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v11 = a1 + 24;
  if ( (a1[24] & 1) != 0 )
  {
    **((_BYTE **)a1 + 5) = 0;
    v12 = a1[24];
    *((_QWORD *)a1 + 4) = 0;
    if ( (v12 & 1) != 0 )
    {
      v17 = (unsigned __int8 *)*((_QWORD *)a1 + 5);
      a1[25] = *v17;
      free(v17);
      a1[24] = 0;
    }
    else if ( (unsigned int)v12 >= 0x2E )
    {
      v13 = v12 >> 1;
      v14 = (unsigned __int8)((v12 >> 1) + 16) & 0xF0;
      v15 = malloc(v14);
      v16 = v15;
      if ( v14 - 1 > 0x16 || v15 )
      {
        memcpy(v15, a1 + 25, v13 + 1);
        *((_QWORD *)a1 + 3) = v14 | 1;
        *((_QWORD *)a1 + 4) = v13;
        *((_QWORD *)a1 + 5) = v16;
      }
    }
  }
  else
  {
    *v11 = 0;
  }
  *((_QWORD *)a1 + 5) = *(_QWORD *)(v10 + 16);
  result = *(long double *)v10;
  *(_OWORD *)v11 = *(_OWORD *)v10;
  *(_QWORD *)v10 = 0;
  *(_QWORD *)(v10 + 8) = 0;
  *(_QWORD *)(v10 + 16) = 0;
  return result;
}

//----- (000000000004CCE0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_4CCE0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3)
{
  unsigned __int8 *v4; // x19
  unsigned __int8 *v6; // x23
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x0
  unsigned __int8 *v9; // x0
  int v10; // t1
  unsigned __int8 *v11; // x22
  unsigned __int8 *v12; // x0
  int v13; // w21
  __int64 v14; // x26
  _BYTE *v15; // x23
  __int64 v16; // x22
  int v17; // w11
  char v18; // w8
  char v19; // w8
  char v20; // w12
  char v21; // w8
  char v22; // w10
  char *v23; // x8
  char *v24; // x9
  char v25; // w11
  bool v26; // cf
  int v27; // w0
  unsigned __int64 *v28; // x27
  size_t v29; // x21
  char *v30; // x22
  unsigned __int8 *v31; // x0
  unsigned __int8 *v32; // x22
  int v33; // w8
  int v34; // w21
  _BYTE *v35; // x23
  __int64 v36; // x22
  int v37; // w11
  char v38; // w8
  char v39; // w8
  char v40; // w12
  char v41; // w8
  char v42; // w10
  char *v43; // x8
  char *v44; // x9
  char v45; // w11
  int v46; // w0
  size_t v47; // x21
  char *v48; // x22
  int v49; // w21
  int v50; // w9
  char v51; // w8
  char v52; // w8
  char v53; // w10
  char v54; // w22
  int v55; // w21
  int v56; // w9
  char v57; // w8
  char v58; // w8
  char v59; // w10
  char v60; // w23
  int v61; // w21
  int v62; // w9
  char v63; // w8
  char v64; // w8
  char v65; // w10
  char v66; // w20
  int v67; // w21
  int v68; // w9
  char v69; // w8
  char v70; // w8
  char v71; // w10
  char v72; // w8
  int v73; // w0
  size_t v74; // x21
  char *v75; // x22
  int v76; // w8
  unsigned __int64 v77; // x8
  unsigned __int64 v78; // x9
  __int64 v79; // x9
  unsigned __int8 *v81; // x23
  unsigned __int8 *v82; // x9
  int v83; // t1
  unsigned __int64 v84; // x21
  unsigned __int64 v85; // x20
  unsigned __int64 v86; // x8
  const void *v87; // x1
  size_t v88; // x2
  void *v89; // x8
  long double v90; // q0
  void *v91; // x8
  long double v92; // q0
  char *v93; // x0
  char *v94; // x8
  unsigned __int64 v95; // x9
  int v96; // w9
  __int64 v97; // x9
  unsigned __int64 v98; // x22
  __int64 v99; // x21
  unsigned __int64 v100; // x9
  unsigned __int64 v101; // x9
  unsigned __int64 v102; // x9
  char *v103; // x0
  unsigned __int64 v104; // x22
  __int64 v105; // x21
  unsigned __int64 v106; // x9
  unsigned __int64 v107; // x9
  unsigned __int64 v108; // x9
  char *v109; // x0
  size_t v110; // x23
  __int64 v111; // x8
  void *v112; // x21
  __int64 v113; // x9
  char v114; // w22
  unsigned __int64 v115; // x8
  unsigned __int64 v116; // x9
  unsigned __int64 v117; // x25
  __int64 v118; // x23
  unsigned __int64 v119; // x9
  unsigned __int64 v120; // x9
  unsigned __int64 v121; // x9
  char *v122; // x0
  size_t v123; // x23
  __int64 v124; // x8
  __int64 v125; // x9
  unsigned __int64 v126; // x9
  __int64 v127; // x9
  __int64 v128; // x9
  unsigned __int64 v129; // x25
  __int64 v130; // x23
  unsigned __int64 v131; // x9
  unsigned __int64 v132; // x9
  unsigned __int64 v133; // x9
  char *v134; // x0
  _OWORD *v135; // x11
  __int128 *v136; // x12
  unsigned __int64 v137; // x13
  __int128 v138; // q0
  __int128 v139; // q1
  char v140; // t1
  char v141; // w22
  void *v142; // x21
  char *v143; // x1
  size_t v144; // x2
  __int64 v145; // x9
  __int64 v146; // x10
  void *v147; // x11
  char v148; // w8
  __int64 v149; // x8
  __int64 v150; // x9
  char *v151; // x8
  char *v152; // x9
  __int64 v153; // x10
  unsigned __int64 v154; // x11
  unsigned __int64 v155; // x22
  unsigned __int64 v156; // x10
  __int64 v157; // x12
  void *v158; // x21
  unsigned __int64 v159; // x23
  void *v160; // x20
  unsigned __int64 v161; // x8
  char *v162; // x8
  char *v163; // x9
  int v164; // w10
  __int64 v165; // x10
  unsigned __int64 v166; // x11
  unsigned __int64 v167; // x22
  unsigned __int64 v168; // x10
  __int64 v169; // x12
  void *v170; // x20
  __int64 v171; // x8
  void *v172; // x21
  __int64 v173; // x9
  char v174; // w22
  unsigned __int64 v175; // x8
  unsigned __int64 v176; // x9
  unsigned __int64 v177; // x25
  __int64 v178; // x23
  unsigned __int64 v179; // x9
  unsigned __int64 v180; // x9
  unsigned __int64 v181; // x9
  char *v182; // x0
  char *v183; // x8
  char *v184; // x9
  unsigned __int64 v185; // x11
  unsigned __int64 v186; // x22
  unsigned __int64 v187; // x10
  __int64 v188; // x12
  void *v189; // x21
  unsigned __int64 v190; // x23
  void *v191; // x20
  unsigned __int64 v192; // x8
  char *v193; // x8
  char *v194; // x9
  unsigned __int64 v195; // x11
  unsigned __int64 v196; // x22
  unsigned __int64 v197; // x10
  __int64 v198; // x12
  void *v199; // x20
  char *v200; // x8
  char *v201; // x9
  unsigned __int64 v202; // x11
  unsigned __int64 v203; // x22
  unsigned __int64 v204; // x10
  __int64 v205; // x12
  void *v206; // x21
  unsigned __int64 v207; // x23
  void *v208; // x20
  unsigned __int64 v209; // x8
  __int64 v212; // [xsp+18h] [xbp-108h]
  long double v213; // [xsp+20h] [xbp-100h] BYREF
  void *v214; // [xsp+30h] [xbp-F0h]
  __int128 v215; // [xsp+38h] [xbp-E8h] BYREF
  char *v216; // [xsp+48h] [xbp-D8h]
  long double v217; // [xsp+50h] [xbp-D0h] BYREF
  void *p; // [xsp+60h] [xbp-C0h]
  _BYTE v219[15]; // [xsp+70h] [xbp-B0h] BYREF
  char s[32]; // [xsp+80h] [xbp-A0h] BYREF
  __int64 v221; // [xsp+A0h] [xbp-80h]
  void *v222; // [xsp+A8h] [xbp-78h]
  long double v223; // [xsp+B0h] [xbp-70h] BYREF
  void *v224; // [xsp+C0h] [xbp-60h]

  v4 = a1;
  v212 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 >= 4 && *a1 == 76 )
  {
    v6 = a1 + 1;
    switch ( a1[1] )
    {
      case 'T':
        return v4;
      case '_':
        if ( a1[2] == 90 )
        {
          v7 = a1 + 3;
          v8 = (unsigned __int8 *)sub_36F74(a1 + 3, a2, a3);
          if ( v8 != v7 && v8 != a2 )
          {
            v10 = *v8;
            v9 = v8 + 1;
            if ( v10 == 69 )
              return v9;
          }
        }
        return v4;
      case 'a':
        *(_DWORD *)&s[12] = 0;
        s[0] = 22;
        v11 = a1 + 2;
        *(_QWORD *)&s[16] = 0;
        strcpy(&s[1], "signed char");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'b':
        if ( a1[3] != 69 )
          return v4;
        v76 = a1[2];
        if ( v76 == 48 )
        {
          BYTE8(v223) = 0;
          *(_QWORD *)&v223 = 0;
          *(_QWORD *)&s[7] = 0;
          *(_QWORD *)s = 0;
          qmemcpy(&v213, "false", 5);
          v77 = a3[1];
          v95 = a3[2];
          if ( v77 < v95 )
          {
            *(_BYTE *)v77 = 10;
            v4 = a1 + 4;
            *(_BYTE *)(v77 + 5) = BYTE4(v213);
            v96 = LODWORD(v213);
            *(_BYTE *)(v77 + 6) = 0;
            *(_DWORD *)(v77 + 1) = v96;
            *(_BYTE *)(v77 + 15) = BYTE8(v223);
            v97 = *(_QWORD *)&v223;
            *(_QWORD *)(v77 + 16) = 0;
            *(_QWORD *)(v77 + 7) = v97;
            BYTE4(v213) = 0;
            LODWORD(v213) = 0;
            BYTE8(v223) = 0;
            goto LABEL_131;
          }
          v104 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v77 - *a3) >> 4);
          v105 = 0x555555555555555LL;
          if ( v104 + 1 > 0x555555555555555LL )
            abort();
          v106 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v95 - *a3) >> 4);
          if ( v106 >= 0x2AAAAAAAAAAAAAALL
            || ((v107 = 2 * v106, v107 >= v104 + 1) ? (v105 = v107) : (v105 = v104 + 1), v105) )
          {
            v108 = a3[3];
            v109 = *(char **)(v108 + 4096);
            if ( v108 + 4096 - (unsigned __int64)v109 >= 48 * v105 )
              *(_QWORD *)(v108 + 4096) = &v109[48 * v105];
            else
              v109 = (char *)malloc(48 * v105);
          }
          else
          {
            v109 = 0;
          }
          v162 = &v109[48 * v104];
          *v162 = 10;
          v163 = &v109[48 * v105];
          v162[5] = BYTE4(v213);
          v164 = LODWORD(v213);
          v162[6] = 0;
          *(_DWORD *)(v162 + 1) = v164;
          v162[15] = BYTE8(v223);
          v165 = *(_QWORD *)&v223;
          *((_QWORD *)v162 + 2) = 0;
          *(_QWORD *)(v162 + 7) = v165;
          BYTE4(v213) = 0;
          LODWORD(v213) = 0;
          BYTE8(v223) = 0;
          *(_QWORD *)&v223 = 0;
          v162[24] = 0;
          *((_QWORD *)v162 + 4) = *(_QWORD *)&s[7];
          *((_QWORD *)v162 + 5) = 0;
          *(_QWORD *)(v162 + 25) = *(_QWORD *)s;
          *(_QWORD *)&s[7] = 0;
          *(_QWORD *)s = 0;
          v167 = *a3;
          v166 = a3[1];
          v168 = (unsigned __int64)(v162 + 48);
          if ( v166 == *a3 )
          {
            v158 = (void *)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v162 - 4) = *(_QWORD *)(v166 - 32);
              *((_OWORD *)v162 - 3) = *(_OWORD *)(v166 - 48);
              v169 = *(_QWORD *)(v166 - 8);
              *(_QWORD *)(v166 - 40) = 0;
              *(_QWORD *)(v166 - 32) = 0;
              *(_QWORD *)(v166 - 48) = 0;
              *((_QWORD *)v162 - 1) = v169;
              *(_OWORD *)(v162 - 24) = *(_OWORD *)(v166 - 24);
              *(_QWORD *)(v166 - 24) = 0;
              *(_QWORD *)(v166 - 16) = 0;
              *(_QWORD *)(v166 - 8) = 0;
              v166 -= 48LL;
              v162 -= 48;
            }
            while ( v167 != v166 );
            v158 = (void *)*a3;
            v167 = a3[1];
          }
          v159 = a3[2];
          *a3 = (unsigned __int64)v162;
          a3[1] = v168;
          a3[2] = (unsigned __int64)v163;
          if ( (void *)v167 != v158 )
          {
            do
            {
              if ( (*(_BYTE *)(v167 - 24) & 1) != 0 )
                free(*(void **)(v167 - 8));
              v170 = (void *)(v167 - 48);
              if ( (*(_BYTE *)(v167 - 48) & 1) != 0 )
                free(*(void **)(v167 - 32));
              v167 -= 48LL;
            }
            while ( v158 != v170 );
          }
          if ( !v158 )
            goto LABEL_233;
          v161 = a3[3];
          if ( v161 + 4096 < (unsigned __int64)v158 || v161 > (unsigned __int64)v158 )
            goto LABEL_232;
        }
        else
        {
          if ( v76 != 49 )
            return v4;
          WORD4(v223) = 0;
          *(_QWORD *)&v223 = 0;
          *(_QWORD *)&s[7] = 0;
          *(_QWORD *)s = 0;
          v77 = a3[1];
          v78 = a3[2];
          if ( v77 < v78 )
          {
            *(_BYTE *)v77 = 8;
            strcpy((char *)(v77 + 1), "true");
            v4 = a1 + 4;
            *(_WORD *)(v77 + 14) = WORD4(v223);
            v79 = *(_QWORD *)&v223;
            *(_QWORD *)(v77 + 16) = 0;
            *(_QWORD *)(v77 + 6) = v79;
            WORD4(v223) = 0;
LABEL_131:
            *(_QWORD *)&v223 = 0;
            *(_BYTE *)(v77 + 24) = 0;
            *(_QWORD *)(v77 + 32) = *(_QWORD *)&s[7];
            *(_QWORD *)(v77 + 40) = 0;
            *(_QWORD *)(v77 + 25) = *(_QWORD *)s;
            *(_QWORD *)&s[7] = 0;
            *(_QWORD *)s = 0;
            a3[1] += 48LL;
            return v4;
          }
          v98 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v77 - *a3) >> 4);
          v99 = 0x555555555555555LL;
          if ( v98 + 1 > 0x555555555555555LL )
            abort();
          v100 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v78 - *a3) >> 4);
          if ( v100 >= 0x2AAAAAAAAAAAAAALL || ((v101 = 2 * v100, v101 >= v98 + 1) ? (v99 = v101) : (v99 = v98 + 1), v99) )
          {
            v102 = a3[3];
            v103 = *(char **)(v102 + 4096);
            if ( v102 + 4096 - (unsigned __int64)v103 >= 48 * v99 )
              *(_QWORD *)(v102 + 4096) = &v103[48 * v99];
            else
              v103 = (char *)malloc(48 * v99);
          }
          else
          {
            v103 = 0;
          }
          v151 = &v103[48 * v98];
          *v151 = 8;
          strcpy(v151 + 1, "true");
          v152 = &v103[48 * v99];
          *((_WORD *)v151 + 7) = WORD4(v223);
          v153 = *(_QWORD *)&v223;
          *((_QWORD *)v151 + 2) = 0;
          *(_QWORD *)(v151 + 6) = v153;
          WORD4(v223) = 0;
          *(_QWORD *)&v223 = 0;
          v151[24] = 0;
          *((_QWORD *)v151 + 4) = *(_QWORD *)&s[7];
          *((_QWORD *)v151 + 5) = 0;
          *(_QWORD *)(v151 + 25) = *(_QWORD *)s;
          *(_QWORD *)&s[7] = 0;
          *(_QWORD *)s = 0;
          v155 = *a3;
          v154 = a3[1];
          v156 = (unsigned __int64)(v151 + 48);
          if ( v154 == *a3 )
          {
            v158 = (void *)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v151 - 4) = *(_QWORD *)(v154 - 32);
              *((_OWORD *)v151 - 3) = *(_OWORD *)(v154 - 48);
              v157 = *(_QWORD *)(v154 - 8);
              *(_QWORD *)(v154 - 40) = 0;
              *(_QWORD *)(v154 - 32) = 0;
              *(_QWORD *)(v154 - 48) = 0;
              *((_QWORD *)v151 - 1) = v157;
              *(_OWORD *)(v151 - 24) = *(_OWORD *)(v154 - 24);
              *(_QWORD *)(v154 - 24) = 0;
              *(_QWORD *)(v154 - 16) = 0;
              *(_QWORD *)(v154 - 8) = 0;
              v154 -= 48LL;
              v151 -= 48;
            }
            while ( v155 != v154 );
            v158 = (void *)*a3;
            v155 = a3[1];
          }
          v159 = a3[2];
          *a3 = (unsigned __int64)v151;
          a3[1] = v156;
          a3[2] = (unsigned __int64)v152;
          if ( (void *)v155 != v158 )
          {
            do
            {
              if ( (*(_BYTE *)(v155 - 24) & 1) != 0 )
                free(*(void **)(v155 - 8));
              v160 = (void *)(v155 - 48);
              if ( (*(_BYTE *)(v155 - 48) & 1) != 0 )
                free(*(void **)(v155 - 32));
              v155 -= 48LL;
            }
            while ( v158 != v160 );
          }
          if ( !v158 )
            goto LABEL_233;
          v161 = a3[3];
          if ( v161 + 4096 < (unsigned __int64)v158 || v161 > (unsigned __int64)v158 )
          {
LABEL_232:
            free(v158);
            goto LABEL_233;
          }
        }
        if ( *(_QWORD *)(v161 + 4096) == v159 )
        {
          *(_QWORD *)(v161 + 4096) = v158;
          v4 += 4;
          return v4;
        }
LABEL_233:
        v4 += 4;
        return v4;
      case 'c':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 0x7261686308LL;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'd':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 0x11 )
          return v4;
        v13 = a1[2];
        v14 = 0;
        v15 = a1 + 3;
        v16 = -1;
        do
        {
          if ( !isxdigit(v13) )
            return v4;
          v17 = (unsigned __int8)v15[v14];
          if ( (unsigned int)(v13 - 48) >= 0xA )
            v18 = 9;
          else
            v18 = 0;
          v19 = v18 + v13;
          if ( (unsigned int)(v17 - 48) >= 0xA )
            v20 = -87;
          else
            v20 = -48;
          v21 = v17 + 16 * v19 + v20;
          *((_BYTE *)&v213 + v16 + 1) = v21;
          v13 = (unsigned __int8)v15[v14 + 1];
          v14 += 2;
          ++v16;
        }
        while ( v14 != 16 );
        if ( v13 != 69 )
          return v4;
        if ( (long double *)((char *)&v213 + v16) > &v213 && v16 != -1 )
        {
          v22 = LOBYTE(v213);
          LOBYTE(v213) = v21;
          *((_BYTE *)&v213 + v16) = v22;
          if ( v16 >= 3 )
          {
            v23 = (char *)&v213 + v16 - 1;
            v24 = (char *)&v213 + 2;
            do
            {
              v25 = *(v24 - 1);
              *(v24 - 1) = *v23;
              *v23-- = v25;
              v26 = v24++ >= v23;
            }
            while ( !v26 );
          }
        }
        memset(s, 0, sizeof(s));
        v27 = snprintf(s, 0x20u, "%a", *(double *)&v213);
        v28 = a3;
        if ( (unsigned int)v27 > 0x1F )
          return v4;
        v29 = v27;
        *(_OWORD *)&v223 = 0u;
        v224 = 0;
        if ( (unsigned int)v27 >= 0x17 )
        {
          v110 = (v27 + 16LL) & 0xFFFFFFFFFFFFFFF0LL;
          v30 = (char *)malloc(v110);
          *((_QWORD *)&v223 + 1) = v29;
          v224 = v30;
          *(_QWORD *)&v223 = v110 | 1;
        }
        else
        {
          v30 = (char *)&v223 + 1;
          LOBYTE(v223) = 2 * v27;
          if ( !v27 )
            goto LABEL_152;
        }
        memcpy(v30, s, v29);
LABEL_152:
        v30[v29] = 0;
        v111 = *((_QWORD *)&v223 + 1);
        v112 = v224;
        v113 = *(_QWORD *)((char *)&v223 + 1);
        *(_QWORD *)((char *)&v215 + 7) = 0;
        *(_QWORD *)&v215 = 0;
        v114 = LOBYTE(v223);
        v224 = 0;
        *(_OWORD *)&v223 = 0u;
        *(_QWORD *)((char *)&v217 + 7) = v111;
        *(_QWORD *)&v217 = v113;
        v115 = a3[1];
        v116 = a3[2];
        if ( v115 < v116 )
          goto LABEL_164;
        v117 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v115 - *a3) >> 4);
        v118 = 0x555555555555555LL;
        if ( v117 + 1 > 0x555555555555555LL )
          abort();
        v119 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v116 - *a3) >> 4);
        if ( v119 >= 0x2AAAAAAAAAAAAAALL
          || ((v120 = 2 * v119, v120 >= v117 + 1) ? (v118 = v120) : (v118 = v117 + 1), v118) )
        {
          v121 = a3[3];
          v122 = *(char **)(v121 + 4096);
          if ( v121 + 4096 - (unsigned __int64)v122 >= 48 * v118 )
            *(_QWORD *)(v121 + 4096) = &v122[48 * v118];
          else
            v122 = (char *)malloc(48 * v118);
        }
        else
        {
          v122 = 0;
        }
        v183 = &v122[48 * v117];
        *v183 = v114;
        v184 = &v122[48 * v118];
        *((_QWORD *)v183 + 1) = *(_QWORD *)((char *)&v217 + 7);
        *((_QWORD *)v183 + 2) = v112;
        *(_QWORD *)(v183 + 1) = *(_QWORD *)&v217;
        *(_QWORD *)((char *)&v217 + 7) = 0;
        *(_QWORD *)&v217 = 0;
        v183[24] = 0;
        *((_QWORD *)v183 + 4) = *(_QWORD *)((char *)&v215 + 7);
        *((_QWORD *)v183 + 5) = 0;
        *(_QWORD *)(v183 + 25) = v215;
        *(_QWORD *)((char *)&v215 + 7) = 0;
        *(_QWORD *)&v215 = 0;
        v186 = *a3;
        v185 = a3[1];
        v187 = (unsigned __int64)(v183 + 48);
        if ( v185 == *a3 )
        {
          v189 = (void *)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v183 - 4) = *(_QWORD *)(v185 - 32);
            *((_OWORD *)v183 - 3) = *(_OWORD *)(v185 - 48);
            v188 = *(_QWORD *)(v185 - 8);
            *(_QWORD *)(v185 - 40) = 0;
            *(_QWORD *)(v185 - 32) = 0;
            *(_QWORD *)(v185 - 48) = 0;
            *((_QWORD *)v183 - 1) = v188;
            *(_OWORD *)(v183 - 24) = *(_OWORD *)(v185 - 24);
            *(_QWORD *)(v185 - 24) = 0;
            *(_QWORD *)(v185 - 16) = 0;
            *(_QWORD *)(v185 - 8) = 0;
            v185 -= 48LL;
            v183 -= 48;
          }
          while ( v186 != v185 );
          v189 = (void *)*a3;
          v186 = a3[1];
        }
        v190 = a3[2];
        *a3 = (unsigned __int64)v183;
        a3[1] = v187;
        a3[2] = (unsigned __int64)v184;
        if ( (void *)v186 != v189 )
        {
          do
          {
            if ( (*(_BYTE *)(v186 - 24) & 1) != 0 )
              free(*(void **)(v186 - 8));
            v191 = (void *)(v186 - 48);
            if ( (*(_BYTE *)(v186 - 48) & 1) != 0 )
              free(*(void **)(v186 - 32));
            v186 -= 48LL;
          }
          while ( v189 != v191 );
        }
        if ( !v189 )
          goto LABEL_282;
        v192 = a3[3];
        if ( v192 + 4096 >= (unsigned __int64)v189 && v192 <= (unsigned __int64)v189 )
          goto LABEL_278;
        goto LABEL_281;
      case 'e':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 0x21 )
          return v4;
        v34 = a1[2];
        v14 = 0;
        v35 = a1 + 3;
        v36 = -1;
        do
        {
          if ( !isxdigit(v34) )
            return v4;
          v37 = (unsigned __int8)v35[v14];
          if ( (unsigned int)(v34 - 48) >= 0xA )
            v38 = 9;
          else
            v38 = 0;
          v39 = v38 + v34;
          if ( (unsigned int)(v37 - 48) >= 0xA )
            v40 = -87;
          else
            v40 = -48;
          v41 = v37 + 16 * v39 + v40;
          *((_BYTE *)&v213 + v36 + 1) = v41;
          v34 = (unsigned __int8)v35[v14 + 1];
          v14 += 2;
          ++v36;
        }
        while ( v14 != 32 );
        if ( v34 != 69 )
          return v4;
        if ( (long double *)((char *)&v213 + v36) > &v213 && v36 != -1 )
        {
          v42 = LOBYTE(v213);
          LOBYTE(v213) = v41;
          *((_BYTE *)&v213 + v36) = v42;
          if ( v36 >= 3 )
          {
            v43 = (char *)&v213 + v36 - 1;
            v44 = (char *)&v213 + 2;
            do
            {
              v45 = *(v44 - 1);
              *(v44 - 1) = *v43;
              *v43-- = v45;
              v26 = v44++ >= v43;
            }
            while ( !v26 );
          }
        }
        v221 = 0;
        memset(s, 0, sizeof(s));
        v46 = snprintf(s, 0x28u, "%LaL", v213);
        v28 = a3;
        if ( (unsigned int)v46 > 0x27 )
          return v4;
        v47 = v46;
        *(_OWORD *)&v223 = 0u;
        v224 = 0;
        if ( (unsigned int)v46 >= 0x17 )
        {
          v123 = (v46 + 16LL) & 0xFFFFFFFFFFFFFFF0LL;
          v48 = (char *)malloc(v123);
          *((_QWORD *)&v223 + 1) = v47;
          v224 = v48;
          *(_QWORD *)&v223 = v123 | 1;
        }
        else
        {
          v48 = (char *)&v223 + 1;
          LOBYTE(v223) = 2 * v46;
          if ( !v46 )
          {
LABEL_163:
            v48[v47] = 0;
            v124 = *((_QWORD *)&v223 + 1);
            v112 = v224;
            v125 = *(_QWORD *)((char *)&v223 + 1);
            *(_QWORD *)((char *)&v215 + 7) = 0;
            *(_QWORD *)&v215 = 0;
            v114 = LOBYTE(v223);
            v224 = 0;
            *(_OWORD *)&v223 = 0u;
            *(_QWORD *)((char *)&v217 + 7) = v124;
            *(_QWORD *)&v217 = v125;
            v115 = a3[1];
            v126 = a3[2];
            if ( v115 < v126 )
            {
LABEL_164:
              *(_BYTE *)v115 = v114;
              *(_QWORD *)(v115 + 8) = *(_QWORD *)((char *)&v217 + 7);
              v127 = *(_QWORD *)&v217;
              *(_QWORD *)(v115 + 16) = v112;
              *(_QWORD *)(v115 + 1) = v127;
              *(_QWORD *)((char *)&v217 + 7) = 0;
              *(_QWORD *)&v217 = 0;
              *(_BYTE *)(v115 + 24) = 0;
              *(_QWORD *)(v115 + 32) = *(_QWORD *)((char *)&v215 + 7);
              v128 = v215;
              *(_QWORD *)(v115 + 40) = 0;
              *(_QWORD *)(v115 + 25) = v128;
              *(_QWORD *)((char *)&v215 + 7) = 0;
              *(_QWORD *)&v215 = 0;
              v28[1] += 48LL;
              if ( (LOBYTE(v223) & 1) == 0 )
                goto LABEL_284;
              goto LABEL_283;
            }
            v129 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v115 - *a3) >> 4);
            v130 = 0x555555555555555LL;
            if ( v129 + 1 > 0x555555555555555LL )
              abort();
            v131 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v126 - *a3) >> 4);
            if ( v131 >= 0x2AAAAAAAAAAAAAALL
              || ((v132 = 2 * v131, v132 >= v129 + 1) ? (v130 = v132) : (v130 = v129 + 1), v130) )
            {
              v133 = a3[3];
              v134 = *(char **)(v133 + 4096);
              if ( v133 + 4096 - (unsigned __int64)v134 >= 48 * v130 )
                *(_QWORD *)(v133 + 4096) = &v134[48 * v130];
              else
                v134 = (char *)malloc(48 * v130);
            }
            else
            {
              v134 = 0;
            }
            v193 = &v134[48 * v129];
            *v193 = v114;
            v194 = &v134[48 * v130];
            *((_QWORD *)v193 + 1) = *(_QWORD *)((char *)&v217 + 7);
            *((_QWORD *)v193 + 2) = v112;
            *(_QWORD *)(v193 + 1) = *(_QWORD *)&v217;
            *(_QWORD *)((char *)&v217 + 7) = 0;
            *(_QWORD *)&v217 = 0;
            v193[24] = 0;
            *((_QWORD *)v193 + 4) = *(_QWORD *)((char *)&v215 + 7);
            *((_QWORD *)v193 + 5) = 0;
            *(_QWORD *)(v193 + 25) = v215;
            *(_QWORD *)((char *)&v215 + 7) = 0;
            *(_QWORD *)&v215 = 0;
            v196 = *a3;
            v195 = a3[1];
            v197 = (unsigned __int64)(v193 + 48);
            if ( v195 == *a3 )
            {
              v189 = (void *)*a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v193 - 4) = *(_QWORD *)(v195 - 32);
                *((_OWORD *)v193 - 3) = *(_OWORD *)(v195 - 48);
                v198 = *(_QWORD *)(v195 - 8);
                *(_QWORD *)(v195 - 40) = 0;
                *(_QWORD *)(v195 - 32) = 0;
                *(_QWORD *)(v195 - 48) = 0;
                *((_QWORD *)v193 - 1) = v198;
                *(_OWORD *)(v193 - 24) = *(_OWORD *)(v195 - 24);
                *(_QWORD *)(v195 - 24) = 0;
                *(_QWORD *)(v195 - 16) = 0;
                *(_QWORD *)(v195 - 8) = 0;
                v195 -= 48LL;
                v193 -= 48;
              }
              while ( v196 != v195 );
              v189 = (void *)*a3;
              v196 = a3[1];
            }
            v190 = a3[2];
            *a3 = (unsigned __int64)v193;
            a3[1] = v197;
            a3[2] = (unsigned __int64)v194;
            if ( (void *)v196 != v189 )
            {
              do
              {
                if ( (*(_BYTE *)(v196 - 24) & 1) != 0 )
                  free(*(void **)(v196 - 8));
                v199 = (void *)(v196 - 48);
                if ( (*(_BYTE *)(v196 - 48) & 1) != 0 )
                  free(*(void **)(v196 - 32));
                v196 -= 48LL;
              }
              while ( v189 != v199 );
            }
            if ( v189 )
            {
              v192 = a3[3];
              if ( v192 + 4096 < (unsigned __int64)v189 || v192 > (unsigned __int64)v189 )
              {
LABEL_281:
                free(v189);
              }
              else
              {
LABEL_278:
                if ( *(_QWORD *)(v192 + 4096) == v190 )
                {
                  *(_QWORD *)(v192 + 4096) = v189;
                  if ( (LOBYTE(v223) & 1) == 0 )
                    goto LABEL_284;
                  goto LABEL_283;
                }
              }
            }
LABEL_282:
            if ( (LOBYTE(v223) & 1) == 0 )
            {
LABEL_284:
              v4 += v14 + 3;
              return v4;
            }
LABEL_283:
            free(v224);
            goto LABEL_284;
          }
        }
        memcpy(v48, s, v47);
        goto LABEL_163;
      case 'f':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 9 )
          return v4;
        v49 = a1[2];
        if ( !isxdigit(v49) )
          return v4;
        v50 = v4[3];
        v51 = (unsigned int)(v49 - 48) >= 0xA ? 9 : 0;
        v52 = v51 + v49;
        v53 = (unsigned int)(v50 - 48) >= 0xA ? -87 : -48;
        v54 = v50 + 16 * v52 + v53;
        LOBYTE(v213) = v54;
        v55 = v4[4];
        if ( !isxdigit(v55) )
          return v4;
        v56 = v4[5];
        v57 = (unsigned int)(v55 - 48) >= 0xA ? 9 : 0;
        v58 = v57 + v55;
        v59 = (unsigned int)(v56 - 48) >= 0xA ? -87 : -48;
        v60 = v56 + 16 * v58 + v59;
        BYTE1(v213) = v60;
        v61 = v4[6];
        if ( !isxdigit(v61) )
          return v4;
        v62 = v4[7];
        v63 = (unsigned int)(v61 - 48) >= 0xA ? 9 : 0;
        v64 = v63 + v61;
        v65 = (unsigned int)(v62 - 48) >= 0xA ? -87 : -48;
        v66 = v62 + 16 * v64 + v65;
        BYTE2(v213) = v66;
        v67 = v4[8];
        if ( !isxdigit(v67) )
          return v4;
        v68 = v4[9];
        v69 = (unsigned int)(v67 - 48) >= 0xA ? 9 : 0;
        v70 = v69 + v67;
        v71 = (unsigned int)(v68 - 48) >= 0xA ? -87 : -48;
        v72 = v68 + 16 * v70 + v71;
        BYTE3(v213) = v72;
        if ( v4[10] != 69 )
          return v4;
        LOBYTE(v213) = v72;
        BYTE3(v213) = v54;
        BYTE1(v213) = v66;
        BYTE2(v213) = v60;
        memset(s, 0, 24);
        v73 = snprintf(s, 0x18u, "%af", *(float *)&v213);
        if ( (unsigned int)v73 > 0x17 )
          return v4;
        v74 = v73;
        *(_OWORD *)&v223 = 0u;
        v224 = 0;
        if ( v73 == 23 )
        {
          v75 = (char *)malloc(0x20u);
          *((_QWORD *)&v223 + 1) = v74;
          v224 = v75;
          *(_QWORD *)&v223 = 33;
        }
        else
        {
          v75 = (char *)&v223 + 1;
          LOBYTE(v223) = 2 * v73;
          if ( !v73 )
            goto LABEL_238;
        }
        memcpy(v75, s, v74);
LABEL_238:
        v75[v74] = 0;
        v171 = *((_QWORD *)&v223 + 1);
        v172 = v224;
        v173 = *(_QWORD *)((char *)&v223 + 1);
        *(_QWORD *)((char *)&v215 + 7) = 0;
        *(_QWORD *)&v215 = 0;
        v174 = LOBYTE(v223);
        v224 = 0;
        *(_OWORD *)&v223 = 0u;
        *(_QWORD *)((char *)&v217 + 7) = v171;
        *(_QWORD *)&v217 = v173;
        v175 = a3[1];
        v176 = a3[2];
        if ( v175 < v176 )
        {
          *(_BYTE *)v175 = v174;
          *(_QWORD *)(v175 + 8) = *(_QWORD *)((char *)&v217 + 7);
          *(_QWORD *)(v175 + 16) = v172;
          *(_QWORD *)(v175 + 1) = *(_QWORD *)&v217;
          *(_QWORD *)((char *)&v217 + 7) = 0;
          *(_QWORD *)&v217 = 0;
          *(_BYTE *)(v175 + 24) = 0;
          *(_QWORD *)(v175 + 32) = *(_QWORD *)((char *)&v215 + 7);
          *(_QWORD *)(v175 + 40) = 0;
          *(_QWORD *)(v175 + 25) = v215;
          *(_QWORD *)((char *)&v215 + 7) = 0;
          *(_QWORD *)&v215 = 0;
          a3[1] += 48LL;
          if ( (LOBYTE(v223) & 1) == 0 )
            goto LABEL_306;
          goto LABEL_305;
        }
        v177 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v175 - *a3) >> 4);
        v178 = 0x555555555555555LL;
        if ( v177 + 1 > 0x555555555555555LL )
          abort();
        v179 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v176 - *a3) >> 4);
        if ( v179 >= 0x2AAAAAAAAAAAAAALL
          || ((v180 = 2 * v179, v180 >= v177 + 1) ? (v178 = v180) : (v178 = v177 + 1), v178) )
        {
          v181 = a3[3];
          v182 = *(char **)(v181 + 4096);
          if ( v181 + 4096 - (unsigned __int64)v182 >= 48 * v178 )
            *(_QWORD *)(v181 + 4096) = &v182[48 * v178];
          else
            v182 = (char *)malloc(48 * v178);
        }
        else
        {
          v182 = 0;
        }
        v200 = &v182[48 * v177];
        *v200 = v174;
        v201 = &v182[48 * v178];
        *((_QWORD *)v200 + 1) = *(_QWORD *)((char *)&v217 + 7);
        *((_QWORD *)v200 + 2) = v172;
        *(_QWORD *)(v200 + 1) = *(_QWORD *)&v217;
        *(_QWORD *)((char *)&v217 + 7) = 0;
        *(_QWORD *)&v217 = 0;
        v200[24] = 0;
        *((_QWORD *)v200 + 4) = *(_QWORD *)((char *)&v215 + 7);
        *((_QWORD *)v200 + 5) = 0;
        *(_QWORD *)(v200 + 25) = v215;
        *(_QWORD *)((char *)&v215 + 7) = 0;
        *(_QWORD *)&v215 = 0;
        v203 = *a3;
        v202 = a3[1];
        v204 = (unsigned __int64)(v200 + 48);
        if ( v202 == *a3 )
        {
          v206 = (void *)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v200 - 4) = *(_QWORD *)(v202 - 32);
            *((_OWORD *)v200 - 3) = *(_OWORD *)(v202 - 48);
            v205 = *(_QWORD *)(v202 - 8);
            *(_QWORD *)(v202 - 40) = 0;
            *(_QWORD *)(v202 - 32) = 0;
            *(_QWORD *)(v202 - 48) = 0;
            *((_QWORD *)v200 - 1) = v205;
            *(_OWORD *)(v200 - 24) = *(_OWORD *)(v202 - 24);
            *(_QWORD *)(v202 - 24) = 0;
            *(_QWORD *)(v202 - 16) = 0;
            *(_QWORD *)(v202 - 8) = 0;
            v202 -= 48LL;
            v200 -= 48;
          }
          while ( v203 != v202 );
          v206 = (void *)*a3;
          v203 = a3[1];
        }
        v207 = a3[2];
        *a3 = (unsigned __int64)v200;
        a3[1] = v204;
        a3[2] = (unsigned __int64)v201;
        if ( (void *)v203 != v206 )
        {
          do
          {
            if ( (*(_BYTE *)(v203 - 24) & 1) != 0 )
              free(*(void **)(v203 - 8));
            v208 = (void *)(v203 - 48);
            if ( (*(_BYTE *)(v203 - 48) & 1) != 0 )
              free(*(void **)(v203 - 32));
            v203 -= 48LL;
          }
          while ( v206 != v208 );
        }
        if ( !v206 )
          goto LABEL_304;
        v209 = a3[3];
        if ( v209 + 4096 < (unsigned __int64)v206 || v209 > (unsigned __int64)v206 )
        {
          free(v206);
        }
        else if ( *(_QWORD *)(v209 + 4096) == v207 )
        {
          *(_QWORD *)(v209 + 4096) = v206;
          if ( (LOBYTE(v223) & 1) == 0 )
            goto LABEL_306;
          goto LABEL_305;
        }
LABEL_304:
        if ( (LOBYTE(v223) & 1) == 0 )
          goto LABEL_306;
LABEL_305:
        free(v224);
LABEL_306:
        v4 += 11;
        return v4;
      case 'h':
        v11 = a1 + 2;
        s[15] = 0;
        *(_QWORD *)&s[16] = 0;
        s[0] = 26;
        strcpy(&s[1], "unsigned char");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'i':
        v11 = a1 + 2;
        memset(s, 0, 24);
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'j':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 29954;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'l':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 27650;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'm':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 7107844;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'n':
        v11 = a1 + 2;
        s[9] = 0;
        *(_WORD *)&s[10] = 0;
        *(_DWORD *)&s[12] = 0;
        *(_QWORD *)&s[16] = 0;
        s[0] = 16;
        strcpy(&s[1], "__int12");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'o':
        v11 = a1 + 2;
        strcpy(&s[17], "8");
        s[19] = 0;
        *(_DWORD *)&s[20] = 0;
        strcpy(s, "\"unsigned __int1");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 's':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 0x74726F68730ALL;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 't':
        v11 = a1 + 2;
        *(_QWORD *)&s[16] = 0;
        s[0] = 28;
        strcpy(&s[1], "unsigned short");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'w':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        s[0] = 14;
        strcpy(&s[1], "wchar_t");
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'x':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 7105540;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
        goto LABEL_108;
      case 'y':
        v11 = a1 + 2;
        *(_QWORD *)&s[8] = 0;
        *(_QWORD *)&s[16] = 0;
        *(_QWORD *)s = 1819047174;
        v12 = sub_50168(a1 + 2, a2, (unsigned __int8 *)s, a3);
LABEL_108:
        if ( v12 != v11 )
          return v12;
        return v4;
      default:
        v31 = (unsigned __int8 *)sub_38008(a1 + 1, a2, a3);
        v32 = v31;
        if ( v31 == v6 || v31 == a2 )
          return v4;
        v33 = *v31;
        if ( v33 == 69 )
          return v31 + 1;
        v81 = v31;
        if ( (unsigned int)(v33 - 48) > 9 )
          goto LABEL_116;
        v82 = v31 + 1;
        do
        {
          if ( a2 == v82 )
            return v4;
          v83 = *v82++;
          v33 = v83;
        }
        while ( (unsigned int)(v83 - 48) < 0xA );
        v81 = v82 - 1;
LABEL_116:
        v84 = v81 - v31;
        if ( v81 == v31 )
          return v4;
        if ( v33 != 69 )
          return v4;
        v85 = a3[1];
        if ( *a3 == v85 )
          return v4;
        v86 = *(unsigned __int8 *)(v85 - 24);
        if ( (v86 & 1) != 0 )
          v87 = *(const void **)(v85 - 8);
        else
          v87 = (const void *)(v85 - 23);
        if ( (v86 & 1) != 0 )
          v88 = *(_QWORD *)(v85 - 16);
        else
          v88 = v86 >> 1;
        sub_42BE4((size_t *)(v85 - 48), v87, v88);
        p = *(void **)(v85 - 32);
        v217 = *(long double *)(v85 - 48);
        *(_QWORD *)(v85 - 48) = 0;
        *(_QWORD *)(v85 - 40) = 0;
        *(_QWORD *)(v85 - 32) = 0;
        sub_429F4((size_t *)&v217, 0, "(", 1u);
        v89 = p;
        v90 = v217;
        *(_OWORD *)&v217 = 0u;
        p = 0;
        v214 = v89;
        v213 = v90;
        sub_42BE4((size_t *)&v213, ")", 1u);
        v91 = v214;
        v92 = v213;
        *(_OWORD *)&v213 = 0u;
        v214 = 0;
        v215 = 0u;
        v224 = v91;
        v223 = v92;
        v216 = 0;
        if ( v84 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        if ( v84 > 0x16 )
        {
          v93 = (char *)malloc((v84 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          *((_QWORD *)&v215 + 1) = v81 - v32;
          v216 = v93;
          *(_QWORD *)&v215 = (v84 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          if ( v84 >= 0x20 )
          {
            if ( v93 >= (char *)v81 || (v94 = v93, v32 >= &v81[v93 - (char *)v32]) )
            {
              v135 = v93 + 16;
              v94 = &v93[v84 & 0xFFFFFFFFFFFFFFE0LL];
              v136 = (__int128 *)(v32 + 16);
              v137 = v84 & 0xFFFFFFFFFFFFFFE0LL;
              do
              {
                v138 = *(v136 - 1);
                v139 = *v136;
                v137 -= 32LL;
                v136 += 2;
                *(v135 - 1) = v138;
                *v135 = v139;
                v135 += 2;
              }
              while ( v137 );
              v32 += v84 & 0xFFFFFFFFFFFFFFE0LL;
              if ( (v84 & 0xFFFFFFFFFFFFFFE0LL) == v84 )
              {
LABEL_181:
                v93[v84] = 0;
                v141 = v215;
                v142 = v216;
                if ( (v215 & 1) != 0 )
                  v143 = v216;
                else
                  v143 = (char *)&v215 + 1;
                if ( (v215 & 1) != 0 )
                  v144 = *((_QWORD *)&v215 + 1);
                else
                  v144 = (unsigned __int64)(unsigned __int8)v215 >> 1;
                sub_42BE4((size_t *)&v223, v143, v144);
                v145 = *(_QWORD *)((char *)&v223 + 1);
                v146 = *((_QWORD *)&v223 + 1);
                v147 = v224;
                v148 = LOBYTE(v223);
                *(_OWORD *)&v223 = 0u;
                v224 = 0;
                *(_QWORD *)&v219[7] = v146;
                v219[7] = HIBYTE(v145);
                s[0] = v148;
                v149 = v145;
                v150 = *(_QWORD *)&v219[7];
                memset(v219, 0, sizeof(v219));
                *(_QWORD *)&s[1] = v149;
                *(_QWORD *)&s[8] = v150;
                *(_QWORD *)&s[16] = v147;
                v221 = 0;
                v222 = 0;
                *(_QWORD *)&s[24] = 0;
                sub_4CB68((unsigned __int8 *)(a3[1] - 48), (__int64)s);
                if ( (s[24] & 1) != 0 )
                {
                  free(v222);
                  if ( (s[0] & 1) == 0 )
                  {
LABEL_189:
                    if ( (v141 & 1) == 0 )
                      goto LABEL_190;
                    goto LABEL_197;
                  }
                }
                else if ( (s[0] & 1) == 0 )
                {
                  goto LABEL_189;
                }
                free(*(void **)&s[16]);
                if ( (v141 & 1) == 0 )
                {
LABEL_190:
                  if ( (LOBYTE(v223) & 1) == 0 )
                    goto LABEL_191;
                  goto LABEL_198;
                }
LABEL_197:
                free(v142);
                if ( (LOBYTE(v223) & 1) == 0 )
                {
LABEL_191:
                  if ( (LOBYTE(v213) & 1) == 0 )
                    goto LABEL_192;
                  goto LABEL_199;
                }
LABEL_198:
                free(v224);
                if ( (LOBYTE(v213) & 1) == 0 )
                {
LABEL_192:
                  if ( (LOBYTE(v217) & 1) == 0 )
                    return v81 + 1;
LABEL_193:
                  free(p);
                  return v81 + 1;
                }
LABEL_199:
                free(v214);
                if ( (LOBYTE(v217) & 1) == 0 )
                  return v81 + 1;
                goto LABEL_193;
              }
            }
            do
            {
LABEL_180:
              v140 = *v32++;
              *v94++ = v140;
            }
            while ( v81 != v32 );
            goto LABEL_181;
          }
        }
        else
        {
          LOBYTE(v215) = 2 * v84;
          v93 = (char *)&v215 + 1;
        }
        v94 = v93;
        goto LABEL_180;
    }
  }
  return v4;
}
// 4D6F4: conditional instruction was optimized away because x21.8<17u
// 36F74: using guessed type __int64 __fastcall sub_36F74(_QWORD, _QWORD, _QWORD);
// 38008: using guessed type __int64 __fastcall sub_38008(_QWORD, _QWORD, _QWORD);

//----- (000000000004E518) ----------------------------------------------------
unsigned __int8 *__fastcall sub_4E518(unsigned __int8 *result, unsigned __int8 *a2, void **a3)
{
  int v4; // w8
  unsigned __int8 *v5; // x8
  int v6; // w9
  int v7; // t1
  unsigned __int8 *v8; // x23
  unsigned __int8 *v9; // x8
  unsigned __int8 *v10; // x22
  int v11; // w9
  unsigned __int8 *v12; // x8
  unsigned __int8 *v13; // x9
  int v14; // w10
  unsigned __int8 *v15; // x9
  int v16; // w10
  int v17; // t1
  unsigned __int8 *v18; // x23
  unsigned __int8 *v19; // x8
  int v20; // w9
  unsigned __int64 v21; // x24
  unsigned __int8 *v22; // x0
  unsigned __int8 *v23; // x8
  _OWORD *v24; // x11
  __int128 *v25; // x12
  unsigned __int64 v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  unsigned __int8 v29; // t1
  __int64 v30; // x8
  __int64 v31; // x9
  void *v32; // x20
  char v33; // w23
  __int64 v34; // x8
  __int64 v35; // x9
  _QWORD *v36; // x8
  _BYTE *v37; // x9
  __int64 v38; // x9
  __int64 v39; // x9
  unsigned __int64 v40; // x25
  __int64 v41; // x24
  unsigned __int64 v42; // x9
  unsigned __int64 v43; // x9
  _QWORD *v44; // x9
  char *v45; // x0
  unsigned __int64 v46; // x24
  unsigned __int8 *v47; // x0
  char *v48; // x8
  char *v49; // x9
  void **v50; // x11
  void **v51; // x23
  char *v52; // x10
  __int64 v53; // x12
  void **v54; // x20
  void *v55; // x24
  void **v56; // x25
  unsigned __int64 v57; // x8
  unsigned __int8 *v58; // x8
  _OWORD *v59; // x11
  __int128 *v60; // x12
  unsigned __int64 v61; // x13
  __int128 v62; // q0
  __int128 v63; // q1
  unsigned __int8 v64; // t1
  __int64 v65; // x8
  __int64 v66; // x9
  __int64 v67; // x8
  __int64 v68; // x9
  _BYTE *v69; // x9
  unsigned __int64 v70; // x25
  __int64 v71; // x24
  unsigned __int64 v72; // x9
  unsigned __int64 v73; // x9
  _QWORD *v74; // x9
  char *v75; // x0
  char *v76; // x8
  char *v77; // x9
  void **v78; // x11
  void **v79; // x23
  char *v80; // x10
  __int64 v81; // x12
  void **v82; // x25
  __int128 v83; // [xsp+0h] [xbp-A0h] BYREF
  void *p; // [xsp+10h] [xbp-90h]
  _QWORD v85[4]; // [xsp+18h] [xbp-88h] BYREF
  _QWORD v86[2]; // [xsp+38h] [xbp-68h] BYREF
  _QWORD v87[3]; // [xsp+48h] [xbp-58h] BYREF

  v87[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - result < 3 || *result != 102 )
    return result;
  v4 = result[1];
  if ( v4 == 76 )
  {
    v12 = result + 2;
    if ( result + 2 == a2 )
      return result;
    if ( result[2] == 110 )
      v13 = result + 3;
    else
      v13 = result + 2;
    if ( v13 != a2 )
    {
      v14 = *v13;
      if ( v14 == 48 )
      {
        v12 = v13 + 1;
      }
      else if ( (unsigned int)(v14 - 49) <= 8 )
      {
        v12 = v13 + 1;
        if ( v13 + 1 == a2 )
          return result;
        while ( (unsigned int)*v12 - 48 < 0xA )
        {
          if ( a2 == ++v12 )
            return result;
        }
      }
    }
    if ( v12 == a2 )
      return result;
    if ( *v12 != 112 )
      return result;
    v15 = v12 + 1;
    if ( v12 + 1 == a2 )
      return result;
    v16 = *v15;
    if ( v16 == 114 )
    {
      v16 = v12[2];
      v15 = v12 + 2;
    }
    if ( v16 == 86 )
    {
      v17 = *++v15;
      v16 = v17;
    }
    v18 = v16 == 75 ? v15 + 1 : v15;
    if ( v18 == a2 )
      return result;
    v19 = v18 + 1;
    v10 = v18;
    if ( *v18 != 110 )
      v19 = v18;
    if ( v19 != a2 )
    {
      v20 = *v19;
      if ( v20 == 48 )
      {
        v10 = v19 + 1;
      }
      else
      {
        v10 = v18;
        if ( (unsigned int)(v20 - 49) <= 8 )
        {
          v10 = v19 + 1;
          if ( v19 + 1 == a2 )
            return result;
          while ( (unsigned int)*v10 - 48 < 0xA )
          {
            if ( a2 == ++v10 )
              return result;
          }
        }
      }
    }
    if ( v10 == a2 || *v10 != 95 )
      return result;
    v46 = v10 - v18;
    v83 = 0u;
    p = 0;
    if ( (unsigned __int64)(v10 - v18) >= 0xFFFFFFFFFFFFFFF0LL )
      goto LABEL_147;
    if ( v46 > 0x16 )
    {
      v47 = (unsigned __int8 *)malloc((v46 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v83 + 1) = v10 - v18;
      p = v47;
      *(_QWORD *)&v83 = (v46 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      if ( v18 == v10 )
        goto LABEL_118;
    }
    else
    {
      LOBYTE(v83) = 2 * v46;
      v47 = (unsigned __int8 *)&v83 + 1;
      if ( v18 == v10 )
      {
LABEL_118:
        *v47 = 0;
        sub_429F4((size_t *)&v83, 0, "fp", 2u);
        v65 = *(_QWORD *)((char *)&v83 + 1);
        v66 = *((_QWORD *)&v83 + 1);
        v32 = p;
        v33 = v83;
        v83 = 0u;
        p = 0;
        *(_QWORD *)((char *)v85 + 7) = v66;
        v85[0] = v65;
        v67 = *(_QWORD *)((char *)v85 + 7);
        v68 = v85[0];
        memset(v86, 0, 15);
        memset(v85, 0, 15);
        *(_QWORD *)((char *)v87 + 7) = v67;
        v87[0] = v68;
        v36 = a3[1];
        v69 = a3[2];
        if ( v36 < (_QWORD *)v69 )
        {
LABEL_69:
          *(_BYTE *)v36 = v33;
          v36[1] = *(_QWORD *)((char *)v87 + 7);
          v38 = v87[0];
          v36[2] = v32;
          *(_QWORD *)((char *)v36 + 1) = v38;
          memset(v87, 0, 15);
          *((_BYTE *)v36 + 24) = 0;
          v36[4] = *(_QWORD *)((char *)v86 + 7);
          v39 = v86[0];
          v36[5] = 0;
          *(_QWORD *)((char *)v36 + 25) = v39;
          memset(v86, 0, 15);
          a3[1] = (char *)a3[1] + 48;
          if ( (v83 & 1) == 0 )
            return v10 + 1;
          goto LABEL_144;
        }
        v70 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (_BYTE *)*a3) >> 4);
        v71 = 0x555555555555555LL;
        if ( v70 + 1 > 0x555555555555555LL )
          abort();
        v72 = 0xAAAAAAAAAAAAAAABLL * ((v69 - (_BYTE *)*a3) >> 4);
        if ( v72 >= 0x2AAAAAAAAAAAAAALL || ((v73 = 2 * v72, v73 >= v70 + 1) ? (v71 = v73) : (v71 = v70 + 1), v71) )
        {
          v74 = a3[3];
          v75 = (char *)v74[512];
          if ( (char *)(v74 + 512) - v75 >= (unsigned __int64)(48 * v71) )
            v74[512] = &v75[48 * v71];
          else
            v75 = (char *)malloc(48 * v71);
        }
        else
        {
          v75 = 0;
        }
        v76 = &v75[48 * v70];
        *v76 = v33;
        v77 = &v75[48 * v71];
        *((_QWORD *)v76 + 1) = *(_QWORD *)((char *)v87 + 7);
        *((_QWORD *)v76 + 2) = v32;
        *(_QWORD *)(v76 + 1) = v87[0];
        memset(v87, 0, 15);
        v76[24] = 0;
        *((_QWORD *)v76 + 4) = *(_QWORD *)((char *)v86 + 7);
        *((_QWORD *)v76 + 5) = 0;
        *(_QWORD *)(v76 + 25) = v86[0];
        memset(v86, 0, 15);
        v79 = (void **)*a3;
        v78 = (void **)a3[1];
        v80 = v76 + 48;
        if ( v78 == *a3 )
        {
          v54 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v76 - 4) = *(v78 - 4);
            *((_OWORD *)v76 - 3) = *((_OWORD *)v78 - 3);
            v81 = (__int64)*(v78 - 1);
            *(v78 - 5) = 0;
            *(v78 - 4) = 0;
            *(v78 - 6) = 0;
            *((_QWORD *)v76 - 1) = v81;
            *(_OWORD *)(v76 - 24) = *(_OWORD *)(v78 - 3);
            *(v78 - 3) = 0;
            *(v78 - 2) = 0;
            *(v78 - 1) = 0;
            v78 -= 6;
            v76 -= 48;
          }
          while ( v79 != v78 );
          v54 = (void **)*a3;
          v79 = (void **)a3[1];
        }
        v55 = a3[2];
        *a3 = v76;
        a3[1] = v80;
        a3[2] = v77;
        if ( v79 != v54 )
        {
          do
          {
            if ( (*(_BYTE *)(v79 - 3) & 1) != 0 )
              free(*(v79 - 1));
            v82 = v79 - 6;
            if ( (*(_BYTE *)(v79 - 6) & 1) != 0 )
              free(*(v79 - 4));
            v79 -= 6;
          }
          while ( v54 != v82 );
        }
        if ( !v54 )
          goto LABEL_143;
        v57 = (unsigned __int64)a3[3];
        if ( v57 + 4096 >= (unsigned __int64)v54 && v57 <= (unsigned __int64)v54 )
        {
LABEL_105:
          if ( *(void **)(v57 + 4096) == v55 )
          {
            *(_QWORD *)(v57 + 4096) = v54;
            if ( (v83 & 1) == 0 )
              return v10 + 1;
            goto LABEL_144;
          }
LABEL_143:
          if ( (v83 & 1) == 0 )
            return v10 + 1;
LABEL_144:
          free(p);
          return v10 + 1;
        }
LABEL_142:
        free(v54);
        goto LABEL_143;
      }
    }
    if ( v46 >= 0x20 )
    {
      if ( v47 >= v10 || (v58 = v47, v18 >= &v10[v47 - v18]) )
      {
        v59 = v47 + 16;
        v58 = &v47[v46 & 0xFFFFFFFFFFFFFFE0LL];
        v60 = (__int128 *)(v18 + 16);
        v61 = v46 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v62 = *(v60 - 1);
          v63 = *v60;
          v61 -= 32LL;
          v60 += 2;
          *(v59 - 1) = v62;
          *v59 = v63;
          v59 += 2;
        }
        while ( v61 );
        v18 += v46 & 0xFFFFFFFFFFFFFFE0LL;
        if ( (v46 & 0xFFFFFFFFFFFFFFE0LL) == v46 )
          goto LABEL_117;
      }
    }
    else
    {
      v58 = v47;
    }
    do
    {
      v64 = *v18++;
      *v58++ = v64;
    }
    while ( v10 != v18 );
LABEL_117:
    v47 += v46;
    goto LABEL_118;
  }
  if ( v4 == 112 )
  {
    v5 = result + 2;
    if ( result + 2 != a2 )
    {
      v6 = *v5;
      if ( v6 == 114 )
      {
        v5 = result + 3;
        v6 = result[3];
      }
      if ( v6 == 86 )
      {
        v7 = *++v5;
        v6 = v7;
      }
      v8 = v6 == 75 ? v5 + 1 : v5;
      if ( v8 != a2 )
      {
        v9 = v8 + 1;
        v10 = v8;
        if ( *v8 != 110 )
          v9 = v8;
        if ( v9 != a2 )
        {
          v11 = *v9;
          if ( v11 == 48 )
          {
            v10 = v9 + 1;
          }
          else
          {
            v10 = v8;
            if ( (unsigned int)(v11 - 49) <= 8 )
            {
              v10 = v9 + 1;
              if ( v9 + 1 == a2 )
                return result;
              while ( (unsigned int)*v10 - 48 < 0xA )
              {
                if ( a2 == ++v10 )
                  return result;
              }
            }
          }
        }
        if ( v10 != a2 && *v10 == 95 )
        {
          v21 = v10 - v8;
          v83 = 0u;
          p = 0;
          if ( (unsigned __int64)(v10 - v8) < 0xFFFFFFFFFFFFFFF0LL )
          {
            if ( v21 > 0x16 )
            {
              v22 = (unsigned __int8 *)malloc((v21 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              *((_QWORD *)&v83 + 1) = v10 - v8;
              p = v22;
              *(_QWORD *)&v83 = (v21 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              if ( v8 == v10 )
                goto LABEL_68;
            }
            else
            {
              LOBYTE(v83) = 2 * v21;
              v22 = (unsigned __int8 *)&v83 + 1;
              if ( v8 == v10 )
              {
LABEL_68:
                *v22 = 0;
                sub_429F4((size_t *)&v83, 0, "fp", 2u);
                v30 = *(_QWORD *)((char *)&v83 + 1);
                v31 = *((_QWORD *)&v83 + 1);
                v32 = p;
                v33 = v83;
                v83 = 0u;
                p = 0;
                *(_QWORD *)((char *)&v85[2] + 7) = v31;
                v85[2] = v30;
                v34 = *(_QWORD *)((char *)&v85[2] + 7);
                v35 = v85[2];
                memset(v86, 0, 15);
                memset(&v85[2], 0, 15);
                *(_QWORD *)((char *)v87 + 7) = v34;
                v87[0] = v35;
                v36 = a3[1];
                v37 = a3[2];
                if ( v36 < (_QWORD *)v37 )
                  goto LABEL_69;
                v40 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (_BYTE *)*a3) >> 4);
                v41 = 0x555555555555555LL;
                if ( v40 + 1 > 0x555555555555555LL )
                  abort();
                v42 = 0xAAAAAAAAAAAAAAABLL * ((v37 - (_BYTE *)*a3) >> 4);
                if ( v42 >= 0x2AAAAAAAAAAAAAALL
                  || ((v43 = 2 * v42, v43 >= v40 + 1) ? (v41 = v43) : (v41 = v40 + 1), v41) )
                {
                  v44 = a3[3];
                  v45 = (char *)v44[512];
                  if ( (char *)(v44 + 512) - v45 >= (unsigned __int64)(48 * v41) )
                    v44[512] = &v45[48 * v41];
                  else
                    v45 = (char *)malloc(48 * v41);
                }
                else
                {
                  v45 = 0;
                }
                v48 = &v45[48 * v40];
                *v48 = v33;
                v49 = &v45[48 * v41];
                *((_QWORD *)v48 + 1) = *(_QWORD *)((char *)v87 + 7);
                *((_QWORD *)v48 + 2) = v32;
                *(_QWORD *)(v48 + 1) = v87[0];
                memset(v87, 0, 15);
                v48[24] = 0;
                *((_QWORD *)v48 + 4) = *(_QWORD *)((char *)v86 + 7);
                *((_QWORD *)v48 + 5) = 0;
                *(_QWORD *)(v48 + 25) = v86[0];
                memset(v86, 0, 15);
                v51 = (void **)*a3;
                v50 = (void **)a3[1];
                v52 = v48 + 48;
                if ( v50 == *a3 )
                {
                  v54 = (void **)*a3;
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v48 - 4) = *(v50 - 4);
                    *((_OWORD *)v48 - 3) = *((_OWORD *)v50 - 3);
                    v53 = (__int64)*(v50 - 1);
                    *(v50 - 5) = 0;
                    *(v50 - 4) = 0;
                    *(v50 - 6) = 0;
                    *((_QWORD *)v48 - 1) = v53;
                    *(_OWORD *)(v48 - 24) = *(_OWORD *)(v50 - 3);
                    *(v50 - 3) = 0;
                    *(v50 - 2) = 0;
                    *(v50 - 1) = 0;
                    v50 -= 6;
                    v48 -= 48;
                  }
                  while ( v51 != v50 );
                  v54 = (void **)*a3;
                  v51 = (void **)a3[1];
                }
                v55 = a3[2];
                *a3 = v48;
                a3[1] = v52;
                a3[2] = v49;
                if ( v51 != v54 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v51 - 3) & 1) != 0 )
                      free(*(v51 - 1));
                    v56 = v51 - 6;
                    if ( (*(_BYTE *)(v51 - 6) & 1) != 0 )
                      free(*(v51 - 4));
                    v51 -= 6;
                  }
                  while ( v54 != v56 );
                }
                if ( !v54 )
                  goto LABEL_143;
                v57 = (unsigned __int64)a3[3];
                if ( v57 + 4096 >= (unsigned __int64)v54 && v57 <= (unsigned __int64)v54 )
                  goto LABEL_105;
                goto LABEL_142;
              }
            }
            if ( v21 >= 0x20 )
            {
              if ( v22 >= v10 || (v23 = v22, v8 >= &v10[v22 - v8]) )
              {
                v24 = v22 + 16;
                v23 = &v22[v21 & 0xFFFFFFFFFFFFFFE0LL];
                v25 = (__int128 *)(v8 + 16);
                v26 = v21 & 0xFFFFFFFFFFFFFFE0LL;
                do
                {
                  v27 = *(v25 - 1);
                  v28 = *v25;
                  v26 -= 32LL;
                  v25 += 2;
                  *(v24 - 1) = v27;
                  *v24 = v28;
                  v24 += 2;
                }
                while ( v26 );
                v8 += v21 & 0xFFFFFFFFFFFFFFE0LL;
                if ( (v21 & 0xFFFFFFFFFFFFFFE0LL) == v21 )
                  goto LABEL_67;
              }
            }
            else
            {
              v23 = v22;
            }
            do
            {
              v29 = *v8++;
              *v23++ = v29;
            }
            while ( v10 != v8 );
LABEL_67:
            v22 += v21;
            goto LABEL_68;
          }
LABEL_147:
          abort();
        }
      }
    }
  }
  return result;
}

//----- (000000000004EE40) ----------------------------------------------------
__int64 __fastcall sub_4EE40(__int64 a1, __int64 a2, unsigned __int8 *a3, _QWORD *a4)
{
  __int64 v7; // x22
  __int64 v8; // x0
  __int64 v9; // x23
  __int64 v10; // x19
  __int64 v11; // x23
  unsigned __int64 v12; // x8
  const void *v13; // x1
  size_t v14; // x2
  __int64 v15; // x22
  _BYTE *v16; // x23
  unsigned __int64 v17; // x8
  const void *v18; // x1
  size_t v19; // x2
  size_t *v20; // x0
  __int64 v21; // x8
  size_t *v22; // x21
  __int64 v23; // x19
  _BYTE *v24; // x20
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int8 *v27; // x8
  size_t v28; // x23
  int v29; // w26
  _WORD *v30; // x0
  char *v31; // x22
  char *v32; // x1
  void *v33; // x8
  __int128 v34; // q0
  unsigned __int64 v35; // x8
  const void *v36; // x1
  size_t v37; // x2
  void *v38; // x8
  __int128 v39; // q0
  char v40; // w27
  void *v41; // x8
  __int128 v42; // q0
  void *v43; // x23
  char *v44; // x1
  size_t v45; // x2
  void *v46; // x8
  __int128 v47; // q0
  __int128 v48; // q0
  char *v49; // x8
  char v50; // w28
  void *v51; // x24
  char *v52; // x1
  size_t v53; // x2
  unsigned __int64 v54; // x8
  unsigned __int64 v55; // x9
  unsigned __int8 *v56; // x8
  __int128 v58; // [xsp+18h] [xbp-148h] BYREF
  void *p; // [xsp+28h] [xbp-138h]
  __int128 v60; // [xsp+30h] [xbp-130h] BYREF
  void *v61; // [xsp+40h] [xbp-120h]
  __int128 v62; // [xsp+50h] [xbp-110h] BYREF
  void *v63; // [xsp+60h] [xbp-100h]
  __int128 v64; // [xsp+70h] [xbp-F0h] BYREF
  void *v65; // [xsp+80h] [xbp-E0h]
  __int128 v66; // [xsp+90h] [xbp-D0h] BYREF
  void *v67; // [xsp+A0h] [xbp-C0h]
  __int128 v68; // [xsp+B0h] [xbp-B0h] BYREF
  char *v69; // [xsp+C0h] [xbp-A0h]
  __int128 v70; // [xsp+D0h] [xbp-90h] BYREF
  char *v71; // [xsp+E0h] [xbp-80h]
  __int128 v72; // [xsp+F0h] [xbp-70h] BYREF
  char *v73; // [xsp+100h] [xbp-60h]

  v7 = a1;
  _ReadStatusReg(TPIDR_EL0);
  v8 = sub_47B84(a1, a2, a4);
  v9 = v8;
  if ( v8 == v7 )
    return v7;
  v10 = sub_47B84(v8, a2, a4);
  if ( v10 != v9 )
  {
    v11 = a4[1];
    if ( 0xAAAAAAAAAAAAAAABLL * ((v11 - *a4) >> 4) < 2 )
      return v7;
    v12 = *(unsigned __int8 *)(v11 - 24);
    if ( (v12 & 1) != 0 )
      v13 = *(const void **)(v11 - 8);
    else
      v13 = (const void *)(v11 - 23);
    if ( (v12 & 1) != 0 )
      v14 = *(_QWORD *)(v11 - 16);
    else
      v14 = v12 >> 1;
    sub_42BE4((size_t *)(v11 - 48), v13, v14);
    v73 = *(char **)(v11 - 32);
    v72 = *(_OWORD *)(v11 - 48);
    *(_QWORD *)(v11 - 40) = 0;
    *(_QWORD *)(v11 - 32) = 0;
    *(_QWORD *)(v11 - 48) = 0;
    v15 = a4[1];
    v16 = (_BYTE *)(v15 - 48);
    if ( (*(_BYTE *)(v15 - 24) & 1) != 0 )
      free(*(void **)(v15 - 8));
    if ( (*v16 & 1) != 0 )
      free(*(void **)(v15 - 32));
    a4[1] = v16;
    v17 = *(unsigned __int8 *)(v15 - 72);
    if ( (v17 & 1) != 0 )
      v18 = *(const void **)(v15 - 56);
    else
      v18 = (const void *)(v15 - 71);
    if ( (v17 & 1) != 0 )
      v19 = *(_QWORD *)(v15 - 64);
    else
      v19 = v17 >> 1;
    v20 = sub_42BE4((size_t *)(v15 - 96), v18, v19);
    v71 = (char *)v20[2];
    v70 = *(_OWORD *)v20;
    v20[1] = 0;
    v20[2] = 0;
    *v20 = 0;
    v21 = a4[1];
    v22 = (size_t *)(v21 - 48);
    if ( (*(_BYTE *)(v21 - 48) & 1) != 0 )
    {
      **(_BYTE **)(v21 - 32) = 0;
      *(_QWORD *)(v21 - 40) = 0;
    }
    else
    {
      *(_WORD *)v22 = 0;
    }
    v25 = *a3;
    v26 = *((_QWORD *)a3 + 1);
    if ( (v25 & 1) == 0 )
      v26 = v25 >> 1;
    if ( v26 == 1 )
    {
      v27 = (v25 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1;
      if ( *v27 == 62 )
        sub_57F64(v22, 40);
    }
    v58 = 0u;
    p = 0;
    if ( (v70 & 1) != 0 )
      v28 = *((_QWORD *)&v70 + 1);
    else
      v28 = (unsigned __int64)(unsigned __int8)v70 >> 1;
    v29 = v70 & 1;
    if ( v28 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    if ( v28 + 1 > 0x16 )
    {
      v30 = malloc((v28 + 17) & 0xFFFFFFFFFFFFFFF0LL);
      *(_QWORD *)&v58 = (v28 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
      *((_QWORD *)&v58 + 1) = 1;
      p = v30;
    }
    else
    {
      LOBYTE(v58) = 2;
      v30 = (_WORD *)((char *)&v58 + 1);
    }
    v31 = v71;
    *v30 = 40;
    if ( v29 )
      v32 = v31;
    else
      v32 = (char *)&v70 + 1;
    sub_42BE4((size_t *)&v58, v32, v28);
    sub_42BE4((size_t *)&v58, ") ", 2u);
    v33 = p;
    v34 = v58;
    p = 0;
    v58 = 0u;
    v61 = v33;
    v60 = v34;
    v35 = *a3;
    if ( (v35 & 1) != 0 )
      v36 = (const void *)*((_QWORD *)a3 + 2);
    else
      v36 = a3 + 1;
    if ( (v35 & 1) != 0 )
      v37 = *((_QWORD *)a3 + 1);
    else
      v37 = v35 >> 1;
    sub_42BE4((size_t *)&v60, v36, v37);
    v38 = v61;
    v39 = v60;
    v60 = 0u;
    v61 = 0;
    v63 = v38;
    v62 = v39;
    sub_42BE4((size_t *)&v62, " (", 2u);
    v40 = v72;
    v41 = v63;
    v42 = v62;
    v63 = 0;
    v62 = 0u;
    v43 = v73;
    v65 = v41;
    if ( (v72 & 1) != 0 )
      v44 = v73;
    else
      v44 = (char *)&v72 + 1;
    v64 = v42;
    if ( (v72 & 1) != 0 )
      v45 = *((_QWORD *)&v72 + 1);
    else
      v45 = (unsigned __int64)(unsigned __int8)v72 >> 1;
    sub_42BE4((size_t *)&v64, v44, v45);
    v46 = v65;
    v47 = v64;
    v64 = 0u;
    v65 = 0;
    v67 = v46;
    v66 = v47;
    sub_42BE4((size_t *)&v66, ")", 1u);
    v48 = v66;
    v49 = (char *)v67;
    v67 = 0;
    v66 = 0u;
    v68 = v48;
    v50 = v48;
    v69 = v49;
    v51 = v49;
    if ( (v48 & 1) != 0 )
      v52 = v49;
    else
      v52 = (char *)&v68 + 1;
    if ( (v68 & 1) != 0 )
      v53 = *((_QWORD *)&v68 + 1);
    else
      v53 = (unsigned __int64)(unsigned __int8)v68 >> 1;
    sub_42BE4(v22, v52, v53);
    if ( (v50 & 1) != 0 )
    {
      free(v51);
      if ( (v66 & 1) == 0 )
      {
LABEL_67:
        if ( (v64 & 1) == 0 )
          goto LABEL_68;
        goto LABEL_88;
      }
    }
    else if ( (v66 & 1) == 0 )
    {
      goto LABEL_67;
    }
    free(v67);
    if ( (v64 & 1) == 0 )
    {
LABEL_68:
      if ( (v62 & 1) == 0 )
        goto LABEL_69;
      goto LABEL_89;
    }
LABEL_88:
    free(v65);
    if ( (v62 & 1) == 0 )
    {
LABEL_69:
      if ( (v60 & 1) == 0 )
        goto LABEL_70;
      goto LABEL_90;
    }
LABEL_89:
    free(v63);
    if ( (v60 & 1) == 0 )
    {
LABEL_70:
      if ( (v58 & 1) == 0 )
      {
LABEL_72:
        v54 = *a3;
        v55 = *((_QWORD *)a3 + 1);
        if ( (v54 & 1) == 0 )
          v55 = v54 >> 1;
        if ( v55 == 1 )
        {
          v56 = (v54 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1;
          if ( *v56 == 62 )
            sub_57F64(v22, 41);
        }
        if ( v29 )
          free(v31);
        if ( (v40 & 1) != 0 )
          free(v43);
        return v10;
      }
LABEL_71:
      free(p);
      goto LABEL_72;
    }
LABEL_90:
    free(v61);
    if ( (v58 & 1) == 0 )
      goto LABEL_72;
    goto LABEL_71;
  }
  v23 = a4[1];
  if ( *a4 != v23 )
  {
    v24 = (_BYTE *)(v23 - 48);
    if ( (*(_BYTE *)(v23 - 24) & 1) != 0 )
      free(*(void **)(v23 - 8));
    if ( (*v24 & 1) != 0 )
      free(*(void **)(v23 - 32));
    a4[1] = v24;
  }
  return v7;
}
// 47B84: using guessed type __int64 __fastcall sub_47B84(_QWORD, _QWORD, _QWORD);

//----- (000000000004F434) ----------------------------------------------------
__int64 __fastcall sub_4F434(__int64 a1, __int64 a2, unsigned __int8 *a3, _QWORD *a4)
{
  __int64 v6; // x20
  __int64 v7; // x19
  __int64 v8; // x8
  unsigned __int64 v9; // x9
  size_t v10; // x10
  const void *v11; // x11
  size_t *v12; // x0
  const void *v13; // x8
  const void *v14; // x1
  size_t v15; // x2
  size_t *v16; // x0
  void *v17; // x20
  char *v18; // x1
  size_t v19; // x2
  void *v20; // x8
  __int128 v21; // q0
  __int64 v22; // x8
  __int64 v23; // x9
  _BYTE *v24; // x26
  char v25; // w25
  __int64 v26; // x27
  _BYTE **v27; // x28
  unsigned __int64 v28; // x8
  size_t v29; // x22
  void *v30; // x0
  void *v31; // x21
  _BYTE *v32; // x0
  unsigned __int64 v34; // [xsp+0h] [xbp-C0h]
  __int128 v35; // [xsp+10h] [xbp-B0h] BYREF
  char *v36; // [xsp+20h] [xbp-A0h]
  __int128 v37; // [xsp+28h] [xbp-98h] BYREF
  void *p; // [xsp+38h] [xbp-88h]
  __int128 v39; // [xsp+40h] [xbp-80h] BYREF
  void *v40; // [xsp+50h] [xbp-70h]
  _QWORD v41[3]; // [xsp+58h] [xbp-68h] BYREF

  v6 = a1;
  v41[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = sub_47B84(a1, a2, a4);
  if ( v7 != v6 && *a4 != a4[1] )
  {
    sub_50A9C(a3, "(", (size_t *)&v37);
    v8 = a4[1];
    v9 = *(unsigned __int8 *)(v8 - 24);
    v10 = *(_QWORD *)(v8 - 16);
    v11 = *(const void **)(v8 - 8);
    v12 = (size_t *)(v8 - 48);
    v13 = (const void *)(v8 - 23);
    if ( (v9 & 1) != 0 )
      v14 = v11;
    else
      v14 = v13;
    if ( (v9 & 1) != 0 )
      v15 = v10;
    else
      v15 = v9 >> 1;
    v16 = sub_42BE4(v12, v14, v15);
    v36 = (char *)v16[2];
    v35 = *(_OWORD *)v16;
    v16[1] = 0;
    v16[2] = 0;
    *v16 = 0;
    v17 = v36;
    if ( (v35 & 1) != 0 )
      v18 = v36;
    else
      v18 = (char *)&v35 + 1;
    if ( (v35 & 1) != 0 )
      v19 = *((_QWORD *)&v35 + 1);
    else
      v19 = (unsigned __int64)(unsigned __int8)v35 >> 1;
    sub_42BE4((size_t *)&v37, v18, v19);
    v20 = p;
    v21 = v37;
    v37 = 0u;
    p = 0;
    v40 = v20;
    v39 = v21;
    sub_42BE4((size_t *)&v39, ")", 1u);
    v22 = *(_QWORD *)((char *)&v39 + 1);
    v23 = *((_QWORD *)&v39 + 1);
    v24 = v40;
    v25 = v39;
    v39 = 0u;
    v40 = 0;
    *(_QWORD *)((char *)v41 + 7) = v23;
    v41[0] = v22;
    v26 = a4[1];
    if ( (*(_BYTE *)(v26 - 48) & 1) != 0 )
    {
      v27 = (_BYTE **)(v26 - 32);
      **(_BYTE **)(v26 - 32) = 0;
      v28 = *(unsigned __int8 *)(v26 - 48);
      *(_QWORD *)(v26 - 40) = 0;
      if ( (v28 & 1) != 0 )
      {
        v32 = *v27;
        *(_BYTE *)(v26 - 47) = **v27;
        free(v32);
        *(_BYTE *)(v26 - 48) = 0;
      }
      else if ( (unsigned int)v28 >= 0x2E )
      {
        v34 = v28 >> 1;
        v29 = (unsigned __int8)((v28 >> 1) + 16) & 0xF0;
        v30 = malloc(v29);
        if ( v29 - 1 > 0x16 || v30 )
        {
          v31 = v30;
          memcpy(v30, (const void *)(v26 - 47), v34 + 1);
          *(_QWORD *)(v26 - 32) = v31;
          *(_QWORD *)(v26 - 48) = v29 | 1;
          *(_QWORD *)(v26 - 40) = v34;
        }
      }
    }
    else
    {
      *(_WORD *)(v26 - 48) = 0;
      v27 = (_BYTE **)(v26 - 32);
    }
    *(_BYTE *)(v26 - 48) = v25;
    *(_QWORD *)(v26 - 47) = v41[0];
    *(_QWORD *)(v26 - 40) = *(_QWORD *)((char *)v41 + 7);
    *v27 = v24;
    memset(v41, 0, 15);
    if ( (v39 & 1) != 0 )
    {
      free(v40);
      if ( (v35 & 1) == 0 )
      {
LABEL_25:
        if ( (v37 & 1) == 0 )
          return v7;
LABEL_26:
        free(p);
        return v7;
      }
    }
    else if ( (v35 & 1) == 0 )
    {
      goto LABEL_25;
    }
    free(v17);
    if ( (v37 & 1) == 0 )
      return v7;
    goto LABEL_26;
  }
  return v6;
}
// 47B84: using guessed type __int64 __fastcall sub_47B84(_QWORD, _QWORD, _QWORD);

//----- (000000000004F704) ----------------------------------------------------
__int64 __fastcall sub_4F704(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x20
  int v6; // w8
  _BOOL4 v7; // w26
  unsigned __int8 *v8; // x22
  __int64 v9; // x23
  __int64 v10; // x8
  unsigned __int8 *v11; // x24
  unsigned __int8 *v12; // x23
  unsigned __int8 *v13; // x0
  _BYTE *v14; // x22
  __int64 v15; // x23
  __int64 v16; // x22
  unsigned __int64 v17; // x8
  const void *v18; // x1
  size_t v19; // x2
  __int64 v20; // x22
  _BYTE *v21; // x24
  char v22; // w24
  size_t *v23; // x0
  void *v24; // x22
  char *v25; // x1
  size_t v26; // x2
  int v27; // w26
  unsigned __int8 *v28; // x22
  __int64 v29; // x21
  __int64 v30; // x22
  unsigned __int64 v31; // x8
  const void *v32; // x1
  size_t v33; // x2
  __int64 v34; // x22
  _BYTE *v35; // x20
  __int128 v36; // q0
  char *v37; // x8
  char v38; // w22
  void *v39; // x20
  size_t *v40; // x0
  char *v41; // x1
  size_t v42; // x2
  unsigned __int8 *v43; // x0
  unsigned __int8 *v44; // x23
  __int64 v45; // x22
  __int64 v46; // x23
  unsigned __int64 v47; // x8
  const void *v48; // x1
  size_t v49; // x2
  __int64 v50; // x23
  _BYTE *v51; // x24
  size_t *v52; // x0
  void *v53; // x23
  char *v54; // x1
  size_t v55; // x2
  __int64 v56; // x22
  unsigned __int64 v57; // x8
  const void *v58; // x1
  size_t v59; // x2
  __int64 v60; // x22
  _BYTE *v61; // x20
  __int128 v62; // q0
  char *v63; // x8
  __int64 v64; // x0
  _BYTE *v65; // x22
  __int64 v66; // x8
  unsigned __int8 *v67; // x22
  __int64 v68; // x22
  unsigned __int64 v69; // x8
  const void *v70; // x1
  size_t v71; // x2
  __int64 v72; // x22
  _BYTE *v73; // x20
  __int128 v74; // q0
  char *v75; // x8
  __int64 v76; // x21
  _BYTE *v77; // x22
  _BYTE *v79; // x24
  __int64 v80; // x0
  __int64 v81; // x24
  unsigned __int64 v82; // x8
  const void *v83; // x1
  size_t v84; // x2
  __int64 v85; // x24
  _BYTE *v86; // x23
  __int128 v87; // q0
  char *v88; // x8
  char v89; // w23
  void *v90; // x24
  char *v91; // x1
  size_t v92; // x2
  _BYTE *v93; // x24
  __int64 v94; // x0
  __int64 v95; // x24
  unsigned __int64 v96; // x8
  const void *v97; // x1
  size_t v98; // x2
  __int64 v99; // x24
  _BYTE *v100; // x23
  __int128 v101; // q0
  char *v102; // x8
  char v103; // w23
  void *v104; // x24
  char *v105; // x1
  size_t v106; // x2
  __int64 v107; // x27
  _BYTE *v108; // x26
  __int128 v109; // [xsp+0h] [xbp-90h] BYREF
  char *v110; // [xsp+10h] [xbp-80h]
  __int128 v111; // [xsp+20h] [xbp-70h] BYREF
  void *p; // [xsp+30h] [xbp-60h]
  __int64 v113; // [xsp+38h] [xbp-58h]

  v4 = a1;
  v113 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 3 )
    return (__int64)v4;
  if ( *a1 == 103 )
  {
    v6 = a1[1];
    v7 = v6 == 115;
    if ( v6 == 115 )
      v8 = a1 + 2;
    else
      v8 = a1;
  }
  else
  {
    v7 = 0;
    v8 = a1;
  }
  v9 = sub_50BA4(v8, a2, a3);
  if ( (unsigned __int8 *)v9 == v8 )
  {
    if ( a2 - v8 < 3 || *v8 != 115 || v8[1] != 114 )
      return (__int64)v4;
    v11 = v8 + 2;
    if ( v8[2] != 78 )
    {
      v43 = sub_50EE8(v8 + 2, a2, (void **)a3);
      v44 = v43;
      if ( v43 == v11 )
      {
        v64 = ((__int64 (__fastcall *)(unsigned __int8 *, unsigned __int8 *, __int64))loc_572B4)(v8 + 2, a2, a3);
        v65 = (_BYTE *)v64;
        if ( (unsigned __int8 *)v64 == v11 || (unsigned __int8 *)v64 == a2 )
          return (__int64)v4;
        if ( v7 )
        {
          v66 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v66 )
            return (__int64)v4;
          sub_429F4((size_t *)(v66 - 48), 0, "::", 2u);
        }
        while ( *v65 != 69 )
        {
          v93 = v65;
          v94 = ((__int64 (__fastcall *)(_BYTE *, unsigned __int8 *, __int64))loc_572B4)(v65, a2, a3);
          v65 = (_BYTE *)v94;
          if ( (_BYTE *)v94 == v93 )
            return (__int64)v4;
          if ( (unsigned __int8 *)v94 == a2 )
            return (__int64)v4;
          v95 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v95 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v96 = *(unsigned __int8 *)(v95 - 24);
          if ( (v96 & 1) != 0 )
            v97 = *(const void **)(v95 - 8);
          else
            v97 = (const void *)(v95 - 23);
          if ( (v96 & 1) != 0 )
            v98 = *(_QWORD *)(v95 - 16);
          else
            v98 = v96 >> 1;
          sub_42BE4((size_t *)(v95 - 48), v97, v98);
          p = *(void **)(v95 - 32);
          v111 = *(_OWORD *)(v95 - 48);
          *(_QWORD *)(v95 - 40) = 0;
          *(_QWORD *)(v95 - 32) = 0;
          *(_QWORD *)(v95 - 48) = 0;
          v99 = *(_QWORD *)(a3 + 8);
          v100 = (_BYTE *)(v99 - 48);
          if ( (*(_BYTE *)(v99 - 24) & 1) != 0 )
            free(*(void **)(v99 - 8));
          if ( (*v100 & 1) != 0 )
            free(*(void **)(v99 - 32));
          *(_QWORD *)(a3 + 8) = v100;
          sub_429F4((size_t *)&v111, 0, "::", 2u);
          v101 = v111;
          v102 = (char *)p;
          p = 0;
          v111 = 0u;
          v109 = v101;
          v110 = v102;
          v103 = v101;
          v104 = v102;
          if ( (v101 & 1) != 0 )
            v105 = v102;
          else
            v105 = (char *)&v109 + 1;
          if ( (v101 & 1) != 0 )
            v106 = *((_QWORD *)&v101 + 1);
          else
            v106 = (unsigned __int64)(unsigned __int8)v101 >> 1;
          sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v105, v106);
          if ( (v103 & 1) != 0 )
            free(v104);
          if ( (v111 & 1) != 0 )
            free(p);
        }
        v67 = v65 + 1;
        v29 = sub_50BA4(v67, a2, a3);
        if ( (unsigned __int8 *)v29 == v67 )
          goto LABEL_129;
        v68 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v68 - *(_QWORD *)a3) >> 4) < 2 )
          return (__int64)v4;
        v69 = *(unsigned __int8 *)(v68 - 24);
        if ( (v69 & 1) != 0 )
          v70 = *(const void **)(v68 - 8);
        else
          v70 = (const void *)(v68 - 23);
        if ( (v69 & 1) != 0 )
          v71 = *(_QWORD *)(v68 - 16);
        else
          v71 = v69 >> 1;
        sub_42BE4((size_t *)(v68 - 48), v70, v71);
        p = *(void **)(v68 - 32);
        v111 = *(_OWORD *)(v68 - 48);
        *(_QWORD *)(v68 - 40) = 0;
        *(_QWORD *)(v68 - 32) = 0;
        *(_QWORD *)(v68 - 48) = 0;
        v72 = *(_QWORD *)(a3 + 8);
        v73 = (_BYTE *)(v72 - 48);
        if ( (*(_BYTE *)(v72 - 24) & 1) != 0 )
          free(*(void **)(v72 - 8));
        if ( (*v73 & 1) != 0 )
          free(*(void **)(v72 - 32));
        *(_QWORD *)(a3 + 8) = v73;
        sub_429F4((size_t *)&v111, 0, "::", 2u);
        v74 = v111;
        v75 = (char *)p;
        p = 0;
        v111 = 0u;
        v109 = v74;
        v110 = v75;
        v38 = v74;
        v39 = v75;
        v40 = (size_t *)(*(_QWORD *)(a3 + 8) - 48LL);
        if ( (v74 & 1) != 0 )
          v41 = v75;
        else
          v41 = (char *)&v109 + 1;
        if ( (v74 & 1) != 0 )
          v42 = *((_QWORD *)&v74 + 1);
        else
          v42 = (unsigned __int64)(unsigned __int8)v74 >> 1;
      }
      else
      {
        v45 = sub_42FE0(v43, a2, a3);
        if ( (unsigned __int8 *)v45 != v44 )
        {
          v46 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v46 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v47 = *(unsigned __int8 *)(v46 - 24);
          if ( (v47 & 1) != 0 )
            v48 = *(const void **)(v46 - 8);
          else
            v48 = (const void *)(v46 - 23);
          if ( (v47 & 1) != 0 )
            v49 = *(_QWORD *)(v46 - 16);
          else
            v49 = v47 >> 1;
          sub_42BE4((size_t *)(v46 - 48), v48, v49);
          p = *(void **)(v46 - 32);
          v111 = *(_OWORD *)(v46 - 48);
          *(_QWORD *)(v46 - 40) = 0;
          *(_QWORD *)(v46 - 32) = 0;
          *(_QWORD *)(v46 - 48) = 0;
          v50 = *(_QWORD *)(a3 + 8);
          v51 = (_BYTE *)(v50 - 48);
          if ( (*(_BYTE *)(v50 - 24) & 1) != 0 )
            free(*(void **)(v50 - 8));
          if ( (*v51 & 1) != 0 )
            free(*(void **)(v50 - 32));
          *(_QWORD *)(a3 + 8) = v51;
          v52 = (size_t *)(v50 - 96);
          v53 = p;
          if ( (v111 & 1) != 0 )
            v54 = (char *)p;
          else
            v54 = (char *)&v111 + 1;
          if ( (v111 & 1) != 0 )
            v55 = *((_QWORD *)&v111 + 1);
          else
            v55 = (unsigned __int64)(unsigned __int8)v111 >> 1;
          sub_42BE4(v52, v54, v55);
          if ( (v111 & 1) != 0 )
            free(v53);
          v44 = (unsigned __int8 *)v45;
        }
        v29 = sub_50BA4(v44, a2, a3);
        if ( (unsigned __int8 *)v29 == v44 )
          goto LABEL_129;
        v56 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v56 - *(_QWORD *)a3) >> 4) < 2 )
          return (__int64)v4;
        v57 = *(unsigned __int8 *)(v56 - 24);
        if ( (v57 & 1) != 0 )
          v58 = *(const void **)(v56 - 8);
        else
          v58 = (const void *)(v56 - 23);
        if ( (v57 & 1) != 0 )
          v59 = *(_QWORD *)(v56 - 16);
        else
          v59 = v57 >> 1;
        sub_42BE4((size_t *)(v56 - 48), v58, v59);
        p = *(void **)(v56 - 32);
        v111 = *(_OWORD *)(v56 - 48);
        *(_QWORD *)(v56 - 40) = 0;
        *(_QWORD *)(v56 - 32) = 0;
        *(_QWORD *)(v56 - 48) = 0;
        v60 = *(_QWORD *)(a3 + 8);
        v61 = (_BYTE *)(v60 - 48);
        if ( (*(_BYTE *)(v60 - 24) & 1) != 0 )
          free(*(void **)(v60 - 8));
        if ( (*v61 & 1) != 0 )
          free(*(void **)(v60 - 32));
        *(_QWORD *)(a3 + 8) = v61;
        sub_429F4((size_t *)&v111, 0, "::", 2u);
        v62 = v111;
        v63 = (char *)p;
        p = 0;
        v111 = 0u;
        v109 = v62;
        v110 = v63;
        v38 = v62;
        v39 = v63;
        v40 = (size_t *)(*(_QWORD *)(a3 + 8) - 48LL);
        if ( (v62 & 1) != 0 )
          v41 = v63;
        else
          v41 = (char *)&v109 + 1;
        if ( (v62 & 1) != 0 )
          v42 = *((_QWORD *)&v62 + 1);
        else
          v42 = (unsigned __int64)(unsigned __int8)v62 >> 1;
      }
LABEL_100:
      sub_42BE4(v40, v41, v42);
      if ( (v38 & 1) != 0 )
        free(v39);
      if ( (v111 & 1) != 0 )
        free(p);
      return v29;
    }
    v12 = v8 + 3;
    v13 = sub_50EE8(v8 + 3, a2, (void **)a3);
    v14 = v13;
    if ( v13 == v12 || v13 == a2 )
      return (__int64)v4;
    v15 = sub_42FE0(v13, a2, a3);
    if ( (_BYTE *)v15 == v14 )
    {
LABEL_41:
      while ( *v14 != 69 )
      {
        v79 = v14;
        v80 = ((__int64 (__fastcall *)(_BYTE *, unsigned __int8 *, __int64))loc_572B4)(v14, a2, a3);
        v14 = (_BYTE *)v80;
        if ( (_BYTE *)v80 == v79 )
          return (__int64)v4;
        if ( (unsigned __int8 *)v80 == a2 )
          return (__int64)v4;
        v81 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v81 - *(_QWORD *)a3) >> 4) < 2 )
          return (__int64)v4;
        v82 = *(unsigned __int8 *)(v81 - 24);
        if ( (v82 & 1) != 0 )
          v83 = *(const void **)(v81 - 8);
        else
          v83 = (const void *)(v81 - 23);
        if ( (v82 & 1) != 0 )
          v84 = *(_QWORD *)(v81 - 16);
        else
          v84 = v82 >> 1;
        sub_42BE4((size_t *)(v81 - 48), v83, v84);
        p = *(void **)(v81 - 32);
        v111 = *(_OWORD *)(v81 - 48);
        *(_QWORD *)(v81 - 40) = 0;
        *(_QWORD *)(v81 - 32) = 0;
        *(_QWORD *)(v81 - 48) = 0;
        v85 = *(_QWORD *)(a3 + 8);
        v86 = (_BYTE *)(v85 - 48);
        if ( (*(_BYTE *)(v85 - 24) & 1) != 0 )
          free(*(void **)(v85 - 8));
        if ( (*v86 & 1) != 0 )
          free(*(void **)(v85 - 32));
        *(_QWORD *)(a3 + 8) = v86;
        sub_429F4((size_t *)&v111, 0, "::", 2u);
        v87 = v111;
        v88 = (char *)p;
        p = 0;
        v111 = 0u;
        v109 = v87;
        v110 = v88;
        v89 = v87;
        v90 = v88;
        if ( (v87 & 1) != 0 )
          v91 = v88;
        else
          v91 = (char *)&v109 + 1;
        if ( (v87 & 1) != 0 )
          v92 = *((_QWORD *)&v87 + 1);
        else
          v92 = (unsigned __int64)(unsigned __int8)v87 >> 1;
        sub_42BE4((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v91, v92);
        if ( (v89 & 1) != 0 )
          free(v90);
        if ( (v111 & 1) != 0 )
          free(p);
      }
      v28 = v14 + 1;
      v29 = sub_50BA4(v28, a2, a3);
      if ( (unsigned __int8 *)v29 != v28 )
      {
        v30 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v30 - *(_QWORD *)a3) >> 4) < 2 )
          return (__int64)v4;
        v31 = *(unsigned __int8 *)(v30 - 24);
        if ( (v31 & 1) != 0 )
          v32 = *(const void **)(v30 - 8);
        else
          v32 = (const void *)(v30 - 23);
        if ( (v31 & 1) != 0 )
          v33 = *(_QWORD *)(v30 - 16);
        else
          v33 = v31 >> 1;
        sub_42BE4((size_t *)(v30 - 48), v32, v33);
        p = *(void **)(v30 - 32);
        v111 = *(_OWORD *)(v30 - 48);
        *(_QWORD *)(v30 - 40) = 0;
        *(_QWORD *)(v30 - 32) = 0;
        *(_QWORD *)(v30 - 48) = 0;
        v34 = *(_QWORD *)(a3 + 8);
        v35 = (_BYTE *)(v34 - 48);
        if ( (*(_BYTE *)(v34 - 24) & 1) != 0 )
          free(*(void **)(v34 - 8));
        if ( (*v35 & 1) != 0 )
          free(*(void **)(v34 - 32));
        *(_QWORD *)(a3 + 8) = v35;
        sub_429F4((size_t *)&v111, 0, "::", 2u);
        v36 = v111;
        v37 = (char *)p;
        p = 0;
        v111 = 0u;
        v109 = v36;
        v110 = v37;
        v38 = v36;
        v39 = v37;
        v40 = (size_t *)(*(_QWORD *)(a3 + 8) - 48LL);
        if ( (v36 & 1) != 0 )
          v41 = v37;
        else
          v41 = (char *)&v109 + 1;
        if ( (v36 & 1) != 0 )
          v42 = *((_QWORD *)&v36 + 1);
        else
          v42 = (unsigned __int64)(unsigned __int8)v36 >> 1;
        goto LABEL_100;
      }
LABEL_129:
      v76 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 != v76 )
      {
        v77 = (_BYTE *)(v76 - 48);
        if ( (*(_BYTE *)(v76 - 24) & 1) != 0 )
          free(*(void **)(v76 - 8));
        if ( (*v77 & 1) != 0 )
          free(*(void **)(v76 - 32));
        *(_QWORD *)(a3 + 8) = v77;
      }
      return (__int64)v4;
    }
    v16 = *(_QWORD *)(a3 + 8);
    if ( 0xAAAAAAAAAAAAAAABLL * ((v16 - *(_QWORD *)a3) >> 4) < 2 )
      return (__int64)v4;
    v17 = *(unsigned __int8 *)(v16 - 24);
    if ( (v17 & 1) != 0 )
      v18 = *(const void **)(v16 - 8);
    else
      v18 = (const void *)(v16 - 23);
    if ( (v17 & 1) != 0 )
      v19 = *(_QWORD *)(v16 - 16);
    else
      v19 = v17 >> 1;
    sub_42BE4((size_t *)(v16 - 48), v18, v19);
    p = *(void **)(v16 - 32);
    v111 = *(_OWORD *)(v16 - 48);
    *(_QWORD *)(v16 - 40) = 0;
    *(_QWORD *)(v16 - 32) = 0;
    *(_QWORD *)(v16 - 48) = 0;
    v20 = *(_QWORD *)(a3 + 8);
    v21 = (_BYTE *)(v20 - 48);
    if ( (*(_BYTE *)(v20 - 24) & 1) != 0 )
      free(*(void **)(v20 - 8));
    if ( (*v21 & 1) != 0 )
      free(*(void **)(v20 - 32));
    *(_QWORD *)(a3 + 8) = v21;
    v22 = v111;
    v23 = (size_t *)(v20 - 96);
    v24 = p;
    if ( (v111 & 1) != 0 )
      v25 = (char *)p;
    else
      v25 = (char *)&v111 + 1;
    if ( (v111 & 1) != 0 )
      v26 = *((_QWORD *)&v111 + 1);
    else
      v26 = (unsigned __int64)(unsigned __int8)v111 >> 1;
    sub_42BE4(v23, v25, v26);
    if ( (unsigned __int8 *)v15 == a2 )
    {
      v107 = *(_QWORD *)(a3 + 8);
      v108 = (_BYTE *)(v107 - 48);
      if ( (*(_BYTE *)(v107 - 24) & 1) != 0 )
        free(*(void **)(v107 - 8));
      if ( (*v108 & 1) != 0 )
        free(*(void **)(v107 - 32));
      *(_QWORD *)(a3 + 8) = v108;
      v27 = 1;
      if ( (v22 & 1) == 0 )
        goto LABEL_39;
    }
    else
    {
      v27 = 0;
      if ( (v111 & 1) == 0 )
      {
LABEL_39:
        if ( v27 )
          return (__int64)v4;
        v14 = (_BYTE *)v15;
        goto LABEL_41;
      }
    }
    free(v24);
    goto LABEL_39;
  }
  if ( !v7 )
    return v9;
  v10 = *(_QWORD *)(a3 + 8);
  if ( *(_QWORD *)a3 != v10 )
  {
    sub_429F4((size_t *)(v10 - 48), 0, "::", 2u);
    return v9;
  }
  return (__int64)v4;
}
// 42FE0: using guessed type __int64 __fastcall sub_42FE0(_QWORD, _QWORD, _QWORD);

//----- (0000000000050168) ----------------------------------------------------
unsigned __int8 *__fastcall sub_50168(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int64 *a4)
{
  unsigned __int8 *v4; // x21
  unsigned __int8 *v7; // x8
  int v8; // w9
  unsigned __int8 *v9; // x28
  unsigned __int64 v10; // x25
  size_t v11; // x22
  _WORD *v12; // x0
  unsigned __int64 v13; // x8
  _OWORD *v14; // x9
  unsigned __int64 v15; // x23
  __int64 v16; // x22
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x9
  char *v20; // x0
  const void *v21; // x1
  __int64 v22; // x8
  __int64 v23; // x9
  void *v24; // x22
  char v25; // w23
  __int64 v26; // x8
  __int64 v27; // x9
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x9
  unsigned __int64 v30; // x26
  __int64 v31; // x25
  unsigned __int64 v32; // x9
  unsigned __int64 v33; // x9
  unsigned __int64 v34; // x9
  char *v35; // x0
  char *v36; // x10
  unsigned __int64 v37; // x11
  unsigned __int64 v38; // x23
  char *v39; // x8
  _OWORD *v40; // x9
  __int64 v41; // x12
  unsigned __int64 v42; // x22
  unsigned __int64 v43; // x25
  unsigned __int64 v44; // x26
  unsigned __int64 v45; // x8
  void *v46; // x0
  char *v47; // x8
  char *v48; // x9
  void **v49; // x11
  void **v50; // x23
  char *v51; // x10
  __int64 v52; // x12
  void **v53; // x22
  unsigned __int64 v54; // x25
  void **v55; // x26
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x22
  unsigned __int64 v58; // x8
  size_t *v59; // x25
  size_t v60; // x23
  unsigned __int64 v61; // x26
  __int64 v62; // x9
  unsigned __int64 v63; // x24
  unsigned __int64 v64; // x10
  unsigned __int64 v65; // x11
  _BYTE *v66; // x0
  void *v67; // x8
  unsigned __int8 *v68; // x8
  _BYTE *v69; // x9
  _OWORD *v70; // x11
  __int128 *v71; // x12
  unsigned __int64 v72; // x13
  __int128 v73; // q0
  __int128 v74; // q1
  char v75; // t1
  char v76; // w22
  void *v77; // x21
  char *v78; // x1
  size_t v79; // x2
  unsigned __int64 v80; // x8
  size_t v81; // x8
  void *v82; // x0
  void *v83; // x26
  unsigned __int64 v84; // x8
  unsigned __int8 *v85; // x9
  size_t v86; // x10
  __int128 *v87; // x12
  _OWORD *v88; // x13
  unsigned __int64 v89; // x14
  __int128 v90; // q0
  __int128 v91; // q1
  unsigned __int8 v92; // t1
  size_t v93; // x8
  unsigned __int64 v94; // x8
  size_t v95; // x2
  const void *v96; // x1
  void *v98; // [xsp+8h] [xbp-B8h]
  size_t v99; // [xsp+10h] [xbp-B0h]
  void *v100; // [xsp+18h] [xbp-A8h]
  __int128 v101; // [xsp+20h] [xbp-A0h] BYREF
  void *p; // [xsp+30h] [xbp-90h]
  _QWORD v103[2]; // [xsp+38h] [xbp-88h] BYREF
  _QWORD v104[2]; // [xsp+48h] [xbp-78h] BYREF
  _QWORD v105[3]; // [xsp+58h] [xbp-68h] BYREF

  v4 = a1;
  v105[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 == a2 )
    return v4;
  v7 = *a1 == 110 ? a1 + 1 : a1;
  if ( v7 == a2 )
    return v4;
  v8 = *v7;
  if ( v8 == 48 )
  {
    v9 = v7 + 1;
  }
  else
  {
    if ( (unsigned int)(v8 - 49) > 8 )
      return v4;
    v9 = v7 + 1;
    if ( v7 + 1 == a2 )
      return v4;
    while ( (unsigned int)*v9 - 48 < 0xA )
    {
      if ( a2 == ++v9 )
        return v4;
    }
  }
  if ( v9 == a1 || v9 == a2 || *v9 != 69 )
    return v4;
  v10 = *a3;
  if ( (v10 & 1) != 0 )
    v11 = *((_QWORD *)a3 + 1);
  else
    v11 = v10 >> 1;
  if ( v11 >= 4 )
  {
    v101 = 0u;
    p = 0;
    if ( v11 + 1 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    if ( v11 + 1 > 0x16 )
    {
      v12 = malloc((v11 + 17) & 0xFFFFFFFFFFFFFFF0LL);
      *(_QWORD *)&v101 = (v11 + 17) & 0xFFFFFFFFFFFFFFF0LL | 1;
      *((_QWORD *)&v101 + 1) = 1;
      p = v12;
    }
    else
    {
      LOBYTE(v101) = 2;
      v12 = (_WORD *)((char *)&v101 + 1);
    }
    *v12 = 40;
    if ( (v10 & 1) != 0 )
      v21 = (const void *)*((_QWORD *)a3 + 2);
    else
      v21 = a3 + 1;
    sub_42BE4((size_t *)&v101, v21, v11);
    sub_42BE4((size_t *)&v101, ")", 1u);
    v22 = *(_QWORD *)((char *)&v101 + 1);
    v23 = *((_QWORD *)&v101 + 1);
    v24 = p;
    v25 = v101;
    v101 = 0u;
    p = 0;
    *(_QWORD *)((char *)v103 + 7) = v23;
    v103[0] = v22;
    v26 = *(_QWORD *)((char *)v103 + 7);
    v27 = v103[0];
    memset(v104, 0, 15);
    memset(v103, 0, 15);
    *(_QWORD *)((char *)v105 + 7) = v26;
    v105[0] = v27;
    v28 = a4[1];
    v29 = a4[2];
    if ( v28 < v29 )
    {
      *(_BYTE *)v28 = v25;
      *(_QWORD *)(v28 + 8) = *(_QWORD *)((char *)v105 + 7);
      *(_QWORD *)(v28 + 16) = v24;
      *(_QWORD *)(v28 + 1) = v105[0];
      memset(v105, 0, 15);
      *(_BYTE *)(v28 + 24) = 0;
      *(_QWORD *)(v28 + 32) = *(_QWORD *)((char *)v104 + 7);
      *(_QWORD *)(v28 + 40) = 0;
      *(_QWORD *)(v28 + 25) = v104[0];
      memset(v104, 0, 15);
      a4[1] += 48LL;
      if ( (v101 & 1) == 0 )
        goto LABEL_88;
      goto LABEL_86;
    }
    v30 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v28 - *a4) >> 4);
    v31 = 0x555555555555555LL;
    if ( v30 + 1 > 0x555555555555555LL )
      abort();
    v32 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v29 - *a4) >> 4);
    if ( v32 >= 0x2AAAAAAAAAAAAAALL || ((v33 = 2 * v32, v33 >= v30 + 1) ? (v31 = v33) : (v31 = v30 + 1), v31) )
    {
      v34 = a4[3];
      v35 = *(char **)(v34 + 4096);
      if ( v34 + 4096 - (unsigned __int64)v35 >= 48 * v31 )
        *(_QWORD *)(v34 + 4096) = &v35[48 * v31];
      else
        v35 = (char *)malloc(48 * v31);
    }
    else
    {
      v35 = 0;
    }
    v47 = &v35[48 * v30];
    *v47 = v25;
    v48 = &v35[48 * v31];
    *((_QWORD *)v47 + 1) = *(_QWORD *)((char *)v105 + 7);
    *((_QWORD *)v47 + 2) = v24;
    *(_QWORD *)(v47 + 1) = v105[0];
    memset(v105, 0, 15);
    v47[24] = 0;
    *((_QWORD *)v47 + 4) = *(_QWORD *)((char *)v104 + 7);
    *((_QWORD *)v47 + 5) = 0;
    *(_QWORD *)(v47 + 25) = v104[0];
    memset(v104, 0, 15);
    v50 = (void **)*a4;
    v49 = (void **)a4[1];
    v51 = v47 + 48;
    if ( v49 == (void **)*a4 )
    {
      v53 = (void **)*a4;
    }
    else
    {
      do
      {
        *((_QWORD *)v47 - 4) = *(v49 - 4);
        *((_OWORD *)v47 - 3) = *((_OWORD *)v49 - 3);
        v52 = (__int64)*(v49 - 1);
        *(v49 - 5) = 0;
        *(v49 - 4) = 0;
        *(v49 - 6) = 0;
        *((_QWORD *)v47 - 1) = v52;
        *(_OWORD *)(v47 - 24) = *(_OWORD *)(v49 - 3);
        *(v49 - 3) = 0;
        *(v49 - 2) = 0;
        *(v49 - 1) = 0;
        v49 -= 6;
        v47 -= 48;
      }
      while ( v50 != v49 );
      v53 = (void **)*a4;
      v50 = (void **)a4[1];
    }
    v54 = a4[2];
    *a4 = (unsigned __int64)v47;
    a4[1] = (unsigned __int64)v51;
    a4[2] = (unsigned __int64)v48;
    if ( v50 != v53 )
    {
      do
      {
        if ( (*(_BYTE *)(v50 - 3) & 1) != 0 )
          free(*(v50 - 1));
        v55 = v50 - 6;
        if ( (*(_BYTE *)(v50 - 6) & 1) != 0 )
          free(*(v50 - 4));
        v50 -= 6;
      }
      while ( v53 != v55 );
    }
    if ( v53 )
    {
      v56 = a4[3];
      if ( v56 + 4096 < (unsigned __int64)v53 || v56 > (unsigned __int64)v53 )
      {
        free(v53);
      }
      else if ( *(_QWORD *)(v56 + 4096) == v54 )
      {
        *(_QWORD *)(v56 + 4096) = v53;
        if ( (v101 & 1) == 0 )
          goto LABEL_88;
LABEL_86:
        v46 = p;
        goto LABEL_87;
      }
    }
    if ( (v101 & 1) == 0 )
      goto LABEL_88;
    goto LABEL_86;
  }
  v14 = (_OWORD *)a4[1];
  v13 = a4[2];
  if ( (unsigned __int64)v14 < v13 )
  {
    v14[1] = 0u;
    v14[2] = 0u;
    *v14 = 0u;
    a4[1] += 48LL;
    goto LABEL_88;
  }
  v15 = 0xAAAAAAAAAAAAAAABLL * ((__int64)((__int64)v14 - *a4) >> 4);
  v16 = 0x555555555555555LL;
  if ( v15 + 1 > 0x555555555555555LL )
    goto LABEL_161;
  v17 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v13 - *a4) >> 4);
  if ( v17 >= 0x2AAAAAAAAAAAAAALL || ((v18 = 2 * v17, v18 >= v15 + 1) ? (v16 = v18) : (v16 = v15 + 1), v16) )
  {
    v19 = a4[3];
    v20 = *(char **)(v19 + 4096);
    if ( v19 + 4096 - (unsigned __int64)v20 >= 48 * v16 )
      *(_QWORD *)(v19 + 4096) = &v20[48 * v16];
    else
      v20 = (char *)malloc(48 * v16);
  }
  else
  {
    v20 = 0;
  }
  v36 = &v20[48 * v15];
  *((_OWORD *)v36 + 1) = 0u;
  *((_OWORD *)v36 + 2) = 0u;
  *(_OWORD *)v36 = 0u;
  v38 = *a4;
  v37 = a4[1];
  v39 = &v20[48 * v16];
  v40 = v36 + 48;
  if ( v37 == *a4 )
  {
    v42 = *a4;
  }
  else
  {
    do
    {
      *((_QWORD *)v36 - 4) = *(_QWORD *)(v37 - 32);
      *((_OWORD *)v36 - 3) = *(_OWORD *)(v37 - 48);
      v41 = *(_QWORD *)(v37 - 8);
      *(_QWORD *)(v37 - 40) = 0;
      *(_QWORD *)(v37 - 32) = 0;
      *(_QWORD *)(v37 - 48) = 0;
      *((_QWORD *)v36 - 1) = v41;
      *(_OWORD *)(v36 - 24) = *(_OWORD *)(v37 - 24);
      *(_QWORD *)(v37 - 24) = 0;
      *(_QWORD *)(v37 - 16) = 0;
      *(_QWORD *)(v37 - 8) = 0;
      v37 -= 48LL;
      v36 -= 48;
    }
    while ( v38 != v37 );
    v42 = *a4;
    v38 = a4[1];
  }
  v43 = a4[2];
  *a4 = (unsigned __int64)v36;
  a4[1] = (unsigned __int64)v40;
  a4[2] = (unsigned __int64)v39;
  if ( v38 != v42 )
  {
    do
    {
      if ( (*(_BYTE *)(v38 - 24) & 1) != 0 )
        free(*(void **)(v38 - 8));
      v44 = v38 - 48;
      if ( (*(_BYTE *)(v38 - 48) & 1) != 0 )
        free(*(void **)(v38 - 32));
      v38 -= 48LL;
    }
    while ( v42 != v44 );
  }
  if ( v42 )
  {
    v45 = a4[3];
    if ( v45 + 4096 < v42 || v45 > v42 )
    {
      v46 = (void *)v42;
LABEL_87:
      free(v46);
      goto LABEL_88;
    }
    if ( *(_QWORD *)(v45 + 4096) == v43 )
      *(_QWORD *)(v45 + 4096) = v42;
  }
LABEL_88:
  if ( *v4 == 110 )
  {
    sub_57F64((size_t *)(a4[1] - 48), 45);
    ++v4;
  }
  v57 = a4[1];
  v59 = (size_t *)(v57 - 48);
  v58 = *(unsigned __int8 *)(v57 - 48);
  if ( (*(_BYTE *)(v57 - 48) & 1) == 0 )
  {
    v60 = v58 >> 1;
    v61 = 22;
    LOBYTE(v62) = *(_BYTE *)(v57 - 48);
    v63 = v9 - v4;
    if ( v9 == v4 )
      goto LABEL_151;
LABEL_94:
    if ( (v58 & 1) != 0 )
    {
      v65 = *(_QWORD *)(v57 - 40);
      v64 = *(_QWORD *)(v57 - 32);
      if ( v64 > (unsigned __int64)v4 )
        goto LABEL_103;
    }
    else
    {
      v64 = v57 - 47;
      v65 = v58 >> 1;
      if ( v57 - 47 > (unsigned __int64)v4 )
        goto LABEL_103;
    }
    if ( v64 + v65 > (unsigned __int64)v4 )
    {
      v101 = 0u;
      p = 0;
      if ( v63 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_161;
      if ( v63 > 0x16 )
      {
        v66 = malloc((v63 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        *((_QWORD *)&v101 + 1) = v63;
        p = v66;
        *(_QWORD *)&v101 = (v63 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        if ( v4 == v9 )
          goto LABEL_115;
      }
      else
      {
        LOBYTE(v101) = 2 * v63;
        v66 = (char *)&v101 + 1;
        if ( v4 == v9 )
        {
LABEL_115:
          *v66 = 0;
          v76 = v101;
          v77 = p;
          if ( (v101 & 1) != 0 )
            v78 = (char *)p;
          else
            v78 = (char *)&v101 + 1;
          if ( (v101 & 1) != 0 )
            v79 = *((_QWORD *)&v101 + 1);
          else
            v79 = (unsigned __int64)(unsigned __int8)v101 >> 1;
          sub_42BE4(v59, v78, v79);
          if ( (v76 & 1) != 0 )
            free(v77);
          goto LABEL_151;
        }
      }
      if ( v63 >= 0x20 )
      {
        v70 = v66 + 16;
        v68 = &v4[v63 & 0xFFFFFFFFFFFFFFE0LL];
        v69 = &v66[v63 & 0xFFFFFFFFFFFFFFE0LL];
        v71 = (__int128 *)(v4 + 16);
        v72 = v63 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v73 = *(v71 - 1);
          v74 = *v71;
          v72 -= 32LL;
          v71 += 2;
          *(v70 - 1) = v73;
          *v70 = v74;
          v70 += 2;
        }
        while ( v72 );
        if ( (v63 & 0xFFFFFFFFFFFFFFE0LL) == v63 )
          goto LABEL_114;
      }
      else
      {
        v68 = v4;
        v69 = v66;
      }
      do
      {
        v75 = *v68++;
        *v69++ = v75;
      }
      while ( v9 != v68 );
LABEL_114:
      v66 += v63;
      goto LABEL_115;
    }
LABEL_103:
    if ( v61 - v60 >= v63 )
    {
LABEL_136:
      if ( (v62 & 1) != 0 )
        v84 = *(_QWORD *)(v57 - 32);
      else
        v84 = v57 - 47;
      v85 = (unsigned __int8 *)(v84 + v60);
      if ( v4 != v9 )
      {
        v86 = v60 - (_QWORD)v4;
        if ( v63 < 0x20 || v85 < v9 && v4 < &v9[v84 + v86] )
          goto LABEL_166;
        v87 = (__int128 *)(v4 + 16);
        v85 += v63 & 0xFFFFFFFFFFFFFFE0LL;
        v4 += v63 & 0xFFFFFFFFFFFFFFE0LL;
        v88 = (_OWORD *)(v84 + v60 + 16);
        v89 = v63 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v90 = *(v87 - 1);
          v91 = *v87;
          v87 += 2;
          v89 -= 32LL;
          *(v88 - 1) = v90;
          *v88 = v91;
          v88 += 2;
        }
        while ( v89 );
        if ( (v63 & 0xFFFFFFFFFFFFFFE0LL) != v63 )
        {
LABEL_166:
          do
          {
            v92 = *v4++;
            *v85++ = v92;
          }
          while ( v9 != v4 );
        }
        v85 = &v9[v86 + v84];
      }
      *v85 = 0;
      v93 = v60 + v63;
      if ( (*(_BYTE *)v59 & 1) != 0 )
        *(_QWORD *)(v57 - 40) = v93;
      else
        *(_BYTE *)v59 = 2 * v93;
      goto LABEL_151;
    }
    if ( -17LL - v61 >= v60 + v63 - v61 )
    {
      if ( (v58 & 1) != 0 )
        v67 = *(void **)(v57 - 32);
      else
        v67 = (void *)(v57 - 47);
      v100 = v67;
      if ( v61 > 0x7FFFFFFFFFFFFFE6LL )
      {
        v81 = -17;
      }
      else
      {
        v80 = 2 * v61;
        if ( v60 + v63 >= 2 * v61 )
          v80 = v60 + v63;
        if ( v80 >= 0x17 )
          v81 = (v80 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        else
          v81 = 23;
      }
      v99 = v81;
      v82 = malloc(v81);
      if ( v60 )
      {
        v98 = v82;
        memcpy(v82, v100, v60);
        v82 = v98;
      }
      if ( v61 != 22 )
      {
        v83 = v82;
        free(v100);
        v82 = v83;
      }
      *(_QWORD *)(v57 - 32) = v82;
      LOBYTE(v62) = v99 | 1;
      *(_QWORD *)(v57 - 48) = v99 | 1;
      goto LABEL_136;
    }
LABEL_161:
    abort();
  }
  v62 = *(_QWORD *)(v57 - 48);
  v60 = *(_QWORD *)(v57 - 40);
  v61 = (v62 & 0xFFFFFFFFFFFFFFFELL) - 1;
  v63 = v9 - v4;
  if ( v9 != v4 )
    goto LABEL_94;
LABEL_151:
  v94 = *a3;
  if ( (v94 & 1) != 0 )
    v95 = *((_QWORD *)a3 + 1);
  else
    v95 = v94 >> 1;
  if ( v95 <= 3 )
  {
    if ( (v94 & 1) != 0 )
      v96 = (const void *)*((_QWORD *)a3 + 2);
    else
      v96 = a3 + 1;
    sub_42BE4((size_t *)(a4[1] - 48), v96, v95);
  }
  return v9 + 1;
}

//----- (0000000000050A9C) ----------------------------------------------------
size_t *__usercall sub_50A9C@<X0>(unsigned __int8 *a1@<X0>, const char *a2@<X1>, size_t *a3@<X8>)
{
  unsigned __int64 v5; // x8
  size_t v7; // x21
  size_t v8; // x22
  const void *v9; // x23
  size_t v10; // x0
  unsigned __int64 v11; // x8
  void *v12; // x24
  size_t v13; // x25

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v5 = *a1;
  if ( (v5 & 1) != 0 )
  {
    v7 = *((_QWORD *)a1 + 1);
    v10 = strlen(a2);
    v9 = (const void *)*((_QWORD *)a1 + 2);
    v8 = v10;
  }
  else
  {
    v7 = v5 >> 1;
    v8 = strlen(a2);
    v9 = a1 + 1;
  }
  v11 = v7 + v8;
  if ( v7 + v8 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v11 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * v7;
    v12 = (char *)a3 + 1;
    if ( !v7 )
      goto LABEL_10;
    goto LABEL_9;
  }
  v13 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v12 = malloc(v13);
  a3[1] = v7;
  a3[2] = (size_t)v12;
  *a3 = v13 | 1;
  if ( v7 )
LABEL_9:
    memcpy(v12, v9, v7);
LABEL_10:
  *((_BYTE *)v12 + v7) = 0;
  return sub_42BE4(a3, a2, v8);
}

//----- (0000000000050BA4) ----------------------------------------------------
__int64 __fastcall sub_50BA4(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // x21
  unsigned __int8 *v4; // x20
  int v6; // w8
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x23
  __int64 result; // x0
  __int64 v10; // x21
  unsigned __int64 v11; // x8
  const void *v12; // x1
  size_t v13; // x2
  __int64 v14; // x21
  _BYTE *v15; // x22
  char v16; // w22
  size_t *v17; // x0
  void *v18; // x21
  char *v19; // x1
  size_t v20; // x2
  unsigned __int8 *v21; // x22
  __int64 v22; // x21
  unsigned __int64 v23; // x8
  const void *v24; // x1
  size_t v25; // x2
  __int64 v26; // x21
  _BYTE *v27; // x22
  unsigned __int8 *v28; // x23
  __int64 v29; // x8
  __int128 v30; // [xsp+0h] [xbp-50h] BYREF
  char *v31; // [xsp+10h] [xbp-40h]
  __int64 v32; // [xsp+18h] [xbp-38h]

  v3 = a2;
  v4 = a1;
  v32 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 2 )
    return (__int64)v4;
  v6 = *a1;
  if ( (v6 == 111 || v6 == 100) && a1[1] == 110 )
  {
    v7 = a1 + 2;
    if ( v6 == 111 )
    {
      v8 = sub_51914(a1 + 2, a2, a3);
      result = (__int64)v4;
      if ( v8 != v7 )
      {
        v4 = (unsigned __int8 *)sub_42FE0(v8, v3, a3);
        result = (__int64)v8;
        if ( v4 != v8 )
        {
          v10 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v10 - *(_QWORD *)a3) >> 4) >= 2 )
          {
            v11 = *(unsigned __int8 *)(v10 - 24);
            if ( (v11 & 1) != 0 )
              v12 = *(const void **)(v10 - 8);
            else
              v12 = (const void *)(v10 - 23);
            if ( (v11 & 1) != 0 )
              v13 = *(_QWORD *)(v10 - 16);
            else
              v13 = v11 >> 1;
            sub_42BE4((size_t *)(v10 - 48), v12, v13);
            v31 = *(char **)(v10 - 32);
            v30 = *(_OWORD *)(v10 - 48);
            *(_QWORD *)(v10 - 40) = 0;
            *(_QWORD *)(v10 - 32) = 0;
            *(_QWORD *)(v10 - 48) = 0;
            v14 = *(_QWORD *)(a3 + 8);
            v15 = (_BYTE *)(v14 - 48);
            if ( (*(_BYTE *)(v14 - 24) & 1) != 0 )
              free(*(void **)(v14 - 8));
            if ( (*v15 & 1) != 0 )
              free(*(void **)(v14 - 32));
            *(_QWORD *)(a3 + 8) = v15;
            v16 = v30;
            v17 = (size_t *)(v14 - 96);
            v18 = v31;
            if ( (v30 & 1) != 0 )
              v19 = v31;
            else
              v19 = (char *)&v30 + 1;
            if ( (v30 & 1) != 0 )
              v20 = *((_QWORD *)&v30 + 1);
            else
              v20 = (unsigned __int64)(unsigned __int8)v30 >> 1;
LABEL_45:
            sub_42BE4(v17, v19, v20);
            if ( (v16 & 1) != 0 )
              free(v18);
            return (__int64)v4;
          }
          return (__int64)v4;
        }
      }
    }
    else
    {
      if ( v7 != a2 )
      {
        v28 = sub_50EE8(a1 + 2, a2, (void **)a3);
        if ( v28 == v7 )
          v28 = (unsigned __int8 *)((__int64 (__fastcall *)(unsigned __int8 *, unsigned __int8 *, __int64))loc_572B4)(
                                     v4 + 2,
                                     v3,
                                     a3);
        if ( v28 == v7 )
        {
          v3 = v4 + 2;
        }
        else
        {
          v29 = *(_QWORD *)(a3 + 8);
          v3 = v4 + 2;
          if ( *(_QWORD *)a3 != v29 )
          {
            sub_429F4((size_t *)(v29 - 48), 0, "~", 1u);
            v3 = v28;
          }
        }
      }
      if ( v3 == v7 )
        return (__int64)v4;
      else
        return (__int64)v3;
    }
  }
  else
  {
    result = ((__int64 (__fastcall *)(unsigned __int8 *, unsigned __int8 *, __int64))loc_572B4)(a1, a2, a3);
    if ( (unsigned __int8 *)result == v4 )
    {
      v21 = sub_51914(v4, v3, a3);
      result = (__int64)v4;
      if ( v21 != v4 )
      {
        v4 = (unsigned __int8 *)sub_42FE0(v21, v3, a3);
        result = (__int64)v21;
        if ( v4 != v21 )
        {
          v22 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v22 - *(_QWORD *)a3) >> 4) >= 2 )
          {
            v23 = *(unsigned __int8 *)(v22 - 24);
            if ( (v23 & 1) != 0 )
              v24 = *(const void **)(v22 - 8);
            else
              v24 = (const void *)(v22 - 23);
            if ( (v23 & 1) != 0 )
              v25 = *(_QWORD *)(v22 - 16);
            else
              v25 = v23 >> 1;
            sub_42BE4((size_t *)(v22 - 48), v24, v25);
            v31 = *(char **)(v22 - 32);
            v30 = *(_OWORD *)(v22 - 48);
            *(_QWORD *)(v22 - 40) = 0;
            *(_QWORD *)(v22 - 32) = 0;
            *(_QWORD *)(v22 - 48) = 0;
            v26 = *(_QWORD *)(a3 + 8);
            v27 = (_BYTE *)(v26 - 48);
            if ( (*(_BYTE *)(v26 - 24) & 1) != 0 )
              free(*(void **)(v26 - 8));
            if ( (*v27 & 1) != 0 )
              free(*(void **)(v26 - 32));
            *(_QWORD *)(a3 + 8) = v27;
            v16 = v30;
            v17 = (size_t *)(v26 - 96);
            v18 = v31;
            if ( (v30 & 1) != 0 )
              v19 = v31;
            else
              v19 = (char *)&v30 + 1;
            if ( (v30 & 1) != 0 )
              v20 = *((_QWORD *)&v30 + 1);
            else
              v20 = (unsigned __int64)(unsigned __int8)v30 >> 1;
            goto LABEL_45;
          }
          return (__int64)v4;
        }
      }
    }
  }
  return result;
}
// 42FE0: using guessed type __int64 __fastcall sub_42FE0(_QWORD, _QWORD, _QWORD);

//----- (0000000000050EE8) ----------------------------------------------------
unsigned __int8 *__fastcall sub_50EE8(unsigned __int8 *a1, unsigned __int8 *a2, void **a3)
{
  int v6; // w8
  unsigned __int64 v7; // x24
  __int64 v8; // x0
  _BYTE *v9; // x8
  unsigned __int8 *v10; // x20
  unsigned __int64 v11; // x9
  char *v12; // x8
  char *v13; // x9
  void **v14; // x19
  unsigned __int8 *v15; // x21
  size_t *v16; // x8
  __int64 v17; // x1
  char *v18; // x8
  char *v19; // x9
  void **v20; // x19
  void *v21; // x8
  char *v22; // x8
  char *v23; // x9
  void **v24; // x20
  unsigned __int64 v25; // x21
  _BYTE *v27; // x10
  __int64 v28; // x24
  __int64 v29; // x9
  unsigned __int64 v30; // x9
  __int64 v31; // x22
  char *v32; // x0
  _BYTE *v33; // x10
  __int64 v34; // x24
  __int64 v35; // x9
  unsigned __int64 v36; // x9
  __int64 v37; // x22
  char *v38; // x0
  _QWORD *v39; // x9
  char *v40; // x10
  char *v41; // x9
  void **v42; // x12
  void **v43; // x21
  char *v44; // x8
  unsigned __int64 v45; // x11
  char *v46; // x10
  __int128 v47; // t1
  void **v48; // x22
  _QWORD *v49; // x9
  void *v50; // x24
  unsigned __int64 v51; // x8
  char *v52; // x10
  char *v53; // x9
  void **v54; // x12
  void **v55; // x20
  char *v56; // x8
  unsigned __int64 v57; // x11
  char *v58; // x10
  __int128 v59; // t1
  void **v60; // x22
  void **v61; // x21
  void **v62; // x22
  void *v63; // x24
  unsigned __int64 v64; // x8
  void **v65; // x20
  void **v66; // x22
  _BYTE *v67; // x10
  __int64 v68; // x24
  __int64 v69; // x9
  unsigned __int64 v70; // x9
  __int64 v71; // x22
  char *v72; // x0
  _QWORD *v73; // x9
  char *v74; // x10
  char *v75; // x9
  void **v76; // x12
  void **v77; // x20
  char *v78; // x8
  unsigned __int64 v79; // x11
  char *v80; // x10
  __int128 v81; // t1
  void **v82; // x22
  void *v83; // x24
  unsigned __int64 v84; // x8
  void **v85; // x20
  void **v86; // x22
  void *v87; // [xsp+8h] [xbp-78h] BYREF
  void *p[2]; // [xsp+10h] [xbp-70h] BYREF
  __int64 v89; // [xsp+20h] [xbp-60h]
  unsigned __int64 v90; // [xsp+28h] [xbp-58h]
  __int64 v91; // [xsp+38h] [xbp-48h]

  v91 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 == a2 )
    return a1;
  v6 = *a1;
  if ( v6 == 68 )
  {
    v15 = sub_46514(a1, a2, a3);
    if ( v15 == a1 )
      return a1;
    v21 = a3[1];
    v10 = a1;
    if ( *a3 == v21 )
      return v10;
    v87 = a3[3];
    sub_42D60(p, (__int64)v21 - 48, (__int64 *)&v87);
    v22 = (char *)a3[5];
    v23 = (char *)a3[6];
    if ( v22 < v23 )
    {
      *((_QWORD *)v22 + 3) = v90;
      *(_OWORD *)v22 = *(_OWORD *)p;
      *((_QWORD *)v22 + 2) = v89;
      p[1] = 0;
      v89 = 0;
      p[0] = 0;
      a3[5] = (char *)a3[5] + 32;
      v20 = (void **)p[0];
      if ( !p[0] )
        return v15;
      goto LABEL_95;
    }
    v33 = a3[4];
    v34 = (v22 - v33) >> 5;
    if ( (unsigned __int64)(v34 + 1) >> 59 )
      abort();
    v35 = v23 - v33;
    if ( (unsigned __int64)(v35 >> 5) > 0x3FFFFFFFFFFFFFELL )
    {
      v37 = 0x7FFFFFFFFFFFFFFLL;
    }
    else
    {
      v36 = v35 >> 4;
      if ( v36 >= v34 + 1 )
        v37 = v36;
      else
        v37 = v34 + 1;
      if ( !v37 )
      {
        v38 = 0;
LABEL_67:
        v52 = &v38[32 * v34];
        *((_QWORD *)v52 + 1) = 0;
        *((_QWORD *)v52 + 2) = 0;
        v53 = v52 + 32;
        *((_QWORD *)v52 + 3) = v90;
        *(_OWORD *)v52 = *(_OWORD *)p;
        *((_QWORD *)v52 + 2) = v89;
        p[1] = 0;
        v89 = 0;
        p[0] = 0;
        v55 = (void **)a3[4];
        v54 = (void **)a3[5];
        v56 = &v38[32 * v37];
        if ( v54 == v55 )
        {
          v60 = (void **)a3[4];
        }
        else
        {
          v57 = (char *)(v54 - 4) - (char *)v55;
          v58 = v52 - 32;
          do
          {
            *((_QWORD *)v58 + 1) = 0;
            *((_QWORD *)v58 + 2) = 0;
            *(_QWORD *)v58 = 0;
            *((_QWORD *)v58 + 3) = *(v54 - 1);
            v59 = *((_OWORD *)v54 - 2);
            v54 -= 4;
            *(_OWORD *)v58 = v59;
            *((_QWORD *)v58 + 2) = v54[2];
            v58 -= 32;
            *v54 = 0;
            v54[1] = 0;
            v54[2] = 0;
          }
          while ( v55 != v54 );
          v60 = (void **)a3[4];
          v55 = (void **)a3[5];
          v52 = &v38[32 * (v34 - 1 - (v57 >> 5))];
        }
        v63 = a3[6];
        a3[4] = v52;
        a3[5] = v53;
        a3[6] = v56;
        while ( v60 != v55 )
        {
          v55 -= 4;
          sub_42F30(v55);
        }
        if ( v60 )
        {
          v64 = (unsigned __int64)a3[7];
          if ( v64 + 4096 < (unsigned __int64)v60 || v64 > (unsigned __int64)v60 )
          {
            free(v60);
          }
          else if ( *(void **)(v64 + 4096) == v63 )
          {
            *(_QWORD *)(v64 + 4096) = v60;
            v20 = (void **)p[0];
            if ( !p[0] )
              return v15;
            goto LABEL_95;
          }
        }
        v20 = (void **)p[0];
        if ( !p[0] )
          return v15;
LABEL_95:
        v65 = (void **)p[1];
        if ( p[1] != v20 )
        {
          do
          {
            if ( (*(_BYTE *)(v65 - 3) & 1) != 0 )
              free(*(v65 - 1));
            v66 = v65 - 6;
            if ( (*(_BYTE *)(v65 - 6) & 1) != 0 )
              free(*(v65 - 4));
            v65 -= 6;
          }
          while ( v20 != v66 );
        }
        goto LABEL_101;
      }
    }
    v49 = a3[7];
    v38 = (char *)v49[512];
    if ( (char *)(v49 + 512) - v38 >= (unsigned __int64)(32 * v37) )
      v49[512] = &v38[32 * v37];
    else
      v38 = (char *)malloc(32 * v37);
    goto LABEL_67;
  }
  if ( v6 == 83 )
  {
    v10 = sub_43E00(a1, a2, a3);
    if ( v10 != a1 )
      return v10;
    if ( a2 - a1 < 3 )
      return a1;
    if ( a1[1] != 116 )
      return a1;
    v15 = sub_46760(a1 + 2, a2, (__int64)a3);
    if ( v15 == a1 + 2 )
      return a1;
    v16 = (size_t *)a3[1];
    v10 = a1;
    if ( *a3 == v16 )
      return v10;
    sub_429F4(v16 - 6, 0, "std::", 5u);
    v17 = (__int64)a3[1] - 48;
    v87 = a3[3];
    sub_42D60(p, v17, (__int64 *)&v87);
    v18 = (char *)a3[5];
    v19 = (char *)a3[6];
    if ( v18 < v19 )
    {
      *((_QWORD *)v18 + 3) = v90;
      *(_OWORD *)v18 = *(_OWORD *)p;
      *((_QWORD *)v18 + 2) = v89;
      p[1] = 0;
      v89 = 0;
      p[0] = 0;
      a3[5] = (char *)a3[5] + 32;
      v20 = (void **)p[0];
      if ( !p[0] )
        return v15;
      goto LABEL_133;
    }
    v67 = a3[4];
    v68 = (v18 - v67) >> 5;
    if ( (unsigned __int64)(v68 + 1) >> 59 )
      abort();
    v69 = v19 - v67;
    if ( (unsigned __int64)(v69 >> 5) > 0x3FFFFFFFFFFFFFELL )
    {
      v71 = 0x7FFFFFFFFFFFFFFLL;
    }
    else
    {
      v70 = v69 >> 4;
      if ( v70 >= v68 + 1 )
        v71 = v70;
      else
        v71 = v68 + 1;
      if ( !v71 )
      {
        v72 = 0;
        goto LABEL_118;
      }
    }
    v73 = a3[7];
    v72 = (char *)v73[512];
    if ( (char *)(v73 + 512) - v72 >= (unsigned __int64)(32 * v71) )
      v73[512] = &v72[32 * v71];
    else
      v72 = (char *)malloc(32 * v71);
LABEL_118:
    v74 = &v72[32 * v68];
    *((_QWORD *)v74 + 1) = 0;
    *((_QWORD *)v74 + 2) = 0;
    v75 = v74 + 32;
    *((_QWORD *)v74 + 3) = v90;
    *(_OWORD *)v74 = *(_OWORD *)p;
    *((_QWORD *)v74 + 2) = v89;
    p[1] = 0;
    v89 = 0;
    p[0] = 0;
    v77 = (void **)a3[4];
    v76 = (void **)a3[5];
    v78 = &v72[32 * v71];
    if ( v76 == v77 )
    {
      v82 = (void **)a3[4];
    }
    else
    {
      v79 = (char *)(v76 - 4) - (char *)v77;
      v80 = v74 - 32;
      do
      {
        *((_QWORD *)v80 + 1) = 0;
        *((_QWORD *)v80 + 2) = 0;
        *(_QWORD *)v80 = 0;
        *((_QWORD *)v80 + 3) = *(v76 - 1);
        v81 = *((_OWORD *)v76 - 2);
        v76 -= 4;
        *(_OWORD *)v80 = v81;
        *((_QWORD *)v80 + 2) = v76[2];
        v80 -= 32;
        *v76 = 0;
        v76[1] = 0;
        v76[2] = 0;
      }
      while ( v77 != v76 );
      v82 = (void **)a3[4];
      v77 = (void **)a3[5];
      v74 = &v72[32 * (v68 - 1 - (v79 >> 5))];
    }
    v83 = a3[6];
    a3[4] = v74;
    a3[5] = v75;
    a3[6] = v78;
    while ( v82 != v77 )
    {
      v77 -= 4;
      sub_42F30(v77);
    }
    if ( v82 )
    {
      v84 = (unsigned __int64)a3[7];
      if ( v84 + 4096 < (unsigned __int64)v82 || v84 > (unsigned __int64)v82 )
      {
        free(v82);
      }
      else if ( *(void **)(v84 + 4096) == v83 )
      {
        *(_QWORD *)(v84 + 4096) = v82;
        v20 = (void **)p[0];
        if ( !p[0] )
          return v15;
        goto LABEL_133;
      }
    }
    v20 = (void **)p[0];
    if ( p[0] )
    {
LABEL_133:
      v85 = (void **)p[1];
      if ( p[1] != v20 )
      {
        do
        {
          if ( (*(_BYTE *)(v85 - 3) & 1) != 0 )
            free(*(v85 - 1));
          v86 = v85 - 6;
          if ( (*(_BYTE *)(v85 - 6) & 1) != 0 )
            free(*(v85 - 4));
          v85 -= 6;
        }
        while ( v20 != v86 );
      }
LABEL_101:
      p[1] = v20;
      if ( v90 + 4096 < (unsigned __int64)v20 || v90 > (unsigned __int64)v20 )
      {
        free(v20);
      }
      else if ( *(_QWORD *)(v90 + 4096) == v89 )
      {
        *(_QWORD *)(v90 + 4096) = v20;
      }
    }
    return v15;
  }
  if ( v6 != 84 )
    return a1;
  v7 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a3[1] - (_BYTE *)*a3) >> 4);
  v8 = sub_454F4(a1, a2, (__int64)a3);
  v9 = a3[1];
  v10 = (unsigned __int8 *)v8;
  v11 = 0xAAAAAAAAAAAAAAABLL * ((v9 - (_BYTE *)*a3) >> 4);
  if ( (unsigned __int8 *)v8 == a1 || v11 != v7 + 1 )
  {
    if ( v11 != v7 )
    {
      v24 = (void **)(v9 - 48);
      v25 = v7 - v11;
      do
      {
        if ( ((_BYTE)v24[3] & 1) != 0 )
          free(v24[5]);
        if ( (*(_BYTE *)v24 & 1) != 0 )
          free(v24[2]);
        a3[1] = v24;
        ++v25;
        v24 -= 6;
      }
      while ( v25 );
    }
    return a1;
  }
  v87 = a3[3];
  sub_42D60(p, (__int64)(v9 - 48), (__int64 *)&v87);
  v12 = (char *)a3[5];
  v13 = (char *)a3[6];
  if ( v12 < v13 )
  {
    *((_QWORD *)v12 + 3) = v90;
    *(_OWORD *)v12 = *(_OWORD *)p;
    *((_QWORD *)v12 + 2) = v89;
    p[1] = 0;
    v89 = 0;
    p[0] = 0;
    a3[5] = (char *)a3[5] + 32;
    v14 = (void **)p[0];
    if ( !p[0] )
      return v10;
    goto LABEL_73;
  }
  v27 = a3[4];
  v28 = (v12 - v27) >> 5;
  if ( (unsigned __int64)(v28 + 1) >> 59 )
    abort();
  v29 = v13 - v27;
  if ( (unsigned __int64)(v29 >> 5) > 0x3FFFFFFFFFFFFFELL )
  {
    v31 = 0x7FFFFFFFFFFFFFFLL;
LABEL_47:
    v39 = a3[7];
    v32 = (char *)v39[512];
    if ( (char *)(v39 + 512) - v32 >= (unsigned __int64)(32 * v31) )
      v39[512] = &v32[32 * v31];
    else
      v32 = (char *)malloc(32 * v31);
    goto LABEL_50;
  }
  v30 = v29 >> 4;
  if ( v30 >= v28 + 1 )
    v31 = v30;
  else
    v31 = v28 + 1;
  if ( v31 )
    goto LABEL_47;
  v32 = 0;
LABEL_50:
  v40 = &v32[32 * v28];
  *((_QWORD *)v40 + 1) = 0;
  *((_QWORD *)v40 + 2) = 0;
  v41 = v40 + 32;
  *((_QWORD *)v40 + 3) = v90;
  *(_OWORD *)v40 = *(_OWORD *)p;
  *((_QWORD *)v40 + 2) = v89;
  p[1] = 0;
  v89 = 0;
  p[0] = 0;
  v43 = (void **)a3[4];
  v42 = (void **)a3[5];
  v44 = &v32[32 * v31];
  if ( v42 == v43 )
  {
    v48 = (void **)a3[4];
  }
  else
  {
    v45 = (char *)(v42 - 4) - (char *)v43;
    v46 = v40 - 32;
    do
    {
      *((_QWORD *)v46 + 1) = 0;
      *((_QWORD *)v46 + 2) = 0;
      *(_QWORD *)v46 = 0;
      *((_QWORD *)v46 + 3) = *(v42 - 1);
      v47 = *((_OWORD *)v42 - 2);
      v42 -= 4;
      *(_OWORD *)v46 = v47;
      *((_QWORD *)v46 + 2) = v42[2];
      v46 -= 32;
      *v42 = 0;
      v42[1] = 0;
      v42[2] = 0;
    }
    while ( v43 != v42 );
    v48 = (void **)a3[4];
    v43 = (void **)a3[5];
    v40 = &v32[32 * (v28 - 1 - (v45 >> 5))];
  }
  v50 = a3[6];
  a3[4] = v40;
  a3[5] = v41;
  a3[6] = v44;
  while ( v48 != v43 )
  {
    v43 -= 4;
    sub_42F30(v43);
  }
  if ( !v48 )
  {
LABEL_72:
    v14 = (void **)p[0];
    if ( !p[0] )
      return v10;
    goto LABEL_73;
  }
  v51 = (unsigned __int64)a3[7];
  if ( v51 + 4096 < (unsigned __int64)v48 || v51 > (unsigned __int64)v48 )
  {
    free(v48);
    goto LABEL_72;
  }
  if ( *(void **)(v51 + 4096) != v50 )
    goto LABEL_72;
  *(_QWORD *)(v51 + 4096) = v48;
  v14 = (void **)p[0];
  if ( !p[0] )
    return v10;
LABEL_73:
  v61 = (void **)p[1];
  if ( p[1] != v14 )
  {
    do
    {
      if ( (*(_BYTE *)(v61 - 3) & 1) != 0 )
        free(*(v61 - 1));
      v62 = v61 - 6;
      if ( (*(_BYTE *)(v61 - 6) & 1) != 0 )
        free(*(v61 - 4));
      v61 -= 6;
    }
    while ( v14 != v62 );
  }
  p[1] = v14;
  if ( v90 + 4096 < (unsigned __int64)v14 || v90 > (unsigned __int64)v14 )
  {
    free(v14);
  }
  else if ( *(_QWORD *)(v90 + 4096) == v89 )
  {
    *(_QWORD *)(v90 + 4096) = v14;
  }
  return v10;
}

//----- (0000000000051914) ----------------------------------------------------
unsigned __int8 *__fastcall sub_51914(_BYTE *a1, unsigned __int8 *a2, __int64 a3)
{
  _BYTE *v3; // x19
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x22
  __int64 v8; // x21
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x9
  __int64 v11; // x9
  char *v12; // x0
  unsigned __int8 *v13; // x22
  unsigned __int8 *v14; // x21
  __int64 v15; // x8
  size_t *v16; // x0
  char *v17; // x2
  size_t v18; // x3
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x22
  __int64 v21; // x21
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x9
  __int64 v24; // x9
  char *v25; // x0
  int v26; // w8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x22
  __int64 v29; // x21
  unsigned __int64 v30; // x9
  unsigned __int64 v31; // x9
  __int64 v32; // x9
  char *v33; // x0
  unsigned __int64 v34; // x9
  unsigned __int64 v35; // x22
  __int64 v36; // x21
  unsigned __int64 v37; // x9
  unsigned __int64 v38; // x9
  __int64 v39; // x9
  char *v40; // x0
  unsigned __int64 v41; // x9
  unsigned __int64 v42; // x22
  __int64 v43; // x21
  unsigned __int64 v44; // x9
  unsigned __int64 v45; // x9
  __int64 v46; // x9
  char *v47; // x0
  unsigned __int64 v48; // x9
  unsigned __int64 v49; // x22
  __int64 v50; // x21
  unsigned __int64 v51; // x9
  unsigned __int64 v52; // x9
  __int64 v53; // x9
  char *v54; // x0
  int v55; // w8
  unsigned __int64 v56; // x9
  unsigned __int64 v57; // x22
  __int64 v58; // x21
  unsigned __int64 v59; // x9
  unsigned __int64 v60; // x9
  __int64 v61; // x9
  char *v62; // x0
  unsigned __int64 v63; // x9
  unsigned __int64 v64; // x22
  __int64 v65; // x21
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // x9
  __int64 v68; // x9
  char *v69; // x0
  unsigned __int64 v70; // x9
  unsigned __int64 v71; // x22
  __int64 v72; // x21
  unsigned __int64 v73; // x9
  unsigned __int64 v74; // x9
  __int64 v75; // x9
  char *v76; // x0
  unsigned __int64 v77; // x9
  unsigned __int64 v78; // x22
  __int64 v79; // x21
  unsigned __int64 v80; // x9
  unsigned __int64 v81; // x9
  __int64 v82; // x9
  char *v83; // x0
  unsigned __int64 v84; // x9
  unsigned __int64 v85; // x22
  __int64 v86; // x21
  unsigned __int64 v87; // x9
  unsigned __int64 v88; // x9
  __int64 v89; // x9
  char *v90; // x0
  int v91; // w8
  unsigned __int64 v92; // x9
  unsigned __int64 v93; // x22
  __int64 v94; // x21
  unsigned __int64 v95; // x9
  unsigned __int64 v96; // x9
  __int64 v97; // x9
  char *v98; // x0
  unsigned __int64 v99; // x9
  unsigned __int64 v100; // x9
  unsigned __int64 v101; // x22
  __int64 v102; // x21
  unsigned __int64 v103; // x9
  unsigned __int64 v104; // x9
  __int64 v105; // x9
  char *v106; // x0
  unsigned __int64 v107; // x9
  unsigned __int64 v108; // x22
  __int64 v109; // x21
  unsigned __int64 v110; // x9
  unsigned __int64 v111; // x9
  __int64 v112; // x9
  char *v113; // x0
  unsigned __int64 v114; // x9
  unsigned __int64 v115; // x22
  __int64 v116; // x21
  unsigned __int64 v117; // x9
  unsigned __int64 v118; // x9
  __int64 v119; // x9
  char *v120; // x0
  unsigned __int64 v121; // x9
  unsigned __int64 v122; // x22
  __int64 v123; // x21
  unsigned __int64 v124; // x9
  unsigned __int64 v125; // x9
  __int64 v126; // x9
  char *v127; // x0
  unsigned __int64 v128; // x9
  unsigned __int64 v129; // x22
  __int64 v130; // x21
  unsigned __int64 v131; // x9
  unsigned __int64 v132; // x9
  __int64 v133; // x9
  char *v134; // x0
  unsigned __int64 v135; // x9
  unsigned __int64 v136; // x9
  unsigned __int64 v137; // x9
  unsigned __int64 v138; // x22
  __int64 v139; // x21
  unsigned __int64 v140; // x9
  unsigned __int64 v141; // x9
  __int64 v142; // x9
  char *v143; // x0
  unsigned __int64 v144; // x9
  unsigned __int64 v145; // x22
  __int64 v146; // x21
  unsigned __int64 v147; // x9
  unsigned __int64 v148; // x9
  __int64 v149; // x9
  char *v150; // x0
  unsigned __int64 v151; // x9
  unsigned __int64 v152; // x22
  __int64 v153; // x21
  unsigned __int64 v154; // x9
  unsigned __int64 v155; // x9
  __int64 v156; // x9
  char *v157; // x0
  char v158; // w24
  unsigned __int8 *v159; // x22
  __int64 v160; // x8
  unsigned __int64 v161; // x9
  unsigned __int64 v162; // x22
  __int64 v163; // x21
  unsigned __int64 v164; // x9
  unsigned __int64 v165; // x9
  __int64 v166; // x9
  char *v167; // x0
  unsigned __int8 *v168; // x22
  __int64 v169; // x8
  unsigned __int64 v170; // x9
  unsigned __int64 v171; // x22
  __int64 v172; // x21
  unsigned __int64 v173; // x9
  unsigned __int64 v174; // x9
  __int64 v175; // x9
  char *v176; // x0
  unsigned __int64 v177; // x9
  unsigned __int64 v178; // x22
  __int64 v179; // x21
  unsigned __int64 v180; // x9
  unsigned __int64 v181; // x9
  __int64 v182; // x9
  char *v183; // x0
  unsigned __int64 v184; // x8
  unsigned __int64 v185; // x9
  __int64 v186; // x9
  unsigned __int64 v187; // x9
  unsigned __int64 v188; // x22
  __int64 v189; // x21
  unsigned __int64 v190; // x9
  unsigned __int64 v191; // x9
  __int64 v192; // x9
  char *v193; // x0
  unsigned __int64 v194; // x9
  unsigned __int64 v195; // x22
  __int64 v196; // x21
  unsigned __int64 v197; // x9
  unsigned __int64 v198; // x9
  __int64 v199; // x9
  char *v200; // x0
  unsigned __int64 v201; // x9
  unsigned __int64 v202; // x22
  __int64 v203; // x21
  unsigned __int64 v204; // x9
  unsigned __int64 v205; // x9
  __int64 v206; // x9
  char *v207; // x0
  unsigned __int64 v208; // x9
  unsigned __int64 v209; // x22
  __int64 v210; // x21
  unsigned __int64 v211; // x9
  unsigned __int64 v212; // x9
  __int64 v213; // x9
  char *v214; // x0
  unsigned __int64 v215; // x9
  unsigned __int64 v216; // x22
  __int64 v217; // x21
  unsigned __int64 v218; // x9
  unsigned __int64 v219; // x9
  __int64 v220; // x9
  char *v221; // x0
  unsigned __int64 v222; // x9
  unsigned __int64 v223; // x9
  unsigned __int64 v224; // x22
  __int64 v225; // x21
  unsigned __int64 v226; // x9
  unsigned __int64 v227; // x9
  __int64 v228; // x9
  char *v229; // x0
  unsigned __int64 v230; // x9
  unsigned __int64 v231; // x22
  __int64 v232; // x21
  unsigned __int64 v233; // x9
  unsigned __int64 v234; // x9
  __int64 v235; // x9
  char *v236; // x0
  unsigned __int64 v237; // x9
  unsigned __int64 v238; // x22
  __int64 v239; // x21
  unsigned __int64 v240; // x9
  unsigned __int64 v241; // x9
  __int64 v242; // x9
  char *v243; // x0
  unsigned __int64 v244; // x9
  unsigned __int64 v245; // x22
  __int64 v246; // x21
  unsigned __int64 v247; // x9
  unsigned __int64 v248; // x9
  __int64 v249; // x9
  char *v250; // x0
  unsigned __int64 v251; // x9
  unsigned __int64 v252; // x22
  __int64 v253; // x21
  unsigned __int64 v254; // x9
  unsigned __int64 v255; // x9
  __int64 v256; // x9
  char *v257; // x0
  unsigned __int64 v258; // x9
  unsigned __int64 v259; // x22
  __int64 v260; // x21
  unsigned __int64 v261; // x9
  unsigned __int64 v262; // x9
  __int64 v263; // x9
  char *v264; // x0
  unsigned __int64 v265; // x9
  unsigned __int64 v266; // x22
  __int64 v267; // x21
  unsigned __int64 v268; // x9
  unsigned __int64 v269; // x9
  __int64 v270; // x9
  char *v271; // x0
  unsigned __int64 v272; // x9
  unsigned __int64 v273; // x9
  unsigned __int64 v274; // x9
  unsigned __int64 v275; // x9
  unsigned __int64 v276; // x22
  __int64 v277; // x21
  unsigned __int64 v278; // x9
  unsigned __int64 v279; // x9
  __int64 v280; // x9
  char *v281; // x0
  unsigned __int64 v282; // x9
  unsigned __int64 v283; // x9
  unsigned __int64 v284; // x22
  __int64 v285; // x21
  unsigned __int64 v286; // x9
  unsigned __int64 v287; // x9
  __int64 v288; // x9
  char *v289; // x0
  unsigned __int64 v290; // x22
  __int64 v291; // x21
  unsigned __int64 v292; // x9
  unsigned __int64 v293; // x9
  __int64 v294; // x9
  char *v295; // x0
  unsigned __int64 v296; // x22
  __int64 v297; // x21
  unsigned __int64 v298; // x9
  unsigned __int64 v299; // x9
  __int64 v300; // x9
  char *v301; // x0
  unsigned __int64 v302; // x22
  __int64 v303; // x21
  unsigned __int64 v304; // x9
  unsigned __int64 v305; // x9
  __int64 v306; // x9
  char *v307; // x0
  unsigned __int64 v308; // x22
  __int64 v309; // x21
  unsigned __int64 v310; // x9
  unsigned __int64 v311; // x9
  __int64 v312; // x9
  char *v313; // x0
  unsigned __int64 v314; // x22
  __int64 v315; // x21
  unsigned __int64 v316; // x9
  unsigned __int64 v317; // x9
  __int64 v318; // x9
  char *v319; // x0
  unsigned __int64 v320; // x22
  __int64 v321; // x21
  unsigned __int64 v322; // x9
  unsigned __int64 v323; // x9
  __int64 v324; // x9
  char *v325; // x0
  unsigned __int64 v326; // x22
  __int64 v327; // x21
  unsigned __int64 v328; // x9
  unsigned __int64 v329; // x9
  __int64 v330; // x9
  char *v331; // x0
  unsigned __int64 v332; // x22
  __int64 v333; // x21
  unsigned __int64 v334; // x9
  unsigned __int64 v335; // x9
  __int64 v336; // x9
  char *v337; // x0
  unsigned __int64 v338; // x22
  __int64 v339; // x21
  unsigned __int64 v340; // x9
  unsigned __int64 v341; // x9
  __int64 v342; // x9
  char *v343; // x0
  char *v344; // x8
  char *v345; // x9
  void **v346; // x11
  void **v347; // x22
  char *v348; // x10
  __int64 v349; // x12
  void **v350; // x21
  __int64 v351; // x24
  void **v352; // x25
  char *v353; // x8
  char *v354; // x9
  void **v355; // x11
  void **v356; // x22
  char *v357; // x10
  __int64 v358; // x12
  __int64 v359; // x24
  void **v360; // x25
  char *v361; // x8
  char *v362; // x9
  void **v363; // x11
  void **v364; // x22
  char *v365; // x10
  __int64 v366; // x12
  void **v367; // x25
  char *v368; // x8
  char *v369; // x9
  void **v370; // x11
  void **v371; // x22
  char *v372; // x10
  __int64 v373; // x12
  void **v374; // x25
  char *v375; // x8
  char *v376; // x9
  void **v377; // x11
  void **v378; // x22
  char *v379; // x10
  __int64 v380; // x12
  void **v381; // x25
  char *v382; // x8
  char *v383; // x9
  void **v384; // x11
  void **v385; // x22
  char *v386; // x10
  __int64 v387; // x12
  void **v388; // x25
  char *v389; // x8
  char *v390; // x9
  void **v391; // x11
  void **v392; // x22
  char *v393; // x10
  __int64 v394; // x12
  void **v395; // x25
  char *v396; // x8
  char *v397; // x9
  void **v398; // x11
  void **v399; // x22
  char *v400; // x10
  __int64 v401; // x12
  void **v402; // x25
  char *v403; // x8
  char *v404; // x9
  void **v405; // x11
  void **v406; // x22
  char *v407; // x10
  __int64 v408; // x12
  void **v409; // x25
  char *v410; // x8
  char *v411; // x9
  void **v412; // x11
  void **v413; // x22
  char *v414; // x10
  __int64 v415; // x12
  void **v416; // x25
  char *v417; // x8
  char *v418; // x9
  void **v419; // x11
  void **v420; // x22
  char *v421; // x10
  __int64 v422; // x12
  void **v423; // x25
  char *v424; // x8
  char *v425; // x9
  void **v426; // x11
  void **v427; // x22
  char *v428; // x10
  __int64 v429; // x12
  void **v430; // x25
  char *v431; // x8
  char *v432; // x9
  void **v433; // x11
  void **v434; // x22
  char *v435; // x10
  __int64 v436; // x12
  void **v437; // x25
  char *v438; // x8
  char *v439; // x9
  void **v440; // x11
  void **v441; // x22
  char *v442; // x10
  __int64 v443; // x12
  void **v444; // x25
  char *v445; // x8
  char *v446; // x9
  void **v447; // x11
  void **v448; // x22
  char *v449; // x10
  __int64 v450; // x12
  void **v451; // x25
  char *v452; // x8
  char *v453; // x9
  void **v454; // x11
  void **v455; // x22
  char *v456; // x10
  __int64 v457; // x12
  void **v458; // x25
  unsigned __int64 v459; // x8
  char *v460; // x8
  char *v461; // x9
  void **v462; // x11
  void **v463; // x22
  char *v464; // x10
  __int64 v465; // x12
  void **v466; // x25
  char *v467; // x8
  char *v468; // x9
  void **v469; // x11
  void **v470; // x22
  char *v471; // x10
  __int64 v472; // x12
  void **v473; // x25
  char *v474; // x8
  char *v475; // x9
  void **v476; // x11
  void **v477; // x22
  char *v478; // x10
  __int64 v479; // x12
  void **v480; // x25
  char *v481; // x8
  char *v482; // x9
  void **v483; // x11
  void **v484; // x22
  char *v485; // x10
  __int64 v486; // x12
  void **v487; // x25
  char *v488; // x8
  char *v489; // x9
  void **v490; // x11
  void **v491; // x22
  char *v492; // x10
  __int64 v493; // x12
  void **v494; // x25
  char *v495; // x8
  char *v496; // x9
  void **v497; // x11
  void **v498; // x22
  char *v499; // x10
  __int64 v500; // x12
  void **v501; // x25
  char *v502; // x8
  char *v503; // x9
  void **v504; // x11
  void **v505; // x22
  char *v506; // x10
  __int64 v507; // x12
  void **v508; // x25
  char *v509; // x8
  char *v510; // x9
  void **v511; // x11
  void **v512; // x22
  char *v513; // x10
  __int64 v514; // x12
  void **v515; // x25
  char *v516; // x8
  char *v517; // x9
  void **v518; // x11
  void **v519; // x22
  char *v520; // x10
  __int64 v521; // x12
  void **v522; // x25
  char *v523; // x8
  char *v524; // x9
  void **v525; // x11
  void **v526; // x22
  char *v527; // x10
  __int64 v528; // x12
  void **v529; // x25
  char *v530; // x8
  char *v531; // x9
  void **v532; // x11
  void **v533; // x22
  char *v534; // x10
  __int64 v535; // x12
  void **v536; // x25
  char *v537; // x8
  char *v538; // x9
  void **v539; // x11
  void **v540; // x22
  char *v541; // x10
  __int64 v542; // x12
  void **v543; // x25
  char *v544; // x8
  char *v545; // x9
  void **v546; // x11
  void **v547; // x22
  char *v548; // x10
  __int64 v549; // x12
  void **v550; // x25
  char *v551; // x8
  char *v552; // x9
  void **v553; // x11
  void **v554; // x22
  char *v555; // x10
  __int64 v556; // x12
  void **v557; // x25
  char *v558; // x8
  char *v559; // x9
  void **v560; // x11
  void **v561; // x22
  char *v562; // x10
  __int64 v563; // x12
  void **v564; // x25
  char *v565; // x8
  char *v566; // x9
  void **v567; // x11
  void **v568; // x22
  char *v569; // x10
  __int64 v570; // x12
  void **v571; // x25
  char *v572; // x8
  char *v573; // x9
  void **v574; // x11
  void **v575; // x22
  char *v576; // x10
  __int64 v577; // x12
  void **v578; // x25
  char *v579; // x8
  char *v580; // x9
  void **v581; // x11
  void **v582; // x22
  char *v583; // x10
  __int64 v584; // x12
  void **v585; // x25
  char *v586; // x8
  char *v587; // x9
  void **v588; // x11
  void **v589; // x22
  char *v590; // x10
  __int64 v591; // x12
  void **v592; // x25
  char *v593; // x8
  char *v594; // x9
  void **v595; // x11
  void **v596; // x22
  char *v597; // x10
  __int64 v598; // x12
  void **v599; // x25
  char *v600; // x8
  char *v601; // x9
  void **v602; // x11
  void **v603; // x22
  char *v604; // x10
  __int64 v605; // x12
  void **v606; // x25
  char *v607; // x8
  char *v608; // x9
  void **v609; // x11
  void **v610; // x22
  char *v611; // x10
  __int64 v612; // x12
  void **v613; // x25
  char *v614; // x8
  char *v615; // x9
  void **v616; // x11
  void **v617; // x22
  char *v618; // x10
  __int64 v619; // x12
  void **v620; // x25
  char *v621; // x8
  char *v622; // x9
  void **v623; // x11
  void **v624; // x22
  char *v625; // x10
  __int64 v626; // x12
  void **v627; // x25
  char *v628; // x8
  char *v629; // x9
  void **v630; // x11
  void **v631; // x22
  char *v632; // x10
  __int64 v633; // x12
  void **v634; // x25
  char *v635; // x8
  char *v636; // x9
  void **v637; // x11
  void **v638; // x22
  char *v639; // x10
  __int64 v640; // x12
  void **v641; // x25
  char *v642; // x8
  char *v643; // x9
  void **v644; // x11
  void **v645; // x22
  char *v646; // x10
  __int64 v647; // x12
  void **v648; // x25
  char *v649; // x8
  char *v650; // x9
  void **v651; // x11
  void **v652; // x22
  char *v653; // x10
  __int64 v654; // x12
  void **v655; // x25
  char *v656; // x8
  char *v657; // x9
  void **v658; // x11
  void **v659; // x22
  char *v660; // x10
  __int64 v661; // x12
  void **v662; // x25
  char *v663; // x8
  char *v664; // x9
  void **v665; // x11
  void **v666; // x22
  char *v667; // x10
  __int64 v668; // x12
  void **v669; // x25
  unsigned __int64 v670; // x8
  _QWORD v672[2]; // [xsp+68h] [xbp-68h] BYREF
  _QWORD v673[3]; // [xsp+78h] [xbp-58h] BYREF

  v3 = a1;
  v673[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a2 - a1 < 2 )
    return v3;
  switch ( *a1 )
  {
    case 'a':
      switch ( a1[1] )
      {
        case 'N':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator&=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v208 = *(_QWORD *)(a3 + 16);
          if ( v5 < v208 )
            goto LABEL_375;
          v209 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v210 = 0x555555555555555LL;
          if ( v209 + 1 > 0x555555555555555LL )
            abort();
          v211 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v208 - *(_QWORD *)a3) >> 4);
          if ( v211 >= 0x2AAAAAAAAAAAAAALL
            || ((v212 = 2 * v211, v212 >= v209 + 1) ? (v210 = v212) : (v210 = v209 + 1), v210) )
          {
            v213 = *(_QWORD *)(a3 + 24);
            v214 = *(char **)(v213 + 4096);
            if ( v213 + 4096 - (__int64)v214 >= (unsigned __int64)(48 * v210) )
              *(_QWORD *)(v213 + 4096) = &v214[48 * v210];
            else
              v214 = (char *)malloc(48 * v210);
          }
          else
          {
            v214 = 0;
          }
          v544 = &v214[48 * v209];
          *v544 = 20;
          v545 = &v214[48 * v210];
          *(_WORD *)(v544 + 9) = v672[1];
          v544[11] = 0;
          *((_DWORD *)v544 + 3) = 0;
          *((_QWORD *)v544 + 2) = 0;
          *(_QWORD *)(v544 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v544[24] = 0;
          *((_QWORD *)v544 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v544 + 5) = 0;
          *(_QWORD *)(v544 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v547 = *(void ***)a3;
          v546 = *(void ***)(a3 + 8);
          v548 = v544 + 48;
          if ( v546 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v544 - 4) = *(v546 - 4);
              *((_OWORD *)v544 - 3) = *((_OWORD *)v546 - 3);
              v549 = (__int64)*(v546 - 1);
              *(v546 - 5) = 0;
              *(v546 - 4) = 0;
              *(v546 - 6) = 0;
              *((_QWORD *)v544 - 1) = v549;
              *(_OWORD *)(v544 - 24) = *(_OWORD *)(v546 - 3);
              *(v546 - 3) = 0;
              *(v546 - 2) = 0;
              *(v546 - 1) = 0;
              v546 -= 6;
              v544 -= 48;
            }
            while ( v547 != v546 );
            v350 = *(void ***)a3;
            v547 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v544;
          *(_QWORD *)(a3 + 8) = v548;
          *(_QWORD *)(a3 + 16) = v545;
          if ( v547 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v547 - 3) & 1) != 0 )
                free(*(v547 - 1));
              v550 = v547 - 6;
              if ( (*(_BYTE *)(v547 - 6) & 1) != 0 )
                free(*(v547 - 4));
              v547 -= 6;
            }
            while ( v350 != v550 );
          }
          goto LABEL_1062;
        case 'S':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator=", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v215 = *(_QWORD *)(a3 + 16);
          if ( v5 < v215 )
            goto LABEL_378;
          v216 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v217 = 0x555555555555555LL;
          if ( v216 + 1 > 0x555555555555555LL )
            abort();
          v218 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v215 - *(_QWORD *)a3) >> 4);
          if ( v218 >= 0x2AAAAAAAAAAAAAALL
            || ((v219 = 2 * v218, v219 >= v216 + 1) ? (v217 = v219) : (v217 = v216 + 1), v217) )
          {
            v220 = *(_QWORD *)(a3 + 24);
            v221 = *(char **)(v220 + 4096);
            if ( v220 + 4096 - (__int64)v221 >= (unsigned __int64)(48 * v217) )
              *(_QWORD *)(v220 + 4096) = &v221[48 * v217];
            else
              v221 = (char *)malloc(48 * v217);
          }
          else
          {
            v221 = 0;
          }
          v551 = &v221[48 * v216];
          *v551 = 18;
          v552 = &v221[48 * v217];
          v551[9] = v672[1];
          v551[10] = 0;
          *(_QWORD *)(v551 + 1) = v672[0];
          v551[15] = 0;
          *((_QWORD *)v551 + 2) = 0;
          *(_DWORD *)(v551 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v551[24] = 0;
          *((_QWORD *)v551 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v551 + 5) = 0;
          *(_QWORD *)(v551 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v554 = *(void ***)a3;
          v553 = *(void ***)(a3 + 8);
          v555 = v551 + 48;
          if ( v553 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v551 - 4) = *(v553 - 4);
              *((_OWORD *)v551 - 3) = *((_OWORD *)v553 - 3);
              v556 = (__int64)*(v553 - 1);
              *(v553 - 5) = 0;
              *(v553 - 4) = 0;
              *(v553 - 6) = 0;
              *((_QWORD *)v551 - 1) = v556;
              *(_OWORD *)(v551 - 24) = *(_OWORD *)(v553 - 3);
              *(v553 - 3) = 0;
              *(v553 - 2) = 0;
              *(v553 - 1) = 0;
              v553 -= 6;
              v551 -= 48;
            }
            while ( v554 != v553 );
            v350 = *(void ***)a3;
            v554 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v551;
          *(_QWORD *)(a3 + 8) = v555;
          *(_QWORD *)(a3 + 16) = v552;
          if ( v554 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v554 - 3) & 1) != 0 )
                free(*(v554 - 1));
              v557 = v554 - 6;
              if ( (*(_BYTE *)(v554 - 6) & 1) != 0 )
                free(*(v554 - 4));
              v554 -= 6;
            }
            while ( v350 != v557 );
          }
          goto LABEL_1062;
        case 'a':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator&&", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v177 = *(_QWORD *)(a3 + 16);
          if ( v5 < v177 )
            goto LABEL_375;
          v178 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v179 = 0x555555555555555LL;
          if ( v178 + 1 > 0x555555555555555LL )
            abort();
          v180 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v177 - *(_QWORD *)a3) >> 4);
          if ( v180 >= 0x2AAAAAAAAAAAAAALL
            || ((v181 = 2 * v180, v181 >= v178 + 1) ? (v179 = v181) : (v179 = v178 + 1), v179) )
          {
            v182 = *(_QWORD *)(a3 + 24);
            v183 = *(char **)(v182 + 4096);
            if ( v182 + 4096 - (__int64)v183 >= (unsigned __int64)(48 * v179) )
              *(_QWORD *)(v182 + 4096) = &v183[48 * v179];
            else
              v183 = (char *)malloc(48 * v179);
          }
          else
          {
            v183 = 0;
          }
          v488 = &v183[48 * v178];
          *v488 = 20;
          v489 = &v183[48 * v179];
          *(_WORD *)(v488 + 9) = v672[1];
          v488[11] = 0;
          *((_DWORD *)v488 + 3) = 0;
          *((_QWORD *)v488 + 2) = 0;
          *(_QWORD *)(v488 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v488[24] = 0;
          *((_QWORD *)v488 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v488 + 5) = 0;
          *(_QWORD *)(v488 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v491 = *(void ***)a3;
          v490 = *(void ***)(a3 + 8);
          v492 = v488 + 48;
          if ( v490 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v488 - 4) = *(v490 - 4);
              *((_OWORD *)v488 - 3) = *((_OWORD *)v490 - 3);
              v493 = (__int64)*(v490 - 1);
              *(v490 - 5) = 0;
              *(v490 - 4) = 0;
              *(v490 - 6) = 0;
              *((_QWORD *)v488 - 1) = v493;
              *(_OWORD *)(v488 - 24) = *(_OWORD *)(v490 - 3);
              *(v490 - 3) = 0;
              *(v490 - 2) = 0;
              *(v490 - 1) = 0;
              v490 -= 6;
              v488 -= 48;
            }
            while ( v491 != v490 );
            v350 = *(void ***)a3;
            v491 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v488;
          *(_QWORD *)(a3 + 8) = v492;
          *(_QWORD *)(a3 + 16) = v489;
          if ( v491 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v491 - 3) & 1) != 0 )
                free(*(v491 - 1));
              v494 = v491 - 6;
              if ( (*(_BYTE *)(v491 - 6) & 1) != 0 )
                free(*(v491 - 4));
              v491 -= 6;
            }
            while ( v350 != v494 );
          }
          goto LABEL_1062;
        case 'd':
        case 'n':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator&", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v6 = *(_QWORD *)(a3 + 16);
          if ( v5 < v6 )
            goto LABEL_378;
          v7 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v8 = 0x555555555555555LL;
          if ( v7 + 1 > 0x555555555555555LL )
            abort();
          v9 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v9 >= 0x2AAAAAAAAAAAAAALL || ((v10 = 2 * v9, v10 >= v7 + 1) ? (v8 = v10) : (v8 = v7 + 1), v8) )
          {
            v11 = *(_QWORD *)(a3 + 24);
            v12 = *(char **)(v11 + 4096);
            if ( v11 + 4096 - (__int64)v12 >= (unsigned __int64)(48 * v8) )
              *(_QWORD *)(v11 + 4096) = &v12[48 * v8];
            else
              v12 = (char *)malloc(48 * v8);
          }
          else
          {
            v12 = 0;
          }
          v361 = &v12[48 * v7];
          *v361 = 18;
          v362 = &v12[48 * v8];
          v361[9] = v672[1];
          v361[10] = 0;
          *(_QWORD *)(v361 + 1) = v672[0];
          v361[15] = 0;
          *((_QWORD *)v361 + 2) = 0;
          *(_DWORD *)(v361 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v361[24] = 0;
          *((_QWORD *)v361 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v361 + 5) = 0;
          *(_QWORD *)(v361 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v364 = *(void ***)a3;
          v363 = *(void ***)(a3 + 8);
          v365 = v361 + 48;
          if ( v363 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v361 - 4) = *(v363 - 4);
              *((_OWORD *)v361 - 3) = *((_OWORD *)v363 - 3);
              v366 = (__int64)*(v363 - 1);
              *(v363 - 5) = 0;
              *(v363 - 4) = 0;
              *(v363 - 6) = 0;
              *((_QWORD *)v361 - 1) = v366;
              *(_OWORD *)(v361 - 24) = *(_OWORD *)(v363 - 3);
              *(v363 - 3) = 0;
              *(v363 - 2) = 0;
              *(v363 - 1) = 0;
              v363 -= 6;
              v361 -= 48;
            }
            while ( v364 != v363 );
            v350 = *(void ***)a3;
            v364 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v361;
          *(_QWORD *)(a3 + 8) = v365;
          *(_QWORD *)(a3 + 16) = v362;
          if ( v364 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v364 - 3) & 1) != 0 )
                free(*(v364 - 1));
              v367 = v364 - 6;
              if ( (*(_BYTE *)(v364 - 6) & 1) != 0 )
                free(*(v364 - 4));
              v364 -= 6;
            }
            while ( v350 != v367 );
          }
          goto LABEL_1062;
        default:
          return v3;
      }
      return v3;
    case 'c':
      switch ( a1[1] )
      {
        case 'l':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator()", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v70 = *(_QWORD *)(a3 + 16);
          if ( v5 < v70 )
            goto LABEL_375;
          v71 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v72 = 0x555555555555555LL;
          if ( v71 + 1 > 0x555555555555555LL )
            abort();
          v73 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v70 - *(_QWORD *)a3) >> 4);
          if ( v73 >= 0x2AAAAAAAAAAAAAALL || ((v74 = 2 * v73, v74 >= v71 + 1) ? (v72 = v74) : (v72 = v71 + 1), v72) )
          {
            v75 = *(_QWORD *)(a3 + 24);
            v76 = *(char **)(v75 + 4096);
            if ( v75 + 4096 - (__int64)v76 >= (unsigned __int64)(48 * v72) )
              *(_QWORD *)(v75 + 4096) = &v76[48 * v72];
            else
              v76 = (char *)malloc(48 * v72);
          }
          else
          {
            v76 = 0;
          }
          v460 = &v76[48 * v71];
          *v460 = 20;
          v461 = &v76[48 * v72];
          *(_WORD *)(v460 + 9) = v672[1];
          v460[11] = 0;
          *((_DWORD *)v460 + 3) = 0;
          *((_QWORD *)v460 + 2) = 0;
          *(_QWORD *)(v460 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v460[24] = 0;
          *((_QWORD *)v460 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v460 + 5) = 0;
          *(_QWORD *)(v460 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v463 = *(void ***)a3;
          v462 = *(void ***)(a3 + 8);
          v464 = v460 + 48;
          if ( v462 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v460 - 4) = *(v462 - 4);
              *((_OWORD *)v460 - 3) = *((_OWORD *)v462 - 3);
              v465 = (__int64)*(v462 - 1);
              *(v462 - 5) = 0;
              *(v462 - 4) = 0;
              *(v462 - 6) = 0;
              *((_QWORD *)v460 - 1) = v465;
              *(_OWORD *)(v460 - 24) = *(_OWORD *)(v462 - 3);
              *(v462 - 3) = 0;
              *(v462 - 2) = 0;
              *(v462 - 1) = 0;
              v462 -= 6;
              v460 -= 48;
            }
            while ( v463 != v462 );
            v350 = *(void ***)a3;
            v463 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v460;
          *(_QWORD *)(a3 + 8) = v464;
          *(_QWORD *)(a3 + 16) = v461;
          if ( v463 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v463 - 3) & 1) != 0 )
                free(*(v463 - 1));
              v466 = v463 - 6;
              if ( (*(_BYTE *)(v463 - 6) & 1) != 0 )
                free(*(v463 - 4));
              v463 -= 6;
            }
            while ( v350 != v466 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator,", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v151 = *(_QWORD *)(a3 + 16);
          if ( v5 < v151 )
            goto LABEL_378;
          v152 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v153 = 0x555555555555555LL;
          if ( v152 + 1 > 0x555555555555555LL )
            abort();
          v154 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v151 - *(_QWORD *)a3) >> 4);
          if ( v154 >= 0x2AAAAAAAAAAAAAALL
            || ((v155 = 2 * v154, v155 >= v152 + 1) ? (v153 = v155) : (v153 = v152 + 1), v153) )
          {
            v156 = *(_QWORD *)(a3 + 24);
            v157 = *(char **)(v156 + 4096);
            if ( v156 + 4096 - (__int64)v157 >= (unsigned __int64)(48 * v153) )
              *(_QWORD *)(v156 + 4096) = &v157[48 * v153];
            else
              v157 = (char *)malloc(48 * v153);
          }
          else
          {
            v157 = 0;
          }
          v467 = &v157[48 * v152];
          *v467 = 18;
          v468 = &v157[48 * v153];
          v467[9] = v672[1];
          v467[10] = 0;
          *(_QWORD *)(v467 + 1) = v672[0];
          v467[15] = 0;
          *((_QWORD *)v467 + 2) = 0;
          *(_DWORD *)(v467 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v467[24] = 0;
          *((_QWORD *)v467 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v467 + 5) = 0;
          *(_QWORD *)(v467 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v470 = *(void ***)a3;
          v469 = *(void ***)(a3 + 8);
          v471 = v467 + 48;
          if ( v469 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v467 - 4) = *(v469 - 4);
              *((_OWORD *)v467 - 3) = *((_OWORD *)v469 - 3);
              v472 = (__int64)*(v469 - 1);
              *(v469 - 5) = 0;
              *(v469 - 4) = 0;
              *(v469 - 6) = 0;
              *((_QWORD *)v467 - 1) = v472;
              *(_OWORD *)(v467 - 24) = *(_OWORD *)(v469 - 3);
              *(v469 - 3) = 0;
              *(v469 - 2) = 0;
              *(v469 - 1) = 0;
              v469 -= 6;
              v467 -= 48;
            }
            while ( v470 != v469 );
            v350 = *(void ***)a3;
            v470 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v467;
          *(_QWORD *)(a3 + 8) = v471;
          *(_QWORD *)(a3 + 16) = v468;
          if ( v470 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v470 - 3) & 1) != 0 )
                free(*(v470 - 1));
              v473 = v470 - 6;
              if ( (*(_BYTE *)(v470 - 6) & 1) != 0 )
                free(*(v470 - 4));
              v470 -= 6;
            }
            while ( v350 != v473 );
          }
          goto LABEL_1062;
        case 'o':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator~", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v137 = *(_QWORD *)(a3 + 16);
          if ( v5 < v137 )
            goto LABEL_378;
          v138 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v139 = 0x555555555555555LL;
          if ( v138 + 1 > 0x555555555555555LL )
            abort();
          v140 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v137 - *(_QWORD *)a3) >> 4);
          if ( v140 >= 0x2AAAAAAAAAAAAAALL
            || ((v141 = 2 * v140, v141 >= v138 + 1) ? (v139 = v141) : (v139 = v138 + 1), v139) )
          {
            v142 = *(_QWORD *)(a3 + 24);
            v143 = *(char **)(v142 + 4096);
            if ( v142 + 4096 - (__int64)v143 >= (unsigned __int64)(48 * v139) )
              *(_QWORD *)(v142 + 4096) = &v143[48 * v139];
            else
              v143 = (char *)malloc(48 * v139);
          }
          else
          {
            v143 = 0;
          }
          v445 = &v143[48 * v138];
          *v445 = 18;
          v446 = &v143[48 * v139];
          v445[9] = v672[1];
          v445[10] = 0;
          *(_QWORD *)(v445 + 1) = v672[0];
          v445[15] = 0;
          *((_QWORD *)v445 + 2) = 0;
          *(_DWORD *)(v445 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v445[24] = 0;
          *((_QWORD *)v445 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v445 + 5) = 0;
          *(_QWORD *)(v445 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v448 = *(void ***)a3;
          v447 = *(void ***)(a3 + 8);
          v449 = v445 + 48;
          if ( v447 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v445 - 4) = *(v447 - 4);
              *((_OWORD *)v445 - 3) = *((_OWORD *)v447 - 3);
              v450 = (__int64)*(v447 - 1);
              *(v447 - 5) = 0;
              *(v447 - 4) = 0;
              *(v447 - 6) = 0;
              *((_QWORD *)v445 - 1) = v450;
              *(_OWORD *)(v445 - 24) = *(_OWORD *)(v447 - 3);
              *(v447 - 3) = 0;
              *(v447 - 2) = 0;
              *(v447 - 1) = 0;
              v447 -= 6;
              v445 -= 48;
            }
            while ( v448 != v447 );
            v350 = *(void ***)a3;
            v448 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v445;
          *(_QWORD *)(a3 + 8) = v449;
          *(_QWORD *)(a3 + 16) = v446;
          if ( v448 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v448 - 3) & 1) != 0 )
                free(*(v448 - 1));
              v451 = v448 - 6;
              if ( (*(_BYTE *)(v448 - 6) & 1) != 0 )
                free(*(v448 - 4));
              v448 -= 6;
            }
            while ( v350 != v451 );
          }
          goto LABEL_1062;
        case 'v':
          v158 = *(_BYTE *)(a3 + 111);
          v159 = a1 + 2;
          *(_BYTE *)(a3 + 111) = 0;
          v14 = (unsigned __int8 *)sub_38008(a1 + 2, a2, a3);
          *(_BYTE *)(a3 + 111) = v158;
          if ( v14 == v159 )
            return v3;
          v160 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v160 )
            return v3;
          sub_429F4((size_t *)(v160 - 48), 0, "operator ", 9u);
          *(_BYTE *)(a3 + 108) = 1;
          break;
        default:
          return v3;
      }
      return v14;
    case 'd':
      switch ( a1[1] )
      {
        case 'V':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator/=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v63 = *(_QWORD *)(a3 + 16);
          if ( v5 < v63 )
            goto LABEL_375;
          v64 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v65 = 0x555555555555555LL;
          if ( v64 + 1 > 0x555555555555555LL )
            abort();
          v66 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v63 - *(_QWORD *)a3) >> 4);
          if ( v66 >= 0x2AAAAAAAAAAAAAALL || ((v67 = 2 * v66, v67 >= v64 + 1) ? (v65 = v67) : (v65 = v64 + 1), v65) )
          {
            v68 = *(_QWORD *)(a3 + 24);
            v69 = *(char **)(v68 + 4096);
            if ( v68 + 4096 - (__int64)v69 >= (unsigned __int64)(48 * v65) )
              *(_QWORD *)(v68 + 4096) = &v69[48 * v65];
            else
              v69 = (char *)malloc(48 * v65);
          }
          else
          {
            v69 = 0;
          }
          v495 = &v69[48 * v64];
          *v495 = 20;
          v496 = &v69[48 * v65];
          *(_WORD *)(v495 + 9) = v672[1];
          v495[11] = 0;
          *((_DWORD *)v495 + 3) = 0;
          *((_QWORD *)v495 + 2) = 0;
          *(_QWORD *)(v495 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v495[24] = 0;
          *((_QWORD *)v495 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v495 + 5) = 0;
          *(_QWORD *)(v495 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v498 = *(void ***)a3;
          v497 = *(void ***)(a3 + 8);
          v499 = v495 + 48;
          if ( v497 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v495 - 4) = *(v497 - 4);
              *((_OWORD *)v495 - 3) = *((_OWORD *)v497 - 3);
              v500 = (__int64)*(v497 - 1);
              *(v497 - 5) = 0;
              *(v497 - 4) = 0;
              *(v497 - 6) = 0;
              *((_QWORD *)v495 - 1) = v500;
              *(_OWORD *)(v495 - 24) = *(_OWORD *)(v497 - 3);
              *(v497 - 3) = 0;
              *(v497 - 2) = 0;
              *(v497 - 1) = 0;
              v497 -= 6;
              v495 -= 48;
            }
            while ( v498 != v497 );
            v350 = *(void ***)a3;
            v498 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v495;
          *(_QWORD *)(a3 + 8) = v499;
          *(_QWORD *)(a3 + 16) = v496;
          if ( v498 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v498 - 3) & 1) != 0 )
                free(*(v498 - 1));
              v501 = v498 - 6;
              if ( (*(_BYTE *)(v498 - 6) & 1) != 0 )
                free(*(v498 - 4));
              v498 -= 6;
            }
            while ( v350 != v501 );
          }
          goto LABEL_1062;
        case 'a':
          memset(v672, 0, 15);
          qmemcpy(v673, "operator delete", 15);
          v184 = *(_QWORD *)(a3 + 8);
          v185 = *(_QWORD *)(a3 + 16);
          if ( v184 < v185 )
          {
            *(_BYTE *)v184 = 34;
            v3 = a1 + 2;
            *(_QWORD *)(v184 + 8) = *(_QWORD *)((char *)v673 + 7);
            v186 = v673[0];
            *(_QWORD *)(v184 + 16) = 23899;
            goto LABEL_295;
          }
          v296 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v184 - *(_QWORD *)a3) >> 4);
          v297 = 0x555555555555555LL;
          if ( v296 + 1 > 0x555555555555555LL )
            abort();
          v298 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v185 - *(_QWORD *)a3) >> 4);
          if ( v298 >= 0x2AAAAAAAAAAAAAALL
            || ((v299 = 2 * v298, v299 >= v296 + 1) ? (v297 = v299) : (v297 = v296 + 1), v297) )
          {
            v300 = *(_QWORD *)(a3 + 24);
            v301 = *(char **)(v300 + 4096);
            if ( v300 + 4096 - (__int64)v301 >= (unsigned __int64)(48 * v297) )
              *(_QWORD *)(v300 + 4096) = &v301[48 * v297];
            else
              v301 = (char *)malloc(48 * v297);
          }
          else
          {
            v301 = 0;
          }
          v516 = &v301[48 * v296];
          *v516 = 34;
          v517 = &v301[48 * v297];
          *((_QWORD *)v516 + 1) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v516 + 2) = 23899;
          *(_QWORD *)(v516 + 1) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v516[24] = 0;
          *((_QWORD *)v516 + 4) = *(_QWORD *)((char *)v672 + 7);
          *((_QWORD *)v516 + 5) = 0;
          *(_QWORD *)(v516 + 25) = v672[0];
          memset(v672, 0, 15);
          v519 = *(void ***)a3;
          v518 = *(void ***)(a3 + 8);
          v520 = v516 + 48;
          if ( v518 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v516 - 4) = *(v518 - 4);
              *((_OWORD *)v516 - 3) = *((_OWORD *)v518 - 3);
              v521 = (__int64)*(v518 - 1);
              *(v518 - 5) = 0;
              *(v518 - 4) = 0;
              *(v518 - 6) = 0;
              *((_QWORD *)v516 - 1) = v521;
              *(_OWORD *)(v516 - 24) = *(_OWORD *)(v518 - 3);
              *(v518 - 3) = 0;
              *(v518 - 2) = 0;
              *(v518 - 1) = 0;
              v518 -= 6;
              v516 -= 48;
            }
            while ( v519 != v518 );
            v350 = *(void ***)a3;
            v519 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v516;
          *(_QWORD *)(a3 + 8) = v520;
          *(_QWORD *)(a3 + 16) = v517;
          if ( v519 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v519 - 3) & 1) != 0 )
                free(*(v519 - 1));
              v522 = v519 - 6;
              if ( (*(_BYTE *)(v519 - 6) & 1) != 0 )
                free(*(v519 - 4));
              v519 -= 6;
            }
            while ( v350 != v522 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator*", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v161 = *(_QWORD *)(a3 + 16);
          if ( v5 < v161 )
            goto LABEL_378;
          v162 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v163 = 0x555555555555555LL;
          if ( v162 + 1 > 0x555555555555555LL )
            abort();
          v164 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v161 - *(_QWORD *)a3) >> 4);
          if ( v164 >= 0x2AAAAAAAAAAAAAALL
            || ((v165 = 2 * v164, v165 >= v162 + 1) ? (v163 = v165) : (v163 = v162 + 1), v163) )
          {
            v166 = *(_QWORD *)(a3 + 24);
            v167 = *(char **)(v166 + 4096);
            if ( v166 + 4096 - (__int64)v167 >= (unsigned __int64)(48 * v163) )
              *(_QWORD *)(v166 + 4096) = &v167[48 * v163];
            else
              v167 = (char *)malloc(48 * v163);
          }
          else
          {
            v167 = 0;
          }
          v474 = &v167[48 * v162];
          *v474 = 18;
          v475 = &v167[48 * v163];
          v474[9] = v672[1];
          v474[10] = 0;
          *(_QWORD *)(v474 + 1) = v672[0];
          v474[15] = 0;
          *((_QWORD *)v474 + 2) = 0;
          *(_DWORD *)(v474 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v474[24] = 0;
          *((_QWORD *)v474 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v474 + 5) = 0;
          *(_QWORD *)(v474 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v477 = *(void ***)a3;
          v476 = *(void ***)(a3 + 8);
          v478 = v474 + 48;
          if ( v476 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v474 - 4) = *(v476 - 4);
              *((_OWORD *)v474 - 3) = *((_OWORD *)v476 - 3);
              v479 = (__int64)*(v476 - 1);
              *(v476 - 5) = 0;
              *(v476 - 4) = 0;
              *(v476 - 6) = 0;
              *((_QWORD *)v474 - 1) = v479;
              *(_OWORD *)(v474 - 24) = *(_OWORD *)(v476 - 3);
              *(v476 - 3) = 0;
              *(v476 - 2) = 0;
              *(v476 - 1) = 0;
              v476 -= 6;
              v474 -= 48;
            }
            while ( v477 != v476 );
            v350 = *(void ***)a3;
            v477 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v474;
          *(_QWORD *)(a3 + 8) = v478;
          *(_QWORD *)(a3 + 16) = v475;
          if ( v477 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v477 - 3) & 1) != 0 )
                free(*(v477 - 1));
              v480 = v477 - 6;
              if ( (*(_BYTE *)(v477 - 6) & 1) != 0 )
                free(*(v477 - 4));
              v477 -= 6;
            }
            while ( v350 != v480 );
          }
          goto LABEL_1062;
        case 'l':
          memset(v672, 0, 15);
          qmemcpy(v673, "operator delete", 15);
          v184 = *(_QWORD *)(a3 + 8);
          v222 = *(_QWORD *)(a3 + 16);
          if ( v184 >= v222 )
          {
            v302 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v184 - *(_QWORD *)a3) >> 4);
            v303 = 0x555555555555555LL;
            if ( v302 + 1 > 0x555555555555555LL )
              abort();
            v304 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v222 - *(_QWORD *)a3) >> 4);
            if ( v304 >= 0x2AAAAAAAAAAAAAALL
              || ((v305 = 2 * v304, v305 >= v302 + 1) ? (v303 = v305) : (v303 = v302 + 1), v303) )
            {
              v306 = *(_QWORD *)(a3 + 24);
              v307 = *(char **)(v306 + 4096);
              if ( v306 + 4096 - (__int64)v307 >= (unsigned __int64)(48 * v303) )
                *(_QWORD *)(v306 + 4096) = &v307[48 * v303];
              else
                v307 = (char *)malloc(48 * v303);
            }
            else
            {
              v307 = 0;
            }
            v558 = &v307[48 * v302];
            *v558 = 30;
            v559 = &v307[48 * v303];
            *((_QWORD *)v558 + 1) = *(_QWORD *)((char *)v673 + 7);
            *((_QWORD *)v558 + 2) = 0;
            *(_QWORD *)(v558 + 1) = v673[0];
            *(_QWORD *)((char *)v673 + 7) = 0;
            v673[0] = 0;
            v558[24] = 0;
            *((_QWORD *)v558 + 4) = *(_QWORD *)((char *)v672 + 7);
            *((_QWORD *)v558 + 5) = 0;
            *(_QWORD *)(v558 + 25) = v672[0];
            memset(v672, 0, 15);
            v561 = *(void ***)a3;
            v560 = *(void ***)(a3 + 8);
            v562 = v558 + 48;
            if ( v560 == *(void ***)a3 )
            {
              v350 = *(void ***)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v558 - 4) = *(v560 - 4);
                *((_OWORD *)v558 - 3) = *((_OWORD *)v560 - 3);
                v563 = (__int64)*(v560 - 1);
                *(v560 - 5) = 0;
                *(v560 - 4) = 0;
                *(v560 - 6) = 0;
                *((_QWORD *)v558 - 1) = v563;
                *(_OWORD *)(v558 - 24) = *(_OWORD *)(v560 - 3);
                *(v560 - 3) = 0;
                *(v560 - 2) = 0;
                *(v560 - 1) = 0;
                v560 -= 6;
                v558 -= 48;
              }
              while ( v561 != v560 );
              v350 = *(void ***)a3;
              v561 = *(void ***)(a3 + 8);
            }
            v351 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v558;
            *(_QWORD *)(a3 + 8) = v562;
            *(_QWORD *)(a3 + 16) = v559;
            if ( v561 != v350 )
            {
              do
              {
                if ( (*(_BYTE *)(v561 - 3) & 1) != 0 )
                  free(*(v561 - 1));
                v564 = v561 - 6;
                if ( (*(_BYTE *)(v561 - 6) & 1) != 0 )
                  free(*(v561 - 4));
                v561 -= 6;
              }
              while ( v350 != v564 );
            }
            goto LABEL_1062;
          }
          *(_BYTE *)v184 = 30;
          v3 = a1 + 2;
          *(_QWORD *)(v184 + 8) = *(_QWORD *)((char *)v673 + 7);
          *(_QWORD *)(v184 + 16) = 0;
          v186 = v673[0];
LABEL_295:
          *(_QWORD *)(v184 + 1) = v186;
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          *(_BYTE *)(v184 + 24) = 0;
          *(_QWORD *)(v184 + 32) = *(_QWORD *)((char *)v672 + 7);
          *(_QWORD *)(v184 + 40) = 0;
          *(_QWORD *)(v184 + 25) = v672[0];
          memset(v672, 0, 15);
          break;
        case 'v':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator/", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v237 = *(_QWORD *)(a3 + 16);
          if ( v5 < v237 )
            goto LABEL_378;
          v238 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v239 = 0x555555555555555LL;
          if ( v238 + 1 > 0x555555555555555LL )
            abort();
          v240 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v237 - *(_QWORD *)a3) >> 4);
          if ( v240 >= 0x2AAAAAAAAAAAAAALL
            || ((v241 = 2 * v240, v241 >= v238 + 1) ? (v239 = v241) : (v239 = v238 + 1), v239) )
          {
            v242 = *(_QWORD *)(a3 + 24);
            v243 = *(char **)(v242 + 4096);
            if ( v242 + 4096 - (__int64)v243 >= (unsigned __int64)(48 * v239) )
              *(_QWORD *)(v242 + 4096) = &v243[48 * v239];
            else
              v243 = (char *)malloc(48 * v239);
          }
          else
          {
            v243 = 0;
          }
          v579 = &v243[48 * v238];
          *v579 = 18;
          v580 = &v243[48 * v239];
          v579[9] = v672[1];
          v579[10] = 0;
          *(_QWORD *)(v579 + 1) = v672[0];
          v579[15] = 0;
          *((_QWORD *)v579 + 2) = 0;
          *(_DWORD *)(v579 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v579[24] = 0;
          *((_QWORD *)v579 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v579 + 5) = 0;
          *(_QWORD *)(v579 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v582 = *(void ***)a3;
          v581 = *(void ***)(a3 + 8);
          v583 = v579 + 48;
          if ( v581 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v579 - 4) = *(v581 - 4);
              *((_OWORD *)v579 - 3) = *((_OWORD *)v581 - 3);
              v584 = (__int64)*(v581 - 1);
              *(v581 - 5) = 0;
              *(v581 - 4) = 0;
              *(v581 - 6) = 0;
              *((_QWORD *)v579 - 1) = v584;
              *(_OWORD *)(v579 - 24) = *(_OWORD *)(v581 - 3);
              *(v581 - 3) = 0;
              *(v581 - 2) = 0;
              *(v581 - 1) = 0;
              v581 -= 6;
              v579 -= 48;
            }
            while ( v582 != v581 );
            v350 = *(void ***)a3;
            v582 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v579;
          *(_QWORD *)(a3 + 8) = v583;
          *(_QWORD *)(a3 + 16) = v580;
          if ( v582 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v582 - 3) & 1) != 0 )
                free(*(v582 - 1));
              v585 = v582 - 6;
              if ( (*(_BYTE *)(v582 - 6) & 1) != 0 )
                free(*(v582 - 4));
              v582 -= 6;
            }
            while ( v350 != v585 );
          }
          goto LABEL_1062;
        default:
          return v3;
      }
      goto LABEL_380;
    case 'e':
      v55 = (unsigned __int8)a1[1];
      if ( v55 == 79 )
      {
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        qmemcpy(v672, "operator^=", 10);
        v5 = *(_QWORD *)(a3 + 8);
        v114 = *(_QWORD *)(a3 + 16);
        if ( v5 < v114 )
          goto LABEL_375;
        v115 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v116 = 0x555555555555555LL;
        if ( v115 + 1 > 0x555555555555555LL )
          abort();
        v117 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v114 - *(_QWORD *)a3) >> 4);
        if ( v117 >= 0x2AAAAAAAAAAAAAALL
          || ((v118 = 2 * v117, v118 >= v115 + 1) ? (v116 = v118) : (v116 = v115 + 1), v116) )
        {
          v119 = *(_QWORD *)(a3 + 24);
          v120 = *(char **)(v119 + 4096);
          if ( v119 + 4096 - (__int64)v120 >= (unsigned __int64)(48 * v116) )
            *(_QWORD *)(v119 + 4096) = &v120[48 * v116];
          else
            v120 = (char *)malloc(48 * v116);
        }
        else
        {
          v120 = 0;
        }
        v389 = &v120[48 * v115];
        *v389 = 20;
        v390 = &v120[48 * v116];
        *(_WORD *)(v389 + 9) = v672[1];
        v389[11] = 0;
        *((_DWORD *)v389 + 3) = 0;
        *((_QWORD *)v389 + 2) = 0;
        *(_QWORD *)(v389 + 1) = v672[0];
        LOWORD(v672[1]) = 0;
        v672[0] = 0;
        v389[24] = 0;
        *((_QWORD *)v389 + 4) = *(_QWORD *)((char *)v673 + 7);
        *((_QWORD *)v389 + 5) = 0;
        *(_QWORD *)(v389 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        v392 = *(void ***)a3;
        v391 = *(void ***)(a3 + 8);
        v393 = v389 + 48;
        if ( v391 == *(void ***)a3 )
        {
          v350 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v389 - 4) = *(v391 - 4);
            *((_OWORD *)v389 - 3) = *((_OWORD *)v391 - 3);
            v394 = (__int64)*(v391 - 1);
            *(v391 - 5) = 0;
            *(v391 - 4) = 0;
            *(v391 - 6) = 0;
            *((_QWORD *)v389 - 1) = v394;
            *(_OWORD *)(v389 - 24) = *(_OWORD *)(v391 - 3);
            *(v391 - 3) = 0;
            *(v391 - 2) = 0;
            *(v391 - 1) = 0;
            v391 -= 6;
            v389 -= 48;
          }
          while ( v392 != v391 );
          v350 = *(void ***)a3;
          v392 = *(void ***)(a3 + 8);
        }
        v351 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v389;
        *(_QWORD *)(a3 + 8) = v393;
        *(_QWORD *)(a3 + 16) = v390;
        if ( v392 != v350 )
        {
          do
          {
            if ( (*(_BYTE *)(v392 - 3) & 1) != 0 )
              free(*(v392 - 1));
            v395 = v392 - 6;
            if ( (*(_BYTE *)(v392 - 6) & 1) != 0 )
              free(*(v392 - 4));
            v392 -= 6;
          }
          while ( v350 != v395 );
        }
        goto LABEL_1062;
      }
      if ( v55 == 113 )
      {
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        qmemcpy(v672, "operator==", 10);
        v5 = *(_QWORD *)(a3 + 8);
        v107 = *(_QWORD *)(a3 + 16);
        if ( v5 < v107 )
          goto LABEL_375;
        v108 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v109 = 0x555555555555555LL;
        if ( v108 + 1 > 0x555555555555555LL )
          abort();
        v110 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v107 - *(_QWORD *)a3) >> 4);
        if ( v110 >= 0x2AAAAAAAAAAAAAALL
          || ((v111 = 2 * v110, v111 >= v108 + 1) ? (v109 = v111) : (v109 = v108 + 1), v109) )
        {
          v112 = *(_QWORD *)(a3 + 24);
          v113 = *(char **)(v112 + 4096);
          if ( v112 + 4096 - (__int64)v113 >= (unsigned __int64)(48 * v109) )
            *(_QWORD *)(v112 + 4096) = &v113[48 * v109];
          else
            v113 = (char *)malloc(48 * v109);
        }
        else
        {
          v113 = 0;
        }
        v382 = &v113[48 * v108];
        *v382 = 20;
        v383 = &v113[48 * v109];
        *(_WORD *)(v382 + 9) = v672[1];
        v382[11] = 0;
        *((_DWORD *)v382 + 3) = 0;
        *((_QWORD *)v382 + 2) = 0;
        *(_QWORD *)(v382 + 1) = v672[0];
        LOWORD(v672[1]) = 0;
        v672[0] = 0;
        v382[24] = 0;
        *((_QWORD *)v382 + 4) = *(_QWORD *)((char *)v673 + 7);
        *((_QWORD *)v382 + 5) = 0;
        *(_QWORD *)(v382 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        v385 = *(void ***)a3;
        v384 = *(void ***)(a3 + 8);
        v386 = v382 + 48;
        if ( v384 == *(void ***)a3 )
        {
          v350 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v382 - 4) = *(v384 - 4);
            *((_OWORD *)v382 - 3) = *((_OWORD *)v384 - 3);
            v387 = (__int64)*(v384 - 1);
            *(v384 - 5) = 0;
            *(v384 - 4) = 0;
            *(v384 - 6) = 0;
            *((_QWORD *)v382 - 1) = v387;
            *(_OWORD *)(v382 - 24) = *(_OWORD *)(v384 - 3);
            *(v384 - 3) = 0;
            *(v384 - 2) = 0;
            *(v384 - 1) = 0;
            v384 -= 6;
            v382 -= 48;
          }
          while ( v385 != v384 );
          v350 = *(void ***)a3;
          v385 = *(void ***)(a3 + 8);
        }
        v351 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v382;
        *(_QWORD *)(a3 + 8) = v386;
        *(_QWORD *)(a3 + 16) = v383;
        if ( v385 != v350 )
        {
          do
          {
            if ( (*(_BYTE *)(v385 - 3) & 1) != 0 )
              free(*(v385 - 1));
            v388 = v385 - 6;
            if ( (*(_BYTE *)(v385 - 6) & 1) != 0 )
              free(*(v385 - 4));
            v385 -= 6;
          }
          while ( v350 != v388 );
        }
        goto LABEL_1062;
      }
      if ( v55 != 111 )
        return v3;
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      qmemcpy(v672, "operator^", 9);
      v5 = *(_QWORD *)(a3 + 8);
      v56 = *(_QWORD *)(a3 + 16);
      if ( v5 >= v56 )
      {
        v57 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v58 = 0x555555555555555LL;
        if ( v57 + 1 > 0x555555555555555LL )
          abort();
        v59 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v56 - *(_QWORD *)a3) >> 4);
        if ( v59 >= 0x2AAAAAAAAAAAAAALL || ((v60 = 2 * v59, v60 >= v57 + 1) ? (v58 = v60) : (v58 = v57 + 1), v58) )
        {
          v61 = *(_QWORD *)(a3 + 24);
          v62 = *(char **)(v61 + 4096);
          if ( v61 + 4096 - (__int64)v62 >= (unsigned __int64)(48 * v58) )
            *(_QWORD *)(v61 + 4096) = &v62[48 * v58];
          else
            v62 = (char *)malloc(48 * v58);
        }
        else
        {
          v62 = 0;
        }
        v396 = &v62[48 * v57];
        *v396 = 18;
        v397 = &v62[48 * v58];
        v396[9] = v672[1];
        v396[10] = 0;
        *(_QWORD *)(v396 + 1) = v672[0];
        v396[15] = 0;
        *((_QWORD *)v396 + 2) = 0;
        *(_DWORD *)(v396 + 11) = 0;
        LOBYTE(v672[1]) = 0;
        v672[0] = 0;
        v396[24] = 0;
        *((_QWORD *)v396 + 4) = *(_QWORD *)((char *)v673 + 7);
        *((_QWORD *)v396 + 5) = 0;
        *(_QWORD *)(v396 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        v399 = *(void ***)a3;
        v398 = *(void ***)(a3 + 8);
        v400 = v396 + 48;
        if ( v398 == *(void ***)a3 )
        {
          v350 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v396 - 4) = *(v398 - 4);
            *((_OWORD *)v396 - 3) = *((_OWORD *)v398 - 3);
            v401 = (__int64)*(v398 - 1);
            *(v398 - 5) = 0;
            *(v398 - 4) = 0;
            *(v398 - 6) = 0;
            *((_QWORD *)v396 - 1) = v401;
            *(_OWORD *)(v396 - 24) = *(_OWORD *)(v398 - 3);
            *(v398 - 3) = 0;
            *(v398 - 2) = 0;
            *(v398 - 1) = 0;
            v398 -= 6;
            v396 -= 48;
          }
          while ( v399 != v398 );
          v350 = *(void ***)a3;
          v399 = *(void ***)(a3 + 8);
        }
        v351 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v396;
        *(_QWORD *)(a3 + 8) = v400;
        *(_QWORD *)(a3 + 16) = v397;
        if ( v399 != v350 )
        {
          do
          {
            if ( (*(_BYTE *)(v399 - 3) & 1) != 0 )
              free(*(v399 - 1));
            v402 = v399 - 6;
            if ( (*(_BYTE *)(v399 - 6) & 1) != 0 )
              free(*(v399 - 4));
            v399 -= 6;
          }
          while ( v350 != v402 );
        }
        goto LABEL_1062;
      }
      goto LABEL_378;
    case 'g':
      v26 = (unsigned __int8)a1[1];
      if ( v26 == 116 )
      {
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        qmemcpy(v672, "operator>", 9);
        v5 = *(_QWORD *)(a3 + 8);
        v100 = *(_QWORD *)(a3 + 16);
        if ( v5 < v100 )
          goto LABEL_378;
        v101 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v102 = 0x555555555555555LL;
        if ( v101 + 1 > 0x555555555555555LL )
          abort();
        v103 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v100 - *(_QWORD *)a3) >> 4);
        if ( v103 >= 0x2AAAAAAAAAAAAAALL
          || ((v104 = 2 * v103, v104 >= v101 + 1) ? (v102 = v104) : (v102 = v101 + 1), v102) )
        {
          v105 = *(_QWORD *)(a3 + 24);
          v106 = *(char **)(v105 + 4096);
          if ( v105 + 4096 - (__int64)v106 >= (unsigned __int64)(48 * v102) )
            *(_QWORD *)(v105 + 4096) = &v106[48 * v102];
          else
            v106 = (char *)malloc(48 * v102);
        }
        else
        {
          v106 = 0;
        }
        v375 = &v106[48 * v101];
        *v375 = 18;
        v376 = &v106[48 * v102];
        v375[9] = v672[1];
        v375[10] = 0;
        *(_QWORD *)(v375 + 1) = v672[0];
        v375[15] = 0;
        *((_QWORD *)v375 + 2) = 0;
        *(_DWORD *)(v375 + 11) = 0;
        LOBYTE(v672[1]) = 0;
        v672[0] = 0;
        v375[24] = 0;
        *((_QWORD *)v375 + 4) = *(_QWORD *)((char *)v673 + 7);
        *((_QWORD *)v375 + 5) = 0;
        *(_QWORD *)(v375 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        v378 = *(void ***)a3;
        v377 = *(void ***)(a3 + 8);
        v379 = v375 + 48;
        if ( v377 == *(void ***)a3 )
        {
          v350 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v375 - 4) = *(v377 - 4);
            *((_OWORD *)v375 - 3) = *((_OWORD *)v377 - 3);
            v380 = (__int64)*(v377 - 1);
            *(v377 - 5) = 0;
            *(v377 - 4) = 0;
            *(v377 - 6) = 0;
            *((_QWORD *)v375 - 1) = v380;
            *(_OWORD *)(v375 - 24) = *(_OWORD *)(v377 - 3);
            *(v377 - 3) = 0;
            *(v377 - 2) = 0;
            *(v377 - 1) = 0;
            v377 -= 6;
            v375 -= 48;
          }
          while ( v378 != v377 );
          v350 = *(void ***)a3;
          v378 = *(void ***)(a3 + 8);
        }
        v351 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v375;
        *(_QWORD *)(a3 + 8) = v379;
        *(_QWORD *)(a3 + 16) = v376;
        if ( v378 != v350 )
        {
          do
          {
            if ( (*(_BYTE *)(v378 - 3) & 1) != 0 )
              free(*(v378 - 1));
            v381 = v378 - 6;
            if ( (*(_BYTE *)(v378 - 6) & 1) != 0 )
              free(*(v378 - 4));
            v378 -= 6;
          }
          while ( v350 != v381 );
        }
        goto LABEL_1062;
      }
      if ( v26 != 101 )
        return v3;
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      qmemcpy(v672, "operator>=", 10);
      v5 = *(_QWORD *)(a3 + 8);
      v27 = *(_QWORD *)(a3 + 16);
      if ( v5 >= v27 )
      {
        v28 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v29 = 0x555555555555555LL;
        if ( v28 + 1 > 0x555555555555555LL )
          abort();
        v30 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v27 - *(_QWORD *)a3) >> 4);
        if ( v30 >= 0x2AAAAAAAAAAAAAALL || ((v31 = 2 * v30, v31 >= v28 + 1) ? (v29 = v31) : (v29 = v28 + 1), v29) )
        {
          v32 = *(_QWORD *)(a3 + 24);
          v33 = *(char **)(v32 + 4096);
          if ( v32 + 4096 - (__int64)v33 >= (unsigned __int64)(48 * v29) )
            *(_QWORD *)(v32 + 4096) = &v33[48 * v29];
          else
            v33 = (char *)malloc(48 * v29);
        }
        else
        {
          v33 = 0;
        }
        v368 = &v33[48 * v28];
        *v368 = 20;
        v369 = &v33[48 * v29];
        *(_WORD *)(v368 + 9) = v672[1];
        v368[11] = 0;
        *((_DWORD *)v368 + 3) = 0;
        *((_QWORD *)v368 + 2) = 0;
        *(_QWORD *)(v368 + 1) = v672[0];
        LOWORD(v672[1]) = 0;
        v672[0] = 0;
        v368[24] = 0;
        *((_QWORD *)v368 + 4) = *(_QWORD *)((char *)v673 + 7);
        *((_QWORD *)v368 + 5) = 0;
        *(_QWORD *)(v368 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        v371 = *(void ***)a3;
        v370 = *(void ***)(a3 + 8);
        v372 = v368 + 48;
        if ( v370 == *(void ***)a3 )
        {
          v350 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v368 - 4) = *(v370 - 4);
            *((_OWORD *)v368 - 3) = *((_OWORD *)v370 - 3);
            v373 = (__int64)*(v370 - 1);
            *(v370 - 5) = 0;
            *(v370 - 4) = 0;
            *(v370 - 6) = 0;
            *((_QWORD *)v368 - 1) = v373;
            *(_OWORD *)(v368 - 24) = *(_OWORD *)(v370 - 3);
            *(v370 - 3) = 0;
            *(v370 - 2) = 0;
            *(v370 - 1) = 0;
            v370 -= 6;
            v368 -= 48;
          }
          while ( v371 != v370 );
          v350 = *(void ***)a3;
          v371 = *(void ***)(a3 + 8);
        }
        v351 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v368;
        *(_QWORD *)(a3 + 8) = v372;
        *(_QWORD *)(a3 + 16) = v369;
        if ( v371 != v350 )
        {
          do
          {
            if ( (*(_BYTE *)(v371 - 3) & 1) != 0 )
              free(*(v371 - 1));
            v374 = v371 - 6;
            if ( (*(_BYTE *)(v371 - 6) & 1) != 0 )
              free(*(v371 - 4));
            v371 -= 6;
          }
          while ( v350 != v374 );
        }
        goto LABEL_1062;
      }
      goto LABEL_375;
    case 'i':
      if ( a1[1] != 120 )
        return v3;
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      qmemcpy(v672, "operator[]", 10);
      v5 = *(_QWORD *)(a3 + 8);
      v41 = *(_QWORD *)(a3 + 16);
      if ( v5 < v41 )
        goto LABEL_375;
      v42 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
      v43 = 0x555555555555555LL;
      if ( v42 + 1 > 0x555555555555555LL )
        abort();
      v44 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v41 - *(_QWORD *)a3) >> 4);
      if ( v44 >= 0x2AAAAAAAAAAAAAALL || ((v45 = 2 * v44, v45 >= v42 + 1) ? (v43 = v45) : (v43 = v42 + 1), v43) )
      {
        v46 = *(_QWORD *)(a3 + 24);
        v47 = *(char **)(v46 + 4096);
        if ( v46 + 4096 - (__int64)v47 >= (unsigned __int64)(48 * v43) )
          *(_QWORD *)(v46 + 4096) = &v47[48 * v43];
        else
          v47 = (char *)malloc(48 * v43);
      }
      else
      {
        v47 = 0;
      }
      v344 = &v47[48 * v42];
      *v344 = 20;
      v345 = &v47[48 * v43];
      *(_WORD *)(v344 + 9) = v672[1];
      v344[11] = 0;
      *((_DWORD *)v344 + 3) = 0;
      *((_QWORD *)v344 + 2) = 0;
      *(_QWORD *)(v344 + 1) = v672[0];
      LOWORD(v672[1]) = 0;
      v672[0] = 0;
      v344[24] = 0;
      *((_QWORD *)v344 + 4) = *(_QWORD *)((char *)v673 + 7);
      *((_QWORD *)v344 + 5) = 0;
      *(_QWORD *)(v344 + 25) = v673[0];
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      v347 = *(void ***)a3;
      v346 = *(void ***)(a3 + 8);
      v348 = v344 + 48;
      if ( v346 == *(void ***)a3 )
      {
        v350 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v344 - 4) = *(v346 - 4);
          *((_OWORD *)v344 - 3) = *((_OWORD *)v346 - 3);
          v349 = (__int64)*(v346 - 1);
          *(v346 - 5) = 0;
          *(v346 - 4) = 0;
          *(v346 - 6) = 0;
          *((_QWORD *)v344 - 1) = v349;
          *(_OWORD *)(v344 - 24) = *(_OWORD *)(v346 - 3);
          *(v346 - 3) = 0;
          *(v346 - 2) = 0;
          *(v346 - 1) = 0;
          v346 -= 6;
          v344 -= 48;
        }
        while ( v347 != v346 );
        v350 = *(void ***)a3;
        v347 = *(void ***)(a3 + 8);
      }
      v351 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v344;
      *(_QWORD *)(a3 + 8) = v348;
      *(_QWORD *)(a3 + 16) = v345;
      if ( v347 != v350 )
      {
        do
        {
          if ( (*(_BYTE *)(v347 - 3) & 1) != 0 )
            free(*(v347 - 1));
          v352 = v347 - 6;
          if ( (*(_BYTE *)(v347 - 6) & 1) != 0 )
            free(*(v347 - 4));
          v347 -= 6;
        }
        while ( v350 != v352 );
      }
      goto LABEL_1062;
    case 'l':
      switch ( a1[1] )
      {
        case 'S':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator<<=", 11);
          v5 = *(_QWORD *)(a3 + 8);
          v77 = *(_QWORD *)(a3 + 16);
          if ( v5 < v77 )
            goto LABEL_183;
          v78 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v79 = 0x555555555555555LL;
          if ( v78 + 1 > 0x555555555555555LL )
            abort();
          v80 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v77 - *(_QWORD *)a3) >> 4);
          if ( v80 >= 0x2AAAAAAAAAAAAAALL || ((v81 = 2 * v80, v81 >= v78 + 1) ? (v79 = v81) : (v79 = v78 + 1), v79) )
          {
            v82 = *(_QWORD *)(a3 + 24);
            v83 = *(char **)(v82 + 4096);
            if ( v82 + 4096 - (__int64)v83 >= (unsigned __int64)(48 * v79) )
              *(_QWORD *)(v82 + 4096) = &v83[48 * v79];
            else
              v83 = (char *)malloc(48 * v79);
          }
          else
          {
            v83 = 0;
          }
          v502 = &v83[48 * v78];
          *v502 = 22;
          v503 = &v83[48 * v79];
          v502[11] = BYTE2(v672[1]);
          *(_WORD *)(v502 + 9) = v672[1];
          v502[12] = 0;
          *(_QWORD *)(v502 + 1) = v672[0];
          v502[15] = 0;
          *((_QWORD *)v502 + 2) = 0;
          *(_WORD *)(v502 + 13) = 0;
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          BYTE2(v672[1]) = 0;
          v502[24] = 0;
          *((_QWORD *)v502 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v502 + 5) = 0;
          *(_QWORD *)(v502 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v505 = *(void ***)a3;
          v504 = *(void ***)(a3 + 8);
          v506 = v502 + 48;
          if ( v504 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v502 - 4) = *(v504 - 4);
              *((_OWORD *)v502 - 3) = *((_OWORD *)v504 - 3);
              v507 = (__int64)*(v504 - 1);
              *(v504 - 5) = 0;
              *(v504 - 4) = 0;
              *(v504 - 6) = 0;
              *((_QWORD *)v502 - 1) = v507;
              *(_OWORD *)(v502 - 24) = *(_OWORD *)(v504 - 3);
              *(v504 - 3) = 0;
              *(v504 - 2) = 0;
              *(v504 - 1) = 0;
              v504 -= 6;
              v502 -= 48;
            }
            while ( v505 != v504 );
            v350 = *(void ***)a3;
            v505 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v502;
          *(_QWORD *)(a3 + 8) = v506;
          *(_QWORD *)(a3 + 16) = v503;
          if ( v505 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v505 - 3) & 1) != 0 )
                free(*(v505 - 1));
              v508 = v505 - 6;
              if ( (*(_BYTE *)(v505 - 6) & 1) != 0 )
                free(*(v505 - 4));
              v505 -= 6;
            }
            while ( v350 != v508 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator<=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v187 = *(_QWORD *)(a3 + 16);
          if ( v5 < v187 )
            goto LABEL_375;
          v188 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v189 = 0x555555555555555LL;
          if ( v188 + 1 > 0x555555555555555LL )
            abort();
          v190 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v187 - *(_QWORD *)a3) >> 4);
          if ( v190 >= 0x2AAAAAAAAAAAAAALL
            || ((v191 = 2 * v190, v191 >= v188 + 1) ? (v189 = v191) : (v189 = v188 + 1), v189) )
          {
            v192 = *(_QWORD *)(a3 + 24);
            v193 = *(char **)(v192 + 4096);
            if ( v192 + 4096 - (__int64)v193 >= (unsigned __int64)(48 * v189) )
              *(_QWORD *)(v192 + 4096) = &v193[48 * v189];
            else
              v193 = (char *)malloc(48 * v189);
          }
          else
          {
            v193 = 0;
          }
          v523 = &v193[48 * v188];
          *v523 = 20;
          v524 = &v193[48 * v189];
          *(_WORD *)(v523 + 9) = v672[1];
          v523[11] = 0;
          *((_DWORD *)v523 + 3) = 0;
          *((_QWORD *)v523 + 2) = 0;
          *(_QWORD *)(v523 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v523[24] = 0;
          *((_QWORD *)v523 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v523 + 5) = 0;
          *(_QWORD *)(v523 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v526 = *(void ***)a3;
          v525 = *(void ***)(a3 + 8);
          v527 = v523 + 48;
          if ( v525 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v523 - 4) = *(v525 - 4);
              *((_OWORD *)v523 - 3) = *((_OWORD *)v525 - 3);
              v528 = (__int64)*(v525 - 1);
              *(v525 - 5) = 0;
              *(v525 - 4) = 0;
              *(v525 - 6) = 0;
              *((_QWORD *)v523 - 1) = v528;
              *(_OWORD *)(v523 - 24) = *(_OWORD *)(v525 - 3);
              *(v525 - 3) = 0;
              *(v525 - 2) = 0;
              *(v525 - 1) = 0;
              v525 -= 6;
              v523 -= 48;
            }
            while ( v526 != v525 );
            v350 = *(void ***)a3;
            v526 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v523;
          *(_QWORD *)(a3 + 8) = v527;
          *(_QWORD *)(a3 + 16) = v524;
          if ( v526 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v526 - 3) & 1) != 0 )
                free(*(v526 - 1));
              v529 = v526 - 6;
              if ( (*(_BYTE *)(v526 - 6) & 1) != 0 )
                free(*(v526 - 4));
              v526 -= 6;
            }
            while ( v350 != v529 );
          }
          goto LABEL_1062;
        case 'i':
          v168 = a1 + 2;
          v14 = sub_57438(a1 + 2, a2, (void **)a3);
          if ( v14 == v168 )
            return v3;
          v169 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v169 )
            return v3;
          v16 = (size_t *)(v169 - 48);
          v17 = "operator\"\" ";
          v18 = 11;
          break;
        case 's':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator<<", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v223 = *(_QWORD *)(a3 + 16);
          if ( v5 < v223 )
            goto LABEL_375;
          v224 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v225 = 0x555555555555555LL;
          if ( v224 + 1 > 0x555555555555555LL )
            abort();
          v226 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v223 - *(_QWORD *)a3) >> 4);
          if ( v226 >= 0x2AAAAAAAAAAAAAALL
            || ((v227 = 2 * v226, v227 >= v224 + 1) ? (v225 = v227) : (v225 = v224 + 1), v225) )
          {
            v228 = *(_QWORD *)(a3 + 24);
            v229 = *(char **)(v228 + 4096);
            if ( v228 + 4096 - (__int64)v229 >= (unsigned __int64)(48 * v225) )
              *(_QWORD *)(v228 + 4096) = &v229[48 * v225];
            else
              v229 = (char *)malloc(48 * v225);
          }
          else
          {
            v229 = 0;
          }
          v565 = &v229[48 * v224];
          *v565 = 20;
          v566 = &v229[48 * v225];
          *(_WORD *)(v565 + 9) = v672[1];
          v565[11] = 0;
          *((_DWORD *)v565 + 3) = 0;
          *((_QWORD *)v565 + 2) = 0;
          *(_QWORD *)(v565 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v565[24] = 0;
          *((_QWORD *)v565 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v565 + 5) = 0;
          *(_QWORD *)(v565 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v568 = *(void ***)a3;
          v567 = *(void ***)(a3 + 8);
          v569 = v565 + 48;
          if ( v567 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v565 - 4) = *(v567 - 4);
              *((_OWORD *)v565 - 3) = *((_OWORD *)v567 - 3);
              v570 = (__int64)*(v567 - 1);
              *(v567 - 5) = 0;
              *(v567 - 4) = 0;
              *(v567 - 6) = 0;
              *((_QWORD *)v565 - 1) = v570;
              *(_OWORD *)(v565 - 24) = *(_OWORD *)(v567 - 3);
              *(v567 - 3) = 0;
              *(v567 - 2) = 0;
              *(v567 - 1) = 0;
              v567 -= 6;
              v565 -= 48;
            }
            while ( v568 != v567 );
            v350 = *(void ***)a3;
            v568 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v565;
          *(_QWORD *)(a3 + 8) = v569;
          *(_QWORD *)(a3 + 16) = v566;
          if ( v568 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v568 - 3) & 1) != 0 )
                free(*(v568 - 1));
              v571 = v568 - 6;
              if ( (*(_BYTE *)(v568 - 6) & 1) != 0 )
                free(*(v568 - 4));
              v568 -= 6;
            }
            while ( v350 != v571 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator<", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v244 = *(_QWORD *)(a3 + 16);
          if ( v5 < v244 )
            goto LABEL_378;
          v245 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v246 = 0x555555555555555LL;
          if ( v245 + 1 > 0x555555555555555LL )
            abort();
          v247 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v244 - *(_QWORD *)a3) >> 4);
          if ( v247 >= 0x2AAAAAAAAAAAAAALL
            || ((v248 = 2 * v247, v248 >= v245 + 1) ? (v246 = v248) : (v246 = v245 + 1), v246) )
          {
            v249 = *(_QWORD *)(a3 + 24);
            v250 = *(char **)(v249 + 4096);
            if ( v249 + 4096 - (__int64)v250 >= (unsigned __int64)(48 * v246) )
              *(_QWORD *)(v249 + 4096) = &v250[48 * v246];
            else
              v250 = (char *)malloc(48 * v246);
          }
          else
          {
            v250 = 0;
          }
          v586 = &v250[48 * v245];
          *v586 = 18;
          v587 = &v250[48 * v246];
          v586[9] = v672[1];
          v586[10] = 0;
          *(_QWORD *)(v586 + 1) = v672[0];
          v586[15] = 0;
          *((_QWORD *)v586 + 2) = 0;
          *(_DWORD *)(v586 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v586[24] = 0;
          *((_QWORD *)v586 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v586 + 5) = 0;
          *(_QWORD *)(v586 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v589 = *(void ***)a3;
          v588 = *(void ***)(a3 + 8);
          v590 = v586 + 48;
          if ( v588 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v586 - 4) = *(v588 - 4);
              *((_OWORD *)v586 - 3) = *((_OWORD *)v588 - 3);
              v591 = (__int64)*(v588 - 1);
              *(v588 - 5) = 0;
              *(v588 - 4) = 0;
              *(v588 - 6) = 0;
              *((_QWORD *)v586 - 1) = v591;
              *(_OWORD *)(v586 - 24) = *(_OWORD *)(v588 - 3);
              *(v588 - 3) = 0;
              *(v588 - 2) = 0;
              *(v588 - 1) = 0;
              v588 -= 6;
              v586 -= 48;
            }
            while ( v589 != v588 );
            v350 = *(void ***)a3;
            v589 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v586;
          *(_QWORD *)(a3 + 8) = v590;
          *(_QWORD *)(a3 + 16) = v587;
          if ( v589 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v589 - 3) & 1) != 0 )
                free(*(v589 - 1));
              v592 = v589 - 6;
              if ( (*(_BYTE *)(v589 - 6) & 1) != 0 )
                free(*(v589 - 4));
              v589 -= 6;
            }
            while ( v350 != v592 );
          }
          goto LABEL_1062;
        default:
          return v3;
      }
      goto LABEL_226;
    case 'm':
      switch ( a1[1] )
      {
        case 'I':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator-=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v84 = *(_QWORD *)(a3 + 16);
          if ( v5 < v84 )
            goto LABEL_375;
          v85 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v86 = 0x555555555555555LL;
          if ( v85 + 1 > 0x555555555555555LL )
            abort();
          v87 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v84 - *(_QWORD *)a3) >> 4);
          if ( v87 >= 0x2AAAAAAAAAAAAAALL || ((v88 = 2 * v87, v88 >= v85 + 1) ? (v86 = v88) : (v86 = v85 + 1), v86) )
          {
            v89 = *(_QWORD *)(a3 + 24);
            v90 = *(char **)(v89 + 4096);
            if ( v89 + 4096 - (__int64)v90 >= (unsigned __int64)(48 * v86) )
              *(_QWORD *)(v89 + 4096) = &v90[48 * v86];
            else
              v90 = (char *)malloc(48 * v86);
          }
          else
          {
            v90 = 0;
          }
          v509 = &v90[48 * v85];
          *v509 = 20;
          v510 = &v90[48 * v86];
          *(_WORD *)(v509 + 9) = v672[1];
          v509[11] = 0;
          *((_DWORD *)v509 + 3) = 0;
          *((_QWORD *)v509 + 2) = 0;
          *(_QWORD *)(v509 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v509[24] = 0;
          *((_QWORD *)v509 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v509 + 5) = 0;
          *(_QWORD *)(v509 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v512 = *(void ***)a3;
          v511 = *(void ***)(a3 + 8);
          v513 = v509 + 48;
          if ( v511 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v509 - 4) = *(v511 - 4);
              *((_OWORD *)v509 - 3) = *((_OWORD *)v511 - 3);
              v514 = (__int64)*(v511 - 1);
              *(v511 - 5) = 0;
              *(v511 - 4) = 0;
              *(v511 - 6) = 0;
              *((_QWORD *)v509 - 1) = v514;
              *(_OWORD *)(v509 - 24) = *(_OWORD *)(v511 - 3);
              *(v511 - 3) = 0;
              *(v511 - 2) = 0;
              *(v511 - 1) = 0;
              v511 -= 6;
              v509 -= 48;
            }
            while ( v512 != v511 );
            v350 = *(void ***)a3;
            v512 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v509;
          *(_QWORD *)(a3 + 8) = v513;
          *(_QWORD *)(a3 + 16) = v510;
          if ( v512 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v512 - 3) & 1) != 0 )
                free(*(v512 - 1));
              v515 = v512 - 6;
              if ( (*(_BYTE *)(v512 - 6) & 1) != 0 )
                free(*(v512 - 4));
              v512 -= 6;
            }
            while ( v350 != v515 );
          }
          goto LABEL_1062;
        case 'L':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator*=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v194 = *(_QWORD *)(a3 + 16);
          if ( v5 < v194 )
            goto LABEL_375;
          v195 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v196 = 0x555555555555555LL;
          if ( v195 + 1 > 0x555555555555555LL )
            abort();
          v197 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v194 - *(_QWORD *)a3) >> 4);
          if ( v197 >= 0x2AAAAAAAAAAAAAALL
            || ((v198 = 2 * v197, v198 >= v195 + 1) ? (v196 = v198) : (v196 = v195 + 1), v196) )
          {
            v199 = *(_QWORD *)(a3 + 24);
            v200 = *(char **)(v199 + 4096);
            if ( v199 + 4096 - (__int64)v200 >= (unsigned __int64)(48 * v196) )
              *(_QWORD *)(v199 + 4096) = &v200[48 * v196];
            else
              v200 = (char *)malloc(48 * v196);
          }
          else
          {
            v200 = 0;
          }
          v530 = &v200[48 * v195];
          *v530 = 20;
          v531 = &v200[48 * v196];
          *(_WORD *)(v530 + 9) = v672[1];
          v530[11] = 0;
          *((_DWORD *)v530 + 3) = 0;
          *((_QWORD *)v530 + 2) = 0;
          *(_QWORD *)(v530 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v530[24] = 0;
          *((_QWORD *)v530 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v530 + 5) = 0;
          *(_QWORD *)(v530 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v533 = *(void ***)a3;
          v532 = *(void ***)(a3 + 8);
          v534 = v530 + 48;
          if ( v532 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v530 - 4) = *(v532 - 4);
              *((_OWORD *)v530 - 3) = *((_OWORD *)v532 - 3);
              v535 = (__int64)*(v532 - 1);
              *(v532 - 5) = 0;
              *(v532 - 4) = 0;
              *(v532 - 6) = 0;
              *((_QWORD *)v530 - 1) = v535;
              *(_OWORD *)(v530 - 24) = *(_OWORD *)(v532 - 3);
              *(v532 - 3) = 0;
              *(v532 - 2) = 0;
              *(v532 - 1) = 0;
              v532 -= 6;
              v530 -= 48;
            }
            while ( v533 != v532 );
            v350 = *(void ***)a3;
            v533 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v530;
          *(_QWORD *)(a3 + 8) = v534;
          *(_QWORD *)(a3 + 16) = v531;
          if ( v533 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v533 - 3) & 1) != 0 )
                free(*(v533 - 1));
              v536 = v533 - 6;
              if ( (*(_BYTE *)(v533 - 6) & 1) != 0 )
                free(*(v533 - 4));
              v533 -= 6;
            }
            while ( v350 != v536 );
          }
          goto LABEL_1062;
        case 'i':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator-", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v170 = *(_QWORD *)(a3 + 16);
          if ( v5 < v170 )
            goto LABEL_378;
          v171 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v172 = 0x555555555555555LL;
          if ( v171 + 1 > 0x555555555555555LL )
            abort();
          v173 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v170 - *(_QWORD *)a3) >> 4);
          if ( v173 >= 0x2AAAAAAAAAAAAAALL
            || ((v174 = 2 * v173, v174 >= v171 + 1) ? (v172 = v174) : (v172 = v171 + 1), v172) )
          {
            v175 = *(_QWORD *)(a3 + 24);
            v176 = *(char **)(v175 + 4096);
            if ( v175 + 4096 - (__int64)v176 >= (unsigned __int64)(48 * v172) )
              *(_QWORD *)(v175 + 4096) = &v176[48 * v172];
            else
              v176 = (char *)malloc(48 * v172);
          }
          else
          {
            v176 = 0;
          }
          v481 = &v176[48 * v171];
          *v481 = 18;
          v482 = &v176[48 * v172];
          v481[9] = v672[1];
          v481[10] = 0;
          *(_QWORD *)(v481 + 1) = v672[0];
          v481[15] = 0;
          *((_QWORD *)v481 + 2) = 0;
          *(_DWORD *)(v481 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v481[24] = 0;
          *((_QWORD *)v481 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v481 + 5) = 0;
          *(_QWORD *)(v481 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v484 = *(void ***)a3;
          v483 = *(void ***)(a3 + 8);
          v485 = v481 + 48;
          if ( v483 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v481 - 4) = *(v483 - 4);
              *((_OWORD *)v481 - 3) = *((_OWORD *)v483 - 3);
              v486 = (__int64)*(v483 - 1);
              *(v483 - 5) = 0;
              *(v483 - 4) = 0;
              *(v483 - 6) = 0;
              *((_QWORD *)v481 - 1) = v486;
              *(_OWORD *)(v481 - 24) = *(_OWORD *)(v483 - 3);
              *(v483 - 3) = 0;
              *(v483 - 2) = 0;
              *(v483 - 1) = 0;
              v483 -= 6;
              v481 -= 48;
            }
            while ( v484 != v483 );
            v350 = *(void ***)a3;
            v484 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v481;
          *(_QWORD *)(a3 + 8) = v485;
          *(_QWORD *)(a3 + 16) = v482;
          if ( v484 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v484 - 3) & 1) != 0 )
                free(*(v484 - 1));
              v487 = v484 - 6;
              if ( (*(_BYTE *)(v484 - 6) & 1) != 0 )
                free(*(v484 - 4));
              v484 -= 6;
            }
            while ( v350 != v487 );
          }
          goto LABEL_1062;
        case 'l':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator*", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v230 = *(_QWORD *)(a3 + 16);
          if ( v5 < v230 )
            goto LABEL_378;
          v231 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v232 = 0x555555555555555LL;
          if ( v231 + 1 > 0x555555555555555LL )
            abort();
          v233 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v230 - *(_QWORD *)a3) >> 4);
          if ( v233 >= 0x2AAAAAAAAAAAAAALL
            || ((v234 = 2 * v233, v234 >= v231 + 1) ? (v232 = v234) : (v232 = v231 + 1), v232) )
          {
            v235 = *(_QWORD *)(a3 + 24);
            v236 = *(char **)(v235 + 4096);
            if ( v235 + 4096 - (__int64)v236 >= (unsigned __int64)(48 * v232) )
              *(_QWORD *)(v235 + 4096) = &v236[48 * v232];
            else
              v236 = (char *)malloc(48 * v232);
          }
          else
          {
            v236 = 0;
          }
          v572 = &v236[48 * v231];
          *v572 = 18;
          v573 = &v236[48 * v232];
          v572[9] = v672[1];
          v572[10] = 0;
          *(_QWORD *)(v572 + 1) = v672[0];
          v572[15] = 0;
          *((_QWORD *)v572 + 2) = 0;
          *(_DWORD *)(v572 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v572[24] = 0;
          *((_QWORD *)v572 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v572 + 5) = 0;
          *(_QWORD *)(v572 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v575 = *(void ***)a3;
          v574 = *(void ***)(a3 + 8);
          v576 = v572 + 48;
          if ( v574 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v572 - 4) = *(v574 - 4);
              *((_OWORD *)v572 - 3) = *((_OWORD *)v574 - 3);
              v577 = (__int64)*(v574 - 1);
              *(v574 - 5) = 0;
              *(v574 - 4) = 0;
              *(v574 - 6) = 0;
              *((_QWORD *)v572 - 1) = v577;
              *(_OWORD *)(v572 - 24) = *(_OWORD *)(v574 - 3);
              *(v574 - 3) = 0;
              *(v574 - 2) = 0;
              *(v574 - 1) = 0;
              v574 -= 6;
              v572 -= 48;
            }
            while ( v575 != v574 );
            v350 = *(void ***)a3;
            v575 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v572;
          *(_QWORD *)(a3 + 8) = v576;
          *(_QWORD *)(a3 + 16) = v573;
          if ( v575 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v575 - 3) & 1) != 0 )
                free(*(v575 - 1));
              v578 = v575 - 6;
              if ( (*(_BYTE *)(v575 - 6) & 1) != 0 )
                free(*(v575 - 4));
              v575 -= 6;
            }
            while ( v350 != v578 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator--", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v251 = *(_QWORD *)(a3 + 16);
          if ( v5 < v251 )
            goto LABEL_375;
          v252 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v253 = 0x555555555555555LL;
          if ( v252 + 1 > 0x555555555555555LL )
            abort();
          v254 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v251 - *(_QWORD *)a3) >> 4);
          if ( v254 >= 0x2AAAAAAAAAAAAAALL
            || ((v255 = 2 * v254, v255 >= v252 + 1) ? (v253 = v255) : (v253 = v252 + 1), v253) )
          {
            v256 = *(_QWORD *)(a3 + 24);
            v257 = *(char **)(v256 + 4096);
            if ( v256 + 4096 - (__int64)v257 >= (unsigned __int64)(48 * v253) )
              *(_QWORD *)(v256 + 4096) = &v257[48 * v253];
            else
              v257 = (char *)malloc(48 * v253);
          }
          else
          {
            v257 = 0;
          }
          v593 = &v257[48 * v252];
          *v593 = 20;
          v594 = &v257[48 * v253];
          *(_WORD *)(v593 + 9) = v672[1];
          v593[11] = 0;
          *((_DWORD *)v593 + 3) = 0;
          *((_QWORD *)v593 + 2) = 0;
          *(_QWORD *)(v593 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v593[24] = 0;
          *((_QWORD *)v593 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v593 + 5) = 0;
          *(_QWORD *)(v593 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v596 = *(void ***)a3;
          v595 = *(void ***)(a3 + 8);
          v597 = v593 + 48;
          if ( v595 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v593 - 4) = *(v595 - 4);
              *((_OWORD *)v593 - 3) = *((_OWORD *)v595 - 3);
              v598 = (__int64)*(v595 - 1);
              *(v595 - 5) = 0;
              *(v595 - 4) = 0;
              *(v595 - 6) = 0;
              *((_QWORD *)v593 - 1) = v598;
              *(_OWORD *)(v593 - 24) = *(_OWORD *)(v595 - 3);
              *(v595 - 3) = 0;
              *(v595 - 2) = 0;
              *(v595 - 1) = 0;
              v595 -= 6;
              v593 -= 48;
            }
            while ( v596 != v595 );
            v350 = *(void ***)a3;
            v596 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v593;
          *(_QWORD *)(a3 + 8) = v597;
          *(_QWORD *)(a3 + 16) = v594;
          if ( v596 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v596 - 3) & 1) != 0 )
                free(*(v596 - 1));
              v599 = v596 - 6;
              if ( (*(_BYTE *)(v596 - 6) & 1) != 0 )
                free(*(v596 - 4));
              v596 -= 6;
            }
            while ( v350 != v599 );
          }
          goto LABEL_1062;
        default:
          return v3;
      }
      return v3;
    case 'n':
      switch ( a1[1] )
      {
        case 'a':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator new[]", 14);
          v5 = *(_QWORD *)(a3 + 8);
          v99 = *(_QWORD *)(a3 + 16);
          if ( v5 < v99 )
          {
            *(_BYTE *)v5 = 28;
            v3 = a1 + 2;
            *(_QWORD *)(v5 + 7) = *(_QWORD *)((char *)v672 + 6);
            *(_BYTE *)(v5 + 15) = 0;
            *(_QWORD *)(v5 + 16) = 0;
            *(_QWORD *)(v5 + 1) = v672[0];
            *(_QWORD *)((char *)v672 + 6) = 0;
            goto LABEL_376;
          }
          v308 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v309 = 0x555555555555555LL;
          if ( v308 + 1 > 0x555555555555555LL )
            abort();
          v310 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v99 - *(_QWORD *)a3) >> 4);
          if ( v310 >= 0x2AAAAAAAAAAAAAALL
            || ((v311 = 2 * v310, v311 >= v308 + 1) ? (v309 = v311) : (v309 = v308 + 1), v309) )
          {
            v312 = *(_QWORD *)(a3 + 24);
            v313 = *(char **)(v312 + 4096);
            if ( v312 + 4096 - (__int64)v313 >= (unsigned __int64)(48 * v309) )
              *(_QWORD *)(v312 + 4096) = &v313[48 * v309];
            else
              v313 = (char *)malloc(48 * v309);
          }
          else
          {
            v313 = 0;
          }
          v600 = &v313[48 * v308];
          *v600 = 28;
          v601 = &v313[48 * v309];
          *(_QWORD *)(v600 + 7) = *(_QWORD *)((char *)v672 + 6);
          v600[15] = 0;
          *((_QWORD *)v600 + 2) = 0;
          *(_QWORD *)(v600 + 1) = v672[0];
          *(_QWORD *)((char *)v672 + 6) = 0;
          v672[0] = 0;
          v600[24] = 0;
          *((_QWORD *)v600 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v600 + 5) = 0;
          *(_QWORD *)(v600 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v603 = *(void ***)a3;
          v602 = *(void ***)(a3 + 8);
          v604 = v600 + 48;
          if ( v602 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v600 - 4) = *(v602 - 4);
              *((_OWORD *)v600 - 3) = *((_OWORD *)v602 - 3);
              v605 = (__int64)*(v602 - 1);
              *(v602 - 5) = 0;
              *(v602 - 4) = 0;
              *(v602 - 6) = 0;
              *((_QWORD *)v600 - 1) = v605;
              *(_OWORD *)(v600 - 24) = *(_OWORD *)(v602 - 3);
              *(v602 - 3) = 0;
              *(v602 - 2) = 0;
              *(v602 - 1) = 0;
              v602 -= 6;
              v600 -= 48;
            }
            while ( v603 != v602 );
            v350 = *(void ***)a3;
            v603 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v600;
          *(_QWORD *)(a3 + 8) = v604;
          *(_QWORD *)(a3 + 16) = v601;
          if ( v603 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v603 - 3) & 1) != 0 )
                free(*(v603 - 1));
              v606 = v603 - 6;
              if ( (*(_BYTE *)(v603 - 6) & 1) != 0 )
                free(*(v603 - 4));
              v603 -= 6;
            }
            while ( v350 != v606 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator!=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v258 = *(_QWORD *)(a3 + 16);
          if ( v5 < v258 )
            goto LABEL_375;
          v259 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v260 = 0x555555555555555LL;
          if ( v259 + 1 > 0x555555555555555LL )
            abort();
          v261 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v258 - *(_QWORD *)a3) >> 4);
          if ( v261 >= 0x2AAAAAAAAAAAAAALL
            || ((v262 = 2 * v261, v262 >= v259 + 1) ? (v260 = v262) : (v260 = v259 + 1), v260) )
          {
            v263 = *(_QWORD *)(a3 + 24);
            v264 = *(char **)(v263 + 4096);
            if ( v263 + 4096 - (__int64)v264 >= (unsigned __int64)(48 * v260) )
              *(_QWORD *)(v263 + 4096) = &v264[48 * v260];
            else
              v264 = (char *)malloc(48 * v260);
          }
          else
          {
            v264 = 0;
          }
          v607 = &v264[48 * v259];
          *v607 = 20;
          v608 = &v264[48 * v260];
          *(_WORD *)(v607 + 9) = v672[1];
          v607[11] = 0;
          *((_DWORD *)v607 + 3) = 0;
          *((_QWORD *)v607 + 2) = 0;
          *(_QWORD *)(v607 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v607[24] = 0;
          *((_QWORD *)v607 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v607 + 5) = 0;
          *(_QWORD *)(v607 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v610 = *(void ***)a3;
          v609 = *(void ***)(a3 + 8);
          v611 = v607 + 48;
          if ( v609 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v607 - 4) = *(v609 - 4);
              *((_OWORD *)v607 - 3) = *((_OWORD *)v609 - 3);
              v612 = (__int64)*(v609 - 1);
              *(v609 - 5) = 0;
              *(v609 - 4) = 0;
              *(v609 - 6) = 0;
              *((_QWORD *)v607 - 1) = v612;
              *(_OWORD *)(v607 - 24) = *(_OWORD *)(v609 - 3);
              *(v609 - 3) = 0;
              *(v609 - 2) = 0;
              *(v609 - 1) = 0;
              v609 -= 6;
              v607 -= 48;
            }
            while ( v610 != v609 );
            v350 = *(void ***)a3;
            v610 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v607;
          *(_QWORD *)(a3 + 8) = v611;
          *(_QWORD *)(a3 + 16) = v608;
          if ( v610 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v610 - 3) & 1) != 0 )
                free(*(v610 - 1));
              v613 = v610 - 6;
              if ( (*(_BYTE *)(v610 - 6) & 1) != 0 )
                free(*(v610 - 4));
              v610 -= 6;
            }
            while ( v350 != v613 );
          }
          goto LABEL_1062;
        case 'g':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator-", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v201 = *(_QWORD *)(a3 + 16);
          if ( v5 < v201 )
            goto LABEL_378;
          v202 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v203 = 0x555555555555555LL;
          if ( v202 + 1 > 0x555555555555555LL )
            abort();
          v204 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v201 - *(_QWORD *)a3) >> 4);
          if ( v204 >= 0x2AAAAAAAAAAAAAALL
            || ((v205 = 2 * v204, v205 >= v202 + 1) ? (v203 = v205) : (v203 = v202 + 1), v203) )
          {
            v206 = *(_QWORD *)(a3 + 24);
            v207 = *(char **)(v206 + 4096);
            if ( v206 + 4096 - (__int64)v207 >= (unsigned __int64)(48 * v203) )
              *(_QWORD *)(v206 + 4096) = &v207[48 * v203];
            else
              v207 = (char *)malloc(48 * v203);
          }
          else
          {
            v207 = 0;
          }
          v537 = &v207[48 * v202];
          *v537 = 18;
          v538 = &v207[48 * v203];
          v537[9] = v672[1];
          v537[10] = 0;
          *(_QWORD *)(v537 + 1) = v672[0];
          v537[15] = 0;
          *((_QWORD *)v537 + 2) = 0;
          *(_DWORD *)(v537 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v537[24] = 0;
          *((_QWORD *)v537 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v537 + 5) = 0;
          *(_QWORD *)(v537 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v540 = *(void ***)a3;
          v539 = *(void ***)(a3 + 8);
          v541 = v537 + 48;
          if ( v539 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v537 - 4) = *(v539 - 4);
              *((_OWORD *)v537 - 3) = *((_OWORD *)v539 - 3);
              v542 = (__int64)*(v539 - 1);
              *(v539 - 5) = 0;
              *(v539 - 4) = 0;
              *(v539 - 6) = 0;
              *((_QWORD *)v537 - 1) = v542;
              *(_OWORD *)(v537 - 24) = *(_OWORD *)(v539 - 3);
              *(v539 - 3) = 0;
              *(v539 - 2) = 0;
              *(v539 - 1) = 0;
              v539 -= 6;
              v537 -= 48;
            }
            while ( v540 != v539 );
            v350 = *(void ***)a3;
            v540 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v537;
          *(_QWORD *)(a3 + 8) = v541;
          *(_QWORD *)(a3 + 16) = v538;
          if ( v540 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v540 - 3) & 1) != 0 )
                free(*(v540 - 1));
              v543 = v540 - 6;
              if ( (*(_BYTE *)(v540 - 6) & 1) != 0 )
                free(*(v540 - 4));
              v540 -= 6;
            }
            while ( v350 != v543 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator!", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v265 = *(_QWORD *)(a3 + 16);
          if ( v5 < v265 )
            goto LABEL_378;
          v266 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v267 = 0x555555555555555LL;
          if ( v266 + 1 > 0x555555555555555LL )
            abort();
          v268 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v265 - *(_QWORD *)a3) >> 4);
          if ( v268 >= 0x2AAAAAAAAAAAAAALL
            || ((v269 = 2 * v268, v269 >= v266 + 1) ? (v267 = v269) : (v267 = v266 + 1), v267) )
          {
            v270 = *(_QWORD *)(a3 + 24);
            v271 = *(char **)(v270 + 4096);
            if ( v270 + 4096 - (__int64)v271 >= (unsigned __int64)(48 * v267) )
              *(_QWORD *)(v270 + 4096) = &v271[48 * v267];
            else
              v271 = (char *)malloc(48 * v267);
          }
          else
          {
            v271 = 0;
          }
          v614 = &v271[48 * v266];
          *v614 = 18;
          v615 = &v271[48 * v267];
          v614[9] = v672[1];
          v614[10] = 0;
          *(_QWORD *)(v614 + 1) = v672[0];
          v614[15] = 0;
          *((_QWORD *)v614 + 2) = 0;
          *(_DWORD *)(v614 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v614[24] = 0;
          *((_QWORD *)v614 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v614 + 5) = 0;
          *(_QWORD *)(v614 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v617 = *(void ***)a3;
          v616 = *(void ***)(a3 + 8);
          v618 = v614 + 48;
          if ( v616 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v614 - 4) = *(v616 - 4);
              *((_OWORD *)v614 - 3) = *((_OWORD *)v616 - 3);
              v619 = (__int64)*(v616 - 1);
              *(v616 - 5) = 0;
              *(v616 - 4) = 0;
              *(v616 - 6) = 0;
              *((_QWORD *)v614 - 1) = v619;
              *(_OWORD *)(v614 - 24) = *(_OWORD *)(v616 - 3);
              *(v616 - 3) = 0;
              *(v616 - 2) = 0;
              *(v616 - 1) = 0;
              v616 -= 6;
              v614 -= 48;
            }
            while ( v617 != v616 );
            v350 = *(void ***)a3;
            v617 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v614;
          *(_QWORD *)(a3 + 8) = v618;
          *(_QWORD *)(a3 + 16) = v615;
          if ( v617 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v617 - 3) & 1) != 0 )
                free(*(v617 - 1));
              v620 = v617 - 6;
              if ( (*(_BYTE *)(v617 - 6) & 1) != 0 )
                free(*(v617 - 4));
              v617 -= 6;
            }
            while ( v350 != v620 );
          }
          goto LABEL_1062;
        case 'w':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator new", 12);
          v5 = *(_QWORD *)(a3 + 8);
          v272 = *(_QWORD *)(a3 + 16);
          if ( v5 < v272 )
          {
            *(_BYTE *)v5 = 24;
            v3 = a1 + 2;
            *(_DWORD *)(v5 + 9) = v672[1];
            *(_BYTE *)(v5 + 13) = 0;
            *(_WORD *)(v5 + 14) = 0;
            *(_QWORD *)(v5 + 16) = 0;
            *(_QWORD *)(v5 + 1) = v672[0];
            LODWORD(v672[1]) = 0;
            goto LABEL_376;
          }
          v314 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v315 = 0x555555555555555LL;
          if ( v314 + 1 > 0x555555555555555LL )
            abort();
          v316 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v272 - *(_QWORD *)a3) >> 4);
          if ( v316 >= 0x2AAAAAAAAAAAAAALL
            || ((v317 = 2 * v316, v317 >= v314 + 1) ? (v315 = v317) : (v315 = v314 + 1), v315) )
          {
            v318 = *(_QWORD *)(a3 + 24);
            v319 = *(char **)(v318 + 4096);
            if ( v318 + 4096 - (__int64)v319 >= (unsigned __int64)(48 * v315) )
              *(_QWORD *)(v318 + 4096) = &v319[48 * v315];
            else
              v319 = (char *)malloc(48 * v315);
          }
          else
          {
            v319 = 0;
          }
          v621 = &v319[48 * v314];
          *v621 = 24;
          v622 = &v319[48 * v315];
          *(_DWORD *)(v621 + 9) = v672[1];
          v621[13] = 0;
          *((_WORD *)v621 + 7) = 0;
          *((_QWORD *)v621 + 2) = 0;
          *(_QWORD *)(v621 + 1) = v672[0];
          LODWORD(v672[1]) = 0;
          v672[0] = 0;
          v621[24] = 0;
          *((_QWORD *)v621 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v621 + 5) = 0;
          *(_QWORD *)(v621 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v624 = *(void ***)a3;
          v623 = *(void ***)(a3 + 8);
          v625 = v621 + 48;
          if ( v623 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v621 - 4) = *(v623 - 4);
              *((_OWORD *)v621 - 3) = *((_OWORD *)v623 - 3);
              v626 = (__int64)*(v623 - 1);
              *(v623 - 5) = 0;
              *(v623 - 4) = 0;
              *(v623 - 6) = 0;
              *((_QWORD *)v621 - 1) = v626;
              *(_OWORD *)(v621 - 24) = *(_OWORD *)(v623 - 3);
              *(v623 - 3) = 0;
              *(v623 - 2) = 0;
              *(v623 - 1) = 0;
              v623 -= 6;
              v621 -= 48;
            }
            while ( v624 != v623 );
            v350 = *(void ***)a3;
            v624 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v621;
          *(_QWORD *)(a3 + 8) = v625;
          *(_QWORD *)(a3 + 16) = v622;
          if ( v624 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v624 - 3) & 1) != 0 )
                free(*(v624 - 1));
              v627 = v624 - 6;
              if ( (*(_BYTE *)(v624 - 6) & 1) != 0 )
                free(*(v624 - 4));
              v624 -= 6;
            }
            while ( v350 != v627 );
          }
          break;
        default:
          return v3;
      }
      goto LABEL_1062;
    case 'o':
      v91 = (unsigned __int8)a1[1];
      if ( v91 == 82 )
      {
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        qmemcpy(v672, "operator|=", 10);
        v5 = *(_QWORD *)(a3 + 8);
        v128 = *(_QWORD *)(a3 + 16);
        if ( v5 >= v128 )
        {
          v129 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v130 = 0x555555555555555LL;
          if ( v129 + 1 > 0x555555555555555LL )
            abort();
          v131 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v128 - *(_QWORD *)a3) >> 4);
          if ( v131 >= 0x2AAAAAAAAAAAAAALL
            || ((v132 = 2 * v131, v132 >= v129 + 1) ? (v130 = v132) : (v130 = v129 + 1), v130) )
          {
            v133 = *(_QWORD *)(a3 + 24);
            v134 = *(char **)(v133 + 4096);
            if ( v133 + 4096 - (__int64)v134 >= (unsigned __int64)(48 * v130) )
              *(_QWORD *)(v133 + 4096) = &v134[48 * v130];
            else
              v134 = (char *)malloc(48 * v130);
          }
          else
          {
            v134 = 0;
          }
          v410 = &v134[48 * v129];
          *v410 = 20;
          v411 = &v134[48 * v130];
          *(_WORD *)(v410 + 9) = v672[1];
          v410[11] = 0;
          *((_DWORD *)v410 + 3) = 0;
          *((_QWORD *)v410 + 2) = 0;
          *(_QWORD *)(v410 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v410[24] = 0;
          *((_QWORD *)v410 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v410 + 5) = 0;
          *(_QWORD *)(v410 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v413 = *(void ***)a3;
          v412 = *(void ***)(a3 + 8);
          v414 = v410 + 48;
          if ( v412 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v410 - 4) = *(v412 - 4);
              *((_OWORD *)v410 - 3) = *((_OWORD *)v412 - 3);
              v415 = (__int64)*(v412 - 1);
              *(v412 - 5) = 0;
              *(v412 - 4) = 0;
              *(v412 - 6) = 0;
              *((_QWORD *)v410 - 1) = v415;
              *(_OWORD *)(v410 - 24) = *(_OWORD *)(v412 - 3);
              *(v412 - 3) = 0;
              *(v412 - 2) = 0;
              *(v412 - 1) = 0;
              v412 -= 6;
              v410 -= 48;
            }
            while ( v413 != v412 );
            v350 = *(void ***)a3;
            v413 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v410;
          *(_QWORD *)(a3 + 8) = v414;
          *(_QWORD *)(a3 + 16) = v411;
          if ( v413 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v413 - 3) & 1) != 0 )
                free(*(v413 - 1));
              v416 = v413 - 6;
              if ( (*(_BYTE *)(v413 - 6) & 1) != 0 )
                free(*(v413 - 4));
              v413 -= 6;
            }
            while ( v350 != v416 );
          }
          goto LABEL_1062;
        }
        goto LABEL_375;
      }
      if ( v91 == 114 )
      {
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
        qmemcpy(v672, "operator|", 9);
        v5 = *(_QWORD *)(a3 + 8);
        v121 = *(_QWORD *)(a3 + 16);
        if ( v5 >= v121 )
        {
          v122 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v123 = 0x555555555555555LL;
          if ( v122 + 1 > 0x555555555555555LL )
            abort();
          v124 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v121 - *(_QWORD *)a3) >> 4);
          if ( v124 >= 0x2AAAAAAAAAAAAAALL
            || ((v125 = 2 * v124, v125 >= v122 + 1) ? (v123 = v125) : (v123 = v122 + 1), v123) )
          {
            v126 = *(_QWORD *)(a3 + 24);
            v127 = *(char **)(v126 + 4096);
            if ( v126 + 4096 - (__int64)v127 >= (unsigned __int64)(48 * v123) )
              *(_QWORD *)(v126 + 4096) = &v127[48 * v123];
            else
              v127 = (char *)malloc(48 * v123);
          }
          else
          {
            v127 = 0;
          }
          v403 = &v127[48 * v122];
          *v403 = 18;
          v404 = &v127[48 * v123];
          v403[9] = v672[1];
          v403[10] = 0;
          *(_QWORD *)(v403 + 1) = v672[0];
          v403[15] = 0;
          *((_QWORD *)v403 + 2) = 0;
          *(_DWORD *)(v403 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v403[24] = 0;
          *((_QWORD *)v403 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v403 + 5) = 0;
          *(_QWORD *)(v403 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v406 = *(void ***)a3;
          v405 = *(void ***)(a3 + 8);
          v407 = v403 + 48;
          if ( v405 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v403 - 4) = *(v405 - 4);
              *((_OWORD *)v403 - 3) = *((_OWORD *)v405 - 3);
              v408 = (__int64)*(v405 - 1);
              *(v405 - 5) = 0;
              *(v405 - 4) = 0;
              *(v405 - 6) = 0;
              *((_QWORD *)v403 - 1) = v408;
              *(_OWORD *)(v403 - 24) = *(_OWORD *)(v405 - 3);
              *(v405 - 3) = 0;
              *(v405 - 2) = 0;
              *(v405 - 1) = 0;
              v405 -= 6;
              v403 -= 48;
            }
            while ( v406 != v405 );
            v350 = *(void ***)a3;
            v406 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v403;
          *(_QWORD *)(a3 + 8) = v407;
          *(_QWORD *)(a3 + 16) = v404;
          if ( v406 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v406 - 3) & 1) != 0 )
                free(*(v406 - 1));
              v409 = v406 - 6;
              if ( (*(_BYTE *)(v406 - 6) & 1) != 0 )
                free(*(v406 - 4));
              v406 -= 6;
            }
            while ( v350 != v409 );
          }
          goto LABEL_1062;
        }
LABEL_378:
        *(_BYTE *)v5 = 18;
        v3 = a1 + 2;
        *(_BYTE *)(v5 + 9) = v672[1];
        *(_BYTE *)(v5 + 10) = 0;
        *(_QWORD *)(v5 + 1) = v672[0];
        *(_BYTE *)(v5 + 15) = 0;
        *(_QWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 11) = 0;
        LOBYTE(v672[1]) = 0;
        v672[0] = 0;
LABEL_379:
        *(_BYTE *)(v5 + 24) = 0;
        *(_QWORD *)(v5 + 32) = *(_QWORD *)((char *)v673 + 7);
        *(_QWORD *)(v5 + 40) = 0;
        *(_QWORD *)(v5 + 25) = v673[0];
        *(_QWORD *)((char *)v673 + 7) = 0;
        v673[0] = 0;
LABEL_380:
        *(_QWORD *)(a3 + 8) += 48LL;
        return v3;
      }
      if ( v91 != 111 )
        return v3;
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      qmemcpy(v672, "operator||", 10);
      v5 = *(_QWORD *)(a3 + 8);
      v92 = *(_QWORD *)(a3 + 16);
      if ( v5 < v92 )
      {
LABEL_375:
        *(_BYTE *)v5 = 20;
        v3 = a1 + 2;
        *(_WORD *)(v5 + 9) = v672[1];
        *(_BYTE *)(v5 + 11) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_QWORD *)(v5 + 16) = 0;
        *(_QWORD *)(v5 + 1) = v672[0];
        LOWORD(v672[1]) = 0;
LABEL_376:
        v672[0] = 0;
        goto LABEL_379;
      }
      v93 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
      v94 = 0x555555555555555LL;
      if ( v93 + 1 > 0x555555555555555LL )
        abort();
      v95 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v92 - *(_QWORD *)a3) >> 4);
      if ( v95 >= 0x2AAAAAAAAAAAAAALL || ((v96 = 2 * v95, v96 >= v93 + 1) ? (v94 = v96) : (v94 = v93 + 1), v94) )
      {
        v97 = *(_QWORD *)(a3 + 24);
        v98 = *(char **)(v97 + 4096);
        if ( v97 + 4096 - (__int64)v98 >= (unsigned __int64)(48 * v94) )
          *(_QWORD *)(v97 + 4096) = &v98[48 * v94];
        else
          v98 = (char *)malloc(48 * v94);
      }
      else
      {
        v98 = 0;
      }
      v417 = &v98[48 * v93];
      *v417 = 20;
      v418 = &v98[48 * v94];
      *(_WORD *)(v417 + 9) = v672[1];
      v417[11] = 0;
      *((_DWORD *)v417 + 3) = 0;
      *((_QWORD *)v417 + 2) = 0;
      *(_QWORD *)(v417 + 1) = v672[0];
      LOWORD(v672[1]) = 0;
      v672[0] = 0;
      v417[24] = 0;
      *((_QWORD *)v417 + 4) = *(_QWORD *)((char *)v673 + 7);
      *((_QWORD *)v417 + 5) = 0;
      *(_QWORD *)(v417 + 25) = v673[0];
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      v420 = *(void ***)a3;
      v419 = *(void ***)(a3 + 8);
      v421 = v417 + 48;
      if ( v419 == *(void ***)a3 )
      {
        v350 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v417 - 4) = *(v419 - 4);
          *((_OWORD *)v417 - 3) = *((_OWORD *)v419 - 3);
          v422 = (__int64)*(v419 - 1);
          *(v419 - 5) = 0;
          *(v419 - 4) = 0;
          *(v419 - 6) = 0;
          *((_QWORD *)v417 - 1) = v422;
          *(_OWORD *)(v417 - 24) = *(_OWORD *)(v419 - 3);
          *(v419 - 3) = 0;
          *(v419 - 2) = 0;
          *(v419 - 1) = 0;
          v419 -= 6;
          v417 -= 48;
        }
        while ( v420 != v419 );
        v350 = *(void ***)a3;
        v420 = *(void ***)(a3 + 8);
      }
      v351 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v417;
      *(_QWORD *)(a3 + 8) = v421;
      *(_QWORD *)(a3 + 16) = v418;
      if ( v420 != v350 )
      {
        do
        {
          if ( (*(_BYTE *)(v420 - 3) & 1) != 0 )
            free(*(v420 - 1));
          v423 = v420 - 6;
          if ( (*(_BYTE *)(v420 - 6) & 1) != 0 )
            free(*(v420 - 4));
          v420 -= 6;
        }
        while ( v350 != v423 );
      }
LABEL_1062:
      if ( v350 )
      {
        v670 = *(_QWORD *)(a3 + 24);
        if ( v670 + 4096 < (unsigned __int64)v350 || v670 > (unsigned __int64)v350 )
        {
LABEL_1067:
          free(v350);
        }
        else if ( *(_QWORD *)(v670 + 4096) == v351 )
        {
          *(_QWORD *)(v670 + 4096) = v350;
        }
      }
LABEL_1068:
      v3 += 2;
      return v3;
    case 'p':
      switch ( a1[1] )
      {
        case 'L':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator+=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v19 = *(_QWORD *)(a3 + 16);
          if ( v5 < v19 )
            goto LABEL_375;
          v20 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v21 = 0x555555555555555LL;
          if ( v20 + 1 > 0x555555555555555LL )
            abort();
          v22 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v19 - *(_QWORD *)a3) >> 4);
          if ( v22 >= 0x2AAAAAAAAAAAAAALL || ((v23 = 2 * v22, v23 >= v20 + 1) ? (v21 = v23) : (v21 = v20 + 1), v21) )
          {
            v24 = *(_QWORD *)(a3 + 24);
            v25 = *(char **)(v24 + 4096);
            if ( v24 + 4096 - (__int64)v25 >= (unsigned __int64)(48 * v21) )
              *(_QWORD *)(v24 + 4096) = &v25[48 * v21];
            else
              v25 = (char *)malloc(48 * v21);
          }
          else
          {
            v25 = 0;
          }
          v642 = &v25[48 * v20];
          *v642 = 20;
          v643 = &v25[48 * v21];
          *(_WORD *)(v642 + 9) = v672[1];
          v642[11] = 0;
          *((_DWORD *)v642 + 3) = 0;
          *((_QWORD *)v642 + 2) = 0;
          *(_QWORD *)(v642 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v642[24] = 0;
          *((_QWORD *)v642 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v642 + 5) = 0;
          *(_QWORD *)(v642 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v645 = *(void ***)a3;
          v644 = *(void ***)(a3 + 8);
          v646 = v642 + 48;
          if ( v644 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v642 - 4) = *(v644 - 4);
              *((_OWORD *)v642 - 3) = *((_OWORD *)v644 - 3);
              v647 = (__int64)*(v644 - 1);
              *(v644 - 5) = 0;
              *(v644 - 4) = 0;
              *(v644 - 6) = 0;
              *((_QWORD *)v642 - 1) = v647;
              *(_OWORD *)(v642 - 24) = *(_OWORD *)(v644 - 3);
              *(v644 - 3) = 0;
              *(v644 - 2) = 0;
              *(v644 - 1) = 0;
              v644 -= 6;
              v642 -= 48;
            }
            while ( v645 != v644 );
            v350 = *(void ***)a3;
            v645 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v642;
          *(_QWORD *)(a3 + 8) = v646;
          *(_QWORD *)(a3 + 16) = v643;
          if ( v645 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v645 - 3) & 1) != 0 )
                free(*(v645 - 1));
              v648 = v645 - 6;
              if ( (*(_BYTE *)(v645 - 6) & 1) != 0 )
                free(*(v645 - 4));
              v645 -= 6;
            }
            while ( v350 != v648 );
          }
          goto LABEL_1062;
        case 'l':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator+", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v275 = *(_QWORD *)(a3 + 16);
          if ( v5 < v275 )
            goto LABEL_378;
          v276 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v277 = 0x555555555555555LL;
          if ( v276 + 1 > 0x555555555555555LL )
            abort();
          v278 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v275 - *(_QWORD *)a3) >> 4);
          if ( v278 >= 0x2AAAAAAAAAAAAAALL
            || ((v279 = 2 * v278, v279 >= v276 + 1) ? (v277 = v279) : (v277 = v276 + 1), v277) )
          {
            v280 = *(_QWORD *)(a3 + 24);
            v281 = *(char **)(v280 + 4096);
            if ( v280 + 4096 - (__int64)v281 >= (unsigned __int64)(48 * v277) )
              *(_QWORD *)(v280 + 4096) = &v281[48 * v277];
            else
              v281 = (char *)malloc(48 * v277);
          }
          else
          {
            v281 = 0;
          }
          v649 = &v281[48 * v276];
          *v649 = 18;
          v650 = &v281[48 * v277];
          v649[9] = v672[1];
          v649[10] = 0;
          *(_QWORD *)(v649 + 1) = v672[0];
          v649[15] = 0;
          *((_QWORD *)v649 + 2) = 0;
          *(_DWORD *)(v649 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v649[24] = 0;
          *((_QWORD *)v649 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v649 + 5) = 0;
          *(_QWORD *)(v649 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v652 = *(void ***)a3;
          v651 = *(void ***)(a3 + 8);
          v653 = v649 + 48;
          if ( v651 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v649 - 4) = *(v651 - 4);
              *((_OWORD *)v649 - 3) = *((_OWORD *)v651 - 3);
              v654 = (__int64)*(v651 - 1);
              *(v651 - 5) = 0;
              *(v651 - 4) = 0;
              *(v651 - 6) = 0;
              *((_QWORD *)v649 - 1) = v654;
              *(_OWORD *)(v649 - 24) = *(_OWORD *)(v651 - 3);
              *(v651 - 3) = 0;
              *(v651 - 2) = 0;
              *(v651 - 1) = 0;
              v651 -= 6;
              v649 -= 48;
            }
            while ( v652 != v651 );
            v350 = *(void ***)a3;
            v652 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v649;
          *(_QWORD *)(a3 + 8) = v653;
          *(_QWORD *)(a3 + 16) = v650;
          if ( v652 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v652 - 3) & 1) != 0 )
                free(*(v652 - 1));
              v655 = v652 - 6;
              if ( (*(_BYTE *)(v652 - 6) & 1) != 0 )
                free(*(v652 - 4));
              v652 -= 6;
            }
            while ( v350 != v655 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator->*", 11);
          v5 = *(_QWORD *)(a3 + 8);
          v273 = *(_QWORD *)(a3 + 16);
          if ( v5 < v273 )
            goto LABEL_183;
          v320 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v321 = 0x555555555555555LL;
          if ( v320 + 1 > 0x555555555555555LL )
            abort();
          v322 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v273 - *(_QWORD *)a3) >> 4);
          if ( v322 >= 0x2AAAAAAAAAAAAAALL
            || ((v323 = 2 * v322, v323 >= v320 + 1) ? (v321 = v323) : (v321 = v320 + 1), v321) )
          {
            v324 = *(_QWORD *)(a3 + 24);
            v325 = *(char **)(v324 + 4096);
            if ( v324 + 4096 - (__int64)v325 >= (unsigned __int64)(48 * v321) )
              *(_QWORD *)(v324 + 4096) = &v325[48 * v321];
            else
              v325 = (char *)malloc(48 * v321);
          }
          else
          {
            v325 = 0;
          }
          v628 = &v325[48 * v320];
          *v628 = 22;
          v629 = &v325[48 * v321];
          v628[11] = BYTE2(v672[1]);
          *(_WORD *)(v628 + 9) = v672[1];
          v628[12] = 0;
          *(_QWORD *)(v628 + 1) = v672[0];
          v628[15] = 0;
          *((_QWORD *)v628 + 2) = 0;
          *(_WORD *)(v628 + 13) = 0;
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          BYTE2(v672[1]) = 0;
          v628[24] = 0;
          *((_QWORD *)v628 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v628 + 5) = 0;
          *(_QWORD *)(v628 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v631 = *(void ***)a3;
          v630 = *(void ***)(a3 + 8);
          v632 = v628 + 48;
          if ( v630 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v628 - 4) = *(v630 - 4);
              *((_OWORD *)v628 - 3) = *((_OWORD *)v630 - 3);
              v633 = (__int64)*(v630 - 1);
              *(v630 - 5) = 0;
              *(v630 - 4) = 0;
              *(v630 - 6) = 0;
              *((_QWORD *)v628 - 1) = v633;
              *(_OWORD *)(v628 - 24) = *(_OWORD *)(v630 - 3);
              *(v630 - 3) = 0;
              *(v630 - 2) = 0;
              *(v630 - 1) = 0;
              v630 -= 6;
              v628 -= 48;
            }
            while ( v631 != v630 );
            v350 = *(void ***)a3;
            v631 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v628;
          *(_QWORD *)(a3 + 8) = v632;
          *(_QWORD *)(a3 + 16) = v629;
          if ( v631 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v631 - 3) & 1) != 0 )
                free(*(v631 - 1));
              v634 = v631 - 6;
              if ( (*(_BYTE *)(v631 - 6) & 1) != 0 )
                free(*(v631 - 4));
              v631 -= 6;
            }
            while ( v350 != v634 );
          }
          goto LABEL_1062;
        case 'p':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator++", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v282 = *(_QWORD *)(a3 + 16);
          if ( v5 < v282 )
            goto LABEL_375;
          v332 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v333 = 0x555555555555555LL;
          if ( v332 + 1 > 0x555555555555555LL )
            abort();
          v334 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v282 - *(_QWORD *)a3) >> 4);
          if ( v334 >= 0x2AAAAAAAAAAAAAALL
            || ((v335 = 2 * v334, v335 >= v332 + 1) ? (v333 = v335) : (v333 = v332 + 1), v333) )
          {
            v336 = *(_QWORD *)(a3 + 24);
            v337 = *(char **)(v336 + 4096);
            if ( v336 + 4096 - (__int64)v337 >= (unsigned __int64)(48 * v333) )
              *(_QWORD *)(v336 + 4096) = &v337[48 * v333];
            else
              v337 = (char *)malloc(48 * v333);
          }
          else
          {
            v337 = 0;
          }
          v656 = &v337[48 * v332];
          *v656 = 20;
          v657 = &v337[48 * v333];
          *(_WORD *)(v656 + 9) = v672[1];
          v656[11] = 0;
          *((_DWORD *)v656 + 3) = 0;
          *((_QWORD *)v656 + 2) = 0;
          *(_QWORD *)(v656 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v656[24] = 0;
          *((_QWORD *)v656 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v656 + 5) = 0;
          *(_QWORD *)(v656 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v659 = *(void ***)a3;
          v658 = *(void ***)(a3 + 8);
          v660 = v656 + 48;
          if ( v658 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v656 - 4) = *(v658 - 4);
              *((_OWORD *)v656 - 3) = *((_OWORD *)v658 - 3);
              v661 = (__int64)*(v658 - 1);
              *(v658 - 5) = 0;
              *(v658 - 4) = 0;
              *(v658 - 6) = 0;
              *((_QWORD *)v656 - 1) = v661;
              *(_OWORD *)(v656 - 24) = *(_OWORD *)(v658 - 3);
              *(v658 - 3) = 0;
              *(v658 - 2) = 0;
              *(v658 - 1) = 0;
              v658 -= 6;
              v656 -= 48;
            }
            while ( v659 != v658 );
            v350 = *(void ***)a3;
            v659 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v656;
          *(_QWORD *)(a3 + 8) = v660;
          *(_QWORD *)(a3 + 16) = v657;
          if ( v659 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v659 - 3) & 1) != 0 )
                free(*(v659 - 1));
              v662 = v659 - 6;
              if ( (*(_BYTE *)(v659 - 6) & 1) != 0 )
                free(*(v659 - 4));
              v659 -= 6;
            }
            while ( v350 != v662 );
          }
          goto LABEL_1062;
        case 's':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator+", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v283 = *(_QWORD *)(a3 + 16);
          if ( v5 < v283 )
            goto LABEL_378;
          v338 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v339 = 0x555555555555555LL;
          if ( v338 + 1 > 0x555555555555555LL )
            abort();
          v340 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v283 - *(_QWORD *)a3) >> 4);
          if ( v340 >= 0x2AAAAAAAAAAAAAALL
            || ((v341 = 2 * v340, v341 >= v338 + 1) ? (v339 = v341) : (v339 = v338 + 1), v339) )
          {
            v342 = *(_QWORD *)(a3 + 24);
            v343 = *(char **)(v342 + 4096);
            if ( v342 + 4096 - (__int64)v343 >= (unsigned __int64)(48 * v339) )
              *(_QWORD *)(v342 + 4096) = &v343[48 * v339];
            else
              v343 = (char *)malloc(48 * v339);
          }
          else
          {
            v343 = 0;
          }
          v663 = &v343[48 * v338];
          *v663 = 18;
          v664 = &v343[48 * v339];
          v663[9] = v672[1];
          v663[10] = 0;
          *(_QWORD *)(v663 + 1) = v672[0];
          v663[15] = 0;
          *((_QWORD *)v663 + 2) = 0;
          *(_DWORD *)(v663 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v663[24] = 0;
          *((_QWORD *)v663 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v663 + 5) = 0;
          *(_QWORD *)(v663 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v666 = *(void ***)a3;
          v665 = *(void ***)(a3 + 8);
          v667 = v663 + 48;
          if ( v665 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v663 - 4) = *(v665 - 4);
              *((_OWORD *)v663 - 3) = *((_OWORD *)v665 - 3);
              v668 = (__int64)*(v665 - 1);
              *(v665 - 5) = 0;
              *(v665 - 4) = 0;
              *(v665 - 6) = 0;
              *((_QWORD *)v663 - 1) = v668;
              *(_OWORD *)(v663 - 24) = *(_OWORD *)(v665 - 3);
              *(v665 - 3) = 0;
              *(v665 - 2) = 0;
              *(v665 - 1) = 0;
              v665 -= 6;
              v663 -= 48;
            }
            while ( v666 != v665 );
            v350 = *(void ***)a3;
            v666 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v663;
          *(_QWORD *)(a3 + 8) = v667;
          *(_QWORD *)(a3 + 16) = v664;
          if ( v666 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v666 - 3) & 1) != 0 )
                free(*(v666 - 1));
              v669 = v666 - 6;
              if ( (*(_BYTE *)(v666 - 6) & 1) != 0 )
                free(*(v666 - 4));
              v666 -= 6;
            }
            while ( v350 != v669 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator->", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v274 = *(_QWORD *)(a3 + 16);
          if ( v5 < v274 )
            goto LABEL_375;
          v326 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v327 = 0x555555555555555LL;
          if ( v326 + 1 > 0x555555555555555LL )
            abort();
          v328 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v274 - *(_QWORD *)a3) >> 4);
          if ( v328 >= 0x2AAAAAAAAAAAAAALL
            || ((v329 = 2 * v328, v329 >= v326 + 1) ? (v327 = v329) : (v327 = v326 + 1), v327) )
          {
            v330 = *(_QWORD *)(a3 + 24);
            v331 = *(char **)(v330 + 4096);
            if ( v330 + 4096 - (__int64)v331 >= (unsigned __int64)(48 * v327) )
              *(_QWORD *)(v330 + 4096) = &v331[48 * v327];
            else
              v331 = (char *)malloc(48 * v327);
          }
          else
          {
            v331 = 0;
          }
          v635 = &v331[48 * v326];
          *v635 = 20;
          v636 = &v331[48 * v327];
          *(_WORD *)(v635 + 9) = v672[1];
          v635[11] = 0;
          *((_DWORD *)v635 + 3) = 0;
          *((_QWORD *)v635 + 2) = 0;
          *(_QWORD *)(v635 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v635[24] = 0;
          *((_QWORD *)v635 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v635 + 5) = 0;
          *(_QWORD *)(v635 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v638 = *(void ***)a3;
          v637 = *(void ***)(a3 + 8);
          v639 = v635 + 48;
          if ( v637 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v635 - 4) = *(v637 - 4);
              *((_OWORD *)v635 - 3) = *((_OWORD *)v637 - 3);
              v640 = (__int64)*(v637 - 1);
              *(v637 - 5) = 0;
              *(v637 - 4) = 0;
              *(v637 - 6) = 0;
              *((_QWORD *)v635 - 1) = v640;
              *(_OWORD *)(v635 - 24) = *(_OWORD *)(v637 - 3);
              *(v637 - 3) = 0;
              *(v637 - 2) = 0;
              *(v637 - 1) = 0;
              v637 -= 6;
              v635 -= 48;
            }
            while ( v638 != v637 );
            v350 = *(void ***)a3;
            v638 = *(void ***)(a3 + 8);
          }
          v351 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v635;
          *(_QWORD *)(a3 + 8) = v639;
          *(_QWORD *)(a3 + 16) = v636;
          if ( v638 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v638 - 3) & 1) != 0 )
                free(*(v638 - 1));
              v641 = v638 - 6;
              if ( (*(_BYTE *)(v638 - 6) & 1) != 0 )
                free(*(v638 - 4));
              v638 -= 6;
            }
            while ( v350 != v641 );
          }
          goto LABEL_1062;
        default:
          return v3;
      }
      return v3;
    case 'q':
      if ( a1[1] != 117 )
        return v3;
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      qmemcpy(v672, "operator?", 9);
      v5 = *(_QWORD *)(a3 + 8);
      v48 = *(_QWORD *)(a3 + 16);
      if ( v5 < v48 )
        goto LABEL_378;
      v49 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
      v50 = 0x555555555555555LL;
      if ( v49 + 1 > 0x555555555555555LL )
        abort();
      v51 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v48 - *(_QWORD *)a3) >> 4);
      if ( v51 >= 0x2AAAAAAAAAAAAAALL || ((v52 = 2 * v51, v52 >= v49 + 1) ? (v50 = v52) : (v50 = v49 + 1), v50) )
      {
        v53 = *(_QWORD *)(a3 + 24);
        v54 = *(char **)(v53 + 4096);
        if ( v53 + 4096 - (__int64)v54 >= (unsigned __int64)(48 * v50) )
          *(_QWORD *)(v53 + 4096) = &v54[48 * v50];
        else
          v54 = (char *)malloc(48 * v50);
      }
      else
      {
        v54 = 0;
      }
      v353 = &v54[48 * v49];
      *v353 = 18;
      v354 = &v54[48 * v50];
      v353[9] = v672[1];
      v353[10] = 0;
      *(_QWORD *)(v353 + 1) = v672[0];
      v353[15] = 0;
      *((_QWORD *)v353 + 2) = 0;
      *(_DWORD *)(v353 + 11) = 0;
      LOBYTE(v672[1]) = 0;
      v672[0] = 0;
      v353[24] = 0;
      *((_QWORD *)v353 + 4) = *(_QWORD *)((char *)v673 + 7);
      *((_QWORD *)v353 + 5) = 0;
      *(_QWORD *)(v353 + 25) = v673[0];
      *(_QWORD *)((char *)v673 + 7) = 0;
      v673[0] = 0;
      v356 = *(void ***)a3;
      v355 = *(void ***)(a3 + 8);
      v357 = v353 + 48;
      if ( v355 == *(void ***)a3 )
      {
        v350 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v353 - 4) = *(v355 - 4);
          *((_OWORD *)v353 - 3) = *((_OWORD *)v355 - 3);
          v358 = (__int64)*(v355 - 1);
          *(v355 - 5) = 0;
          *(v355 - 4) = 0;
          *(v355 - 6) = 0;
          *((_QWORD *)v353 - 1) = v358;
          *(_OWORD *)(v353 - 24) = *(_OWORD *)(v355 - 3);
          *(v355 - 3) = 0;
          *(v355 - 2) = 0;
          *(v355 - 1) = 0;
          v355 -= 6;
          v353 -= 48;
        }
        while ( v356 != v355 );
        v350 = *(void ***)a3;
        v356 = *(void ***)(a3 + 8);
      }
      v359 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v353;
      *(_QWORD *)(a3 + 8) = v357;
      *(_QWORD *)(a3 + 16) = v354;
      if ( v356 != v350 )
      {
        do
        {
          if ( (*(_BYTE *)(v356 - 3) & 1) != 0 )
            free(*(v356 - 1));
          v360 = v356 - 6;
          if ( (*(_BYTE *)(v356 - 6) & 1) != 0 )
            free(*(v356 - 4));
          v356 -= 6;
        }
        while ( v350 != v360 );
      }
LABEL_698:
      if ( !v350 )
        goto LABEL_1068;
      v459 = *(_QWORD *)(a3 + 24);
      if ( v459 + 4096 < (unsigned __int64)v350 || v459 > (unsigned __int64)v350 )
        goto LABEL_1067;
      if ( *(_QWORD *)(v459 + 4096) != v359 )
        goto LABEL_1068;
      *(_QWORD *)(v459 + 4096) = v350;
      v3 += 2;
      return v3;
    case 'r':
      switch ( a1[1] )
      {
        case 'M':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator%=", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v34 = *(_QWORD *)(a3 + 16);
          if ( v5 < v34 )
            goto LABEL_375;
          v35 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v36 = 0x555555555555555LL;
          if ( v35 + 1 > 0x555555555555555LL )
            abort();
          v37 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v34 - *(_QWORD *)a3) >> 4);
          if ( v37 >= 0x2AAAAAAAAAAAAAALL || ((v38 = 2 * v37, v38 >= v35 + 1) ? (v36 = v38) : (v36 = v35 + 1), v36) )
          {
            v39 = *(_QWORD *)(a3 + 24);
            v40 = *(char **)(v39 + 4096);
            if ( v39 + 4096 - (__int64)v40 >= (unsigned __int64)(48 * v36) )
              *(_QWORD *)(v39 + 4096) = &v40[48 * v36];
            else
              v40 = (char *)malloc(48 * v36);
          }
          else
          {
            v40 = 0;
          }
          v431 = &v40[48 * v35];
          *v431 = 20;
          v432 = &v40[48 * v36];
          *(_WORD *)(v431 + 9) = v672[1];
          v431[11] = 0;
          *((_DWORD *)v431 + 3) = 0;
          *((_QWORD *)v431 + 2) = 0;
          *(_QWORD *)(v431 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v431[24] = 0;
          *((_QWORD *)v431 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v431 + 5) = 0;
          *(_QWORD *)(v431 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v434 = *(void ***)a3;
          v433 = *(void ***)(a3 + 8);
          v435 = v431 + 48;
          if ( v433 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v431 - 4) = *(v433 - 4);
              *((_OWORD *)v431 - 3) = *((_OWORD *)v433 - 3);
              v436 = (__int64)*(v433 - 1);
              *(v433 - 5) = 0;
              *(v433 - 4) = 0;
              *(v433 - 6) = 0;
              *((_QWORD *)v431 - 1) = v436;
              *(_OWORD *)(v431 - 24) = *(_OWORD *)(v433 - 3);
              *(v433 - 3) = 0;
              *(v433 - 2) = 0;
              *(v433 - 1) = 0;
              v433 -= 6;
              v431 -= 48;
            }
            while ( v434 != v433 );
            v350 = *(void ***)a3;
            v434 = *(void ***)(a3 + 8);
          }
          v359 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v431;
          *(_QWORD *)(a3 + 8) = v435;
          *(_QWORD *)(a3 + 16) = v432;
          if ( v434 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v434 - 3) & 1) != 0 )
                free(*(v434 - 1));
              v437 = v434 - 6;
              if ( (*(_BYTE *)(v434 - 6) & 1) != 0 )
                free(*(v434 - 4));
              v434 -= 6;
            }
            while ( v350 != v437 );
          }
          goto LABEL_698;
        case 'S':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator>>=", 11);
          v5 = *(_QWORD *)(a3 + 8);
          v136 = *(_QWORD *)(a3 + 16);
          if ( v5 < v136 )
          {
LABEL_183:
            *(_BYTE *)v5 = 22;
            v3 = a1 + 2;
            *(_BYTE *)(v5 + 11) = BYTE2(v672[1]);
            *(_WORD *)(v5 + 9) = v672[1];
            *(_BYTE *)(v5 + 12) = 0;
            *(_QWORD *)(v5 + 1) = v672[0];
            *(_BYTE *)(v5 + 15) = 0;
            *(_QWORD *)(v5 + 16) = 0;
            *(_WORD *)(v5 + 13) = 0;
            LOWORD(v672[1]) = 0;
            v672[0] = 0;
            BYTE2(v672[1]) = 0;
            goto LABEL_379;
          }
          v290 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v291 = 0x555555555555555LL;
          if ( v290 + 1 > 0x555555555555555LL )
            abort();
          v292 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v136 - *(_QWORD *)a3) >> 4);
          if ( v292 >= 0x2AAAAAAAAAAAAAALL
            || ((v293 = 2 * v292, v293 >= v290 + 1) ? (v291 = v293) : (v291 = v290 + 1), v291) )
          {
            v294 = *(_QWORD *)(a3 + 24);
            v295 = *(char **)(v294 + 4096);
            if ( v294 + 4096 - (__int64)v295 >= (unsigned __int64)(48 * v291) )
              *(_QWORD *)(v294 + 4096) = &v295[48 * v291];
            else
              v295 = (char *)malloc(48 * v291);
          }
          else
          {
            v295 = 0;
          }
          v438 = &v295[48 * v290];
          *v438 = 22;
          v439 = &v295[48 * v291];
          v438[11] = BYTE2(v672[1]);
          *(_WORD *)(v438 + 9) = v672[1];
          v438[12] = 0;
          *(_QWORD *)(v438 + 1) = v672[0];
          v438[15] = 0;
          *((_QWORD *)v438 + 2) = 0;
          *(_WORD *)(v438 + 13) = 0;
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          BYTE2(v672[1]) = 0;
          v438[24] = 0;
          *((_QWORD *)v438 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v438 + 5) = 0;
          *(_QWORD *)(v438 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v441 = *(void ***)a3;
          v440 = *(void ***)(a3 + 8);
          v442 = v438 + 48;
          if ( v440 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v438 - 4) = *(v440 - 4);
              *((_OWORD *)v438 - 3) = *((_OWORD *)v440 - 3);
              v443 = (__int64)*(v440 - 1);
              *(v440 - 5) = 0;
              *(v440 - 4) = 0;
              *(v440 - 6) = 0;
              *((_QWORD *)v438 - 1) = v443;
              *(_OWORD *)(v438 - 24) = *(_OWORD *)(v440 - 3);
              *(v440 - 3) = 0;
              *(v440 - 2) = 0;
              *(v440 - 1) = 0;
              v440 -= 6;
              v438 -= 48;
            }
            while ( v441 != v440 );
            v350 = *(void ***)a3;
            v441 = *(void ***)(a3 + 8);
          }
          v359 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v438;
          *(_QWORD *)(a3 + 8) = v442;
          *(_QWORD *)(a3 + 16) = v439;
          if ( v441 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v441 - 3) & 1) != 0 )
                free(*(v441 - 1));
              v444 = v441 - 6;
              if ( (*(_BYTE *)(v441 - 6) & 1) != 0 )
                free(*(v441 - 4));
              v441 -= 6;
            }
            while ( v350 != v444 );
          }
          break;
        case 'm':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator%", 9);
          v5 = *(_QWORD *)(a3 + 8);
          v135 = *(_QWORD *)(a3 + 16);
          if ( v5 < v135 )
            goto LABEL_378;
          v284 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v285 = 0x555555555555555LL;
          if ( v284 + 1 > 0x555555555555555LL )
            abort();
          v286 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v135 - *(_QWORD *)a3) >> 4);
          if ( v286 >= 0x2AAAAAAAAAAAAAALL
            || ((v287 = 2 * v286, v287 >= v284 + 1) ? (v285 = v287) : (v285 = v284 + 1), v285) )
          {
            v288 = *(_QWORD *)(a3 + 24);
            v289 = *(char **)(v288 + 4096);
            if ( v288 + 4096 - (__int64)v289 >= (unsigned __int64)(48 * v285) )
              *(_QWORD *)(v288 + 4096) = &v289[48 * v285];
            else
              v289 = (char *)malloc(48 * v285);
          }
          else
          {
            v289 = 0;
          }
          v424 = &v289[48 * v284];
          *v424 = 18;
          v425 = &v289[48 * v285];
          v424[9] = v672[1];
          v424[10] = 0;
          *(_QWORD *)(v424 + 1) = v672[0];
          v424[15] = 0;
          *((_QWORD *)v424 + 2) = 0;
          *(_DWORD *)(v424 + 11) = 0;
          LOBYTE(v672[1]) = 0;
          v672[0] = 0;
          v424[24] = 0;
          *((_QWORD *)v424 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v424 + 5) = 0;
          *(_QWORD *)(v424 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v427 = *(void ***)a3;
          v426 = *(void ***)(a3 + 8);
          v428 = v424 + 48;
          if ( v426 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v424 - 4) = *(v426 - 4);
              *((_OWORD *)v424 - 3) = *((_OWORD *)v426 - 3);
              v429 = (__int64)*(v426 - 1);
              *(v426 - 5) = 0;
              *(v426 - 4) = 0;
              *(v426 - 6) = 0;
              *((_QWORD *)v424 - 1) = v429;
              *(_OWORD *)(v424 - 24) = *(_OWORD *)(v426 - 3);
              *(v426 - 3) = 0;
              *(v426 - 2) = 0;
              *(v426 - 1) = 0;
              v426 -= 6;
              v424 -= 48;
            }
            while ( v427 != v426 );
            v350 = *(void ***)a3;
            v427 = *(void ***)(a3 + 8);
          }
          v359 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v424;
          *(_QWORD *)(a3 + 8) = v428;
          *(_QWORD *)(a3 + 16) = v425;
          if ( v427 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v427 - 3) & 1) != 0 )
                free(*(v427 - 1));
              v430 = v427 - 6;
              if ( (*(_BYTE *)(v427 - 6) & 1) != 0 )
                free(*(v427 - 4));
              v427 -= 6;
            }
            while ( v350 != v430 );
          }
          goto LABEL_698;
        case 's':
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          qmemcpy(v672, "operator>>", 10);
          v5 = *(_QWORD *)(a3 + 8);
          v144 = *(_QWORD *)(a3 + 16);
          if ( v5 < v144 )
            goto LABEL_375;
          v145 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v146 = 0x555555555555555LL;
          if ( v145 + 1 > 0x555555555555555LL )
            abort();
          v147 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v144 - *(_QWORD *)a3) >> 4);
          if ( v147 >= 0x2AAAAAAAAAAAAAALL
            || ((v148 = 2 * v147, v148 >= v145 + 1) ? (v146 = v148) : (v146 = v145 + 1), v146) )
          {
            v149 = *(_QWORD *)(a3 + 24);
            v150 = *(char **)(v149 + 4096);
            if ( v149 + 4096 - (__int64)v150 >= (unsigned __int64)(48 * v146) )
              *(_QWORD *)(v149 + 4096) = &v150[48 * v146];
            else
              v150 = (char *)malloc(48 * v146);
          }
          else
          {
            v150 = 0;
          }
          v452 = &v150[48 * v145];
          *v452 = 20;
          v453 = &v150[48 * v146];
          *(_WORD *)(v452 + 9) = v672[1];
          v452[11] = 0;
          *((_DWORD *)v452 + 3) = 0;
          *((_QWORD *)v452 + 2) = 0;
          *(_QWORD *)(v452 + 1) = v672[0];
          LOWORD(v672[1]) = 0;
          v672[0] = 0;
          v452[24] = 0;
          *((_QWORD *)v452 + 4) = *(_QWORD *)((char *)v673 + 7);
          *((_QWORD *)v452 + 5) = 0;
          *(_QWORD *)(v452 + 25) = v673[0];
          *(_QWORD *)((char *)v673 + 7) = 0;
          v673[0] = 0;
          v455 = *(void ***)a3;
          v454 = *(void ***)(a3 + 8);
          v456 = v452 + 48;
          if ( v454 == *(void ***)a3 )
          {
            v350 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v452 - 4) = *(v454 - 4);
              *((_OWORD *)v452 - 3) = *((_OWORD *)v454 - 3);
              v457 = (__int64)*(v454 - 1);
              *(v454 - 5) = 0;
              *(v454 - 4) = 0;
              *(v454 - 6) = 0;
              *((_QWORD *)v452 - 1) = v457;
              *(_OWORD *)(v452 - 24) = *(_OWORD *)(v454 - 3);
              *(v454 - 3) = 0;
              *(v454 - 2) = 0;
              *(v454 - 1) = 0;
              v454 -= 6;
              v452 -= 48;
            }
            while ( v455 != v454 );
            v350 = *(void ***)a3;
            v455 = *(void ***)(a3 + 8);
          }
          v359 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v452;
          *(_QWORD *)(a3 + 8) = v456;
          *(_QWORD *)(a3 + 16) = v453;
          if ( v455 != v350 )
          {
            do
            {
              if ( (*(_BYTE *)(v455 - 3) & 1) != 0 )
                free(*(v455 - 1));
              v458 = v455 - 6;
              if ( (*(_BYTE *)(v455 - 6) & 1) != 0 )
                free(*(v455 - 4));
              v455 -= 6;
            }
            while ( v350 != v458 );
          }
          goto LABEL_698;
        default:
          return v3;
      }
      goto LABEL_698;
    case 'v':
      if ( (unsigned int)(unsigned __int8)a1[1] - 48 > 9 )
        return v3;
      v13 = a1 + 2;
      v14 = sub_57438(a1 + 2, a2, (void **)a3);
      if ( v14 == v13 )
        return v3;
      v15 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 == v15 )
        return v3;
      v16 = (size_t *)(v15 - 48);
      v17 = "operator ";
      v18 = 9;
LABEL_226:
      sub_429F4(v16, 0, v17, v18);
      return v14;
    default:
      return v3;
  }
}
// 38008: using guessed type __int64 __fastcall sub_38008(_QWORD, _QWORD, _QWORD);

//----- (0000000000057438) ----------------------------------------------------
unsigned __int8 *__fastcall sub_57438(unsigned __int8 *a1, unsigned __int8 *a2, void **a3)
{
  unsigned __int8 *v3; // x22
  __int64 v5; // x8
  size_t v6; // x19
  unsigned __int8 *v7; // x20
  int v8; // w8
  unsigned __int8 *v9; // x9
  int v10; // t1
  char *v11; // x23
  char *v12; // x22
  unsigned __int64 v13; // x8
  size_t v14; // x22
  char v15; // w22
  unsigned __int64 v16; // x8
  _BOOL4 v17; // w23
  char *v18; // x8
  char *v19; // x9
  __int64 v20; // x9
  char *v21; // x0
  void *v22; // x22
  char v23; // w23
  __int64 v24; // x8
  __int64 v25; // x9
  char *v26; // x8
  char *v27; // x9
  unsigned __int64 v28; // x23
  __int64 v29; // x22
  unsigned __int64 v30; // x9
  unsigned __int64 v31; // x9
  _QWORD *v32; // x9
  char *v33; // x0
  unsigned __int64 v34; // x26
  __int64 v35; // x24
  unsigned __int64 v36; // x9
  unsigned __int64 v37; // x9
  _QWORD *v38; // x9
  char *v39; // x0
  char *v40; // x8
  __int64 v41; // x10
  char *v42; // x9
  void **v43; // x11
  void **v44; // x23
  char *v45; // x10
  __int64 v46; // x12
  void **v47; // x22
  void *v48; // x24
  void **v49; // x26
  unsigned __int64 v50; // x8
  char *v51; // x8
  char *v52; // x9
  void **v53; // x11
  void **v54; // x23
  char *v55; // x10
  __int64 v56; // x12
  void **v57; // x22
  void *v58; // x24
  void **v59; // x26
  unsigned __int64 v60; // x8
  __int128 v62; // [xsp+8h] [xbp-98h] BYREF
  void *v63; // [xsp+18h] [xbp-88h]
  _BYTE v64[15]; // [xsp+20h] [xbp-80h] BYREF
  _QWORD v65[2]; // [xsp+30h] [xbp-70h] BYREF
  __int128 v66; // [xsp+40h] [xbp-60h] BYREF
  void *p; // [xsp+50h] [xbp-50h]
  __int64 v68; // [xsp+58h] [xbp-48h]

  v3 = a1;
  v68 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 == a2 )
    return v3;
  v5 = *a1;
  v6 = v5 - 48;
  if ( (unsigned int)(v5 - 48) > 9 )
    return v3;
  v7 = a1 + 1;
  if ( a1 + 1 == a2 )
    return v3;
  v8 = *v7 - 48;
  if ( (unsigned int)v8 > 9 )
  {
LABEL_9:
    if ( a2 - v7 < v6 )
      return v3;
    v62 = 0u;
    v63 = 0;
    if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    if ( v6 >= 0x17 )
    {
      v12 = (char *)malloc((v6 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v62 + 1) = v6;
      v63 = v12;
      *(_QWORD *)&v62 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      v11 = (char *)&v62 + 1;
    }
    else
    {
      v11 = (char *)&v62 + 1;
      v12 = (char *)&v62 + 1;
      LOBYTE(v62) = 2 * v6;
      if ( !v6 )
      {
LABEL_16:
        v12[v6] = 0;
        v13 = *((_QWORD *)&v62 + 1);
        v66 = 0u;
        p = 0;
        if ( (v62 & 1) != 0 )
          v11 = (char *)v63;
        else
          v13 = (unsigned __int64)(unsigned __int8)v62 >> 1;
        if ( v13 >= 0xA )
          v14 = 10;
        else
          v14 = v13;
        LOBYTE(v66) = 2 * v14;
        if ( v14 )
          memcpy((char *)&v66 + 1, v11, v14);
        *((_BYTE *)&v66 + v14 + 1) = 0;
        v15 = v66;
        v16 = *((_QWORD *)&v66 + 1);
        v17 = 0;
        if ( (v66 & 1) == 0 )
          v16 = (unsigned __int64)(unsigned __int8)v66 >> 1;
        if ( v16 == 10 )
        {
          if ( (v66 & 1) != 0 )
            v21 = (char *)p;
          else
            v21 = (char *)&v66 + 1;
          v17 = memcmp(v21, "_GLOBAL__N", 0xAu) == 0;
          if ( (v15 & 1) == 0 )
          {
LABEL_28:
            if ( v17 )
            {
LABEL_29:
              memset(v65, 0, 15);
              qmemcpy(&v66, "(anonymous name", 15);
              v18 = (char *)a3[1];
              v19 = (char *)a3[2];
              if ( v18 >= v19 )
              {
                v28 = 0xAAAAAAAAAAAAAAABLL * ((v18 - (_BYTE *)*a3) >> 4);
                v29 = 0x555555555555555LL;
                if ( v28 + 1 > 0x555555555555555LL )
                  abort();
                v30 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (_BYTE *)*a3) >> 4);
                if ( v30 >= 0x2AAAAAAAAAAAAAALL
                  || ((v31 = 2 * v30, v31 >= v28 + 1) ? (v29 = v31) : (v29 = v28 + 1), v29) )
                {
                  v32 = a3[3];
                  v33 = (char *)v32[512];
                  if ( (char *)(v32 + 512) - v33 >= (unsigned __int64)(48 * v29) )
                    v32[512] = &v33[48 * v29];
                  else
                    v33 = (char *)malloc(48 * v29);
                }
                else
                {
                  v33 = 0;
                }
                v40 = &v33[48 * v28];
                *v40 = 42;
                *((_QWORD *)v40 + 1) = *(_QWORD *)((char *)&v66 + 7);
                v41 = v66;
                *((_QWORD *)v40 + 2) = 0x296563617073LL;
                v42 = &v33[48 * v29];
                *(_QWORD *)(v40 + 1) = v41;
                *(_QWORD *)((char *)&v66 + 7) = 0;
                *(_QWORD *)&v66 = 0;
                v40[24] = 0;
                *((_QWORD *)v40 + 4) = *(_QWORD *)((char *)v65 + 7);
                *((_QWORD *)v40 + 5) = 0;
                *(_QWORD *)(v40 + 25) = v65[0];
                memset(v65, 0, 15);
                v44 = (void **)*a3;
                v43 = (void **)a3[1];
                v45 = v40 + 48;
                if ( v43 == *a3 )
                {
                  v47 = (void **)*a3;
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v40 - 4) = *(v43 - 4);
                    *((_OWORD *)v40 - 3) = *((_OWORD *)v43 - 3);
                    v46 = (__int64)*(v43 - 1);
                    *(v43 - 5) = 0;
                    *(v43 - 4) = 0;
                    *(v43 - 6) = 0;
                    *((_QWORD *)v40 - 1) = v46;
                    *(_OWORD *)(v40 - 24) = *(_OWORD *)(v43 - 3);
                    *(v43 - 3) = 0;
                    *(v43 - 2) = 0;
                    *(v43 - 1) = 0;
                    v43 -= 6;
                    v40 -= 48;
                  }
                  while ( v44 != v43 );
                  v47 = (void **)*a3;
                  v44 = (void **)a3[1];
                }
                v48 = a3[2];
                *a3 = v40;
                a3[1] = v45;
                a3[2] = v42;
                if ( v44 != v47 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v44 - 3) & 1) != 0 )
                      free(*(v44 - 1));
                    v49 = v44 - 6;
                    if ( (*(_BYTE *)(v44 - 6) & 1) != 0 )
                      free(*(v44 - 4));
                    v44 -= 6;
                  }
                  while ( v47 != v49 );
                }
                if ( v47 )
                {
                  v50 = (unsigned __int64)a3[3];
                  if ( v50 + 4096 < (unsigned __int64)v47 || v50 > (unsigned __int64)v47 )
                  {
                    free(v47);
                  }
                  else if ( *(void **)(v50 + 4096) == v48 )
                  {
                    *(_QWORD *)(v50 + 4096) = v47;
                  }
                }
              }
              else
              {
                *v18 = 42;
                *((_QWORD *)v18 + 1) = *(_QWORD *)((char *)&v66 + 7);
                v20 = v66;
                *((_QWORD *)v18 + 2) = 0x296563617073LL;
                *(_QWORD *)(v18 + 1) = v20;
                *(_QWORD *)((char *)&v66 + 7) = 0;
                *(_QWORD *)&v66 = 0;
                v18[24] = 0;
                *((_QWORD *)v18 + 4) = *(_QWORD *)((char *)v65 + 7);
                *((_QWORD *)v18 + 5) = 0;
                *(_QWORD *)(v18 + 25) = v65[0];
                memset(v65, 0, 15);
                a3[1] = (char *)a3[1] + 48;
              }
              v3 = &v7[v6];
              if ( (v62 & 1) != 0 )
                free(v63);
              return v3;
            }
LABEL_36:
            v22 = v63;
            v23 = v62;
            v63 = 0;
            *(_QWORD *)&v64[7] = *((_QWORD *)&v62 + 1);
            v64[7] = BYTE8(v62);
            v24 = *(_QWORD *)((char *)&v62 + 1);
            v25 = *(_QWORD *)&v64[7];
            v62 = 0u;
            memset(v65, 0, 15);
            memset(v64, 0, sizeof(v64));
            *(_QWORD *)&v66 = v24;
            *(_QWORD *)((char *)&v66 + 7) = v25;
            v26 = (char *)a3[1];
            v27 = (char *)a3[2];
            if ( v26 >= v27 )
            {
              v34 = 0xAAAAAAAAAAAAAAABLL * ((v26 - (_BYTE *)*a3) >> 4);
              v35 = 0x555555555555555LL;
              if ( v34 + 1 > 0x555555555555555LL )
                abort();
              v36 = 0xAAAAAAAAAAAAAAABLL * ((v27 - (_BYTE *)*a3) >> 4);
              if ( v36 >= 0x2AAAAAAAAAAAAAALL || ((v37 = 2 * v36, v37 >= v34 + 1) ? (v35 = v37) : (v35 = v34 + 1), v35) )
              {
                v38 = a3[3];
                v39 = (char *)v38[512];
                if ( (char *)(v38 + 512) - v39 >= (unsigned __int64)(48 * v35) )
                  v38[512] = &v39[48 * v35];
                else
                  v39 = (char *)malloc(48 * v35);
              }
              else
              {
                v39 = 0;
              }
              v51 = &v39[48 * v34];
              *v51 = v23;
              v52 = &v39[48 * v35];
              *((_QWORD *)v51 + 1) = *(_QWORD *)((char *)&v66 + 7);
              *((_QWORD *)v51 + 2) = v22;
              *(_QWORD *)(v51 + 1) = v66;
              *(_QWORD *)((char *)&v66 + 7) = 0;
              *(_QWORD *)&v66 = 0;
              v51[24] = 0;
              *((_QWORD *)v51 + 4) = *(_QWORD *)((char *)v65 + 7);
              *((_QWORD *)v51 + 5) = 0;
              *(_QWORD *)(v51 + 25) = v65[0];
              memset(v65, 0, 15);
              v54 = (void **)*a3;
              v53 = (void **)a3[1];
              v55 = v51 + 48;
              if ( v53 == *a3 )
              {
                v57 = (void **)*a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v51 - 4) = *(v53 - 4);
                  *((_OWORD *)v51 - 3) = *((_OWORD *)v53 - 3);
                  v56 = (__int64)*(v53 - 1);
                  *(v53 - 5) = 0;
                  *(v53 - 4) = 0;
                  *(v53 - 6) = 0;
                  *((_QWORD *)v51 - 1) = v56;
                  *(_OWORD *)(v51 - 24) = *(_OWORD *)(v53 - 3);
                  *(v53 - 3) = 0;
                  *(v53 - 2) = 0;
                  *(v53 - 1) = 0;
                  v53 -= 6;
                  v51 -= 48;
                }
                while ( v54 != v53 );
                v57 = (void **)*a3;
                v54 = (void **)a3[1];
              }
              v58 = a3[2];
              *a3 = v51;
              a3[1] = v55;
              a3[2] = v52;
              if ( v54 != v57 )
              {
                do
                {
                  if ( (*(_BYTE *)(v54 - 3) & 1) != 0 )
                    free(*(v54 - 1));
                  v59 = v54 - 6;
                  if ( (*(_BYTE *)(v54 - 6) & 1) != 0 )
                    free(*(v54 - 4));
                  v54 -= 6;
                }
                while ( v57 != v59 );
              }
              if ( v57 )
              {
                v60 = (unsigned __int64)a3[3];
                if ( v60 + 4096 < (unsigned __int64)v57 || v60 > (unsigned __int64)v57 )
                {
                  free(v57);
                }
                else if ( *(void **)(v60 + 4096) == v58 )
                {
                  *(_QWORD *)(v60 + 4096) = v57;
                }
              }
            }
            else
            {
              *v26 = v23;
              *((_QWORD *)v26 + 1) = *(_QWORD *)((char *)&v66 + 7);
              *((_QWORD *)v26 + 2) = v22;
              *(_QWORD *)(v26 + 1) = v66;
              *(_QWORD *)((char *)&v66 + 7) = 0;
              *(_QWORD *)&v66 = 0;
              v26[24] = 0;
              *((_QWORD *)v26 + 4) = *(_QWORD *)((char *)v65 + 7);
              *((_QWORD *)v26 + 5) = 0;
              *(_QWORD *)(v26 + 25) = v65[0];
              memset(v65, 0, 15);
              a3[1] = (char *)a3[1] + 48;
            }
            return &v7[v6];
          }
        }
        else if ( (v66 & 1) == 0 )
        {
          goto LABEL_28;
        }
        free(p);
        if ( v17 )
          goto LABEL_29;
        goto LABEL_36;
      }
    }
    memcpy(v12, v7, v6);
    goto LABEL_16;
  }
  v9 = a1 + 2;
  while ( a2 != v9 )
  {
    v10 = *v9++;
    v6 = 10 * v6 + v8;
    v8 = v10 - 48;
    if ( (unsigned int)(v10 - 48) >= 0xA )
    {
      v7 = v9 - 1;
      goto LABEL_9;
    }
  }
  return v3;
}
// 57574: conditional instruction was optimized away because x22.8<Bu
// 5757C: conditional instruction was optimized away because x22.8<Bu

//----- (0000000000057B54) ----------------------------------------------------
void __usercall sub_57B54(size_t *a1@<X0>, __int64 a2@<X8>)
{
  unsigned __int64 v3; // x9
  size_t v4; // x20
  size_t v6; // x23
  unsigned __int8 *v7; // x20
  const char *v8; // x8
  unsigned __int64 v9; // x22
  int v10; // w8
  int v11; // w9
  const void *v12; // x21
  void *v13; // x19
  __int64 v14; // x9
  __int64 v15; // x8
  void *v16; // x0
  unsigned __int64 v17; // x23
  unsigned __int8 *v18; // x24
  int v19; // w21
  int v20; // w0
  _BYTE *v21; // x19
  _BYTE *v22; // x0
  unsigned __int64 v23; // x10
  unsigned __int8 *v24; // x8
  _BYTE *v25; // x9
  char v26; // t1
  _OWORD *v27; // x12
  __int128 *v28; // x13
  unsigned __int64 v29; // x14
  __int128 v30; // q0
  __int128 v31; // q1

  v3 = *(unsigned __int8 *)a1;
  v4 = a1[1];
  if ( (v3 & 1) != 0 )
    v6 = a1[1];
  else
    v6 = v3 >> 1;
  switch ( v6 )
  {
    case 0uLL:
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      if ( (v3 & 1) == 0 )
      {
        *(_QWORD *)(a2 + 16) = a1[2];
        *(_OWORD *)a2 = *(_OWORD *)a1;
        return;
      }
      if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_73;
      v12 = (const void *)a1[2];
      if ( v4 >= 0x17 )
      {
        v16 = malloc((v4 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        *(_QWORD *)(a2 + 8) = v4;
        *(_QWORD *)(a2 + 16) = v16;
        *(_QWORD *)a2 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v13 = v16;
      }
      else
      {
        *(_BYTE *)a2 = 2 * v4;
        v13 = (void *)(a2 + 1);
        if ( !v4 )
          goto LABEL_44;
      }
      memcpy(v13, v12, v4);
LABEL_44:
      *((_BYTE *)v13 + v4) = 0;
      return;
    case 0xBuLL:
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)a1[2];
      else
        v7 = (unsigned __int8 *)a1 + 1;
      if ( memcmp(v7, "std::string", 0xBu) )
        goto LABEL_26;
      sub_47A3C(a1, "std::basic_string<char, std::char_traits<char>, std::allocator<char> >", 0x46u);
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 24;
      strcpy((char *)(a2 + 1), "basic_string");
      return;
    case 0xCuLL:
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)a1[2];
      else
        v7 = (unsigned __int8 *)a1 + 1;
      if ( !memcmp(v7, "std::istream", 0xCu) )
      {
        sub_47A3C(a1, "std::basic_istream<char, std::char_traits<char> >", 0x31u);
        v8 = "basic_istream";
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        goto LABEL_41;
      }
      if ( !memcmp(v7, "std::ostream", 0xCu) )
      {
        sub_47A3C(a1, "std::basic_ostream<char, std::char_traits<char> >", 0x31u);
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        v8 = "basic_ostream";
LABEL_41:
        v14 = *(_QWORD *)(v8 + 5);
        v15 = *(_QWORD *)v8;
        *(_BYTE *)a2 = 26;
        *(_QWORD *)(a2 + 6) = v14;
        *(_QWORD *)(a2 + 1) = v15;
        *(_BYTE *)(a2 + 14) = 0;
        return;
      }
LABEL_26:
      v9 = (unsigned __int64)&v7[v6];
      if ( v7[v6 - 1] != 62 )
        goto LABEL_45;
      if ( &v7[v6 - 1] == v7 )
      {
LABEL_46:
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        return;
      }
      v10 = 1;
      break;
    case 0xDuLL:
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)a1[2];
      else
        v7 = (unsigned __int8 *)a1 + 1;
      if ( memcmp(v7, "std::iostream", 0xDu) )
        goto LABEL_26;
      sub_47A3C(a1, "std::basic_iostream<char, std::char_traits<char> >", 0x32u);
      *(_QWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 28;
      strcpy((char *)(a2 + 1), "basic_iostream");
      return;
    default:
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)a1[2];
      else
        v7 = (unsigned __int8 *)a1 + 1;
      goto LABEL_26;
  }
  while ( 1 )
  {
    v11 = v7[v6 - 2];
    if ( v11 != 62 )
      break;
    ++v10;
LABEL_34:
    if ( --v6 == 1 )
      goto LABEL_46;
  }
  if ( v11 != 60 )
    goto LABEL_34;
  if ( --v10 )
    goto LABEL_34;
  v9 = (unsigned __int64)&v7[v6 - 2];
LABEL_45:
  v17 = v9 - (_QWORD)v7;
  if ( (__int64)(v9 - (_QWORD)v7) <= 1 )
    goto LABEL_46;
  v18 = (unsigned __int8 *)(v9 - 1);
  if ( (unsigned __int8 *)(v9 - 1) == v7 )
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    if ( v17 <= 0x16 )
      goto LABEL_59;
LABEL_61:
    v22 = malloc((v17 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *(_QWORD *)(a2 + 8) = v17;
    *(_QWORD *)(a2 + 16) = v22;
    *(_QWORD *)a2 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v21 = v22;
    if ( v7 == (unsigned __int8 *)v9 )
      goto LABEL_68;
LABEL_62:
    v23 = v9 - (_QWORD)v7;
    if ( v9 - (unsigned __int64)v7 >= 0x20 && ((unsigned __int64)v21 >= v9 || v7 >= &v21[v23]) )
    {
      v27 = v21 + 16;
      v24 = &v7[v23 & 0xFFFFFFFFFFFFFFE0LL];
      v25 = &v21[v23 & 0xFFFFFFFFFFFFFFE0LL];
      v28 = (__int128 *)(v7 + 16);
      v29 = v23 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v30 = *(v28 - 1);
        v31 = *v28;
        v29 -= 32LL;
        v28 += 2;
        *(v27 - 1) = v30;
        *v27 = v31;
        v27 += 2;
      }
      while ( v29 );
      if ( (v23 & 0xFFFFFFFFFFFFFFE0LL) == v23 )
        goto LABEL_67;
    }
    else
    {
      v24 = v7;
      v25 = v21;
    }
    do
    {
      v26 = *v24++;
      *v25++ = v26;
    }
    while ( (unsigned __int8 *)v9 != v24 );
LABEL_67:
    v21 += v17;
    goto LABEL_68;
  }
  while ( 1 )
  {
    v19 = *v18;
    if ( v19 == 58 )
      break;
    v20 = isalpha(v19);
    if ( v19 != 95 && (unsigned int)(v19 - 48) >= 0xA && !v20 )
      goto LABEL_46;
    if ( v7 == --v18 )
      goto LABEL_57;
  }
  v7 = v18 + 1;
  v17 = v9 - (_QWORD)(v18 + 1);
LABEL_57:
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_73:
    abort();
  if ( v17 > 0x16 )
    goto LABEL_61;
LABEL_59:
  *(_BYTE *)a2 = 2 * v17;
  v21 = (_BYTE *)(a2 + 1);
  if ( v7 != (unsigned __int8 *)v9 )
    goto LABEL_62;
LABEL_68:
  *v21 = 0;
}

//----- (0000000000057F64) ----------------------------------------------------
void __fastcall sub_57F64(size_t *a1, char a2)
{
  unsigned __int64 v3; // x8
  size_t v5; // x25
  size_t v6; // x21
  char *v7; // x23
  void *v8; // x22
  unsigned __int64 v9; // x8
  size_t v10; // x24
  char *v11; // x8

  v3 = *(unsigned __int8 *)a1;
  if ( (v3 & 1) != 0 )
  {
    v5 = a1[1];
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v5 != v6 )
      goto LABEL_3;
LABEL_6:
    if ( v6 == -17 )
      abort();
    if ( (v3 & 1) != 0 )
      v8 = (void *)a1[2];
    else
      v8 = (char *)a1 + 1;
    if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v10 = -17;
    }
    else
    {
      if ( v6 + 1 >= 2 * v6 )
        v9 = v6 + 1;
      else
        v9 = 2 * v6;
      if ( v9 >= 0x17 )
        v10 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v10 = 23;
    }
    v7 = (char *)malloc(v10);
    memcpy(v7, v8, v6);
    if ( v6 != 22 )
      free(v8);
    a1[2] = (size_t)v7;
    *a1 = v10 | 1;
    goto LABEL_22;
  }
  v5 = v3 >> 1;
  v6 = 22;
  if ( v3 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v3 & 1) != 0 )
  {
    v7 = (char *)a1[2];
LABEL_22:
    a1[1] = v5 + 1;
    goto LABEL_23;
  }
  *(_BYTE *)a1 = 2 * v5 + 2;
  v7 = (char *)a1 + 1;
LABEL_23:
  v11 = &v7[v5];
  *v11 = a2;
  v11[1] = 0;
}

//----- (000000000005808C) ----------------------------------------------------
__int64 __fastcall sub_5808C(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3, unsigned __int8 *a4)
{
  unsigned __int8 *v6; // x22
  unsigned __int64 v7; // x8
  unsigned __int8 *v9; // x25
  unsigned __int64 v10; // x28
  size_t v11; // x23
  unsigned __int8 *v12; // x9
  unsigned __int64 v13; // x10
  _BYTE *v14; // x0
  unsigned __int8 *v15; // x8
  _BYTE *v16; // x9
  unsigned __int64 v17; // x27
  unsigned __int64 v18; // x21
  __int64 v19; // x9
  unsigned __int8 *v20; // x8
  unsigned __int8 *v21; // x24
  _OWORD *v22; // x11
  __int128 *v23; // x12
  unsigned __int64 v24; // x13
  __int128 v25; // q0
  __int128 v26; // q1
  char v27; // t1
  char *v28; // x2
  unsigned __int64 v29; // x8
  __int64 v30; // x19
  __int64 v31; // x21
  unsigned __int64 v32; // x8
  unsigned __int64 v33; // x8
  size_t v34; // x26
  unsigned __int8 *v35; // x0
  unsigned __int8 *v36; // x8
  __int128 *v37; // x10
  unsigned __int8 *v38; // x11
  unsigned __int64 v39; // x12
  __int128 v40; // q0
  __int128 v41; // q1
  unsigned __int8 v42; // t1
  unsigned __int8 *v43; // x8
  unsigned __int8 *v45; // [xsp+10h] [xbp-80h]
  unsigned __int64 v47; // [xsp+20h] [xbp-70h] BYREF
  unsigned __int64 v48; // [xsp+28h] [xbp-68h]
  void *p; // [xsp+30h] [xbp-60h]
  __int64 v50; // [xsp+38h] [xbp-58h]

  v6 = (unsigned __int8 *)a3;
  v50 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  if ( (v7 & 1) != 0 )
    v9 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v9 = a1 + 1;
  v10 = (unsigned __int64)&a4[-a3];
  v11 = a2 - (_QWORD)v9;
  if ( a4 == (unsigned __int8 *)a3 )
  {
LABEL_68:
    if ( (*a1 & 1) != 0 )
      v43 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v43 = a1 + 1;
    return (__int64)&v43[v11];
  }
  if ( (v7 & 1) != 0 )
  {
    v13 = *((_QWORD *)a1 + 1);
    v12 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    if ( (unsigned __int64)v12 > a3 )
    {
LABEL_15:
      if ( (v7 & 1) != 0 )
      {
        v19 = *(_QWORD *)a1;
        v17 = *((_QWORD *)a1 + 1);
        v18 = (*(_QWORD *)a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
      }
      else
      {
        v17 = v7 >> 1;
        v18 = 22;
        LOBYTE(v19) = *a1;
      }
      if ( v18 - v17 >= v10 )
      {
        if ( (v7 & 1) != 0 )
          v21 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
        else
          v21 = a1 + 1;
        v31 = a2;
        if ( v17 != v11 )
        {
          memmove(&v21[v11 + v10], &v21[v11], v17 - v11);
          LOBYTE(v19) = *a1;
        }
        v32 = v17 + v10;
        if ( (v19 & 1) == 0 )
        {
          *a1 = 2 * v32;
LABEL_60:
          v21[v32] = 0;
          if ( v6 != a4 )
          {
            v36 = &v21[v11];
            if ( v10 < 0x20 || v36 < a4 && &a4[v31 - (_QWORD)v6 - (_QWORD)v9 + (_QWORD)v21] > v6 )
              goto LABEL_76;
            v37 = (__int128 *)(v6 + 16);
            v36 += v10 & 0xFFFFFFFFFFFFFFE0LL;
            v6 += v10 & 0xFFFFFFFFFFFFFFE0LL;
            v38 = &v21[v31 + 16 - (_QWORD)v9];
            v39 = v10 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v40 = *(v37 - 1);
              v41 = *v37;
              v37 += 2;
              v39 -= 32LL;
              *((_OWORD *)v38 - 1) = v40;
              *(_OWORD *)v38 = v41;
              v38 += 32;
            }
            while ( v39 );
            if ( v10 != (v10 & 0xFFFFFFFFFFFFFFE0LL) )
            {
LABEL_76:
              do
              {
                v42 = *v6++;
                *v36++ = v42;
              }
              while ( a4 != v6 );
            }
          }
          goto LABEL_68;
        }
LABEL_59:
        *((_QWORD *)a1 + 1) = v32;
        goto LABEL_60;
      }
      if ( -17LL - v18 >= v17 + v10 - v18 )
      {
        if ( (v7 & 1) != 0 )
          v20 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
        else
          v20 = a1 + 1;
        v45 = v20;
        if ( v18 > 0x7FFFFFFFFFFFFFE6LL )
        {
          v34 = -17;
        }
        else
        {
          v33 = 2 * v18;
          if ( v17 + v10 >= 2 * v18 )
            v33 = v17 + v10;
          if ( v33 >= 0x17 )
            v34 = (v33 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          else
            v34 = 23;
        }
        v35 = (unsigned __int8 *)malloc(v34);
        v21 = v35;
        if ( v11 )
          memcpy(v35, v45, v11);
        if ( v17 != v11 )
          memcpy(&v21[v11 + v10], &v45[v11], v17 - v11);
        if ( v18 != 22 )
          free(v45);
        v31 = a2;
        *((_QWORD *)a1 + 2) = v21;
        *(_QWORD *)a1 = v34 | 1;
        v32 = v17 + v10;
        goto LABEL_59;
      }
LABEL_73:
      abort();
    }
  }
  else
  {
    v12 = a1 + 1;
    v13 = v7 >> 1;
    if ( (unsigned __int64)(a1 + 1) > a3 )
      goto LABEL_15;
  }
  if ( (unsigned __int64)&v12[v13] <= a3 )
    goto LABEL_15;
  v47 = 0;
  v48 = 0;
  p = 0;
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_73;
  if ( v10 <= 0x16 )
  {
    LOBYTE(v47) = 2 * v10;
    v14 = (char *)&v47 + 1;
    if ( (unsigned __int8 *)a3 == a4 )
      goto LABEL_31;
LABEL_13:
    if ( v10 >= 0x20 )
    {
      v22 = v14 + 16;
      v15 = &v6[v10 & 0xFFFFFFFFFFFFFFE0LL];
      v16 = &v14[v10 & 0xFFFFFFFFFFFFFFE0LL];
      v23 = (__int128 *)(v6 + 16);
      v24 = v10 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v25 = *(v23 - 1);
        v26 = *v23;
        v24 -= 32LL;
        v23 += 2;
        *(v22 - 1) = v25;
        *v22 = v26;
        v22 += 2;
      }
      while ( v24 );
      if ( v10 == (v10 & 0xFFFFFFFFFFFFFFE0LL) )
        goto LABEL_30;
    }
    else
    {
      v15 = v6;
      v16 = v14;
    }
    do
    {
      v27 = *v15++;
      *v16++ = v27;
    }
    while ( a4 != v15 );
LABEL_30:
    v14 += v10;
    goto LABEL_31;
  }
  v14 = malloc((v10 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  v48 = a4 - v6;
  p = v14;
  v47 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( v6 != a4 )
    goto LABEL_13;
LABEL_31:
  *v14 = 0;
  if ( (v47 & 1) != 0 )
    v28 = (char *)p;
  else
    v28 = (char *)&v47 + 1;
  if ( (v47 & 1) != 0 )
    v29 = v48;
  else
    v29 = (unsigned __int64)(unsigned __int8)v47 >> 1;
  v30 = sub_5808C(a1, a2, v28, &v28[v29]);
  if ( (v47 & 1) != 0 )
    free(p);
  return v30;
}

//----- (0000000000058458) ----------------------------------------------------
unsigned __int8 *__fastcall sub_58458(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3)
{
  unsigned __int8 *v4; // x19
  int v6; // w8
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x0
  unsigned __int8 *v9; // x0
  int v10; // t1
  _BYTE *v11; // x22
  _BYTE *v12; // x0
  unsigned __int8 *v14; // x22

  v4 = a1;
  if ( a1 == a2 )
    return v4;
  v6 = *a1;
  switch ( v6 )
  {
    case 'J':
      v11 = a1 + 1;
      if ( a1 + 1 != a2 )
      {
        if ( *v11 == 69 )
        {
          v12 = a1 + 1;
          return v12 + 1;
        }
        else
        {
          while ( 1 )
          {
            v12 = (_BYTE *)sub_58458(v11, a2, a3);
            if ( v12 == v11 )
              break;
            v11 = v12;
            if ( *v12 == 69 )
              return v12 + 1;
          }
        }
      }
      return v4;
    case 'L':
      if ( a1 + 1 != a2 && a1[1] == 90 )
      {
        v14 = a1 + 2;
        v8 = (unsigned __int8 *)sub_36F74(a1 + 2, a2, a3);
        if ( v8 != v14 )
        {
LABEL_6:
          if ( v8 != a2 )
          {
            v10 = *v8;
            v9 = v8 + 1;
            if ( v10 == 69 )
              return v9;
          }
        }
        return v4;
      }
      return sub_4CCE0(a1, a2, a3);
    case 'X':
      v7 = a1 + 1;
      v8 = sub_47B84(a1 + 1, a2, (__int64)a3);
      if ( v8 != v7 )
        goto LABEL_6;
      return v4;
    default:
      return (unsigned __int8 *)sub_38008(a1, a2, a3);
  }
}
// 36F74: using guessed type __int64 __fastcall sub_36F74(_QWORD, _QWORD, _QWORD);
// 38008: using guessed type __int64 __fastcall sub_38008(_QWORD, _QWORD, _QWORD);

//----- (000000000005859C) ----------------------------------------------------
void __fastcall sub_5859C(__int64 a1)
{
  __int64 v2; // x21
  __int64 v3; // x22
  void **v4; // x23
  void **v5; // x20
  void *v6; // x0
  unsigned __int64 v7; // x8
  void *v8; // x0
  unsigned __int64 v9; // x8

  v2 = *(_QWORD *)(a1 + 8);
  while ( 1 )
  {
    v3 = *(_QWORD *)(a1 + 16);
    if ( v3 == v2 )
      break;
    *(_QWORD *)(a1 + 16) = v3 - 32;
    v4 = *(void ***)(v3 - 32);
    if ( v4 )
    {
      v5 = *(void ***)(v3 - 24);
      v6 = *(void **)(v3 - 32);
      if ( v5 != v4 )
      {
        do
        {
          v5 -= 4;
          sub_42F30(v5);
        }
        while ( v4 != v5 );
        v6 = *(void **)(v3 - 32);
      }
      v7 = *(_QWORD *)(v3 - 8);
      *(_QWORD *)(v3 - 24) = v4;
      if ( v7 + 4096 < (unsigned __int64)v6 || v7 > (unsigned __int64)v6 )
      {
        free(v6);
      }
      else if ( *(_QWORD *)(v7 + 4096) == *(_QWORD *)(v3 - 16) )
      {
        *(_QWORD *)(v7 + 4096) = v6;
      }
    }
  }
  v8 = *(void **)a1;
  if ( *(_QWORD *)a1 )
  {
    v9 = **(_QWORD **)(a1 + 32);
    if ( v9 + 4096 < (unsigned __int64)v8 || v9 > (unsigned __int64)v8 )
    {
      free(v8);
    }
    else if ( *(_QWORD *)(v9 + 4096) == *(_QWORD *)(a1 + 24) )
    {
      *(_QWORD *)(v9 + 4096) = v8;
    }
  }
}

//----- (0000000000058698) ----------------------------------------------------
unsigned __int8 *__fastcall sub_58698(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // x19
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  __int16 v7; // w9
  unsigned __int64 v8; // x9
  int v9; // w9
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  __int64 v12; // x9
  __int64 v13; // x10
  unsigned __int64 v14; // x9
  __int16 v15; // w9
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x23
  __int64 v22; // x21
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x9
  __int64 v25; // x9
  char *v26; // x0
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x23
  __int64 v29; // x21
  unsigned __int64 v30; // x9
  unsigned __int64 v31; // x9
  __int64 v32; // x9
  char *v33; // x0
  unsigned __int64 v34; // x9
  unsigned __int64 v35; // x9
  unsigned __int64 v36; // x23
  __int64 v37; // x21
  unsigned __int64 v38; // x9
  unsigned __int64 v39; // x9
  __int64 v40; // x9
  char *v41; // x0
  unsigned __int64 v42; // x9
  unsigned __int64 v43; // x9
  unsigned __int64 v44; // x9
  unsigned __int64 v45; // x9
  unsigned __int64 v46; // x23
  __int64 v47; // x21
  unsigned __int64 v48; // x9
  unsigned __int64 v49; // x9
  __int64 v50; // x9
  char *v51; // x0
  unsigned __int64 v52; // x9
  __int16 v53; // w9
  unsigned __int64 v54; // x9
  unsigned __int64 v55; // x9
  unsigned __int64 v56; // x9
  unsigned __int64 v57; // x9
  unsigned __int8 *v58; // x21
  unsigned __int8 *v59; // x0
  unsigned __int64 v60; // x9
  __int64 v61; // x9
  unsigned __int64 v62; // x9
  char v63; // w9
  unsigned __int64 v64; // x23
  __int64 v65; // x21
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // x9
  __int64 v68; // x9
  char *v69; // x0
  unsigned __int64 v70; // x23
  __int64 v71; // x21
  unsigned __int64 v72; // x9
  unsigned __int64 v73; // x9
  __int64 v74; // x9
  char *v75; // x0
  unsigned __int64 v76; // x23
  __int64 v77; // x21
  unsigned __int64 v78; // x9
  unsigned __int64 v79; // x9
  __int64 v80; // x9
  char *v81; // x0
  unsigned __int64 v82; // x23
  __int64 v83; // x21
  unsigned __int64 v84; // x9
  unsigned __int64 v85; // x9
  __int64 v86; // x9
  char *v87; // x0
  unsigned __int64 v88; // x23
  __int64 v89; // x21
  unsigned __int64 v90; // x9
  unsigned __int64 v91; // x9
  __int64 v92; // x9
  char *v93; // x0
  unsigned __int64 v94; // x23
  __int64 v95; // x21
  unsigned __int64 v96; // x9
  unsigned __int64 v97; // x9
  __int64 v98; // x9
  char *v99; // x0
  unsigned __int64 v100; // x23
  __int64 v101; // x21
  unsigned __int64 v102; // x9
  unsigned __int64 v103; // x9
  __int64 v104; // x9
  char *v105; // x0
  unsigned __int64 v106; // x23
  __int64 v107; // x21
  unsigned __int64 v108; // x9
  unsigned __int64 v109; // x9
  __int64 v110; // x9
  char *v111; // x0
  unsigned __int64 v112; // x23
  __int64 v113; // x21
  unsigned __int64 v114; // x9
  unsigned __int64 v115; // x9
  __int64 v116; // x9
  char *v117; // x0
  unsigned __int64 v118; // x23
  __int64 v119; // x21
  unsigned __int64 v120; // x9
  unsigned __int64 v121; // x9
  __int64 v122; // x9
  char *v123; // x0
  unsigned __int64 v124; // x23
  __int64 v125; // x21
  unsigned __int64 v126; // x9
  unsigned __int64 v127; // x9
  __int64 v128; // x9
  char *v129; // x0
  unsigned __int64 v130; // x23
  __int64 v131; // x21
  unsigned __int64 v132; // x9
  unsigned __int64 v133; // x9
  __int64 v134; // x9
  char *v135; // x0
  unsigned __int64 v136; // x23
  __int64 v137; // x21
  unsigned __int64 v138; // x9
  unsigned __int64 v139; // x9
  __int64 v140; // x9
  char *v141; // x0
  unsigned __int64 v142; // x23
  __int64 v143; // x21
  unsigned __int64 v144; // x9
  unsigned __int64 v145; // x9
  __int64 v146; // x9
  char *v147; // x0
  unsigned __int64 v148; // x23
  __int64 v149; // x21
  unsigned __int64 v150; // x9
  unsigned __int64 v151; // x9
  __int64 v152; // x9
  char *v153; // x0
  unsigned __int64 v154; // x23
  __int64 v155; // x21
  unsigned __int64 v156; // x9
  unsigned __int64 v157; // x9
  __int64 v158; // x9
  char *v159; // x0
  unsigned __int64 v160; // x23
  __int64 v161; // x21
  unsigned __int64 v162; // x9
  unsigned __int64 v163; // x9
  __int64 v164; // x9
  char *v165; // x0
  char *v166; // x8
  char *v167; // x9
  void **v168; // x11
  void **v169; // x23
  char *v170; // x10
  __int64 v171; // x12
  void **v172; // x21
  __int64 v173; // x24
  void **v174; // x25
  char *v175; // x8
  char *v176; // x9
  void **v177; // x11
  void **v178; // x23
  char *v179; // x10
  __int64 v180; // x12
  void **v181; // x25
  char *v182; // x8
  char *v183; // x9
  void **v184; // x11
  void **v185; // x23
  char *v186; // x10
  __int64 v187; // x12
  void **v188; // x25
  char *v189; // x8
  char *v190; // x9
  void **v191; // x11
  void **v192; // x23
  char *v193; // x10
  __int64 v194; // x12
  void **v195; // x25
  char *v196; // x8
  char *v197; // x9
  void **v198; // x11
  void **v199; // x23
  char *v200; // x10
  __int64 v201; // x12
  void **v202; // x25
  char *v203; // x8
  char *v204; // x9
  void **v205; // x11
  void **v206; // x23
  char *v207; // x10
  __int64 v208; // x12
  void **v209; // x25
  char *v210; // x8
  char *v211; // x9
  void **v212; // x11
  void **v213; // x23
  char *v214; // x10
  __int64 v215; // x12
  void **v216; // x25
  char *v217; // x8
  char *v218; // x9
  void **v219; // x11
  void **v220; // x23
  char *v221; // x10
  __int64 v222; // x12
  void **v223; // x25
  char *v224; // x8
  char *v225; // x9
  void **v226; // x11
  void **v227; // x23
  char *v228; // x10
  __int64 v229; // x12
  void **v230; // x25
  char *v231; // x8
  char *v232; // x9
  void **v233; // x11
  void **v234; // x23
  char *v235; // x10
  __int64 v236; // x12
  void **v237; // x25
  char *v238; // x8
  char *v239; // x9
  void **v240; // x11
  void **v241; // x23
  char *v242; // x10
  __int64 v243; // x12
  void **v244; // x25
  char *v245; // x8
  char *v246; // x9
  void **v247; // x11
  void **v248; // x23
  char *v249; // x10
  __int64 v250; // x12
  void **v251; // x25
  char *v252; // x8
  char *v253; // x9
  void **v254; // x11
  void **v255; // x23
  char *v256; // x10
  __int64 v257; // x12
  void **v258; // x25
  char *v259; // x8
  char *v260; // x9
  void **v261; // x11
  void **v262; // x23
  char *v263; // x10
  __int64 v264; // x12
  void **v265; // x25
  char *v266; // x8
  char *v267; // x9
  void **v268; // x11
  void **v269; // x23
  char *v270; // x10
  __int64 v271; // x12
  void **v272; // x25
  char *v273; // x8
  char *v274; // x9
  void **v275; // x11
  void **v276; // x23
  char *v277; // x10
  __int64 v278; // x12
  void **v279; // x25
  char *v280; // x8
  char *v281; // x9
  void **v282; // x11
  void **v283; // x23
  char *v284; // x10
  __int64 v285; // x12
  void **v286; // x25
  char *v287; // x8
  char *v288; // x9
  void **v289; // x11
  void **v290; // x23
  char *v291; // x10
  __int64 v292; // x12
  void **v293; // x25
  char *v294; // x8
  char *v295; // x9
  void **v296; // x11
  void **v297; // x23
  char *v298; // x10
  __int64 v299; // x12
  void **v300; // x25
  char *v301; // x8
  char *v302; // x9
  void **v303; // x11
  void **v304; // x23
  char *v305; // x10
  __int64 v306; // x12
  void **v307; // x25
  char *v308; // x8
  char *v309; // x9
  void **v310; // x11
  void **v311; // x23
  char *v312; // x10
  __int64 v313; // x12
  void **v314; // x25
  unsigned __int64 v315; // x8
  unsigned __int64 v317; // x9
  unsigned __int64 v318; // x23
  __int64 v319; // x21
  unsigned __int64 v320; // x9
  unsigned __int64 v321; // x9
  __int64 v322; // x9
  char *v323; // x0
  unsigned __int64 v324; // x9
  unsigned __int64 v325; // x23
  __int64 v326; // x21
  unsigned __int64 v327; // x9
  unsigned __int64 v328; // x9
  __int64 v329; // x9
  char *v330; // x0
  unsigned __int64 v331; // x9
  unsigned __int64 v332; // x23
  __int64 v333; // x21
  unsigned __int64 v334; // x9
  unsigned __int64 v335; // x9
  __int64 v336; // x9
  char *v337; // x0
  unsigned __int64 v338; // x9
  __int64 v339; // x9
  unsigned __int64 v340; // x9
  unsigned __int64 v341; // x9
  unsigned __int64 v342; // x9
  unsigned __int64 v343; // x9
  unsigned __int64 v344; // x23
  __int64 v345; // x21
  unsigned __int64 v346; // x9
  unsigned __int64 v347; // x9
  __int64 v348; // x9
  char *v349; // x0
  unsigned __int64 v350; // x23
  __int64 v351; // x21
  unsigned __int64 v352; // x9
  unsigned __int64 v353; // x9
  __int64 v354; // x9
  char *v355; // x0
  unsigned __int64 v356; // x23
  __int64 v357; // x21
  unsigned __int64 v358; // x9
  unsigned __int64 v359; // x9
  __int64 v360; // x9
  char *v361; // x0
  unsigned __int64 v362; // x23
  __int64 v363; // x21
  unsigned __int64 v364; // x9
  unsigned __int64 v365; // x9
  __int64 v366; // x9
  char *v367; // x0
  unsigned __int64 v368; // x23
  __int64 v369; // x21
  unsigned __int64 v370; // x9
  unsigned __int64 v371; // x9
  __int64 v372; // x9
  char *v373; // x0
  unsigned __int64 v374; // x23
  __int64 v375; // x21
  unsigned __int64 v376; // x9
  unsigned __int64 v377; // x9
  __int64 v378; // x9
  char *v379; // x0
  char *v380; // x8
  char *v381; // x9
  void **v382; // x11
  void **v383; // x23
  char *v384; // x10
  __int64 v385; // x12
  void **v386; // x21
  __int64 v387; // x24
  void **v388; // x25
  char *v389; // x8
  char *v390; // x9
  void **v391; // x11
  void **v392; // x23
  char *v393; // x10
  __int64 v394; // x12
  void **v395; // x25
  char *v396; // x8
  char *v397; // x9
  void **v398; // x11
  void **v399; // x23
  char *v400; // x10
  __int64 v401; // x12
  void **v402; // x25
  char *v403; // x8
  char *v404; // x9
  void **v405; // x11
  void **v406; // x23
  char *v407; // x10
  __int64 v408; // x12
  void **v409; // x25
  char *v410; // x8
  char *v411; // x9
  void **v412; // x11
  void **v413; // x23
  char *v414; // x10
  __int64 v415; // x12
  void **v416; // x25
  char *v417; // x8
  char *v418; // x9
  void **v419; // x11
  void **v420; // x23
  char *v421; // x10
  __int64 v422; // x12
  void **v423; // x25
  char *v424; // x8
  char *v425; // x9
  void **v426; // x11
  void **v427; // x23
  char *v428; // x10
  __int64 v429; // x12
  void **v430; // x25
  char *v431; // x8
  char *v432; // x9
  void **v433; // x11
  void **v434; // x23
  char *v435; // x10
  __int64 v436; // x12
  void **v437; // x25
  char *v438; // x8
  char *v439; // x9
  void **v440; // x11
  void **v441; // x23
  char *v442; // x10
  __int64 v443; // x12
  void **v444; // x25
  unsigned __int64 v445; // x8
  __int16 v446; // [xsp+40h] [xbp-70h]
  int v447; // [xsp+40h] [xbp-70h]
  char v448; // [xsp+42h] [xbp-6Eh]
  _QWORD v449[2]; // [xsp+48h] [xbp-68h] BYREF
  _QWORD v450[3]; // [xsp+58h] [xbp-58h] BYREF

  v3 = a1;
  v450[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 != a2 )
  {
    switch ( *a1 )
    {
      case 'D':
        if ( a1 + 1 != a2 )
        {
          switch ( a1[1] )
          {
            case 'a':
              LOWORD(v449[1]) = 0;
              v449[0] = 0;
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v5 = *(_QWORD *)(a3 + 8);
              v6 = *(_QWORD *)(a3 + 16);
              if ( v5 < v6 )
              {
                *(_BYTE *)v5 = 8;
                strcpy((char *)(v5 + 1), "auto");
                v7 = v449[1];
                v3 = a1 + 2;
                goto LABEL_55;
              }
              v344 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v345 = 0x555555555555555LL;
              if ( v344 + 1 > 0x555555555555555LL )
                abort();
              v346 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v346 >= 0x2AAAAAAAAAAAAAALL
                || ((v347 = 2 * v346, v347 >= v344 + 1) ? (v345 = v347) : (v345 = v344 + 1), v345) )
              {
                v348 = *(_QWORD *)(a3 + 24);
                v349 = *(char **)(v348 + 4096);
                if ( v348 + 4096 - (__int64)v349 >= (unsigned __int64)(48 * v345) )
                  *(_QWORD *)(v348 + 4096) = &v349[48 * v345];
                else
                  v349 = (char *)malloc(48 * v345);
              }
              else
              {
                v349 = 0;
              }
              v396 = &v349[48 * v344];
              *v396 = 8;
              strcpy(v396 + 1, "auto");
              v397 = &v349[48 * v345];
              *((_WORD *)v396 + 7) = v449[1];
              *((_QWORD *)v396 + 2) = 0;
              *(_QWORD *)(v396 + 6) = v449[0];
              LOWORD(v449[1]) = 0;
              v449[0] = 0;
              v396[24] = 0;
              *((_QWORD *)v396 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v396 + 5) = 0;
              *(_QWORD *)(v396 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v399 = *(void ***)a3;
              v398 = *(void ***)(a3 + 8);
              v400 = v396 + 48;
              if ( v398 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v396 - 4) = *(v398 - 4);
                  *((_OWORD *)v396 - 3) = *((_OWORD *)v398 - 3);
                  v401 = (__int64)*(v398 - 1);
                  *(v398 - 5) = 0;
                  *(v398 - 4) = 0;
                  *(v398 - 6) = 0;
                  *((_QWORD *)v396 - 1) = v401;
                  *(_OWORD *)(v396 - 24) = *(_OWORD *)(v398 - 3);
                  *(v398 - 3) = 0;
                  *(v398 - 2) = 0;
                  *(v398 - 1) = 0;
                  v398 -= 6;
                  v396 -= 48;
                }
                while ( v399 != v398 );
                v386 = *(void ***)a3;
                v399 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v396;
              *(_QWORD *)(a3 + 8) = v400;
              *(_QWORD *)(a3 + 16) = v397;
              if ( v399 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v399 - 3) & 1) != 0 )
                    free(*(v399 - 1));
                  v402 = v399 - 6;
                  if ( (*(_BYTE *)(v399 - 6) & 1) != 0 )
                    free(*(v399 - 4));
                  v399 -= 6;
                }
                while ( v386 != v402 );
              }
              goto LABEL_710;
            case 'c':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "decltype(auto)", 14);
              v5 = *(_QWORD *)(a3 + 8);
              v331 = *(_QWORD *)(a3 + 16);
              if ( v5 < v331 )
                goto LABEL_538;
              v332 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v333 = 0x555555555555555LL;
              if ( v332 + 1 > 0x555555555555555LL )
                abort();
              v334 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v331 - *(_QWORD *)a3) >> 4);
              if ( v334 >= 0x2AAAAAAAAAAAAAALL
                || ((v335 = 2 * v334, v335 >= v332 + 1) ? (v333 = v335) : (v333 = v332 + 1), v333) )
              {
                v336 = *(_QWORD *)(a3 + 24);
                v337 = *(char **)(v336 + 4096);
                if ( v336 + 4096 - (__int64)v337 >= (unsigned __int64)(48 * v333) )
                  *(_QWORD *)(v336 + 4096) = &v337[48 * v333];
                else
                  v337 = (char *)malloc(48 * v333);
              }
              else
              {
                v337 = 0;
              }
              v403 = &v337[48 * v332];
              *v403 = 28;
              v404 = &v337[48 * v333];
              *(_QWORD *)(v403 + 7) = *(_QWORD *)((char *)v449 + 6);
              v403[15] = 0;
              *((_QWORD *)v403 + 2) = 0;
              *(_QWORD *)(v403 + 1) = v449[0];
              *(_QWORD *)((char *)v449 + 6) = 0;
              v449[0] = 0;
              v403[24] = 0;
              *((_QWORD *)v403 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v403 + 5) = 0;
              *(_QWORD *)(v403 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v406 = *(void ***)a3;
              v405 = *(void ***)(a3 + 8);
              v407 = v403 + 48;
              if ( v405 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v403 - 4) = *(v405 - 4);
                  *((_OWORD *)v403 - 3) = *((_OWORD *)v405 - 3);
                  v408 = (__int64)*(v405 - 1);
                  *(v405 - 5) = 0;
                  *(v405 - 4) = 0;
                  *(v405 - 6) = 0;
                  *((_QWORD *)v403 - 1) = v408;
                  *(_OWORD *)(v403 - 24) = *(_OWORD *)(v405 - 3);
                  *(v405 - 3) = 0;
                  *(v405 - 2) = 0;
                  *(v405 - 1) = 0;
                  v405 -= 6;
                  v403 -= 48;
                }
                while ( v406 != v405 );
                v386 = *(void ***)a3;
                v406 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v403;
              *(_QWORD *)(a3 + 8) = v407;
              *(_QWORD *)(a3 + 16) = v404;
              if ( v406 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v406 - 3) & 1) != 0 )
                    free(*(v406 - 1));
                  v409 = v406 - 6;
                  if ( (*(_BYTE *)(v406 - 6) & 1) != 0 )
                    free(*(v406 - 4));
                  v406 -= 6;
                }
                while ( v386 != v409 );
              }
              goto LABEL_710;
            case 'd':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "decimal64", 9);
              v5 = *(_QWORD *)(a3 + 8);
              v317 = *(_QWORD *)(a3 + 16);
              if ( v5 < v317 )
                goto LABEL_542;
              v318 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v319 = 0x555555555555555LL;
              if ( v318 + 1 > 0x555555555555555LL )
                abort();
              v320 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v317 - *(_QWORD *)a3) >> 4);
              if ( v320 >= 0x2AAAAAAAAAAAAAALL
                || ((v321 = 2 * v320, v321 >= v318 + 1) ? (v319 = v321) : (v319 = v318 + 1), v319) )
              {
                v322 = *(_QWORD *)(a3 + 24);
                v323 = *(char **)(v322 + 4096);
                if ( v322 + 4096 - (__int64)v323 >= (unsigned __int64)(48 * v319) )
                  *(_QWORD *)(v322 + 4096) = &v323[48 * v319];
                else
                  v323 = (char *)malloc(48 * v319);
              }
              else
              {
                v323 = 0;
              }
              v380 = &v323[48 * v318];
              *v380 = 18;
              v381 = &v323[48 * v319];
              v380[9] = v449[1];
              v380[10] = 0;
              *(_QWORD *)(v380 + 1) = v449[0];
              v380[15] = 0;
              *((_QWORD *)v380 + 2) = 0;
              *(_DWORD *)(v380 + 11) = 0;
              LOBYTE(v449[1]) = 0;
              v449[0] = 0;
              v380[24] = 0;
              *((_QWORD *)v380 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v380 + 5) = 0;
              *(_QWORD *)(v380 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v383 = *(void ***)a3;
              v382 = *(void ***)(a3 + 8);
              v384 = v380 + 48;
              if ( v382 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v380 - 4) = *(v382 - 4);
                  *((_OWORD *)v380 - 3) = *((_OWORD *)v382 - 3);
                  v385 = (__int64)*(v382 - 1);
                  *(v382 - 5) = 0;
                  *(v382 - 4) = 0;
                  *(v382 - 6) = 0;
                  *((_QWORD *)v380 - 1) = v385;
                  *(_OWORD *)(v380 - 24) = *(_OWORD *)(v382 - 3);
                  *(v382 - 3) = 0;
                  *(v382 - 2) = 0;
                  *(v382 - 1) = 0;
                  v382 -= 6;
                  v380 -= 48;
                }
                while ( v383 != v382 );
                v386 = *(void ***)a3;
                v383 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v380;
              *(_QWORD *)(a3 + 8) = v384;
              *(_QWORD *)(a3 + 16) = v381;
              if ( v383 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v383 - 3) & 1) != 0 )
                    free(*(v383 - 1));
                  v388 = v383 - 6;
                  if ( (*(_BYTE *)(v383 - 6) & 1) != 0 )
                    free(*(v383 - 4));
                  v383 -= 6;
                }
                while ( v386 != v388 );
              }
              goto LABEL_710;
            case 'e':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "decimal128", 10);
              v5 = *(_QWORD *)(a3 + 8);
              v341 = *(_QWORD *)(a3 + 16);
              if ( v5 < v341 )
              {
                *(_BYTE *)v5 = 20;
                v53 = v449[1];
                v3 = a1 + 2;
                goto LABEL_69;
              }
              v362 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v363 = 0x555555555555555LL;
              if ( v362 + 1 > 0x555555555555555LL )
                abort();
              v364 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v341 - *(_QWORD *)a3) >> 4);
              if ( v364 >= 0x2AAAAAAAAAAAAAALL
                || ((v365 = 2 * v364, v365 >= v362 + 1) ? (v363 = v365) : (v363 = v362 + 1), v363) )
              {
                v366 = *(_QWORD *)(a3 + 24);
                v367 = *(char **)(v366 + 4096);
                if ( v366 + 4096 - (__int64)v367 >= (unsigned __int64)(48 * v363) )
                  *(_QWORD *)(v366 + 4096) = &v367[48 * v363];
                else
                  v367 = (char *)malloc(48 * v363);
              }
              else
              {
                v367 = 0;
              }
              v424 = &v367[48 * v362];
              *v424 = 20;
              v425 = &v367[48 * v363];
              *(_WORD *)(v424 + 9) = v449[1];
              v424[11] = 0;
              *((_DWORD *)v424 + 3) = 0;
              *((_QWORD *)v424 + 2) = 0;
              *(_QWORD *)(v424 + 1) = v449[0];
              LOWORD(v449[1]) = 0;
              v449[0] = 0;
              v424[24] = 0;
              *((_QWORD *)v424 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v424 + 5) = 0;
              *(_QWORD *)(v424 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v427 = *(void ***)a3;
              v426 = *(void ***)(a3 + 8);
              v428 = v424 + 48;
              if ( v426 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v424 - 4) = *(v426 - 4);
                  *((_OWORD *)v424 - 3) = *((_OWORD *)v426 - 3);
                  v429 = (__int64)*(v426 - 1);
                  *(v426 - 5) = 0;
                  *(v426 - 4) = 0;
                  *(v426 - 6) = 0;
                  *((_QWORD *)v424 - 1) = v429;
                  *(_OWORD *)(v424 - 24) = *(_OWORD *)(v426 - 3);
                  *(v426 - 3) = 0;
                  *(v426 - 2) = 0;
                  *(v426 - 1) = 0;
                  v426 -= 6;
                  v424 -= 48;
                }
                while ( v427 != v426 );
                v386 = *(void ***)a3;
                v427 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v424;
              *(_QWORD *)(a3 + 8) = v428;
              *(_QWORD *)(a3 + 16) = v425;
              if ( v427 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v427 - 3) & 1) != 0 )
                    free(*(v427 - 1));
                  v430 = v427 - 6;
                  if ( (*(_BYTE *)(v427 - 6) & 1) != 0 )
                    free(*(v427 - 4));
                  v427 -= 6;
                }
                while ( v386 != v430 );
              }
              goto LABEL_710;
            case 'f':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "decimal32", 9);
              v5 = *(_QWORD *)(a3 + 8);
              v342 = *(_QWORD *)(a3 + 16);
              if ( v5 < v342 )
                goto LABEL_542;
              v368 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v369 = 0x555555555555555LL;
              if ( v368 + 1 > 0x555555555555555LL )
                abort();
              v370 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v342 - *(_QWORD *)a3) >> 4);
              if ( v370 >= 0x2AAAAAAAAAAAAAALL
                || ((v371 = 2 * v370, v371 >= v368 + 1) ? (v369 = v371) : (v369 = v368 + 1), v369) )
              {
                v372 = *(_QWORD *)(a3 + 24);
                v373 = *(char **)(v372 + 4096);
                if ( v372 + 4096 - (__int64)v373 >= (unsigned __int64)(48 * v369) )
                  *(_QWORD *)(v372 + 4096) = &v373[48 * v369];
                else
                  v373 = (char *)malloc(48 * v369);
              }
              else
              {
                v373 = 0;
              }
              v431 = &v373[48 * v368];
              *v431 = 18;
              v432 = &v373[48 * v369];
              v431[9] = v449[1];
              v431[10] = 0;
              *(_QWORD *)(v431 + 1) = v449[0];
              v431[15] = 0;
              *((_QWORD *)v431 + 2) = 0;
              *(_DWORD *)(v431 + 11) = 0;
              LOBYTE(v449[1]) = 0;
              v449[0] = 0;
              v431[24] = 0;
              *((_QWORD *)v431 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v431 + 5) = 0;
              *(_QWORD *)(v431 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v434 = *(void ***)a3;
              v433 = *(void ***)(a3 + 8);
              v435 = v431 + 48;
              if ( v433 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v431 - 4) = *(v433 - 4);
                  *((_OWORD *)v431 - 3) = *((_OWORD *)v433 - 3);
                  v436 = (__int64)*(v433 - 1);
                  *(v433 - 5) = 0;
                  *(v433 - 4) = 0;
                  *(v433 - 6) = 0;
                  *((_QWORD *)v431 - 1) = v436;
                  *(_OWORD *)(v431 - 24) = *(_OWORD *)(v433 - 3);
                  *(v433 - 3) = 0;
                  *(v433 - 2) = 0;
                  *(v433 - 1) = 0;
                  v433 -= 6;
                  v431 -= 48;
                }
                while ( v434 != v433 );
                v386 = *(void ***)a3;
                v434 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v431;
              *(_QWORD *)(a3 + 8) = v435;
              *(_QWORD *)(a3 + 16) = v432;
              if ( v434 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v434 - 3) & 1) != 0 )
                    free(*(v434 - 1));
                  v437 = v434 - 6;
                  if ( (*(_BYTE *)(v434 - 6) & 1) != 0 )
                    free(*(v434 - 4));
                  v434 -= 6;
                }
                while ( v386 != v437 );
              }
              goto LABEL_710;
            case 'h':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "decimal16", 9);
              v5 = *(_QWORD *)(a3 + 8);
              v324 = *(_QWORD *)(a3 + 16);
              if ( v5 < v324 )
              {
LABEL_542:
                *(_BYTE *)v5 = 18;
                v63 = v449[1];
                v3 = a1 + 2;
                goto LABEL_91;
              }
              v325 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v326 = 0x555555555555555LL;
              if ( v325 + 1 > 0x555555555555555LL )
                abort();
              v327 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v324 - *(_QWORD *)a3) >> 4);
              if ( v327 >= 0x2AAAAAAAAAAAAAALL
                || ((v328 = 2 * v327, v328 >= v325 + 1) ? (v326 = v328) : (v326 = v325 + 1), v326) )
              {
                v329 = *(_QWORD *)(a3 + 24);
                v330 = *(char **)(v329 + 4096);
                if ( v329 + 4096 - (__int64)v330 >= (unsigned __int64)(48 * v326) )
                  *(_QWORD *)(v329 + 4096) = &v330[48 * v326];
                else
                  v330 = (char *)malloc(48 * v326);
              }
              else
              {
                v330 = 0;
              }
              v389 = &v330[48 * v325];
              *v389 = 18;
              v390 = &v330[48 * v326];
              v389[9] = v449[1];
              v389[10] = 0;
              *(_QWORD *)(v389 + 1) = v449[0];
              v389[15] = 0;
              *((_QWORD *)v389 + 2) = 0;
              *(_DWORD *)(v389 + 11) = 0;
              LOBYTE(v449[1]) = 0;
              v449[0] = 0;
              v389[24] = 0;
              *((_QWORD *)v389 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v389 + 5) = 0;
              *(_QWORD *)(v389 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v392 = *(void ***)a3;
              v391 = *(void ***)(a3 + 8);
              v393 = v389 + 48;
              if ( v391 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v389 - 4) = *(v391 - 4);
                  *((_OWORD *)v389 - 3) = *((_OWORD *)v391 - 3);
                  v394 = (__int64)*(v391 - 1);
                  *(v391 - 5) = 0;
                  *(v391 - 4) = 0;
                  *(v391 - 6) = 0;
                  *((_QWORD *)v389 - 1) = v394;
                  *(_OWORD *)(v389 - 24) = *(_OWORD *)(v391 - 3);
                  *(v391 - 3) = 0;
                  *(v391 - 2) = 0;
                  *(v391 - 1) = 0;
                  v391 -= 6;
                  v389 -= 48;
                }
                while ( v392 != v391 );
                v386 = *(void ***)a3;
                v392 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v389;
              *(_QWORD *)(a3 + 8) = v393;
              *(_QWORD *)(a3 + 16) = v390;
              if ( v392 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v392 - 3) & 1) != 0 )
                    free(*(v392 - 1));
                  v395 = v392 - 6;
                  if ( (*(_BYTE *)(v392 - 6) & 1) != 0 )
                    free(*(v392 - 4));
                  v392 -= 6;
                }
                while ( v386 != v395 );
              }
              goto LABEL_710;
            case 'i':
              WORD2(v449[0]) = 0;
              LODWORD(v449[0]) = 0;
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v5 = *(_QWORD *)(a3 + 8);
              v338 = *(_QWORD *)(a3 + 16);
              if ( v5 < v338 )
              {
                *(_BYTE *)v5 = 16;
                v339 = 0x323372616863LL;
                goto LABEL_545;
              }
              v350 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v351 = 0x555555555555555LL;
              if ( v350 + 1 > 0x555555555555555LL )
                abort();
              v352 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v338 - *(_QWORD *)a3) >> 4);
              if ( v352 >= 0x2AAAAAAAAAAAAAALL
                || ((v353 = 2 * v352, v353 >= v350 + 1) ? (v351 = v353) : (v351 = v350 + 1), v351) )
              {
                v354 = *(_QWORD *)(a3 + 24);
                v355 = *(char **)(v354 + 4096);
                if ( v354 + 4096 - (__int64)v355 >= (unsigned __int64)(48 * v351) )
                  *(_QWORD *)(v354 + 4096) = &v355[48 * v351];
                else
                  v355 = (char *)malloc(48 * v351);
              }
              else
              {
                v355 = 0;
              }
              v410 = &v355[48 * v350];
              *v410 = 16;
              strcpy(v410 + 1, "char32_t");
              v411 = &v355[48 * v351];
              *((_WORD *)v410 + 7) = WORD2(v449[0]);
              *((_QWORD *)v410 + 2) = 0;
              *(_DWORD *)(v410 + 10) = v449[0];
              WORD2(v449[0]) = 0;
              LODWORD(v449[0]) = 0;
              v410[24] = 0;
              *((_QWORD *)v410 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v410 + 5) = 0;
              *(_QWORD *)(v410 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v413 = *(void ***)a3;
              v412 = *(void ***)(a3 + 8);
              v414 = v410 + 48;
              if ( v412 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v410 - 4) = *(v412 - 4);
                  *((_OWORD *)v410 - 3) = *((_OWORD *)v412 - 3);
                  v415 = (__int64)*(v412 - 1);
                  *(v412 - 5) = 0;
                  *(v412 - 4) = 0;
                  *(v412 - 6) = 0;
                  *((_QWORD *)v410 - 1) = v415;
                  *(_OWORD *)(v410 - 24) = *(_OWORD *)(v412 - 3);
                  *(v412 - 3) = 0;
                  *(v412 - 2) = 0;
                  *(v412 - 1) = 0;
                  v412 -= 6;
                  v410 -= 48;
                }
                while ( v413 != v412 );
                v386 = *(void ***)a3;
                v413 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v410;
              *(_QWORD *)(a3 + 8) = v414;
              *(_QWORD *)(a3 + 16) = v411;
              if ( v413 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v413 - 3) & 1) != 0 )
                    free(*(v413 - 1));
                  v416 = v413 - 6;
                  if ( (*(_BYTE *)(v413 - 6) & 1) != 0 )
                    free(*(v413 - 4));
                  v413 -= 6;
                }
                while ( v386 != v416 );
              }
              goto LABEL_710;
            case 'n':
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              qmemcpy(v449, "std::nullptr_t", 14);
              v5 = *(_QWORD *)(a3 + 8);
              v340 = *(_QWORD *)(a3 + 16);
              if ( v5 < v340 )
              {
LABEL_538:
                *(_BYTE *)v5 = 28;
                v61 = *(_QWORD *)((char *)v449 + 6);
                v3 = a1 + 2;
                goto LABEL_85;
              }
              v356 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v357 = 0x555555555555555LL;
              if ( v356 + 1 > 0x555555555555555LL )
                abort();
              v358 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v340 - *(_QWORD *)a3) >> 4);
              if ( v358 >= 0x2AAAAAAAAAAAAAALL
                || ((v359 = 2 * v358, v359 >= v356 + 1) ? (v357 = v359) : (v357 = v356 + 1), v357) )
              {
                v360 = *(_QWORD *)(a3 + 24);
                v361 = *(char **)(v360 + 4096);
                if ( v360 + 4096 - (__int64)v361 >= (unsigned __int64)(48 * v357) )
                  *(_QWORD *)(v360 + 4096) = &v361[48 * v357];
                else
                  v361 = (char *)malloc(48 * v357);
              }
              else
              {
                v361 = 0;
              }
              v417 = &v361[48 * v356];
              *v417 = 28;
              v418 = &v361[48 * v357];
              *(_QWORD *)(v417 + 7) = *(_QWORD *)((char *)v449 + 6);
              v417[15] = 0;
              *((_QWORD *)v417 + 2) = 0;
              *(_QWORD *)(v417 + 1) = v449[0];
              *(_QWORD *)((char *)v449 + 6) = 0;
              v449[0] = 0;
              v417[24] = 0;
              *((_QWORD *)v417 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v417 + 5) = 0;
              *(_QWORD *)(v417 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v420 = *(void ***)a3;
              v419 = *(void ***)(a3 + 8);
              v421 = v417 + 48;
              if ( v419 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v417 - 4) = *(v419 - 4);
                  *((_OWORD *)v417 - 3) = *((_OWORD *)v419 - 3);
                  v422 = (__int64)*(v419 - 1);
                  *(v419 - 5) = 0;
                  *(v419 - 4) = 0;
                  *(v419 - 6) = 0;
                  *((_QWORD *)v417 - 1) = v422;
                  *(_OWORD *)(v417 - 24) = *(_OWORD *)(v419 - 3);
                  *(v419 - 3) = 0;
                  *(v419 - 2) = 0;
                  *(v419 - 1) = 0;
                  v419 -= 6;
                  v417 -= 48;
                }
                while ( v420 != v419 );
                v386 = *(void ***)a3;
                v420 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v417;
              *(_QWORD *)(a3 + 8) = v421;
              *(_QWORD *)(a3 + 16) = v418;
              if ( v420 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v420 - 3) & 1) != 0 )
                    free(*(v420 - 1));
                  v423 = v420 - 6;
                  if ( (*(_BYTE *)(v420 - 6) & 1) != 0 )
                    free(*(v420 - 4));
                  v420 -= 6;
                }
                while ( v386 != v423 );
              }
              goto LABEL_710;
            case 's':
              WORD2(v449[0]) = 0;
              LODWORD(v449[0]) = 0;
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v5 = *(_QWORD *)(a3 + 8);
              v343 = *(_QWORD *)(a3 + 16);
              if ( v5 < v343 )
              {
                *(_BYTE *)v5 = 16;
                v339 = 0x363172616863LL;
LABEL_545:
                *(_BYTE *)(v5 + 9) = 0;
                *(_QWORD *)(v5 + 1) = v339 & 0xFFFFFFFFFFFFLL | 0x745F000000000000LL;
                v15 = WORD2(v449[0]);
                v3 = a1 + 2;
                goto LABEL_13;
              }
              v374 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
              v375 = 0x555555555555555LL;
              if ( v374 + 1 > 0x555555555555555LL )
                abort();
              v376 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v343 - *(_QWORD *)a3) >> 4);
              if ( v376 >= 0x2AAAAAAAAAAAAAALL
                || ((v377 = 2 * v376, v377 >= v374 + 1) ? (v375 = v377) : (v375 = v374 + 1), v375) )
              {
                v378 = *(_QWORD *)(a3 + 24);
                v379 = *(char **)(v378 + 4096);
                if ( v378 + 4096 - (__int64)v379 >= (unsigned __int64)(48 * v375) )
                  *(_QWORD *)(v378 + 4096) = &v379[48 * v375];
                else
                  v379 = (char *)malloc(48 * v375);
              }
              else
              {
                v379 = 0;
              }
              v438 = &v379[48 * v374];
              *v438 = 16;
              strcpy(v438 + 1, "char16_t");
              v439 = &v379[48 * v375];
              *((_WORD *)v438 + 7) = WORD2(v449[0]);
              *((_QWORD *)v438 + 2) = 0;
              *(_DWORD *)(v438 + 10) = v449[0];
              WORD2(v449[0]) = 0;
              LODWORD(v449[0]) = 0;
              v438[24] = 0;
              *((_QWORD *)v438 + 4) = *(_QWORD *)((char *)v450 + 7);
              *((_QWORD *)v438 + 5) = 0;
              *(_QWORD *)(v438 + 25) = v450[0];
              *(_QWORD *)((char *)v450 + 7) = 0;
              v450[0] = 0;
              v441 = *(void ***)a3;
              v440 = *(void ***)(a3 + 8);
              v442 = v438 + 48;
              if ( v440 == *(void ***)a3 )
              {
                v386 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v438 - 4) = *(v440 - 4);
                  *((_OWORD *)v438 - 3) = *((_OWORD *)v440 - 3);
                  v443 = (__int64)*(v440 - 1);
                  *(v440 - 5) = 0;
                  *(v440 - 4) = 0;
                  *(v440 - 6) = 0;
                  *((_QWORD *)v438 - 1) = v443;
                  *(_OWORD *)(v438 - 24) = *(_OWORD *)(v440 - 3);
                  *(v440 - 3) = 0;
                  *(v440 - 2) = 0;
                  *(v440 - 1) = 0;
                  v440 -= 6;
                  v438 -= 48;
                }
                while ( v441 != v440 );
                v386 = *(void ***)a3;
                v441 = *(void ***)(a3 + 8);
              }
              v387 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v438;
              *(_QWORD *)(a3 + 8) = v442;
              *(_QWORD *)(a3 + 16) = v439;
              if ( v441 != v386 )
              {
                do
                {
                  if ( (*(_BYTE *)(v441 - 3) & 1) != 0 )
                    free(*(v441 - 1));
                  v444 = v441 - 6;
                  if ( (*(_BYTE *)(v441 - 6) & 1) != 0 )
                    free(*(v441 - 4));
                  v441 -= 6;
                }
                while ( v386 != v444 );
              }
LABEL_710:
              if ( v386 )
              {
                v445 = *(_QWORD *)(a3 + 24);
                if ( v445 + 4096 < (unsigned __int64)v386 || v445 > (unsigned __int64)v386 )
                {
                  free(v386);
                }
                else if ( *(_QWORD *)(v445 + 4096) == v387 )
                {
                  *(_QWORD *)(v445 + 4096) = v386;
                  v3 += 2;
                  return v3;
                }
              }
              v3 += 2;
              break;
            default:
              return v3;
          }
        }
        return v3;
      case 'a':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "signed char", 11);
        v5 = *(_QWORD *)(a3 + 8);
        v44 = *(_QWORD *)(a3 + 16);
        if ( v5 < v44 )
          goto LABEL_57;
        v118 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v119 = 0x555555555555555LL;
        if ( v118 + 1 > 0x555555555555555LL )
          abort();
        v120 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v44 - *(_QWORD *)a3) >> 4);
        if ( v120 >= 0x2AAAAAAAAAAAAAALL
          || ((v121 = 2 * v120, v121 >= v118 + 1) ? (v119 = v121) : (v119 = v118 + 1), v119) )
        {
          v122 = *(_QWORD *)(a3 + 24);
          v123 = *(char **)(v122 + 4096);
          if ( v122 + 4096 - (__int64)v123 >= (unsigned __int64)(48 * v119) )
            *(_QWORD *)(v122 + 4096) = &v123[48 * v119];
          else
            v123 = (char *)malloc(48 * v119);
        }
        else
        {
          v123 = 0;
        }
        v252 = &v123[48 * v118];
        *v252 = 22;
        v253 = &v123[48 * v119];
        v252[11] = BYTE2(v449[1]);
        *(_WORD *)(v252 + 9) = v449[1];
        v252[12] = 0;
        *(_QWORD *)(v252 + 1) = v449[0];
        v252[15] = 0;
        *((_QWORD *)v252 + 2) = 0;
        *(_WORD *)(v252 + 13) = 0;
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        BYTE2(v449[1]) = 0;
        v252[24] = 0;
        *((_QWORD *)v252 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v252 + 5) = 0;
        *(_QWORD *)(v252 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v255 = *(void ***)a3;
        v254 = *(void ***)(a3 + 8);
        v256 = v252 + 48;
        if ( v254 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v252 - 4) = *(v254 - 4);
            *((_OWORD *)v252 - 3) = *((_OWORD *)v254 - 3);
            v257 = (__int64)*(v254 - 1);
            *(v254 - 5) = 0;
            *(v254 - 4) = 0;
            *(v254 - 6) = 0;
            *((_QWORD *)v252 - 1) = v257;
            *(_OWORD *)(v252 - 24) = *(_OWORD *)(v254 - 3);
            *(v254 - 3) = 0;
            *(v254 - 2) = 0;
            *(v254 - 1) = 0;
            v254 -= 6;
            v252 -= 48;
          }
          while ( v255 != v254 );
          v172 = *(void ***)a3;
          v255 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v252;
        *(_QWORD *)(a3 + 8) = v256;
        *(_QWORD *)(a3 + 16) = v253;
        if ( v255 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v255 - 3) & 1) != 0 )
              free(*(v255 - 1));
            v258 = v255 - 6;
            if ( (*(_BYTE *)(v255 - 6) & 1) != 0 )
              free(*(v255 - 4));
            v255 -= 6;
          }
          while ( v172 != v258 );
        }
        goto LABEL_500;
      case 'b':
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v5 = *(_QWORD *)(a3 + 8);
        v17 = *(_QWORD *)(a3 + 16);
        if ( v5 < v17 )
        {
          *(_BYTE *)v5 = 8;
          v9 = 1819242338;
          goto LABEL_54;
        }
        v88 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v89 = 0x555555555555555LL;
        if ( v88 + 1 > 0x555555555555555LL )
          abort();
        v90 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v17 - *(_QWORD *)a3) >> 4);
        if ( v90 >= 0x2AAAAAAAAAAAAAALL || ((v91 = 2 * v90, v91 >= v88 + 1) ? (v89 = v91) : (v89 = v88 + 1), v89) )
        {
          v92 = *(_QWORD *)(a3 + 24);
          v93 = *(char **)(v92 + 4096);
          if ( v92 + 4096 - (__int64)v93 >= (unsigned __int64)(48 * v89) )
            *(_QWORD *)(v92 + 4096) = &v93[48 * v89];
          else
            v93 = (char *)malloc(48 * v89);
        }
        else
        {
          v93 = 0;
        }
        v196 = &v93[48 * v88];
        *v196 = 8;
        strcpy(v196 + 1, "bool");
        v197 = &v93[48 * v89];
        *((_WORD *)v196 + 7) = v449[1];
        *((_QWORD *)v196 + 2) = 0;
        *(_QWORD *)(v196 + 6) = v449[0];
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        v196[24] = 0;
        *((_QWORD *)v196 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v196 + 5) = 0;
        *(_QWORD *)(v196 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v199 = *(void ***)a3;
        v198 = *(void ***)(a3 + 8);
        v200 = v196 + 48;
        if ( v198 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v196 - 4) = *(v198 - 4);
            *((_OWORD *)v196 - 3) = *((_OWORD *)v198 - 3);
            v201 = (__int64)*(v198 - 1);
            *(v198 - 5) = 0;
            *(v198 - 4) = 0;
            *(v198 - 6) = 0;
            *((_QWORD *)v196 - 1) = v201;
            *(_OWORD *)(v196 - 24) = *(_OWORD *)(v198 - 3);
            *(v198 - 3) = 0;
            *(v198 - 2) = 0;
            *(v198 - 1) = 0;
            v198 -= 6;
            v196 -= 48;
          }
          while ( v199 != v198 );
          v172 = *(void ***)a3;
          v199 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v196;
        *(_QWORD *)(a3 + 8) = v200;
        *(_QWORD *)(a3 + 16) = v197;
        if ( v199 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v199 - 3) & 1) != 0 )
              free(*(v199 - 1));
            v202 = v199 - 6;
            if ( (*(_BYTE *)(v199 - 6) & 1) != 0 )
              free(*(v199 - 4));
            v199 -= 6;
          }
          while ( v172 != v202 );
        }
        goto LABEL_500;
      case 'c':
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v5 = *(_QWORD *)(a3 + 8);
        v43 = *(_QWORD *)(a3 + 16);
        if ( v5 < v43 )
        {
          *(_BYTE *)v5 = 8;
          v9 = 1918986339;
          goto LABEL_54;
        }
        v112 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v113 = 0x555555555555555LL;
        if ( v112 + 1 > 0x555555555555555LL )
          abort();
        v114 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v43 - *(_QWORD *)a3) >> 4);
        if ( v114 >= 0x2AAAAAAAAAAAAAALL
          || ((v115 = 2 * v114, v115 >= v112 + 1) ? (v113 = v115) : (v113 = v112 + 1), v113) )
        {
          v116 = *(_QWORD *)(a3 + 24);
          v117 = *(char **)(v116 + 4096);
          if ( v116 + 4096 - (__int64)v117 >= (unsigned __int64)(48 * v113) )
            *(_QWORD *)(v116 + 4096) = &v117[48 * v113];
          else
            v117 = (char *)malloc(48 * v113);
        }
        else
        {
          v117 = 0;
        }
        v245 = &v117[48 * v112];
        *v245 = 8;
        strcpy(v245 + 1, "char");
        v246 = &v117[48 * v113];
        *((_WORD *)v245 + 7) = v449[1];
        *((_QWORD *)v245 + 2) = 0;
        *(_QWORD *)(v245 + 6) = v449[0];
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        v245[24] = 0;
        *((_QWORD *)v245 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v245 + 5) = 0;
        *(_QWORD *)(v245 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v248 = *(void ***)a3;
        v247 = *(void ***)(a3 + 8);
        v249 = v245 + 48;
        if ( v247 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v245 - 4) = *(v247 - 4);
            *((_OWORD *)v245 - 3) = *((_OWORD *)v247 - 3);
            v250 = (__int64)*(v247 - 1);
            *(v247 - 5) = 0;
            *(v247 - 4) = 0;
            *(v247 - 6) = 0;
            *((_QWORD *)v245 - 1) = v250;
            *(_OWORD *)(v245 - 24) = *(_OWORD *)(v247 - 3);
            *(v247 - 3) = 0;
            *(v247 - 2) = 0;
            *(v247 - 1) = 0;
            v247 -= 6;
            v245 -= 48;
          }
          while ( v248 != v247 );
          v172 = *(void ***)a3;
          v248 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v245;
        *(_QWORD *)(a3 + 8) = v249;
        *(_QWORD *)(a3 + 16) = v246;
        if ( v248 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v248 - 3) & 1) != 0 )
              free(*(v248 - 1));
            v251 = v248 - 6;
            if ( (*(_BYTE *)(v248 - 6) & 1) != 0 )
              free(*(v248 - 4));
            v248 -= 6;
          }
          while ( v172 != v251 );
        }
        goto LABEL_500;
      case 'd':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "double", 6);
        v5 = *(_QWORD *)(a3 + 8);
        v18 = *(_QWORD *)(a3 + 16);
        if ( v5 < v18 )
        {
          *(_BYTE *)v5 = 12;
          v3 = a1 + 1;
          *(_WORD *)(v5 + 5) = WORD2(v449[0]);
          *(_BYTE *)(v5 + 7) = 0;
          *(_QWORD *)(v5 + 8) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_DWORD *)(v5 + 1) = v449[0];
          goto LABEL_20;
        }
        v94 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v95 = 0x555555555555555LL;
        if ( v94 + 1 > 0x555555555555555LL )
          abort();
        v96 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v18 - *(_QWORD *)a3) >> 4);
        if ( v96 >= 0x2AAAAAAAAAAAAAALL || ((v97 = 2 * v96, v97 >= v94 + 1) ? (v95 = v97) : (v95 = v94 + 1), v95) )
        {
          v98 = *(_QWORD *)(a3 + 24);
          v99 = *(char **)(v98 + 4096);
          if ( v98 + 4096 - (__int64)v99 >= (unsigned __int64)(48 * v95) )
            *(_QWORD *)(v98 + 4096) = &v99[48 * v95];
          else
            v99 = (char *)malloc(48 * v95);
        }
        else
        {
          v99 = 0;
        }
        v203 = &v99[48 * v94];
        *v203 = 12;
        v204 = &v99[48 * v95];
        *(_WORD *)(v203 + 5) = WORD2(v449[0]);
        v203[7] = 0;
        *((_QWORD *)v203 + 1) = 0;
        *((_QWORD *)v203 + 2) = 0;
        *(_DWORD *)(v203 + 1) = v449[0];
        WORD2(v449[0]) = 0;
        LODWORD(v449[0]) = 0;
        v203[24] = 0;
        *((_QWORD *)v203 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v203 + 5) = 0;
        *(_QWORD *)(v203 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v206 = *(void ***)a3;
        v205 = *(void ***)(a3 + 8);
        v207 = v203 + 48;
        if ( v205 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v203 - 4) = *(v205 - 4);
            *((_OWORD *)v203 - 3) = *((_OWORD *)v205 - 3);
            v208 = (__int64)*(v205 - 1);
            *(v205 - 5) = 0;
            *(v205 - 4) = 0;
            *(v205 - 6) = 0;
            *((_QWORD *)v203 - 1) = v208;
            *(_OWORD *)(v203 - 24) = *(_OWORD *)(v205 - 3);
            *(v205 - 3) = 0;
            *(v205 - 2) = 0;
            *(v205 - 1) = 0;
            v205 -= 6;
            v203 -= 48;
          }
          while ( v206 != v205 );
          v172 = *(void ***)a3;
          v206 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v203;
        *(_QWORD *)(a3 + 8) = v207;
        *(_QWORD *)(a3 + 16) = v204;
        if ( v206 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v206 - 3) & 1) != 0 )
              free(*(v206 - 1));
            v209 = v206 - 6;
            if ( (*(_BYTE *)(v206 - 6) & 1) != 0 )
              free(*(v206 - 4));
            v206 -= 6;
          }
          while ( v172 != v209 );
        }
        goto LABEL_500;
      case 'e':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "long double", 11);
        v5 = *(_QWORD *)(a3 + 8);
        v35 = *(_QWORD *)(a3 + 16);
        if ( v5 < v35 )
        {
LABEL_57:
          *(_BYTE *)v5 = 22;
          v3 = a1 + 1;
          *(_BYTE *)(v5 + 11) = BYTE2(v449[1]);
          *(_WORD *)(v5 + 9) = v449[1];
          *(_BYTE *)(v5 + 12) = 0;
          *(_QWORD *)(v5 + 1) = v449[0];
          *(_BYTE *)(v5 + 15) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_WORD *)(v5 + 13) = 0;
          LOWORD(v449[1]) = 0;
          v449[0] = 0;
          BYTE2(v449[1]) = 0;
          goto LABEL_87;
        }
        v36 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v37 = 0x555555555555555LL;
        if ( v36 + 1 > 0x555555555555555LL )
          abort();
        v38 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v35 - *(_QWORD *)a3) >> 4);
        if ( v38 >= 0x2AAAAAAAAAAAAAALL || ((v39 = 2 * v38, v39 >= v36 + 1) ? (v37 = v39) : (v37 = v36 + 1), v37) )
        {
          v40 = *(_QWORD *)(a3 + 24);
          v41 = *(char **)(v40 + 4096);
          if ( v40 + 4096 - (__int64)v41 >= (unsigned __int64)(48 * v37) )
            *(_QWORD *)(v40 + 4096) = &v41[48 * v37];
          else
            v41 = (char *)malloc(48 * v37);
        }
        else
        {
          v41 = 0;
        }
        v231 = &v41[48 * v36];
        *v231 = 22;
        v232 = &v41[48 * v37];
        v231[11] = BYTE2(v449[1]);
        *(_WORD *)(v231 + 9) = v449[1];
        v231[12] = 0;
        *(_QWORD *)(v231 + 1) = v449[0];
        v231[15] = 0;
        *((_QWORD *)v231 + 2) = 0;
        *(_WORD *)(v231 + 13) = 0;
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        BYTE2(v449[1]) = 0;
        v231[24] = 0;
        *((_QWORD *)v231 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v231 + 5) = 0;
        *(_QWORD *)(v231 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v234 = *(void ***)a3;
        v233 = *(void ***)(a3 + 8);
        v235 = v231 + 48;
        if ( v233 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v231 - 4) = *(v233 - 4);
            *((_OWORD *)v231 - 3) = *((_OWORD *)v233 - 3);
            v236 = (__int64)*(v233 - 1);
            *(v233 - 5) = 0;
            *(v233 - 4) = 0;
            *(v233 - 6) = 0;
            *((_QWORD *)v231 - 1) = v236;
            *(_OWORD *)(v231 - 24) = *(_OWORD *)(v233 - 3);
            *(v233 - 3) = 0;
            *(v233 - 2) = 0;
            *(v233 - 1) = 0;
            v233 -= 6;
            v231 -= 48;
          }
          while ( v234 != v233 );
          v172 = *(void ***)a3;
          v234 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v231;
        *(_QWORD *)(a3 + 8) = v235;
        *(_QWORD *)(a3 + 16) = v232;
        if ( v234 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v234 - 3) & 1) != 0 )
              free(*(v234 - 1));
            v237 = v234 - 6;
            if ( (*(_BYTE *)(v234 - 6) & 1) != 0 )
              free(*(v234 - 4));
            v234 -= 6;
          }
          while ( v172 != v237 );
        }
        goto LABEL_500;
      case 'f':
        LOBYTE(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v447 = 1634692198;
        v5 = *(_QWORD *)(a3 + 8);
        v45 = *(_QWORD *)(a3 + 16);
        if ( v5 < v45 )
          goto LABEL_75;
        v46 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v47 = 0x555555555555555LL;
        if ( v46 + 1 > 0x555555555555555LL )
          abort();
        v48 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v45 - *(_QWORD *)a3) >> 4);
        if ( v48 >= 0x2AAAAAAAAAAAAAALL || ((v49 = 2 * v48, v49 >= v46 + 1) ? (v47 = v49) : (v47 = v46 + 1), v47) )
        {
          v50 = *(_QWORD *)(a3 + 24);
          v51 = *(char **)(v50 + 4096);
          if ( v50 + 4096 - (__int64)v51 >= (unsigned __int64)(48 * v47) )
            *(_QWORD *)(v50 + 4096) = &v51[48 * v47];
          else
            v51 = (char *)malloc(48 * v47);
        }
        else
        {
          v51 = 0;
        }
        v259 = &v51[48 * v46];
        *v259 = 10;
        v260 = &v51[48 * v47];
        v259[5] = 116;
        v259[6] = 0;
        *(_DWORD *)(v259 + 1) = 1634692198;
        v259[15] = v449[1];
        *((_QWORD *)v259 + 2) = 0;
        *(_QWORD *)(v259 + 7) = v449[0];
        LOBYTE(v449[1]) = 0;
        v449[0] = 0;
        v259[24] = 0;
        *((_QWORD *)v259 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v259 + 5) = 0;
        *(_QWORD *)(v259 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v262 = *(void ***)a3;
        v261 = *(void ***)(a3 + 8);
        v263 = v259 + 48;
        if ( v261 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v259 - 4) = *(v261 - 4);
            *((_OWORD *)v259 - 3) = *((_OWORD *)v261 - 3);
            v264 = (__int64)*(v261 - 1);
            *(v261 - 5) = 0;
            *(v261 - 4) = 0;
            *(v261 - 6) = 0;
            *((_QWORD *)v259 - 1) = v264;
            *(_OWORD *)(v259 - 24) = *(_OWORD *)(v261 - 3);
            *(v261 - 3) = 0;
            *(v261 - 2) = 0;
            *(v261 - 1) = 0;
            v261 -= 6;
            v259 -= 48;
          }
          while ( v262 != v261 );
          v172 = *(void ***)a3;
          v262 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v259;
        *(_QWORD *)(a3 + 8) = v263;
        *(_QWORD *)(a3 + 16) = v260;
        if ( v262 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v262 - 3) & 1) != 0 )
              free(*(v262 - 1));
            v265 = v262 - 6;
            if ( (*(_BYTE *)(v262 - 6) & 1) != 0 )
              free(*(v262 - 4));
            v262 -= 6;
          }
          while ( v172 != v265 );
        }
        goto LABEL_500;
      case 'g':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "__float128", 10);
        v5 = *(_QWORD *)(a3 + 8);
        v52 = *(_QWORD *)(a3 + 16);
        if ( v5 < v52 )
        {
          *(_BYTE *)v5 = 20;
          v53 = v449[1];
          v3 = a1 + 1;
LABEL_69:
          *(_WORD *)(v5 + 9) = v53;
          *(_BYTE *)(v5 + 11) = 0;
          *(_DWORD *)(v5 + 12) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_QWORD *)(v5 + 1) = v449[0];
          goto LABEL_70;
        }
        v124 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v125 = 0x555555555555555LL;
        if ( v124 + 1 > 0x555555555555555LL )
          abort();
        v126 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v52 - *(_QWORD *)a3) >> 4);
        if ( v126 >= 0x2AAAAAAAAAAAAAALL
          || ((v127 = 2 * v126, v127 >= v124 + 1) ? (v125 = v127) : (v125 = v124 + 1), v125) )
        {
          v128 = *(_QWORD *)(a3 + 24);
          v129 = *(char **)(v128 + 4096);
          if ( v128 + 4096 - (__int64)v129 >= (unsigned __int64)(48 * v125) )
            *(_QWORD *)(v128 + 4096) = &v129[48 * v125];
          else
            v129 = (char *)malloc(48 * v125);
        }
        else
        {
          v129 = 0;
        }
        v266 = &v129[48 * v124];
        *v266 = 20;
        v267 = &v129[48 * v125];
        *(_WORD *)(v266 + 9) = v449[1];
        v266[11] = 0;
        *((_DWORD *)v266 + 3) = 0;
        *((_QWORD *)v266 + 2) = 0;
        *(_QWORD *)(v266 + 1) = v449[0];
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        v266[24] = 0;
        *((_QWORD *)v266 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v266 + 5) = 0;
        *(_QWORD *)(v266 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v269 = *(void ***)a3;
        v268 = *(void ***)(a3 + 8);
        v270 = v266 + 48;
        if ( v268 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v266 - 4) = *(v268 - 4);
            *((_OWORD *)v266 - 3) = *((_OWORD *)v268 - 3);
            v271 = (__int64)*(v268 - 1);
            *(v268 - 5) = 0;
            *(v268 - 4) = 0;
            *(v268 - 6) = 0;
            *((_QWORD *)v266 - 1) = v271;
            *(_OWORD *)(v266 - 24) = *(_OWORD *)(v268 - 3);
            *(v268 - 3) = 0;
            *(v268 - 2) = 0;
            *(v268 - 1) = 0;
            v268 -= 6;
            v266 -= 48;
          }
          while ( v269 != v268 );
          v172 = *(void ***)a3;
          v269 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v266;
        *(_QWORD *)(a3 + 8) = v270;
        *(_QWORD *)(a3 + 16) = v267;
        if ( v269 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v269 - 3) & 1) != 0 )
              free(*(v269 - 1));
            v272 = v269 - 6;
            if ( (*(_BYTE *)(v269 - 6) & 1) != 0 )
              free(*(v269 - 4));
            v269 -= 6;
          }
          while ( v172 != v272 );
        }
        goto LABEL_500;
      case 'h':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "unsigned char", 13);
        v5 = *(_QWORD *)(a3 + 8);
        v57 = *(_QWORD *)(a3 + 16);
        if ( v5 < v57 )
          goto LABEL_79;
        v148 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v149 = 0x555555555555555LL;
        if ( v148 + 1 > 0x555555555555555LL )
          abort();
        v150 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v57 - *(_QWORD *)a3) >> 4);
        if ( v150 >= 0x2AAAAAAAAAAAAAALL
          || ((v151 = 2 * v150, v151 >= v148 + 1) ? (v149 = v151) : (v149 = v148 + 1), v149) )
        {
          v152 = *(_QWORD *)(a3 + 24);
          v153 = *(char **)(v152 + 4096);
          if ( v152 + 4096 - (__int64)v153 >= (unsigned __int64)(48 * v149) )
            *(_QWORD *)(v152 + 4096) = &v153[48 * v149];
          else
            v153 = (char *)malloc(48 * v149);
        }
        else
        {
          v153 = 0;
        }
        v294 = &v153[48 * v148];
        *v294 = 26;
        v295 = &v153[48 * v149];
        *(_QWORD *)(v294 + 6) = *(_QWORD *)((char *)v449 + 5);
        *((_WORD *)v294 + 7) = 0;
        *((_QWORD *)v294 + 2) = 0;
        *(_QWORD *)(v294 + 1) = v449[0];
        *(_QWORD *)((char *)v449 + 5) = 0;
        v449[0] = 0;
        v294[24] = 0;
        *((_QWORD *)v294 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v294 + 5) = 0;
        *(_QWORD *)(v294 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v297 = *(void ***)a3;
        v296 = *(void ***)(a3 + 8);
        v298 = v294 + 48;
        if ( v296 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v294 - 4) = *(v296 - 4);
            *((_OWORD *)v294 - 3) = *((_OWORD *)v296 - 3);
            v299 = (__int64)*(v296 - 1);
            *(v296 - 5) = 0;
            *(v296 - 4) = 0;
            *(v296 - 6) = 0;
            *((_QWORD *)v294 - 1) = v299;
            *(_OWORD *)(v294 - 24) = *(_OWORD *)(v296 - 3);
            *(v296 - 3) = 0;
            *(v296 - 2) = 0;
            *(v296 - 1) = 0;
            v296 -= 6;
            v294 -= 48;
          }
          while ( v297 != v296 );
          v172 = *(void ***)a3;
          v297 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v294;
        *(_QWORD *)(a3 + 8) = v298;
        *(_QWORD *)(a3 + 16) = v295;
        if ( v297 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v297 - 3) & 1) != 0 )
              free(*(v297 - 1));
            v300 = v297 - 6;
            if ( (*(_BYTE *)(v297 - 6) & 1) != 0 )
              free(*(v297 - 4));
            v297 -= 6;
          }
          while ( v172 != v300 );
        }
        goto LABEL_500;
      case 'i':
        BYTE2(v449[1]) = 0;
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v448 = 116;
        v446 = 28265;
        v19 = *(_QWORD *)(a3 + 8);
        v56 = *(_QWORD *)(a3 + 16);
        if ( v19 < v56 )
          goto LABEL_77;
        v142 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v19 - *(_QWORD *)a3) >> 4);
        v143 = 0x555555555555555LL;
        if ( v142 + 1 > 0x555555555555555LL )
          abort();
        v144 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v56 - *(_QWORD *)a3) >> 4);
        if ( v144 >= 0x2AAAAAAAAAAAAAALL
          || ((v145 = 2 * v144, v145 >= v142 + 1) ? (v143 = v145) : (v143 = v142 + 1), v143) )
        {
          v146 = *(_QWORD *)(a3 + 24);
          v147 = *(char **)(v146 + 4096);
          if ( v146 + 4096 - (__int64)v147 >= (unsigned __int64)(48 * v143) )
            *(_QWORD *)(v146 + 4096) = &v147[48 * v143];
          else
            v147 = (char *)malloc(48 * v143);
        }
        else
        {
          v147 = 0;
        }
        v287 = &v147[48 * v142];
        *v287 = 6;
        v288 = &v147[48 * v143];
        *(_WORD *)(v287 + 1) = 28265;
        v287[4] = 0;
        v287[3] = 116;
        v287[15] = BYTE2(v449[1]);
        *(_WORD *)(v287 + 13) = v449[1];
        *((_QWORD *)v287 + 2) = 0;
        *(_QWORD *)(v287 + 5) = v449[0];
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        BYTE2(v449[1]) = 0;
        v287[24] = 0;
        *((_QWORD *)v287 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v287 + 5) = 0;
        *(_QWORD *)(v287 + 25) = v450[0];
        v450[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v290 = *(void ***)a3;
        v289 = *(void ***)(a3 + 8);
        v291 = v287 + 48;
        if ( v289 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v287 - 4) = *(v289 - 4);
            *((_OWORD *)v287 - 3) = *((_OWORD *)v289 - 3);
            v292 = (__int64)*(v289 - 1);
            *(v289 - 5) = 0;
            *(v289 - 4) = 0;
            *(v289 - 6) = 0;
            *((_QWORD *)v287 - 1) = v292;
            *(_OWORD *)(v287 - 24) = *(_OWORD *)(v289 - 3);
            *(v289 - 3) = 0;
            *(v289 - 2) = 0;
            *(v289 - 1) = 0;
            v289 -= 6;
            v287 -= 48;
          }
          while ( v290 != v289 );
          v172 = *(void ***)a3;
          v290 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v287;
        *(_QWORD *)(a3 + 8) = v291;
        *(_QWORD *)(a3 + 16) = v288;
        if ( v290 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v290 - 3) & 1) != 0 )
              free(*(v290 - 1));
            v293 = v290 - 6;
            if ( (*(_BYTE *)(v290 - 6) & 1) != 0 )
              free(*(v290 - 4));
            v290 -= 6;
          }
          while ( v172 != v293 );
        }
        goto LABEL_500;
      case 'j':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "unsigned int", 12);
        v5 = *(_QWORD *)(a3 + 8);
        v16 = *(_QWORD *)(a3 + 16);
        if ( v5 < v16 )
        {
          *(_BYTE *)v5 = 24;
          v3 = a1 + 1;
          *(_DWORD *)(v5 + 9) = v449[1];
          *(_BYTE *)(v5 + 13) = 0;
          *(_WORD *)(v5 + 14) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_QWORD *)(v5 + 1) = v449[0];
          LODWORD(v449[1]) = 0;
          goto LABEL_86;
        }
        v82 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v83 = 0x555555555555555LL;
        if ( v82 + 1 > 0x555555555555555LL )
          abort();
        v84 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - *(_QWORD *)a3) >> 4);
        if ( v84 >= 0x2AAAAAAAAAAAAAALL || ((v85 = 2 * v84, v85 >= v82 + 1) ? (v83 = v85) : (v83 = v82 + 1), v83) )
        {
          v86 = *(_QWORD *)(a3 + 24);
          v87 = *(char **)(v86 + 4096);
          if ( v86 + 4096 - (__int64)v87 >= (unsigned __int64)(48 * v83) )
            *(_QWORD *)(v86 + 4096) = &v87[48 * v83];
          else
            v87 = (char *)malloc(48 * v83);
        }
        else
        {
          v87 = 0;
        }
        v189 = &v87[48 * v82];
        *v189 = 24;
        v190 = &v87[48 * v83];
        *(_DWORD *)(v189 + 9) = v449[1];
        v189[13] = 0;
        *((_WORD *)v189 + 7) = 0;
        *((_QWORD *)v189 + 2) = 0;
        *(_QWORD *)(v189 + 1) = v449[0];
        LODWORD(v449[1]) = 0;
        v449[0] = 0;
        v189[24] = 0;
        *((_QWORD *)v189 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v189 + 5) = 0;
        *(_QWORD *)(v189 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v192 = *(void ***)a3;
        v191 = *(void ***)(a3 + 8);
        v193 = v189 + 48;
        if ( v191 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v189 - 4) = *(v191 - 4);
            *((_OWORD *)v189 - 3) = *((_OWORD *)v191 - 3);
            v194 = (__int64)*(v191 - 1);
            *(v191 - 5) = 0;
            *(v191 - 4) = 0;
            *(v191 - 6) = 0;
            *((_QWORD *)v189 - 1) = v194;
            *(_OWORD *)(v189 - 24) = *(_OWORD *)(v191 - 3);
            *(v191 - 3) = 0;
            *(v191 - 2) = 0;
            *(v191 - 1) = 0;
            v191 -= 6;
            v189 -= 48;
          }
          while ( v192 != v191 );
          v172 = *(void ***)a3;
          v192 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v189;
        *(_QWORD *)(a3 + 8) = v193;
        *(_QWORD *)(a3 + 16) = v190;
        if ( v192 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v192 - 3) & 1) != 0 )
              free(*(v192 - 1));
            v195 = v192 - 6;
            if ( (*(_BYTE *)(v192 - 6) & 1) != 0 )
              free(*(v192 - 4));
            v192 -= 6;
          }
          while ( v172 != v195 );
        }
        goto LABEL_500;
      case 'l':
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v5 = *(_QWORD *)(a3 + 8);
        v42 = *(_QWORD *)(a3 + 16);
        if ( v5 < v42 )
        {
          *(_BYTE *)v5 = 8;
          v9 = 1735290732;
          goto LABEL_54;
        }
        v106 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v107 = 0x555555555555555LL;
        if ( v106 + 1 > 0x555555555555555LL )
          abort();
        v108 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v42 - *(_QWORD *)a3) >> 4);
        if ( v108 >= 0x2AAAAAAAAAAAAAALL
          || ((v109 = 2 * v108, v109 >= v106 + 1) ? (v107 = v109) : (v107 = v106 + 1), v107) )
        {
          v110 = *(_QWORD *)(a3 + 24);
          v111 = *(char **)(v110 + 4096);
          if ( v110 + 4096 - (__int64)v111 >= (unsigned __int64)(48 * v107) )
            *(_QWORD *)(v110 + 4096) = &v111[48 * v107];
          else
            v111 = (char *)malloc(48 * v107);
        }
        else
        {
          v111 = 0;
        }
        v238 = &v111[48 * v106];
        *v238 = 8;
        strcpy(v238 + 1, "long");
        v239 = &v111[48 * v107];
        *((_WORD *)v238 + 7) = v449[1];
        *((_QWORD *)v238 + 2) = 0;
        *(_QWORD *)(v238 + 6) = v449[0];
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        v238[24] = 0;
        *((_QWORD *)v238 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v238 + 5) = 0;
        *(_QWORD *)(v238 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v241 = *(void ***)a3;
        v240 = *(void ***)(a3 + 8);
        v242 = v238 + 48;
        if ( v240 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v238 - 4) = *(v240 - 4);
            *((_OWORD *)v238 - 3) = *((_OWORD *)v240 - 3);
            v243 = (__int64)*(v240 - 1);
            *(v240 - 5) = 0;
            *(v240 - 4) = 0;
            *(v240 - 6) = 0;
            *((_QWORD *)v238 - 1) = v243;
            *(_OWORD *)(v238 - 24) = *(_OWORD *)(v240 - 3);
            *(v240 - 3) = 0;
            *(v240 - 2) = 0;
            *(v240 - 1) = 0;
            v240 -= 6;
            v238 -= 48;
          }
          while ( v241 != v240 );
          v172 = *(void ***)a3;
          v241 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v238;
        *(_QWORD *)(a3 + 8) = v242;
        *(_QWORD *)(a3 + 16) = v239;
        if ( v241 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v241 - 3) & 1) != 0 )
              free(*(v241 - 1));
            v244 = v241 - 6;
            if ( (*(_BYTE *)(v241 - 6) & 1) != 0 )
              free(*(v241 - 4));
            v241 -= 6;
          }
          while ( v172 != v244 );
        }
        goto LABEL_500;
      case 'm':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "unsigned long", 13);
        v5 = *(_QWORD *)(a3 + 8);
        v27 = *(_QWORD *)(a3 + 16);
        if ( v5 < v27 )
        {
LABEL_79:
          *(_BYTE *)v5 = 26;
          v3 = a1 + 1;
          *(_QWORD *)(v5 + 6) = *(_QWORD *)((char *)v449 + 5);
          *(_WORD *)(v5 + 14) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_QWORD *)(v5 + 1) = v449[0];
          *(_QWORD *)((char *)v449 + 5) = 0;
          goto LABEL_86;
        }
        v28 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v29 = 0x555555555555555LL;
        if ( v28 + 1 > 0x555555555555555LL )
          abort();
        v30 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v27 - *(_QWORD *)a3) >> 4);
        if ( v30 >= 0x2AAAAAAAAAAAAAALL || ((v31 = 2 * v30, v31 >= v28 + 1) ? (v29 = v31) : (v29 = v28 + 1), v29) )
        {
          v32 = *(_QWORD *)(a3 + 24);
          v33 = *(char **)(v32 + 4096);
          if ( v32 + 4096 - (__int64)v33 >= (unsigned __int64)(48 * v29) )
            *(_QWORD *)(v32 + 4096) = &v33[48 * v29];
          else
            v33 = (char *)malloc(48 * v29);
        }
        else
        {
          v33 = 0;
        }
        v217 = &v33[48 * v28];
        *v217 = 26;
        v218 = &v33[48 * v29];
        *(_QWORD *)(v217 + 6) = *(_QWORD *)((char *)v449 + 5);
        *((_WORD *)v217 + 7) = 0;
        *((_QWORD *)v217 + 2) = 0;
        *(_QWORD *)(v217 + 1) = v449[0];
        *(_QWORD *)((char *)v449 + 5) = 0;
        v449[0] = 0;
        v217[24] = 0;
        *((_QWORD *)v217 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v217 + 5) = 0;
        *(_QWORD *)(v217 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v220 = *(void ***)a3;
        v219 = *(void ***)(a3 + 8);
        v221 = v217 + 48;
        if ( v219 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v217 - 4) = *(v219 - 4);
            *((_OWORD *)v217 - 3) = *((_OWORD *)v219 - 3);
            v222 = (__int64)*(v219 - 1);
            *(v219 - 5) = 0;
            *(v219 - 4) = 0;
            *(v219 - 6) = 0;
            *((_QWORD *)v217 - 1) = v222;
            *(_OWORD *)(v217 - 24) = *(_OWORD *)(v219 - 3);
            *(v219 - 3) = 0;
            *(v219 - 2) = 0;
            *(v219 - 1) = 0;
            v219 -= 6;
            v217 -= 48;
          }
          while ( v220 != v219 );
          v172 = *(void ***)a3;
          v220 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v217;
        *(_QWORD *)(a3 + 8) = v221;
        *(_QWORD *)(a3 + 16) = v218;
        if ( v220 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v220 - 3) & 1) != 0 )
              free(*(v220 - 1));
            v223 = v220 - 6;
            if ( (*(_BYTE *)(v220 - 6) & 1) != 0 )
              free(*(v220 - 4));
            v220 -= 6;
          }
          while ( v172 != v223 );
        }
        goto LABEL_500;
      case 'n':
        WORD2(v449[0]) = 0;
        LODWORD(v449[0]) = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v5 = *(_QWORD *)(a3 + 8);
        v14 = *(_QWORD *)(a3 + 16);
        if ( v5 >= v14 )
        {
          v76 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v77 = 0x555555555555555LL;
          if ( v76 + 1 > 0x555555555555555LL )
            abort();
          v78 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v14 - *(_QWORD *)a3) >> 4);
          if ( v78 >= 0x2AAAAAAAAAAAAAALL || ((v79 = 2 * v78, v79 >= v76 + 1) ? (v77 = v79) : (v77 = v76 + 1), v77) )
          {
            v80 = *(_QWORD *)(a3 + 24);
            v81 = *(char **)(v80 + 4096);
            if ( v80 + 4096 - (__int64)v81 >= (unsigned __int64)(48 * v77) )
              *(_QWORD *)(v80 + 4096) = &v81[48 * v77];
            else
              v81 = (char *)malloc(48 * v77);
          }
          else
          {
            v81 = 0;
          }
          v182 = &v81[48 * v76];
          *v182 = 16;
          strcpy(v182 + 1, "__int128");
          v183 = &v81[48 * v77];
          *((_WORD *)v182 + 7) = WORD2(v449[0]);
          *((_QWORD *)v182 + 2) = 0;
          *(_DWORD *)(v182 + 10) = v449[0];
          WORD2(v449[0]) = 0;
          LODWORD(v449[0]) = 0;
          v182[24] = 0;
          *((_QWORD *)v182 + 4) = *(_QWORD *)((char *)v450 + 7);
          *((_QWORD *)v182 + 5) = 0;
          *(_QWORD *)(v182 + 25) = v450[0];
          *(_QWORD *)((char *)v450 + 7) = 0;
          v450[0] = 0;
          v185 = *(void ***)a3;
          v184 = *(void ***)(a3 + 8);
          v186 = v182 + 48;
          if ( v184 == *(void ***)a3 )
          {
            v172 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v182 - 4) = *(v184 - 4);
              *((_OWORD *)v182 - 3) = *((_OWORD *)v184 - 3);
              v187 = (__int64)*(v184 - 1);
              *(v184 - 5) = 0;
              *(v184 - 4) = 0;
              *(v184 - 6) = 0;
              *((_QWORD *)v182 - 1) = v187;
              *(_OWORD *)(v182 - 24) = *(_OWORD *)(v184 - 3);
              *(v184 - 3) = 0;
              *(v184 - 2) = 0;
              *(v184 - 1) = 0;
              v184 -= 6;
              v182 -= 48;
            }
            while ( v185 != v184 );
            v172 = *(void ***)a3;
            v185 = *(void ***)(a3 + 8);
          }
          v173 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v182;
          *(_QWORD *)(a3 + 8) = v186;
          *(_QWORD *)(a3 + 16) = v183;
          if ( v185 != v172 )
          {
            do
            {
              if ( (*(_BYTE *)(v185 - 3) & 1) != 0 )
                free(*(v185 - 1));
              v188 = v185 - 6;
              if ( (*(_BYTE *)(v185 - 6) & 1) != 0 )
                free(*(v185 - 4));
              v185 -= 6;
            }
            while ( v172 != v188 );
          }
          goto LABEL_500;
        }
        *(_BYTE *)v5 = 16;
        strcpy((char *)(v5 + 1), "__int128");
        v15 = WORD2(v449[0]);
        v3 = a1 + 1;
LABEL_13:
        *(_WORD *)(v5 + 14) = v15;
        *(_QWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 10) = v449[0];
LABEL_20:
        WORD2(v449[0]) = 0;
        LODWORD(v449[0]) = 0;
        goto LABEL_87;
      case 'o':
        memset(v449, 0, 15);
        qmemcpy(v450, "unsigned __int1", 15);
        v10 = *(_QWORD *)(a3 + 8);
        v54 = *(_QWORD *)(a3 + 16);
        if ( v10 < v54 )
        {
          *(_BYTE *)v10 = 34;
          v12 = *(_QWORD *)((char *)v450 + 7);
          v13 = 14386;
          goto LABEL_73;
        }
        v130 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v10 - *(_QWORD *)a3) >> 4);
        v131 = 0x555555555555555LL;
        if ( v130 + 1 > 0x555555555555555LL )
          abort();
        v132 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v54 - *(_QWORD *)a3) >> 4);
        if ( v132 >= 0x2AAAAAAAAAAAAAALL
          || ((v133 = 2 * v132, v133 >= v130 + 1) ? (v131 = v133) : (v131 = v130 + 1), v131) )
        {
          v134 = *(_QWORD *)(a3 + 24);
          v135 = *(char **)(v134 + 4096);
          if ( v134 + 4096 - (__int64)v135 >= (unsigned __int64)(48 * v131) )
            *(_QWORD *)(v134 + 4096) = &v135[48 * v131];
          else
            v135 = (char *)malloc(48 * v131);
        }
        else
        {
          v135 = 0;
        }
        v273 = &v135[48 * v130];
        *v273 = 34;
        v274 = &v135[48 * v131];
        *((_QWORD *)v273 + 1) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v273 + 2) = 14386;
        *(_QWORD *)(v273 + 1) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v273[24] = 0;
        *((_QWORD *)v273 + 4) = *(_QWORD *)((char *)v449 + 7);
        *((_QWORD *)v273 + 5) = 0;
        *(_QWORD *)(v273 + 25) = v449[0];
        memset(v449, 0, 15);
        v276 = *(void ***)a3;
        v275 = *(void ***)(a3 + 8);
        v277 = v273 + 48;
        if ( v275 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v273 - 4) = *(v275 - 4);
            *((_OWORD *)v273 - 3) = *((_OWORD *)v275 - 3);
            v278 = (__int64)*(v275 - 1);
            *(v275 - 5) = 0;
            *(v275 - 4) = 0;
            *(v275 - 6) = 0;
            *((_QWORD *)v273 - 1) = v278;
            *(_OWORD *)(v273 - 24) = *(_OWORD *)(v275 - 3);
            *(v275 - 3) = 0;
            *(v275 - 2) = 0;
            *(v275 - 1) = 0;
            v275 -= 6;
            v273 -= 48;
          }
          while ( v276 != v275 );
          v172 = *(void ***)a3;
          v276 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v273;
        *(_QWORD *)(a3 + 8) = v277;
        *(_QWORD *)(a3 + 16) = v274;
        if ( v276 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v276 - 3) & 1) != 0 )
              free(*(v276 - 1));
            v279 = v276 - 6;
            if ( (*(_BYTE *)(v276 - 6) & 1) != 0 )
              free(*(v276 - 4));
            v276 -= 6;
          }
          while ( v172 != v279 );
        }
        goto LABEL_500;
      case 's':
        LOBYTE(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v447 = 1919903859;
        v5 = *(_QWORD *)(a3 + 8);
        v55 = *(_QWORD *)(a3 + 16);
        if ( v5 < v55 )
        {
LABEL_75:
          *(_BYTE *)v5 = 10;
          v3 = a1 + 1;
          *(_BYTE *)(v5 + 5) = 116;
          *(_BYTE *)(v5 + 6) = 0;
          *(_DWORD *)(v5 + 1) = v447;
          *(_BYTE *)(v5 + 15) = v449[1];
          *(_QWORD *)(v5 + 16) = 0;
          *(_QWORD *)(v5 + 7) = v449[0];
          LOBYTE(v449[1]) = 0;
          goto LABEL_86;
        }
        v136 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v137 = 0x555555555555555LL;
        if ( v136 + 1 > 0x555555555555555LL )
          abort();
        v138 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v55 - *(_QWORD *)a3) >> 4);
        if ( v138 >= 0x2AAAAAAAAAAAAAALL
          || ((v139 = 2 * v138, v139 >= v136 + 1) ? (v137 = v139) : (v137 = v136 + 1), v137) )
        {
          v140 = *(_QWORD *)(a3 + 24);
          v141 = *(char **)(v140 + 4096);
          if ( v140 + 4096 - (__int64)v141 >= (unsigned __int64)(48 * v137) )
            *(_QWORD *)(v140 + 4096) = &v141[48 * v137];
          else
            v141 = (char *)malloc(48 * v137);
        }
        else
        {
          v141 = 0;
        }
        v280 = &v141[48 * v136];
        *v280 = 10;
        v281 = &v141[48 * v137];
        v280[5] = 116;
        v280[6] = 0;
        *(_DWORD *)(v280 + 1) = 1919903859;
        v280[15] = v449[1];
        *((_QWORD *)v280 + 2) = 0;
        *(_QWORD *)(v280 + 7) = v449[0];
        LOBYTE(v449[1]) = 0;
        v449[0] = 0;
        v280[24] = 0;
        *((_QWORD *)v280 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v280 + 5) = 0;
        *(_QWORD *)(v280 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v283 = *(void ***)a3;
        v282 = *(void ***)(a3 + 8);
        v284 = v280 + 48;
        if ( v282 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v280 - 4) = *(v282 - 4);
            *((_OWORD *)v280 - 3) = *((_OWORD *)v282 - 3);
            v285 = (__int64)*(v282 - 1);
            *(v282 - 5) = 0;
            *(v282 - 4) = 0;
            *(v282 - 6) = 0;
            *((_QWORD *)v280 - 1) = v285;
            *(_OWORD *)(v280 - 24) = *(_OWORD *)(v282 - 3);
            *(v282 - 3) = 0;
            *(v282 - 2) = 0;
            *(v282 - 1) = 0;
            v282 -= 6;
            v280 -= 48;
          }
          while ( v283 != v282 );
          v172 = *(void ***)a3;
          v283 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v280;
        *(_QWORD *)(a3 + 8) = v284;
        *(_QWORD *)(a3 + 16) = v281;
        if ( v283 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v283 - 3) & 1) != 0 )
              free(*(v283 - 1));
            v286 = v283 - 6;
            if ( (*(_BYTE *)(v283 - 6) & 1) != 0 )
              free(*(v283 - 4));
            v283 -= 6;
          }
          while ( v172 != v286 );
        }
        goto LABEL_500;
      case 't':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "unsigned short", 14);
        v5 = *(_QWORD *)(a3 + 8);
        v60 = *(_QWORD *)(a3 + 16);
        if ( v5 < v60 )
        {
          *(_BYTE *)v5 = 28;
          v61 = *(_QWORD *)((char *)v449 + 6);
          v3 = a1 + 1;
LABEL_85:
          *(_QWORD *)(v5 + 7) = v61;
          *(_BYTE *)(v5 + 15) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_QWORD *)(v5 + 1) = v449[0];
          *(_QWORD *)((char *)v449 + 6) = 0;
          goto LABEL_86;
        }
        v154 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v155 = 0x555555555555555LL;
        if ( v154 + 1 > 0x555555555555555LL )
          abort();
        v156 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v60 - *(_QWORD *)a3) >> 4);
        if ( v156 >= 0x2AAAAAAAAAAAAAALL
          || ((v157 = 2 * v156, v157 >= v154 + 1) ? (v155 = v157) : (v155 = v154 + 1), v155) )
        {
          v158 = *(_QWORD *)(a3 + 24);
          v159 = *(char **)(v158 + 4096);
          if ( v158 + 4096 - (__int64)v159 >= (unsigned __int64)(48 * v155) )
            *(_QWORD *)(v158 + 4096) = &v159[48 * v155];
          else
            v159 = (char *)malloc(48 * v155);
        }
        else
        {
          v159 = 0;
        }
        v301 = &v159[48 * v154];
        *v301 = 28;
        v302 = &v159[48 * v155];
        *(_QWORD *)(v301 + 7) = *(_QWORD *)((char *)v449 + 6);
        v301[15] = 0;
        *((_QWORD *)v301 + 2) = 0;
        *(_QWORD *)(v301 + 1) = v449[0];
        *(_QWORD *)((char *)v449 + 6) = 0;
        v449[0] = 0;
        v301[24] = 0;
        *((_QWORD *)v301 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v301 + 5) = 0;
        *(_QWORD *)(v301 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v304 = *(void ***)a3;
        v303 = *(void ***)(a3 + 8);
        v305 = v301 + 48;
        if ( v303 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v301 - 4) = *(v303 - 4);
            *((_OWORD *)v301 - 3) = *((_OWORD *)v303 - 3);
            v306 = (__int64)*(v303 - 1);
            *(v303 - 5) = 0;
            *(v303 - 4) = 0;
            *(v303 - 6) = 0;
            *((_QWORD *)v301 - 1) = v306;
            *(_OWORD *)(v301 - 24) = *(_OWORD *)(v303 - 3);
            *(v303 - 3) = 0;
            *(v303 - 2) = 0;
            *(v303 - 1) = 0;
            v303 -= 6;
            v301 -= 48;
          }
          while ( v304 != v303 );
          v172 = *(void ***)a3;
          v304 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v301;
        *(_QWORD *)(a3 + 8) = v305;
        *(_QWORD *)(a3 + 16) = v302;
        if ( v304 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v304 - 3) & 1) != 0 )
              free(*(v304 - 1));
            v307 = v304 - 6;
            if ( (*(_BYTE *)(v304 - 6) & 1) != 0 )
              free(*(v304 - 4));
            v304 -= 6;
          }
          while ( v172 != v307 );
        }
        goto LABEL_500;
      case 'u':
        v58 = a1 + 1;
        v59 = sub_57438(a1 + 1, a2, (void **)a3);
        if ( v59 != v58 )
          return v59;
        return v3;
      case 'v':
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v5 = *(_QWORD *)(a3 + 8);
        v8 = *(_QWORD *)(a3 + 16);
        if ( v5 >= v8 )
        {
          v64 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v65 = 0x555555555555555LL;
          if ( v64 + 1 > 0x555555555555555LL )
            abort();
          v66 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v8 - *(_QWORD *)a3) >> 4);
          if ( v66 >= 0x2AAAAAAAAAAAAAALL || ((v67 = 2 * v66, v67 >= v64 + 1) ? (v65 = v67) : (v65 = v64 + 1), v65) )
          {
            v68 = *(_QWORD *)(a3 + 24);
            v69 = *(char **)(v68 + 4096);
            if ( v68 + 4096 - (__int64)v69 >= (unsigned __int64)(48 * v65) )
              *(_QWORD *)(v68 + 4096) = &v69[48 * v65];
            else
              v69 = (char *)malloc(48 * v65);
          }
          else
          {
            v69 = 0;
          }
          v166 = &v69[48 * v64];
          *v166 = 8;
          strcpy(v166 + 1, "void");
          v167 = &v69[48 * v65];
          *((_WORD *)v166 + 7) = v449[1];
          *((_QWORD *)v166 + 2) = 0;
          *(_QWORD *)(v166 + 6) = v449[0];
          LOWORD(v449[1]) = 0;
          v449[0] = 0;
          v166[24] = 0;
          *((_QWORD *)v166 + 4) = *(_QWORD *)((char *)v450 + 7);
          *((_QWORD *)v166 + 5) = 0;
          *(_QWORD *)(v166 + 25) = v450[0];
          *(_QWORD *)((char *)v450 + 7) = 0;
          v450[0] = 0;
          v169 = *(void ***)a3;
          v168 = *(void ***)(a3 + 8);
          v170 = v166 + 48;
          if ( v168 == *(void ***)a3 )
          {
            v172 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v166 - 4) = *(v168 - 4);
              *((_OWORD *)v166 - 3) = *((_OWORD *)v168 - 3);
              v171 = (__int64)*(v168 - 1);
              *(v168 - 5) = 0;
              *(v168 - 4) = 0;
              *(v168 - 6) = 0;
              *((_QWORD *)v166 - 1) = v171;
              *(_OWORD *)(v166 - 24) = *(_OWORD *)(v168 - 3);
              *(v168 - 3) = 0;
              *(v168 - 2) = 0;
              *(v168 - 1) = 0;
              v168 -= 6;
              v166 -= 48;
            }
            while ( v169 != v168 );
            v172 = *(void ***)a3;
            v169 = *(void ***)(a3 + 8);
          }
          v173 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v166;
          *(_QWORD *)(a3 + 8) = v170;
          *(_QWORD *)(a3 + 16) = v167;
          if ( v169 != v172 )
          {
            do
            {
              if ( (*(_BYTE *)(v169 - 3) & 1) != 0 )
                free(*(v169 - 1));
              v174 = v169 - 6;
              if ( (*(_BYTE *)(v169 - 6) & 1) != 0 )
                free(*(v169 - 4));
              v169 -= 6;
            }
            while ( v172 != v174 );
          }
          goto LABEL_500;
        }
        *(_BYTE *)v5 = 8;
        v9 = 1684631414;
LABEL_54:
        *(_BYTE *)(v5 + 5) = 0;
        *(_DWORD *)(v5 + 1) = v9;
        v7 = v449[1];
        v3 = a1 + 1;
LABEL_55:
        *(_WORD *)(v5 + 14) = v7;
        *(_QWORD *)(v5 + 16) = 0;
        *(_QWORD *)(v5 + 6) = v449[0];
LABEL_70:
        LOWORD(v449[1]) = 0;
LABEL_86:
        v449[0] = 0;
        goto LABEL_87;
      case 'w':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "wchar_t", 7);
        v5 = *(_QWORD *)(a3 + 8);
        v34 = *(_QWORD *)(a3 + 16);
        if ( v5 < v34 )
        {
          *(_BYTE *)v5 = 14;
          v3 = a1 + 1;
          *(_BYTE *)(v5 + 7) = BYTE6(v449[0]);
          *(_WORD *)(v5 + 5) = WORD2(v449[0]);
          *(_BYTE *)(v5 + 8) = 0;
          *(_DWORD *)(v5 + 1) = v449[0];
          *(_BYTE *)(v5 + 15) = 0;
          *(_WORD *)(v5 + 13) = 0;
          *(_QWORD *)(v5 + 16) = 0;
          *(_DWORD *)(v5 + 9) = 0;
          BYTE6(v449[0]) = 0;
          WORD2(v449[0]) = 0;
          LODWORD(v449[0]) = 0;
          goto LABEL_87;
        }
        v100 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
        v101 = 0x555555555555555LL;
        if ( v100 + 1 > 0x555555555555555LL )
          abort();
        v102 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v34 - *(_QWORD *)a3) >> 4);
        if ( v102 >= 0x2AAAAAAAAAAAAAALL
          || ((v103 = 2 * v102, v103 >= v100 + 1) ? (v101 = v103) : (v101 = v100 + 1), v101) )
        {
          v104 = *(_QWORD *)(a3 + 24);
          v105 = *(char **)(v104 + 4096);
          if ( v104 + 4096 - (__int64)v105 >= (unsigned __int64)(48 * v101) )
            *(_QWORD *)(v104 + 4096) = &v105[48 * v101];
          else
            v105 = (char *)malloc(48 * v101);
        }
        else
        {
          v105 = 0;
        }
        v224 = &v105[48 * v100];
        *v224 = 14;
        v225 = &v105[48 * v101];
        v224[7] = BYTE6(v449[0]);
        *(_WORD *)(v224 + 5) = WORD2(v449[0]);
        v224[8] = 0;
        *(_DWORD *)(v224 + 1) = v449[0];
        v224[15] = 0;
        *(_WORD *)(v224 + 13) = 0;
        *((_QWORD *)v224 + 2) = 0;
        *(_DWORD *)(v224 + 9) = 0;
        BYTE6(v449[0]) = 0;
        WORD2(v449[0]) = 0;
        LODWORD(v449[0]) = 0;
        v224[24] = 0;
        *((_QWORD *)v224 + 4) = *(_QWORD *)((char *)v450 + 7);
        *((_QWORD *)v224 + 5) = 0;
        *(_QWORD *)(v224 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v227 = *(void ***)a3;
        v226 = *(void ***)(a3 + 8);
        v228 = v224 + 48;
        if ( v226 == *(void ***)a3 )
        {
          v172 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v224 - 4) = *(v226 - 4);
            *((_OWORD *)v224 - 3) = *((_OWORD *)v226 - 3);
            v229 = (__int64)*(v226 - 1);
            *(v226 - 5) = 0;
            *(v226 - 4) = 0;
            *(v226 - 6) = 0;
            *((_QWORD *)v224 - 1) = v229;
            *(_OWORD *)(v224 - 24) = *(_OWORD *)(v226 - 3);
            *(v226 - 3) = 0;
            *(v226 - 2) = 0;
            *(v226 - 1) = 0;
            v226 -= 6;
            v224 -= 48;
          }
          while ( v227 != v226 );
          v172 = *(void ***)a3;
          v227 = *(void ***)(a3 + 8);
        }
        v173 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v224;
        *(_QWORD *)(a3 + 8) = v228;
        *(_QWORD *)(a3 + 16) = v225;
        if ( v227 != v172 )
        {
          do
          {
            if ( (*(_BYTE *)(v227 - 3) & 1) != 0 )
              free(*(v227 - 1));
            v230 = v227 - 6;
            if ( (*(_BYTE *)(v227 - 6) & 1) != 0 )
              free(*(v227 - 4));
            v227 -= 6;
          }
          while ( v172 != v230 );
        }
        goto LABEL_500;
      case 'x':
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        qmemcpy(v449, "long long", 9);
        v5 = *(_QWORD *)(a3 + 8);
        v62 = *(_QWORD *)(a3 + 16);
        if ( v5 >= v62 )
        {
          v160 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - *(_QWORD *)a3) >> 4);
          v161 = 0x555555555555555LL;
          if ( v160 + 1 > 0x555555555555555LL )
            abort();
          v162 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v62 - *(_QWORD *)a3) >> 4);
          if ( v162 >= 0x2AAAAAAAAAAAAAALL
            || ((v163 = 2 * v162, v163 >= v160 + 1) ? (v161 = v163) : (v161 = v160 + 1), v161) )
          {
            v164 = *(_QWORD *)(a3 + 24);
            v165 = *(char **)(v164 + 4096);
            if ( v164 + 4096 - (__int64)v165 >= (unsigned __int64)(48 * v161) )
              *(_QWORD *)(v164 + 4096) = &v165[48 * v161];
            else
              v165 = (char *)malloc(48 * v161);
          }
          else
          {
            v165 = 0;
          }
          v308 = &v165[48 * v160];
          *v308 = 18;
          v309 = &v165[48 * v161];
          v308[9] = v449[1];
          v308[10] = 0;
          *(_QWORD *)(v308 + 1) = v449[0];
          v308[15] = 0;
          *((_QWORD *)v308 + 2) = 0;
          *(_DWORD *)(v308 + 11) = 0;
          LOBYTE(v449[1]) = 0;
          v449[0] = 0;
          v308[24] = 0;
          *((_QWORD *)v308 + 4) = *(_QWORD *)((char *)v450 + 7);
          *((_QWORD *)v308 + 5) = 0;
          *(_QWORD *)(v308 + 25) = v450[0];
          *(_QWORD *)((char *)v450 + 7) = 0;
          v450[0] = 0;
          v311 = *(void ***)a3;
          v310 = *(void ***)(a3 + 8);
          v312 = v308 + 48;
          if ( v310 == *(void ***)a3 )
          {
            v172 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v308 - 4) = *(v310 - 4);
              *((_OWORD *)v308 - 3) = *((_OWORD *)v310 - 3);
              v313 = (__int64)*(v310 - 1);
              *(v310 - 5) = 0;
              *(v310 - 4) = 0;
              *(v310 - 6) = 0;
              *((_QWORD *)v308 - 1) = v313;
              *(_OWORD *)(v308 - 24) = *(_OWORD *)(v310 - 3);
              *(v310 - 3) = 0;
              *(v310 - 2) = 0;
              *(v310 - 1) = 0;
              v310 -= 6;
              v308 -= 48;
            }
            while ( v311 != v310 );
            v172 = *(void ***)a3;
            v311 = *(void ***)(a3 + 8);
          }
          v173 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v308;
          *(_QWORD *)(a3 + 8) = v312;
          *(_QWORD *)(a3 + 16) = v309;
          if ( v311 != v172 )
          {
            do
            {
              if ( (*(_BYTE *)(v311 - 3) & 1) != 0 )
                free(*(v311 - 1));
              v314 = v311 - 6;
              if ( (*(_BYTE *)(v311 - 6) & 1) != 0 )
                free(*(v311 - 4));
              v311 -= 6;
            }
            while ( v172 != v314 );
          }
          goto LABEL_500;
        }
        *(_BYTE *)v5 = 18;
        v63 = v449[1];
        v3 = a1 + 1;
LABEL_91:
        *(_BYTE *)(v5 + 9) = v63;
        *(_BYTE *)(v5 + 10) = 0;
        *(_QWORD *)(v5 + 1) = v449[0];
        *(_BYTE *)(v5 + 15) = 0;
        *(_QWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 11) = 0;
        LOBYTE(v449[1]) = 0;
        v449[0] = 0;
LABEL_87:
        *(_BYTE *)(v5 + 24) = 0;
        *(_QWORD *)(v5 + 32) = *(_QWORD *)((char *)v450 + 7);
        *(_QWORD *)(v5 + 40) = 0;
        *(_QWORD *)(v5 + 25) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        goto LABEL_88;
      case 'y':
        memset(v449, 0, 15);
        qmemcpy(v450, "unsigned long l", 15);
        v10 = *(_QWORD *)(a3 + 8);
        v11 = *(_QWORD *)(a3 + 16);
        if ( v10 >= v11 )
        {
          v70 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v10 - *(_QWORD *)a3) >> 4);
          v71 = 0x555555555555555LL;
          if ( v70 + 1 > 0x555555555555555LL )
            abort();
          v72 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v11 - *(_QWORD *)a3) >> 4);
          if ( v72 >= 0x2AAAAAAAAAAAAAALL || ((v73 = 2 * v72, v73 >= v70 + 1) ? (v71 = v73) : (v71 = v70 + 1), v71) )
          {
            v74 = *(_QWORD *)(a3 + 24);
            v75 = *(char **)(v74 + 4096);
            if ( v74 + 4096 - (__int64)v75 >= (unsigned __int64)(48 * v71) )
              *(_QWORD *)(v74 + 4096) = &v75[48 * v71];
            else
              v75 = (char *)malloc(48 * v71);
          }
          else
          {
            v75 = 0;
          }
          v175 = &v75[48 * v70];
          *v175 = 36;
          v176 = &v75[48 * v71];
          *((_QWORD *)v175 + 1) = *(_QWORD *)((char *)v450 + 7);
          *((_QWORD *)v175 + 2) = 6778479;
          *(_QWORD *)(v175 + 1) = v450[0];
          *(_QWORD *)((char *)v450 + 7) = 0;
          v450[0] = 0;
          v175[24] = 0;
          *((_QWORD *)v175 + 4) = *(_QWORD *)((char *)v449 + 7);
          *((_QWORD *)v175 + 5) = 0;
          *(_QWORD *)(v175 + 25) = v449[0];
          memset(v449, 0, 15);
          v178 = *(void ***)a3;
          v177 = *(void ***)(a3 + 8);
          v179 = v175 + 48;
          if ( v177 == *(void ***)a3 )
          {
            v172 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v175 - 4) = *(v177 - 4);
              *((_OWORD *)v175 - 3) = *((_OWORD *)v177 - 3);
              v180 = (__int64)*(v177 - 1);
              *(v177 - 5) = 0;
              *(v177 - 4) = 0;
              *(v177 - 6) = 0;
              *((_QWORD *)v175 - 1) = v180;
              *(_OWORD *)(v175 - 24) = *(_OWORD *)(v177 - 3);
              *(v177 - 3) = 0;
              *(v177 - 2) = 0;
              *(v177 - 1) = 0;
              v177 -= 6;
              v175 -= 48;
            }
            while ( v178 != v177 );
            v172 = *(void ***)a3;
            v178 = *(void ***)(a3 + 8);
          }
          v173 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v175;
          *(_QWORD *)(a3 + 8) = v179;
          *(_QWORD *)(a3 + 16) = v176;
          if ( v178 != v172 )
          {
            do
            {
              if ( (*(_BYTE *)(v178 - 3) & 1) != 0 )
                free(*(v178 - 1));
              v181 = v178 - 6;
              if ( (*(_BYTE *)(v178 - 6) & 1) != 0 )
                free(*(v178 - 4));
              v178 -= 6;
            }
            while ( v172 != v181 );
          }
          goto LABEL_500;
        }
        *(_BYTE *)v10 = 36;
        v12 = *(_QWORD *)((char *)v450 + 7);
        v13 = 6778479;
LABEL_73:
        v3 = a1 + 1;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)(v10 + 16) = v13;
        *(_QWORD *)(v10 + 1) = v450[0];
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        *(_BYTE *)(v10 + 24) = 0;
        *(_QWORD *)(v10 + 32) = *(_QWORD *)((char *)v449 + 7);
        *(_QWORD *)(v10 + 40) = 0;
        *(_QWORD *)(v10 + 25) = v449[0];
        memset(v449, 0, 15);
        goto LABEL_88;
      case 'z':
        BYTE2(v449[1]) = 0;
        LOWORD(v449[1]) = 0;
        v449[0] = 0;
        *(_QWORD *)((char *)v450 + 7) = 0;
        v450[0] = 0;
        v448 = 46;
        v446 = 11822;
        v19 = *(_QWORD *)(a3 + 8);
        v20 = *(_QWORD *)(a3 + 16);
        if ( v19 < v20 )
        {
LABEL_77:
          *(_BYTE *)v19 = 6;
          v3 = a1 + 1;
          *(_WORD *)(v19 + 1) = v446;
          *(_BYTE *)(v19 + 4) = 0;
          *(_BYTE *)(v19 + 3) = v448;
          *(_BYTE *)(v19 + 15) = BYTE2(v449[1]);
          *(_WORD *)(v19 + 13) = v449[1];
          *(_QWORD *)(v19 + 16) = 0;
          *(_QWORD *)(v19 + 5) = v449[0];
          LOWORD(v449[1]) = 0;
          v449[0] = 0;
          BYTE2(v449[1]) = 0;
          *(_BYTE *)(v19 + 24) = 0;
          *(_QWORD *)(v19 + 32) = *(_QWORD *)((char *)v450 + 7);
          *(_QWORD *)(v19 + 40) = 0;
          *(_QWORD *)(v19 + 25) = v450[0];
          v450[0] = 0;
          *(_QWORD *)((char *)v450 + 7) = 0;
LABEL_88:
          *(_QWORD *)(a3 + 8) += 48LL;
        }
        else
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v19 - *(_QWORD *)a3) >> 4);
          v22 = 0x555555555555555LL;
          if ( v21 + 1 > 0x555555555555555LL )
            abort();
          v23 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v20 - *(_QWORD *)a3) >> 4);
          if ( v23 >= 0x2AAAAAAAAAAAAAALL || ((v24 = 2 * v23, v24 >= v21 + 1) ? (v22 = v24) : (v22 = v21 + 1), v22) )
          {
            v25 = *(_QWORD *)(a3 + 24);
            v26 = *(char **)(v25 + 4096);
            if ( v25 + 4096 - (__int64)v26 >= (unsigned __int64)(48 * v22) )
              *(_QWORD *)(v25 + 4096) = &v26[48 * v22];
            else
              v26 = (char *)malloc(48 * v22);
          }
          else
          {
            v26 = 0;
          }
          v210 = &v26[48 * v21];
          *v210 = 6;
          v211 = &v26[48 * v22];
          *(_WORD *)(v210 + 1) = 11822;
          v210[4] = 0;
          v210[3] = 46;
          v210[15] = BYTE2(v449[1]);
          *(_WORD *)(v210 + 13) = v449[1];
          *((_QWORD *)v210 + 2) = 0;
          *(_QWORD *)(v210 + 5) = v449[0];
          LOWORD(v449[1]) = 0;
          v449[0] = 0;
          BYTE2(v449[1]) = 0;
          v210[24] = 0;
          *((_QWORD *)v210 + 4) = *(_QWORD *)((char *)v450 + 7);
          *((_QWORD *)v210 + 5) = 0;
          *(_QWORD *)(v210 + 25) = v450[0];
          v450[0] = 0;
          *(_QWORD *)((char *)v450 + 7) = 0;
          v213 = *(void ***)a3;
          v212 = *(void ***)(a3 + 8);
          v214 = v210 + 48;
          if ( v212 == *(void ***)a3 )
          {
            v172 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v210 - 4) = *(v212 - 4);
              *((_OWORD *)v210 - 3) = *((_OWORD *)v212 - 3);
              v215 = (__int64)*(v212 - 1);
              *(v212 - 5) = 0;
              *(v212 - 4) = 0;
              *(v212 - 6) = 0;
              *((_QWORD *)v210 - 1) = v215;
              *(_OWORD *)(v210 - 24) = *(_OWORD *)(v212 - 3);
              *(v212 - 3) = 0;
              *(v212 - 2) = 0;
              *(v212 - 1) = 0;
              v212 -= 6;
              v210 -= 48;
            }
            while ( v213 != v212 );
            v172 = *(void ***)a3;
            v213 = *(void ***)(a3 + 8);
          }
          v173 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v210;
          *(_QWORD *)(a3 + 8) = v214;
          *(_QWORD *)(a3 + 16) = v211;
          if ( v213 != v172 )
          {
            do
            {
              if ( (*(_BYTE *)(v213 - 3) & 1) != 0 )
                free(*(v213 - 1));
              v216 = v213 - 6;
              if ( (*(_BYTE *)(v213 - 6) & 1) != 0 )
                free(*(v213 - 4));
              v213 -= 6;
            }
            while ( v172 != v216 );
          }
LABEL_500:
          if ( v172 )
          {
            v315 = *(_QWORD *)(a3 + 24);
            if ( v315 + 4096 < (unsigned __int64)v172 || v315 > (unsigned __int64)v172 )
            {
              free(v172);
            }
            else if ( *(_QWORD *)(v315 + 4096) == v173 )
            {
              *(_QWORD *)(v315 + 4096) = v172;
            }
          }
          ++v3;
        }
        break;
      default:
        return v3;
    }
  }
  return v3;
}

//----- (000000000005C3A4) ----------------------------------------------------
char *__fastcall sub_5C3A4(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  int v3; // w3
  char v4; // t1
  unsigned __int64 v5; // x4

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = *result++;
    v5 = (unsigned __int64)(v4 & 0x7F) << v3;
    v3 += 7;
    v2 |= v5;
  }
  while ( v4 < 0 );
  *a2 = v2;
  return result;
}

//----- (000000000005C3CC) ----------------------------------------------------
char *__fastcall sub_5C3CC(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  unsigned int v3; // w3
  char v4; // w4
  char v5; // t1
  unsigned __int64 v6; // x5

  v2 = 0;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v6 = (unsigned __int64)(v5 & 0x7F) << v3;
    v3 += 7;
    v2 |= v6;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x3F && (v4 & 0x40) != 0 )
    v2 |= -1LL << v3;
  *a2 = v2;
  return result;
}

//----- (000000000005C40C) ----------------------------------------------------
char *__fastcall sub_5C40C(char a1, char *a2, char *a3, unsigned __int64 *a4)
{
  char *v5; // x19
  _QWORD *v8; // x0
  char *result; // x0
  unsigned __int64 v10; // x1
  _QWORD *v11; // t1
  _QWORD *v12; // [xsp+38h] [xbp+38h] BYREF

  v5 = a3;
  if ( a1 == 80 )
  {
    v8 = (_QWORD *)((unsigned __int64)(a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v11 = (_QWORD *)*v8;
    result = (char *)(v8 + 1);
    v10 = (unsigned __int64)v11;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 4:
      case 0xC:
        result = a3 + 8;
        v10 = *(_QWORD *)a3;
        break;
      case 1:
        result = sub_5C3A4(a3, &v12);
        goto LABEL_6;
      case 2:
        result = a3 + 2;
        v10 = *(unsigned __int16 *)a3;
        break;
      case 3:
        result = a3 + 4;
        v10 = *(unsigned int *)a3;
        break;
      case 9:
        result = sub_5C3CC(a3, &v12);
LABEL_6:
        v10 = (unsigned __int64)v12;
        break;
      case 0xA:
        result = a3 + 2;
        v10 = *(__int16 *)a3;
        break;
      case 0xB:
        result = a3 + 4;
        v10 = *(int *)a3;
        break;
      default:
        abort();
    }
    if ( v10 )
    {
      if ( (a1 & 0x70) != 0x10 )
        v5 = a2;
      v10 += (unsigned __int64)v5;
      if ( a1 < 0 )
        v10 = *(_QWORD *)v10;
    }
  }
  *a4 = v10;
  return result;
}

//----- (000000000005C4FC) ----------------------------------------------------
__int64 sub_5C4FC()
{
  __int64 result; // x0

  result = 8;
  memset(&byte_80290, 8, 32);
  memset(&byte_802D0, 8, 33);
  return result;
}
// 80290: using guessed type char byte_80290;
// 802D0: using guessed type char byte_802D0;

//----- (000000000005C610) ----------------------------------------------------
__int64 __fastcall sub_5C610(__int64 result, __int64 a2, _QWORD *a3)
{
  if ( byte_802AF != 8 )
    abort();
  *a3 = a2;
  if ( (*(_QWORD *)(result + 832) & 0x4000000000000000LL) != 0 )
    *(_BYTE *)(result + 887) = 0;
  *(_QWORD *)(result + 248) = a3;
  return result;
}
// 802AF: using guessed type char byte_802AF;

//----- (000000000005C64C) ----------------------------------------------------
__int64 __fastcall sub_5C64C(__int64 a1, int a2)
{
  __int64 v2; // x2
  __int64 v3; // x1

  if ( a2 > 97 )
LABEL_2:
    abort();
  v2 = a2;
  v3 = *(_QWORD *)(a1 + 8LL * a2);
  if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) != 0 && *(_BYTE *)(a1 + v2 + 856) )
    return v3;
  if ( byte_80290[v2] != 8 )
    goto LABEL_2;
  return *(_QWORD *)v3;
}

//----- (000000000005C6A4) ----------------------------------------------------
__int64 __fastcall sub_5C6A4(__int64 a1, __int64 a2)
{
  __int64 i; // x20
  _QWORD *v5; // x0
  _QWORD *v6; // x1
  __int64 result; // x0
  __int64 v8; // [xsp+38h] [xbp+38h] BYREF

  if ( ((*(_QWORD *)(a2 + 832) & 0x4000000000000000LL) == 0 || !*(_BYTE *)(a2 + 887)) && !*(_QWORD *)(a2 + 248) )
    sub_5C610(a2, *(_QWORD *)(a2 + 784), &v8);
  for ( i = 0; i != 97; ++i )
  {
    v5 = *(_QWORD **)(a1 + 8 * i);
    v6 = *(_QWORD **)(a2 + 8 * i);
    if ( *(_BYTE *)(a1 + i + 856) )
LABEL_7:
      abort();
    if ( *(_BYTE *)(a2 + i + 856) && v5 )
    {
      if ( byte_80290[i] != 8 )
        goto LABEL_7;
      *v5 = v6;
    }
    else if ( v5 != 0 && v6 != 0 && v6 != v5 )
    {
      memcpy(v5, v6, (unsigned __int8)byte_80290[i]);
    }
  }
  if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) == 0 || (result = 0, !*(_BYTE *)(a1 + 887)) )
  {
    result = 0;
    if ( !*(_QWORD *)(a1 + 248) )
      return sub_5C64C(a2, 31) - *(_QWORD *)(a1 + 784) + *(_QWORD *)(a2 + 848);
  }
  return result;
}

//----- (000000000005C7B0) ----------------------------------------------------
__int64 __fastcall sub_5C7B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 784);
}

//----- (000000000005C7B8) ----------------------------------------------------
_QWORD *__fastcall sub_5C7B8(_QWORD *result, int a2, __int64 a3)
{
  if ( a2 > 97 )
LABEL_2:
    abort();
  if ( (result[104] & 0x4000000000000000LL) != 0 && *((_BYTE *)result + a2 + 856) )
  {
    result[a2] = a3;
  }
  else
  {
    result = (_QWORD *)result[a2];
    if ( byte_80290[a2] != 8 )
      goto LABEL_2;
    *result = a3;
  }
  return result;
}

//----- (000000000005C810) ----------------------------------------------------
__int64 __fastcall sub_5C810(__int64 a1)
{
  return *(_QWORD *)(a1 + 792);
}

//----- (000000000005C818) ----------------------------------------------------
__int64 __fastcall sub_5C818(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v2; // x2
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 832);
  result = *(_QWORD *)(a1 + 792);
  *a2 = v2 >> 63;
  return result;
}

//----- (000000000005C82C) ----------------------------------------------------
__int64 __fastcall sub_5C82C(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 792) = a2;
  return result;
}

//----- (000000000005C834) ----------------------------------------------------
__int64 __fastcall sub_5C834(__int64 a1)
{
  return *(_QWORD *)(a1 + 800);
}

//----- (000000000005C83C) ----------------------------------------------------
__int64 __fastcall sub_5C83C(__int64 a1)
{
  return *(_QWORD *)(a1 + 824);
}

//----- (000000000005C844) ----------------------------------------------------
__int64 __fastcall sub_5C844(__int64 a1)
{
  bool v1; // zf
  __int64 result; // x0
  _QWORD v3[3]; // [xsp+18h] [xbp+18h] BYREF

  v1 = sub_5F98C(a1 - 1, v3) == 0;
  result = v3[2];
  if ( v1 )
    return 0;
  return result;
}

//----- (000000000005C87C) ----------------------------------------------------
__int64 __fastcall sub_5C87C(unsigned __int8 a1, __int64 a2)
{
  unsigned int v3; // w2

  if ( a1 == 255 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return *(_QWORD *)(a2 + 808);
  if ( v3 <= 0x20 )
  {
    if ( (a1 & 0x70) == 0 || v3 == 16 )
      return 0;
LABEL_13:
    abort();
  }
  if ( v3 == 64 )
    return sub_5C83C(a2);
  if ( v3 != 80 )
  {
    if ( v3 == 48 )
      return *(_QWORD *)(a2 + 816);
    goto LABEL_13;
  }
  return 0;
}

//----- (000000000005C8F4) ----------------------------------------------------
char *__fastcall sub_5C8F4(char *result, unsigned __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 *v7; // x24
  unsigned __int64 v8; // x2
  char v9; // w1
  char *v10; // x20
  int v11; // w3
  char *v12; // x0
  char *v13; // x0
  __int64 v14; // x1
  unsigned __int64 v15; // x0
  char *v16; // x0
  __int64 v17; // x0
  unsigned __int64 v18; // x1
  __int64 *v19; // x3
  __int64 *v20; // x3
  char *v21; // x0
  unsigned __int64 v22; // x0
  char *v23; // x0
  __int64 v24; // x1
  int v25; // w3
  __int64 v26; // x2
  char *v27; // x0
  char *v28; // x0
  char *v29; // x0
  char *v30; // x0
  __int64 v31; // x1
  unsigned __int64 v32; // x0
  char *v33; // x0
  char *v34; // x0
  __int64 v35; // x0
  __int64 v36; // x2
  __int64 v37; // x1
  char *v38; // x0
  __int64 v39; // [xsp-660h] [xbp-660h] BYREF
  void *v40; // [xsp+68h] [xbp+68h]
  unsigned __int64 v41; // [xsp+78h] [xbp+78h] BYREF
  unsigned __int64 v42; // [xsp+80h] [xbp+80h] BYREF
  unsigned __int64 v43; // [xsp+88h] [xbp+88h] BYREF

  *(_QWORD *)(a4 + 1568) = 0;
  v7 = 0;
  while ( (unsigned __int64)result < a2 )
  {
    v8 = *(_QWORD *)(a4 + 1608);
    if ( v8 >= a3[99] + (a3[104] >> 63) )
      break;
    v9 = *result;
    v10 = result + 1;
    v11 = *result & 0xC0;
    if ( v11 == 64 )
    {
      *(_QWORD *)(a4 + 1608) = v8 + (v9 & 0x3F) * *(_QWORD *)(a4 + 1632);
      goto LABEL_58;
    }
    if ( v11 != 128 )
    {
      if ( v11 == 192 )
      {
        *(_DWORD *)(a4 + 16LL * (v9 & 0x3F) + 8) = 0;
        goto LABEL_58;
      }
      switch ( *result )
      {
        case 0:
          goto LABEL_58;
        case 1:
          v40 = (void *)*(unsigned __int8 *)(a4 + 1648);
          v13 = (char *)sub_5C87C((unsigned __int8)v40, (__int64)a3);
          v10 = sub_5C40C((char)v40, v13, v10, &v43);
          *(_QWORD *)(a4 + 1608) = v43;
          goto LABEL_58;
        case 2:
          v10 = result + 2;
          *(_QWORD *)(a4 + 1608) = v8 + (unsigned __int8)result[1] * *(_QWORD *)(a4 + 1632);
          goto LABEL_58;
        case 3:
          v10 = result + 3;
          *(_QWORD *)(a4 + 1608) = v8 + *(unsigned __int16 *)(result + 1) * *(_QWORD *)(a4 + 1632);
          goto LABEL_58;
        case 4:
          v10 = result + 5;
          *(_QWORD *)(a4 + 1608) = v8 + *(unsigned int *)(result + 1) * *(_QWORD *)(a4 + 1632);
          goto LABEL_58;
        case 5:
          v12 = sub_5C3A4(result + 1, &v41);
          goto LABEL_16;
        case 6:
        case 8:
          v10 = sub_5C3A4(result + 1, &v41);
          if ( v41 <= 0x61 )
            *(_DWORD *)(a4 + 16 * v41 + 8) = 0;
          goto LABEL_58;
        case 7:
          v10 = sub_5C3A4(result + 1, &v41);
          if ( v41 <= 0x61 )
            *(_DWORD *)(a4 + 16 * v41 + 8) = 6;
          goto LABEL_58;
        case 9:
          v16 = sub_5C3A4(result + 1, &v41);
          v10 = sub_5C3A4(v16, &v43);
          if ( v41 > 0x61 )
            goto LABEL_58;
          v17 = 16 * v41;
          *(_DWORD *)(a4 + 16 * v41 + 8) = 2;
          v18 = v43;
          goto LABEL_56;
        case 10:
          if ( v7 )
          {
            v19 = v7;
            v7 = (__int64 *)v7[196];
          }
          else
          {
            v19 = &v39;
          }
          *(_QWORD *)(a4 + 1568) = memcpy(v19, (const void *)a4, 0x648u);
          goto LABEL_58;
        case 11:
          v40 = *(void **)(a4 + 1568);
          memcpy((void *)a4, v40, 0x648u);
          v20 = (__int64 *)v40;
          *((_QWORD *)v40 + 196) = v7;
          v7 = v20;
          goto LABEL_58;
        case 12:
          v21 = sub_5C3A4(result + 1, &v42);
          *(_QWORD *)(a4 + 1584) = v42;
          v10 = sub_5C3A4(v21, &v42);
          *(_QWORD *)(a4 + 1576) = v42;
          goto LABEL_30;
        case 13:
          v10 = sub_5C3A4(result + 1, &v42);
          *(_QWORD *)(a4 + 1584) = v42;
LABEL_30:
          *(_DWORD *)(a4 + 1600) = 1;
          goto LABEL_58;
        case 14:
          v10 = sub_5C3A4(result + 1, &v42);
          v22 = v42;
          goto LABEL_40;
        case 15:
          *(_QWORD *)(a4 + 1592) = v10;
          *(_DWORD *)(a4 + 1600) = 2;
          v23 = result + 1;
          goto LABEL_49;
        case 16:
          v23 = sub_5C3A4(result + 1, &v41);
          if ( v41 > 0x61 )
            goto LABEL_49;
          v24 = 16 * v41;
          v25 = 3;
          v26 = a4 + 16 * v41;
          goto LABEL_48;
        case 17:
          v27 = sub_5C3A4(result + 1, &v41);
          v10 = sub_5C3CC(v27, &v43);
          v14 = *(_QWORD *)(a4 + 1624);
          v15 = v43;
          goto LABEL_36;
        case 18:
          v28 = sub_5C3A4(result + 1, &v42);
          *(_QWORD *)(a4 + 1584) = v42;
          v29 = sub_5C3CC(v28, &v43);
          *(_DWORD *)(a4 + 1600) = 1;
          v10 = v29;
          goto LABEL_39;
        case 19:
          v10 = sub_5C3CC(result + 1, &v43);
LABEL_39:
          v22 = v43 * *(_QWORD *)(a4 + 1624);
LABEL_40:
          *(_QWORD *)(a4 + 1576) = v22;
          goto LABEL_58;
        case 20:
          v30 = sub_5C3A4(result + 1, &v41);
          v10 = sub_5C3A4(v30, &v42);
          v31 = *(_QWORD *)(a4 + 1624);
          v32 = v42;
          goto LABEL_44;
        case 21:
          v33 = sub_5C3A4(result + 1, &v41);
          v10 = sub_5C3CC(v33, &v43);
          v31 = *(_QWORD *)(a4 + 1624);
          v32 = v43;
LABEL_44:
          v18 = v32 * v31;
          if ( v41 > 0x61 )
            goto LABEL_58;
          v17 = 16 * v41;
          *(_DWORD *)(a4 + 16 * v41 + 8) = 4;
          break;
        case 22:
          v23 = sub_5C3A4(result + 1, &v41);
          if ( v41 <= 0x61 )
          {
            v24 = 16 * v41;
            v25 = 5;
            v26 = a4 + 16 * v41;
LABEL_48:
            *(_DWORD *)(v26 + 8) = v25;
            *(_QWORD *)(a4 + v24) = v23;
          }
LABEL_49:
          v34 = sub_5C3A4(v23, &v42);
          v10 = &v34[v42];
          goto LABEL_58;
        case 45:
          v35 = 16;
          v36 = a4 + 256;
          v41 = 16;
          v37 = 0;
          do
          {
            *(_DWORD *)(v36 + 8) = 1;
            ++v35;
            *(_QWORD *)v36 = v37;
            v36 += 16;
            v37 += 8;
          }
          while ( v35 != 32 );
          goto LABEL_58;
        case 46:
          v10 = sub_5C3A4(result + 1, &v42);
          a3[106] = v42;
          goto LABEL_58;
        case 47:
          v38 = sub_5C3A4(result + 1, &v41);
          v10 = sub_5C3A4(v38, &v42);
          if ( v41 > 0x61 )
            goto LABEL_58;
          v17 = 16 * v41;
          v18 = -(__int64)(*(_QWORD *)(a4 + 1624) * v42);
          *(_DWORD *)(a4 + 16 * v41 + 8) = 1;
          break;
        default:
          abort();
      }
      goto LABEL_56;
    }
    v12 = result + 1;
    v41 = v9 & 0x3F;
LABEL_16:
    v10 = sub_5C3A4(v12, &v42);
    v14 = *(_QWORD *)(a4 + 1624);
    v15 = v42;
LABEL_36:
    v18 = v15 * v14;
    if ( v41 <= 0x61 )
    {
      v17 = 16 * v41;
      *(_DWORD *)(a4 + 16 * v41 + 8) = 1;
LABEL_56:
      *(_QWORD *)(a4 + v17) = v18;
    }
LABEL_58:
    result = v10;
  }
  return result;
}

//----- (000000000005CDEC) ----------------------------------------------------
__int64 __fastcall sub_5CDEC(_QWORD *a1, __int64 a2)
{
  __int64 v4; // x1
  unsigned int *v6; // x0
  unsigned int *v7; // x21
  _DWORD *v8; // x1
  __int64 v9; // x20
  __int64 v10; // x0
  __int64 v11; // x2
  _DWORD *i; // x0
  __int64 v13; // x2
  unsigned int *v14; // x22
  _BYTE *v15; // x23
  char *v16; // x0
  __int64 v17; // t1
  char *v18; // x0
  char *v19; // x0
  char *v20; // x1
  char *v21; // x0
  __int64 v22; // x1
  char *v23; // x24
  __int64 v24; // x24
  _BYTE *j; // x23
  int v26; // w1
  char v27; // w26
  char *v28; // x0
  int v29; // w0
  int v30; // w2
  char *v31; // x22
  char *v32; // x2
  int v33; // w23
  char *v34; // x0
  char *v35; // x0
  char *v36; // [xsp+68h] [xbp+68h]
  char *v37; // [xsp+68h] [xbp+68h]
  __int64 v38; // [xsp+78h] [xbp+78h] BYREF
  __int64 v39; // [xsp+80h] [xbp+80h] BYREF
  unsigned __int64 v40; // [xsp+88h] [xbp+88h] BYREF

  memset((void *)a2, 0, 0x680u);
  v4 = a1[99];
  a1[106] = 0;
  a1[100] = 0;
  if ( !v4 )
    return 5;
  v6 = sub_5F98C(v4 + (a1[104] >> 63) - 1LL, a1 + 101);
  v7 = v6;
  if ( !v6 )
  {
    v8 = (_DWORD *)a1[99];
    if ( *v8 == -763358872 && v8[1] == -738197503 )
    {
      v9 = a1[98];
      *(_QWORD *)(a2 + 1584) = 31;
      *(_DWORD *)(a2 + 1600) = 1;
      *(_QWORD *)(a2 + 1576) = 304;
      v10 = 8;
      v11 = a2;
      do
      {
        *(_DWORD *)(v11 + 8) = 1;
        *(_QWORD *)v11 = v10;
        v11 += 16;
        v10 += 8;
      }
      while ( v10 != 256 );
      for ( i = (_DWORD *)(v9 + 592); *i; i = (_DWORD *)((char *)i + (unsigned int)i[1]) )
      {
        if ( *i == 1179680769 )
        {
          v13 = a2 + 1024;
          do
          {
            *(_DWORD *)(v13 + 8) = 1;
            *(_QWORD *)v13 = (char *)i + -1312 - v9 - a2 + v13;
            v13 += 16;
          }
          while ( v13 != a2 + 1536 );
        }
      }
      *(_BYTE *)(a2 + 1651) = 1;
      *(_QWORD *)(a2 + 496) = 256;
      *(_DWORD *)(a2 + 504) = 1;
      *(_DWORD *)(a2 + 1544) = 4;
      *(_QWORD *)(a2 + 1536) = *(_QWORD *)(v9 + 568) - (v9 + 304);
      *(_QWORD *)(a2 + 1640) = 96;
      return 0;
    }
    return 5;
  }
  v14 = (unsigned int *)((char *)v6 - (int)v6[1] + 4);
  *(_QWORD *)(a2 + 1608) = a1[103];
  v15 = (char *)v14 + 9;
  v16 = (char *)v14 + strlen((const char *)v14 + 9) + 10;
  if ( *((_BYTE *)v14 + 9) == 101 && *((_BYTE *)v14 + 10) == 104 )
  {
    v17 = *(_QWORD *)v16;
    v16 += 8;
    v15 = (char *)v14 + 11;
    *(_QWORD *)(a2 + 1656) = v17;
  }
  if ( *((unsigned __int8 *)v14 + 8) > 3u )
  {
    if ( *v16 != 8 || v16[1] )
      return 3;
    v16 += 2;
  }
  v18 = sub_5C3A4(v16, &v38);
  *(_QWORD *)(a2 + 1632) = v38;
  v19 = sub_5C3CC(v18, &v39);
  v20 = v19;
  *(_QWORD *)(a2 + 1624) = v39;
  if ( *((_BYTE *)v14 + 8) == 1 )
  {
    v21 = v19 + 1;
    v22 = (unsigned __int8)*v20;
  }
  else
  {
    v21 = sub_5C3A4(v19, &v38);
    v22 = v38;
  }
  *(_QWORD *)(a2 + 1640) = v22;
  *(_BYTE *)(a2 + 1649) = -1;
  v23 = 0;
  if ( *v15 == 122 )
  {
    ++v15;
    v21 = sub_5C3A4(v21, &v38);
    v24 = v38;
    *(_BYTE *)(a2 + 1650) = 1;
    v23 = &v21[v24];
  }
  for ( j = v15 + 1; ; ++j )
  {
    v26 = (unsigned __int8)*(j - 1);
    if ( !*(j - 1) )
      break;
    switch ( v26 )
    {
      case 'L':
        *(_BYTE *)(a2 + 1649) = *v21;
LABEL_33:
        ++v21;
        continue;
      case 'R':
        *(_BYTE *)(a2 + 1648) = *v21;
        goto LABEL_33;
      case 'P':
        v27 = *v21;
        v36 = v21 + 1;
        v28 = (char *)sub_5C87C(*v21, (__int64)a1);
        v21 = sub_5C40C(v27, v28, v36, &v40);
        *(_QWORD *)(a2 + 1616) = v40;
        break;
      case 'S':
        *(_BYTE *)(a2 + 1651) = 1;
        break;
      default:
        v21 = v23;
        goto LABEL_43;
    }
  }
  if ( v23 )
    v21 = v23;
LABEL_43:
  if ( !v21 )
    return 3;
  sub_5C8F4(v21, (unsigned __int64)v14 + *v14 + 4, a1, a2);
  v29 = *(unsigned __int8 *)(a2 + 1648);
  if ( v29 == 255 )
  {
    v30 = 0;
  }
  else
  {
    switch ( v29 & 7 )
    {
      case 0:
      case 4:
        v30 = 8;
        break;
      case 2:
        v30 = 2;
        break;
      case 3:
        v30 = 4;
        break;
      default:
        abort();
    }
  }
  v31 = 0;
  v32 = (char *)v7 + (unsigned int)(2 * v30) + 8;
  if ( *(_BYTE *)(a2 + 1650) )
  {
    v32 = sub_5C3A4(v32, &v40);
    v31 = &v32[v40];
  }
  v33 = *(unsigned __int8 *)(a2 + 1649);
  if ( v33 != 255 )
  {
    v37 = v32;
    v34 = (char *)sub_5C87C(v33, (__int64)a1);
    v32 = sub_5C40C(v33, v34, v37, &v40);
    a1[100] = v40;
  }
  if ( v31 )
    v35 = v31;
  else
    v35 = v32;
  sub_5C8F4(v35, (unsigned __int64)v7 + *v7 + 4, a1, a2);
  return 0;
}

//----- (000000000005D210) ----------------------------------------------------
__int64 __fastcall sub_5D210(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  int v7; // w25
  unsigned int v8; // w26
  char *v9; // x27
  __int64 v10; // x0
  int v11; // w1
  int v12; // w0
  __int64 v13; // x0
  int v14; // w1
  char *v15; // x0
  __int64 v16; // x0
  __int64 v17; // x1
  char *v18; // x27
  char *v19; // x0
  char *v20; // x0
  int v21; // w0
  __int64 v22; // x1
  __int64 v23; // x0
  __int64 v24; // x2
  __int64 v25; // x3
  __int64 v26; // x4
  __int64 v27; // x2
  __int64 v28; // x1
  __int64 v29; // x0
  unsigned __int8 v31; // [xsp+68h] [xbp+68h]
  __int64 v32; // [xsp+68h] [xbp+68h]
  __int64 v33; // [xsp+70h] [xbp+70h] BYREF
  __int64 v34; // [xsp+78h] [xbp+78h] BYREF
  __int64 v35; // [xsp+80h] [xbp+80h] BYREF
  __int64 v36; // [xsp+88h] [xbp+88h] BYREF
  _QWORD v37[64]; // [xsp+90h] [xbp+90h]

  v37[0] = a4;
  v7 = 1;
  while ( (unsigned __int64)a1 < a2 )
  {
    v8 = (unsigned __int8)*a1;
    v9 = a1 + 1;
    if ( v8 > 0x20 )
    {
      if ( v8 > 0x4F )
      {
        if ( v8 != 144 )
        {
          if ( v8 > 0x90 )
          {
            if ( v8 == 148 )
              goto LABEL_78;
            if ( v8 > 0x94 )
            {
              if ( v8 == 150 )
                goto LABEL_121;
              if ( v8 != 241 )
                goto LABEL_118;
              v18 = a1 + 2;
              v31 = a1[1];
              v19 = (char *)sub_5C87C(v31, a3);
              v20 = sub_5C40C(v31, v19, v18, (unsigned __int64 *)&v36);
LABEL_60:
              v9 = v20;
              v10 = v36;
              goto LABEL_119;
            }
            if ( v8 != 146 )
              goto LABEL_118;
            v15 = sub_5C3A4(a1 + 1, &v33);
            v9 = sub_5C3CC(v15, &v35);
            v16 = sub_5C64C(a3, v33);
            v17 = v35;
          }
          else
          {
            if ( v8 <= 0x6F )
            {
              v13 = a3;
              v14 = v8 - 80;
LABEL_62:
              v10 = sub_5C64C(v13, v14);
              goto LABEL_119;
            }
            v9 = sub_5C3CC(a1 + 1, &v35);
            v16 = sub_5C64C(a3, v8 - 112);
            v17 = v35;
          }
          v10 = v16 + v17;
          goto LABEL_119;
        }
        v9 = sub_5C3A4(a1 + 1, &v33);
        v14 = v33;
        v13 = a3;
        goto LABEL_62;
      }
      if ( v8 >= 0x30 )
      {
        v10 = v8 - 48;
        goto LABEL_119;
      }
      if ( v8 <= 0x27 )
      {
        if ( v8 != 35 )
          goto LABEL_93;
        goto LABEL_78;
      }
      if ( v8 > 0x2E )
      {
        v9 = &a1[*(__int16 *)(a1 + 1) + 3];
      }
      else
      {
        if ( v8 >= 0x29 )
        {
LABEL_93:
          if ( v7 > 1 )
          {
            v28 = v37[v7 - 2];
            v29 = v37[v7 - 1];
            switch ( *a1 )
            {
              case 26:
                v10 = v29 & v28;
                goto LABEL_111;
              case 27:
                v10 = v28 / v29;
                goto LABEL_111;
              case 28:
                v10 = v28 - v29;
                goto LABEL_111;
              case 29:
                v10 = v28 % (unsigned __int64)v29;
                goto LABEL_111;
              case 30:
                v10 = v29 * v28;
                goto LABEL_111;
              case 33:
                v10 = v29 | v28;
                goto LABEL_111;
              case 34:
                v10 = v29 + v28;
                goto LABEL_111;
              case 36:
                v10 = v28 << v29;
                goto LABEL_111;
              case 37:
                v10 = (unsigned __int64)v28 >> v29;
                goto LABEL_111;
              case 38:
                v10 = v28 >> v29;
                goto LABEL_111;
              case 39:
                v10 = v29 ^ v28;
                goto LABEL_111;
              case 41:
                v10 = v28 == v29;
                goto LABEL_111;
              case 42:
                v10 = v28 >= v29;
                goto LABEL_111;
              case 43:
                v10 = v28 > v29;
                goto LABEL_111;
              case 44:
                v10 = v28 <= v29;
                goto LABEL_111;
              case 45:
                v10 = v28 < v29;
                goto LABEL_111;
              case 46:
                v10 = v28 != v29;
LABEL_111:
                v7 -= 2;
                goto LABEL_119;
              default:
                break;
            }
          }
LABEL_118:
          abort();
        }
        if ( !v7 )
          goto LABEL_118;
        --v7;
        v9 = a1 + 3;
        if ( v37[v7] )
          v9 = &a1[*(__int16 *)(a1 + 1) + 3];
      }
    }
    else
    {
      if ( v8 >= 0x1F )
        goto LABEL_78;
      if ( v8 == 16 )
      {
        v9 = sub_5C3A4(a1 + 1, &v34);
        v10 = v34;
        goto LABEL_119;
      }
      if ( v8 <= 0x10 )
      {
        if ( v8 == 10 )
        {
          v10 = *(unsigned __int16 *)(a1 + 1);
          goto LABEL_56;
        }
        if ( v8 <= 0xA )
        {
          if ( v8 != 6 )
          {
            if ( v8 > 6 )
            {
              v9 = a1 + 2;
              if ( v8 == 8 )
              {
                v10 = (unsigned __int8)a1[1];
              }
              else
              {
                if ( v8 != 9 )
                  goto LABEL_118;
                v10 = a1[1];
              }
            }
            else
            {
              if ( v8 != 3 )
                goto LABEL_118;
              v10 = *(_QWORD *)(a1 + 1);
              v9 = a1 + 9;
            }
            goto LABEL_119;
          }
LABEL_78:
          if ( !v7 )
            goto LABEL_118;
          v27 = v37[--v7];
          if ( v8 == 31 )
          {
            v10 = -v27;
          }
          else if ( v8 > 0x1F )
          {
            if ( v8 == 35 )
            {
              v32 = v37[v7];
              v9 = sub_5C3A4(a1 + 1, &v34);
              v10 = v32 + v34;
            }
            else
            {
              if ( v8 == 148 )
              {
                v9 = a1 + 2;
                switch ( a1[1] )
                {
                  case 1:
                    v10 = *(unsigned __int8 *)v27;
                    goto LABEL_119;
                  case 2:
                    v10 = *(unsigned __int16 *)v27;
                    goto LABEL_119;
                  case 4:
                    v10 = *(unsigned int *)v27;
                    goto LABEL_119;
                  case 8:
                    goto LABEL_90;
                  default:
                    goto LABEL_118;
                }
              }
              v10 = ~v27;
            }
          }
          else if ( v8 == 6 )
          {
LABEL_90:
            v10 = *(_QWORD *)v27;
          }
          else
          {
            v10 = (v27 ^ (v27 >> 63)) + ((unsigned __int64)v27 >> 63);
          }
          goto LABEL_119;
        }
        if ( v8 == 13 )
        {
          v10 = *(int *)(a1 + 1);
LABEL_58:
          v9 = a1 + 5;
        }
        else if ( v8 > 0xD )
        {
          v9 = a1 + 9;
          v10 = *(_QWORD *)(a1 + 1);
        }
        else
        {
          if ( v8 != 11 )
          {
            v10 = *(unsigned int *)(a1 + 1);
            goto LABEL_58;
          }
          v10 = *(__int16 *)(a1 + 1);
LABEL_56:
          v9 = a1 + 3;
        }
LABEL_119:
        if ( (unsigned int)v7 > 0x3F )
          goto LABEL_118;
        v37[v7++] = v10;
        goto LABEL_121;
      }
      if ( v8 == 21 )
      {
        v22 = (unsigned __int8)a1[1];
        v35 = v22;
        v9 = a1 + 2;
        v23 = v7 - 1;
        if ( v22 >= v23 )
          goto LABEL_118;
        v10 = v37[v23 - v22];
        goto LABEL_119;
      }
      if ( v8 <= 0x15 )
      {
        if ( v8 == 18 )
        {
          if ( !v7 )
            goto LABEL_118;
          v21 = v7 - 1;
        }
        else
        {
          if ( v8 < 0x12 )
          {
            v20 = sub_5C3CC(a1 + 1, &v36);
            goto LABEL_60;
          }
          if ( v8 == 19 )
          {
            if ( !v7 )
              goto LABEL_118;
            --v7;
            goto LABEL_121;
          }
          if ( v7 <= 1 )
            goto LABEL_118;
          v21 = v7 - 2;
        }
        v10 = v37[v21];
        goto LABEL_119;
      }
      if ( v8 == 25 )
        goto LABEL_78;
      if ( v8 > 0x19 )
        goto LABEL_93;
      v11 = v7 - 1;
      v12 = v7 - 2;
      if ( v8 == 22 )
      {
        if ( v7 <= 1 )
          goto LABEL_118;
        v24 = v37[v11];
        v37[v11] = v37[v12];
        v37[v12] = v24;
      }
      else
      {
        if ( v8 != 23 || v7 <= 2 )
          goto LABEL_118;
        v25 = v37[v11];
        v26 = v37[v7 - 3];
        v37[v11] = v37[v12];
        v37[v12] = v26;
        v37[v7 - 3] = v25;
      }
    }
LABEL_121:
    a1 = v9;
  }
  if ( !v7 )
    goto LABEL_118;
  return v37[v7 - 1];
}
// 5D2EC: conditional instruction was optimized away because w26.4==C
// 5D308: conditional instruction was optimized away because w26.4==F
// 5D334: conditional instruction was optimized away because w26.4==14
// 5D5CC: conditional instruction was optimized away because w26.4==19
// 5D5F0: conditional instruction was optimized away because w26.4==20

//----- (000000000005D7C4) ----------------------------------------------------
__int64 __fastcall sub_5D7C4(__int64 a1, __int64 *a2)
{
  int v4; // w0
  char *v5; // x0
  __int64 v6; // x23
  char **v7; // x26
  _BYTE *v8; // x22
  __int64 v9; // x20
  __int64 v10; // x0
  char *v11; // x1
  char *v12; // x0
  char *v13; // x0
  __int64 v14; // x0
  unsigned __int64 v15; // x1
  __int64 result; // x0
  __int64 v17; // [xsp+70h] [xbp+70h] BYREF
  __int64 v18; // [xsp+78h] [xbp+78h] BYREF
  _QWORD v19[110]; // [xsp+80h] [xbp+80h] BYREF
  char v20; // [xsp+3F7h] [xbp+3F7h]

  memcpy(v19, (const void *)a1, 0x3C0u);
  if ( ((v19[104] & 0x4000000000000000LL) == 0 || !v20) && !v19[31] )
    sub_5C610((__int64)v19, *(_QWORD *)(a1 + 784), &v17);
  if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) != 0 )
    *(_BYTE *)(a1 + 887) = 0;
  v4 = *((_DWORD *)a2 + 400);
  *(_QWORD *)(a1 + 248) = 0;
  if ( v4 == 1 )
  {
    v6 = sub_5C64C((__int64)v19, *((_DWORD *)a2 + 396)) + a2[197];
  }
  else
  {
    if ( v4 != 2 )
LABEL_17:
      abort();
    v5 = sub_5C3A4((char *)a2[199], &v18);
    v6 = sub_5D210(v5, (unsigned __int64)&v5[v18], (__int64)v19, 0);
  }
  *(_QWORD *)(a1 + 784) = v6;
  v7 = (char **)a2;
  v8 = (_BYTE *)(a1 + 856);
  v9 = 0;
  while ( 2 )
  {
    switch ( *((_DWORD *)v7 + 2) )
    {
      case 1:
        v10 = (__int64)&(*v7)[v6];
        goto LABEL_20;
      case 2:
        v11 = *v7;
        if ( *((_BYTE *)&v19[107] + (int)*v7) )
        {
          v10 = sub_5C64C((__int64)v19, (int)v11);
LABEL_16:
          if ( (unsigned __int8)byte_80290[v9] > 8u )
            goto LABEL_17;
          *v8 = 1;
        }
        else
        {
          v10 = v19[(int)v11];
LABEL_20:
          if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) != 0 )
            *v8 = 0;
        }
        *(_QWORD *)(a1 + 8 * v9) = v10;
LABEL_26:
        ++v9;
        v7 += 2;
        ++v8;
        if ( v9 != 98 )
          continue;
        v14 = *(_QWORD *)(a1 + 832);
        v15 = v14 | 0x8000000000000000LL;
        result = v14 & 0x7FFFFFFFFFFFFFFFLL;
        if ( *((_BYTE *)a2 + 1651) )
          result = v15;
        *(_QWORD *)(a1 + 832) = result;
        return result;
      case 3:
        v12 = sub_5C3A4(*v7, &v18);
        v10 = sub_5D210(v12, (unsigned __int64)&v12[v18], (__int64)v19, v6);
        goto LABEL_20;
      case 4:
        v10 = (__int64)&(*v7)[v6];
        goto LABEL_16;
      case 5:
        v13 = sub_5C3A4(*v7, &v18);
        v10 = sub_5D210(v13, (unsigned __int64)&v13[v18], (__int64)v19, v6);
        goto LABEL_16;
      default:
        goto LABEL_26;
    }
  }
}

//----- (000000000005D9D0) ----------------------------------------------------
__int64 __fastcall sub_5D9D0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x30
  __int64 result; // x0
  __int64 v8; // [xsp+48h] [xbp+48h] BYREF
  __int64 v9[200]; // [xsp+50h] [xbp+50h] BYREF
  int v10; // [xsp+690h] [xbp+690h]

  memset(a1, 0, 0x3C0u);
  a1[99] = v3;
  a1[104] = 0x4000000000000000LL;
  if ( (unsigned int)sub_5CDEC(a1, (__int64)v9) )
    abort();
  if ( (!&pthread_create || pthread_once((pthread_once_t *)&algn_802F1[3], (void (*)(void))sub_5C4FC)) && !byte_80290[0] )
    sub_5C4FC();
  sub_5C610((__int64)a1, a2, &v8);
  v9[197] = 0;
  v10 = 1;
  v9[198] = 31;
  result = sub_5D7C4((__int64)a1, v9);
  a1[99] = a3;
  return result;
}
// 5DA04: variable 'v3' is possibly undefined
// 802F1: using guessed type _BYTE[7];

//----- (000000000005DAAC) ----------------------------------------------------
__int64 __fastcall sub_5DAAC(__int64 a1, __int64 *a2)
{
  __int64 v4; // x1
  __int64 result; // x0

  sub_5D7C4(a1, a2);
  v4 = a2[205];
  result = LODWORD(a2[2 * v4 + 1]);
  if ( (_DWORD)result == 6 )
  {
    *(_QWORD *)(a1 + 792) = 0;
  }
  else
  {
    result = sub_5C64C(a1, v4);
    *(_QWORD *)(a1 + 792) = result;
  }
  return result;
}

//----- (000000000005DAF8) ----------------------------------------------------
__int64 __fastcall sub_5DAF8(_QWORD *a1, _QWORD *a2)
{
  int v4; // w24
  int v5; // w22
  __int64 result; // x0
  __int64 v7[202]; // [xsp+40h] [xbp+40h] BYREF
  __int64 (__fastcall *v8)(__int64, _QWORD, _QWORD, _QWORD *, _QWORD *); // [xsp+690h] [xbp+690h]

  while ( 1 )
  {
    v4 = sub_5CDEC(a2, (__int64)v7);
    v5 = sub_5C7B0((__int64)a2) - (a2[104] >> 63) == a1[3] ? 4 : 0;
    if ( v4 )
      break;
    if ( v8 )
    {
      result = v8(1, v5 | 2u, *a1, a1, a2);
      if ( (_DWORD)result == 7 )
        return result;
      if ( (_DWORD)result != 8 )
        break;
    }
    if ( v5 )
      abort();
    sub_5DAAC((__int64)a2, v7);
  }
  return 2;
}

//----- (000000000005DBB8) ----------------------------------------------------
__int64 __fastcall sub_5DBB8(_QWORD *a1, _QWORD *a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64, _QWORD, _QWORD *, _QWORD *, __int64); // x23
  __int64 v3; // x24
  unsigned int v6; // w0
  unsigned int v7; // w19
  __int64 v8; // x1
  unsigned int v9; // w0
  __int64 v11[202]; // [xsp+50h] [xbp+50h] BYREF
  __int64 (__fastcall *v12)(__int64, __int64, _QWORD, _QWORD *, _QWORD *); // [xsp+6A0h] [xbp+6A0h]

  v2 = (unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD *, _QWORD *, __int64))a1[2];
  v3 = a1[3];
  while ( 1 )
  {
    v6 = sub_5CDEC(a2, (__int64)v11);
    v7 = v6;
    if ( v6 != 5 && v6 )
      return 2;
    v8 = v6 == 5 ? 26LL : 10LL;
    if ( v2(1, v8, *a1, a1, a2, v3) )
      return 2;
    if ( v7 == 5 )
      return v7;
    if ( v12 )
      break;
LABEL_10:
    sub_5DAAC((__int64)a2, v11);
  }
  v9 = v12(1, 10, *a1, a1, a2);
  v7 = v9;
  if ( v9 != 7 )
  {
    if ( v9 != 8 )
      return 2;
    goto LABEL_10;
  }
  return v7;
}

//----- (000000000005DCA4) ----------------------------------------------------
__int64 __fastcall sub_5DCA4(__int64 a1, __int64 a2)
{
  int v4; // w0
  __int64 v5; // x1
  __int64 *v6; // x0
  _BYTE *v7; // x2
  _QWORD *v8; // x1
  int v9; // w3
  _QWORD v11[120]; // [xsp+30h] [xbp+30h] BYREF
  _BYTE v12[8]; // [xsp+3F0h] [xbp+3F0h] BYREF
  __int64 v13; // [xsp+3F8h] [xbp+3F8h] BYREF
  __int64 v14; // [xsp+A18h] [xbp+A18h] BYREF
  __int64 v15; // [xsp+A20h] [xbp+A20h]
  int v16; // [xsp+A30h] [xbp+A30h]
  __int64 v17; // [xsp+A58h] [xbp+A58h]
  __int64 v18; // [xsp+A68h] [xbp+A68h]

  memset(v11, 0, sizeof(v11));
  v11[99] = a1 + 1;
  v11[104] = 0x4000000000000000LL;
  v4 = sub_5CDEC(v11, (__int64)v12);
  v5 = 0;
  if ( !v4 && v16 != 2 )
  {
    v6 = &v13;
    v7 = (_BYTE *)(a2 + 820);
    v8 = (_QWORD *)(a2 + 32);
    do
    {
      v9 = *(unsigned __int8 *)v6;
      *v7 = v9;
      if ( v9 == 1 || v9 == 2 )
        *v8 = *(v6 - 1);
      else
        *v8 = 0;
      v6 += 2;
      ++v7;
      ++v8;
    }
    while ( v6 != &v14 );
    v5 = a2;
    *(_QWORD *)(a2 + 16) = v14;
    *(_WORD *)(a2 + 816) = v15;
    *(_WORD *)(a2 + 818) = v17;
    *(_QWORD *)(a2 + 24) = v11[106];
    *(_QWORD *)(a2 + 8) = v18;
  }
  return v5;
}

//----- (000000000005DD9C) ----------------------------------------------------
_QWORD *__fastcall sub_5DD9C(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x30
  int v11; // w0
  __int64 v12; // x0
  _QWORD v15[120]; // [xsp+D0h] [xbp+D0h] BYREF
  _QWORD v16[120]; // [xsp+490h] [xbp+490h] BYREF
  __int64 v17[202]; // [xsp+850h] [xbp+850h] BYREF
  __int64 (__fastcall *v18)(__int64, __int64, _QWORD, _QWORD *, _QWORD *); // [xsp+EA0h] [xbp+EA0h]

  sub_5D9D0(v15, (__int64)&a9, v9);
  memcpy(v16, v15, sizeof(v16));
  while ( !(unsigned int)sub_5CDEC(v16, (__int64)v17) )
  {
    if ( v18 )
    {
      v11 = v18(1, 1, *a1, a1, v16);
      if ( v11 == 6 )
      {
        a1[2] = 0;
        v12 = sub_5C7B0((__int64)v16);
        a1[3] = v12 - (v16[104] >> 63);
        memcpy(v16, v15, sizeof(v16));
        if ( (unsigned int)sub_5DAF8(a1, v16) == 7 )
        {
          sub_5C6A4((__int64)v15, (__int64)v16);
          nullsub_1(v16[98], v16[99]);
        }
        return a1;
      }
      if ( v11 != 8 )
        return a1;
    }
    sub_5DAAC((__int64)v16, v17);
  }
  return a1;
}
// 5DDEC: variable 'v9' is possibly undefined
// 5DD98: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000000005DF14) ----------------------------------------------------
_QWORD *__fastcall sub_5DF14(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x30
  _QWORD v15[120]; // [xsp+D0h] [xbp+D0h] BYREF
  _QWORD v16[120]; // [xsp+490h] [xbp+490h] BYREF

  sub_5D9D0(v15, (__int64)&a9, v9);
  memcpy(v16, v15, sizeof(v16));
  a1[2] = a2;
  a1[3] = a3;
  if ( (unsigned int)sub_5DBB8(a1, v16) == 7 )
  {
    sub_5C6A4((__int64)v15, (__int64)v16);
    nullsub_1(v16[98], v16[99]);
  }
  return a1;
}
// 5DF6C: variable 'v9' is possibly undefined
// 5DD98: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000000005E008) ----------------------------------------------------
_QWORD *__fastcall sub_5E008(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x30
  int v11; // w0
  _QWORD v14[120]; // [xsp+D0h] [xbp+D0h] BYREF
  _QWORD v15[120]; // [xsp+490h] [xbp+490h] BYREF

  sub_5D9D0(v14, (__int64)&a9, v9);
  memcpy(v15, v14, sizeof(v15));
  if ( a1[2] )
    v11 = sub_5DBB8(a1, v15);
  else
    v11 = sub_5DAF8(a1, v15);
  if ( v11 != 7 )
    abort();
  sub_5C6A4((__int64)v14, (__int64)v15);
  nullsub_1(v15[98], v15[99]);
  return a1;
}
// 5E058: variable 'v9' is possibly undefined
// 5DD98: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000000005E104) ----------------------------------------------------
_QWORD *__fastcall sub_5E104(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x30
  char v12; // [xsp+0h] [xbp+0h]
  _QWORD v14[120]; // [xsp+D0h] [xbp+D0h] BYREF
  _QWORD v15[120]; // [xsp+490h] [xbp+490h] BYREF

  if ( a1[2] )
  {
    sub_5D9D0(v14, (__int64)&a9, v9);
    memcpy(v15, v14, sizeof(v15));
    if ( (unsigned int)sub_5DBB8(a1, v15) != 7 )
      abort();
    sub_5C6A4((__int64)v14, (__int64)v15);
    nullsub_1(v15[98], v15[99]);
  }
  else
  {
    sub_5DD9C(a1, 0, v9, a4, a5, a6, a7, a8, v12);
  }
  return a1;
}
// 5E14C: variable 'v9' is possibly undefined
// 5E14C: variable 'v12' is possibly undefined
// 5DD98: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000000005E1FC) ----------------------------------------------------
__int64 __fastcall sub_5E1FC(__int64 result)
{
  __int64 (__fastcall *v1)(__int64, __int64); // x2

  v1 = *(__int64 (__fastcall **)(__int64, __int64))(result + 8);
  if ( v1 )
    return v1(1, result);
  return result;
}

//----- (000000000005E220) ----------------------------------------------------
__int64 __fastcall sub_5E220(
        unsigned int (__fastcall *a1)(_QWORD *, __int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x30
  int v12; // w0
  int v13; // w19
  _QWORD v15[120]; // [xsp+A0h] [xbp+A0h] BYREF
  __int64 v16[208]; // [xsp+460h] [xbp+460h] BYREF

  sub_5D9D0(v15, (__int64)&a9, v9);
  while ( 1 )
  {
    v12 = sub_5CDEC(v15, (__int64)v16);
    v13 = v12;
    if ( v12 != 5 && v12 || a1(v15, a2) )
      return 3;
    if ( v13 == 5 )
      break;
    sub_5DAAC((__int64)v15, v16);
  }
  return 5;
}
// 5E26C: variable 'v9' is possibly undefined

//----- (000000000005E2F0) ----------------------------------------------------
char *__fastcall sub_5E2F0(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  int v3; // w3
  char v4; // t1
  unsigned __int64 v5; // x4

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = *result++;
    v5 = (unsigned __int64)(v4 & 0x7F) << v3;
    v3 += 7;
    v2 |= v5;
  }
  while ( v4 < 0 );
  *a2 = v2;
  return result;
}

//----- (000000000005E318) ----------------------------------------------------
char *__fastcall sub_5E318(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  unsigned int v3; // w3
  char v4; // w4
  char v5; // t1
  unsigned __int64 v6; // x5

  v2 = 0;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v6 = (unsigned __int64)(v5 & 0x7F) << v3;
    v3 += 7;
    v2 |= v6;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x3F && (v4 & 0x40) != 0 )
    v2 |= -1LL << v3;
  *a2 = v2;
  return result;
}

//----- (000000000005E358) ----------------------------------------------------
__int64 __fastcall sub_5E358(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x1
  __int64 result; // x0

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a3 + 8);
  if ( v3 >= v4 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v3 > v4 )
    return 1;
  else
    return (unsigned int)result;
}

//----- (000000000005E374) ----------------------------------------------------
__int64 __fastcall sub_5E374(
        __int64 result,
        __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD),
        __int64 a3,
        int a4,
        int a5)
{
  __int64 v5; // x24
  int i; // w19
  int v10; // w0
  __int64 v11; // x21
  __int64 v12; // x0
  int v13; // [xsp+58h] [xbp+58h]

  v5 = result;
  for ( i = 2 * a4 + 1; i < a5; i = result + 1 )
  {
    if ( i + 1 < a5 )
    {
      v13 = a4;
      v10 = a2(v5, *(_QWORD *)(a3 + 8LL * i), *(_QWORD *)(a3 + 8LL * i + 8));
      a4 = v13;
      if ( v10 < 0 )
        ++i;
    }
    v11 = 8LL * a4;
    result = a2(v5, *(_QWORD *)(a3 + v11), *(_QWORD *)(a3 + 8LL * i));
    if ( (result & 0x80000000) == 0 )
      break;
    a4 = i;
    v12 = *(_QWORD *)(a3 + v11);
    *(_QWORD *)(a3 + v11) = *(_QWORD *)(a3 + 8LL * i);
    *(_QWORD *)(a3 + 8LL * i) = v12;
    result = (unsigned int)(2 * i);
  }
  return result;
}

//----- (000000000005E434) ----------------------------------------------------
__int64 __fastcall sub_5E434(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3)
{
  unsigned __int64 v3; // x19
  __int64 v4; // x24
  __int64 v7; // x22
  unsigned __int64 i; // x20
  __int64 v9; // x20
  int v10; // w19
  __int64 v11; // x23
  int v12; // w4
  __int64 v13; // x0

  v3 = *(_QWORD *)(a3 + 8);
  v4 = result;
  v7 = a3 + 16;
  for ( i = v3 >> 1; ; result = sub_5E374(v4, a2, v7, i, v3) )
  {
    LODWORD(i) = i - 1;
    if ( (i & 0x80000000) != 0 )
      break;
  }
  v9 = 0;
  v10 = v3 - 1;
  v11 = v7 + 8LL * v10;
  while ( v10 > 0 )
  {
    v12 = v10;
    v13 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(v11 + v9);
    *(_QWORD *)(v11 + v9) = v13;
    --v10;
    v9 -= 8;
    result = sub_5E374(v4, a2, v7, 0, v12);
  }
  return result;
}

//----- (000000000005E4E8) ----------------------------------------------------
__int64 __fastcall sub_5E4E8(unsigned __int8 a1)
{
  __int64 result; // x0

  if ( a1 == 255 )
    return 0;
  switch ( a1 & 7 )
  {
    case 0:
    case 4:
      result = 8;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 4;
      break;
    default:
      abort();
  }
  return result;
}

//----- (000000000005E548) ----------------------------------------------------
__int64 __fastcall sub_5E548(unsigned __int8 a1, __int64 a2)
{
  unsigned int v2; // w0
  bool v3; // zf

  if ( a1 == 255 )
    return 0;
  v2 = a1 & 0x70;
  if ( v2 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( v2 > 0x20 )
  {
    if ( v2 == 48 )
      return *(_QWORD *)(a2 + 16);
    v3 = v2 == 80;
    goto LABEL_8;
  }
  v3 = v2 == 16;
  if ( v2 )
  {
LABEL_8:
    if ( !v3 )
      abort();
  }
  return 0;
}

//----- (000000000005E5A8) ----------------------------------------------------
__int64 __fastcall sub_5E5A8(unsigned __int8 a1, __int64 a2)
{
  unsigned int v2; // w0
  bool v3; // zf

  if ( a1 == 255 )
    return 0;
  v2 = a1 & 0x70;
  if ( v2 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( v2 > 0x20 )
  {
    if ( v2 == 48 )
      return *(_QWORD *)(a2 + 16);
    v3 = v2 == 80;
    goto LABEL_8;
  }
  v3 = v2 == 16;
  if ( v2 )
  {
LABEL_8:
    if ( !v3 )
      abort();
  }
  return 0;
}

//----- (000000000005E608) ----------------------------------------------------
char *__fastcall sub_5E608(char a1, char *a2, char *a3, unsigned __int64 *a4)
{
  char *v5; // x19
  _QWORD *v8; // x0
  char *result; // x0
  unsigned __int64 v10; // x1
  _QWORD *v11; // t1
  _QWORD *v12; // [xsp+38h] [xbp+38h] BYREF

  v5 = a3;
  if ( a1 == 80 )
  {
    v8 = (_QWORD *)((unsigned __int64)(a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v11 = (_QWORD *)*v8;
    result = (char *)(v8 + 1);
    v10 = (unsigned __int64)v11;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 4:
      case 0xC:
        result = a3 + 8;
        v10 = *(_QWORD *)a3;
        break;
      case 1:
        result = sub_5E2F0(a3, &v12);
        goto LABEL_6;
      case 2:
        result = a3 + 2;
        v10 = *(unsigned __int16 *)a3;
        break;
      case 3:
        result = a3 + 4;
        v10 = *(unsigned int *)a3;
        break;
      case 9:
        result = sub_5E318(a3, &v12);
LABEL_6:
        v10 = (unsigned __int64)v12;
        break;
      case 0xA:
        result = a3 + 2;
        v10 = *(__int16 *)a3;
        break;
      case 0xB:
        result = a3 + 4;
        v10 = *(int *)a3;
        break;
      default:
        abort();
    }
    if ( v10 )
    {
      if ( (a1 & 0x70) != 0x10 )
        v5 = a2;
      v10 += (unsigned __int64)v5;
      if ( a1 < 0 )
        v10 = *(_QWORD *)v10;
    }
  }
  *a4 = v10;
  return result;
}

//----- (000000000005E6F8) ----------------------------------------------------
__int64 __fastcall sub_5E6F8(__int64 a1, __int64 a2, __int64 a3)
{
  char v5; // w19
  char *v7; // x21
  __int64 result; // x0
  unsigned __int64 v9; // [xsp+40h] [xbp+40h] BYREF
  unsigned __int64 v10; // [xsp+48h] [xbp+48h] BYREF

  v5 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v7 = (char *)sub_5E548(v5, a1);
  sub_5E608(v5, v7, (char *)(a2 + 8), &v9);
  sub_5E608((unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3, v7, (char *)(a3 + 8), &v10);
  if ( v9 >= v10 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v9 > v10 )
    return 1;
  else
    return (unsigned int)result;
}

//----- (000000000005E788) ----------------------------------------------------
__int64 __fastcall sub_5E788(__int64 a1)
{
  __int64 v1; // x20
  size_t v3; // x0
  char *v4; // x1
  int v5; // w2
  __int64 result; // x0
  char *v7; // x0
  char *v8; // x0
  char *v9; // x0
  unsigned __int8 *v10; // x19
  char *v11; // x0
  int v12; // w1
  unsigned __int64 v13; // [xsp+28h] [xbp+28h] BYREF
  __int64 v14; // [xsp+30h] [xbp+30h] BYREF
  __int64 v15; // [xsp+38h] [xbp+38h] BYREF

  v1 = a1 + 9;
  v3 = strlen((const char *)(a1 + 9)) + 1;
  v4 = (char *)(v1 + v3);
  if ( *(unsigned __int8 *)(a1 + 8) > 3u )
  {
    v5 = *(unsigned __int8 *)(v1 + v3);
    result = 255;
    if ( v5 != 8 || v4[1] )
      return result;
    v4 += 2;
  }
  if ( *(_BYTE *)(a1 + 9) != 122 )
    return 0;
  v7 = sub_5E2F0(v4, &v14);
  v8 = sub_5E318(v7, &v15);
  if ( *(_BYTE *)(a1 + 8) == 1 )
    v9 = v8 + 1;
  else
    v9 = sub_5E2F0(v8, &v14);
  v10 = (unsigned __int8 *)(a1 + 10);
  v11 = sub_5E2F0(v9, &v14);
  while ( 1 )
  {
    v12 = *v10;
    if ( v12 == 82 )
      break;
    if ( v12 == 80 )
    {
      v11 = sub_5E608(*v11 & 0x7F, 0, v11 + 1, &v13);
    }
    else
    {
      if ( v12 != 76 )
        return 0;
      ++v11;
    }
    ++v10;
  }
  return (unsigned __int8)*v11;
}

//----- (000000000005E884) ----------------------------------------------------
unsigned int *__fastcall sub_5E884(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned __int8 v4; // w0
  int v7; // w21
  char *v8; // x27
  __int64 v9; // x0
  signed int v10; // w1
  __int64 v11; // x20
  unsigned __int64 v12; // x1
  char *v14; // x0
  unsigned int v15; // w0
  __int64 v16; // x1
  unsigned __int64 v17; // [xsp+60h] [xbp+60h] BYREF
  unsigned __int64 v18; // [xsp+68h] [xbp+68h] BYREF

  v4 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v7 = v4;
  v8 = (char *)sub_5E548(v4, a1);
  v9 = 0;
  while ( *a2 )
  {
    v10 = a2[1];
    if ( !v10 )
    {
      v11 = v9;
      goto LABEL_16;
    }
    v11 = v9;
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v11 = (__int64)a2 - v10 + 4;
      if ( v11 != v9 )
      {
        v7 = sub_5E788((__int64)a2 - v10 + 4);
        v8 = (char *)sub_5E548(v7, a1);
      }
    }
    if ( v7 )
    {
      v14 = sub_5E608(v7, v8, (char *)a2 + 8, &v17);
      sub_5E608(v7 & 0xF, 0, v14, &v18);
      v15 = sub_5E4E8(v7);
      v16 = -1;
      if ( v15 <= 7uLL )
        v16 = (1LL << (8 * (unsigned __int8)v15)) - 1;
      if ( (v16 & v17) == 0 )
        goto LABEL_16;
    }
    else
    {
      v12 = *((_QWORD *)a2 + 2);
      v17 = *((_QWORD *)a2 + 1);
      v18 = v12;
      if ( !v17 )
        goto LABEL_16;
    }
    if ( a3 - v17 < v18 )
      return a2;
LABEL_16:
    a2 = (unsigned int *)((char *)a2 + *a2 + 4);
    v9 = v11;
  }
  return 0;
}

//----- (000000000005E9E4) ----------------------------------------------------
__int64 __fastcall sub_5E9E4(__int64 a1)
{
  return sub_5E788(a1 + 4 - *(int *)(a1 + 4));
}

//----- (000000000005E9F4) ----------------------------------------------------
__int64 __fastcall sub_5E9F4(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  _BOOL4 v3; // w14
  int *v4; // x6
  __int64 v5; // x7
  __int64 v6; // x5
  __int64 v7; // x9
  __int64 v8; // x4
  _QWORD *v9; // x5
  _QWORD *i; // x1
  int *v11; // x8
  pthread_mutex_t *v12; // x1
  __int64 v13; // x13
  unsigned __int64 v14; // x9
  __int64 v15; // x10
  __int64 v16; // x12
  int *v17; // x11
  int v18; // w0
  unsigned __int64 v19; // x1
  _QWORD *v21; // x0
  _BYTE *v22; // x21
  char v23; // w20
  char *v25; // x0
  char *v26; // x0
  int v27; // w20
  char *v28; // x0
  char *v29; // x22
  unsigned __int64 v30; // x1
  unsigned __int64 v31; // x0
  unsigned __int64 v32; // x3
  unsigned __int64 v33; // x4
  __int64 v34; // x20
  __int64 v35; // x23
  unsigned __int8 v36; // w24
  unsigned int v37; // w0
  _BYTE *v38; // x21
  __int64 v39; // x2
  unsigned int *v40; // x0
  char v41; // w20
  char *v42; // x0
  char *v43; // [xsp+48h] [xbp+48h]
  unsigned int *v44; // [xsp+50h] [xbp+50h] BYREF
  unsigned __int64 v45; // [xsp+58h] [xbp+58h] BYREF
  unsigned __int64 v46[4]; // [xsp+60h] [xbp+60h] BYREF
  __int64 v47; // [xsp+80h] [xbp+80h]

  v3 = a2 > 0x2F;
  v4 = (int *)a1[2];
  v5 = *a1;
  if ( a2 > 0x2F && *(_DWORD *)(a3 + 40) )
  {
    v6 = a1[5];
    if ( a1[4] == qword_80038 && v6 == qword_802F8 )
    {
      v7 = qword_80300;
      v8 = 0;
      v9 = 0;
      for ( i = (_QWORD *)qword_80300; i; i = (_QWORD *)i[5] )
      {
        if ( *(_QWORD *)a3 >= *i && *(_QWORD *)a3 < i[1] )
        {
          v5 = i[2];
          v11 = (int *)i[3];
          if ( i != (_QWORD *)qword_80300 )
          {
            v9[5] = i[5];
            i[5] = v7;
            qword_80300 = (__int64)i;
          }
          goto LABEL_41;
        }
        if ( *(_OWORD *)i == 0 )
        {
          v8 = (__int64)i;
          break;
        }
        v8 = (__int64)i;
        if ( i[5] )
          v9 = i;
      }
LABEL_21:
      v13 = *((unsigned __int16 *)a1 + 12);
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v11 = 0;
      while ( --v13 != -1 )
      {
        v18 = *v4;
        if ( *v4 == 1 )
        {
          v19 = v5 + *((_QWORD *)v4 + 2);
          if ( *(_QWORD *)a3 >= v19 && *(_QWORD *)a3 < v19 + *((_QWORD *)v4 + 5) )
          {
            v14 = v19 + *((_QWORD *)v4 + 5);
            v15 = v5 + *((_QWORD *)v4 + 2);
            v16 = 1;
          }
        }
        else if ( v18 == 1685382480 )
        {
          v11 = v4;
        }
        else if ( v18 == 2 )
        {
          v17 = v4;
        }
        v4 += 14;
      }
      if ( !v16 )
        return 0;
      if ( v3 )
      {
        if ( v9 && v8 )
        {
          v9[5] = *(_QWORD *)(v8 + 40);
          *(_QWORD *)(v8 + 40) = qword_80300;
          qword_80300 = v8;
        }
        v21 = (_QWORD *)qword_80300;
        *(_QWORD *)(qword_80300 + 16) = v5;
        v21[3] = v11;
        v21[4] = v17;
        *v21 = v15;
        v21[1] = v14;
      }
LABEL_41:
      if ( !v11 )
        return 0;
      v22 = (_BYTE *)(v5 + *((_QWORD *)v11 + 2));
      if ( *v22 != 1 )
        return 1;
      v23 = v22[1];
      v25 = (char *)sub_5E5A8(v23, a3);
      v26 = sub_5E608(v23, v25, v22 + 4, (unsigned __int64 *)&v44);
      v27 = (unsigned __int8)v22[2];
      if ( v27 != 255 && v22[3] == 59 )
      {
        v43 = v26;
        v28 = (char *)sub_5E5A8(v27, a3);
        v29 = sub_5E608(v27, v28, v43, &v45);
        if ( !v45 )
          return 1;
        if ( ((unsigned __int8)v29 & 3) == 0 )
        {
          v30 = *(_QWORD *)a3;
          if ( *(_QWORD *)a3 >= (unsigned __int64)&v22[*(int *)v29] )
          {
            v31 = v45 - 1;
            if ( v30 < (unsigned __int64)&v22[*(int *)&v29[8 * v45 - 8]] )
            {
              v32 = v45 - 1;
              v33 = 0;
              do
              {
                while ( 1 )
                {
                  if ( v33 >= v32 )
                    abort();
                  v31 = (v32 + v33) >> 1;
                  if ( v30 >= (unsigned __int64)&v22[*(int *)&v29[8 * v31]] )
                    break;
                  v32 = (v32 + v33) >> 1;
                }
                v33 = v31 + 1;
              }
              while ( v30 >= (unsigned __int64)&v22[*(int *)&v29[8 * v31 + 8]] );
            }
            v34 = 8 * v31;
            v35 = (__int64)&v22[*(int *)&v29[8 * v31 + 4]];
            v36 = sub_5E9E4(v35);
            v37 = sub_5E4E8(v36);
            sub_5E608(v36 & 0xF, 0, (char *)(v35 + v37 + 8), v46);
            v38 = &v22[*(int *)&v29[v34]];
            if ( *(_QWORD *)a3 < (unsigned __int64)&v38[v46[0]] )
              *(_QWORD *)(a3 + 32) = v35;
            *(_QWORD *)(a3 + 24) = v38;
          }
          return 1;
        }
      }
      v46[1] = *(_QWORD *)(a3 + 8);
      v46[2] = *(_QWORD *)(a3 + 16);
      v47 = 0;
      v39 = *(_QWORD *)a3;
      LOBYTE(v47) = 4;
      v46[0] = 0;
      v46[3] = (unsigned __int64)v44;
      v40 = sub_5E884((__int64)v46, v44, v39);
      *(_QWORD *)(a3 + 32) = v40;
      if ( v40 )
      {
        v41 = sub_5E9E4((__int64)v40);
        v42 = (char *)sub_5E5A8(v41, a3);
        sub_5E608(v41, v42, (char *)(*(_QWORD *)(a3 + 32) + 8LL), &v45);
        *(_QWORD *)(a3 + 24) = v45;
      }
      return 1;
    }
    qword_80038 = a1[4];
    v12 = (pthread_mutex_t *)&unk_80338;
    qword_802F8 = v6;
    do
    {
      v12[-2].__list.__next = 0;
      v12[-1].__align = 0;
      v12[-1].__list.__next = (struct __pthread_internal_list *)v12;
      v12 = (pthread_mutex_t *)((char *)v12 + 48);
    }
    while ( v12 != (pthread_mutex_t *)(&stru_80498.__align + 4) );
    qword_80480 = 0;
    qword_80300 = (__int64)&unk_80308;
    *(_DWORD *)(a3 + 40) = 0;
LABEL_19:
    v8 = 0;
    v9 = 0;
    goto LABEL_21;
  }
  if ( a2 > 0x19 )
    goto LABEL_19;
  return 0xFFFFFFFFLL;
}
// 80038: using guessed type __int64 qword_80038;
// 802F8: using guessed type __int64 qword_802F8;
// 80300: using guessed type __int64 qword_80300;
// 80480: using guessed type __int64 qword_80480;
// 80498: using guessed type pthread_mutex_t stru_80498;

//----- (000000000005EE10) ----------------------------------------------------
__int64 __fastcall sub_5EE10(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x20
  char v6; // w22
  char *v7; // x0
  char *v8; // x0
  __int64 result; // x0
  unsigned __int64 v10; // [xsp+30h] [xbp+30h] BYREF
  unsigned __int64 v11; // [xsp+38h] [xbp+38h] BYREF

  v5 = a2;
  v6 = sub_5E9E4(a2);
  v7 = (char *)sub_5E548(v6, a1);
  sub_5E608(v6, v7, (char *)(v5 + 8), &v10);
  LOBYTE(v5) = sub_5E9E4(a3);
  v8 = (char *)sub_5E548(v5, a1);
  sub_5E608(v5, v8, (char *)(a3 + 8), &v11);
  if ( v10 >= v11 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v10 > v11 )
    return 1;
  else
    return (unsigned int)result;
}

//----- (000000000005EEAC) ----------------------------------------------------
__int64 __fastcall sub_5EEAC(__int64 a1, char *a2)
{
  char *v4; // x26
  int v5; // w25
  __int64 v6; // x22
  __int64 v7; // x0
  signed int v8; // w21
  __int64 v9; // x21
  int v10; // w0
  unsigned __int8 v12; // w27
  unsigned __int64 v13; // x1
  unsigned int v14; // w0
  __int64 v15; // x1
  unsigned __int64 v16; // [xsp+68h] [xbp+68h] BYREF

  v4 = 0;
  LOBYTE(v5) = 0;
  v6 = 0;
  v7 = 0;
  while ( *(_DWORD *)a2 )
  {
    v8 = *((_DWORD *)a2 + 1);
    if ( v8 )
    {
      v9 = (__int64)&a2[-v8 + 4];
      if ( v9 == v7 )
      {
        v9 = v7;
      }
      else
      {
        v10 = sub_5E788(v9);
        v5 = v10;
        if ( v10 == 255 )
          return -1;
        v12 = v10;
        v4 = (char *)sub_5E548(v10, a1);
        v13 = *(unsigned __int16 *)(a1 + 32);
        if ( (v13 & 0x7F8) == 0x7F8 )
        {
          *(_WORD *)(a1 + 32) = v13 & 0xF807 | (8 * v12);
        }
        else if ( (unsigned __int8)(v13 >> 3) != v5 )
        {
          *(_BYTE *)(a1 + 32) |= 4u;
        }
      }
      sub_5E608(v5, v4, a2 + 8, &v16);
      v14 = sub_5E4E8(v5);
      v15 = -1;
      if ( v14 <= 7uLL )
        v15 = (1LL << (8 * (unsigned __int8)v14)) - 1;
      if ( (v15 & v16) != 0 )
      {
        ++v6;
        if ( v16 < *(_QWORD *)a1 )
          *(_QWORD *)a1 = v16;
      }
    }
    else
    {
      v9 = v7;
    }
    a2 += *(unsigned int *)a2 + 4;
    v7 = v9;
  }
  return v6;
}

//----- (000000000005F00C) ----------------------------------------------------
__int64 __fastcall sub_5F00C(__int64 a1, __int64 *a2, unsigned int *a3)
{
  unsigned __int8 v4; // w0
  int v6; // w21
  char *v8; // x26
  __int64 result; // x0
  signed int v10; // w1
  __int64 v11; // x20
  unsigned int v12; // w0
  __int64 v13; // x1
  __int64 v14; // x0
  __int64 v15; // x1
  unsigned __int64 v16; // [xsp+68h] [xbp+68h] BYREF

  v4 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v6 = v4;
  v8 = (char *)sub_5E548(v4, a1);
  result = 0;
  while ( *a3 )
  {
    v10 = a3[1];
    v11 = result;
    if ( !v10 )
      goto LABEL_15;
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v11 = (__int64)a3 - v10 + 4;
      if ( v11 != result )
      {
        v6 = sub_5E788((__int64)a3 - v10 + 4);
        v8 = (char *)sub_5E548(v6, a1);
      }
    }
    if ( !v6 )
    {
      if ( !*((_QWORD *)a3 + 1) )
        goto LABEL_15;
LABEL_13:
      v14 = *a2;
      if ( *a2 )
      {
        v15 = *(_QWORD *)(v14 + 8);
        *(_QWORD *)(v14 + 8) = v15 + 1;
        *(_QWORD *)(v14 + 8 * (v15 + 2)) = a3;
      }
      goto LABEL_15;
    }
    sub_5E608(v6, v8, (char *)a3 + 8, &v16);
    v12 = sub_5E4E8(v6);
    v13 = -1;
    if ( v12 <= 7uLL )
      v13 = (1LL << (8 * (unsigned __int8)v12)) - 1;
    if ( (v13 & v16) != 0 )
      goto LABEL_13;
LABEL_15:
    a3 = (unsigned int *)((char *)a3 + *a3 + 4);
    result = v11;
  }
  return result;
}

//----- (000000000005F140) ----------------------------------------------------
unsigned int *__fastcall sub_5F140(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // x20
  char **i; // x21
  __int64 v6; // x0
  int v7; // w0
  _QWORD *v8; // x0
  _QWORD *v9; // x0
  __int64 v10; // x5
  __int64 v11; // x4
  __int64 v12; // x1
  __int64 k; // x2
  char *v14; // x26
  _QWORD *v15; // x27
  _QWORD *v16; // x21
  __int64 v17; // x20
  __int64 v18; // x24
  __int64 v19; // x26
  _QWORD *v20; // x25
  __int64 v21; // x28
  _QWORD *v22; // x0
  unsigned int *result; // x0
  __int64 v24; // x27
  unsigned __int64 v25; // x24
  unsigned __int64 m; // x23
  unsigned __int64 v27; // x21
  __int64 v28; // x20
  char v29; // w28
  char *v30; // x0
  char *v31; // x0
  unsigned __int64 v32; // x0
  __int64 v33; // x5
  unsigned __int64 v34; // x3
  unsigned __int64 v35; // x2
  unsigned __int64 v36; // x1
  unsigned __int64 v37; // x6
  __int64 v38; // x24
  unsigned __int64 v39; // x23
  char v40; // w25
  char *v41; // x28
  unsigned __int64 v42; // x21
  unsigned __int64 *v43; // x4
  unsigned __int64 v44; // x19
  char *v45; // x0
  unsigned int **n; // x20
  unsigned int **j; // x21
  unsigned int *v48; // x2
  _QWORD *v49; // x24
  __int64 (__fastcall *v50)(__int64, __int64, __int64); // x23
  _QWORD *v51; // x25
  __int64 v52; // x3
  __int64 *v53; // x21
  __int64 *v54; // x28
  __int64 v55; // x27
  __int64 *v56; // x4
  int v57; // w0
  char *v58; // x0
  char *v59; // x0
  __int64 v60; // x0
  __int64 v61; // x4
  __int64 v62; // x1
  __int64 *v63; // [xsp+60h] [xbp+60h]
  unsigned __int64 *v64; // [xsp+68h] [xbp+68h]
  __int64 v65; // [xsp+68h] [xbp+68h]
  unsigned __int64 v66; // [xsp+78h] [xbp+78h] BYREF
  _QWORD *v67; // [xsp+80h] [xbp+80h] BYREF
  void *p; // [xsp+88h] [xbp+88h]

  if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
    goto LABEL_2;
  v4 = *(_DWORD *)(a1 + 32) >> 11;
  if ( *(_DWORD *)(a1 + 32) >> 11 )
    goto LABEL_16;
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    for ( i = *(char ***)(a1 + 24); *i; ++i )
    {
      v6 = sub_5EEAC(a1, *i);
      if ( v6 == -1 )
        goto LABEL_9;
      v4 += v6;
    }
  }
  else
  {
    v4 = sub_5EEAC(a1, *(char **)(a1 + 24));
    if ( v4 == -1 )
    {
LABEL_9:
      *(_QWORD *)(a1 + 32) = 0;
      *(_WORD *)(a1 + 32) = 2040;
      *(_QWORD *)(a1 + 24) = &unk_80490;
      goto LABEL_32;
    }
  }
  v7 = (v4 & 0x1FFFFF) == v4 ? *(_DWORD *)(a1 + 32) & 0x7FF | ((_DWORD)v4 << 11) : *(_DWORD *)(a1 + 32) & 0x7FF;
  *(_DWORD *)(a1 + 32) = v7;
  if ( v4 )
  {
LABEL_16:
    v8 = malloc(8 * (v4 + 2));
    v67 = v8;
    if ( v8 )
    {
      v8[1] = 0;
      v9 = malloc(8 * (v4 + 2));
      p = v9;
      if ( v9 )
        v9[1] = 0;
      if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
      {
        for ( j = *(unsigned int ***)(a1 + 24); ; ++j )
        {
          v48 = *j;
          if ( !*j )
            break;
          sub_5F00C(a1, (__int64 *)&v67, v48);
        }
      }
      else
      {
        sub_5F00C(a1, (__int64 *)&v67, *(unsigned int **)(a1 + 24));
      }
      v49 = v67;
      if ( v67 && v67[1] != v4 )
LABEL_69:
        abort();
      if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
      {
        v50 = sub_5EE10;
      }
      else if ( (*(_WORD *)(a1 + 32) & 0x7F8) != 0 )
      {
        v50 = sub_5E6F8;
      }
      else
      {
        v50 = sub_5E358;
      }
      v51 = p;
      if ( p )
      {
        v14 = (char *)(v67 + 2);
        v52 = v67[1];
        v53 = (__int64 *)algn_80488;
        v54 = v67 + 2;
        v55 = 0;
        v56 = (__int64 *)algn_80488;
        while ( v55 != v52 )
        {
          while ( v53 != v56 )
          {
            v63 = v56;
            v65 = v52;
            v57 = v50(a1, *v54, *v53);
            v52 = v65;
            v56 = v63;
            if ( (v57 & 0x80000000) == 0 )
              break;
            v58 = (char *)v51 + (char *)v53 - v14;
            v53 = (__int64 *)*((_QWORD *)v58 + 2);
            *((_QWORD *)v58 + 2) = 0;
          }
          v59 = (char *)&v51[v55++];
          *((_QWORD *)v59 + 2) = v53;
          v53 = v54++;
        }
        v60 = 0;
        v12 = 0;
        for ( k = 0; k != v52; ++k )
        {
          v10 = *(_QWORD *)v14;
          if ( v51[k + 2] )
          {
            v11 = v12 + 2;
            ++v12;
            v49[v11] = v10;
          }
          else
          {
            v61 = v60 + 2;
            ++v60;
            v51[v61] = v10;
          }
          v14 += 8;
        }
        v49[1] = v12;
        v51[1] = v60;
        if ( *((_QWORD *)p + 1) + v67[1] != v4 )
          goto LABEL_69;
        sub_5E434(a1, v50, (__int64)p);
        v15 = p;
        v16 = v67;
        v17 = *((_QWORD *)p + 1);
        if ( v17 )
        {
          v18 = v67[1];
          v19 = v17;
          do
          {
            --v17;
            v20 = &v16[v18];
            v21 = v15[v19 + 1];
            while ( v18 )
            {
              v62 = v20[1];
              --v20;
              if ( (int)v50(a1, v62, v21) <= 0 )
                break;
              --v18;
              v20[v19 + 2] = v20[2];
            }
            --v19;
            v16[v17 + 2 + v18] = v21;
          }
          while ( v17 );
          v16[1] += v15[1];
        }
        free(p);
      }
      else
      {
        sub_5E434(a1, v50, (__int64)v67);
      }
      v22 = v67;
      *v67 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = v22;
      *(_BYTE *)(a1 + 32) |= 1u;
    }
  }
LABEL_32:
  if ( a2 < *(_QWORD *)a1 )
    return 0;
LABEL_2:
  if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v24 = *(_QWORD *)(a1 + 24);
      v25 = 0;
      for ( m = *(_QWORD *)(v24 + 8); v25 < m; m = v27 )
      {
        v27 = (m + v25) >> 1;
        v28 = *(_QWORD *)(v24 + 8 * (v27 + 2));
        v29 = sub_5E9E4(v28);
        v30 = (char *)sub_5E548(v29, a1);
        v31 = sub_5E608(v29, v30, (char *)(v28 + 8), &v66);
        sub_5E608(v29 & 0xF, 0, v31, (unsigned __int64 *)&v67);
        if ( a2 >= v66 )
        {
          if ( a2 < (unsigned __int64)v67 + v66 )
            return (unsigned int *)v28;
          v25 = v27 + 1;
          v27 = m;
        }
      }
    }
    else
    {
      v32 = *(unsigned __int16 *)(a1 + 32);
      if ( (v32 & 0x7F8) != 0 )
      {
        v38 = *(_QWORD *)(a1 + 24);
        v39 = 0;
        v40 = v32 >> 3;
        v41 = (char *)sub_5E548(v40, a1);
        v42 = *(_QWORD *)(v38 + 8);
        v43 = &v66;
        while ( v39 < v42 )
        {
          v44 = (v42 + v39) >> 1;
          v64 = v43;
          v28 = *(_QWORD *)(v38 + 8 * (v44 + 2));
          v45 = sub_5E608(v40, v41, (char *)(v28 + 8), v43);
          sub_5E608(v40 & 0xF, 0, v45, (unsigned __int64 *)&v67);
          v43 = v64;
          if ( a2 >= v66 )
          {
            if ( a2 < (unsigned __int64)v67 + v66 )
              return (unsigned int *)v28;
            v39 = v44 + 1;
            v44 = v42;
          }
          v42 = v44;
        }
      }
      else
      {
        v33 = *(_QWORD *)(a1 + 24);
        v34 = 0;
        v35 = *(_QWORD *)(v33 + 8);
        while ( v34 < v35 )
        {
          v36 = (v35 + v34) >> 1;
          result = *(unsigned int **)(v33 + 8 * (v36 + 2));
          v37 = *((_QWORD *)result + 1);
          if ( a2 < v37 )
          {
            v35 = (v35 + v34) >> 1;
          }
          else
          {
            if ( a2 < v37 + *((_QWORD *)result + 2) )
              return result;
            v34 = v36 + 1;
          }
        }
      }
    }
    return 0;
  }
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    for ( n = *(unsigned int ***)(a1 + 24); *n; ++n )
    {
      result = sub_5E884(a1, *n, a2);
      if ( result )
        return result;
    }
    return 0;
  }
  return sub_5E884(a1, *(unsigned int **)(a1 + 24), a2);
}
// 80488: using guessed type _BYTE[8];

//----- (000000000005F6B0) ----------------------------------------------------
__int64 *__fastcall sub_5F6B0(__int64 *result, _QWORD *a2, __int64 a3, __int64 a4)
{
  if ( result && *(_DWORD *)result )
  {
    *a2 = -1;
    a2[4] = 0;
    a2[3] = result;
    a2[1] = a3;
    a2[2] = a4;
    *((_WORD *)a2 + 16) = 2040;
    if ( &pthread_create )
      pthread_mutex_lock(&stru_80498);
    result = &qword_802F8;
    a2[5] = qword_804C0;
    qword_804C0 = (__int64)a2;
    if ( &pthread_create )
      return (__int64 *)pthread_mutex_unlock(&stru_80498);
  }
  return result;
}
// 802F8: using guessed type __int64 qword_802F8;
// 80498: using guessed type pthread_mutex_t;
// 804C0: using guessed type __int64 qword_804C0;

//----- (000000000005F74C) ----------------------------------------------------
__int64 *__fastcall sub_5F74C(__int64 *a1, _QWORD *a2)
{
  return sub_5F6B0(a1, a2, 0, 0);
}

//----- (000000000005F758) ----------------------------------------------------
__int64 *__fastcall sub_5F758(__int64 *result)
{
  __int64 *v1; // x19
  _QWORD *v2; // x0

  if ( *(_DWORD *)result )
  {
    v1 = result;
    v2 = malloc(0x30u);
    return sub_5F74C(v1, v2);
  }
  return result;
}

//----- (000000000005F798) ----------------------------------------------------
__int64 *__fastcall sub_5F798(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int16 v4; // w0
  __int64 *result; // x0
  _QWORD *v6; // [xsp+28h] [xbp+28h]

  a2[4] = 0;
  a2[3] = a1;
  *((_BYTE *)a2 + 32) = 2;
  a2[1] = a3;
  v4 = *((_WORD *)a2 + 16);
  *a2 = -1;
  a2[2] = a4;
  *((_WORD *)a2 + 16) = v4 | 0x7F8;
  if ( &pthread_create )
  {
    v6 = a2;
    pthread_mutex_lock(&stru_80498);
    a2 = v6;
  }
  result = &qword_802F8;
  a2[5] = qword_804C0;
  qword_804C0 = (__int64)a2;
  if ( &pthread_create )
    return (__int64 *)pthread_mutex_unlock(&stru_80498);
  return result;
}
// 802F8: using guessed type __int64 qword_802F8;
// 80498: using guessed type pthread_mutex_t stru_80498;
// 804C0: using guessed type __int64 qword_804C0;

//----- (000000000005F82C) ----------------------------------------------------
__int64 *__fastcall sub_5F82C(__int64 a1, _QWORD *a2)
{
  return sub_5F798(a1, a2, 0, 0);
}

//----- (000000000005F838) ----------------------------------------------------
__int64 *__fastcall sub_5F838(__int64 a1)
{
  _QWORD *v2; // x0

  v2 = malloc(0x30u);
  return sub_5F82C(a1, v2);
}

//----- (000000000005F864) ----------------------------------------------------
__int64 __fastcall sub_5F864(_DWORD *a1)
{
  __int64 *j; // x0
  __int64 i; // x19

  if ( !a1 || !*a1 )
    return 0;
  if ( &pthread_create )
    pthread_mutex_lock(&stru_80498);
  j = &qword_804C0;
  for ( i = qword_804C0; i; i = *(_QWORD *)(i + 40) )
  {
    if ( *(_DWORD **)(i + 24) == a1 )
    {
LABEL_14:
      *j = *(_QWORD *)(i + 40);
      goto LABEL_21;
    }
    j = (__int64 *)(i + 40);
  }
  for ( j = &qword_804C8; ; j = (__int64 *)(i + 40) )
  {
    i = *j;
    if ( !*j )
    {
      if ( !&pthread_create )
        goto LABEL_20;
      goto LABEL_19;
    }
    if ( (*(_BYTE *)(i + 32) & 1) != 0 )
      break;
    if ( *(_DWORD **)(i + 24) == a1 )
      goto LABEL_14;
LABEL_10:
    ;
  }
  if ( **(_DWORD ***)(i + 24) != a1 )
    goto LABEL_10;
  *j = *(_QWORD *)(i + 40);
  free(*(void **)(i + 24));
LABEL_21:
  if ( &pthread_create )
  {
LABEL_19:
    pthread_mutex_unlock(&stru_80498);
    if ( i )
      return i;
LABEL_20:
    abort();
  }
  return i;
}
// 80498: using guessed type pthread_mutex_t stru_80498;
// 804C0: using guessed type __int64 qword_804C0;
// 804C8: using guessed type __int64 qword_804C8;

//----- (000000000005F968) ----------------------------------------------------
void __fastcall sub_5F968(_DWORD *a1)
{
  void *v1; // x0

  if ( *a1 )
  {
    v1 = (void *)sub_5F964(a1);
    free(v1);
  }
}

//----- (000000000005F98C) ----------------------------------------------------
unsigned int *__fastcall sub_5F98C(unsigned __int64 a1, _QWORD *a2)
{
  __int64 i; // x19
  unsigned int *v5; // x20
  _QWORD *v6; // x1
  __int64 *v7; // x2
  char v8; // w1
  unsigned __int8 v9; // w0
  char v10; // w21
  char *v11; // x0
  unsigned __int64 v12; // x0
  unsigned __int64 data; // [xsp+50h] [xbp+50h] BYREF
  __int64 v15; // [xsp+58h] [xbp+58h]
  __int64 v16; // [xsp+60h] [xbp+60h]
  unsigned __int64 v17; // [xsp+68h] [xbp+68h]
  unsigned int *v18; // [xsp+70h] [xbp+70h]
  int v19; // [xsp+78h] [xbp+78h]

  if ( &pthread_create )
    pthread_mutex_lock(&stru_80498);
  for ( i = qword_804C8; ; i = *(_QWORD *)(i + 40) )
  {
    if ( !i )
      goto LABEL_9;
    if ( a1 >= *(_QWORD *)i )
      break;
  }
  v5 = sub_5F140(i, a1);
  if ( v5 )
  {
LABEL_25:
    if ( !&pthread_create )
      goto LABEL_18;
  }
  else
  {
LABEL_9:
    while ( 1 )
    {
      i = qword_804C0;
      if ( !qword_804C0 )
        break;
      qword_804C0 = *(_QWORD *)(qword_804C0 + 40);
      v5 = sub_5F140(i, a1);
      v6 = (_QWORD *)qword_804C8;
      v7 = &qword_804C8;
      while ( v6 && *v6 >= *(_QWORD *)i )
      {
        v7 = v6 + 5;
        v6 = (_QWORD *)v6[5];
      }
      *(_QWORD *)(i + 40) = v6;
      *v7 = i;
      if ( v5 )
        goto LABEL_25;
    }
    v5 = 0;
    if ( !&pthread_create )
      goto LABEL_21;
  }
  pthread_mutex_unlock(&stru_80498);
  if ( v5 )
  {
LABEL_18:
    *a2 = *(_QWORD *)(i + 8);
    v8 = *(_BYTE *)(i + 32);
    a2[1] = *(_QWORD *)(i + 16);
    v9 = (unsigned __int64)*(unsigned __int16 *)(i + 32) >> 3;
    if ( (v8 & 4) != 0 )
      v9 = sub_5E9E4((__int64)v5);
    v10 = v9;
    v11 = (char *)sub_5E548(v9, i);
    sub_5E608(v10, v11, (char *)v5 + 8, &data);
    v12 = data;
    goto LABEL_24;
  }
LABEL_21:
  v19 = 1;
  data = a1;
  v5 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if ( (dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))sub_5E9F4, &data) & 0x80000000) == 0 )
  {
    v5 = v18;
    if ( v18 )
    {
      *a2 = v15;
      a2[1] = v16;
      v12 = v17;
LABEL_24:
      a2[2] = v12;
    }
  }
  return v5;
}
// 80498: using guessed type pthread_mutex_t stru_80498;
// 804C0: using guessed type __int64 qword_804C0;
// 804C8: using guessed type __int64 qword_804C8;

// nfuncs=899 queued=731 decompiled=731 lumina nreq=0 worse=0 better=0
// ALL OK, 731 function(s) have been successfully decompiled
