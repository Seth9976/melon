/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_C224();
void sub_C234();
void sub_C23C();
__int64 (*__fastcall sub_C244(__int64 (*result)(void)))(void);
__int64 __fastcall sub_C258(void *obj); // idb
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3);
__int64 DRM_SetClientID();
__int64 DRM_Init();
void DRM_Destroy();
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall sub_C9AC(__int64 a1);
__int64 __fastcall DRM_Open_Path(const char *a1, int a2, __int16 a3);
__int64 __fastcall DRM_Close(unsigned __int16 a1);
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3);
__int64 __fastcall sub_D834(unsigned __int16 a1, int **a2);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2);
__int64 __fastcall sub_EC2C(unsigned __int16 a1);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_EF50(_QWORD *a1);
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3);
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
__int64 __fastcall sub_F2A0(__int16 a1);
void __fastcall sub_F418(_QWORD *a1);
__int64 __fastcall DA_DRA_DCFParser(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, const char *a6, __int16 a7);
__int64 __fastcall compute_eServiceCode(unsigned __int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5);
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, const char *a3, __int64 a4, __int16 a5);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
char *__fastcall sub_1368C(char *result, __int64 a2, int *a3, int *a4);
__int64 __fastcall DRM_GetID3HeaderDataSize(__int64 a1, int *a2);
__int64 __fastcall DRM_GetBufferSizeForAlbumArt(__int64 a1, _DWORD *a2, _DWORD *a3);
__int64 __fastcall DRM_ExtractAlbumArt(__int64 a1, _QWORD *a2, int *a3);
__int64 __fastcall DRM_GetMetaTextValueFromID3(__int64 a1, char *a2, __int64 *a3, int *a4);
void printLogV();
void printLogI();
void printLogW();
void printLogF();
void printLogS();
void printLogE();
void printLogD();
void printLogUNK();
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3);
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaInit();
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaPfdOpen(__int64 a1, __int64 a2, int a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaPathOpen(__int64 a1, __int64 a2, __int64 a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaClose(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetErrorCode(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetUnsupportedValue(__int64 *a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaSetClientID(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetBufferSizeForAlbumArt(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14C18(unsigned int a1, char **a2, _DWORD *a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaExtractAlbumArt(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaTextValueFromID3(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetUnsupportedValueUTF8(__int64 *a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaTextValueFromID3UTF8(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaDataCharacterSet(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
void __fastcall sub_172A0(__int64 a1);
__int64 __fastcall sub_173DC(__int64 a1, __int64 *a2);
void __fastcall ClientIDDestroy(_QWORD *a1);
__int64 __fastcall sub_17524(__int64 a1, unsigned int a2, __int64 **a3);
void __fastcall DomainListDestroy(__int64 a1);
__int64 __fastcall sub_1764C(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6);
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3);
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5);
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4);
__int64 DA_DRA_SetClientID(void); // weak
__int64 __fastcall StrErrorReturn(int a1);
__int64 __fastcall StrErrorReturn_uch(int a1);
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
void *__fastcall DHmalloc(int a1);
void __fastcall DHfree(void *a1);
FILE *__fastcall DHfsOpen(char *filename, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 DHfsClose(void); // weak
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3);
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3);
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3);
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
__int64 __fastcall DHfsMetaTell(__int64 a1);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
__int64 __fastcall DHfsMetaSize(const char *a1);
__int64 __fastcall DHfsSize(const char *a1);
void *__fastcall DHmemset(void *a1, int a2, int a3);
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3);
void *__fastcall DHmemchr(const void *a1, int a2, int a3);
void DHmemcount();
size_t __fastcall DHstrlen(const char *a1);
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 DHstrcat(void); // weak
char *__fastcall DHstrncat(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
__int64 DHatoi(void); // weak
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
__int64 DHstrstr(void); // weak
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
const char *__fastcall DHstristr(const char *a1, const char *a2);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
_BYTE *__fastcall DHstrupr(_BYTE *result);
__int64 DHvsnprintf(char *a1, int a2, char *s, ...);
__int64 DHsprintf(char *a1, const char *a2, ...);
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
__int64 __fastcall DHGetStateInfo(void *a1);
__int64 DHcurrentTime_ByLib();
__int64 DHcurrentTime();
__int64 DHAuthTime_ByLib();
__int64 DHAuthTime_ByFile();
__int64 DHAuthTime();
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
void __fastcall DHFreeClientID(void *a1);
__int64 DHGetClientID_ByLib();
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3);
__int64 DHGetDeviceID_ByLib();
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
__int64 __fastcall sub_1A510(_DWORD *a1, __int64 a2, unsigned int a3);
int32x4_t __fastcall sub_1A5EC(_DWORD *a1, unsigned int *a2);
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5);
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
const char *AES_options();
__int64 AES_set_decrypt_key(void); // weak
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
void sub_1CAC0();
// int __cxa_finalize(void *);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
void __fastcall DHFreeClientID(void *a1);
__int64 DRM_SetClientID();
void *__fastcall DHmalloc(int a1);
__int64 DA_DRA_SetClientID();
void printLogD();
__int64 DRM_Init();
void *__fastcall DHmemset(void *a1, int a2, int a3);
void DRM_Destroy();
void __fastcall DHfree(void *a1);
void DHmemcount();
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3);
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_DCFParser(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
__int64 __fastcall DHfsMetaTell(__int64 a1);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
// char *strerror(int errnum);
__int64 __fastcall StrErrorReturn(int a1);
__int64 __fastcall DRM_Open_Path(const char *a1, int a2, __int16 a3);
size_t __fastcall DHstrlen(const char *a1);
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3);
__int64 __fastcall DRM_Close(unsigned __int16 a1);
void __fastcall ClientIDDestroy(_QWORD *a1);
void __fastcall DomainListDestroy(__int64 a1);
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3);
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 AES_set_decrypt_key();
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eServiceCode(unsigned __int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, const char *a6, __int16 a7);
const char *__fastcall DHstristr(const char *a1, const char *a2);
__int64 DHatoi();
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5);
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
__int64 DHAuthTime();
__int64 DHcurrentTime();
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3);
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
// char *strstr(const char *haystack, const char *needle);
// int strcmp(const char *s1, const char *s2);
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, const char *a3, __int64 a4, __int16 a5);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
__int64 DHstrstr();
__int64 __fastcall DRM_GetID3HeaderDataSize(__int64 a1, int *a2);
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3);
__int64 __fastcall DRM_GetBufferSizeForAlbumArt(__int64 a1, _DWORD *a2, _DWORD *a3);
void *__fastcall DHmemchr(const void *a1, int a2, int a3);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
__int64 __fastcall DRM_GetMetaTextValueFromID3(__int64 a1, char *a2, __int64 *a3, int *a4);
_BYTE *__fastcall DHstrupr(_BYTE *result);
// FILE *fopen(const char *filename, const char *modes);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fclose(FILE *stream);
// void *memset(void *s, int c, size_t n);
// size_t __strlen_chk(const char *, size_t);
// __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
__int64 DHstrcat();
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9);
FILE *__fastcall DHfsOpen(char *filename, int a2);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 DHfsClose();
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
// void *malloc(size_t size);
// void free(void *ptr);
// int dup(int fd);
// FILE *fdopen(int fd, const char *modes);
// void rewind(FILE *stream);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ftell(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// int memcmp(const void *s1, const void *s2, size_t n);
// void *memchr(const void *s, int c, size_t n);
// size_t strlen(const char *s);
// char *strcpy(char *dest, const char *src);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// int atoi(const char *nptr);
// char *strchr(const char *s, int c);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// time_t mktime(struct tm *tp);
__int64 __fastcall DHGetStateInfo(void *a1);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
// time_t time(time_t *timer);
// __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_4AA5; // weak
_UNKNOWN unk_593E; // weak
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
__int128 xmmword_7C40 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
__int128 xmmword_7C50 = 0x2065756C61562065646F436874754165LL; // weak
__int128 xmmword_7CB0 = 0xFFFFFFF8FFFFFFF0FFFFFFE8LL; // weak
char a0123456789abcd[77] = "0123456789abcdefl Base Key Gener10574021eneratioue Generen GenerGeneratirati"; // weak
_UNKNOWN unk_7D30; // weak
_DWORD dword_7D40[3] = { 1, 2, 0 }; // weak
_UNKNOWN unk_7D4C; // weak
unsigned __int8 byte_7D50[1024] =
{
  99u,
  198u,
  165u,
  99u,
  124u,
  248u,
  132u,
  124u,
  119u,
  238u,
  153u,
  119u,
  123u,
  246u,
  141u,
  123u,
  242u,
  255u,
  13u,
  242u,
  107u,
  214u,
  189u,
  107u,
  111u,
  222u,
  177u,
  111u,
  197u,
  145u,
  84u,
  197u,
  48u,
  96u,
  80u,
  48u,
  1u,
  2u,
  3u,
  1u,
  103u,
  206u,
  169u,
  103u,
  43u,
  86u,
  125u,
  43u,
  254u,
  231u,
  25u,
  254u,
  215u,
  181u,
  98u,
  215u,
  171u,
  77u,
  230u,
  171u,
  118u,
  236u,
  154u,
  118u,
  202u,
  143u,
  69u,
  202u,
  130u,
  31u,
  157u,
  130u,
  201u,
  137u,
  64u,
  201u,
  125u,
  250u,
  135u,
  125u,
  250u,
  239u,
  21u,
  250u,
  89u,
  178u,
  235u,
  89u,
  71u,
  142u,
  201u,
  71u,
  240u,
  251u,
  11u,
  240u,
  173u,
  65u,
  236u,
  173u,
  212u,
  179u,
  103u,
  212u,
  162u,
  95u,
  253u,
  162u,
  175u,
  69u,
  234u,
  175u,
  156u,
  35u,
  191u,
  156u,
  164u,
  83u,
  247u,
  164u,
  114u,
  228u,
  150u,
  114u,
  192u,
  155u,
  91u,
  192u,
  183u,
  117u,
  194u,
  183u,
  253u,
  225u,
  28u,
  253u,
  147u,
  61u,
  174u,
  147u,
  38u,
  76u,
  106u,
  38u,
  54u,
  108u,
  90u,
  54u,
  63u,
  126u,
  65u,
  63u,
  247u,
  245u,
  2u,
  247u,
  204u,
  131u,
  79u,
  204u,
  52u,
  104u,
  92u,
  52u,
  165u,
  81u,
  244u,
  165u,
  229u,
  209u,
  52u,
  229u,
  241u,
  249u,
  8u,
  241u,
  113u,
  226u,
  147u,
  113u,
  216u,
  171u,
  115u,
  216u,
  49u,
  98u,
  83u,
  49u,
  21u,
  42u,
  63u,
  21u,
  4u,
  8u,
  12u,
  4u,
  199u,
  149u,
  82u,
  199u,
  35u,
  70u,
  101u,
  35u,
  195u,
  157u,
  94u,
  195u,
  24u,
  48u,
  40u,
  24u,
  150u,
  55u,
  161u,
  150u,
  5u,
  10u,
  15u,
  5u,
  154u,
  47u,
  181u,
  154u,
  7u,
  14u,
  9u,
  7u,
  18u,
  36u,
  54u,
  18u,
  128u,
  27u,
  155u,
  128u,
  226u,
  223u,
  61u,
  226u,
  235u,
  205u,
  38u,
  235u,
  39u,
  78u,
  105u,
  39u,
  178u,
  127u,
  205u,
  178u,
  117u,
  234u,
  159u,
  117u,
  9u,
  18u,
  27u,
  9u,
  131u,
  29u,
  158u,
  131u,
  44u,
  88u,
  116u,
  44u,
  26u,
  52u,
  46u,
  26u,
  27u,
  54u,
  45u,
  27u,
  110u,
  220u,
  178u,
  110u,
  90u,
  180u,
  238u,
  90u,
  160u,
  91u,
  251u,
  160u,
  82u,
  164u,
  246u,
  82u,
  59u,
  118u,
  77u,
  59u,
  214u,
  183u,
  97u,
  214u,
  179u,
  125u,
  206u,
  179u,
  41u,
  82u,
  123u,
  41u,
  227u,
  221u,
  62u,
  227u,
  47u,
  94u,
  113u,
  47u,
  132u,
  19u,
  151u,
  132u,
  83u,
  166u,
  245u,
  83u,
  209u,
  185u,
  104u,
  209u,
  0u,
  0u,
  0u,
  0u,
  237u,
  193u,
  44u,
  237u,
  32u,
  64u,
  96u,
  32u,
  252u,
  227u,
  31u,
  252u,
  177u,
  121u,
  200u,
  177u,
  91u,
  182u,
  237u,
  91u,
  106u,
  212u,
  190u,
  106u,
  203u,
  141u,
  70u,
  203u,
  190u,
  103u,
  217u,
  190u,
  57u,
  114u,
  75u,
  57u,
  74u,
  148u,
  222u,
  74u,
  76u,
  152u,
  212u,
  76u,
  88u,
  176u,
  232u,
  88u,
  207u,
  133u,
  74u,
  207u,
  208u,
  187u,
  107u,
  208u,
  239u,
  197u,
  42u,
  239u,
  170u,
  79u,
  229u,
  170u,
  251u,
  237u,
  22u,
  251u,
  67u,
  134u,
  197u,
  67u,
  77u,
  154u,
  215u,
  77u,
  51u,
  102u,
  85u,
  51u,
  133u,
  17u,
  148u,
  133u,
  69u,
  138u,
  207u,
  69u,
  249u,
  233u,
  16u,
  249u,
  2u,
  4u,
  6u,
  2u,
  127u,
  254u,
  129u,
  127u,
  80u,
  160u,
  240u,
  80u,
  60u,
  120u,
  68u,
  60u,
  159u,
  37u,
  186u,
  159u,
  168u,
  75u,
  227u,
  168u,
  81u,
  162u,
  243u,
  81u,
  163u,
  93u,
  254u,
  163u,
  64u,
  128u,
  192u,
  64u,
  143u,
  5u,
  138u,
  143u,
  146u,
  63u,
  173u,
  146u,
  157u,
  33u,
  188u,
  157u,
  56u,
  112u,
  72u,
  56u,
  245u,
  241u,
  4u,
  245u,
  188u,
  99u,
  223u,
  188u,
  182u,
  119u,
  193u,
  182u,
  218u,
  175u,
  117u,
  218u,
  33u,
  66u,
  99u,
  33u,
  16u,
  32u,
  48u,
  16u,
  255u,
  229u,
  26u,
  255u,
  243u,
  253u,
  14u,
  243u,
  210u,
  191u,
  109u,
  210u,
  205u,
  129u,
  76u,
  205u,
  12u,
  24u,
  20u,
  12u,
  19u,
  38u,
  53u,
  19u,
  236u,
  195u,
  47u,
  236u,
  95u,
  190u,
  225u,
  95u,
  151u,
  53u,
  162u,
  151u,
  68u,
  136u,
  204u,
  68u,
  23u,
  46u,
  57u,
  23u,
  196u,
  147u,
  87u,
  196u,
  167u,
  85u,
  242u,
  167u,
  126u,
  252u,
  130u,
  126u,
  61u,
  122u,
  71u,
  61u,
  100u,
  200u,
  172u,
  100u,
  93u,
  186u,
  231u,
  93u,
  25u,
  50u,
  43u,
  25u,
  115u,
  230u,
  149u,
  115u,
  96u,
  192u,
  160u,
  96u,
  129u,
  25u,
  152u,
  129u,
  79u,
  158u,
  209u,
  79u,
  220u,
  163u,
  127u,
  220u,
  34u,
  68u,
  102u,
  34u,
  42u,
  84u,
  126u,
  42u,
  144u,
  59u,
  171u,
  144u,
  136u,
  11u,
  131u,
  136u,
  70u,
  140u,
  202u,
  70u,
  238u,
  199u,
  41u,
  238u,
  184u,
  107u,
  211u,
  184u,
  20u,
  40u,
  60u,
  20u,
  222u,
  167u,
  121u,
  222u,
  94u,
  188u,
  226u,
  94u,
  11u,
  22u,
  29u,
  11u,
  219u,
  173u,
  118u,
  219u,
  224u,
  219u,
  59u,
  224u,
  50u,
  100u,
  86u,
  50u,
  58u,
  116u,
  78u,
  58u,
  10u,
  20u,
  30u,
  10u,
  73u,
  146u,
  219u,
  73u,
  6u,
  12u,
  10u,
  6u,
  36u,
  72u,
  108u,
  36u,
  92u,
  184u,
  228u,
  92u,
  194u,
  159u,
  93u,
  194u,
  211u,
  189u,
  110u,
  211u,
  172u,
  67u,
  239u,
  172u,
  98u,
  196u,
  166u,
  98u,
  145u,
  57u,
  168u,
  145u,
  149u,
  49u,
  164u,
  149u,
  228u,
  211u,
  55u,
  228u,
  121u,
  242u,
  139u,
  121u,
  231u,
  213u,
  50u,
  231u,
  200u,
  139u,
  67u,
  200u,
  55u,
  110u,
  89u,
  55u,
  109u,
  218u,
  183u,
  109u,
  141u,
  1u,
  140u,
  141u,
  213u,
  177u,
  100u,
  213u,
  78u,
  156u,
  210u,
  78u,
  169u,
  73u,
  224u,
  169u,
  108u,
  216u,
  180u,
  108u,
  86u,
  172u,
  250u,
  86u,
  244u,
  243u,
  7u,
  244u,
  234u,
  207u,
  37u,
  234u,
  101u,
  202u,
  175u,
  101u,
  122u,
  244u,
  142u,
  122u,
  174u,
  71u,
  233u,
  174u,
  8u,
  16u,
  24u,
  8u,
  186u,
  111u,
  213u,
  186u,
  120u,
  240u,
  136u,
  120u,
  37u,
  74u,
  111u,
  37u,
  46u,
  92u,
  114u,
  46u,
  28u,
  56u,
  36u,
  28u,
  166u,
  87u,
  241u,
  166u,
  180u,
  115u,
  199u,
  180u,
  198u,
  151u,
  81u,
  198u,
  232u,
  203u,
  35u,
  232u,
  221u,
  161u,
  124u,
  221u,
  116u,
  232u,
  156u,
  116u,
  31u,
  62u,
  33u,
  31u,
  75u,
  150u,
  221u,
  75u,
  189u,
  97u,
  220u,
  189u,
  139u,
  13u,
  134u,
  139u,
  138u,
  15u,
  133u,
  138u,
  112u,
  224u,
  144u,
  112u,
  62u,
  124u,
  66u,
  62u,
  181u,
  113u,
  196u,
  181u,
  102u,
  204u,
  170u,
  102u,
  72u,
  144u,
  216u,
  72u,
  3u,
  6u,
  5u,
  3u,
  246u,
  247u,
  1u,
  246u,
  14u,
  28u,
  18u,
  14u,
  97u,
  194u,
  163u,
  97u,
  53u,
  106u,
  95u,
  53u,
  87u,
  174u,
  249u,
  87u,
  185u,
  105u,
  208u,
  185u,
  134u,
  23u,
  145u,
  134u,
  193u,
  153u,
  88u,
  193u,
  29u,
  58u,
  39u,
  29u,
  158u,
  39u,
  185u,
  158u,
  225u,
  217u,
  56u,
  225u,
  248u,
  235u,
  19u,
  248u,
  152u,
  43u,
  179u,
  152u,
  17u,
  34u,
  51u,
  17u,
  105u,
  210u,
  187u,
  105u,
  217u,
  169u,
  112u,
  217u,
  142u,
  7u,
  137u,
  142u,
  148u,
  51u,
  167u,
  148u,
  155u,
  45u,
  182u,
  155u,
  30u,
  60u,
  34u,
  30u,
  135u,
  21u,
  146u,
  135u,
  233u,
  201u,
  32u,
  233u,
  206u,
  135u,
  73u,
  206u,
  85u,
  170u,
  255u,
  85u,
  40u,
  80u,
  120u,
  40u,
  223u,
  165u,
  122u,
  223u,
  140u,
  3u,
  143u,
  140u,
  161u,
  89u,
  248u,
  161u,
  137u,
  9u,
  128u,
  137u,
  13u,
  26u,
  23u,
  13u,
  191u,
  101u,
  218u,
  191u,
  230u,
  215u,
  49u,
  230u,
  66u,
  132u,
  198u,
  66u,
  104u,
  208u,
  184u,
  104u,
  65u,
  130u,
  195u,
  65u,
  153u,
  41u,
  176u,
  153u,
  45u,
  90u,
  119u,
  45u,
  15u,
  30u,
  17u,
  15u,
  176u,
  123u,
  203u,
  176u,
  84u,
  168u,
  252u,
  84u,
  187u,
  109u,
  214u,
  187u,
  22u,
  44u,
  58u,
  22u
}; // weak
unsigned __int8 byte_8150[1024] =
{
  198u,
  165u,
  99u,
  99u,
  248u,
  132u,
  124u,
  124u,
  238u,
  153u,
  119u,
  119u,
  246u,
  141u,
  123u,
  123u,
  255u,
  13u,
  242u,
  242u,
  214u,
  189u,
  107u,
  107u,
  222u,
  177u,
  111u,
  111u,
  145u,
  84u,
  197u,
  197u,
  96u,
  80u,
  48u,
  48u,
  2u,
  3u,
  1u,
  1u,
  206u,
  169u,
  103u,
  103u,
  86u,
  125u,
  43u,
  43u,
  231u,
  25u,
  254u,
  254u,
  181u,
  98u,
  215u,
  215u,
  77u,
  230u,
  171u,
  171u,
  236u,
  154u,
  118u,
  118u,
  143u,
  69u,
  202u,
  202u,
  31u,
  157u,
  130u,
  130u,
  137u,
  64u,
  201u,
  201u,
  250u,
  135u,
  125u,
  125u,
  239u,
  21u,
  250u,
  250u,
  178u,
  235u,
  89u,
  89u,
  142u,
  201u,
  71u,
  71u,
  251u,
  11u,
  240u,
  240u,
  65u,
  236u,
  173u,
  173u,
  179u,
  103u,
  212u,
  212u,
  95u,
  253u,
  162u,
  162u,
  69u,
  234u,
  175u,
  175u,
  35u,
  191u,
  156u,
  156u,
  83u,
  247u,
  164u,
  164u,
  228u,
  150u,
  114u,
  114u,
  155u,
  91u,
  192u,
  192u,
  117u,
  194u,
  183u,
  183u,
  225u,
  28u,
  253u,
  253u,
  61u,
  174u,
  147u,
  147u,
  76u,
  106u,
  38u,
  38u,
  108u,
  90u,
  54u,
  54u,
  126u,
  65u,
  63u,
  63u,
  245u,
  2u,
  247u,
  247u,
  131u,
  79u,
  204u,
  204u,
  104u,
  92u,
  52u,
  52u,
  81u,
  244u,
  165u,
  165u,
  209u,
  52u,
  229u,
  229u,
  249u,
  8u,
  241u,
  241u,
  226u,
  147u,
  113u,
  113u,
  171u,
  115u,
  216u,
  216u,
  98u,
  83u,
  49u,
  49u,
  42u,
  63u,
  21u,
  21u,
  8u,
  12u,
  4u,
  4u,
  149u,
  82u,
  199u,
  199u,
  70u,
  101u,
  35u,
  35u,
  157u,
  94u,
  195u,
  195u,
  48u,
  40u,
  24u,
  24u,
  55u,
  161u,
  150u,
  150u,
  10u,
  15u,
  5u,
  5u,
  47u,
  181u,
  154u,
  154u,
  14u,
  9u,
  7u,
  7u,
  36u,
  54u,
  18u,
  18u,
  27u,
  155u,
  128u,
  128u,
  223u,
  61u,
  226u,
  226u,
  205u,
  38u,
  235u,
  235u,
  78u,
  105u,
  39u,
  39u,
  127u,
  205u,
  178u,
  178u,
  234u,
  159u,
  117u,
  117u,
  18u,
  27u,
  9u,
  9u,
  29u,
  158u,
  131u,
  131u,
  88u,
  116u,
  44u,
  44u,
  52u,
  46u,
  26u,
  26u,
  54u,
  45u,
  27u,
  27u,
  220u,
  178u,
  110u,
  110u,
  180u,
  238u,
  90u,
  90u,
  91u,
  251u,
  160u,
  160u,
  164u,
  246u,
  82u,
  82u,
  118u,
  77u,
  59u,
  59u,
  183u,
  97u,
  214u,
  214u,
  125u,
  206u,
  179u,
  179u,
  82u,
  123u,
  41u,
  41u,
  221u,
  62u,
  227u,
  227u,
  94u,
  113u,
  47u,
  47u,
  19u,
  151u,
  132u,
  132u,
  166u,
  245u,
  83u,
  83u,
  185u,
  104u,
  209u,
  209u,
  0u,
  0u,
  0u,
  0u,
  193u,
  44u,
  237u,
  237u,
  64u,
  96u,
  32u,
  32u,
  227u,
  31u,
  252u,
  252u,
  121u,
  200u,
  177u,
  177u,
  182u,
  237u,
  91u,
  91u,
  212u,
  190u,
  106u,
  106u,
  141u,
  70u,
  203u,
  203u,
  103u,
  217u,
  190u,
  190u,
  114u,
  75u,
  57u,
  57u,
  148u,
  222u,
  74u,
  74u,
  152u,
  212u,
  76u,
  76u,
  176u,
  232u,
  88u,
  88u,
  133u,
  74u,
  207u,
  207u,
  187u,
  107u,
  208u,
  208u,
  197u,
  42u,
  239u,
  239u,
  79u,
  229u,
  170u,
  170u,
  237u,
  22u,
  251u,
  251u,
  134u,
  197u,
  67u,
  67u,
  154u,
  215u,
  77u,
  77u,
  102u,
  85u,
  51u,
  51u,
  17u,
  148u,
  133u,
  133u,
  138u,
  207u,
  69u,
  69u,
  233u,
  16u,
  249u,
  249u,
  4u,
  6u,
  2u,
  2u,
  254u,
  129u,
  127u,
  127u,
  160u,
  240u,
  80u,
  80u,
  120u,
  68u,
  60u,
  60u,
  37u,
  186u,
  159u,
  159u,
  75u,
  227u,
  168u,
  168u,
  162u,
  243u,
  81u,
  81u,
  93u,
  254u,
  163u,
  163u,
  128u,
  192u,
  64u,
  64u,
  5u,
  138u,
  143u,
  143u,
  63u,
  173u,
  146u,
  146u,
  33u,
  188u,
  157u,
  157u,
  112u,
  72u,
  56u,
  56u,
  241u,
  4u,
  245u,
  245u,
  99u,
  223u,
  188u,
  188u,
  119u,
  193u,
  182u,
  182u,
  175u,
  117u,
  218u,
  218u,
  66u,
  99u,
  33u,
  33u,
  32u,
  48u,
  16u,
  16u,
  229u,
  26u,
  255u,
  255u,
  253u,
  14u,
  243u,
  243u,
  191u,
  109u,
  210u,
  210u,
  129u,
  76u,
  205u,
  205u,
  24u,
  20u,
  12u,
  12u,
  38u,
  53u,
  19u,
  19u,
  195u,
  47u,
  236u,
  236u,
  190u,
  225u,
  95u,
  95u,
  53u,
  162u,
  151u,
  151u,
  136u,
  204u,
  68u,
  68u,
  46u,
  57u,
  23u,
  23u,
  147u,
  87u,
  196u,
  196u,
  85u,
  242u,
  167u,
  167u,
  252u,
  130u,
  126u,
  126u,
  122u,
  71u,
  61u,
  61u,
  200u,
  172u,
  100u,
  100u,
  186u,
  231u,
  93u,
  93u,
  50u,
  43u,
  25u,
  25u,
  230u,
  149u,
  115u,
  115u,
  192u,
  160u,
  96u,
  96u,
  25u,
  152u,
  129u,
  129u,
  158u,
  209u,
  79u,
  79u,
  163u,
  127u,
  220u,
  220u,
  68u,
  102u,
  34u,
  34u,
  84u,
  126u,
  42u,
  42u,
  59u,
  171u,
  144u,
  144u,
  11u,
  131u,
  136u,
  136u,
  140u,
  202u,
  70u,
  70u,
  199u,
  41u,
  238u,
  238u,
  107u,
  211u,
  184u,
  184u,
  40u,
  60u,
  20u,
  20u,
  167u,
  121u,
  222u,
  222u,
  188u,
  226u,
  94u,
  94u,
  22u,
  29u,
  11u,
  11u,
  173u,
  118u,
  219u,
  219u,
  219u,
  59u,
  224u,
  224u,
  100u,
  86u,
  50u,
  50u,
  116u,
  78u,
  58u,
  58u,
  20u,
  30u,
  10u,
  10u,
  146u,
  219u,
  73u,
  73u,
  12u,
  10u,
  6u,
  6u,
  72u,
  108u,
  36u,
  36u,
  184u,
  228u,
  92u,
  92u,
  159u,
  93u,
  194u,
  194u,
  189u,
  110u,
  211u,
  211u,
  67u,
  239u,
  172u,
  172u,
  196u,
  166u,
  98u,
  98u,
  57u,
  168u,
  145u,
  145u,
  49u,
  164u,
  149u,
  149u,
  211u,
  55u,
  228u,
  228u,
  242u,
  139u,
  121u,
  121u,
  213u,
  50u,
  231u,
  231u,
  139u,
  67u,
  200u,
  200u,
  110u,
  89u,
  55u,
  55u,
  218u,
  183u,
  109u,
  109u,
  1u,
  140u,
  141u,
  141u,
  177u,
  100u,
  213u,
  213u,
  156u,
  210u,
  78u,
  78u,
  73u,
  224u,
  169u,
  169u,
  216u,
  180u,
  108u,
  108u,
  172u,
  250u,
  86u,
  86u,
  243u,
  7u,
  244u,
  244u,
  207u,
  37u,
  234u,
  234u,
  202u,
  175u,
  101u,
  101u,
  244u,
  142u,
  122u,
  122u,
  71u,
  233u,
  174u,
  174u,
  16u,
  24u,
  8u,
  8u,
  111u,
  213u,
  186u,
  186u,
  240u,
  136u,
  120u,
  120u,
  74u,
  111u,
  37u,
  37u,
  92u,
  114u,
  46u,
  46u,
  56u,
  36u,
  28u,
  28u,
  87u,
  241u,
  166u,
  166u,
  115u,
  199u,
  180u,
  180u,
  151u,
  81u,
  198u,
  198u,
  203u,
  35u,
  232u,
  232u,
  161u,
  124u,
  221u,
  221u,
  232u,
  156u,
  116u,
  116u,
  62u,
  33u,
  31u,
  31u,
  150u,
  221u,
  75u,
  75u,
  97u,
  220u,
  189u,
  189u,
  13u,
  134u,
  139u,
  139u,
  15u,
  133u,
  138u,
  138u,
  224u,
  144u,
  112u,
  112u,
  124u,
  66u,
  62u,
  62u,
  113u,
  196u,
  181u,
  181u,
  204u,
  170u,
  102u,
  102u,
  144u,
  216u,
  72u,
  72u,
  6u,
  5u,
  3u,
  3u,
  247u,
  1u,
  246u,
  246u,
  28u,
  18u,
  14u,
  14u,
  194u,
  163u,
  97u,
  97u,
  106u,
  95u,
  53u,
  53u,
  174u,
  249u,
  87u,
  87u,
  105u,
  208u,
  185u,
  185u,
  23u,
  145u,
  134u,
  134u,
  153u,
  88u,
  193u,
  193u,
  58u,
  39u,
  29u,
  29u,
  39u,
  185u,
  158u,
  158u,
  217u,
  56u,
  225u,
  225u,
  235u,
  19u,
  248u,
  248u,
  43u,
  179u,
  152u,
  152u,
  34u,
  51u,
  17u,
  17u,
  210u,
  187u,
  105u,
  105u,
  169u,
  112u,
  217u,
  217u,
  7u,
  137u,
  142u,
  142u,
  51u,
  167u,
  148u,
  148u,
  45u,
  182u,
  155u,
  155u,
  60u,
  34u,
  30u,
  30u,
  21u,
  146u,
  135u,
  135u,
  201u,
  32u,
  233u,
  233u,
  135u,
  73u,
  206u,
  206u,
  170u,
  255u,
  85u,
  85u,
  80u,
  120u,
  40u,
  40u,
  165u,
  122u,
  223u,
  223u,
  3u,
  143u,
  140u,
  140u,
  89u,
  248u,
  161u,
  161u,
  9u,
  128u,
  137u,
  137u,
  26u,
  23u,
  13u,
  13u,
  101u,
  218u,
  191u,
  191u,
  215u,
  49u,
  230u,
  230u,
  132u,
  198u,
  66u,
  66u,
  208u,
  184u,
  104u,
  104u,
  130u,
  195u,
  65u,
  65u,
  41u,
  176u,
  153u,
  153u,
  90u,
  119u,
  45u,
  45u,
  30u,
  17u,
  15u,
  15u,
  123u,
  203u,
  176u,
  176u,
  168u,
  252u,
  84u,
  84u,
  109u,
  214u,
  187u,
  187u,
  44u,
  58u,
  22u,
  22u
}; // weak
unsigned __int8 byte_8550[1024] =
{
  165u,
  99u,
  99u,
  198u,
  132u,
  124u,
  124u,
  248u,
  153u,
  119u,
  119u,
  238u,
  141u,
  123u,
  123u,
  246u,
  13u,
  242u,
  242u,
  255u,
  189u,
  107u,
  107u,
  214u,
  177u,
  111u,
  111u,
  222u,
  84u,
  197u,
  197u,
  145u,
  80u,
  48u,
  48u,
  96u,
  3u,
  1u,
  1u,
  2u,
  169u,
  103u,
  103u,
  206u,
  125u,
  43u,
  43u,
  86u,
  25u,
  254u,
  254u,
  231u,
  98u,
  215u,
  215u,
  181u,
  230u,
  171u,
  171u,
  77u,
  154u,
  118u,
  118u,
  236u,
  69u,
  202u,
  202u,
  143u,
  157u,
  130u,
  130u,
  31u,
  64u,
  201u,
  201u,
  137u,
  135u,
  125u,
  125u,
  250u,
  21u,
  250u,
  250u,
  239u,
  235u,
  89u,
  89u,
  178u,
  201u,
  71u,
  71u,
  142u,
  11u,
  240u,
  240u,
  251u,
  236u,
  173u,
  173u,
  65u,
  103u,
  212u,
  212u,
  179u,
  253u,
  162u,
  162u,
  95u,
  234u,
  175u,
  175u,
  69u,
  191u,
  156u,
  156u,
  35u,
  247u,
  164u,
  164u,
  83u,
  150u,
  114u,
  114u,
  228u,
  91u,
  192u,
  192u,
  155u,
  194u,
  183u,
  183u,
  117u,
  28u,
  253u,
  253u,
  225u,
  174u,
  147u,
  147u,
  61u,
  106u,
  38u,
  38u,
  76u,
  90u,
  54u,
  54u,
  108u,
  65u,
  63u,
  63u,
  126u,
  2u,
  247u,
  247u,
  245u,
  79u,
  204u,
  204u,
  131u,
  92u,
  52u,
  52u,
  104u,
  244u,
  165u,
  165u,
  81u,
  52u,
  229u,
  229u,
  209u,
  8u,
  241u,
  241u,
  249u,
  147u,
  113u,
  113u,
  226u,
  115u,
  216u,
  216u,
  171u,
  83u,
  49u,
  49u,
  98u,
  63u,
  21u,
  21u,
  42u,
  12u,
  4u,
  4u,
  8u,
  82u,
  199u,
  199u,
  149u,
  101u,
  35u,
  35u,
  70u,
  94u,
  195u,
  195u,
  157u,
  40u,
  24u,
  24u,
  48u,
  161u,
  150u,
  150u,
  55u,
  15u,
  5u,
  5u,
  10u,
  181u,
  154u,
  154u,
  47u,
  9u,
  7u,
  7u,
  14u,
  54u,
  18u,
  18u,
  36u,
  155u,
  128u,
  128u,
  27u,
  61u,
  226u,
  226u,
  223u,
  38u,
  235u,
  235u,
  205u,
  105u,
  39u,
  39u,
  78u,
  205u,
  178u,
  178u,
  127u,
  159u,
  117u,
  117u,
  234u,
  27u,
  9u,
  9u,
  18u,
  158u,
  131u,
  131u,
  29u,
  116u,
  44u,
  44u,
  88u,
  46u,
  26u,
  26u,
  52u,
  45u,
  27u,
  27u,
  54u,
  178u,
  110u,
  110u,
  220u,
  238u,
  90u,
  90u,
  180u,
  251u,
  160u,
  160u,
  91u,
  246u,
  82u,
  82u,
  164u,
  77u,
  59u,
  59u,
  118u,
  97u,
  214u,
  214u,
  183u,
  206u,
  179u,
  179u,
  125u,
  123u,
  41u,
  41u,
  82u,
  62u,
  227u,
  227u,
  221u,
  113u,
  47u,
  47u,
  94u,
  151u,
  132u,
  132u,
  19u,
  245u,
  83u,
  83u,
  166u,
  104u,
  209u,
  209u,
  185u,
  0u,
  0u,
  0u,
  0u,
  44u,
  237u,
  237u,
  193u,
  96u,
  32u,
  32u,
  64u,
  31u,
  252u,
  252u,
  227u,
  200u,
  177u,
  177u,
  121u,
  237u,
  91u,
  91u,
  182u,
  190u,
  106u,
  106u,
  212u,
  70u,
  203u,
  203u,
  141u,
  217u,
  190u,
  190u,
  103u,
  75u,
  57u,
  57u,
  114u,
  222u,
  74u,
  74u,
  148u,
  212u,
  76u,
  76u,
  152u,
  232u,
  88u,
  88u,
  176u,
  74u,
  207u,
  207u,
  133u,
  107u,
  208u,
  208u,
  187u,
  42u,
  239u,
  239u,
  197u,
  229u,
  170u,
  170u,
  79u,
  22u,
  251u,
  251u,
  237u,
  197u,
  67u,
  67u,
  134u,
  215u,
  77u,
  77u,
  154u,
  85u,
  51u,
  51u,
  102u,
  148u,
  133u,
  133u,
  17u,
  207u,
  69u,
  69u,
  138u,
  16u,
  249u,
  249u,
  233u,
  6u,
  2u,
  2u,
  4u,
  129u,
  127u,
  127u,
  254u,
  240u,
  80u,
  80u,
  160u,
  68u,
  60u,
  60u,
  120u,
  186u,
  159u,
  159u,
  37u,
  227u,
  168u,
  168u,
  75u,
  243u,
  81u,
  81u,
  162u,
  254u,
  163u,
  163u,
  93u,
  192u,
  64u,
  64u,
  128u,
  138u,
  143u,
  143u,
  5u,
  173u,
  146u,
  146u,
  63u,
  188u,
  157u,
  157u,
  33u,
  72u,
  56u,
  56u,
  112u,
  4u,
  245u,
  245u,
  241u,
  223u,
  188u,
  188u,
  99u,
  193u,
  182u,
  182u,
  119u,
  117u,
  218u,
  218u,
  175u,
  99u,
  33u,
  33u,
  66u,
  48u,
  16u,
  16u,
  32u,
  26u,
  255u,
  255u,
  229u,
  14u,
  243u,
  243u,
  253u,
  109u,
  210u,
  210u,
  191u,
  76u,
  205u,
  205u,
  129u,
  20u,
  12u,
  12u,
  24u,
  53u,
  19u,
  19u,
  38u,
  47u,
  236u,
  236u,
  195u,
  225u,
  95u,
  95u,
  190u,
  162u,
  151u,
  151u,
  53u,
  204u,
  68u,
  68u,
  136u,
  57u,
  23u,
  23u,
  46u,
  87u,
  196u,
  196u,
  147u,
  242u,
  167u,
  167u,
  85u,
  130u,
  126u,
  126u,
  252u,
  71u,
  61u,
  61u,
  122u,
  172u,
  100u,
  100u,
  200u,
  231u,
  93u,
  93u,
  186u,
  43u,
  25u,
  25u,
  50u,
  149u,
  115u,
  115u,
  230u,
  160u,
  96u,
  96u,
  192u,
  152u,
  129u,
  129u,
  25u,
  209u,
  79u,
  79u,
  158u,
  127u,
  220u,
  220u,
  163u,
  102u,
  34u,
  34u,
  68u,
  126u,
  42u,
  42u,
  84u,
  171u,
  144u,
  144u,
  59u,
  131u,
  136u,
  136u,
  11u,
  202u,
  70u,
  70u,
  140u,
  41u,
  238u,
  238u,
  199u,
  211u,
  184u,
  184u,
  107u,
  60u,
  20u,
  20u,
  40u,
  121u,
  222u,
  222u,
  167u,
  226u,
  94u,
  94u,
  188u,
  29u,
  11u,
  11u,
  22u,
  118u,
  219u,
  219u,
  173u,
  59u,
  224u,
  224u,
  219u,
  86u,
  50u,
  50u,
  100u,
  78u,
  58u,
  58u,
  116u,
  30u,
  10u,
  10u,
  20u,
  219u,
  73u,
  73u,
  146u,
  10u,
  6u,
  6u,
  12u,
  108u,
  36u,
  36u,
  72u,
  228u,
  92u,
  92u,
  184u,
  93u,
  194u,
  194u,
  159u,
  110u,
  211u,
  211u,
  189u,
  239u,
  172u,
  172u,
  67u,
  166u,
  98u,
  98u,
  196u,
  168u,
  145u,
  145u,
  57u,
  164u,
  149u,
  149u,
  49u,
  55u,
  228u,
  228u,
  211u,
  139u,
  121u,
  121u,
  242u,
  50u,
  231u,
  231u,
  213u,
  67u,
  200u,
  200u,
  139u,
  89u,
  55u,
  55u,
  110u,
  183u,
  109u,
  109u,
  218u,
  140u,
  141u,
  141u,
  1u,
  100u,
  213u,
  213u,
  177u,
  210u,
  78u,
  78u,
  156u,
  224u,
  169u,
  169u,
  73u,
  180u,
  108u,
  108u,
  216u,
  250u,
  86u,
  86u,
  172u,
  7u,
  244u,
  244u,
  243u,
  37u,
  234u,
  234u,
  207u,
  175u,
  101u,
  101u,
  202u,
  142u,
  122u,
  122u,
  244u,
  233u,
  174u,
  174u,
  71u,
  24u,
  8u,
  8u,
  16u,
  213u,
  186u,
  186u,
  111u,
  136u,
  120u,
  120u,
  240u,
  111u,
  37u,
  37u,
  74u,
  114u,
  46u,
  46u,
  92u,
  36u,
  28u,
  28u,
  56u,
  241u,
  166u,
  166u,
  87u,
  199u,
  180u,
  180u,
  115u,
  81u,
  198u,
  198u,
  151u,
  35u,
  232u,
  232u,
  203u,
  124u,
  221u,
  221u,
  161u,
  156u,
  116u,
  116u,
  232u,
  33u,
  31u,
  31u,
  62u,
  221u,
  75u,
  75u,
  150u,
  220u,
  189u,
  189u,
  97u,
  134u,
  139u,
  139u,
  13u,
  133u,
  138u,
  138u,
  15u,
  144u,
  112u,
  112u,
  224u,
  66u,
  62u,
  62u,
  124u,
  196u,
  181u,
  181u,
  113u,
  170u,
  102u,
  102u,
  204u,
  216u,
  72u,
  72u,
  144u,
  5u,
  3u,
  3u,
  6u,
  1u,
  246u,
  246u,
  247u,
  18u,
  14u,
  14u,
  28u,
  163u,
  97u,
  97u,
  194u,
  95u,
  53u,
  53u,
  106u,
  249u,
  87u,
  87u,
  174u,
  208u,
  185u,
  185u,
  105u,
  145u,
  134u,
  134u,
  23u,
  88u,
  193u,
  193u,
  153u,
  39u,
  29u,
  29u,
  58u,
  185u,
  158u,
  158u,
  39u,
  56u,
  225u,
  225u,
  217u,
  19u,
  248u,
  248u,
  235u,
  179u,
  152u,
  152u,
  43u,
  51u,
  17u,
  17u,
  34u,
  187u,
  105u,
  105u,
  210u,
  112u,
  217u,
  217u,
  169u,
  137u,
  142u,
  142u,
  7u,
  167u,
  148u,
  148u,
  51u,
  182u,
  155u,
  155u,
  45u,
  34u,
  30u,
  30u,
  60u,
  146u,
  135u,
  135u,
  21u,
  32u,
  233u,
  233u,
  201u,
  73u,
  206u,
  206u,
  135u,
  255u,
  85u,
  85u,
  170u,
  120u,
  40u,
  40u,
  80u,
  122u,
  223u,
  223u,
  165u,
  143u,
  140u,
  140u,
  3u,
  248u,
  161u,
  161u,
  89u,
  128u,
  137u,
  137u,
  9u,
  23u,
  13u,
  13u,
  26u,
  218u,
  191u,
  191u,
  101u,
  49u,
  230u,
  230u,
  215u,
  198u,
  66u,
  66u,
  132u,
  184u,
  104u,
  104u,
  208u,
  195u,
  65u,
  65u,
  130u,
  176u,
  153u,
  153u,
  41u,
  119u,
  45u,
  45u,
  90u,
  17u,
  15u,
  15u,
  30u,
  203u,
  176u,
  176u,
  123u,
  252u,
  84u,
  84u,
  168u,
  214u,
  187u,
  187u,
  109u,
  58u,
  22u,
  22u,
  44u
}; // weak
unsigned __int8 byte_8950[1024] =
{
  99u,
  99u,
  198u,
  165u,
  124u,
  124u,
  248u,
  132u,
  119u,
  119u,
  238u,
  153u,
  123u,
  123u,
  246u,
  141u,
  242u,
  242u,
  255u,
  13u,
  107u,
  107u,
  214u,
  189u,
  111u,
  111u,
  222u,
  177u,
  197u,
  197u,
  145u,
  84u,
  48u,
  48u,
  96u,
  80u,
  1u,
  1u,
  2u,
  3u,
  103u,
  103u,
  206u,
  169u,
  43u,
  43u,
  86u,
  125u,
  254u,
  254u,
  231u,
  25u,
  215u,
  215u,
  181u,
  98u,
  171u,
  171u,
  77u,
  230u,
  118u,
  118u,
  236u,
  154u,
  202u,
  202u,
  143u,
  69u,
  130u,
  130u,
  31u,
  157u,
  201u,
  201u,
  137u,
  64u,
  125u,
  125u,
  250u,
  135u,
  250u,
  250u,
  239u,
  21u,
  89u,
  89u,
  178u,
  235u,
  71u,
  71u,
  142u,
  201u,
  240u,
  240u,
  251u,
  11u,
  173u,
  173u,
  65u,
  236u,
  212u,
  212u,
  179u,
  103u,
  162u,
  162u,
  95u,
  253u,
  175u,
  175u,
  69u,
  234u,
  156u,
  156u,
  35u,
  191u,
  164u,
  164u,
  83u,
  247u,
  114u,
  114u,
  228u,
  150u,
  192u,
  192u,
  155u,
  91u,
  183u,
  183u,
  117u,
  194u,
  253u,
  253u,
  225u,
  28u,
  147u,
  147u,
  61u,
  174u,
  38u,
  38u,
  76u,
  106u,
  54u,
  54u,
  108u,
  90u,
  63u,
  63u,
  126u,
  65u,
  247u,
  247u,
  245u,
  2u,
  204u,
  204u,
  131u,
  79u,
  52u,
  52u,
  104u,
  92u,
  165u,
  165u,
  81u,
  244u,
  229u,
  229u,
  209u,
  52u,
  241u,
  241u,
  249u,
  8u,
  113u,
  113u,
  226u,
  147u,
  216u,
  216u,
  171u,
  115u,
  49u,
  49u,
  98u,
  83u,
  21u,
  21u,
  42u,
  63u,
  4u,
  4u,
  8u,
  12u,
  199u,
  199u,
  149u,
  82u,
  35u,
  35u,
  70u,
  101u,
  195u,
  195u,
  157u,
  94u,
  24u,
  24u,
  48u,
  40u,
  150u,
  150u,
  55u,
  161u,
  5u,
  5u,
  10u,
  15u,
  154u,
  154u,
  47u,
  181u,
  7u,
  7u,
  14u,
  9u,
  18u,
  18u,
  36u,
  54u,
  128u,
  128u,
  27u,
  155u,
  226u,
  226u,
  223u,
  61u,
  235u,
  235u,
  205u,
  38u,
  39u,
  39u,
  78u,
  105u,
  178u,
  178u,
  127u,
  205u,
  117u,
  117u,
  234u,
  159u,
  9u,
  9u,
  18u,
  27u,
  131u,
  131u,
  29u,
  158u,
  44u,
  44u,
  88u,
  116u,
  26u,
  26u,
  52u,
  46u,
  27u,
  27u,
  54u,
  45u,
  110u,
  110u,
  220u,
  178u,
  90u,
  90u,
  180u,
  238u,
  160u,
  160u,
  91u,
  251u,
  82u,
  82u,
  164u,
  246u,
  59u,
  59u,
  118u,
  77u,
  214u,
  214u,
  183u,
  97u,
  179u,
  179u,
  125u,
  206u,
  41u,
  41u,
  82u,
  123u,
  227u,
  227u,
  221u,
  62u,
  47u,
  47u,
  94u,
  113u,
  132u,
  132u,
  19u,
  151u,
  83u,
  83u,
  166u,
  245u,
  209u,
  209u,
  185u,
  104u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  193u,
  44u,
  32u,
  32u,
  64u,
  96u,
  252u,
  252u,
  227u,
  31u,
  177u,
  177u,
  121u,
  200u,
  91u,
  91u,
  182u,
  237u,
  106u,
  106u,
  212u,
  190u,
  203u,
  203u,
  141u,
  70u,
  190u,
  190u,
  103u,
  217u,
  57u,
  57u,
  114u,
  75u,
  74u,
  74u,
  148u,
  222u,
  76u,
  76u,
  152u,
  212u,
  88u,
  88u,
  176u,
  232u,
  207u,
  207u,
  133u,
  74u,
  208u,
  208u,
  187u,
  107u,
  239u,
  239u,
  197u,
  42u,
  170u,
  170u,
  79u,
  229u,
  251u,
  251u,
  237u,
  22u,
  67u,
  67u,
  134u,
  197u,
  77u,
  77u,
  154u,
  215u,
  51u,
  51u,
  102u,
  85u,
  133u,
  133u,
  17u,
  148u,
  69u,
  69u,
  138u,
  207u,
  249u,
  249u,
  233u,
  16u,
  2u,
  2u,
  4u,
  6u,
  127u,
  127u,
  254u,
  129u,
  80u,
  80u,
  160u,
  240u,
  60u,
  60u,
  120u,
  68u,
  159u,
  159u,
  37u,
  186u,
  168u,
  168u,
  75u,
  227u,
  81u,
  81u,
  162u,
  243u,
  163u,
  163u,
  93u,
  254u,
  64u,
  64u,
  128u,
  192u,
  143u,
  143u,
  5u,
  138u,
  146u,
  146u,
  63u,
  173u,
  157u,
  157u,
  33u,
  188u,
  56u,
  56u,
  112u,
  72u,
  245u,
  245u,
  241u,
  4u,
  188u,
  188u,
  99u,
  223u,
  182u,
  182u,
  119u,
  193u,
  218u,
  218u,
  175u,
  117u,
  33u,
  33u,
  66u,
  99u,
  16u,
  16u,
  32u,
  48u,
  255u,
  255u,
  229u,
  26u,
  243u,
  243u,
  253u,
  14u,
  210u,
  210u,
  191u,
  109u,
  205u,
  205u,
  129u,
  76u,
  12u,
  12u,
  24u,
  20u,
  19u,
  19u,
  38u,
  53u,
  236u,
  236u,
  195u,
  47u,
  95u,
  95u,
  190u,
  225u,
  151u,
  151u,
  53u,
  162u,
  68u,
  68u,
  136u,
  204u,
  23u,
  23u,
  46u,
  57u,
  196u,
  196u,
  147u,
  87u,
  167u,
  167u,
  85u,
  242u,
  126u,
  126u,
  252u,
  130u,
  61u,
  61u,
  122u,
  71u,
  100u,
  100u,
  200u,
  172u,
  93u,
  93u,
  186u,
  231u,
  25u,
  25u,
  50u,
  43u,
  115u,
  115u,
  230u,
  149u,
  96u,
  96u,
  192u,
  160u,
  129u,
  129u,
  25u,
  152u,
  79u,
  79u,
  158u,
  209u,
  220u,
  220u,
  163u,
  127u,
  34u,
  34u,
  68u,
  102u,
  42u,
  42u,
  84u,
  126u,
  144u,
  144u,
  59u,
  171u,
  136u,
  136u,
  11u,
  131u,
  70u,
  70u,
  140u,
  202u,
  238u,
  238u,
  199u,
  41u,
  184u,
  184u,
  107u,
  211u,
  20u,
  20u,
  40u,
  60u,
  222u,
  222u,
  167u,
  121u,
  94u,
  94u,
  188u,
  226u,
  11u,
  11u,
  22u,
  29u,
  219u,
  219u,
  173u,
  118u,
  224u,
  224u,
  219u,
  59u,
  50u,
  50u,
  100u,
  86u,
  58u,
  58u,
  116u,
  78u,
  10u,
  10u,
  20u,
  30u,
  73u,
  73u,
  146u,
  219u,
  6u,
  6u,
  12u,
  10u,
  36u,
  36u,
  72u,
  108u,
  92u,
  92u,
  184u,
  228u,
  194u,
  194u,
  159u,
  93u,
  211u,
  211u,
  189u,
  110u,
  172u,
  172u,
  67u,
  239u,
  98u,
  98u,
  196u,
  166u,
  145u,
  145u,
  57u,
  168u,
  149u,
  149u,
  49u,
  164u,
  228u,
  228u,
  211u,
  55u,
  121u,
  121u,
  242u,
  139u,
  231u,
  231u,
  213u,
  50u,
  200u,
  200u,
  139u,
  67u,
  55u,
  55u,
  110u,
  89u,
  109u,
  109u,
  218u,
  183u,
  141u,
  141u,
  1u,
  140u,
  213u,
  213u,
  177u,
  100u,
  78u,
  78u,
  156u,
  210u,
  169u,
  169u,
  73u,
  224u,
  108u,
  108u,
  216u,
  180u,
  86u,
  86u,
  172u,
  250u,
  244u,
  244u,
  243u,
  7u,
  234u,
  234u,
  207u,
  37u,
  101u,
  101u,
  202u,
  175u,
  122u,
  122u,
  244u,
  142u,
  174u,
  174u,
  71u,
  233u,
  8u,
  8u,
  16u,
  24u,
  186u,
  186u,
  111u,
  213u,
  120u,
  120u,
  240u,
  136u,
  37u,
  37u,
  74u,
  111u,
  46u,
  46u,
  92u,
  114u,
  28u,
  28u,
  56u,
  36u,
  166u,
  166u,
  87u,
  241u,
  180u,
  180u,
  115u,
  199u,
  198u,
  198u,
  151u,
  81u,
  232u,
  232u,
  203u,
  35u,
  221u,
  221u,
  161u,
  124u,
  116u,
  116u,
  232u,
  156u,
  31u,
  31u,
  62u,
  33u,
  75u,
  75u,
  150u,
  221u,
  189u,
  189u,
  97u,
  220u,
  139u,
  139u,
  13u,
  134u,
  138u,
  138u,
  15u,
  133u,
  112u,
  112u,
  224u,
  144u,
  62u,
  62u,
  124u,
  66u,
  181u,
  181u,
  113u,
  196u,
  102u,
  102u,
  204u,
  170u,
  72u,
  72u,
  144u,
  216u,
  3u,
  3u,
  6u,
  5u,
  246u,
  246u,
  247u,
  1u,
  14u,
  14u,
  28u,
  18u,
  97u,
  97u,
  194u,
  163u,
  53u,
  53u,
  106u,
  95u,
  87u,
  87u,
  174u,
  249u,
  185u,
  185u,
  105u,
  208u,
  134u,
  134u,
  23u,
  145u,
  193u,
  193u,
  153u,
  88u,
  29u,
  29u,
  58u,
  39u,
  158u,
  158u,
  39u,
  185u,
  225u,
  225u,
  217u,
  56u,
  248u,
  248u,
  235u,
  19u,
  152u,
  152u,
  43u,
  179u,
  17u,
  17u,
  34u,
  51u,
  105u,
  105u,
  210u,
  187u,
  217u,
  217u,
  169u,
  112u,
  142u,
  142u,
  7u,
  137u,
  148u,
  148u,
  51u,
  167u,
  155u,
  155u,
  45u,
  182u,
  30u,
  30u,
  60u,
  34u,
  135u,
  135u,
  21u,
  146u,
  233u,
  233u,
  201u,
  32u,
  206u,
  206u,
  135u,
  73u,
  85u,
  85u,
  170u,
  255u,
  40u,
  40u,
  80u,
  120u,
  223u,
  223u,
  165u,
  122u,
  140u,
  140u,
  3u,
  143u,
  161u,
  161u,
  89u,
  248u,
  137u,
  137u,
  9u,
  128u,
  13u,
  13u,
  26u,
  23u,
  191u,
  191u,
  101u,
  218u,
  230u,
  230u,
  215u,
  49u,
  66u,
  66u,
  132u,
  198u,
  104u,
  104u,
  208u,
  184u,
  65u,
  65u,
  130u,
  195u,
  153u,
  153u,
  41u,
  176u,
  45u,
  45u,
  90u,
  119u,
  15u,
  15u,
  30u,
  17u,
  176u,
  176u,
  123u,
  203u,
  84u,
  84u,
  168u,
  252u,
  187u,
  187u,
  109u,
  214u,
  22u,
  22u,
  44u,
  58u
}; // weak
_UNKNOWN unk_8D50; // weak
_DWORD dword_8D78[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
_DWORD dword_9178[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
_DWORD dword_9578[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
_DWORD dword_9978[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
unsigned __int8 byte_9D78[256] =
{
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u
}; // weak
_UNKNOWN *off_212C0 = &off_212C0; // weak
char *off_212C8[4] = { "w+b", "r+b", "rb", "ab" }; // weak
__int64 qword_258C0; // weak
int dword_258C8; // weak
__int16 word_258D0[]; // weak
__int128 xmmword_258E0; // weak
__int128 xmmword_258F0; // weak
__int128 xmmword_25900; // weak
__int128 xmmword_25910; // weak
__int128 xmmword_25920; // weak
__int128 xmmword_25930; // weak
__int128 xmmword_25940; // weak
__int128 xmmword_25950; // weak
__int128 xmmword_25960; // weak
__int128 xmmword_25970; // weak
__int128 xmmword_25980; // weak
__int128 xmmword_25990; // weak
__int128 xmmword_259A0; // weak
__int128 xmmword_259B0; // weak
__int128 xmmword_259C0; // weak
__int128 xmmword_259D0; // weak
__int128 xmmword_259E0; // weak
__int128 xmmword_259F0; // weak
__int128 xmmword_25A00; // weak
__int128 xmmword_25A10; // weak
__int128 xmmword_25A20; // weak
__int128 xmmword_25A30; // weak
__int128 xmmword_25A40; // weak
__int128 xmmword_25A50; // weak
__int64 qword_25A60; // weak
__int128 xmmword_25A6A; // weak
__int128 xmmword_25A7A; // weak
__int128 xmmword_25A8A; // weak
__int128 xmmword_25A9A; // weak
__int128 xmmword_25AAA; // weak
__int128 xmmword_25ABA; // weak
__int16 word_25ACA; // weak
_QWORD qword_25B00[1]; // weak
__int128 xmmword_25B08; // weak
__int128 xmmword_25B18; // weak
__int128 xmmword_25B28; // weak
__int128 xmmword_25B38; // weak
__int128 xmmword_25B48; // weak
__int128 xmmword_25B58; // weak
__int128 xmmword_25B68; // weak
__int128 xmmword_25B78; // weak
__int128 xmmword_25B88; // weak
__int128 xmmword_25B98; // weak
__int128 xmmword_25BA8; // weak
__int128 xmmword_25BB8; // weak
__int128 xmmword_25BC8; // weak
__int128 xmmword_25BD8; // weak
__int128 xmmword_25BE8; // weak
__int128 xmmword_25BF8; // weak
__int128 xmmword_25C08; // weak
__int128 xmmword_25C18; // weak
__int128 xmmword_25C28; // weak
__int128 xmmword_25C38; // weak
__int128 xmmword_25C48; // weak
__int128 xmmword_25C58; // weak
__int128 xmmword_25C68; // weak
__int128 xmmword_25C78; // weak
__int64 qword_25C88; // weak
__int64 qword_25C90; // weak
__int64 qword_25C98; // weak
__int64 qword_25CA0; // weak
__int64 qword_25CA8; // weak
__int64 qword_25CB0; // weak


//----- (000000000000C224) ----------------------------------------------------
__int64 sub_C224()
{
  return __cxa_finalize(&off_212C0);
}
// 212C0: using guessed type _UNKNOWN *off_212C0;

//----- (000000000000C234) ----------------------------------------------------
void sub_C234()
{
  ;
}

//----- (000000000000C23C) ----------------------------------------------------
void sub_C23C()
{
  sub_C234();
}

//----- (000000000000C244) ----------------------------------------------------
__int64 (*__fastcall sub_C244(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (000000000000C258) ----------------------------------------------------
__int64 __fastcall sub_C258(void *obj)
{
  return __cxa_atexit((void (*)(void *))sub_C244, obj, &off_212C0);
}
// 212C0: using guessed type _UNKNOWN *off_212C0;

//----- (000000000000C274) ----------------------------------------------------
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3)
{
  __int64 result; // x0
  unsigned int v4; // w19

  result = DHGetClientID_BySetVal(a1, a2, a3, (__int16 **)&qword_258C0);
  if ( (int)result <= 0 )
  {
    v4 = result;
    DHFreeClientID((void *)qword_258C0);
    result = v4;
    qword_258C0 = 0;
  }
  return result;
}
// 258C0: using guessed type __int64 qword_258C0;

//----- (000000000000C2BC) ----------------------------------------------------
__int64 DRM_SetClientID()
{
  int v0; // w19

  if ( !qword_258C0 )
    qword_258C0 = (__int64)DHmalloc(14);
  v0 = DA_DRA_SetClientID();
  if ( v0 <= 0 )
  {
    DHFreeClientID((void *)qword_258C0);
    return DRM_Init();
  }
  else
  {
    printLogD();
    return (unsigned int)v0;
  }
}
// 258C0: using guessed type __int64 qword_258C0;

//----- (000000000000C340) ----------------------------------------------------
__int64 DRM_Init()
{
  __int128 v1; // q0

  printLogD();
  if ( dword_258C8++ <= 0 )
  {
    DHmemset(&word_258D0, 0, 560);
    *(_QWORD *)&v1 = -1;
    *((_QWORD *)&v1 + 1) = -1;
    qword_25C88 = 0;
    qword_25A60 = -1;
    xmmword_258E0 = v1;
    xmmword_258F0 = v1;
    xmmword_25900 = v1;
    xmmword_25910 = v1;
    xmmword_25920 = v1;
    xmmword_25930 = v1;
    xmmword_25940 = v1;
    xmmword_25950 = v1;
    xmmword_25960 = v1;
    xmmword_25970 = v1;
    xmmword_25980 = v1;
    xmmword_25990 = v1;
    xmmword_259A0 = v1;
    xmmword_259B0 = v1;
    xmmword_259C0 = v1;
    xmmword_259D0 = v1;
    xmmword_259E0 = v1;
    xmmword_259F0 = v1;
    xmmword_25A00 = v1;
    xmmword_25A10 = v1;
    xmmword_25A20 = v1;
    xmmword_25A30 = v1;
    xmmword_25A40 = v1;
    xmmword_25A50 = v1;
    *(_QWORD *)&v1 = 0x1000100010001LL;
    *((_QWORD *)&v1 + 1) = 0x1000100010001LL;
    xmmword_25B08 = 0u;
    xmmword_25B18 = 0u;
    xmmword_25B28 = 0u;
    xmmword_25B38 = 0u;
    xmmword_25B48 = 0u;
    xmmword_25B58 = 0u;
    xmmword_25B68 = 0u;
    xmmword_25B78 = 0u;
    xmmword_25B88 = 0u;
    xmmword_25B98 = 0u;
    xmmword_25BA8 = 0u;
    xmmword_25BB8 = 0u;
    xmmword_25BC8 = 0u;
    xmmword_25BD8 = 0u;
    xmmword_25BE8 = 0u;
    xmmword_25BF8 = 0u;
    xmmword_25C08 = 0u;
    xmmword_25C18 = 0u;
    xmmword_25C28 = 0u;
    xmmword_25C38 = 0u;
    xmmword_25C48 = 0u;
    xmmword_25C58 = 0u;
    xmmword_25C68 = 0u;
    xmmword_25C78 = 0u;
    xmmword_25A6A = v1;
    xmmword_25A7A = v1;
    xmmword_25A8A = v1;
    xmmword_25A9A = v1;
    xmmword_25AAA = v1;
    xmmword_25ABA = v1;
    word_258D0 = 0;
    word_25ACA = 1;
    printLogD();
    if ( !qword_258C0 )
      qword_258C0 = (__int64)DHmalloc(14);
  }
  return 0;
}
// 0: using guessed type int dword_0;
// 20: using guessed type __int64;
// 30: using guessed type int;
// 40: using guessed type int dword_40;
// 50: using guessed type int *[4];
// 1F8: using guessed type __int64;
// 258C0: using guessed type __int64 qword_258C0;
// 258C8: using guessed type int dword_258C8;
// 258D0: using guessed type __int16 word_258D0;
// 258E0: using guessed type __int128 xmmword_258E0;
// 258F0: using guessed type __int128 xmmword_258F0;
// 25900: using guessed type __int128 xmmword_25900;
// 25910: using guessed type __int128 xmmword_25910;
// 25920: using guessed type __int128 xmmword_25920;
// 25930: using guessed type __int128 xmmword_25930;
// 25940: using guessed type __int128 xmmword_25940;
// 25950: using guessed type __int128 xmmword_25950;
// 25960: using guessed type __int128 xmmword_25960;
// 25970: using guessed type __int128 xmmword_25970;
// 25980: using guessed type __int128 xmmword_25980;
// 25990: using guessed type __int128 xmmword_25990;
// 259A0: using guessed type __int128 xmmword_259A0;
// 259B0: using guessed type __int128 xmmword_259B0;
// 259C0: using guessed type __int128 xmmword_259C0;
// 259D0: using guessed type __int128 xmmword_259D0;
// 259E0: using guessed type __int128 xmmword_259E0;
// 259F0: using guessed type __int128 xmmword_259F0;
// 25A00: using guessed type __int128 xmmword_25A00;
// 25A10: using guessed type __int128 xmmword_25A10;
// 25A20: using guessed type __int128 xmmword_25A20;
// 25A30: using guessed type __int128 xmmword_25A30;
// 25A40: using guessed type __int128 xmmword_25A40;
// 25A50: using guessed type __int128 xmmword_25A50;
// 25A60: using guessed type __int64 qword_25A60;
// 25A6A: using guessed type __int128 xmmword_25A6A;
// 25A7A: using guessed type __int128 xmmword_25A7A;
// 25A8A: using guessed type __int128 xmmword_25A8A;
// 25A9A: using guessed type __int128 xmmword_25A9A;
// 25AAA: using guessed type __int128 xmmword_25AAA;
// 25ABA: using guessed type __int128 xmmword_25ABA;
// 25ACA: using guessed type __int16 word_25ACA;
// 25B08: using guessed type __int128 xmmword_25B08;
// 25B18: using guessed type __int128;
// 25B28: using guessed type __int128 xmmword_25B28;
// 25B38: using guessed type __int128 xmmword_25B38;
// 25B48: using guessed type __int128 xmmword_25B48;
// 25B58: using guessed type __int128 xmmword_25B58;
// 25B68: using guessed type __int128 xmmword_25B68;
// 25B78: using guessed type __int128 xmmword_25B78;
// 25B88: using guessed type __int128 xmmword_25B88;
// 25B98: using guessed type __int128 xmmword_25B98;
// 25BA8: using guessed type __int128 xmmword_25BA8;
// 25BB8: using guessed type __int128 xmmword_25BB8;
// 25BC8: using guessed type __int128 xmmword_25BC8;
// 25BD8: using guessed type __int128 xmmword_25BD8;
// 25BE8: using guessed type __int128 xmmword_25BE8;
// 25BF8: using guessed type __int128 xmmword_25BF8;
// 25C08: using guessed type __int128 xmmword_25C08;
// 25C18: using guessed type __int128 xmmword_25C18;
// 25C28: using guessed type __int128 xmmword_25C28;
// 25C38: using guessed type __int128 xmmword_25C38;
// 25C48: using guessed type __int128 xmmword_25C48;
// 25C58: using guessed type __int128 xmmword_25C58;
// 25C68: using guessed type __int128 xmmword_25C68;
// 25C78: using guessed type __int128 xmmword_25C78;
// 25C88: using guessed type __int64 qword_25C88;

//----- (000000000000C474) ----------------------------------------------------
void DRM_Destroy()
{
  __int64 i; // x19
  void **v2; // x0
  _QWORD *v3; // x24

  printLogD();
  word_258D0[0] = 0;
  if ( dword_258C8-- <= 1 )
  {
    for ( i = 0; i != 49; ++i )
    {
      *((_WORD *)&xmmword_25A6A + i) = 32;
      v2 = (void **)qword_25B00[i + 1];
      *(_QWORD *)((char *)&xmmword_25A6A + 8 * i - 394) = -1;
      if ( v2 )
      {
        v3 = &qword_25B00[i];
        if ( v2[66] )
        {
          DHfree(v2[66]);
          v2 = (void **)v3[1];
          v2[66] = 0;
        }
        DHfree(v2);
        v3[1] = 0;
      }
    }
    DHFreeClientID((void *)qword_258C0);
    qword_258C0 = 0;
    DHmemcount();
    printLogD();
  }
}
// 258C0: using guessed type __int64 qword_258C0;
// 258C8: using guessed type int dword_258C8;
// 258D0: using guessed type __int16 word_258D0[];
// 25A6A: using guessed type __int128 xmmword_25A6A;
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000C578) ----------------------------------------------------
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  unsigned int v6; // w19
  unsigned int v7; // w0
  __int16 *v8; // x27
  int v9; // w20
  void *v10; // x0
  __int64 v11; // x21
  int v12; // w9
  void *v13; // x0
  __int16 v14; // w0
  _BYTE *v15; // x0
  __int16 v16; // w0
  int v17; // w22
  __int16 v18; // w0
  __int64 v19; // x8
  int v20; // w10
  int v21; // w11
  int v22; // w9
  int v23; // w10
  int v24; // w3
  __int64 v25; // x2
  __int16 v26; // w8
  __int16 v27; // w8
  int v29; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v30; // [xsp+8h] [xbp-8h]

  v30 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  if ( word_258D0[0] == 50 )
    return 65510;
  if ( a1 <= 0 )
  {
    printLogD();
    return 65523;
  }
  printLogD();
  v7 = DA_DRA_MetaFilePfdOpen(a1, a2, (__int64)word_258D0);
  if ( !(v7 << 16) )
    return 0xFFFF;
  v8 = &word_258D0[(__int16)v7];
  v9 = (__int16)v7;
  v6 = v7;
  printLogD();
  if ( (v8[204] & 1) == 0 )
  {
    DA_DRA_MetaFileClose(v9, (__int64)word_258D0);
    return 65511;
  }
  printLogD();
  v10 = DHmalloc(880);
  if ( !v10 )
  {
LABEL_24:
    DA_DRA_MetaFileClose(v9, (__int64)word_258D0);
    return 65514;
  }
  v11 = (__int64)v10;
  DHmemset(v10, 0, 880);
  *(_QWORD *)v11 = *(_QWORD *)&word_258D0[4 * (__int16)v6 + 4];
  DHmemset((void *)(v11 + 8), 0, 512);
  v12 = *(_DWORD *)(v11 + 524);
  *(_DWORD *)(v11 + 520) = a2;
  *(_DWORD *)(v11 + 588) = 0;
  *(_DWORD *)(v11 + 524) = v12 | a3;
  *(_QWORD *)(v11 + 592) = 0;
  *(_QWORD *)(v11 + 664) = 0;
  *(_DWORD *)(v11 + 672) = 0;
  v13 = DHmalloc(256);
  *(_QWORD *)(v11 + 528) = v13;
  if ( !v13 )
  {
    DHfree((void *)v11);
    goto LABEL_24;
  }
  DHmemset(v13, 0, 256);
  DHmemset((void *)(v11 + 808), 0, 16);
  printLogD();
  v14 = DA_DRA_DCFParser(*(_QWORD *)v11, *(_QWORD *)(v11 + 528), &v29);
  if ( v14 < 0 )
  {
    v6 = v14;
    DA_DRA_DCFDestroy(*(_QWORD **)(v11 + 528));
    DHfree((void *)v11);
    DA_DRA_MetaFileClose(v9, (__int64)word_258D0);
  }
  else
  {
    printLogD();
    v15 = *(_BYTE **)(*(_QWORD *)(v11 + 528) + 128LL);
    *(_DWORD *)(v11 + 832) = 0;
    *(_QWORD *)(v11 + 860) = 0;
    if ( !(unsigned int)DHstrnicmp(v15, "GID", 4) || !*(_QWORD *)(*(_QWORD *)(v11 + 528) + 40LL) )
    {
      printLogD();
      v16 = sub_C9AC(v11);
      if ( v16 )
      {
        v17 = v16;
        printLogD();
        *(_DWORD *)(v11 + 864) = v17;
      }
    }
    if ( *(_DWORD *)(v11 + 860) != 1 )
    {
      printLogD();
      v18 = ClusterAuthentication(
              *(_BYTE **)(*(_QWORD *)(v11 + 528) + 40LL),
              (__int64 *)(v11 + 824),
              (__int64 *)(v11 + 840),
              (__int64 **)(v11 + 848),
              (_DWORD *)(v11 + 856),
              (void **)&qword_258C0);
      if ( v18 )
      {
        *(_DWORD *)(v11 + 864) = v18;
        printLogD();
      }
    }
    printLogD();
    *(_DWORD *)(v11 + 600) = DHfsMetaTell(*(_QWORD *)v11);
    printLogD();
    v19 = *(_QWORD *)(v11 + 528);
    v20 = *(_DWORD *)(v19 + 80);
    v21 = *(_DWORD *)(v19 + 36);
    *(_QWORD *)(v11 + 628) = 0;
    *(_DWORD *)(v11 + 604) = 0;
    *(_QWORD *)(v11 + 608) = 0;
    if ( v20 )
      v22 = v20;
    else
      v22 = v21;
    *(_DWORD *)(v11 + 616) = v21;
    v23 = v29;
    *(_DWORD *)(v11 + 624) = v22;
    *(_DWORD *)(v11 + 620) = v22;
    v24 = *(_DWORD *)(v19 + 8);
    v25 = *(_QWORD *)(v19 + 24);
    *(_DWORD *)(v11 + 676) = v23;
    *(_DWORD *)(v11 + 636) = v24;
    DHmemcpy_s(v11 + 640, 21, v25, v24);
    v26 = word_258D0[0];
    qword_25B00[(__int16)v6] = v11;
    word_258D0[0] = v26 + 1;
    v27 = v8[204];
    *(_QWORD *)(v11 + 872) = 0;
    *(_DWORD *)(v11 + 868) = -1;
    v8[204] = v27 | 3;
  }
  printLogD();
  return v6;
}
// 258C0: using guessed type __int64 qword_258C0;
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000C9AC) ----------------------------------------------------
__int64 __fastcall sub_C9AC(__int64 a1)
{
  unsigned int v2; // w3
  int v3; // w0
  int v4; // w19
  unsigned int v6; // [xsp+Ch] [xbp-44h] BYREF
  _BYTE v7[51]; // [xsp+10h] [xbp-40h] BYREF
  __int64 v8; // [xsp+48h] [xbp-8h]

  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  *(_DWORD *)(a1 + 860) = 1;
  v6 = 50;
  memset(v7, 0, sizeof(v7));
  printLogD();
  if ( !qword_258C0 )
    qword_258C0 = (__int64)DHmalloc(14);
  if ( (int)DHGetClientID_BySetVal(
              *(const char **)(*(_QWORD *)(a1 + 528) + 128LL),
              &v6,
              (__int64)v7,
              (__int16 **)&qword_258C0) <= 0 )
  {
    DHFreeClientID((void *)qword_258C0);
    qword_258C0 = 0;
    printLogD();
    printLogD();
    return 65436;
  }
  else
  {
    printLogD();
    v2 = v6;
    *(_DWORD *)(a1 + 832) = 1;
    v3 = DHstrncpy_s(a1 + 536, 50, (__int64)v7, v2);
    if ( v3 )
    {
      v4 = v3;
      strerror(v3);
      printLogD();
      return StrErrorReturn(v4);
    }
    else
    {
      *(_DWORD *)(a1 + 636) = v6;
      printLogD();
      return 0;
    }
  }
}
// 258C0: using guessed type __int64 qword_258C0;

//----- (000000000000CB5C) ----------------------------------------------------
__int64 __fastcall DRM_Open_Path(const char *a1, int a2, __int16 a3)
{
  unsigned int v6; // w19
  unsigned int v7; // w0
  __int16 *v8; // x28
  int v9; // w20
  void *v10; // x0
  __int64 v11; // x21
  int v12; // w0
  int v13; // w9
  void *v14; // x0
  __int16 v15; // w0
  _BYTE *v16; // x0
  __int16 v17; // w0
  int v18; // w22
  __int16 v19; // w0
  __int64 v20; // x8
  int v21; // w10
  int v22; // w11
  int v23; // w9
  int v24; // w10
  int v25; // w3
  __int64 v26; // x2
  __int16 v27; // w8
  int v28; // w0
  int v30; // [xsp+14h] [xbp-Ch] BYREF
  __int64 v31; // [xsp+18h] [xbp-8h]

  v31 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  if ( word_258D0[0] == 50 )
    return 65510;
  if ( !a1 )
  {
    printLogD();
    return 65523;
  }
  DHstrlen(a1);
  printLogD();
  v7 = DA_DRA_MetaFileOpen(a1, a2, (__int64)word_258D0);
  if ( !(v7 << 16) )
    return 0xFFFF;
  v8 = &word_258D0[(__int16)v7];
  v9 = (__int16)v7;
  v6 = v7;
  printLogD();
  if ( (v8[204] & 1) == 0 )
  {
    DA_DRA_MetaFileClose(v9, (__int64)word_258D0);
    return 65511;
  }
  printLogD();
  v10 = DHmalloc(880);
  if ( !v10 )
  {
    v28 = v9;
LABEL_25:
    DA_DRA_MetaFileClose(v28, (__int64)word_258D0);
    return 65514;
  }
  v11 = (__int64)v10;
  DHmemset(v10, 0, 880);
  *(_QWORD *)v11 = *(_QWORD *)&word_258D0[4 * (__int16)v6 + 4];
  DHmemset((void *)(v11 + 8), 0, 512);
  v12 = DHstrlen(a1);
  DHmemcpy_s(v11 + 8, 512, (__int64)a1, v12);
  v13 = *(_DWORD *)(v11 + 524);
  *(_DWORD *)(v11 + 520) = a2;
  *(_DWORD *)(v11 + 588) = 0;
  *(_DWORD *)(v11 + 524) = v13 | a3;
  *(_QWORD *)(v11 + 592) = 0;
  *(_QWORD *)(v11 + 664) = 0;
  *(_DWORD *)(v11 + 672) = 0;
  v14 = DHmalloc(256);
  *(_QWORD *)(v11 + 528) = v14;
  if ( !v14 )
  {
    DHfree((void *)v11);
    v28 = v9;
    goto LABEL_25;
  }
  DHmemset(v14, 0, 256);
  DHmemset((void *)(v11 + 808), 0, 16);
  printLogD();
  v15 = DA_DRA_DCFParser(*(_QWORD *)v11, *(_QWORD *)(v11 + 528), &v30);
  if ( v15 < 0 )
  {
    v6 = v15;
    DA_DRA_DCFDestroy(*(_QWORD **)(v11 + 528));
    DHfree((void *)v11);
    DA_DRA_MetaFileClose(v9, (__int64)word_258D0);
  }
  else
  {
    printLogD();
    v16 = *(_BYTE **)(*(_QWORD *)(v11 + 528) + 128LL);
    *(_DWORD *)(v11 + 832) = 0;
    *(_QWORD *)(v11 + 860) = 0;
    if ( !(unsigned int)DHstrnicmp(v16, "GID", 4) || !*(_QWORD *)(*(_QWORD *)(v11 + 528) + 40LL) )
    {
      printLogD();
      v17 = sub_C9AC(v11);
      if ( v17 )
      {
        v18 = v17;
        printLogD();
        *(_DWORD *)(v11 + 864) = v18;
      }
    }
    if ( *(_DWORD *)(v11 + 860) != 1 )
    {
      printLogD();
      v19 = ClusterAuthentication(
              *(_BYTE **)(*(_QWORD *)(v11 + 528) + 40LL),
              (__int64 *)(v11 + 824),
              (__int64 *)(v11 + 840),
              (__int64 **)(v11 + 848),
              (_DWORD *)(v11 + 856),
              (void **)&qword_258C0);
      if ( v19 )
      {
        *(_DWORD *)(v11 + 864) = v19;
        printLogD();
      }
    }
    printLogD();
    *(_DWORD *)(v11 + 600) = DHfsMetaTell(*(_QWORD *)v11);
    printLogD();
    v20 = *(_QWORD *)(v11 + 528);
    v21 = *(_DWORD *)(v20 + 80);
    v22 = *(_DWORD *)(v20 + 36);
    *(_QWORD *)(v11 + 628) = 0;
    *(_DWORD *)(v11 + 604) = 0;
    *(_QWORD *)(v11 + 608) = 0;
    if ( v21 )
      v23 = v21;
    else
      v23 = v22;
    *(_DWORD *)(v11 + 616) = v22;
    v24 = v30;
    *(_DWORD *)(v11 + 624) = v23;
    *(_DWORD *)(v11 + 620) = v23;
    v25 = *(_DWORD *)(v20 + 8);
    v26 = *(_QWORD *)(v20 + 24);
    *(_DWORD *)(v11 + 676) = v24;
    *(_DWORD *)(v11 + 636) = v25;
    DHmemcpy_s(v11 + 640, 21, v26, v25);
    ++word_258D0[0];
    qword_25B00[(__int16)v6] = v11;
    v27 = v8[204];
    *(_QWORD *)(v11 + 872) = 0;
    *(_DWORD *)(v11 + 868) = -1;
    v8[204] = v27 | 3;
  }
  printLogD();
  return v6;
}
// 258C0: using guessed type __int64 qword_258C0;
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000CFDC) ----------------------------------------------------
__int64 __fastcall DRM_Close(unsigned __int16 a1)
{
  int v1; // w20
  __int16 *v3; // x23
  _QWORD *v4; // x23
  __int64 v5; // t1
  __int64 v6; // x24
  __int64 v7; // x21
  void *v8; // x0
  void *v9; // x0
  __int64 v10; // x0
  __int16 *v11; // x8
  unsigned int v12; // w20
  __int16 v13; // w10
  __int16 v14; // w9

  v1 = (__int16)a1;
  printLogD();
  if ( v1 < 1 )
  {
    v12 = 65533;
  }
  else
  {
    v3 = &word_258D0[4 * a1];
    v5 = *((_QWORD *)v3 + 1);
    v4 = v3 + 4;
    if ( v5 )
    {
      v6 = a1;
      v7 = qword_25B00[a1];
      printLogD();
      DA_DRA_DCFDestroy(*(_QWORD **)(v7 + 528));
      printLogD();
      v8 = *(void **)(v7 + 872);
      if ( v8 )
        DHfree(v8);
      printLogD();
      printLogD();
      ClientIDDestroy(*(_QWORD **)(v7 + 824));
      printLogD();
      v9 = *(void **)(v7 + 840);
      if ( v9 )
        DHfree(v9);
      printLogD();
      v10 = *(_QWORD *)(v7 + 848);
      if ( v10 )
        DomainListDestroy(v10);
      printLogD();
      DHfree((void *)v7);
      printLogD();
      qword_25B00[v6] = 0;
      DA_DRA_MetaFileClose(v1, (__int64)word_258D0);
      printLogD();
      v11 = &word_258D0[v6];
      v12 = 0;
      v13 = v11[204];
      v14 = word_258D0[0] - 1;
      *v4 = -1;
      word_258D0[0] = v14;
      v11[204] = v13 & 0xFFED | 0x10;
    }
    else
    {
      v12 = 65533;
    }
  }
  printLogD();
  return v12;
}
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000D1A4) ----------------------------------------------------
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3)
{
  __int64 v6; // x26
  __int64 v7; // x8
  int v8; // w2
  __int64 v9; // x22
  int v10; // w8
  __int16 *v11; // x8
  int v12; // w24
  int v13; // w25
  __int64 v14; // x26
  int v15; // w23
  int v16; // w12
  int v17; // w11
  int v18; // w13
  int v19; // w28
  unsigned int v20; // w8
  unsigned int v21; // w2
  int v22; // w0
  unsigned int v23; // w8
  int v24; // w10
  __int64 v25; // x11
  char *v26; // x12
  int v27; // w9
  __int64 result; // x0
  _BYTE *v29; // x14
  char v30; // w13
  unsigned int v31; // w14
  __int16 v32; // w0
  unsigned int v33; // w19
  __int64 v34; // x8
  __int16 *v35; // x25
  __int64 *v36; // x25
  __int64 v37; // t1
  int v38; // w24
  int v39; // w8
  int v40; // w23
  signed int v41; // w24
  char *v42; // x0
  int8x16_t *v43; // x22
  int v44; // w0
  unsigned int v45; // w23
  __int64 v46; // x9
  int v47; // w28
  unsigned int v48; // w23
  char *v49; // x21
  signed int v50; // w10
  unsigned int v51; // w2
  int v52; // w0
  unsigned int v53; // w8
  int v54; // w10
  int v55; // w22
  __int64 v56; // x11
  int v57; // w9
  _BYTE *v58; // x13
  char v59; // w12
  unsigned int v60; // w13
  __int64 *v61; // x22
  int v62; // w8
  int v63; // w23
  __int64 v64; // x8
  int8x16_t *v65; // x28
  int8x16_t *v66; // x26
  int v67; // w8
  int v68; // w8
  int v69; // w22
  int v70; // [xsp+8h] [xbp-148h]
  int v71; // [xsp+Ch] [xbp-144h]
  int v72; // [xsp+Ch] [xbp-144h]
  int v73; // [xsp+10h] [xbp-140h]
  signed int v74; // [xsp+10h] [xbp-140h]
  int v75; // [xsp+14h] [xbp-13Ch]
  unsigned int v76; // [xsp+14h] [xbp-13Ch]
  __int64 *v77; // [xsp+18h] [xbp-138h]
  int v78; // [xsp+18h] [xbp-138h]
  int *v79; // [xsp+20h] [xbp-130h] BYREF
  char v80[16]; // [xsp+28h] [xbp-128h] BYREF
  _DWORD v81[61]; // [xsp+38h] [xbp-118h] BYREF
  __int128 v82; // [xsp+12Fh] [xbp-21h] BYREF
  char v83; // [xsp+13Fh] [xbp-11h]
  __int64 v84; // [xsp+140h] [xbp-10h]

  v84 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v79 = 0;
  printLogD();
  printLogD();
  if ( (__int16)a1 <= 0 )
  {
    printLogD();
    return 4294967293LL;
  }
  printLogD();
  if ( (~(unsigned __int16)word_258D0[(unsigned __int16)a1 + 204] & 3) != 0 )
    return 4294967271LL;
  v6 = (unsigned __int16)a1;
  v7 = qword_25B00[(unsigned __int16)a1];
  v8 = *(_DWORD *)(v7 + 868);
  if ( v8 == -1 )
  {
    printLogD();
    printLogD();
    v32 = sub_D834(a1, &v79);
    if ( v32 )
    {
      v33 = v32;
      printLogD();
      printLogD();
      v34 = qword_25B00[(unsigned __int16)a1];
      result = v33;
      *(_QWORD *)(v34 + 872) = 0;
      *(_DWORD *)(v34 + 868) = 0;
      return result;
    }
    printLogD();
    v46 = qword_25B00[(unsigned __int16)a1];
    *(_QWORD *)(v46 + 872) = v79;
    *(_DWORD *)(v46 + 868) = 1;
    DRM_Seek(a1, 0, 3);
    v7 = qword_25B00[(unsigned __int16)a1];
    if ( *(_DWORD *)(v7 + 868) != 1 )
      goto LABEL_31;
  }
  else if ( v8 != 1 )
  {
    goto LABEL_31;
  }
  v9 = *(_QWORD *)(v7 + 872);
  v10 = *(unsigned __int16 *)(v9 + 16);
  if ( (unsigned int)(v10 - 4096) >= 2 )
  {
    if ( v10 == 1 )
    {
      printLogD();
      v35 = &word_258D0[4 * v6];
      v37 = *((_QWORD *)v35 + 1);
      v36 = (__int64 *)(v35 + 4);
      v38 = DHfsMetaTell(v37);
      printLogD();
      v39 = *(_DWORD *)(v9 + 4);
      v40 = (v38 - v39 - 16) & ~((v38 - v39 - 16) >> 31);
      if ( (DHfsMetaSeek(*v36, (v40 & 0x7FFFFFF0u) + v39, 3) & 0x80000000) != 0
        || (v78 = v38, v41 = a3 + 49, (v42 = (char *)DHmalloc(a3 + 49)) == 0) )
      {
        v45 = -1;
      }
      else
      {
        v43 = (int8x16_t *)v42;
        v44 = DHfsMetaRead(*v36, v42, v41);
        if ( v44 > 15 )
        {
          v62 = v40 & 0xF;
          v72 = v44 - 1;
          v74 = v44;
          if ( v44 >= v41 )
            v63 = v44 - 1;
          else
            v63 = v44;
          v76 = v62;
          DHmemcpy_s((__int64)&v82, 17, (__int64)v43, 16);
          v64 = qword_25B00[v6];
          v83 = 0;
          v65 = v43;
          v66 = v43 + 1;
          DHmemcpy_s((__int64)v80, 16, v64 + 680, 16);
          AES_set_decrypt_key();
          AES_cbc_encrypt((int8x16_t *)v43[1].n128_u64, v43 + 1, v63 - 16, (__int64)v81, &v82, 0);
          v67 = v72;
          if ( v74 < v41 )
            v67 = v74 - *((unsigned __int8 *)&v66[-1] + (unsigned int)v74 - 1);
          v68 = v67 - v76 - 16;
          if ( v68 >= a3 )
            v69 = a3;
          else
            v69 = v68;
          DHmemcpy_s((__int64)a2, v69, (__int64)v66 + v76, v69);
          DHfree(v65);
          v45 = v69;
          DHfsMetaSeek(*v36, v69 + v78, 3);
          printLogD();
        }
        else
        {
          DHfree(v43);
          v45 = -1;
        }
      }
      goto LABEL_48;
    }
LABEL_31:
    printLogD();
    return 4294967288LL;
  }
  printLogD();
  v11 = &word_258D0[4 * v6];
  v12 = *(_DWORD *)(v9 + 40);
  v13 = *(_DWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 48);
  v77 = (__int64 *)(v11 + 4);
  v15 = DHfsMetaTell(*((_QWORD *)v11 + 1));
  printLogD();
  v16 = *(_DWORD *)(v9 + 8);
  v17 = *(_DWORD *)(v9 + 24);
  v18 = *(unsigned __int8 *)(v9 + 28);
  v19 = v15 - *(_DWORD *)(v9 + 4);
  if ( *(_WORD *)(v9 + 16) == 4097 )
  {
    v20 = 0;
    if ( *(_WORD *)(v9 + 18) == 1 )
    {
      v61 = v77;
      if ( v17 - v18 > v19 )
      {
        if ( v17 - v18 - v19 >= a3 )
          v21 = a3;
        else
          v21 = v17 - v18 - v19;
        v73 = v18;
        v75 = v17 - v18;
        v70 = v16;
        v71 = v17;
        v22 = DHfsMetaRead(*v77, a2, v21);
        v23 = v19 / v13;
        v81[0] = bswap32(v19 / v13);
        if ( v22 >= 1 )
        {
          v24 = v19 % v13;
          v25 = (unsigned int)v22;
          v26 = a2;
          v27 = v23 % v12;
          do
          {
            v29 = (_BYTE *)((unsigned __int64)v81 | v24 & 3);
            v30 = *(_BYTE *)(v14 + v27 + v24++);
            *v26 ^= v30 ^ *v29;
            if ( v24 >= v13 )
            {
              ++v23;
              v24 = 0;
              v31 = bswap32(v23);
              if ( v27 + 1 < v12 )
                ++v27;
              else
                v27 = 0;
              v81[0] = v31;
            }
            --v25;
            ++v26;
          }
          while ( v25 );
          v19 += v22;
        }
        v45 = v22;
        if ( v19 < v75 || (DHfsMetaSeek(*v77, v73, 1) & 0x80000000) != 0 )
          goto LABEL_48;
        v17 = v71;
        v18 = v73;
        v16 = v70;
        v20 = v45;
        v19 += v73;
      }
    }
    else
    {
      v61 = v77;
    }
  }
  else
  {
    v61 = v77;
    v20 = 0;
  }
  v47 = v19 - v17;
  v48 = v20;
  v49 = &a2[v20];
  v50 = v18 - v17 + v16;
  if ( (int)(v47 + a3 - v20) >= v50 )
    v51 = v50 - v47;
  else
    v51 = a3 - v20;
  v52 = DHfsMetaRead(*v61, v49, v51);
  v53 = v47 / v13;
  v81[0] = bswap32(v47 / v13);
  if ( v52 < 1 )
  {
    v55 = 0;
  }
  else
  {
    v54 = v47 % v13;
    v55 = v52;
    v56 = (unsigned int)v52;
    v57 = v53 % v12;
    do
    {
      v58 = (_BYTE *)((unsigned __int64)v81 | v54 & 3);
      v59 = *(_BYTE *)(v14 + v57 + v54++);
      *v49 ^= v59 ^ *v58;
      if ( v54 >= v13 )
      {
        ++v53;
        v54 = 0;
        v60 = bswap32(v53);
        if ( v57 + 1 < v12 )
          ++v57;
        else
          v57 = 0;
        v81[0] = v60;
      }
      --v56;
      ++v49;
    }
    while ( v56 );
  }
  printLogD();
  v45 = v55 + v48;
LABEL_48:
  printLogD();
  printLogD();
  return v45;
}
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000D834) ----------------------------------------------------
__int64 __fastcall sub_D834(unsigned __int16 a1, int **a2)
{
  int v4; // w21
  __int64 v5; // x27
  __int16 ClientID; // w0
  unsigned int v8; // w19
  __int64 v9; // x8
  __int16 v10; // w22
  __int64 v11; // x8
  unsigned int v12; // w0
  int32x2_t *v13; // x0
  int32x2_t *v14; // x22
  int32x2_t *v15; // x21
  int32x2_t *v16; // x8
  int32x2_t *v17; // x27
  unsigned __int64 v18; // x28
  _BYTE *v19; // x0
  __int16 v20; // w8
  _BYTE *v21; // x0
  _BYTE *v22; // x0
  __int16 v23; // w0
  __int64 v24; // x8
  unsigned int v25; // w0
  __int64 v26; // x8
  __int16 v27; // w20
  _BYTE *v28; // x0
  int v29; // w20
  int *v30; // x0
  int *v31; // x22
  unsigned __int32 v32; // w9
  unsigned __int32 v33; // w10
  unsigned __int32 v34; // w8
  __int64 v35; // x2
  const char *v36; // x0
  unsigned __int32 v37; // w8
  __int16 v38; // w9
  __int64 v39; // x22
  __int64 i; // x8
  __int64 v41; // x27
  int v42; // w9
  unsigned __int8 *v43; // x22
  int v44; // w8
  __int64 *v45; // x27
  int j; // w8
  __int64 *v47; // x27
  int v48; // w8
  unsigned __int8 *v49; // x22
  int v50; // t1
  int v51; // t1
  unsigned __int32 v52; // w0
  int v53; // w8
  __int16 SSEBaseStream; // w0
  __int16 *v55; // x26
  unsigned int v56; // w22
  __int64 *v57; // x26
  __int64 v58; // t1
  unsigned int v59; // w8
  unsigned int v60; // w10
  unsigned __int8 v61; // w9
  const char *v62; // x0
  unsigned int v63; // w19
  int32x2_t *v64; // [xsp+0h] [xbp-70h]
  int32x2_t *v65; // [xsp+8h] [xbp-68h]
  unsigned int v66; // [xsp+14h] [xbp-5Ch] BYREF
  char ptr[4]; // [xsp+18h] [xbp-58h] BYREF
  unsigned int v68; // [xsp+1Ch] [xbp-54h] BYREF
  _BYTE v69[51]; // [xsp+20h] [xbp-50h] BYREF
  __int64 v70; // [xsp+58h] [xbp-18h] BYREF
  __int16 v71; // [xsp+60h] [xbp-10h]
  __int64 v72; // [xsp+68h] [xbp-8h]

  v4 = a1;
  v72 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v68 = 0;
  v71 = 0;
  v70 = 0;
  memset(v69, 0, sizeof(v69));
  printLogD();
  if ( !v4 )
  {
    printLogD();
    return 65533;
  }
  printLogD();
  if ( (~(unsigned __int16)word_258D0[(__int16)a1 + 204] & 3) != 0 )
    return 65511;
  printLogD();
  v5 = qword_25B00[(__int16)a1];
  if ( *(_DWORD *)(v5 + 864) )
  {
    printLogD();
    return *(unsigned int *)(v5 + 864);
  }
  if ( *(_DWORD *)(v5 + 860) != 1
    && (unsigned __int16)checkDomain(
                           *(_BYTE **)(v5 + 840),
                           *(_QWORD *)(v5 + 848),
                           *(char **)(*(_QWORD *)(v5 + 528) + 24LL)) != 1 )
  {
    printLogD();
    return 65502;
  }
  v66 = 51;
  ClientID = GetClientID(a1, (__int64)v69, &v66);
  if ( ClientID )
  {
    if ( ClientID < 0 )
    {
      v8 = ClientID;
LABEL_49:
      printLogD();
      return v8;
    }
  }
  else
  {
    printLogD();
    v9 = *(_QWORD *)(qword_25B00[(__int16)a1] + 528LL);
    v10 = compute_eTarget(*(const char **)(v9 + 128), v69, *(_BYTE **)(v9 + 136), *(const char **)(v9 + 24));
    printLogD();
    if ( v10 < 0 )
    {
      printLogD();
      return (unsigned int)v10;
    }
  }
  v11 = *(_QWORD *)(v5 + 528);
  if ( *(_DWORD *)(v11 + 184) )
  {
    if ( *(_DWORD *)(v11 + 216) != 1 )
    {
      v12 = sub_EC2C(a1);
      if ( (_WORD)v12 )
      {
        v8 = v12;
        goto LABEL_49;
      }
    }
  }
  v13 = (int32x2_t *)DHmalloc(56);
  if ( !v13 )
  {
LABEL_22:
    printLogD();
    return 65514;
  }
  v13->n64_u64[0] = 0;
  v13[1].n64_u64[0] = 0;
  v13[4].n64_u64[0] = 0;
  v14 = v13 + 4;
  v15 = v13;
  v13[2].n64_u32[0] = 0;
  v13[5].n64_u64[0] = 0;
  v13[6].n64_u64[0] = 0;
  v16 = (int32x2_t *)qword_25B00[(__int16)a1];
  v13[3].n64_u32[0] = 0;
  v17 = v13 + 3;
  v13[3].n64_u8[4] = 0;
  v18 = v16[66].n64_u64[0];
  v13->n64_u32[1] = v16[75].n64_u32[0];
  v19 = *(_BYTE **)(v18 + 72);
  v15[1].n64_u64[0] = vrev64_s32(v16[77]).n64_u64[0];
  v20 = v19 && !(unsigned int)DHstrnicmp(v19, "RFC2630", 7);
  v21 = *(_BYTE **)(v18 + 64);
  v15[2].n64_u16[1] = v20;
  if ( !v21 )
  {
    v15[2].n64_u16[0] = 0;
    goto LABEL_33;
  }
  if ( !(unsigned int)DHstrnicmp(v21, "aes128cbc", 9) )
  {
    v15[2].n64_u16[0] = 1;
    v23 = sub_F2A0(a1);
    if ( v23 < 0 )
    {
      v8 = v23;
      v15[2].n64_u16[0] = 0;
      sub_F418(v15);
      goto LABEL_49;
    }
    goto LABEL_33;
  }
  v22 = *(_BYTE **)(v18 + 64);
  if ( !v22 || (unsigned int)DHstrnicmp(v22, "sse", 3) )
  {
    v15[2].n64_u16[0] = 0;
    sub_F418(v15);
LABEL_30:
    printLogD();
    return 65504;
  }
  v36 = *(const char **)(v18 + 64);
  if ( !v36 )
    goto LABEL_62;
  if ( !DHstristr(v36, "Combined") )
  {
    v62 = *(const char **)(v18 + 64);
    if ( v62 && DHstristr(v62, "Separate") )
    {
      v37 = *(_DWORD *)(v18 + 84);
      v65 = v14;
      v38 = 4097;
      goto LABEL_44;
    }
LABEL_62:
    sub_F418(v15);
    goto LABEL_30;
  }
  v37 = 0;
  v38 = 4096;
  v65 = v14;
LABEL_44:
  v39 = *(_QWORD *)(v18 + 64);
  v15[2].n64_u16[0] = v38;
  v64 = v17;
  v17->n64_u32[0] = v37;
  DHmemset(&v70, 0, 10);
  for ( i = 0; ; ++i )
  {
    v41 = v39 + i;
    v42 = *(unsigned __int8 *)(v39 + i + 3);
    if ( !*(_BYTE *)(v39 + i + 3) || v42 == 45 )
      break;
    *((_BYTE *)&v70 + i) = v42;
  }
  v43 = (unsigned __int8 *)(v41 + 5);
  v15[4].n64_u32[1] = DHatoi();
  v44 = *(unsigned __int8 *)(v41 + 3);
  if ( *(_BYTE *)(v41 + 3) )
  {
    do
    {
      if ( v44 == 47 )
        break;
      v44 = *(++v43 - 2);
    }
    while ( *(v43 - 2) );
  }
  v45 = &v70;
  DHmemset(&v70, 0, 10);
  for ( j = *(v43 - 1); *(v43 - 1); j = *v43++ )
  {
    if ( j == 45 )
      break;
    *(_BYTE *)v45 = j;
    v45 = (__int64 *)((char *)v45 + 1);
  }
  v47 = &v70;
  v65->n64_u32[0] = DHatoi();
  DHmemset(&v70, 0, 10);
  v50 = *v43;
  v49 = v43 + 1;
  v48 = v50;
  if ( v50 )
  {
    do
    {
      if ( v48 == 59 )
        break;
      *(_BYTE *)v47 = v48;
      v47 = (__int64 *)((char *)v47 + 1);
      v51 = *v49++;
      v48 = v51;
    }
    while ( v51 );
  }
  v52 = DHatoi();
  v53 = v15[2].n64_u16[1];
  v15[5].n64_u32[0] = v52;
  if ( v53 == 1 && v65->n64_u32[0] >= 0x100 )
    goto LABEL_62;
  SSEBaseStream = get_SSEBaseStream(
                    a1,
                    *(const char **)(v18 + 24),
                    *(_DWORD *)(v18 + 8),
                    *(const char **)(v18 + 128),
                    (__int64)v64);
  if ( SSEBaseStream < 0 )
  {
    v63 = SSEBaseStream;
    sub_F418(v15);
    printLogD();
    return v63;
  }
  if ( v15[2].n64_u16[0] != 4097 )
    goto LABEL_33;
  if ( v15[2].n64_u16[1] != 1 )
    goto LABEL_33;
  v55 = &word_258D0[4 * (__int16)a1];
  v56 = v64->n64_u32[0] - 1;
  v58 = *((_QWORD *)v55 + 1);
  v57 = (__int64 *)(v55 + 4);
  if ( (DHfsMetaSeek(v58, *(_DWORD *)(qword_25B00[(__int16)a1] + 600LL) + v56, 3) & 0x8000000000000000LL) == 0
    && (int)DHfsMetaRead(*v57, ptr, 1u) > 0 )
  {
    v59 = v15[4].n64_u32[0];
    v60 = v56 / v59 % v15[5].n64_u32[0];
    v68 = bswap32(v56 / v59);
    v61 = *(_BYTE *)(v15[6].n64_u64[0] + (int)(v60 + v56 % v59))
        ^ ptr[0]
        ^ *(_BYTE *)((unsigned __int64)&v68 | (v56 % v59) & 3LL);
    ptr[0] = v61;
    v15[3].n64_u8[4] = v61;
    if ( v59 >= v61 )
    {
LABEL_33:
      v24 = *(_QWORD *)(qword_25B00[(__int16)a1] + 528LL);
      v25 = compute_eServiceCode(
              a1,
              *(const char **)(v24 + 24),
              *(_BYTE **)(v24 + 56),
              *(const char **)(v24 + 40),
              *(const char **)(v24 + 48));
      if ( (_WORD)v25 )
      {
        v8 = v25;
        sub_F418(v15);
        goto LABEL_49;
      }
      v26 = *(_QWORD *)(qword_25B00[(__int16)a1] + 528LL);
      v27 = compute_eAuthCode(
              a1,
              *(const char **)(v26 + 200),
              *(char **)(v26 + 176),
              *(const char **)(v26 + 192),
              *(unsigned __int8 **)(v26 + 208),
              *(const char **)(v26 + 24),
              v15[2].n64_i16[0]);
      printLogD();
      if ( v27 < 0 )
      {
        sub_F418(v15);
        printLogD();
        return (unsigned int)v27;
      }
      if ( !v15[6].n64_u64[0] )
      {
        v28 = DHmalloc(1);
        v15[6].n64_u64[0] = (unsigned __int64)v28;
        if ( !v28 )
        {
LABEL_63:
          sub_F418(v15);
          goto LABEL_22;
        }
        *v28 = 0;
      }
      v29 = v15[4].n64_u32[1] + v15[4].n64_u32[0] + 57;
      v30 = (int *)DHmalloc(v29);
      if ( v30 )
      {
        v31 = v30;
        DHmemcpy_s((__int64)v30, v29, (__int64)v15, 56);
        v33 = v15[4].n64_u32[0];
        v32 = v15[4].n64_u32[1];
        v34 = v15[3].n64_u32[0];
        v35 = v15[6].n64_i64[0];
        *v31 = v29;
        v31[6] = v34;
        DHmemcpy_s((__int64)(v31 + 14), v29, v35, v32 + v33 + 1);
        *((_QWORD *)v31 + 6) = (char *)v31 + (unsigned int)v31[11] + 56;
        sub_F418(v15);
        *a2 = v31;
        printLogD();
        return 0;
      }
      goto LABEL_63;
    }
  }
  sub_F418(v15);
  printLogD();
  return 65528;
}
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000E0B0) ----------------------------------------------------
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  __int64 v6; // x22
  __int64 v7; // x8
  int v8; // w2
  __int64 v9; // x25
  int v10; // w8
  __int16 *v11; // x28
  __int64 *v12; // x28
  __int64 v13; // t1
  int v14; // w19
  int v15; // w26
  int v16; // w8
  int v17; // w27
  int v18; // w8
  int v19; // w9
  int v20; // w8
  bool v21; // cc
  int v22; // w8
  int v23; // w9
  _BOOL4 v24; // w8
  int v25; // w10
  int v26; // w8
  int v27; // w21
  __int64 v28; // x0
  int v29; // w1
  int v30; // w2
  __int16 v32; // w0
  __int64 v33; // x8
  unsigned int v34; // w19
  __int16 *v35; // x26
  __int64 *v36; // x26
  __int64 v37; // t1
  int v38; // w8
  __int64 v39; // x0
  int v40; // w1
  int v41; // w2
  __int64 v42; // x9
  int v43; // w9
  int v44; // w21
  int v45; // w20
  int v46; // w20
  int v47; // w8
  int v48; // w9
  int v49; // w20
  int v50; // w8
  int v51; // w8
  int *v52[2]; // [xsp+0h] [xbp-10h] BYREF

  v52[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v52[0] = 0;
  printLogD();
  printLogD();
  if ( (__int16)a1 <= 0 )
  {
    printLogD();
    return 4294967293LL;
  }
  printLogD();
  if ( (~(unsigned __int16)word_258D0[(unsigned __int16)a1 + 204] & 3) != 0 )
    goto LABEL_35;
  v6 = (unsigned __int16)a1;
  v7 = qword_25B00[(unsigned __int16)a1];
  v8 = *(_DWORD *)(v7 + 868);
  if ( v8 != -1 )
  {
    if ( v8 == 1 )
      goto LABEL_5;
    goto LABEL_35;
  }
  v32 = sub_D834(a1, v52);
  if ( !v32 )
  {
    v42 = qword_25B00[(unsigned __int16)a1];
    *(int **)(v42 + 872) = v52[0];
    *(_DWORD *)(v42 + 868) = 1;
    printLogD();
    DRM_Seek(a1, 0, 3);
    v7 = qword_25B00[(unsigned __int16)a1];
    if ( *(_DWORD *)(v7 + 868) == 1 )
    {
LABEL_5:
      v9 = *(_QWORD *)(v7 + 872);
      v10 = *(unsigned __int16 *)(v9 + 16);
      if ( (unsigned int)(v10 - 4096) < 2 )
      {
        v11 = &word_258D0[4 * (unsigned __int16)a1];
        v13 = *((_QWORD *)v11 + 1);
        v12 = (__int64 *)(v11 + 4);
        v14 = DHfsMetaTell(v13);
        printLogD();
        v15 = *(unsigned __int8 *)(v9 + 28);
        v16 = *(_DWORD *)(v9 + 4);
        v17 = *(_DWORD *)(v9 + 24) - v15;
        switch ( a3 )
        {
          case 3:
            v21 = v17 <= a2;
            v45 = v16 + a2;
            if ( v21 )
              v44 = *(unsigned __int8 *)(v9 + 28);
            else
              v44 = 0;
            break;
          case 2:
            v43 = *(_DWORD *)(v9 + 8);
            v44 = v16 + a2 + v43;
            if ( v43 + a2 >= v17 )
              v45 = *(unsigned __int8 *)(v9 + 28);
            else
              v45 = 0;
            break;
          case 1:
            v18 = v14 - v16;
            if ( v18 >= v17 )
              v19 = *(unsigned __int8 *)(v9 + 28);
            else
              v19 = 0;
            v20 = v18 - v19;
            v21 = v20 < v17;
            v22 = v20 + a2;
            v23 = !v21;
            v21 = v22 < v17;
            v24 = v22 < v17;
            if ( v21 )
              v25 = 1;
            else
              v25 = v23;
            if ( (v23 & v24) != 0 )
              v26 = *(unsigned __int8 *)(v9 + 28);
            else
              v26 = 0;
            if ( v25 )
              v27 = -v26;
            else
              v27 = *(unsigned __int8 *)(v9 + 28);
            printLogD();
            v28 = *v12;
            v29 = v27 + a2;
            v30 = 1;
            goto LABEL_44;
          default:
LABEL_36:
            printLogD();
            return 4294967281LL;
        }
        printLogD();
        v28 = *v12;
        v29 = v45 + v44;
        v30 = 3;
LABEL_44:
        v46 = DHfsMetaSeek(v28, v29, v30);
        printLogD();
        v47 = v46 - *(_DWORD *)(v9 + 4);
        if ( v47 >= v17 )
          v48 = v15;
        else
          v48 = 0;
        v49 = v47 - v48;
        printLogD();
        v50 = v49;
LABEL_52:
        if ( v50 > *(_DWORD *)(v9 + 8) || v50 < 0 )
        {
          DHfsMetaSeek(*(_QWORD *)&word_258D0[4 * v6 + 4], v14, 3);
          printLogD();
          v50 = -15;
        }
        v34 = v50;
        printLogD();
        return v34;
      }
      if ( v10 != 1 )
        goto LABEL_36;
      v35 = &word_258D0[4 * (unsigned __int16)a1];
      v37 = *((_QWORD *)v35 + 1);
      v36 = (__int64 *)(v35 + 4);
      v14 = DHfsMetaTell(v37);
      printLogD();
      v38 = *(_DWORD *)(v9 + 4);
      switch ( a3 )
      {
        case 3:
          v39 = *v36;
          v51 = a2 + v38;
          break;
        case 2:
          v39 = *v36;
          v51 = a2 + v38 + *(_DWORD *)(v9 + 8);
          break;
        case 1:
          v39 = *v36;
          v40 = a2;
          v41 = 1;
LABEL_51:
          v50 = DHfsMetaSeek(v39, v40, v41) - *(_DWORD *)(v9 + 4) - 16;
          goto LABEL_52;
        default:
          goto LABEL_36;
      }
      v40 = v51 + 16;
      v41 = 3;
      goto LABEL_51;
    }
LABEL_35:
    printLogD();
    return 4294967271LL;
  }
  v33 = qword_25B00[(unsigned __int16)a1];
  v34 = v32;
  *(_QWORD *)(v33 + 872) = 0;
  *(_DWORD *)(v33 + 868) = 0;
  printLogD();
  return v34;
}
// 1CD10: using guessed type __int64 __fastcall DRM_Seek(_QWORD, _QWORD, _QWORD);
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000E54C) ----------------------------------------------------
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2)
{
  __int64 v4; // x22
  _QWORD *v5; // x0
  __int64 v6; // x20
  __int64 v7; // x1
  __int16 DCFHeader; // w0
  int v9; // w9
  __int16 v10; // w8
  int v11; // w0
  __int16 v12; // w26
  int v13; // w8
  int v14; // w9
  int v15; // w22
  int v16; // w19
  int v17; // w21
  int v18; // w27
  int v19; // w26
  int v20; // w25
  int v21; // w24
  int v22; // w28
  int v23; // w23
  int v24; // w0
  int v25; // w9
  int v26; // w8
  int v27; // w22
  int v28; // w27
  int v29; // w28
  int *v30; // x0
  int *v31; // x21
  __int64 v32; // x2
  __int64 v33; // x2
  __int64 v34; // x8
  __int64 v35; // x2
  __int64 v36; // x8
  __int64 v37; // x2
  __int64 v38; // x8
  __int64 v39; // x2
  __int64 v40; // x8
  __int64 v41; // x2
  __int64 v42; // x8
  __int64 v43; // x2
  __int64 v44; // x8
  __int64 v45; // x2
  __int64 v46; // x8
  __int64 v47; // x2
  __int64 v48; // x8
  __int64 v49; // x2
  __int64 v50; // x8
  __int64 v51; // x2
  __int64 v52; // x8
  __int64 v53; // x10
  __int64 v54; // x9
  __int64 v55; // x8
  __int64 v56; // x9
  __int64 v57; // x10
  char *v58; // x8
  __int64 v59; // x9
  char *v60; // x8
  __int64 v61; // x10
  char *v62; // x8
  __int64 v63; // x9
  char *v64; // x8
  __int64 v65; // x10
  char *v66; // x8
  __int64 v67; // x9
  __int64 v69; // x8
  __int16 ClientID; // w23
  __int64 v71; // x8
  __int16 v72; // w0
  __int64 v73; // x8
  _BYTE *v74; // x0
  __int16 v75; // w22
  __int64 v76; // x8
  __int16 v77; // w21
  int v78; // [xsp+0h] [xbp-70h]
  int v79; // [xsp+8h] [xbp-68h]
  int v80; // [xsp+14h] [xbp-5Ch]
  int **v81; // [xsp+18h] [xbp-58h]
  int v82; // [xsp+28h] [xbp-48h]
  unsigned int v83; // [xsp+2Ch] [xbp-44h] BYREF
  _BYTE v84[51]; // [xsp+30h] [xbp-40h] BYREF
  __int64 v85; // [xsp+68h] [xbp-8h]

  v85 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v84, 0, sizeof(v84));
  v83 = 0;
  printLogD();
  if ( (__int16)a1 <= 0 )
  {
    printLogD();
    return 65533;
  }
  printLogD();
  if ( (~(unsigned __int16)word_258D0[a1 + 204] & 3) != 0 )
    return 65511;
  v4 = qword_25B00[a1];
  v5 = DHmalloc(224);
  if ( !v5 )
    return 65514;
  v5[1] = 0;
  v6 = (__int64)v5;
  v5[3] = 0;
  v5[5] = 0;
  v5[6] = 0;
  v5[9] = 0;
  v5[11] = 0;
  v5[13] = 0;
  v5[15] = 0;
  v5[17] = 0;
  v5[19] = 0;
  v5[23] = 0;
  v5[25] = 0;
  v5[27] = 0;
  *(_QWORD *)((char *)v5 + 172) = 0;
  *(_QWORD *)((char *)v5 + 164) = 0;
  *((_WORD *)v5 + 30) = 1;
  v81 = a2;
  v7 = *(_QWORD *)(qword_25B00[a1] + 528LL);
  *(_DWORD *)v5 = 0;
  *((_WORD *)v5 + 2) = 0;
  *((_DWORD *)v5 + 4) = 0;
  *((_DWORD *)v5 + 8) = 0;
  *((_DWORD *)v5 + 14) = 0;
  *((_DWORD *)v5 + 16) = 0;
  *((_DWORD *)v5 + 20) = 0;
  *((_DWORD *)v5 + 24) = 0;
  *((_DWORD *)v5 + 28) = 0;
  *((_DWORD *)v5 + 32) = 0;
  *((_DWORD *)v5 + 36) = 0;
  *((_WORD *)v5 + 80) = 0;
  *((_DWORD *)v5 + 48) = 0;
  *((_DWORD *)v5 + 52) = 0;
  DCFHeader = DA_DRA_GetDCFHeader((__int64)v5, v7);
  v9 = DCFHeader;
  v10 = DCFHeader;
  v11 = *(_DWORD *)(v4 + 864);
  if ( v9 >= 0 )
    v12 = 1;
  else
    v12 = v10;
  if ( !v11 )
  {
    if ( *(_DWORD *)(v4 + 860) != 1
      && (unsigned __int16)checkDomain(
                             *(_BYTE **)(v4 + 840),
                             *(_QWORD *)(v4 + 848),
                             *(char **)(*(_QWORD *)(v4 + 528) + 24LL)) != 1 )
    {
      LOWORD(v11) = -34;
      goto LABEL_8;
    }
    v69 = *(_QWORD *)(v4 + 528);
    if ( *(_DWORD *)(v69 + 184) )
    {
      if ( *(_DWORD *)(v69 + 216) != 1 )
      {
        LOWORD(v11) = sub_EC2C(a1);
        if ( (_WORD)v11 )
          goto LABEL_8;
      }
    }
    ClientID = GetClientID(a1, (__int64)v84, &v83);
    printLogD();
    printLogD();
    if ( ClientID )
    {
      LOWORD(v11) = ClientID;
      if ( ClientID < 0 )
        goto LABEL_8;
    }
    else
    {
      v71 = *(_QWORD *)(qword_25B00[a1] + 528LL);
      v72 = compute_eTarget(*(const char **)(v71 + 128), v84, *(_BYTE **)(v71 + 136), *(const char **)(v71 + 24));
      if ( v72 < 0 )
      {
        v77 = v72;
        printLogD();
        LOWORD(v11) = v77;
        goto LABEL_8;
      }
    }
    v73 = *(_QWORD *)(qword_25B00[a1] + 528LL);
    v74 = *(_BYTE **)(v73 + 64);
    if ( v74 )
    {
      v75 = ((unsigned int)DHstrnicmp(v74, "sse", 3) == 0) << 12;
      v73 = *(_QWORD *)(qword_25B00[a1] + 528LL);
    }
    else
    {
      v75 = 0;
    }
    LOWORD(v11) = compute_eServiceCode(
                    a1,
                    *(const char **)(v73 + 24),
                    *(_BYTE **)(v73 + 56),
                    *(const char **)(v73 + 40),
                    *(const char **)(v73 + 48));
    if ( !(_WORD)v11 )
    {
      v76 = *(_QWORD *)(qword_25B00[a1] + 528LL);
      LOWORD(v11) = compute_eAuthCode(
                      a1,
                      *(const char **)(v76 + 200),
                      *(char **)(v76 + 176),
                      *(const char **)(v76 + 192),
                      *(unsigned __int8 **)(v76 + 208),
                      *(const char **)(v76 + 24),
                      v75);
      if ( (v11 & 0x8000u) == 0 )
        LOWORD(v11) = v12;
    }
  }
LABEL_8:
  v13 = *(_DWORD *)(v6 + 8);
  v14 = *(_DWORD *)(v6 + 12);
  *(_WORD *)(v6 + 60) = v11;
  v82 = v13;
  v15 = v14 + 1;
  v16 = DHstrlen(*(const char **)(v6 + 72)) + 1;
  v17 = DHstrlen(*(const char **)(v6 + 88)) + 1;
  v18 = DHstrlen(*(const char **)(v6 + 104)) + 1;
  v19 = DHstrlen(*(const char **)(v6 + 120)) + 1;
  v20 = DHstrlen(*(const char **)(v6 + 136)) + 1;
  v21 = DHstrlen(*(const char **)(v6 + 152)) + 1;
  v22 = DHstrlen(*(const char **)(v6 + 184)) + 1;
  v23 = DHstrlen(*(const char **)(v6 + 200)) + 1;
  v24 = DHstrlen(*(const char **)(v6 + 216));
  v25 = v17 + v18;
  v78 = v15;
  v26 = v82 + v15;
  v27 = v24 + 1;
  v80 = v22;
  v79 = v18;
  v28 = v17;
  v29 = v26 + v16 + v25 + v19 + v20 + v21 + v22 + v23 + v24 + 1 + 225;
  v30 = (int *)DHmalloc(v29);
  if ( v30 )
  {
    v31 = v30;
    DHmemcpy_s((__int64)v30, v29, v6, 224);
    *v31 = v29;
    printLogD();
    v32 = *(_QWORD *)(v6 + 24);
    v31[4] = 0;
    DHmemcpy_s((__int64)(v31 + 56), v29, v32, v82 + 1);
    v33 = *(_QWORD *)(v6 + 40);
    v34 = (unsigned int)(v31[4] + v82 + 1);
    v31[8] = v34;
    DHmemcpy_s((__int64)v31 + v34 + 224, v29, v33, v78);
    v35 = *(_QWORD *)(v6 + 72);
    v36 = (unsigned int)(v31[8] + v78);
    v31[16] = v36;
    DHmemcpy_s((__int64)v31 + v36 + 224, v29, v35, v16);
    v37 = *(_QWORD *)(v6 + 88);
    v38 = (unsigned int)(v31[16] + v16);
    v31[20] = v38;
    DHmemcpy_s((__int64)v31 + v38 + 224, v29, v37, v28);
    v39 = *(_QWORD *)(v6 + 104);
    v40 = (unsigned int)(v31[20] + v28);
    v31[24] = v40;
    DHmemcpy_s((__int64)v31 + v40 + 224, v29, v39, v79);
    v41 = *(_QWORD *)(v6 + 120);
    v42 = (unsigned int)(v31[24] + v79);
    v31[28] = v42;
    DHmemcpy_s((__int64)v31 + v42 + 224, v29, v41, v19);
    v43 = *(_QWORD *)(v6 + 136);
    v44 = (unsigned int)(v31[28] + v19);
    v31[32] = v44;
    DHmemcpy_s((__int64)v31 + v44 + 224, v29, v43, v20);
    v45 = *(_QWORD *)(v6 + 152);
    v46 = (unsigned int)(v31[32] + v20);
    v31[36] = v46;
    DHmemcpy_s((__int64)v31 + v46 + 224, v29, v45, v21);
    v47 = *(_QWORD *)(v6 + 184);
    v48 = (unsigned int)(v31[36] + v21);
    v31[44] = v48;
    DHmemcpy_s((__int64)v31 + v48 + 224, v29, v47, v80);
    v49 = *(_QWORD *)(v6 + 200);
    v50 = (unsigned int)(v31[44] + v80);
    v31[48] = v50;
    DHmemcpy_s((__int64)v31 + v50 + 224, v29, v49, v23);
    v51 = *(_QWORD *)(v6 + 216);
    v52 = (unsigned int)(v31[48] + v23);
    v31[52] = v52;
    DHmemcpy_s((__int64)v31 + v52 + 224, v29, v51, v27);
    v53 = (unsigned int)v31[16];
    v54 = (__int64)v31 + (unsigned int)v31[8] + 224;
    *((_QWORD *)v31 + 3) = (char *)v31 + (unsigned int)v31[4] + 224;
    v55 = (unsigned int)v31[20];
    *((_QWORD *)v31 + 5) = v54;
    v56 = (unsigned int)v31[24];
    *((_QWORD *)v31 + 9) = (char *)v31 + v53 + 224;
    v57 = (unsigned int)v31[28];
    *((_QWORD *)v31 + 11) = (char *)v31 + v55 + 224;
    v58 = (char *)v31 + v56 + 224;
    v59 = (unsigned int)v31[32];
    *((_QWORD *)v31 + 13) = v58;
    v60 = (char *)v31 + v57 + 224;
    v61 = (unsigned int)v31[36];
    *((_QWORD *)v31 + 15) = v60;
    v62 = (char *)v31 + v59 + 224;
    v63 = (unsigned int)v31[44];
    *((_QWORD *)v31 + 17) = v62;
    v64 = (char *)v31 + v61 + 224;
    v65 = (unsigned int)v31[48];
    *((_QWORD *)v31 + 19) = v64;
    v66 = (char *)v31 + v63 + 224;
    v67 = (unsigned int)v31[52];
    *((_QWORD *)v31 + 23) = v66;
    *((_QWORD *)v31 + 25) = (char *)v31 + v65 + 224;
    *((_QWORD *)v31 + 27) = (char *)v31 + v67 + 224;
    sub_EF50((_QWORD *)v6);
    *v81 = v31;
    printLogD();
    printLogD();
    return 0;
  }
  else
  {
    sub_EF50((_QWORD *)v6);
    return 65514;
  }
}
// 258D0: using guessed type __int16 word_258D0[];
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000EC2C) ----------------------------------------------------
__int64 __fastcall sub_EC2C(unsigned __int16 a1)
{
  __int64 v1; // x20
  int v2; // w19
  unsigned int v4; // w0
  __int64 v5; // x8
  __int64 v6; // x9
  unsigned int v7; // w8

  if ( (__int16)a1 <= 0 )
  {
    printLogD();
    return 65533;
  }
  v1 = a1;
  if ( *(_DWORD *)(qword_25B00[a1] + 860LL) == 1 )
  {
    v2 = 0;
  }
  else
  {
    v2 = DHAuthTime();
    if ( !v2 )
      return 65431;
  }
  v4 = DHcurrentTime();
  if ( !v4 )
    return 65433;
  v5 = qword_25B00[v1];
  if ( *(_DWORD *)(v5 + 860) != 1 && v4 - v2 >= *(_DWORD *)(v5 + 856) )
    return 65430;
  v6 = *(_QWORD *)(v5 + 528);
  v7 = *(_DWORD *)(v6 + 184);
  if ( !v7 || *(_DWORD *)(v6 + 216) == 1 )
    return 0;
  if ( v4 <= v7 )
    return 0;
  return 4294967195LL;
}
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000ED10) ----------------------------------------------------
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3)
{
  __int64 v6; // x26
  unsigned int v7; // w21
  int v8; // w0
  int v9; // w19
  __int64 result; // x0
  int v11; // w0
  __int64 v12; // x21
  int v13; // w22
  unsigned int v14; // w22

  printLogD();
  v6 = qword_25B00[a1];
  if ( *(_DWORD *)(v6 + 832) )
  {
    if ( *(_BYTE *)(v6 + 536) )
    {
      v7 = DHstrlen((const char *)(v6 + 536));
      v8 = DHstrncpy_s(a2, 50, v6 + 536, v7);
      if ( v8 )
      {
LABEL_4:
        v9 = v8;
        strerror(v8);
        printLogD();
        return StrErrorReturn(v9);
      }
      *a3 = v7;
      printLogD();
      return 0;
    }
    else
    {
      return 65436;
    }
  }
  else
  {
    v11 = DHstrlen(*(const char **)(*(_QWORD *)(v6 + 528) + 128LL));
    v12 = *(_QWORD *)(v6 + 824);
    if ( v12 )
    {
      v13 = v11;
      while ( 1 )
      {
        if ( !(unsigned int)DHstrnicmp(*(_BYTE **)(*(_QWORD *)(v6 + 528) + 128LL), (_BYTE *)v12, v13) )
        {
          printLogD();
          printLogD();
          result = compute_eTarget(
                     *(const char **)(*(_QWORD *)(v6 + 528) + 128LL),
                     (const char *)(v12 + 16),
                     *(_BYTE **)(*(_QWORD *)(v6 + 528) + 136LL),
                     *(const char **)(*(_QWORD *)(v6 + 528) + 24LL));
          if ( (unsigned __int16)result != 65434 )
            break;
        }
        v12 = *(_QWORD *)(v12 + 72);
        if ( !v12 )
          goto LABEL_14;
      }
      if ( !(_WORD)result )
      {
        v14 = DHstrlen((const char *)(v12 + 16));
        v8 = DHstrncpy_s(a2, 50, v12 + 16, v14);
        if ( v8 )
          goto LABEL_4;
        *a3 = v14;
        v8 = DHstrncpy_s(v6 + 536, 50, v12 + 16, v14);
        if ( v8 )
          goto LABEL_4;
        result = 1;
        *(_DWORD *)(v6 + 832) = 1;
      }
    }
    else
    {
LABEL_14:
      printLogD();
      return 65434;
    }
  }
  return result;
}
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000EF50) ----------------------------------------------------
void __fastcall sub_EF50(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0

  printLogD();
  v2 = (void *)a1[3];
  if ( v2 )
    DHfree(v2);
  v3 = (void *)a1[5];
  if ( v3 )
    DHfree(v3);
  v4 = (void *)a1[9];
  if ( v4 )
    DHfree(v4);
  v5 = (void *)a1[11];
  if ( v5 )
    DHfree(v5);
  v6 = (void *)a1[13];
  if ( v6 )
    DHfree(v6);
  v7 = (void *)a1[15];
  if ( v7 )
    DHfree(v7);
  v8 = (void *)a1[17];
  if ( v8 )
    DHfree(v8);
  v9 = (void *)a1[19];
  if ( v9 )
    DHfree(v9);
  v10 = (void *)a1[23];
  if ( v10 )
    DHfree(v10);
  v11 = (void *)a1[25];
  if ( v11 )
    DHfree(v11);
  v12 = (void *)a1[27];
  if ( v12 )
    DHfree(v12);
  DHfree(a1);
  printLogD();
}

//----- (000000000000F01C) ----------------------------------------------------
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3)
{
  __int64 v6; // x21
  int v8; // w0
  unsigned int v9; // w3
  int v10; // w0
  int v11; // w19

  printLogD();
  if ( a2 )
  {
    printLogD();
    printLogD();
    v6 = *(_QWORD *)(*(_QWORD *)(qword_25B00[a1] + 528LL) + 248LL);
    if ( v6 )
    {
      while ( 1 )
      {
        printLogD();
        if ( !(unsigned int)DHstrnicmp((_BYTE *)v6, a2, 20) )
          break;
        v6 = *(_QWORD *)(v6 + 640);
        if ( !v6 )
          goto LABEL_5;
      }
      v8 = DHstrlen((const char *)(v6 + 128));
      if ( v8 >= 255 )
        v9 = 255;
      else
        v9 = v8;
      v10 = DHstrncpy_s((__int64)a3, 256, v6 + 128, v9);
      if ( v10 )
      {
        v11 = v10;
        strerror(v10);
        printLogD();
        return StrErrorReturn(v11);
      }
      else
      {
        printLogD();
        printLogD();
        return 0;
      }
    }
    else
    {
LABEL_5:
      *a3 = 0;
      printLogD();
      printLogD();
      return 65500;
    }
  }
  else
  {
    printLogD();
    return 65501;
  }
}
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000F1F0) ----------------------------------------------------
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  const char *v2; // x19

  printLogD();
  if ( !*(_QWORD *)(*(_QWORD *)(qword_25B00[a1] + 528LL) + 224LL) )
    return 65500;
  printLogD();
  v2 = *(const char **)(*(_QWORD *)(qword_25B00[a1] + 528LL) + 224LL);
  if ( strstr(v2, "KS_C_5601") )
    return 0;
  if ( !strcmp(v2, "UTF-8") )
    return 3;
  return 4294967260LL;
}
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000F2A0) ----------------------------------------------------
__int64 __fastcall sub_F2A0(__int16 a1)
{
  __int64 v1; // x20
  __int64 v2; // x8
  __int16 v3; // w0
  __int64 v4; // x8
  __int64 v5; // x9
  _BYTE *v6; // x10
  unsigned __int8 *v7; // x10
  unsigned int v8; // w13
  unsigned int v9; // w12
  _QWORD v11[4]; // [xsp+4h] [xbp-13Ch] BYREF
  _BYTE v12[244]; // [xsp+24h] [xbp-11Ch] BYREF
  __int128 v13; // [xsp+118h] [xbp-28h] BYREF
  _BYTE v14[16]; // [xsp+128h] [xbp-18h] BYREF
  __int64 v15; // [xsp+138h] [xbp-8h]

  v1 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = *(_QWORD *)(qword_25B00[a1] + 528LL);
  v3 = compute_SSKey(a1, *(const char **)(v2 + 152), *(const char **)(v2 + 24), (__int64)v14, 16);
  if ( v3 < 0 )
    return (unsigned int)v3;
  DHmemset(&v13, 0, 16);
  AES_set_decrypt_key();
  v4 = qword_25B00[v1];
  v5 = 0;
  v6 = *(_BYTE **)(*(_QWORD *)(v4 + 528) + 168LL);
  if ( *v6 == 34 )
    ++v6;
  v7 = v6 + 1;
  do
  {
    v9 = *(v7 - 1);
    if ( v9 - 65 > 5 )
    {
      if ( v9 - 97 > 5 )
      {
        v9 -= 48;
        if ( v9 > 9 )
          return 65513;
      }
      else
      {
        LOBYTE(v9) = v9 - 87;
      }
    }
    else
    {
      LOBYTE(v9) = v9 - 55;
    }
    v8 = *v7;
    if ( v8 - 65 <= 5 )
    {
      LOBYTE(v8) = v8 - 55;
    }
    else if ( v8 - 97 > 5 )
    {
      v8 -= 48;
      if ( v8 > 9 )
        return 65513;
    }
    else
    {
      LOBYTE(v8) = v8 - 87;
    }
    v7 += 2;
    *((_BYTE *)v11 + v5++) = v8 | (16 * v9);
  }
  while ( v5 != 32 );
  AES_cbc_encrypt(v11, (int8x16_t *)(v4 + 680), 0x10u, (__int64)v12, &v13, 0);
  return 0;
}
// 25B00: using guessed type _QWORD qword_25B00[1];

//----- (000000000000F418) ----------------------------------------------------
void __fastcall sub_F418(_QWORD *a1)
{
  void *v2; // x0

  printLogD();
  v2 = (void *)a1[6];
  if ( v2 )
    DHfree(v2);
  DHfree(a1);
  printLogD();
}

//----- (000000000000F46C) ----------------------------------------------------
__int64 __fastcall DA_DRA_DCFParser(__int64 a1, __int64 a2, int *a3)
{
  unsigned int v6; // w20
  int v7; // w3
  int v8; // w4
  void *v9; // x0
  int v10; // w8
  void *v12; // x0
  int v13; // w8
  int v14; // w21
  int v15; // w8
  int v16; // w21
  int v17; // w3
  signed int v18; // w22
  char *v19; // x0
  char *v20; // x21
  int v21; // w24
  char *v22; // x13
  signed int v23; // w9
  char *v24; // x8
  signed int v25; // w23
  int v26; // w10
  __int64 v27; // x9
  char *v28; // x8
  int v29; // w8
  __int64 v30; // x12
  char *v31; // x8
  char *v32; // x11
  __int64 v33; // x21
  int v34; // w10
  unsigned __int8 *v35; // x13
  unsigned __int8 *v36; // x9
  int v37; // w11
  int v38; // t1
  int v39; // w26
  int v40; // w24
  void *v41; // x0
  int v42; // w24
  void *v43; // x0
  int v44; // w23
  char *v45; // x10
  int v46; // w9
  __int64 v47; // x8
  char *v48; // x9
  int v49; // w11
  unsigned __int8 *v50; // x10
  int v51; // w12
  int v52; // t1
  int v53; // w26
  int v54; // w21
  int v55; // w24
  void *v56; // x0
  int v57; // w24
  void *v58; // x0
  int v59; // w23
  char *v60; // x10
  int v61; // w9
  __int64 v62; // x8
  char *v63; // x9
  int v64; // w11
  unsigned __int8 *v65; // x10
  int v66; // w12
  int v67; // t1
  int v68; // w24
  int v69; // w26
  int v70; // w21
  void *v71; // x0
  int v72; // w21
  void *v73; // x0
  int v74; // w24
  void *v75; // x0
  int v76; // w24
  void *v77; // x0
  int v78; // w24
  void *v79; // x0
  int v80; // w24
  void *v81; // x0
  int v82; // w21
  void *v83; // x0
  __int64 v84; // x24
  int i; // w8
  int v86; // w21
  void *v87; // x0
  int v88; // w21
  void *v89; // x0
  int v90; // w24
  void *v91; // x0
  int v92; // w21
  char *v93; // x10
  int v94; // w9
  __int64 v95; // x8
  char *v96; // x9
  int v97; // w11
  unsigned __int8 *v98; // x10
  int v99; // w12
  int v100; // t1
  int v101; // w26
  int v102; // w23
  int v103; // w24
  void *v104; // x0
  __int64 v105; // x0
  int v106; // w24
  void *v107; // x0
  void *v108; // x0
  int v109; // w21
  char *v110; // x10
  int v111; // w9
  __int64 v112; // x8
  char *v113; // x9
  int v114; // w11
  unsigned __int8 *v115; // x10
  int v116; // w12
  int v117; // t1
  int v118; // w26
  __int64 v119; // x21
  void *v120; // x0
  __int64 v121; // x21
  int v122; // w0
  __int64 v123; // x23
  __int64 v124; // x8
  __int64 v125; // x9
  int v126; // w24
  void *v127; // x0
  int v128; // w0
  int v129; // w24
  char *v130; // x0
  const char *v131; // x21
  const char *v132; // x0
  const char *v133; // x24
  void *v134; // x0
  char *v135; // x0
  __int64 v136; // x24
  int v137; // w21
  __int64 v138; // x21
  unsigned __int64 v139; // x21
  __int64 v140; // x21
  unsigned __int16 v141; // w24
  __int64 v142; // x24
  unsigned __int64 v143; // x21
  const char *v144; // x0
  const char *v145; // x24
  void *v146; // x0
  char *v147; // x0
  char *v148; // x10
  int v149; // w9
  __int64 v150; // x8
  char *v151; // x9
  int v152; // w11
  unsigned __int8 *v153; // x10
  int v154; // w12
  int v155; // t1
  int v156; // w26
  int v157; // w23
  int v158; // w24
  void *v159; // x0
  int v160; // w24
  void *v161; // x0
  __int64 v162; // x23
  int v163; // w22
  int v164; // w24
  int v165; // w0
  void *v166; // x0
  const char **v167; // x21
  const char *v168; // x23
  char *v169; // x24
  __int64 v170; // x21
  int v171; // w0
  char *v172; // x24
  int v173; // w0
  char *v174; // x24
  int v175; // w0
  char *v176; // x24
  int v177; // w0
  char *v178; // x24
  int v179; // w0
  void *v180; // x0
  char *v181; // x24
  int v182; // w0
  _BYTE *v183; // x0
  int v184; // w8
  int v185; // w24
  unsigned __int64 v186; // [xsp+0h] [xbp-C80h]
  int v187; // [xsp+8h] [xbp-C78h]
  unsigned __int64 v188; // [xsp+8h] [xbp-C78h]
  int v189; // [xsp+10h] [xbp-C70h]
  char *v190; // [xsp+10h] [xbp-C70h]
  int v191; // [xsp+10h] [xbp-C70h]
  __int64 *v192; // [xsp+18h] [xbp-C68h]
  __int64 *v193; // [xsp+20h] [xbp-C60h]
  __int64 *v194; // [xsp+28h] [xbp-C58h]
  __int64 *v195; // [xsp+30h] [xbp-C50h]
  __int64 *v196; // [xsp+38h] [xbp-C48h]
  char *v197; // [xsp+40h] [xbp-C40h]
  unsigned __int8 *v198; // [xsp+50h] [xbp-C30h]
  int v199; // [xsp+5Ch] [xbp-C24h] BYREF
  int v200; // [xsp+60h] [xbp-C20h] BYREF
  char ptr[514]; // [xsp+64h] [xbp-C1Ch] BYREF
  _BYTE v202[10]; // [xsp+266h] [xbp-A1Ah] BYREF
  _BYTE v203[256]; // [xsp+270h] [xbp-A10h] BYREF
  _BYTE v204[256]; // [xsp+370h] [xbp-910h] BYREF
  char v205[2048]; // [xsp+470h] [xbp-810h] BYREF
  __int64 v206; // [xsp+C70h] [xbp-10h]

  v206 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  DHmemset(ptr, 0, 512);
  if ( (int)DHfsMetaRead(a1, ptr, 3u) < 3 )
  {
    v6 = 65523;
    goto LABEL_7;
  }
  v7 = (unsigned __int8)ptr[1];
  v8 = (unsigned __int8)ptr[2];
  *(_WORD *)a2 = (unsigned __int8)ptr[0];
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  printLogD();
  if ( *(_WORD *)a2 != 1 )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  v9 = DHmalloc(*(_DWORD *)(a2 + 4) + 1);
  v10 = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a2 + 16) = v9;
  DHmemset(v9, 0, v10 + 1);
  if ( (int)DHfsMetaRead(a1, *(char **)(a2 + 16), *(_DWORD *)(a2 + 4)) < *(_DWORD *)(a2 + 4) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v12 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  v13 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 24) = v12;
  DHmemset(v12, 0, v13 + 1);
  if ( (int)DHfsMetaRead(a1, *(char **)(a2 + 24), *(_DWORD *)(a2 + 8)) < *(_DWORD *)(a2 + 8) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v14 = 0;
  while ( (int)DHfsMetaRead(a1, v205, 1u) >= 1 )
  {
    v15 = v205[0] & 0x7F | (v14 << 7);
    v14 = v15;
    if ( (v205[0] & 0x80) == 0 )
      goto LABEL_15;
  }
  v15 = -1;
LABEL_15:
  v16 = 0;
  *(_DWORD *)(a2 + 32) = v15;
  while ( (int)DHfsMetaRead(a1, v205, 1u) >= 1 )
  {
    v17 = v205[0] & 0x7F | (v16 << 7);
    v16 = v17;
    if ( (v205[0] & 0x80) == 0 )
      goto LABEL_20;
  }
  v17 = -1;
LABEL_20:
  *(_DWORD *)(a2 + 36) = v17;
  printLogD();
  v18 = *(_DWORD *)(a2 + 32);
  if ( !v18 )
  {
    *a3 = 0;
    v6 = 65528;
    goto LABEL_7;
  }
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 68) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  v196 = (__int64 *)(a2 + 88);
  *(_QWORD *)(a2 + 192) = 0;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_QWORD *)(a2 + 200) = 0;
  *(_QWORD *)(a2 + 208) = 0;
  *(_DWORD *)(a2 + 216) = 0;
  *(_OWORD *)(a2 + 240) = 0u;
  printLogD();
  v19 = (char *)DHmalloc(v18 + 1);
  if ( !v19 )
    goto LABEL_234;
  v20 = v19;
  v192 = (__int64 *)(a2 + 192);
  v193 = (__int64 *)(a2 + 224);
  v194 = (__int64 *)(a2 + 40);
  v195 = (__int64 *)(a2 + 248);
  v21 = DHfsMetaRead(a1, v19, v18);
  printLogD();
  printLogD();
  v197 = v20;
  v20[v21] = 0;
  if ( v18 < 1 )
  {
LABEL_227:
    if ( *v195 )
    {
      printLogD();
      v162 = *v195;
      if ( *v195 )
      {
        v163 = 1;
        do
        {
          v164 = DHstrlen((const char *)v162);
          v165 = DHstrlen((const char *)(v162 + 128));
          v162 = *(_QWORD *)(v162 + 640);
          v163 += v164 + v165 + 2;
        }
        while ( v162 );
      }
      else
      {
        v163 = 1;
      }
      v166 = DHmalloc(v163);
      *(_QWORD *)(a2 + 240) = v166;
      if ( !v166 )
      {
        DHfree(v197);
        goto LABEL_234;
      }
      DHmemset(v166, 0, v163);
      v167 = (const char **)(a2 + 248);
      while ( 1 )
      {
        v168 = *v167;
        v169 = *(char **)(a2 + 240);
        v170 = *((_QWORD *)*v167 + 80);
        v171 = DHstrlen(v168);
        v185 = DHstrncat_s(v169, v163, (__int64)v168, v171);
        if ( !v170 )
          break;
        if ( v185 )
          goto LABEL_268;
        v172 = *(char **)(a2 + 240);
        v173 = DHstrlen("=");
        v122 = DHstrncat_s(v172, v163, (__int64)"=", v173);
        if ( !v122 )
        {
          v174 = *(char **)(a2 + 240);
          v175 = DHstrlen(v168 + 128);
          v122 = DHstrncat_s(v174, v163, (__int64)(v168 + 128), v175);
          if ( !v122 )
          {
            v176 = *(char **)(a2 + 240);
            v167 = (const char **)(v168 + 640);
            v177 = DHstrlen(";");
            v122 = DHstrncat_s(v176, v163, (__int64)";", v177);
            if ( !v122 )
              continue;
          }
        }
        goto LABEL_188;
      }
      if ( v185 )
        goto LABEL_268;
      v178 = *(char **)(a2 + 240);
      v179 = DHstrlen("=");
      v122 = DHstrncat_s(v178, v163, (__int64)"=", v179);
      if ( v122 )
        goto LABEL_188;
      v181 = *(char **)(a2 + 240);
      v182 = DHstrlen(v168 + 128);
      v122 = DHstrncat_s(v181, v163, (__int64)(v168 + 128), v182);
      if ( v122 )
        goto LABEL_188;
    }
    printLogD();
    DHfree(v197);
    if ( *(_QWORD *)(a2 + 128) )
    {
      printLogD();
      goto LABEL_270;
    }
    goto LABEL_233;
  }
  v22 = v20;
LABEL_27:
  v23 = 0;
  v24 = v22;
  while ( 1 )
  {
    v26 = (unsigned __int8)*v24;
    if ( v26 == 13 )
      break;
    ++v24;
LABEL_29:
    v25 = v23 + 1;
    v205[v23] = v26;
    v23 = v25;
    if ( v18 <= v25 )
      goto LABEL_33;
  }
  v205[v23] = 13;
  v25 = v23 + 1;
  v26 = (unsigned __int8)v24[1];
  if ( v26 != 10 )
  {
    v24 += 2;
    ++v23;
    goto LABEL_29;
  }
LABEL_33:
  v27 = v25;
  v28 = &v205[v25];
  if ( v18 <= v25 )
  {
    *v28 = 0;
  }
  else
  {
    ++v25;
    *(v28 - 1) = 0;
    v27 = v25;
  }
  v29 = (unsigned __int8)v205[0];
  v199 = 0;
  if ( v205[0] == 32 )
  {
    v30 = 0;
    do
    {
      v31 = &v205[v30++];
      v29 = (unsigned __int8)v31[1];
    }
    while ( v29 == 32 );
    v199 = v30;
    v32 = &v205[v30];
  }
  else
  {
    LODWORD(v30) = 0;
    v32 = v205;
  }
  v33 = (int)v30;
  v34 = 0;
  v35 = (unsigned __int8 *)&v22[v27];
  v18 -= v25;
  v36 = (unsigned __int8 *)(v32 + 1);
  while ( 2 )
  {
    if ( v29 > 58 )
    {
      if ( v29 == 59 )
      {
        v37 = 0;
      }
      else
      {
        if ( v29 == 61 )
          goto LABEL_51;
LABEL_50:
        v37 = v34 + 1;
        v204[v34] = v29;
      }
      ++v33;
      v38 = *v36++;
      v29 = v38;
      v199 = v33;
      v34 = v37;
      continue;
    }
    break;
  }
  if ( v29 && v29 != 58 )
    goto LABEL_50;
LABEL_51:
  v198 = v35;
  v204[v34] = 0;
  sub_1368C(&v205[v33 + 1], (__int64)v203, &v200, &v199);
  v39 = v199 + v33 + 2;
  if ( !(unsigned int)DHstrnicmp("encryption-method", v204, 17) )
  {
    printLogD();
    v42 = v200;
    v43 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 64) = v43;
    if ( !v43 )
      goto LABEL_232;
    DHmemset(v43, 0, v42 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 64), v42 + 1, (__int64)v203, v42);
    v44 = v25 - 1;
    while ( 1 )
    {
      v45 = &v205[v39];
      v199 = 0;
      v46 = (unsigned __int8)*v45;
      if ( v46 == 32 )
      {
        v47 = 0;
        do
        {
          v48 = &v45[v47++];
          v46 = (unsigned __int8)v48[1];
        }
        while ( v46 == 32 );
        v199 = v47;
        v45 += v47;
      }
      else
      {
        LODWORD(v47) = 0;
      }
      v49 = 0;
      v50 = (unsigned __int8 *)(v45 + 1);
      while ( v46 > 58 )
      {
        if ( v46 == 59 )
        {
          v51 = 0;
          goto LABEL_75;
        }
        if ( v46 == 61 )
          goto LABEL_83;
LABEL_82:
        v51 = v49 + 1;
        v204[v49] = v46;
LABEL_75:
        LODWORD(v47) = v47 + 1;
        v52 = *v50++;
        v46 = v52;
        v199 = v47;
        v49 = v51;
      }
      if ( v46 && v46 != 58 )
        goto LABEL_82;
LABEL_83:
      v53 = v39 + v47;
      v204[v49] = 0;
      sub_1368C(&v205[v53 + 1], (__int64)v203, &v200, &v199);
      v54 = v199;
      if ( (unsigned int)DHstrnicmp("padding", v204, 7) )
      {
        if ( (unsigned int)DHstrnicmp("plaintextlen", v204, 12) )
        {
          if ( !(unsigned int)DHstrnicmp("hlen", v204, 4) )
            *(_DWORD *)(a2 + 84) = DHatoi();
        }
        else
        {
          *(_DWORD *)(a2 + 80) = DHatoi();
        }
      }
      else
      {
        v55 = v200;
        v56 = DHmalloc(v200 + 1);
        *(_QWORD *)(a2 + 72) = v56;
        if ( !v56 )
          goto LABEL_232;
        DHmemset(v56, 0, v55 + 1);
        DHmemcpy_s(*(_QWORD *)(a2 + 72), v55 + 1, (__int64)v203, v55);
      }
      v39 = v53 + v54 + 2;
      if ( v39 >= v44 )
        goto LABEL_25;
    }
  }
  if ( !(unsigned int)DHstrnicmp("Service-Name", v204, 12) )
  {
    printLogD();
    v57 = v200;
    v58 = DHmalloc(v200 + 1);
    *v194 = (__int64)v58;
    if ( !v58 )
      goto LABEL_232;
    DHmemset(v58, 0, v57 + 1);
    DHmemcpy_s(*v194, v57 + 1, (__int64)v203, v57);
    v59 = v25 - 1;
LABEL_92:
    v60 = &v205[v39];
    v199 = 0;
    v61 = (unsigned __int8)*v60;
    if ( v61 == 32 )
    {
      v62 = 0;
      do
      {
        v63 = &v60[v62++];
        v61 = (unsigned __int8)v63[1];
      }
      while ( v61 == 32 );
      v199 = v62;
      v60 += v62;
    }
    else
    {
      LODWORD(v62) = 0;
    }
    v64 = 0;
    v65 = (unsigned __int8 *)(v60 + 1);
    while ( 1 )
    {
      if ( v61 <= 58 )
      {
        if ( !v61 || v61 == 58 )
        {
LABEL_107:
          v68 = v39 + v62;
          v204[v64] = 0;
          sub_1368C(&v205[v39 + 1 + (int)v62], (__int64)v203, &v200, &v199);
          v69 = v199;
          if ( !(unsigned int)DHstrnicmp("cidType", v204, 7) )
          {
            v70 = v200;
            v71 = DHmalloc(v200 + 1);
            *(_QWORD *)(a2 + 48) = v71;
            if ( !v71 )
              goto LABEL_232;
            DHmemset(v71, 0, v70 + 1);
            DHmemcpy_s(*(_QWORD *)(a2 + 48), v70 + 1, (__int64)v203, v70 + 1);
          }
          if ( !(unsigned int)DHstrnicmp("eServiceCode", v204, 12) )
          {
            v72 = v200;
            v73 = DHmalloc(v200 + 1);
            *(_QWORD *)(a2 + 56) = v73;
            if ( !v73 )
              goto LABEL_232;
            DHmemset(v73, 0, v72 + 1);
            DHmemcpy_s(*(_QWORD *)(a2 + 56), v72 + 1, (__int64)v203, v72 + 1);
          }
          v39 = v68 + v69 + 2;
          if ( v39 < v59 )
            goto LABEL_92;
LABEL_25:
          printLogD();
          printLogD();
LABEL_26:
          v22 = (char *)v198;
          if ( v18 <= 0 )
            goto LABEL_227;
          goto LABEL_27;
        }
      }
      else
      {
        if ( v61 == 59 )
        {
          v66 = 0;
          goto LABEL_99;
        }
        if ( v61 == 61 )
          goto LABEL_107;
      }
      v66 = v64 + 1;
      v204[v64] = v61;
LABEL_99:
      LODWORD(v62) = v62 + 1;
      v67 = *v65++;
      v61 = v67;
      v199 = v62;
      v64 = v66;
    }
  }
  if ( !(unsigned int)DHstrnicmp("rights-issuer", v204, 13) )
  {
    printLogD();
    v74 = v200;
    v75 = DHmalloc(v200 + 1);
    *v196 = (__int64)v75;
    if ( !v75 )
      goto LABEL_232;
    DHmemset(v75, 0, v74 + 1);
    DHmemcpy_s(*v196, v74 + 1, (__int64)v203, v74);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("content-name", v204, 12) )
  {
    printLogD();
    v76 = v200;
    v77 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 96) = v77;
    if ( !v77 )
      goto LABEL_232;
    DHmemset(v77, 0, v76 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 96), v76 + 1, (__int64)v203, v76);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("content-description", v204, 19) )
  {
    printLogD();
    v78 = v200;
    v79 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 104) = v79;
    if ( !v79 )
      goto LABEL_232;
    DHmemset(v79, 0, v78 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 104), v78 + 1, (__int64)v203, v78);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("content-vendor", v204, 14) )
  {
    printLogD();
    v80 = v200;
    v81 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 112) = v81;
    if ( !v81 )
      goto LABEL_232;
    DHmemset(v81, 0, v80 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 112), v80 + 1, (__int64)v203, v80);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("icon-uri", v204, 8) )
  {
    printLogD();
    v82 = v200;
    v83 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 120) = v83;
    if ( !v83 )
      goto LABEL_232;
    DHmemset(v83, 0, v82 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 120), v82 + 1, (__int64)v203, v82 + 1);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("eTarget", v204, 7) )
  {
    printLogD();
    v84 = 0;
    for ( i = v203[0]; v203[v84]; i = (unsigned __int8)v203[v84] )
    {
      if ( i == 44 )
        break;
      ++v84;
    }
    v86 = v84 + 1;
    v87 = DHmalloc((int)v84 + 1);
    *(_QWORD *)(a2 + 128) = v87;
    if ( !v87 )
      goto LABEL_232;
    DHmemset(v87, 0, v86);
    DHmemcpy_s(*(_QWORD *)(a2 + 128), v86, (__int64)v203, v84);
    DHstrlwr(*(_BYTE **)(a2 + 128));
    v88 = v200;
    v89 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 136) = v89;
    if ( !v89 )
      goto LABEL_232;
    DHmemset(v89, 0, v88 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 136), v88 + 1, (__int64)&v203[v84 + 1], ~(_DWORD)v84 + v88);
    printLogD();
    goto LABEL_26;
  }
  if ( !(unsigned int)DHstrnicmp("eCEK", v204, 4) )
  {
    printLogD();
    v90 = v200;
    v91 = DHmalloc(v200 + 1);
    *(_QWORD *)(a2 + 144) = v91;
    if ( !v91 )
      goto LABEL_232;
    DHmemset(v91, 0, v90 + 1);
    DHmemcpy_s(*(_QWORD *)(a2 + 144), v90 + 1, (__int64)v203, v90);
    v92 = v25 - 1;
    while ( 1 )
    {
      v93 = &v205[v39];
      v199 = 0;
      v94 = (unsigned __int8)*v93;
      if ( v94 == 32 )
      {
        v95 = 0;
        do
        {
          v96 = &v93[v95++];
          v94 = (unsigned __int8)v96[1];
        }
        while ( v94 == 32 );
        v199 = v95;
        v93 += v95;
      }
      else
      {
        LODWORD(v95) = 0;
      }
      v97 = 0;
      v98 = (unsigned __int8 *)(v93 + 1);
      while ( v94 > 58 )
      {
        if ( v94 == 59 )
        {
          v99 = 0;
          goto LABEL_141;
        }
        if ( v94 == 61 )
          goto LABEL_149;
LABEL_148:
        v99 = v97 + 1;
        v204[v97] = v94;
LABEL_141:
        LODWORD(v95) = v95 + 1;
        v100 = *v98++;
        v94 = v100;
        v199 = v95;
        v97 = v99;
      }
      if ( v94 && v94 != 58 )
        goto LABEL_148;
LABEL_149:
      v101 = v39 + v95;
      v204[v97] = 0;
      sub_1368C(&v205[v101 + 1], (__int64)v203, &v200, &v199);
      v102 = v199;
      if ( (unsigned int)DHstrnicmp("cidType", v204, 7) )
      {
        if ( (unsigned int)DHstrnicmp("dMethod", v204, 7) )
        {
          if ( !(unsigned int)DHstrnicmp("eValue", v204, 6) )
          {
            v103 = v200;
            v104 = DHmalloc(v200 + 1);
            *(_QWORD *)(a2 + 168) = v104;
            if ( v104 )
            {
              DHmemset(v104, 0, v103 + 1);
              v105 = *(_QWORD *)(a2 + 168);
              goto LABEL_132;
            }
LABEL_232:
            DHfree(v197);
            goto LABEL_233;
          }
        }
        else
        {
          v103 = v200;
          v108 = DHmalloc(v200 + 1);
          *(_QWORD *)(a2 + 160) = v108;
          if ( !v108 )
            goto LABEL_232;
          DHmemset(v108, 0, v103 + 1);
          v105 = *(_QWORD *)(a2 + 160);
LABEL_132:
          DHmemcpy_s(v105, v103 + 1, (__int64)v203, v103);
        }
      }
      else
      {
        v106 = v200;
        v107 = DHmalloc(v200 + 1);
        *(_QWORD *)(a2 + 152) = v107;
        if ( !v107 )
          goto LABEL_232;
        DHmemset(v107, 0, v106 + 1);
        DHmemcpy_s(*(_QWORD *)(a2 + 152), v106 + 1, (__int64)v203, v106);
        DHstrlwr(*(_BYTE **)(a2 + 152));
      }
      v39 = v101 + v102 + 2;
      if ( v39 >= v92 )
        goto LABEL_25;
    }
  }
  if ( !(unsigned int)DHstrnicmp("Usage-Control", v204, 13) )
  {
    printLogD();
    v129 = v200;
    v130 = (char *)DHmalloc(v200 + 1);
    if ( !v130 )
      goto LABEL_253;
    v131 = v130;
    DHmemset(v130, 0, v129 + 1);
    DHmemcpy_s((__int64)v131, v129 + 1, (__int64)v203, v129);
    v132 = DHstristr(v131, "Time-Not-After");
    v190 = (char *)v131;
    if ( v132 )
    {
      v133 = v132;
      v134 = DHmalloc(19);
      *(_QWORD *)(a2 + 176) = v134;
      if ( !v134 )
      {
        DHfree(v197);
        v180 = (void *)v131;
        goto LABEL_254;
      }
      DHmemset(v134, 0, 19);
      DHmemcpy_s(*(_QWORD *)(a2 + 176), 19, (__int64)(v133 + 15), 18);
      v135 = DHstrchr(*(const char **)(a2 + 176), 0x2Cu);
      if ( v135 )
        *v135 = 0;
      v136 = *(_QWORD *)(a2 + 176);
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v136, 4);
      v137 = (unsigned __int16)DHatoi();
      if ( v137 == 2099 )
        *(_DWORD *)(a2 + 216) = 1;
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v136 + 4, 2);
      v138 = v137 | ((unsigned int)DHatoi() << 16);
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v136 + 6, 2);
      v139 = v138 | ((unsigned __int64)(unsigned __int16)DHatoi() << 32);
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v136 + 8, 2);
      v188 = v139 | (DHatoi() << 48);
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v136 + 10, 2);
      v140 = v136;
      v141 = DHatoi();
      DHmemset(v202, 0, 10);
      DHmemcpy_s((__int64)v202, 10, v140 + 12, 2);
      v142 = v141 | ((unsigned __int16)DHatoi() << 16);
      v143 = v186 & 0xFFFFFFFF00000000LL | v142;
      *(_DWORD *)(a2 + 184) = DHmktime(v188, v142);
      printLogD();
    }
    else
    {
      v143 = v186;
    }
    v144 = DHstristr(v190, "Allowable-Services");
    v186 = v143;
    if ( v144 )
    {
      v145 = v144;
      v146 = DHmalloc(9);
      *v192 = (__int64)v146;
      if ( !v146 )
      {
        DHfree(v197);
        v180 = v190;
        goto LABEL_254;
      }
      DHmemset(v146, 0, 9);
      DHmemcpy_s(*v192, 9, (__int64)(v145 + 19), 8);
      v147 = DHstrchr((const char *)*v192, 0x2Cu);
      if ( v147 )
        *v147 = 0;
    }
    DHfree(v190);
    v191 = v25 - 1;
    while ( 1 )
    {
      v148 = &v205[v39];
      v199 = 0;
      v149 = (unsigned __int8)*v148;
      if ( v149 == 32 )
      {
        v150 = 0;
        do
        {
          v151 = &v148[v150++];
          v149 = (unsigned __int8)v151[1];
        }
        while ( v149 == 32 );
        v199 = v150;
        v148 += v150;
      }
      else
      {
        LODWORD(v150) = 0;
      }
      v152 = 0;
      v153 = (unsigned __int8 *)(v148 + 1);
      while ( v149 > 58 )
      {
        if ( v149 == 59 )
        {
          v154 = 0;
          goto LABEL_212;
        }
        if ( v149 == 61 )
          goto LABEL_220;
LABEL_219:
        v154 = v152 + 1;
        v204[v152] = v149;
LABEL_212:
        LODWORD(v150) = v150 + 1;
        v155 = *v153++;
        v149 = v155;
        v199 = v150;
        v152 = v154;
      }
      if ( v149 && v149 != 58 )
        goto LABEL_219;
LABEL_220:
      v156 = v39 + v150;
      v204[v152] = 0;
      sub_1368C(&v205[v156 + 1], (__int64)v203, &v200, &v199);
      v157 = v199;
      if ( (unsigned int)DHstrnicmp("cidType", v204, 7) )
      {
        if ( (unsigned int)DHstrnicmp("eAuthCode", v204, 9) )
          goto LABEL_204;
        v158 = v200;
        v159 = DHmalloc(v200 + 1);
        *(_QWORD *)(a2 + 208) = v159;
        if ( v159 )
        {
          DHmemset(v159, 0, v158 + 1);
          DHmemcpy_s(*(_QWORD *)(a2 + 208), v158 + 1, (__int64)v203, v158);
          goto LABEL_204;
        }
LABEL_253:
        v180 = v197;
LABEL_254:
        DHfree(v180);
LABEL_233:
        printLogD();
LABEL_234:
        v6 = 65528;
        goto LABEL_7;
      }
      v160 = v200;
      v161 = DHmalloc(v200 + 1);
      *(_QWORD *)(a2 + 200) = v161;
      if ( !v161 )
        goto LABEL_253;
      DHmemset(v161, 0, v160 + 1);
      DHmemcpy_s(*(_QWORD *)(a2 + 200), v160 + 1, (__int64)v203, v160);
      DHstrlwr(*(_BYTE **)(a2 + 200));
LABEL_204:
      v39 = v156 + v157 + 2;
      if ( v39 >= v191 )
        goto LABEL_25;
    }
  }
  if ( (unsigned int)DHstrnicmp("Meta-Container", v204, 14) )
    goto LABEL_26;
  printLogD();
  v40 = v200;
  v41 = DHmalloc(v200 + 1);
  *v193 = (__int64)v41;
  if ( !v41 )
    goto LABEL_232;
  DHmemset(v41, 0, v40 + 1);
  DHmemcpy_s(*v193, v40 + 1, (__int64)v203, v40);
  printLogD();
  v187 = v25 - 1;
  while ( 2 )
  {
    v110 = &v205[v39];
    v199 = 0;
    v111 = (unsigned __int8)*v110;
    if ( v111 == 32 )
    {
      v112 = 0;
      do
      {
        v113 = &v110[v112++];
        v111 = (unsigned __int8)v113[1];
      }
      while ( v111 == 32 );
      v199 = v112;
      v110 += v112;
    }
    else
    {
      LODWORD(v112) = 0;
    }
    v114 = 0;
    v115 = (unsigned __int8 *)(v110 + 1);
    while ( 2 )
    {
      if ( v111 > 58 )
      {
        if ( v111 == 59 )
        {
          v116 = 0;
        }
        else
        {
          if ( v111 == 61 )
            goto LABEL_175;
LABEL_174:
          v116 = v114 + 1;
          v204[v114] = v111;
        }
        LODWORD(v112) = v112 + 1;
        v117 = *v115++;
        v111 = v117;
        v199 = v112;
        v114 = v116;
        continue;
      }
      break;
    }
    if ( v111 && v111 != 58 )
      goto LABEL_174;
LABEL_175:
    v118 = v39 + v112;
    v204[v114] = 0;
    sub_1368C(&v205[v118 + 1], (__int64)v203, &v200, &v199);
    v109 = v199;
    printLogD();
    if ( !(unsigned int)DHstrnicmp("encoding", v204, 8) )
    {
      v126 = v200;
      v127 = DHmalloc(v200 + 1);
      *(_QWORD *)(a2 + 232) = v127;
      if ( v127 )
      {
        DHmemset(v127, 0, v126 + 1);
        DHmemcpy_s(*(_QWORD *)(a2 + 232), v126 + 1, (__int64)v203, v126);
        goto LABEL_159;
      }
      goto LABEL_232;
    }
    v189 = v109;
    v119 = *v195;
    v120 = DHmalloc(648);
    if ( !v119 )
    {
      *v195 = (__int64)v120;
      if ( !v120 )
        goto LABEL_232;
      DHmemset(v120, 0, 648);
      v128 = DHstrncpy_s(*v195, 128, (__int64)v204, 0x14u);
      if ( !v128 )
      {
        v122 = DHstrncpy_s(*v195 + 128, 512, (__int64)v203, 0xFFu);
        if ( !v122 )
        {
          v109 = v189;
          *(_QWORD *)(*v195 + 640) = 0;
          goto LABEL_159;
        }
        break;
      }
      v185 = v128;
LABEL_268:
      strerror(v185);
      goto LABEL_269;
    }
    if ( !v120 )
      goto LABEL_232;
    v121 = (__int64)v120;
    DHmemset(v120, 0, 648);
    v122 = DHstrncpy_s(v121, 128, (__int64)v204, 0x14u);
    v123 = v121;
    v109 = v189;
    if ( !v122 )
    {
      v122 = DHstrncpy_s(v123 + 128, 512, (__int64)v203, 0xFFu);
      if ( !v122 )
      {
        *(_QWORD *)(v123 + 640) = 0;
        v124 = *v195;
        do
        {
          v125 = v124;
          v124 = *(_QWORD *)(v124 + 640);
        }
        while ( v124 );
        *(_QWORD *)(v125 + 640) = v123;
LABEL_159:
        v39 = v118 + v109 + 2;
        if ( v39 >= v187 )
          goto LABEL_26;
        continue;
      }
    }
    break;
  }
LABEL_188:
  v185 = v122;
  strerror(v122);
LABEL_269:
  printLogD();
  if ( (StrErrorReturn(v185) & 0x8000) != 0 )
    goto LABEL_234;
LABEL_270:
  v183 = *(_BYTE **)(a2 + 64);
  if ( v183 )
  {
    if ( (unsigned int)DHstrnicmp(v183, "aes128ecb", 255) )
    {
      if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cbc", 255) )
      {
        if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cfb1", 255) )
          v184 = 0;
        else
          v184 = 3;
      }
      else
      {
        v184 = 2;
      }
    }
    else
    {
      v184 = 1;
    }
  }
  else
  {
    v184 = 0;
  }
  v6 = 0;
  *a3 = v184;
LABEL_7:
  printLogD();
  return v6;
}
// 10730: variable 'v186' is possibly undefined

//----- (0000000000010FBC) ----------------------------------------------------
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  __int64 v4; // d0
  void *v5; // x0
  void *v6; // x0
  __int64 v7; // d0
  int v8; // w8
  const char *v9; // x0
  int v10; // w0
  void *v11; // x0
  void *v12; // x21
  int v13; // w0
  int v14; // w0
  const char *v15; // x22
  __int64 v16; // x21
  int v17; // w23
  int v18; // w0
  const char *v19; // x0
  int v20; // w0
  void *v21; // x0
  void *v22; // x21
  int v23; // w0
  int v24; // w0
  const char *v25; // x22
  __int64 v26; // x21
  int v27; // w23
  int v28; // w0
  const char *v29; // x0
  int v30; // w0
  void *v31; // x0
  void *v32; // x21
  int v33; // w0
  int v34; // w0
  const char *v35; // x22
  __int64 v36; // x21
  int v37; // w23
  int v38; // w0
  const char *v39; // x0
  int v40; // w0
  void *v41; // x0
  void *v42; // x21
  int v43; // w0
  int v44; // w0
  const char *v45; // x22
  __int64 v46; // x21
  int v47; // w23
  int v48; // w0
  _BYTE *v49; // x0
  _BYTE *v50; // x0
  _BYTE *v51; // x0
  _BYTE *v52; // x0
  const char *v53; // x0
  int v54; // w0
  void *v55; // x0
  void *v56; // x21
  int v57; // w0
  int v58; // w0
  const char *v59; // x22
  __int64 v60; // x21
  int v61; // w23
  int v62; // w0
  _BYTE *v63; // x0
  const char *v64; // x0
  int v65; // w0
  void *v66; // x0
  void *v67; // x21
  int v68; // w0
  int v69; // w0
  const char *v70; // x22
  __int64 v71; // x21
  int v72; // w23
  int v73; // w0
  _BYTE *v74; // x0
  const char *v75; // x0
  int v76; // w0
  void *v77; // x0
  void *v78; // x21
  int v79; // w0
  int v80; // w0
  const char *v81; // x22
  __int64 v82; // x21
  int v83; // w23
  int v84; // w0
  _BYTE *v85; // x0
  const char *v86; // x0
  int v87; // w0
  void *v88; // x0
  void *v89; // x21
  int v90; // w0
  int v91; // w0
  const char *v92; // x22
  __int64 v93; // x21
  int v94; // w23
  int v95; // w0
  _BYTE *v96; // x0
  const char *v97; // x0
  int v98; // w0
  void *v99; // x0
  void *v100; // x21
  int v101; // w0
  int v102; // w0
  const char *v103; // x20
  __int64 v104; // x19
  int v105; // w0
  _BYTE *v106; // x0

  printLogD();
  v4 = *(_QWORD *)(a2 + 4);
  *(_WORD *)(a1 + 4) = *(_WORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  v5 = DHmalloc((int)v4 + 1);
  *(_QWORD *)(a1 + 24) = v5;
  if ( !v5 )
    return 65514;
  DHmemset(v5, 0, *(_DWORD *)(a1 + 8) + 1);
  DHmemcpy_s(*(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 8) + 1, *(_QWORD *)(a2 + 16), *(_DWORD *)(a2 + 4));
  v6 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  *(_QWORD *)(a1 + 40) = v6;
  if ( !v6 )
    return 65514;
  DHmemset(v6, 0, *(_DWORD *)(a1 + 12) + 1);
  DHmemcpy_s(*(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 12) + 1, *(_QWORD *)(a2 + 24), *(_DWORD *)(a2 + 8));
  v7 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = v7;
  if ( !(_DWORD)v7 )
  {
LABEL_49:
    printLogD();
    return 0;
  }
  printLogD();
  v8 = *(_DWORD *)(a2 + 80);
  if ( !v8 )
    v8 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 56) = v8;
  v9 = *(const char **)(a2 + 96);
  if ( !v9 )
  {
    v49 = DHmalloc(1);
    *(_QWORD *)(a1 + 72) = v49;
    if ( !v49 )
      return 65514;
    *v49 = 0;
    v19 = *(const char **)(a2 + 104);
    if ( v19 )
      goto LABEL_9;
LABEL_17:
    v50 = DHmalloc(1);
    *(_QWORD *)(a1 + 88) = v50;
    if ( !v50 )
      return 65514;
    *v50 = 0;
    v29 = *(const char **)(a2 + 112);
    if ( v29 )
      goto LABEL_11;
    goto LABEL_19;
  }
  v10 = DHstrlen(v9);
  v11 = DHmalloc(v10 + 1);
  *(_QWORD *)(a1 + 72) = v11;
  if ( !v11 )
    return 65514;
  v12 = v11;
  v13 = DHstrlen(*(const char **)(a2 + 96));
  DHmemset(v12, 0, v13 + 1);
  v14 = DHstrlen(*(const char **)(a2 + 96));
  v15 = *(const char **)(a2 + 96);
  v16 = *(_QWORD *)(a1 + 72);
  v17 = v14;
  v18 = DHstrlen(v15);
  DHmemcpy_s(v16, v17 + 1, (__int64)v15, v18 + 1);
  v19 = *(const char **)(a2 + 104);
  if ( !v19 )
    goto LABEL_17;
LABEL_9:
  v20 = DHstrlen(v19);
  v21 = DHmalloc(v20 + 1);
  *(_QWORD *)(a1 + 88) = v21;
  if ( !v21 )
    return 65514;
  v22 = v21;
  v23 = DHstrlen(*(const char **)(a2 + 104));
  DHmemset(v22, 0, v23 + 1);
  v24 = DHstrlen(*(const char **)(a2 + 104));
  v25 = *(const char **)(a2 + 104);
  v26 = *(_QWORD *)(a1 + 88);
  v27 = v24;
  v28 = DHstrlen(v25);
  DHmemcpy_s(v26, v27 + 1, (__int64)v25, v28 + 1);
  v29 = *(const char **)(a2 + 112);
  if ( v29 )
  {
LABEL_11:
    v30 = DHstrlen(v29);
    v31 = DHmalloc(v30 + 1);
    *(_QWORD *)(a1 + 104) = v31;
    if ( !v31 )
      return 65514;
    v32 = v31;
    v33 = DHstrlen(*(const char **)(a2 + 112));
    DHmemset(v32, 0, v33 + 1);
    v34 = DHstrlen(*(const char **)(a2 + 112));
    v35 = *(const char **)(a2 + 112);
    v36 = *(_QWORD *)(a1 + 104);
    v37 = v34;
    v38 = DHstrlen(v35);
    DHmemcpy_s(v36, v37 + 1, (__int64)v35, v38 + 1);
    v39 = *(const char **)(a2 + 120);
    if ( v39 )
      goto LABEL_13;
    goto LABEL_21;
  }
LABEL_19:
  v51 = DHmalloc(1);
  *(_QWORD *)(a1 + 104) = v51;
  if ( !v51 )
    return 65514;
  *v51 = 0;
  v39 = *(const char **)(a2 + 120);
  if ( v39 )
  {
LABEL_13:
    v40 = DHstrlen(v39);
    v41 = DHmalloc(v40 + 1);
    *(_QWORD *)(a1 + 120) = v41;
    if ( !v41 )
      return 65514;
    v42 = v41;
    v43 = DHstrlen(*(const char **)(a2 + 120));
    DHmemset(v42, 0, v43 + 1);
    v44 = DHstrlen(*(const char **)(a2 + 120));
    v45 = *(const char **)(a2 + 120);
    v46 = *(_QWORD *)(a1 + 120);
    v47 = v44;
    v48 = DHstrlen(v45);
    DHmemcpy_s(v46, v47 + 1, (__int64)v45, v48 + 1);
    goto LABEL_23;
  }
LABEL_21:
  v52 = DHmalloc(1);
  *(_QWORD *)(a1 + 120) = v52;
  if ( !v52 )
    return 65514;
  *v52 = 0;
LABEL_23:
  v53 = *(const char **)(a2 + 176);
  if ( v53 )
  {
    v54 = DHstrlen(v53);
    v55 = DHmalloc(v54 + 1);
    *(_QWORD *)(a1 + 136) = v55;
    if ( !v55 )
      return 65514;
    v56 = v55;
    v57 = DHstrlen(*(const char **)(a2 + 176));
    DHmemset(v56, 0, v57 + 1);
    v58 = DHstrlen(*(const char **)(a2 + 176));
    v59 = *(const char **)(a2 + 176);
    v60 = *(_QWORD *)(a1 + 136);
    v61 = v58;
    v62 = DHstrlen(v59);
    DHmemcpy_s(v60, v61 + 1, (__int64)v59, v62 + 1);
  }
  else
  {
    v63 = DHmalloc(1);
    *(_QWORD *)(a1 + 136) = v63;
    if ( !v63 )
      return 65514;
    *v63 = 0;
  }
  v64 = *(const char **)(a2 + 192);
  if ( v64 )
  {
    v65 = DHstrlen(v64);
    v66 = DHmalloc(v65 + 1);
    *(_QWORD *)(a1 + 152) = v66;
    if ( !v66 )
      return 65514;
    v67 = v66;
    v68 = DHstrlen(*(const char **)(a2 + 192));
    DHmemset(v67, 0, v68 + 1);
    v69 = DHstrlen(*(const char **)(a2 + 192));
    v70 = *(const char **)(a2 + 192);
    v71 = *(_QWORD *)(a1 + 152);
    v72 = v69;
    v73 = DHstrlen(v70);
    DHmemcpy_s(v71, v72 + 1, (__int64)v70, v73 + 1);
  }
  else
  {
    v74 = DHmalloc(1);
    *(_QWORD *)(a1 + 152) = v74;
    if ( !v74 )
      return 65514;
    *v74 = 0;
  }
  v75 = *(const char **)(a2 + 224);
  if ( v75 )
  {
    v76 = DHstrlen(v75);
    v77 = DHmalloc(v76 + 1);
    *(_QWORD *)(a1 + 184) = v77;
    if ( !v77 )
      return 65514;
    v78 = v77;
    v79 = DHstrlen(*(const char **)(a2 + 224));
    DHmemset(v78, 0, v79 + 1);
    v80 = DHstrlen(*(const char **)(a2 + 224));
    v81 = *(const char **)(a2 + 224);
    v82 = *(_QWORD *)(a1 + 184);
    v83 = v80;
    v84 = DHstrlen(v81);
    DHmemcpy_s(v82, v83 + 1, (__int64)v81, v84 + 1);
  }
  else
  {
    v85 = DHmalloc(1);
    *(_QWORD *)(a1 + 184) = v85;
    if ( !v85 )
      return 65514;
    *v85 = 0;
  }
  v86 = *(const char **)(a2 + 232);
  if ( v86 )
  {
    v87 = DHstrlen(v86);
    v88 = DHmalloc(v87 + 1);
    *(_QWORD *)(a1 + 200) = v88;
    if ( !v88 )
      return 65514;
    v89 = v88;
    v90 = DHstrlen(*(const char **)(a2 + 232));
    DHmemset(v89, 0, v90 + 1);
    v91 = DHstrlen(*(const char **)(a2 + 232));
    v92 = *(const char **)(a2 + 232);
    v93 = *(_QWORD *)(a1 + 200);
    v94 = v91;
    v95 = DHstrlen(v92);
    DHmemcpy_s(v93, v94 + 1, (__int64)v92, v95 + 1);
  }
  else
  {
    v96 = DHmalloc(1);
    *(_QWORD *)(a1 + 200) = v96;
    if ( !v96 )
      return 65514;
    *v96 = 0;
  }
  v97 = *(const char **)(a2 + 240);
  if ( v97 )
  {
    v98 = DHstrlen(v97);
    v99 = DHmalloc(v98 + 1);
    *(_QWORD *)(a1 + 216) = v99;
    if ( v99 )
    {
      v100 = v99;
      v101 = DHstrlen(*(const char **)(a2 + 240));
      DHmemset(v100, 0, v101 + 1);
      v102 = DHstrlen(*(const char **)(a2 + 240));
      v103 = *(const char **)(a2 + 240);
      v104 = *(_QWORD *)(a1 + 216);
      LODWORD(v100) = v102;
      v105 = DHstrlen(v103);
      DHmemcpy_s(v104, (_DWORD)v100 + 1, (__int64)v103, v105 + 1);
LABEL_48:
      printLogD();
      goto LABEL_49;
    }
  }
  else
  {
    v106 = DHmalloc(1);
    *(_QWORD *)(a1 + 216) = v106;
    if ( v106 )
    {
      *v106 = 0;
      goto LABEL_48;
    }
  }
  return 65514;
}

//----- (000000000001157C) ----------------------------------------------------
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  void *v18; // x0
  void *v19; // x0
  void *v20; // x0
  void *v21; // x0
  void *v22; // x0
  void *v23; // x0
  void *v24; // x0
  void *v25; // x0
  void *v26; // x0
  _QWORD *v27; // x0
  _QWORD *v28; // x8
  _QWORD *v29; // x20

  printLogD();
  if ( a1 )
  {
    v2 = (void *)a1[2];
    if ( v2 )
      DHfree(v2);
    v3 = (void *)a1[3];
    if ( v3 )
      DHfree(v3);
    v4 = (void *)a1[8];
    if ( v4 )
      DHfree(v4);
    v5 = (void *)a1[9];
    if ( v5 )
      DHfree(v5);
    v6 = (void *)a1[11];
    if ( v6 )
      DHfree(v6);
    v7 = (void *)a1[12];
    if ( v7 )
      DHfree(v7);
    v8 = (void *)a1[13];
    if ( v8 )
      DHfree(v8);
    v9 = (void *)a1[14];
    if ( v9 )
      DHfree(v9);
    v10 = (void *)a1[15];
    if ( v10 )
      DHfree(v10);
    v11 = (void *)a1[17];
    if ( v11 )
      DHfree(v11);
    v12 = (void *)a1[16];
    if ( v12 )
      DHfree(v12);
    v13 = (void *)a1[5];
    if ( v13 )
      DHfree(v13);
    v14 = (void *)a1[6];
    if ( v14 )
      DHfree(v14);
    v15 = (void *)a1[7];
    if ( v15 )
      DHfree(v15);
    v16 = (void *)a1[18];
    if ( v16 )
      DHfree(v16);
    v17 = (void *)a1[20];
    if ( v17 )
      DHfree(v17);
    v18 = (void *)a1[21];
    if ( v18 )
      DHfree(v18);
    v19 = (void *)a1[19];
    if ( v19 )
      DHfree(v19);
    v20 = (void *)a1[22];
    if ( v20 )
      DHfree(v20);
    v21 = (void *)a1[24];
    if ( v21 )
      DHfree(v21);
    v22 = (void *)a1[26];
    if ( v22 )
      DHfree(v22);
    v23 = (void *)a1[25];
    if ( v23 )
      DHfree(v23);
    v24 = (void *)a1[28];
    if ( v24 )
      DHfree(v24);
    v25 = (void *)a1[29];
    if ( v25 )
      DHfree(v25);
    v26 = (void *)a1[30];
    if ( v26 )
      DHfree(v26);
    printLogD();
    v27 = (_QWORD *)a1[31];
    if ( v27 )
    {
      v28 = (_QWORD *)v27[80];
      if ( v28 )
      {
        do
        {
          v29 = v28;
          DHfree(v27);
          v28 = (_QWORD *)v29[80];
          v27 = v29;
        }
        while ( v28 );
      }
      else
      {
        v29 = (_QWORD *)a1[31];
      }
      DHfree(v29);
    }
    printLogD();
    DHfree(a1);
  }
  printLogD();
}

//----- (0000000000011750) ----------------------------------------------------
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  __int64 v3; // x12
  __int64 v4; // x11
  int8x16_t *v5; // x9
  int8x16_t *v6; // x10
  int8x16_t *v7; // x9
  int8x16_t *v8; // x10
  __int64 v9; // x12
  int8x16_t v10; // q0
  int8x16_t v11; // q1
  int8x8_t *v12; // x13
  int8x8_t *v13; // x14
  __int64 v14; // x11
  int8x8_t v15; // t1
  int v16; // w8
  unsigned __int8 v17; // t1

  if ( a3 >= 1 )
  {
    LODWORD(v3) = 0;
    if ( (unsigned int)a3 < 8 || (unsigned __int64)((char *)a2 - (char *)result) < 0x20 )
    {
      v5 = result;
      v6 = a2;
      goto LABEL_16;
    }
    if ( (unsigned int)a3 < 0x20 )
    {
      v4 = 0;
      goto LABEL_11;
    }
    v4 = a3 & 0x7FFFFFE0;
    v7 = a2 + 1;
    v8 = result + 1;
    v9 = v4;
    do
    {
      v10 = v8[-1];
      v11 = *v8;
      v9 -= 32;
      v8 += 2;
      v7[-1] = vmvnq_s8(v10);
      *v7 = vmvnq_s8(v11);
      v7 += 2;
    }
    while ( v9 );
    if ( v4 != a3 )
    {
      if ( (a3 & 0x18) == 0 )
      {
        v6 = (int8x16_t *)((char *)a2 + v4);
        v5 = (int8x16_t *)((char *)result + v4);
        LODWORD(v3) = a3 & 0x7FFFFFE0;
        goto LABEL_16;
      }
LABEL_11:
      v3 = a3 & 0x7FFFFFF8;
      v12 = (int8x8_t *)((char *)a2 + v4);
      v13 = (int8x8_t *)((char *)result + v4);
      v5 = (int8x16_t *)((char *)result + v3);
      v6 = (int8x16_t *)((char *)a2 + v3);
      v14 = v4 - v3;
      do
      {
        v15.n64_u64[0] = v13->n64_u64[0];
        ++v13;
        v14 += 8;
        v12->n64_u64[0] = vmvn_s8(v15).n64_u64[0];
        ++v12;
      }
      while ( v14 );
      if ( v3 == a3 )
        return result;
LABEL_16:
      v16 = a3 - v3;
      do
      {
        v17 = v5->n128_u8[0];
        v5 = (int8x16_t *)((char *)v5 + 1);
        --v16;
        v6->n128_u8[0] = ~v17;
        v6 = (int8x16_t *)((char *)v6 + 1);
      }
      while ( v16 );
    }
  }
  return result;
}

//----- (0000000000011830) ----------------------------------------------------
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5)
{
  void *v10; // x0
  __int64 v11; // x21
  unsigned __int64 v12; // x28
  __int64 result; // x0
  int v14; // w8
  int v15; // w26
  __int16 ClientID; // w0
  __int64 v17; // x8
  __int64 v18; // x12
  char *v19; // x9
  int8x16_t *v20; // x10
  __int64 v21; // x11
  int8x16_t *v22; // x10
  __int64 v23; // x12
  int8x16_t *v24; // x9
  int8x16_t v25; // q0
  int8x16_t v26; // q1
  int8x8_t *v27; // x14
  int8x8_t *v28; // x13
  __int64 v29; // x11
  int8x8_t v30; // t1
  int v31; // w8
  char v32; // t1
  unsigned int v33; // w22
  int v34; // w23
  _BYTE *v35; // x0
  _BYTE *v36; // x20
  __int64 v37; // x24
  __int64 v38; // x24
  unsigned int v39; // w2
  int v40; // w22
  __int64 v41; // x23
  __int64 v42; // x8
  __int64 v43; // x28
  int v44; // w22
  unsigned int v45; // w0
  int v46; // w0
  int v47; // w25
  int v48; // w22
  void *v49; // x0
  void *v50; // x24
  __int64 v51; // x26
  int v52; // w19
  __int64 v53; // [xsp+0h] [xbp-130h]
  int v54; // [xsp+Ch] [xbp-124h]
  __int64 v55; // [xsp+10h] [xbp-120h]
  int v56; // [xsp+1Ch] [xbp-114h]
  __int64 v57; // [xsp+20h] [xbp-110h]
  int v58; // [xsp+28h] [xbp-108h]
  int8x16_t *v59; // [xsp+30h] [xbp-100h]
  int v60; // [xsp+3Ch] [xbp-F4h] BYREF
  int8x16_t v61; // [xsp+40h] [xbp-F0h] BYREF
  __int64 v62; // [xsp+50h] [xbp-E0h] BYREF
  _QWORD v63[2]; // [xsp+58h] [xbp-D8h]
  __int64 v64; // [xsp+68h] [xbp-C8h] BYREF
  _QWORD v65[2]; // [xsp+70h] [xbp-C0h]
  __int64 v66; // [xsp+80h] [xbp-B0h] BYREF
  __int16 v67; // [xsp+88h] [xbp-A8h]
  char v68[32]; // [xsp+90h] [xbp-A0h] BYREF
  char v69[48]; // [xsp+B0h] [xbp-80h] BYREF
  __int128 v70; // [xsp+E0h] [xbp-50h] BYREF
  _BYTE v71[35]; // [xsp+F0h] [xbp-40h] BYREF
  __int64 v72; // [xsp+118h] [xbp-18h]

  v72 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v71, 0, sizeof(v71));
  v70 = 0u;
  memset(&v69[20], 0, 18);
  memset(v68, 0, sizeof(v68));
  v67 = 0;
  v66 = 0;
  v64 = 0;
  v65[0] = 0;
  *(_QWORD *)((char *)v65 + 5) = 0;
  v62 = 0;
  v63[0] = 0;
  *(_QWORD *)((char *)v63 + 5) = 0;
  printLogD();
  v10 = DHmalloc(*(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1);
  *(_QWORD *)(a5 + 24) = v10;
  if ( !v10 )
    return 65514;
  v11 = (__int64)v10;
  DHmemset(v10, 0, *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1);
  v12 = *(unsigned int *)(a5 + 12);
  result = 65501;
  if ( !(_DWORD)v12 )
    return result;
  if ( (unsigned int)v12 % 0x14 )
    return result;
  strcpy(v69, "SSE Primary-Level Base Key Generation");
  strcpy(v68, "SSE 2-Level Base Key Generation");
  DHmemset(&v62, 0, 21);
  DHmemset(&v66, 0, 10);
  v14 = DHstrlen(a2);
  result = 65509;
  if ( !a3 || v14 < 1 )
    return result;
  v15 = DHstrlen(a4);
  DHmemset(&v70, 0, 51);
  v60 = 51;
  ClientID = GetClientID(a1, (__int64)&v70, (unsigned int *)&v60);
  if ( ClientID < 0 )
    return (unsigned int)ClientID;
  DHstrlwr(&v70);
  v59 = (int8x16_t *)DHmalloc(v60);
  if ( !v59 )
    return 65514;
  v17 = (unsigned int)v60;
  if ( v60 >= 1 )
  {
    LODWORD(v18) = 0;
    v19 = (char *)&v70;
    if ( (unsigned int)v60 < 8 )
    {
      v20 = v59;
    }
    else
    {
      v20 = v59;
      if ( (unsigned __int64)((char *)v59 - (char *)&v70) >= 0x20 )
      {
        if ( (unsigned int)v60 < 0x20 )
        {
          v21 = 0;
          goto LABEL_19;
        }
        v21 = v60 & 0x7FFFFFE0;
        v22 = (int8x16_t *)v71;
        v23 = v21;
        v24 = v59 + 1;
        do
        {
          v25 = v22[-1];
          v26 = *v22;
          v23 -= 32;
          v22 += 2;
          v24[-1] = vmvnq_s8(v25);
          *v24 = vmvnq_s8(v26);
          v24 += 2;
        }
        while ( v23 );
        if ( v21 == v17 )
          goto LABEL_26;
        if ( (v17 & 0x18) != 0 )
        {
LABEL_19:
          v18 = v17 & 0x7FFFFFF8;
          v19 = &v71[v18 - 16];
          v27 = (int8x8_t *)&v71[v21 - 16];
          v20 = (int8x16_t *)((char *)v59 + v18);
          v28 = (int8x8_t *)((char *)v59 + v21);
          v29 = v21 - v18;
          do
          {
            v30.n64_u64[0] = v27->n64_u64[0];
            ++v27;
            v29 += 8;
            v28->n64_u64[0] = vmvn_s8(v30).n64_u64[0];
            ++v28;
          }
          while ( v29 );
          if ( v18 == v17 )
            goto LABEL_26;
          goto LABEL_24;
        }
        LODWORD(v18) = v17 & 0x7FFFFFE0;
        v19 = &v71[v21 - 16];
        v20 = (int8x16_t *)((char *)v59 + v21);
      }
    }
LABEL_24:
    v31 = v17 - v18;
    do
    {
      v32 = *v19++;
      --v31;
      v20->n128_u8[0] = ~v32;
      v20 = (int8x16_t *)((char *)v20 + 1);
    }
    while ( v31 );
LABEL_26:
    LODWORD(v17) = v60;
  }
  v33 = v15 + a3;
  v34 = v15 + a3 + 2 * v17;
  v35 = DHmalloc(v34 + 38);
  if ( !v35 )
    return 65514;
  v53 = (__int64)a4;
  v36 = v35;
  DHmemset(v35, 0, v34 + 38);
  DHmemcpy_s((__int64)v36, v34 + 38, (__int64)a2, a3);
  DHstrlwr(v36);
  v37 = (__int64)&v36[a3];
  DHmemcpy_s(v37, v34 + 38, v53, v15);
  v38 = v37 + v15;
  v57 = v15;
  v58 = v15;
  DHmemcpy_s(v38, v34 + 38, (__int64)&v70, v60);
  DHmemcpy_s(v38 + v60, v34 + 38, (__int64)v59, v60);
  DHmemcpy_s(v38 + 2LL * v60, v34 + 38, (__int64)v69, 37);
  v39 = v33 + 2 * v60 + 37;
  v40 = *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8);
  DA_DRM_HASH_SHA1Digest((__int64)v36, (uint32x4_t *)&v64, v39);
  DHmemcpy_s(v11, v40 + 1, (__int64)&v64, 20);
  DHfree(v36);
  if ( (unsigned int)v12 < 0x28 )
  {
LABEL_33:
    DHmemcpy_s(
      v11 + *(unsigned int *)(a5 + 12),
      *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1,
      v11,
      *(_DWORD *)(a5 + 8));
    DHfree(v59);
    printLogD();
    return 0;
  }
  else
  {
    v41 = 0x1400000000LL;
    v42 = (v12 * (unsigned __int128)0xCCCCCCCCCCCCCCDuLL) >> 64;
    v43 = 1;
    v55 = v42;
    v56 = v15 + 51;
    v54 = v15 + 50;
    while ( 1 )
    {
      v44 = v60;
      v61.n128_u16[4] = 0;
      v61.n128_u64[0] = 0;
      DHultoa(v43 + 1, &v61, 0xAu);
      v45 = DHstrlen((const char *)&v61);
      v46 = DHstrncpy_s((__int64)&v66, 10, (__int64)&v61, v45);
      if ( v46 )
        break;
      v47 = DHstrlen((const char *)&v66);
      v48 = v56 + 2 * v44;
      v49 = DHmalloc(v48 + v47);
      if ( !v49 )
        return 65514;
      v50 = v49;
      DHmemset(v49, 0, v48 + v47);
      DHmemcpy_s((__int64)v50, v48 + v47, (__int64)&v64, 20);
      DHmemcpy_s((__int64)v50 + 20, v48 + v47, v53, v58);
      v51 = (__int64)v50 + v57 + 20;
      DHmemcpy_s(v51, v48 + v47, (__int64)&v70, v60);
      DHmemcpy_s(v51 + v60, v48 + v47, (__int64)v59, v60);
      DHmemcpy_s(v51 + 2LL * v60, v48 + v47, (__int64)v68, 4);
      DHmemcpy_s(v51 + 2LL * v60 + 4, v48 + v47, (__int64)&v66, v47);
      DHmemcpy_s(v51 + 2LL * v60 + v47 + 4, v48 + v47, (__int64)&v68[5], 26);
      DA_DRM_HASH_SHA1Digest((__int64)v50, (uint32x4_t *)&v64, v54 + v47 + 2 * v60);
      DHmemcpy_s(v11 + (v41 >> 32), *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1, (__int64)&v64, 20);
      DHfree(v50);
      ++v43;
      v41 += 0x1400000000LL;
      if ( v55 == v43 )
        goto LABEL_33;
    }
    v52 = v46;
    strerror(v46);
    printLogD();
    return StrErrorReturn(v52);
  }
}

//----- (0000000000011E38) ----------------------------------------------------
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  __int64 result; // x0
  signed int v9; // w25
  int8x16_t *v10; // x0
  int8x16_t *v11; // x20
  int v12; // w0
  int v13; // w19
  __int64 v14; // x22
  int v15; // w8
  __int64 i; // x8
  int v17; // w10
  int v18; // w26
  int v19; // w24
  int v20; // w0
  int8x16_t *v21; // x0
  __int64 v22; // x12
  char *v23; // x9
  int8x16_t *v24; // x10
  __int64 v25; // x11
  int8x16_t *v26; // x0
  int8x16_t *v27; // x9
  int8x16_t *v28; // x10
  __int64 v29; // x12
  int8x16_t v30; // q0
  int8x16_t v31; // q1
  int8x8_t *v32; // x13
  int8x8_t *v33; // x14
  __int64 v34; // x11
  int8x8_t v35; // t1
  int v36; // w8
  char v37; // t1
  int v38; // w23
  int v39; // w26
  int v40; // w27
  void *v41; // x0
  int v42; // w8
  void *v43; // x26
  __int64 v44; // x19
  int v45; // [xsp+4h] [xbp-FCh]
  __int64 v46; // [xsp+10h] [xbp-F0h]
  int8x16_t *v47; // [xsp+18h] [xbp-E8h]
  int v48; // [xsp+24h] [xbp-DCh] BYREF
  __int64 v49; // [xsp+28h] [xbp-D8h] BYREF
  _QWORD v50[2]; // [xsp+30h] [xbp-D0h]
  __int64 v51; // [xsp+40h] [xbp-C0h] BYREF
  __int16 v52; // [xsp+48h] [xbp-B8h]
  char v53[48]; // [xsp+50h] [xbp-B0h] BYREF
  __int64 v54; // [xsp+80h] [xbp-80h] BYREF
  _QWORD v55[2]; // [xsp+88h] [xbp-78h]
  __int64 v56; // [xsp+98h] [xbp-68h] BYREF
  _QWORD v57[2]; // [xsp+A0h] [xbp-60h]
  __int128 v58; // [xsp+B0h] [xbp-50h] BYREF
  _BYTE v59[35]; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v60; // [xsp+E8h] [xbp-18h]

  v60 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v59, 0, sizeof(v59));
  v58 = 0u;
  v56 = 0;
  v57[0] = 0;
  *(_QWORD *)((char *)v57 + 5) = 0;
  strcpy(v53, "Encrypted Target Identifying Token Generation");
  v54 = 0;
  v55[0] = 0;
  *(_QWORD *)((char *)v55 + 5) = 0;
  v52 = 0;
  v51 = 0;
  v49 = 0;
  v50[0] = 0;
  *(_QWORD *)((char *)v50 + 5) = 0;
  printLogD();
  printLogD();
  result = 65501;
  if ( a1 && a2 && a3 && a4 )
  {
    v9 = DHstrlen(a4);
    v10 = (int8x16_t *)DHmalloc(v9 + 1);
    if ( !v10 )
      return 65514;
    v11 = v10;
    v12 = DHstrncpy_s((__int64)v10, v9 + 1, (__int64)a4, v9);
    if ( v12 )
    {
      v13 = v12;
      strerror(v12);
LABEL_8:
      printLogD();
      return StrErrorReturn(v13);
    }
    DHstrlwr(v11);
    DHmemset(&v51, 0, 10);
    DHmemset(&v49, 0, 21);
    DHmemset(&v56, 0, 21);
    DHmemset(&v54, 0, 21);
    v14 = 0;
    if ( *a3 == 34 )
      ++a3;
    v15 = (unsigned __int8)*a3;
    if ( !*a3 )
      goto LABEL_24;
    while ( v15 != 47 )
    {
      *((_BYTE *)&v51 + v14++) = v15;
      v15 = (unsigned __int8)a3[v14];
      if ( !a3[v14] )
        goto LABEL_24;
    }
    DHstrlwr(&v51);
    for ( i = 0; ; *((_BYTE *)&v50[-1] + i++) = v17 )
    {
      v17 = (unsigned __int8)a3[i + 1 + v14];
      if ( !a3[i + 1 + v14] || v17 == 34 )
        break;
    }
    if ( v17 != 34 || (unsigned int)i != 20 )
    {
LABEL_24:
      DHfree(v11);
      printLogD();
      return 65434;
    }
    v18 = DHstrlen(a1);
    v19 = DHstrlen(a2);
    v20 = DHstrncpy_s((__int64)&v58, 50, (__int64)a2, v19);
    if ( v20 )
    {
      v13 = v20;
      strerror(v20);
      goto LABEL_8;
    }
    DHstrlwr(&v58);
    v21 = (int8x16_t *)DHmalloc(v19);
    if ( !v21 )
    {
      v26 = v11;
      goto LABEL_50;
    }
    if ( v19 < 1 )
    {
LABEL_46:
      v47 = v21;
      DHmemset(&v56, 0, 21);
      DHmemset(&v54, 0, 21);
      v46 = 2LL * v19;
      v38 = v18;
      v39 = v18 + v46;
      v40 = v39 + v9 + v14 + 46;
      v41 = DHmalloc(v40);
      if ( v41 )
      {
        v42 = v9 + v14 + v39;
        v43 = v41;
        v45 = v42;
        DHmemset(v41, 0, v40);
        DHmemcpy_s((__int64)v43, v40, (__int64)v11, v9);
        DHmemcpy_s((__int64)v43 + v9, v40, (__int64)&v51, v14);
        DHmemcpy_s((__int64)v43 + v9 + (unsigned int)v14, v40, (__int64)a1, v38);
        v44 = (__int64)v43 + v9 + (unsigned int)v14 + v38;
        DHmemcpy_s(v44, v40, (__int64)&v58, v19);
        DHmemcpy_s(v44 + v19, v40, (__int64)v47, v19);
        DHmemcpy_s(v44 + v46, v40, (__int64)v53, 45);
        DA_DRM_HASH_SHA1Digest((__int64)v43, (uint32x4_t *)&v54, v45 + 45);
        PP_HexEncode_A((unsigned __int8 *)&v54, 0xAu, &v56, &v48);
        DHfree(v47);
        DHfree(v43);
        DHfree(v11);
        if ( !(unsigned int)DHstrnicmp(&v49, &v56, 255) )
        {
          printLogD();
          return 0;
        }
        printLogD();
        printLogD();
        return 65434;
      }
      DHfree(v11);
      v26 = v47;
LABEL_50:
      DHfree(v26);
      return 65514;
    }
    LODWORD(v22) = 0;
    v23 = (char *)&v58;
    if ( (unsigned int)v19 < 8 )
    {
      v24 = v21;
    }
    else
    {
      v24 = v21;
      if ( (unsigned __int64)((char *)v21 - (char *)&v58) >= 0x20 )
      {
        if ( (unsigned int)v19 < 0x20 )
        {
          v25 = 0;
          goto LABEL_39;
        }
        v25 = v19 & 0x7FFFFFE0;
        v27 = v21 + 1;
        v28 = (int8x16_t *)v59;
        v29 = v25;
        do
        {
          v30 = v28[-1];
          v31 = *v28;
          v29 -= 32;
          v28 += 2;
          v27[-1] = vmvnq_s8(v30);
          *v27 = vmvnq_s8(v31);
          v27 += 2;
        }
        while ( v29 );
        if ( v25 == v19 )
          goto LABEL_46;
        if ( (v19 & 0x18) != 0 )
        {
LABEL_39:
          v22 = v19 & 0x7FFFFFF8;
          v32 = (int8x8_t *)((char *)v21 + v25);
          v23 = &v59[v22 - 16];
          v24 = (int8x16_t *)((char *)v21 + v22);
          v33 = (int8x8_t *)&v59[v25 - 16];
          v34 = v25 - v22;
          do
          {
            v35.n64_u64[0] = v33->n64_u64[0];
            ++v33;
            v34 += 8;
            v32->n64_u64[0] = vmvn_s8(v35).n64_u64[0];
            ++v32;
          }
          while ( v34 );
          if ( v22 == v19 )
            goto LABEL_46;
          goto LABEL_44;
        }
        v24 = (int8x16_t *)((char *)v21 + v25);
        LODWORD(v22) = v19 & 0x7FFFFFE0;
        v23 = &v59[v25 - 16];
      }
    }
LABEL_44:
    v36 = v19 - v22;
    do
    {
      v37 = *v23++;
      --v36;
      v24->n128_u8[0] = ~v37;
      v24 = (int8x16_t *)((char *)v24 + 1);
    }
    while ( v36 );
    goto LABEL_46;
  }
  return result;
}

//----- (0000000000012408) ----------------------------------------------------
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        const char *a6,
        __int16 a7)
{
  int v14; // w0
  int v15; // w23
  signed int v17; // w27
  _BYTE *v18; // x0
  _BYTE *v19; // x20
  int v20; // w0
  int v21; // w19
  int v22; // w27
  int v23; // w8
  unsigned __int8 *v24; // x8
  _BYTE *v25; // x23
  int v26; // w8
  __int64 v27; // x8
  int v28; // w9
  int v29; // w26
  __int16 ClientID; // w0
  int8x16_t *v31; // x0
  __int64 v32; // x9
  int8x16_t *v33; // x19
  int v34; // w8
  int v35; // w23
  __int64 v36; // x13
  char *v37; // x10
  int v38; // w27
  int8x16_t *v39; // x11
  __int64 v40; // x12
  unsigned int v41; // w19
  int8x16_t *v42; // x10
  int8x16_t *v43; // x11
  __int64 v44; // x13
  int8x16_t v45; // q0
  int8x16_t v46; // q1
  int8x8_t *v47; // x14
  int8x8_t *v48; // x15
  __int64 v49; // x12
  int8x8_t v50; // t1
  int v51; // w9
  char v52; // t1
  int v53; // w25
  void *v54; // x0
  void *v55; // x28
  __int64 v56; // x10
  __int64 v57; // x21
  __int64 v58; // x19
  unsigned int v59; // w20
  __int64 v60; // [xsp+0h] [xbp-F0h]
  __int64 v61; // [xsp+8h] [xbp-E8h]
  int v62; // [xsp+10h] [xbp-E0h]
  int v63; // [xsp+18h] [xbp-D8h]
  int8x16_t *v64; // [xsp+18h] [xbp-D8h]
  unsigned int v65; // [xsp+24h] [xbp-CCh]
  unsigned int v66; // [xsp+28h] [xbp-C8h]
  int v67; // [xsp+2Ch] [xbp-C4h] BYREF
  signed int v68; // [xsp+30h] [xbp-C0h] BYREF
  uint32x4_t v69; // [xsp+36h] [xbp-BAh] BYREF
  _BYTE v70[21]; // [xsp+4Bh] [xbp-A5h] BYREF
  __int128 v71; // [xsp+60h] [xbp-90h] BYREF
  _OWORD v72[3]; // [xsp+70h] [xbp-80h] BYREF
  __int128 v73; // [xsp+A0h] [xbp-50h] BYREF
  char v74[19]; // [xsp+B0h] [xbp-40h] BYREF
  _BYTE v75[21]; // [xsp+C3h] [xbp-2Dh] BYREF
  __int64 v76; // [xsp+D8h] [xbp-18h]

  v76 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v72, 0, 35);
  v71 = 0u;
  printLogD();
  printLogD();
  if ( !a5 )
  {
    if ( (a7 & 0xFFFE) == 0x1000 )
      return 4294967271LL;
    else
      return 0;
  }
  if ( a3 )
  {
    v14 = DHstrlen(a3);
    v15 = v14 + 14;
    v62 = v14;
    v66 = 14;
    if ( a4 )
    {
LABEL_4:
      v63 = DHstrlen(a4);
      v65 = 18;
      v15 += v63 + 18;
      goto LABEL_10;
    }
  }
  else
  {
    v62 = 0;
    v15 = 0;
    v66 = 0;
    if ( a4 )
      goto LABEL_4;
  }
  v63 = 0;
  v65 = 0;
LABEL_10:
  v17 = DHstrlen(a6);
  v18 = DHmalloc(v17 + 1);
  if ( !v18 )
    return 65514;
  v19 = v18;
  v61 = (__int64)a2;
  DHmemset(v18, 0, v17 + 1);
  v20 = DHstrncpy_s((__int64)v19, v17 + 1, (__int64)a6, v17);
  if ( v20 )
  {
    v21 = v20;
    strerror(v20);
    printLogD();
    return StrErrorReturn(v21);
  }
  v60 = v17;
  DHstrlwr(v19);
  if ( a3 )
    DHstrlwr(a3);
  v22 = v17 + v15;
  printLogD();
  v23 = *a5;
  v73 = xmmword_7C50;
  if ( v23 == 34 )
    v24 = a5 + 1;
  else
    v24 = a5;
  strcpy(v74, "Generation");
  v25 = v24 + 1;
  v26 = *v24;
  if ( !v26 )
    goto LABEL_34;
  while ( v26 != 47 )
  {
    v26 = (unsigned __int8)*v25++;
    if ( !*(v25 - 1) )
      goto LABEL_34;
  }
  printLogD();
  DHmemset(v75, 0, 21);
  v27 = 0;
  v28 = (unsigned __int8)*v25;
  if ( *v25 )
  {
    do
    {
      if ( v28 == 34 )
        break;
      v75[v27++] = v28;
      v28 = (unsigned __int8)v25[v27];
    }
    while ( v25[v27] );
  }
  if ( (_DWORD)v27 != 20 )
  {
LABEL_34:
    DHfree(v19);
    return 65511;
  }
  printLogD();
  v29 = DHstrlen(a2);
  DHmemset(&v71, 0, 51);
  v68 = 51;
  ClientID = GetClientID(a1, (__int64)&v71, (unsigned int *)&v68);
  if ( ClientID < 0 )
  {
    v41 = ClientID;
    DHfree(v19);
    return v41;
  }
  DHstrlwr(&v71);
  printLogD();
  DHstrlwr(&v71);
  printLogD();
  v31 = (int8x16_t *)DHmalloc(v68);
  if ( !v31 )
    goto LABEL_60;
  v32 = (unsigned int)v68;
  v33 = v31;
  v34 = v22 + v29;
  if ( v68 < 1 )
  {
    v38 = v63;
    v35 = v62;
    goto LABEL_50;
  }
  v35 = v62;
  LODWORD(v36) = 0;
  v37 = (char *)&v71;
  if ( (unsigned int)v68 < 8 )
  {
    v38 = v63;
    v39 = v31;
  }
  else
  {
    v38 = v63;
    v39 = v31;
    if ( (unsigned __int64)((char *)v31 - (char *)&v71) >= 0x20 )
    {
      if ( (unsigned int)v68 < 0x20 )
      {
        v40 = 0;
        goto LABEL_42;
      }
      v40 = v68 & 0x7FFFFFE0;
      v42 = v31 + 1;
      v43 = (int8x16_t *)v72;
      v44 = v40;
      do
      {
        v45 = v43[-1];
        v46 = *v43;
        v44 -= 32;
        v43 += 2;
        v42[-1] = vmvnq_s8(v45);
        *v42 = vmvnq_s8(v46);
        v42 += 2;
      }
      while ( v44 );
      if ( v40 == v32 )
        goto LABEL_49;
      if ( (v32 & 0x18) != 0 )
      {
LABEL_42:
        v36 = v32 & 0x7FFFFFF8;
        v47 = (int8x8_t *)((char *)v31 + v40);
        v37 = (char *)&v72[-1] + v36;
        v39 = (int8x16_t *)((char *)v31 + v36);
        v48 = (int8x8_t *)((char *)&v72[-1] + v40);
        v49 = v40 - v36;
        do
        {
          v50.n64_u64[0] = v48->n64_u64[0];
          ++v48;
          v49 += 8;
          v47->n64_u64[0] = vmvn_s8(v50).n64_u64[0];
          ++v47;
        }
        while ( v49 );
        if ( v36 == v32 )
          goto LABEL_49;
        goto LABEL_47;
      }
      v39 = (int8x16_t *)((char *)v31 + v40);
      LODWORD(v36) = v32 & 0x7FFFFFE0;
      v37 = (char *)&v72[-1] + v40;
    }
  }
LABEL_47:
  v51 = v32 - v36;
  do
  {
    v52 = *v37++;
    --v51;
    v39->n128_u8[0] = ~v52;
    v39 = (int8x16_t *)((char *)v39 + 1);
  }
  while ( v51 );
LABEL_49:
  LODWORD(v32) = v68;
LABEL_50:
  v53 = v34 + 2 * v32;
  v54 = DHmalloc(v53 + 27);
  if ( !v54 )
  {
    DHfree(v33);
LABEL_60:
    DHfree(v19);
    return 65514;
  }
  v55 = v54;
  v64 = v33;
  DHmemset(v54, 0, v53 + 27);
  DHmemcpy_s((__int64)v55, v53 + 27, (__int64)v19, v60);
  if ( v35 )
    DHmemcpy_s((__int64)v55 + v60, v53 + 27, (__int64)"time-not-after", v66);
  if ( v38 )
    DHmemcpy_s((__int64)v55 + v60 + v66, v53 + 27, (__int64)"allowable-services", v65);
  v56 = v60;
  if ( v35 )
  {
    DHmemcpy_s((__int64)v55 + v60 + v66 + v65, v53 + 27, (__int64)a3, v35);
    v56 = v60;
  }
  if ( v38 )
  {
    DHmemcpy_s((__int64)v55 + v56 + v66 + v65 + v35, v53 + 27, (__int64)a4, v38);
    v56 = v60;
  }
  v57 = (__int64)v55 + v56 + v66 + v65 + v35 + v38;
  DHmemcpy_s(v57, v53 + 27, v61, v29);
  v58 = v57 + v29;
  DHmemcpy_s(v58, v53 + 27, (__int64)&v71, v68);
  DHmemcpy_s(v58 + v68, v53 + 27, (__int64)v64, v68);
  DHmemcpy_s(v58 + 2LL * v68, v53 + 27, (__int64)&v73, 26);
  printLogD();
  DA_DRM_HASH_SHA1Digest((__int64)v55, &v69, v53 + 26);
  PP_HexEncode_A((unsigned __int8 *)&v69, 0xAu, v70, &v67);
  DHfree(v64);
  DHfree(v55);
  DHfree(v19);
  printLogD();
  if ( (unsigned int)DHstrnicmp(v75, v70, 20) )
    v59 = -25;
  else
    v59 = 0;
  printLogD();
  return v59;
}
// 7C50: using guessed type __int128 xmmword_7C50;

//----- (0000000000012ABC) ----------------------------------------------------
__int64 __fastcall compute_eServiceCode(unsigned __int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5)
{
  int v7; // w19
  __int64 result; // x0
  signed int v12; // w20
  int8x16_t *v13; // x0
  int8x16_t *v14; // x19
  int v15; // w0
  int v16; // w19
  _BYTE *v17; // x8
  __int64 v18; // x9
  int v19; // w11
  signed int v20; // w23
  int8x16_t *v21; // x0
  int8x16_t *v22; // x21
  int v23; // w0
  int8x16_t *v24; // x0
  unsigned int v25; // w0
  int v26; // w27
  unsigned int v27; // w25
  int8x16_t *v28; // x0
  int8x16_t *v29; // x22
  __int16 ClientID; // w0
  int8x16_t *v31; // x0
  __int64 v32; // x8
  int8x16_t *v33; // x26
  __int64 v34; // x12
  char *v35; // x9
  int8x16_t *v36; // x10
  int8x16_t *v37; // x13
  __int64 v38; // x11
  unsigned int v39; // w20
  int8x16_t *v40; // x9
  int8x16_t *v41; // x10
  __int64 v42; // x12
  int8x16_t v43; // q0
  int8x16_t v44; // q1
  int8x8_t *v45; // x13
  int8x8_t *v46; // x14
  __int64 v47; // x11
  int8x8_t v48; // t1
  int v49; // w8
  char v50; // t1
  int v51; // w27
  void *v52; // x0
  void *v53; // x26
  __int64 v54; // x20
  int8x16_t *v55; // [xsp+8h] [xbp-D8h]
  __int64 v56; // [xsp+10h] [xbp-D0h]
  int v57; // [xsp+1Ch] [xbp-C4h]
  int v58; // [xsp+20h] [xbp-C0h] BYREF
  int v59; // [xsp+24h] [xbp-BCh] BYREF
  __int64 v60; // [xsp+28h] [xbp-B8h] BYREF
  _QWORD v61[2]; // [xsp+30h] [xbp-B0h]
  __int64 v62; // [xsp+40h] [xbp-A0h] BYREF
  _QWORD v63[2]; // [xsp+48h] [xbp-98h]
  __int64 v64; // [xsp+58h] [xbp-88h] BYREF
  _QWORD v65[2]; // [xsp+60h] [xbp-80h]
  char v66[32]; // [xsp+70h] [xbp-70h] BYREF
  __int128 v67; // [xsp+90h] [xbp-50h] BYREF
  _OWORD v68[3]; // [xsp+A0h] [xbp-40h] BYREF
  __int64 v69; // [xsp+D0h] [xbp-10h]

  v7 = a1;
  v69 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v68, 0, 35);
  v67 = 0u;
  v64 = 0;
  v65[0] = 0;
  *(_QWORD *)((char *)v65 + 5) = 0;
  v62 = 0;
  v63[0] = 0;
  *(_QWORD *)((char *)v63 + 5) = 0;
  v60 = 0;
  v61[0] = 0;
  *(_QWORD *)((char *)v61 + 5) = 0;
  printLogD();
  result = 65501;
  if ( !v7 || !a2 )
    return result;
  if ( !a3 && !a4 && !a5 )
    return 0;
  strcpy(v66, "eServiceCode Value Generation");
  v12 = DHstrlen(a2);
  v13 = (int8x16_t *)DHmalloc(v12 + 1);
  if ( !v13 )
    return 65514;
  v14 = v13;
  DHmemset(v13, 0, v12 + 1);
  v15 = DHstrncpy_s((__int64)v14, v12 + 1, (__int64)a2, v12);
  if ( !v15 )
  {
    DHstrlwr(v14);
    v17 = a3 + 1;
    if ( *a3 != 34 )
      v17 = a3;
    do
    {
      if ( !*v17++ )
        goto LABEL_23;
    }
    while ( *(v17 - 1) != 47 );
    v18 = 0;
    v19 = (unsigned __int8)*v17;
    if ( *v17 )
    {
      do
      {
        if ( v19 == 47 )
          break;
        *((_BYTE *)&v65[-1] + v18++) = v19;
        v19 = (unsigned __int8)v17[v18];
      }
      while ( v17[v18] );
    }
    if ( (_DWORD)v18 != 20 )
    {
LABEL_23:
      DHfree(v14);
      return 65432;
    }
    v20 = DHstrlen(a4);
    v21 = (int8x16_t *)DHmalloc(v20 + 1);
    if ( !v21 )
    {
      v24 = v14;
      goto LABEL_27;
    }
    v22 = v21;
    DHmemset(v21, 0, v20 + 1);
    v23 = DHstrncpy_s((__int64)v22, v20 + 1, (__int64)a4, v20);
    if ( v23 )
    {
LABEL_22:
      v16 = v23;
      strerror(v23);
      goto LABEL_10;
    }
    DHstrlwr(v22);
    v25 = DHstrlen(a5);
    v26 = v25 + 1;
    v27 = v25;
    v28 = (int8x16_t *)DHmalloc(v25 + 1);
    if ( !v28 )
    {
      DHfree(v14);
      v24 = v22;
      goto LABEL_27;
    }
    v29 = v28;
    DHmemset(v28, 0, v26);
    v23 = DHstrncpy_s((__int64)v29, v26, (__int64)a5, v27);
    if ( v23 )
      goto LABEL_22;
    DHstrlwr(v29);
    v59 = v26;
    ClientID = GetClientID(a1, (__int64)&v67, (unsigned int *)&v59);
    if ( ClientID < 0 )
    {
      v39 = ClientID;
      DHfree(v14);
      DHfree(v22);
      DHfree(v29);
      return v39;
    }
    DHstrlwr(&v67);
    v31 = (int8x16_t *)DHmalloc(v59 + 1);
    if ( !v31 )
    {
      DHfree(v14);
      DHfree(v22);
      v24 = v29;
      goto LABEL_27;
    }
    v32 = (unsigned int)v59;
    v33 = v31;
    if ( v59 < 1 )
    {
LABEL_54:
      v56 = v12 + (__int64)v20;
      v51 = v27 + v56 + 2 * v32;
      v57 = v27 + v56;
      v52 = DHmalloc(v51 + 30);
      if ( v52 )
      {
        v55 = v33;
        v53 = v52;
        DHmemset(v52, 0, v51 + 30);
        DHmemcpy_s((__int64)v53, v51 + 30, (__int64)v14, v12);
        DHmemcpy_s((__int64)v53 + v12, v51 + 30, (__int64)v22, v20);
        DHmemcpy_s((__int64)v53 + v56, v51 + 30, (__int64)v29, v27);
        DHmemcpy_s((__int64)v53 + v57, v51 + 30, (__int64)&v67, v59);
        v54 = v59 + v57;
        DHmemcpy_s((__int64)v53 + v54, v51 + 30, (__int64)v55, v59);
        DHmemcpy_s((__int64)v53 + v59 + v54, v51 + 30, (__int64)v66, 29);
        DHfree(v14);
        DHfree(v22);
        DHfree(v29);
        DHfree(v55);
        DA_DRM_HASH_SHA1Digest((__int64)v53, (uint32x4_t *)&v62, v51 + 29);
        PP_HexEncode_A((unsigned __int8 *)&v62, 0xAu, &v60, &v58);
        DHfree(v53);
        if ( !(unsigned int)DHstrnicmp(&v64, &v60, 20) )
        {
          printLogD();
          return 0;
        }
        return 65432;
      }
      DHfree(v14);
      DHfree(v22);
      DHfree(v29);
      v24 = v33;
LABEL_27:
      DHfree(v24);
      return 65514;
    }
    LODWORD(v34) = 0;
    v35 = (char *)&v67;
    if ( (unsigned int)v59 < 8 )
    {
      v36 = v31;
    }
    else
    {
      v36 = v31;
      if ( (unsigned __int64)((char *)v31 - (char *)&v67) >= 0x20 )
      {
        if ( (unsigned int)v59 < 0x20 )
        {
          v37 = v31;
          v38 = 0;
          goto LABEL_46;
        }
        v38 = v59 & 0x7FFFFFE0;
        v37 = v31;
        v40 = v31 + 1;
        v41 = (int8x16_t *)v68;
        v42 = v38;
        do
        {
          v43 = v41[-1];
          v44 = *v41;
          v42 -= 32;
          v41 += 2;
          v40[-1] = vmvnq_s8(v43);
          *v40 = vmvnq_s8(v44);
          v40 += 2;
        }
        while ( v42 );
        if ( v38 == v32 )
          goto LABEL_53;
        if ( (v32 & 0x18) != 0 )
        {
LABEL_46:
          v34 = v32 & 0x7FFFFFF8;
          v33 = v37;
          v35 = (char *)&v68[-1] + v34;
          v36 = (int8x16_t *)((char *)v37 + v34);
          v45 = (int8x8_t *)((char *)v37 + v38);
          v46 = (int8x8_t *)((char *)&v68[-1] + v38);
          v47 = v38 - v34;
          do
          {
            v48.n64_u64[0] = v46->n64_u64[0];
            ++v46;
            v47 += 8;
            v45->n64_u64[0] = vmvn_s8(v48).n64_u64[0];
            ++v45;
          }
          while ( v47 );
          if ( v34 == v32 )
            goto LABEL_53;
          goto LABEL_51;
        }
        v33 = v31;
        v36 = (int8x16_t *)((char *)v31 + v38);
        v35 = (char *)&v68[-1] + v38;
        LODWORD(v34) = v32 & 0x7FFFFFE0;
      }
    }
LABEL_51:
    v49 = v32 - v34;
    do
    {
      v50 = *v35++;
      --v49;
      v36->n128_u8[0] = ~v50;
      v36 = (int8x16_t *)((char *)v36 + 1);
    }
    while ( v49 );
LABEL_53:
    LODWORD(v32) = v59;
    goto LABEL_54;
  }
  v16 = v15;
  strerror(v15);
LABEL_10:
  printLogD();
  return StrErrorReturn(v16);
}

//----- (00000000000130A0) ----------------------------------------------------
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, const char *a3, __int64 a4, __int16 a5)
{
  signed int v10; // w26
  int8x16_t *v11; // x0
  __int64 v12; // x24
  int8x16_t *v13; // x21
  int v14; // w0
  int v15; // w19
  int v17; // w25
  __int16 ClientID; // w0
  int8x16_t *v19; // x0
  __int64 v20; // x8
  int8x16_t *v21; // x23
  __int64 v22; // x12
  char *v23; // x9
  int8x16_t *v24; // x10
  __int64 v25; // x11
  unsigned int v26; // w19
  int8x16_t *v27; // x0
  int8x16_t *v28; // x9
  int8x16_t *v29; // x10
  __int64 v30; // x12
  int8x16_t v31; // q0
  int8x16_t v32; // q1
  int8x8_t *v33; // x13
  int8x8_t *v34; // x14
  __int64 v35; // x11
  int8x8_t v36; // t1
  int v37; // w8
  char v38; // t1
  int v39; // w28
  void *v40; // x0
  void *v41; // x26
  __int64 v42; // x24
  __int64 v43; // x22
  int v44; // [xsp+Ch] [xbp-84h] BYREF
  __int128 v45; // [xsp+10h] [xbp-80h] BYREF
  _OWORD v46[3]; // [xsp+20h] [xbp-70h] BYREF
  char v47[32]; // [xsp+50h] [xbp-40h] BYREF
  __int64 v48; // [xsp+70h] [xbp-20h] BYREF
  _QWORD v49[3]; // [xsp+78h] [xbp-18h]

  v49[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v48 = 0;
  v49[0] = 0;
  *(_QWORD *)((char *)v49 + 5) = 0;
  *(_DWORD *)&v47[19] = 0;
  memset(v46, 0, 35);
  v45 = 0u;
  printLogD();
  v10 = DHstrlen(a3);
  v11 = (int8x16_t *)DHmalloc(v10 + 1);
  if ( !v11 )
    return 65514;
  v12 = v10;
  v13 = v11;
  v14 = DHstrncpy_s((__int64)v11, v10 + 1, (__int64)a3, v10);
  if ( v14 )
  {
    v15 = v14;
    strerror(v14);
    printLogD();
    return StrErrorReturn(v15);
  }
  DHstrlwr(v13);
  v17 = DHstrlen(a2);
  DHmemset(&v45, 0, 51);
  v44 = 51;
  ClientID = GetClientID(a1, (__int64)&v45, (unsigned int *)&v44);
  if ( ClientID < 0 )
  {
    v26 = ClientID;
    DHfree(v13);
    return v26;
  }
  DHstrlwr(&v45);
  v19 = (int8x16_t *)DHmalloc(v44);
  if ( v19 )
  {
    v20 = (unsigned int)v44;
    v21 = v19;
    if ( v44 < 1 )
    {
LABEL_26:
      v39 = v17 + v10 + 2 * v20;
      strcpy(v47, "SSKEY-1 Key Generation");
      v40 = DHmalloc(v39 + 23);
      if ( v40 )
      {
        v41 = v40;
        DHmemset(v40, 0, v39 + 23);
        DHmemcpy_s((__int64)v41, v39 + 23, (__int64)v13, v12);
        v42 = (__int64)v41 + v12;
        DHmemcpy_s(v42, v39 + 23, (__int64)a2, v17);
        v43 = v42 + v17;
        DHmemcpy_s(v43, v39 + 23, (__int64)&v45, v44);
        DHmemcpy_s(v43 + v44, v39 + 23, (__int64)v21, v44);
        DHmemcpy_s(v43 + 2LL * v44, v39 + 23, (__int64)v47, 22);
        DA_DRM_HASH_SHA1Digest((__int64)v41, (uint32x4_t *)&v48, v39 + 22);
        DHmemcpy_s(a4, 16, (__int64)&v48, a5);
        DHfree(v41);
        DHfree(v13);
        DHfree(v21);
        printLogD();
        return 0;
      }
      DHfree(v13);
      v27 = v21;
      goto LABEL_29;
    }
    LODWORD(v22) = 0;
    v23 = (char *)&v45;
    if ( (unsigned int)v44 < 8 )
    {
      v24 = v19;
    }
    else
    {
      v24 = v19;
      if ( (unsigned __int64)((char *)v19 - (char *)&v45) >= 0x20 )
      {
        if ( (unsigned int)v44 < 0x20 )
        {
          v25 = 0;
          goto LABEL_18;
        }
        v25 = v44 & 0x7FFFFFE0;
        v28 = v19 + 1;
        v29 = (int8x16_t *)v46;
        v30 = v25;
        do
        {
          v31 = v29[-1];
          v32 = *v29;
          v30 -= 32;
          v29 += 2;
          v28[-1] = vmvnq_s8(v31);
          *v28 = vmvnq_s8(v32);
          v28 += 2;
        }
        while ( v30 );
        if ( v25 == v20 )
          goto LABEL_25;
        if ( (v20 & 0x18) != 0 )
        {
LABEL_18:
          v22 = v20 & 0x7FFFFFF8;
          v33 = (int8x8_t *)((char *)v19 + v25);
          v23 = (char *)&v46[-1] + v22;
          v24 = (int8x16_t *)((char *)v19 + v22);
          v34 = (int8x8_t *)((char *)&v46[-1] + v25);
          v35 = v25 - v22;
          do
          {
            v36.n64_u64[0] = v34->n64_u64[0];
            ++v34;
            v35 += 8;
            v33->n64_u64[0] = vmvn_s8(v36).n64_u64[0];
            ++v33;
          }
          while ( v35 );
          if ( v22 == v20 )
            goto LABEL_25;
          goto LABEL_23;
        }
        v24 = (int8x16_t *)((char *)v19 + v25);
        LODWORD(v22) = v20 & 0x7FFFFFE0;
        v23 = (char *)&v46[-1] + v25;
      }
    }
LABEL_23:
    v37 = v20 - v22;
    do
    {
      v38 = *v23++;
      --v37;
      v24->n128_u8[0] = ~v38;
      v24 = (int8x16_t *)((char *)v24 + 1);
    }
    while ( v37 );
LABEL_25:
    LODWORD(v20) = v44;
    goto LABEL_26;
  }
  v27 = v13;
LABEL_29:
  DHfree(v27);
  return 65514;
}

//----- (0000000000013440) ----------------------------------------------------
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  __int64 v6; // x0
  char *v7; // x23
  unsigned int v8; // w22
  _BYTE *v9; // x0
  _BYTE *v10; // x21
  int v11; // w0
  _BYTE *v13; // x0
  int v14; // w19

  printLogD();
  v6 = DHstrstr();
  if ( v6 )
    v7 = (char *)(v6 + 1);
  else
    v7 = a3;
  if ( !(unsigned int)DHstrnicmp(a1, "ALL", 4) )
    return 1;
  if ( !(unsigned int)DHstrnicmp(a1, "LOCAL", 6) )
    return (unsigned int)DHstrnicmp(v7, "local", 5) != 0;
  if ( !(unsigned int)DHstrnicmp(v7, "p-cluster", 9) )
  {
    v8 = DHstrlen("p-cluster");
    v13 = DHmalloc(v8 + 1);
    if ( v13 )
    {
      v10 = v13;
      DHmemset(v13, 0, v8 + 1);
      v11 = DHstrncpy_s((__int64)v10, v8 + 1, (__int64)"p-cluster", v8);
      if ( v11 )
      {
LABEL_14:
        v14 = v11;
        strerror(v11);
        printLogD();
        return StrErrorReturn(v14);
      }
      goto LABEL_17;
    }
    return 65514;
  }
  v8 = DHstrlen(v7);
  v9 = DHmalloc(v8 + 1);
  if ( !v9 )
    return 65514;
  v10 = v9;
  DHmemset(v9, 0, v8 + 1);
  v11 = DHstrncpy_s((__int64)v10, v8 + 1, (__int64)v7, v8);
  if ( v11 )
    goto LABEL_14;
  DHstrlwr(v10);
LABEL_17:
  if ( (unsigned int)DHstrnicmp(a1, "domain", 7) )
  {
    DHfree(v10);
    return 0;
  }
  else
  {
    if ( a2 )
    {
      while ( (unsigned int)DHstrnicmp(v10, *(_BYTE **)a2, v8) )
      {
        a2 = *(_QWORD *)(a2 + 16);
        if ( !a2 )
          goto LABEL_24;
      }
      LODWORD(a2) = 1;
    }
LABEL_24:
    DHfree(v10);
    printLogD();
    return (unsigned int)a2;
  }
}

//----- (000000000001368C) ----------------------------------------------------
char *__fastcall sub_1368C(char *result, __int64 a2, int *a3, int *a4)
{
  int v4; // w8
  int v5; // w9
  int v6; // t1
  int v7; // w10
  int v8; // t1
  int v9; // w9
  int v10; // w11
  int v11; // w10
  int v12; // w10
  char v13; // w9
  __int64 v14; // x9
  char v15; // t1
  int v16; // w9
  int v17; // w9
  int v18; // w11
  int v19; // w12
  unsigned int v20; // w9
  char v21; // w10
  int v22; // w10
  char v23; // w9
  char v24; // w10
  __int64 v25; // x10
  int i; // w8

  *a4 = 0;
  *a3 = 0;
  v4 = (unsigned __int8)*result;
  if ( v4 == 32 )
  {
    v5 = *a4 + 1;
    do
    {
      *a4 = v5++;
      v6 = (unsigned __int8)*++result;
      v4 = v6;
    }
    while ( v6 == 32 );
  }
  if ( v4 == 34 )
  {
    ++*a4;
    v8 = (unsigned __int8)*++result;
    v7 = v8;
  }
  else
  {
    v7 = v4;
  }
  v9 = v4 != 34;
  v10 = v7 == 59 && v4 != 34;
  if ( !v7 )
    v10 = 1;
  if ( v7 != 34 )
    v9 = 1;
  if ( v9 != v10 )
  {
    while ( 1 )
    {
      if ( v7 != 92 )
        goto LABEL_24;
      v11 = (unsigned __int8)result[1];
      if ( v11 == 34 || v11 == 92 )
      {
        ++result;
        ++*a4;
LABEL_24:
        v14 = *a3;
        v15 = *result++;
        *a3 = v14 + 1;
        *(_BYTE *)(a2 + v14) = v15;
        v16 = *a4 + 1;
        goto LABEL_25;
      }
      if ( v11 != 48 || ((unsigned __int8)result[2] | 0x20) != 0x78 )
        goto LABEL_24;
      v12 = (unsigned __int8)result[3];
      v13 = v12 - 48;
      if ( (unsigned int)(v12 - 48) >= 0xA )
      {
        if ( (unsigned int)(v12 - 65) > 5 )
        {
          v20 = v12 - 97;
          v21 = v12 - 87;
          if ( v20 >= 6 )
            v13 = 0;
          else
            v13 = v21;
        }
        else
        {
          v13 = v12 - 55;
        }
      }
      v22 = (unsigned __int8)result[4];
      v23 = 16 * v13;
      if ( (unsigned int)(v22 - 48) > 9 )
      {
        if ( (unsigned int)(v22 - 65) <= 5 )
        {
          v24 = v22 - 55;
LABEL_44:
          v23 |= v24;
          goto LABEL_45;
        }
        if ( (unsigned int)(v22 - 97) <= 5 )
        {
          v24 = v22 - 87;
          goto LABEL_44;
        }
      }
      else
      {
        v23 |= v22 - 48;
      }
LABEL_45:
      v25 = *a3;
      result += 5;
      *a3 = v25 + 1;
      *(_BYTE *)(a2 + v25) = v23;
      v16 = *a4 + 5;
LABEL_25:
      *a4 = v16;
      v17 = *a3;
      if ( *a3 <= 254 )
      {
        v7 = (unsigned __int8)*result;
        v18 = v4 != 34;
        v19 = v7 == 59 && v4 != 34;
        if ( !*result )
          v19 = 1;
        if ( v7 != 34 )
          v18 = 1;
        if ( v18 != v19 )
          continue;
      }
      goto LABEL_47;
    }
  }
  v17 = *a3;
LABEL_47:
  *(_BYTE *)(a2 + v17) = 0;
  for ( i = (unsigned __int8)*result; *result; i = (unsigned __int8)*result )
  {
    if ( i == 59 )
      break;
    ++result;
    ++*a4;
  }
  return result;
}

//----- (0000000000013874) ----------------------------------------------------
__int64 __fastcall DRM_GetID3HeaderDataSize(__int64 a1, int *a2)
{
  __int64 result; // x0
  int v4; // [xsp+8h] [xbp-18h] BYREF
  char v5; // [xsp+Ch] [xbp-14h]
  _BYTE v6[10]; // [xsp+Eh] [xbp-12h] BYREF
  __int64 v7; // [xsp+18h] [xbp-8h]

  v7 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v5 = 0;
  v4 = 53691465;
  DHmemcpy_s((__int64)v6, 10, a1, 10);
  result = DHmemcmp(&v4, v6, 5);
  if ( (_DWORD)result )
    return 4294966895LL;
  *a2 = v6[9] | (v6[8] << 7) | (v6[7] << 14) | (v6[6] << 21);
  return result;
}

//----- (0000000000013918) ----------------------------------------------------
__int64 __fastcall DRM_GetBufferSizeForAlbumArt(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v6; // w23
  unsigned int v7; // w23
  char *v8; // x0
  char *v9; // x21
  unsigned __int64 v10; // x27
  char *v11; // x25
  const char *v12; // x24
  const char *v13; // x0
  const char *v14; // x23
  unsigned int v15; // w22
  int v16; // w0
  __int64 v17; // x8
  int v18; // w24
  int v19; // w25
  int v20; // w0
  int v22; // [xsp+8h] [xbp-18h] BYREF
  char v23; // [xsp+Ch] [xbp-14h]
  _BYTE v24[10]; // [xsp+Eh] [xbp-12h] BYREF
  __int64 v25; // [xsp+18h] [xbp-8h]

  v25 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  printLogD();
  v23 = 0;
  v22 = 53691465;
  DHmemcpy_s((__int64)v24, 10, a1, 10);
  if ( (unsigned int)DHmemcmp(&v22, v24, 5) )
  {
    v6 = -401;
  }
  else
  {
    v7 = v24[9] | (v24[8] << 7) | (v24[7] << 14) | (v24[6] << 21);
    v8 = (char *)DHmalloc(v7);
    if ( v8 )
    {
      v9 = v8;
      DHmemcpy_s((__int64)v8, v7, a1, v7);
      printLogD();
      printLogD();
      v10 = (unsigned __int64)&v9[v7 - 256];
      if ( (unsigned __int64)v9 >= v10 )
      {
        v12 = 0;
        v15 = 0;
      }
      else
      {
        v11 = v9;
        while ( 1 )
        {
          while ( 1 )
          {
            v13 = (const char *)DHmemchr(v11, 65, 256);
            if ( v13 )
              break;
            v12 = 0;
            v11 += 256;
            if ( (unsigned __int64)v11 >= v10 )
              goto LABEL_10;
          }
          v14 = v13;
          if ( !(unsigned int)DHstrncmp(v13, "APIC", 4) )
            break;
          v11 = (char *)(v14 + 1);
          v12 = v14 + 1;
          if ( (unsigned __int64)(v14 + 1) >= v10 )
          {
LABEL_10:
            v15 = 0;
            goto LABEL_14;
          }
        }
        v12 = v14;
        v15 = bswap32(*((_DWORD *)v14 + 1));
      }
LABEL_14:
      printLogD();
      printLogD();
      v6 = -402;
      if ( v12 && v15 )
      {
        printLogD();
        v16 = DHstrlen(v12 + 11);
        v17 = (__int64)&v12[v16 + 11];
        v18 = v16;
        v19 = v17 + 2;
        v20 = DHstrlen((const char *)(v17 + 2));
        v6 = 0;
        *a3 = v19 + v20 - (_DWORD)v9 + 1;
        *a2 = -4 - (v18 - v15) - v20;
      }
      DHfree(v9);
    }
    else
    {
      v6 = -22;
    }
  }
  printLogD();
  return v6;
}

//----- (0000000000013BC8) ----------------------------------------------------
__int64 __fastcall DRM_ExtractAlbumArt(__int64 a1, _QWORD *a2, int *a3)
{
  unsigned int BufferSizeForAlbumArt; // w0
  unsigned int v7; // w24
  int v8; // w22
  void *v9; // x0
  _QWORD v11[2]; // [xsp+0h] [xbp-10h] BYREF

  v11[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11[0] = 0;
  if ( !a1 )
    return 4294967261LL;
  BufferSizeForAlbumArt = DRM_GetBufferSizeForAlbumArt(a1, v11, (_DWORD *)v11 + 1);
  if ( (BufferSizeForAlbumArt & 0x80000000) != 0 )
    return 4294966894LL;
  v7 = BufferSizeForAlbumArt;
  printLogD();
  v8 = v11[0];
  v9 = DHmalloc(v11[0]);
  *a2 = v9;
  if ( !v9 )
    return 4294967274LL;
  DHmemcpy_s((__int64)v9, v8, a1 + SHIDWORD(v11[0]), v8);
  *a3 = v8;
  printLogD();
  return v7;
}

//----- (0000000000013CBC) ----------------------------------------------------
__int64 __fastcall DRM_GetMetaTextValueFromID3(__int64 a1, char *a2, __int64 *a3, int *a4)
{
  unsigned int v8; // w19
  unsigned int v10; // w24
  char *v11; // x0
  char *v12; // x21
  unsigned __int64 v13; // x26
  unsigned __int64 v14; // x27
  char *v15; // x24
  const char *v16; // x0
  const char *v17; // x23
  unsigned int v18; // w24
  signed int v19; // w22
  int v20; // w26
  int v21; // w22
  void *v22; // x0
  int v23; // [xsp+8h] [xbp-18h] BYREF
  char v24; // [xsp+Ch] [xbp-14h]
  _BYTE v25[10]; // [xsp+Eh] [xbp-12h] BYREF
  __int64 v26; // [xsp+18h] [xbp-8h]

  v26 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  if ( !a2 || (DHstrupr(a2), DHstrlen(a2), printLogD(), *a2 != 84) || (unsigned int)DHstrlen(a2) != 4 )
  {
    v8 = -35;
    goto LABEL_7;
  }
  printLogD();
  v24 = 0;
  v23 = 53691465;
  DHmemcpy_s((__int64)v25, 10, a1, 10);
  if ( !(unsigned int)DHmemcmp(&v23, v25, 5) )
  {
    v10 = v25[9] | (v25[8] << 7) | (v25[7] << 14) | (v25[6] << 21);
    v11 = (char *)DHmalloc(v10);
    if ( !v11 )
    {
      v8 = -22;
      goto LABEL_7;
    }
    v12 = v11;
    DHmemcpy_s((__int64)v11, v10, a1, v10);
    printLogD();
    printLogD();
    printLogD();
    v13 = (unsigned __int64)&v12[v10];
    v14 = v13 - 256;
    if ( (unsigned __int64)v12 >= v13 - 256 )
    {
LABEL_16:
      printLogD();
    }
    else
    {
      v15 = v12;
      while ( 1 )
      {
        while ( 1 )
        {
          v16 = (const char *)DHmemchr(v15, (unsigned __int8)*a2, 256);
          if ( v16 )
            break;
          v15 += 256;
          if ( (unsigned __int64)v15 >= v14 )
            goto LABEL_16;
        }
        v17 = v16;
        if ( !(unsigned int)DHstrncmp(v16, a2, 4) )
          break;
        v15 = (char *)(v17 + 1);
        if ( (unsigned __int64)(v17 + 1) >= v14 )
          goto LABEL_16;
      }
      v18 = *((_DWORD *)v17 + 1);
      v19 = bswap32(v18);
      printLogD();
      if ( v18 && (unsigned __int64)&v17[v19] <= v13 )
      {
        printLogD();
        if ( !v17[10] )
        {
          v20 = 1;
          goto LABEL_26;
        }
        if ( v17[10] == 1 )
        {
          v20 = 2;
LABEL_26:
          v21 = v19 - 1;
          printLogD();
          v22 = DHmalloc(v20 + v21);
          *a3 = (__int64)v22;
          DHmemset(v22, 0, v20 + v21);
          DHmemcpy_s(*a3, v20 + v21, (__int64)(v17 + 11), v21);
          *a4 = v21;
          DHfree(v12);
          printLogD();
          return 0;
        }
        printLogD();
        v8 = -400;
LABEL_18:
        DHfree(v12);
        goto LABEL_7;
      }
    }
    printLogD();
    v8 = -402;
    goto LABEL_18;
  }
  v8 = -401;
LABEL_7:
  printLogD();
  return v8;
}

//----- (000000000001401C) ----------------------------------------------------
void printLogV()
{
  ;
}

//----- (0000000000014048) ----------------------------------------------------
void printLogI()
{
  ;
}

//----- (0000000000014074) ----------------------------------------------------
void printLogW()
{
  ;
}

//----- (00000000000140A0) ----------------------------------------------------
void printLogF()
{
  ;
}

//----- (00000000000140CC) ----------------------------------------------------
void printLogS()
{
  ;
}

//----- (00000000000140F8) ----------------------------------------------------
void printLogE()
{
  ;
}

//----- (0000000000014124) ----------------------------------------------------
void printLogD()
{
  ;
}

//----- (0000000000014150) ----------------------------------------------------
void printLogUNK()
{
  ;
}

//----- (000000000001417C) ----------------------------------------------------
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3)
{
  FILE *result; // x0
  FILE *v7; // x19
  int v8; // w0
  int v9; // w0
  int v10; // w0
  int v11; // w0
  int v12; // w0
  int v13; // w0

  result = fopen("/drmInterface.log", "a");
  if ( result )
  {
    v7 = result;
    v8 = DHstrlen(a1);
    fwrite(a1, 1u, v8, v7);
    v9 = DHstrlen("\t");
    fwrite("\t", 1u, v9, v7);
    v10 = DHstrlen(a2);
    fwrite(a2, 1u, v10, v7);
    v11 = DHstrlen("\t");
    fwrite("\t", 1u, v11, v7);
    v12 = DHstrlen(a3);
    fwrite(a3, 1u, v12, v7);
    v13 = DHstrlen("\n");
    fwrite("\n", 1u, v13, v7);
    return (FILE *)fclose(v7);
  }
  return result;
}

//----- (0000000000014290) ----------------------------------------------------
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x23
  __int64 v9; // x0
  __int64 v11; // x0
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64, __int64); // [xsp+8h] [xbp-8h]

  v5 = qword_25C90;
  if ( !qword_25C90 )
  {
    v7 = qword_25C98;
    if ( !qword_25C98 )
    {
      v11 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v11 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v11);
      qword_25C98 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "<init>",
           "([BLjava/lang/String;)V");
    qword_25C90 = v5;
    if ( !v5 )
      return 0;
  }
  v8 = qword_25C98;
  v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 224LL);
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v12(a1, v8, v5, a2, v9);
}
// 25C90: using guessed type __int64 qword_25C90;
// 25C98: using guessed type __int64 qword_25C98;

//----- (00000000000143A0) ----------------------------------------------------
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x0
  __int64 v10; // x0
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64); // [xsp+18h] [xbp+18h]

  v5 = qword_25CA0;
  if ( !qword_25CA0 )
  {
    v7 = qword_25C98;
    if ( !qword_25C98 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v10 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v10);
      qword_25C98 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "getBytes",
           "(Ljava/lang/String;)[B");
    qword_25CA0 = v5;
    if ( !v5 )
      return 0;
  }
  v11 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v11(a1, a2, v5, v8);
}
// 25C98: using guessed type __int64 qword_25C98;
// 25CA0: using guessed type __int64 qword_25CA0;

//----- (000000000001449C) ----------------------------------------------------
__int64 Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaInit()
{
  return (unsigned int)(__int16)DRM_Init();
}

//----- (00000000000144B8) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaPfdOpen(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        int a5)
{
  __int64 result; // x0

  result = 4294967261LL;
  if ( a5 == 1 && a3 >= 1 && (unsigned int)(a4 - 1) <= 3 )
    return (unsigned int)(__int16)DRM_Open_Pfd(a3, a4, 1);
  return result;
}

//----- (00000000000144FC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaPathOpen(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        int a5)
{
  __int64 v9; // x23
  int v10; // w0
  __int64 result; // x0
  int v12; // w24
  char v13; // [xsp+6h] [xbp-20Ah] BYREF
  char s[513]; // [xsp+7h] [xbp-209h] BYREF
  __int64 v15; // [xsp+208h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  if ( !a3 )
    return 4294967261LL;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1472LL))(a1, a3, &v13);
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  if ( v10 > 512 )
    return 4294957297LL;
  v12 = v10;
  DHmemcpy_s((__int64)s, 512, v9, v10);
  s[v12] = 0;
  DHstrlen(s);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v9, 0);
  result = 4294967261LL;
  if ( (unsigned int)(a4 - 1) <= 3 && a5 == 1 )
    return (unsigned int)(__int16)DRM_Open_Path(s, a4, 1);
  return result;
}

//----- (0000000000014638) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaClose(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  return (unsigned int)(__int16)DRM_Close(a3);
}

//----- (0000000000014654) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetErrorCode(
        __int64 a1,
        __int64 a2,
        unsigned __int16 a3)
{
  __int16 ContentInfo; // w0
  int *v6[2]; // [xsp+0h] [xbp-10h] BYREF

  v6[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  ContentInfo = DRM_GetContentInfo(a3, v6);
  if ( ContentInfo < 0 )
    return ContentInfo;
  else
    return *((__int16 *)v6[0] + 30);
}

//----- (00000000000146B8) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetUnsupportedValue(
        __int64 *a1,
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v7; // x8
  __int64 (__fastcall *v8)(__int64 *, __int64, _QWORD); // x8
  __int64 v9; // x22
  unsigned int v10; // w0
  unsigned int v11; // w8
  unsigned int v12; // w3
  __int64 result; // x0
  int v14; // w0
  int DCFMetaDataEncodingType; // w8
  size_t v16; // x21
  __int64 v17; // x20
  __int64 v18; // x0
  __int64 v19; // x2
  __int64 v20; // x8
  __int64 v21; // x0
  __int64 v22; // x8
  __int64 v23; // x1
  __int64 *v24; // x0
  __int64 v25; // x8
  __int64 v26; // x20
  __int64 v27; // x21
  __int64 v28; // x1
  __int64 (__fastcall *v29)(__int64 *, __int64, __int64, __int64); // x22
  __int64 v30; // x0
  unsigned __int64 v31; // x9
  _OWORD *v32; // x11
  _OWORD *v33; // x12
  __int128 v34; // q1
  __int64 v35; // x9
  __int64 v36; // x0
  char v37; // [xsp+0h] [xbp-1130h] BYREF
  _OWORD v38[16]; // [xsp+1000h] [xbp-130h] BYREF
  _OWORD v39[2]; // [xsp+1100h] [xbp-30h] BYREF
  __int64 v40; // [xsp+1128h] [xbp-8h]

  v40 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  memset(v39, 0, sizeof(v39));
  v8 = *(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 1352);
  memset(v38, 0, sizeof(v38));
  v9 = v8(a1, a4, 0);
  v10 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  v11 = v10 - 33;
  v12 = v10;
  result = 0;
  if ( v11 >= 0xFFFFFFE0 )
  {
    v14 = DHstrncpy_s((__int64)v39, 32, v9, v12);
    if ( v14 )
    {
      StrErrorReturn(v14);
      return 0;
    }
    (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1360))(a1, a4, v9);
    if ( (DRM_GetUnsupportedValue(a3, v39, v38) & 0x8000) == 0 )
    {
      DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
      if ( DCFMetaDataEncodingType == 3 )
      {
        memset(&v37, 0, 0x1000u);
        v25 = 3;
        if ( LOWORD(v38[0]) ^ 0xBBEF | BYTE2(v38[0]) ^ 0xBF )
          v25 = 0;
        __strcpy_chk(&v37, (unsigned __int64)v38 | v25, 4096);
        v26 = (*(__int64 (__fastcall **)(__int64 *, char *))(*a1 + 1336))(a1, &v37);
        v27 = qword_25CA0;
        if ( qword_25CA0
          || ((v28 = qword_25C98) != 0
           || (v36 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "java/lang/String")) != 0
           && (v28 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, v36), (qword_25C98 = v28) != 0))
          && (v27 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
                      a1,
                      v28,
                      "getBytes",
                      "(Ljava/lang/String;)[B"),
              (qword_25CA0 = v27) != 0) )
        {
          v29 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 272);
          v30 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 1336))(a1, "ksc-5601");
          v17 = v29(a1, v26, v27, v30);
        }
        else
        {
          v17 = 0;
        }
        v22 = *a1;
        v24 = a1;
        v23 = v17;
        goto LABEL_20;
      }
      if ( !DCFMetaDataEncodingType )
      {
        v16 = __strlen_chk((const char *)v38, 0x100u);
        v17 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v16);
        v18 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 1472))(a1);
        v19 = v18;
        if ( (__int64)v16 >= 1 )
        {
          v20 = 0;
          if ( v16 >= 8 && (unsigned __int64)(v18 - (_QWORD)v38) >= 0x20 )
          {
            if ( v16 < 0x20 )
            {
              v20 = 0;
              goto LABEL_27;
            }
            v31 = 0;
            v20 = v16 & 0x7FFFFFFFFFFFFFE0LL;
            do
            {
              v32 = &v38[v31 / 0x10];
              v33 = (_OWORD *)(v18 + v31);
              v31 += 32LL;
              v34 = v32[1];
              *v33 = *v32;
              v33[1] = v34;
            }
            while ( v20 != v31 );
            if ( v16 == v20 )
              goto LABEL_21;
            if ( (v16 & 0x18) != 0 )
            {
LABEL_27:
              v35 = v20;
              v20 = v16 & 0x7FFFFFFFFFFFFFF8LL;
              do
              {
                *(_QWORD *)(v18 + v35) = *(_QWORD *)((char *)v38 + v35);
                v35 += 8;
              }
              while ( v20 != v35 );
              if ( v16 == v20 )
                goto LABEL_21;
              goto LABEL_30;
            }
          }
          do
          {
LABEL_30:
            *(_BYTE *)(v18 + v20) = *((_BYTE *)v38 + v20);
            ++v20;
          }
          while ( v16 != v20 );
        }
LABEL_21:
        (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v17, v19, 0);
        return v17;
      }
    }
    v21 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, 0);
    v22 = *a1;
    v23 = v21;
    v24 = a1;
    v17 = v23;
LABEL_20:
    v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v22 + 1472))(v24, v23, 0);
    goto LABEL_21;
  }
  return result;
}
// 1CFA0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 25C98: using guessed type __int64 qword_25C98;
// 25CA0: using guessed type __int64 qword_25CA0;

//----- (0000000000014A84) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaSetClientID(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v5; // w0
  __int64 result; // x0
  unsigned int v7; // w21
  __int64 v8; // x22
  int v9; // w0
  __int64 v10; // [xsp+8h] [xbp-18h] BYREF
  int v11; // [xsp+10h] [xbp-10h]
  __int64 v12; // [xsp+18h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11 = 0;
  v10 = 0;
  if ( !a3 )
    return -35;
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3);
  if ( v5 - 12 < 0xFFFFFFFE )
    return -35;
  v7 = v5;
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  v9 = DHstrncpy_s((__int64)&v10, 12, v8, v7);
  if ( v9 )
  {
    LODWORD(result) = StrErrorReturn(v9);
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, a3, v8);
    LODWORD(result) = DRM_SetClientID();
  }
  return (int)result;
}

//----- (0000000000014B74) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetBufferSizeForAlbumArt(
        __int64 a1,
        __int64 a2,
        unsigned int a3)
{
  int v3; // w0
  char *v4; // x20
  int BufferSizeForAlbumArt; // w0
  int v6; // w19
  int v8; // [xsp+4h] [xbp-1Ch] BYREF
  int v9; // [xsp+8h] [xbp-18h] BYREF
  int v10; // [xsp+Ch] [xbp-14h] BYREF
  char *v11[2]; // [xsp+10h] [xbp-10h] BYREF

  v11[1] = *(char **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11[0] = 0;
  v3 = sub_14C18(a3, v11, &v10);
  if ( v3 < 0 )
  {
    v4 = v11[0];
    v6 = v3;
    if ( !v11[0] )
      return v6;
    goto LABEL_6;
  }
  v4 = v11[0];
  v8 = 0;
  v9 = 0;
  BufferSizeForAlbumArt = DRM_GetBufferSizeForAlbumArt((__int64)v11[0], &v9, &v8);
  if ( BufferSizeForAlbumArt >= 0 )
    v6 = v9;
  else
    v6 = BufferSizeForAlbumArt;
  if ( v4 )
LABEL_6:
    DHfree(v4);
  return v6;
}

//----- (0000000000014C18) ----------------------------------------------------
__int64 __fastcall sub_14C18(unsigned int a1, char **a2, _DWORD *a3)
{
  char *v6; // x0
  __int64 result; // x0
  char *v8; // x0
  int v9; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v10; // [xsp+8h] [xbp-8h]

  v10 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v9 = 0;
  v6 = (char *)DHmalloc(16);
  *a2 = v6;
  if ( !v6 )
    return 4294967261LL;
  result = DRM_Seek(a1, 0, 3);
  if ( (result & 0x80000000) == 0 )
  {
    result = DRM_Read(a1, *a2, 16);
    if ( (result & 0x80000000) == 0 )
    {
      result = DRM_GetID3HeaderDataSize((__int64)*a2, &v9);
      if ( (result & 0x80000000) == 0 )
      {
        if ( *a2 )
          DHfree(*a2);
        v8 = (char *)DHmalloc(v9);
        *a2 = v8;
        if ( v8 )
        {
          result = DRM_Seek(a1, 0, 3);
          if ( (result & 0x80000000) == 0 )
          {
            result = DRM_Read(a1, *a2, v9);
            if ( (result & 0x80000000) == 0 )
              *a3 = result;
          }
        }
        else
        {
          return 4294957420LL;
        }
      }
    }
  }
  return result;
}

//----- (0000000000014D10) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaExtractAlbumArt(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4)
{
  char *v7; // x20
  char *v8; // x22
  __int64 v9; // x23
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x21
  int v14; // [xsp+4h] [xbp-1Ch] BYREF
  unsigned int v15; // [xsp+8h] [xbp-18h] BYREF
  int v16; // [xsp+Ch] [xbp-14h] BYREF
  char *v17[2]; // [xsp+10h] [xbp-10h] BYREF

  v17[1] = *(char **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v17[0] = 0;
  sub_14C18(a3, v17, &v16);
  v7 = v17[0];
  v14 = 0;
  v15 = 0;
  DRM_GetBufferSizeForAlbumArt((__int64)v17[0], &v15, &v14);
  v8 = (char *)DHmalloc(v15);
  DRM_Seek(a3, v14, 3);
  DRM_Read(a3, v8, v15);
  v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(a1, v15);
  (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, char *))(*(_QWORD *)a1 + 1664LL))(a1, v9, 0, v15, v8);
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 248LL))(a1, a4);
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v10,
          "put",
          "([B)Ljava/nio/ByteBuffer;");
  if ( v11 )
  {
    (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, a4, v11, v9);
    v12 = (int)v15;
    if ( !v9 )
      goto LABEL_4;
    goto LABEL_3;
  }
  v12 = -12;
  if ( v9 )
LABEL_3:
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v9);
LABEL_4:
  DHfree(v8);
  if ( v7 )
    DHfree(v7);
  return v12;
}

//----- (0000000000014E94) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaTextValueFromID3(
        __int64 *a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4)
{
  __int64 v7; // x8
  __int64 (__fastcall *v8)(__int64 *, __int64, _QWORD); // x8
  __int64 v9; // x22
  unsigned int v10; // w0
  int v11; // w0
  __int64 v12; // x1
  __int64 v13; // x20
  __int64 v14; // x0
  __int64 i; // x8
  int v17; // [xsp+4h] [xbp-2Ch] BYREF
  char *v18; // [xsp+8h] [xbp-28h] BYREF
  unsigned int v19; // [xsp+14h] [xbp-1Ch] BYREF
  _BYTE *v20; // [xsp+18h] [xbp-18h] BYREF
  int v21; // [xsp+20h] [xbp-10h] BYREF
  char v22; // [xsp+24h] [xbp-Ch]
  __int64 v23; // [xsp+28h] [xbp-8h]

  v23 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  v22 = 0;
  v21 = 0;
  v8 = *(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 1352);
  v20 = 0;
  v19 = 0;
  v9 = v8(a1, a4, 0);
  v10 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  v11 = DHstrncpy_s((__int64)&v21, 5, v9, v10);
  if ( v11 )
  {
    StrErrorReturn(v11);
LABEL_3:
    v12 = 0;
    goto LABEL_6;
  }
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1360))(a1, a4, v9);
  v18 = 0;
  if ( (sub_14C18(a3, &v18, &v17) & 0x80000000) != 0 )
    goto LABEL_3;
  DRM_GetMetaTextValueFromID3((__int64)v18, (char *)&v21, (__int64 *)&v20, (int *)&v19);
  v12 = v19;
LABEL_6:
  v13 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1408))(a1, v12);
  v14 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v13, 0);
  if ( (int)v19 >= 1 )
  {
    for ( i = 0; i < (int)v19; ++i )
      *(_BYTE *)(v14 + i) = v20[i];
  }
  if ( v13 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v13, v14, 0);
  if ( v20 )
    DHfree(v20);
  if ( v18 )
    DHfree(v18);
  return v13;
}

//----- (000000000001502C) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetUnsupportedValueUTF8(
        __int64 *a1,
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v7; // x8
  __int64 v8; // x22
  signed int v9; // w0
  __int64 result; // x0
  int v11; // w0
  __int64 v12; // x8
  int DCFMetaDataEncodingType; // w8
  size_t v14; // x21
  __int64 v15; // x20
  __int64 v16; // x0
  __int64 v17; // x2
  __int64 v18; // x8
  _OWORD *v19; // x10
  __int128 *v20; // x9
  __int64 v21; // x11
  __int128 v22; // q0
  __int128 v23; // q1
  __int64 v24; // x11
  __int64 *v25; // x9
  _QWORD *v26; // x10
  size_t v27; // x11
  __int64 v28; // t1
  _BYTE *v29; // x9
  char *v30; // x10
  size_t v31; // x8
  char v32; // t1
  __int64 v33; // x21
  __int64 v34; // x1
  __int64 v35; // x22
  __int64 (__fastcall *v36)(__int64 *, __int64, __int64, __int64, __int64); // x24
  __int64 v37; // x0
  __int64 v38; // x21
  __int128 v39; // [xsp+0h] [xbp-130h] BYREF
  _OWORD v40[15]; // [xsp+10h] [xbp-120h] BYREF
  _OWORD v41[2]; // [xsp+100h] [xbp-30h] BYREF
  __int64 v42; // [xsp+128h] [xbp-8h]

  v42 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  memset(v41, 0, sizeof(v41));
  v39 = 0u;
  memset(v40, 0, sizeof(v40));
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 1352))(a1, a4, 0);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  if ( v9 <= 0 || (unsigned int)v9 >= 0x21 )
    return (*(__int64 (__fastcall **)(__int64 *, void *))(*a1 + 1336))(a1, &unk_4AA5);
  v11 = DHstrncpy_s((__int64)v41, 32, v8, v9);
  v12 = *a1;
  if ( v11 )
    return (*(__int64 (__fastcall **)(__int64 *, void *))(v12 + 1336))(a1, &unk_4AA5);
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(v12 + 1360))(a1, a4, v8);
  if ( (DRM_GetUnsupportedValue(a3, v41, &v39) & 0x8000) != 0 )
    goto LABEL_13;
  DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
  if ( DCFMetaDataEncodingType == 3 )
    return (*(__int64 (__fastcall **)(__int64 *, __int128 *))(*a1 + 1336))(a1, &v39);
  if ( DCFMetaDataEncodingType )
  {
LABEL_13:
    v12 = *a1;
    return (*(__int64 (__fastcall **)(__int64 *, void *))(v12 + 1336))(a1, &unk_4AA5);
  }
  v14 = __strlen_chk((const char *)&v39, 0x100u);
  v15 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v14);
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v15, 0);
  v17 = v16;
  if ( (__int64)v14 >= 1 )
  {
    v18 = 0;
    if ( v14 >= 8 && (unsigned __int64)(v16 - (_QWORD)&v39) >= 0x20 )
    {
      if ( v14 < 0x20 )
      {
        v18 = 0;
        goto LABEL_21;
      }
      v18 = v14 & 0x7FFFFFFFFFFFFFE0LL;
      v19 = (_OWORD *)(v16 + 16);
      v20 = v40;
      v21 = v14 & 0x7FFFFFFFFFFFFFE0LL;
      do
      {
        v22 = *(v20 - 1);
        v23 = *v20;
        v21 -= 32;
        v20 += 2;
        *(v19 - 1) = v22;
        *v19 = v23;
        v19 += 2;
      }
      while ( v21 );
      if ( v14 == v18 )
        goto LABEL_26;
      if ( (v14 & 0x18) != 0 )
      {
LABEL_21:
        v24 = v18;
        v18 = v14 & 0x7FFFFFFFFFFFFFF8LL;
        v25 = (__int64 *)((char *)&v40[-1] + v24);
        v26 = (_QWORD *)(v16 + v24);
        v27 = v24 - (v14 & 0x7FFFFFFFFFFFFFF8LL);
        do
        {
          v28 = *v25++;
          v27 += 8LL;
          *v26++ = v28;
        }
        while ( v27 );
        if ( v14 == v18 )
          goto LABEL_26;
      }
    }
    v29 = (_BYTE *)(v16 + v18);
    v30 = (char *)&v40[-1] + v18;
    v31 = v14 - v18;
    do
    {
      v32 = *v30++;
      --v31;
      *v29++ = v32;
    }
    while ( v31 );
  }
LABEL_26:
  if ( v15 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v15, v16, 0);
  v33 = qword_25C90;
  if ( qword_25C90 )
    goto LABEL_31;
  v34 = qword_25C98;
  if ( qword_25C98
    || (result = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 48))(a1, "java/lang/String", v17)) != 0
    && (result = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, result),
        v34 = result,
        (qword_25C98 = result) != 0) )
  {
    result = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
               a1,
               v34,
               "<init>",
               "([BLjava/lang/String;)V");
    v33 = result;
    qword_25C90 = result;
    if ( result )
    {
LABEL_31:
      v35 = qword_25C98;
      v36 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64, __int64))(*a1 + 224);
      v37 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 1336))(a1, "ksc-5601", v17);
      result = v36(a1, v35, v33, v15, v37);
    }
  }
  if ( v15 )
  {
    v38 = result;
    (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 184))(a1, v15);
    return v38;
  }
  return result;
}
// 15338: variable 'v17' is possibly undefined
// 25C90: using guessed type __int64 qword_25C90;
// 25C98: using guessed type __int64 qword_25C98;

//----- (00000000000153BC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaTextValueFromID3UTF8(
        __int64 *a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4)
{
  __int64 v7; // x8
  __int64 (__fastcall *v8)(__int64 *, __int64, _QWORD); // x8
  __int64 v9; // x22
  unsigned int v10; // w0
  int v11; // w0
  __int64 v12; // x20
  _BYTE *v13; // x21
  bool v15; // zf
  __int64 v16; // x20
  __int64 v17; // x0
  __int64 v18; // x8
  __int64 v19; // x21
  __int64 v20; // x1
  __int64 v21; // x22
  __int64 (__fastcall *v22)(__int64 *, __int64, __int64, __int64, __int64); // x25
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 (__fastcall *v25)(__int64 *, __int64, __int64, __int64); // x22
  __int64 v26; // x3
  __int64 v27; // x20
  __int64 v28; // x21
  __int64 v29; // x1
  __int64 (__fastcall *v30)(__int64 *, __int64, __int64, __int64); // x22
  __int64 v31; // x3
  __int64 v32; // x0
  __int64 v33; // x0
  __int64 v34; // x0
  int v35; // [xsp+4h] [xbp-2Ch] BYREF
  char *v36; // [xsp+8h] [xbp-28h] BYREF
  _BYTE *v37; // [xsp+10h] [xbp-20h] BYREF
  __int64 v38; // [xsp+1Ch] [xbp-14h] BYREF
  char v39; // [xsp+24h] [xbp-Ch]
  __int64 v40; // [xsp+28h] [xbp-8h]

  v40 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  v38 = 0;
  v39 = 0;
  v8 = *(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 1352);
  v37 = 0;
  v9 = v8(a1, a4, 0);
  v10 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  v11 = DHstrncpy_s((__int64)&v38 + 4, 5, v9, v10);
  if ( v11 )
  {
    StrErrorReturn(v11);
LABEL_3:
    v12 = 0;
    v13 = 0;
    goto LABEL_4;
  }
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1360))(a1, a4, v9);
  v36 = 0;
  v35 = 0;
  if ( (sub_14C18(a3, &v36, &v35) & 0x80000000) != 0
    || (DRM_GetMetaTextValueFromID3((__int64)v36, (char *)&v38 + 4, (__int64 *)&v37, (int *)&v38) & 0x80000000) != 0 )
  {
    goto LABEL_3;
  }
  if ( *(__int16 *)v37 == -257 )
  {
    v27 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 1304))(a1);
    v28 = qword_25CA0;
    if ( !qword_25CA0 )
    {
      v29 = qword_25C98;
      if ( !qword_25C98 )
      {
        v32 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "java/lang/String");
        if ( !v32 )
          goto LABEL_47;
        v29 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, v32);
        qword_25C98 = v29;
        if ( !v29 )
          goto LABEL_47;
      }
      v28 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
              a1,
              v29,
              "getBytes",
              "(Ljava/lang/String;)[B");
      qword_25CA0 = v28;
      if ( !v28 )
        goto LABEL_47;
    }
    v30 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 272);
    v31 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 1336))(a1, "utf-8");
    v12 = v30(a1, v27, v28, v31);
    goto LABEL_37;
  }
  if ( *(__int16 *)v37 == -2
    || (*(unsigned __int16 *)v37 == 48111 ? (v15 = (unsigned __int8)v37[2] == 191) : (v15 = 0), v15) )
  {
    v12 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1408))(a1, 1);
    v13 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v12, 0);
    *v13 = 0;
    goto LABEL_4;
  }
  v16 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v38);
  v17 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v16, 0);
  if ( (int)v38 >= 1 )
  {
    v18 = 0;
    do
    {
      *(_BYTE *)(v17 + v18) = v37[v18];
      ++v18;
    }
    while ( v18 < (int)v38 );
  }
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v16, v17, 0);
  v19 = qword_25C90;
  if ( qword_25C90 )
    goto LABEL_25;
  v20 = qword_25C98;
  if ( !qword_25C98 )
  {
    v33 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "java/lang/String");
    if ( !v33 || (v20 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, v33), (qword_25C98 = v20) == 0) )
    {
      v19 = 0;
      if ( !v16 )
        goto LABEL_28;
      goto LABEL_27;
    }
  }
  v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
          a1,
          v20,
          "<init>",
          "([BLjava/lang/String;)V");
  qword_25C90 = v19;
  if ( v19 )
  {
LABEL_25:
    v21 = qword_25C98;
    v22 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64, __int64))(*a1 + 224);
    v23 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 1336))(a1, "ksc-5601");
    v19 = v22(a1, v21, v19, v16, v23);
  }
  if ( v16 )
LABEL_27:
    (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 184))(a1, v16);
LABEL_28:
  v12 = qword_25CA0;
  if ( qword_25CA0 )
    goto LABEL_31;
  v24 = qword_25C98;
  if ( !qword_25C98 )
  {
    v34 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "java/lang/String");
    if ( !v34 || (v24 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, v34), (qword_25C98 = v24) == 0) )
    {
LABEL_47:
      v12 = 0;
      goto LABEL_37;
    }
  }
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
          a1,
          v24,
          "getBytes",
          "(Ljava/lang/String;)[B");
  qword_25CA0 = v12;
  if ( v12 )
  {
LABEL_31:
    v25 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 272);
    v26 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 1336))(a1, "utf-8");
    v12 = v25(a1, v19, v12, v26);
  }
LABEL_37:
  v13 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v12, 0);
LABEL_4:
  if ( v37 )
    DHfree(v37);
  if ( v36 )
    DHfree(v36);
  if ( v12 )
    (*(void (__fastcall **)(__int64 *, __int64, _BYTE *, _QWORD))(*a1 + 1536))(a1, v12, v13, 0);
  return v12;
}
// 25C90: using guessed type __int64 qword_25C90;
// 25C98: using guessed type __int64 qword_25C98;
// 25CA0: using guessed type __int64 qword_25CA0;

//----- (0000000000015880) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMMetaInterface_DRMMetaGetMetaDataCharacterSet(
        __int64 a1,
        __int64 a2,
        __int16 a3)
{
  return (unsigned int)(__int16)DRM_GetDCFMetaDataEncodingType(a3);
}

//----- (000000000001589C) ----------------------------------------------------
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  int v10; // w26
  int v11; // w24
  char *v12; // x24
  unsigned int v13; // w27
  char v14; // w19
  int v15; // w0
  int v16; // w25
  void *v17; // x0
  int v18; // w22
  char *v19; // x19
  int v20; // w23
  __int64 v21; // x20
  int v22; // w8
  int v23; // w28
  int v24; // w19
  int v25; // w19
  void *v26; // x0
  void *v27; // x0
  int v28; // w19
  void *v29; // x0
  int v30; // w19
  void *v31; // x0
  unsigned int v32; // w0
  void *v33; // x0
  int v34; // w19
  int v35; // w19
  void *v36; // x0
  int v37; // w27
  void *v38; // x0
  int v39; // w19
  unsigned int v40; // w27
  __int64 v41; // x28
  void *v42; // x0
  __int64 v43; // x19
  unsigned int v44; // w27
  void *v45; // x0
  __int64 v46; // x8
  __int64 v47; // x9
  unsigned __int16 v48; // w19
  __int64 v49; // x19
  __int64 v50; // x28
  unsigned __int64 v51; // x19
  __int64 v52; // x8
  int v53; // w19
  void *v54; // x0
  unsigned int v55; // w19
  void *v56; // x0
  __int64 v57; // x8
  void *v58; // x0
  int v59; // w8
  __int16 **v60; // x3
  int v61; // w19
  int v62; // w25
  unsigned int v63; // w0
  int v64; // w0
  int v65; // w0
  int v66; // w0
  int v67; // w0
  int v68; // w0
  int v69; // w0
  int v70; // w0
  int v71; // w0
  int v72; // w0
  unsigned int v73; // w19
  __int64 v74; // x8
  __int64 v75; // x23
  unsigned int v76; // w26
  int8x16_t *v77; // x19
  char *v78; // x27
  __int64 i; // x23
  unsigned int v80; // w0
  int v81; // w0
  int v83; // w0
  int v84; // w19
  char *v85; // x0
  unsigned int v86; // w0
  unsigned int v87; // w19
  _BYTE *v88; // x0
  _BYTE *v89; // x19
  unsigned int v90; // w23
  int v91; // w23
  int8x16_t *v92; // x0
  int8x16_t *v93; // x23
  int v94; // w19
  void *v95; // x0
  __int64 v96; // x24
  int v97; // w20
  int v98; // w19
  int v99; // w19
  int v100; // w19
  __int64 v101; // x19
  unsigned int v102; // w0
  void *v103; // x0
  __int64 v104; // x19
  unsigned int v105; // w0
  unsigned __int64 v106; // [xsp+28h] [xbp-408h]
  unsigned __int64 v107; // [xsp+30h] [xbp-400h]
  _DWORD *v108; // [xsp+58h] [xbp-3D8h]
  __int64 *v109; // [xsp+60h] [xbp-3D0h]
  __int64 *v110; // [xsp+60h] [xbp-3D0h]
  _BYTE *v113; // [xsp+80h] [xbp-3B0h]
  int v114; // [xsp+8Ch] [xbp-3A4h] BYREF
  char v115[8]; // [xsp+90h] [xbp-3A0h] BYREF
  __int64 v116; // [xsp+98h] [xbp-398h] BYREF
  _QWORD v117[2]; // [xsp+A0h] [xbp-390h]
  char v118[8]; // [xsp+B0h] [xbp-380h] BYREF
  _QWORD v119[2]; // [xsp+B8h] [xbp-378h]
  __int64 v120; // [xsp+C8h] [xbp-368h] BYREF
  _QWORD v121[2]; // [xsp+D0h] [xbp-360h]
  char v122[32]; // [xsp+E0h] [xbp-350h] BYREF
  char s[16]; // [xsp+100h] [xbp-330h] BYREF
  __int128 v124; // [xsp+110h] [xbp-320h]
  const void *v125[4]; // [xsp+120h] [xbp-310h] BYREF
  __int128 v126; // [xsp+140h] [xbp-2F0h] BYREF
  __int128 v127; // [xsp+150h] [xbp-2E0h]
  __int128 v128; // [xsp+160h] [xbp-2D0h]
  __int128 v129; // [xsp+170h] [xbp-2C0h]
  _DWORD v130[8]; // [xsp+180h] [xbp-2B0h] BYREF
  __int128 v131; // [xsp+1A0h] [xbp-290h]
  __int128 v132; // [xsp+1B0h] [xbp-280h]
  __int128 v133; // [xsp+1C0h] [xbp-270h]
  __int128 v134; // [xsp+1D0h] [xbp-260h]
  __int128 v135; // [xsp+1E0h] [xbp-250h]
  __int128 v136; // [xsp+1F0h] [xbp-240h]
  __int128 v137; // [xsp+200h] [xbp-230h]
  __int128 v138; // [xsp+210h] [xbp-220h]
  __int128 v139; // [xsp+220h] [xbp-210h]
  __int128 v140; // [xsp+230h] [xbp-200h]
  __int128 v141; // [xsp+240h] [xbp-1F0h]
  __int128 v142; // [xsp+250h] [xbp-1E0h]
  __int128 v143; // [xsp+260h] [xbp-1D0h]
  __int128 v144; // [xsp+270h] [xbp-1C0h]
  __int128 v145; // [xsp+280h] [xbp-1B0h]
  __int128 v146; // [xsp+290h] [xbp-1A0h]
  __int128 v147; // [xsp+2A0h] [xbp-190h]
  __int128 v148; // [xsp+2B0h] [xbp-180h]
  __int128 v149; // [xsp+2C0h] [xbp-170h]
  __int128 v150; // [xsp+2D0h] [xbp-160h]
  __int128 v151; // [xsp+2E0h] [xbp-150h]
  __int128 v152; // [xsp+2F0h] [xbp-140h]
  __int64 v153; // [xsp+300h] [xbp-130h] BYREF
  _QWORD v154[2]; // [xsp+308h] [xbp-128h]
  __int64 v155; // [xsp+318h] [xbp-118h] BYREF
  _QWORD v156[2]; // [xsp+320h] [xbp-110h]
  __int128 v157; // [xsp+330h] [xbp-100h] BYREF
  __int128 v158; // [xsp+340h] [xbp-F0h]
  char v159[32]; // [xsp+350h] [xbp-E0h] BYREF
  __int128 v160; // [xsp+370h] [xbp-C0h] BYREF
  __int128 v161; // [xsp+380h] [xbp-B0h]
  _OWORD v162[3]; // [xsp+390h] [xbp-A0h] BYREF
  char v163; // [xsp+3C0h] [xbp-70h]
  int8x16_t v164; // [xsp+3D0h] [xbp-60h] BYREF
  __int128 v165; // [xsp+3E0h] [xbp-50h]
  _BYTE v166[33]; // [xsp+3F0h] [xbp-40h] BYREF
  __int64 v167; // [xsp+418h] [xbp-18h]

  v167 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v122, 0, 26);
  v120 = 0;
  v121[0] = 0;
  *(_QWORD *)((char *)v121 + 5) = 0;
  *(_QWORD *)v118 = 0;
  v119[0] = 0;
  *(_QWORD *)((char *)v119 + 5) = 0;
  v116 = 0;
  v117[0] = 0;
  *(_QWORD *)((char *)v117 + 5) = 0;
  memset(v159, 0, 26);
  v157 = 0u;
  v158 = 0u;
  v161 = 0u;
  memset(v162, 0, 19);
  v160 = 0u;
  v165 = 0u;
  memset(v166, 0, 19);
  v164 = 0u;
  v114 = 50;
  v155 = 0;
  v156[0] = 0;
  *(_QWORD *)((char *)v156 + 5) = 0;
  v154[0] = 0;
  v153 = 0;
  *(_QWORD *)((char *)v154 + 5) = 0;
  memset(v125, 0, sizeof(v125));
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  memset(v130, 0, sizeof(v130));
  v131 = 0u;
  v132 = 0u;
  v133 = 0u;
  v134 = 0u;
  v135 = 0u;
  v136 = 0u;
  v137 = 0u;
  v138 = 0u;
  v139 = 0u;
  v140 = 0u;
  v141 = 0u;
  v142 = 0u;
  v143 = 0u;
  v144 = 0u;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v152 = 0u;
  v124 = 0u;
  *(_OWORD *)s = 0u;
  *(_QWORD *)v115 = 0;
  printLogD();
  DHstrcpy_s((char *)&v157, 32, "melon");
  DHmemset(&v164, 0, 50);
  printLogD();
  v10 = DHGetDeviceID_ConstVal((char *)&v164);
  v11 = DHstrlen((const char *)&v164);
  printLogD();
  v113 = a1;
  if ( v10 )
  {
    v12 = 0;
    v13 = 65333;
    v14 = 1;
  }
  else
  {
    printLogD();
    v60 = (__int16 **)*a6;
    if ( !*a6 )
    {
      v60 = (__int16 **)DHmalloc(14);
      *a6 = v60;
    }
    v61 = DHGetClientID_BySetVal("min", (unsigned int *)&v114, (__int64)&v160, v60);
    printLogD();
    if ( v61 <= 0 )
    {
      DHFreeClientID(*a6);
      v12 = 0;
      *a6 = 0;
      v13 = 65436;
      v14 = 1;
    }
    else
    {
      strcpy(v159, "SS MAC-1 Token Generation");
      v62 = DHstrlen(v159);
      v63 = DHstrlen("ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=");
      DHstrncpy_s((__int64)s, 512, (__int64)"ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=", v63);
      v64 = DHstrlen((const char *)&v157);
      DHstrncat_s(s, 512, (__int64)&v157, v64);
      v65 = DHstrlen("\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:");
      DHstrncat_s(s, 512, (__int64)"\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:", v65);
      v66 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v66);
      v67 = DHstrlen("\ntt=120\nmc=6\nce=MIN:");
      DHstrncat_s(s, 512, (__int64)"\ntt=120\nmc=6\nce=MIN:", v67);
      printLogD();
      v68 = DHstrlen((const char *)&v160);
      DHstrncat_s(s, 512, (__int64)&v160, v68);
      v69 = DHstrlen("\nce=HID:");
      DHstrncat_s(s, 512, (__int64)"\nce=HID:", v69);
      v70 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v70);
      v71 = DHstrlen("\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n");
      DHstrncat_s(s, 512, (__int64)"\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n", v71);
      v72 = DHstrlen(s);
      if ( v72 < 1 )
      {
        v12 = 0;
        v14 = 0;
        v13 = 0;
      }
      else
      {
        v73 = v72;
        v110 = a3;
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)s, (uint32x4_t *)&v155, v73);
        v74 = 2LL * v11;
        v75 = v74 + 37;
        v76 = v62 + v74 + 37;
        v77 = (int8x16_t *)DHmalloc(v11 + 1);
        DHmemset(v77, 0, v11 + 1);
        inverse(&v164, v77, v11);
        v78 = (char *)DHmalloc(v76 + 1);
        DHmemset(v78, 0, v76 + 1);
        DHmemcpy(v78, &v155, 20);
        DHmemcpy(v78 + 20, "SSMAC-1", 7);
        DHmemcpy(v78 + 27, "DEV_SERIAL", 10);
        DHmemcpy(v78 + 37, &v164, v11);
        DHmemcpy(&v78[v11 + 37], v77, v11);
        DHmemcpy(&v78[v75], v159, v62);
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)v78, (uint32x4_t *)&v155, v76);
        DHfree(v78);
        DHfree(v77);
        DHmemset(&v153, 0, 21);
        DHmemset(&v115[4], 0, 4);
        for ( i = 0; i != 10; ++i )
        {
          if ( !DHultoa(*((unsigned __int8 *)&v156[-1] + i), (int8x16_t *)&v115[4], 0x10u) )
            return 0xFFFF;
          if ( (unsigned int)DHstrlen(&v115[4]) == 1 )
          {
            v80 = DHstrlen(&v115[4]);
            DHstrncpy_s((__int64)v115, 4, (__int64)&v115[4], v80);
            DHstrncpy_s((__int64)&v115[4], 4, (__int64)"0", 1u);
            v81 = DHstrlen(v115);
            DHstrncat_s(&v115[4], 4, (__int64)v115, v81);
          }
          DHstrncat_s((char *)&v153, 21, (__int64)&v115[4], 2);
          DHmemset(&v115[4], 0, 4);
        }
        DHfree(&v115[4]);
        DHstrcat();
        DHstrcat();
        DHstrcat();
        v83 = DHstrlen(s);
        a3 = v110;
        if ( v83 < 1 )
        {
          v12 = 0;
          v13 = 65332;
          v14 = 1;
        }
        else
        {
          v84 = v83;
          v85 = (char *)DHmalloc(v83 + 1);
          v12 = v85;
          if ( v85 )
          {
            DHmemset(v85, 0, v84 + 1);
            DHmemcpy(v12, s, v84);
            DHstrlen(v12);
            printLogD();
            v14 = 0;
            v13 = 0;
          }
          else
          {
            v13 = 65514;
            v14 = 1;
          }
        }
      }
    }
  }
  printLogD();
  if ( !v12 || (v14 & 1) != 0 )
    return v13;
  v15 = DHstrlen(v12);
  if ( v15 <= 0 )
  {
    DHfree(v12);
    printLogD();
    return 65336;
  }
  v16 = v15;
  printLogD();
  LOWORD(v130[0]) = 0;
  *(_QWORD *)&v130[3] = 0;
  *(_QWORD *)&v130[1] = 0;
  v124 = 0u;
  memset(v125, 0, 28);
  *(_OWORD *)s = 0u;
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  printLogD();
  v17 = DHmalloc(v16 + 1);
  *(_QWORD *)&v127 = v17;
  if ( !v17 )
  {
    DHfree(v12);
    return 65514;
  }
  v109 = a3;
  DHmemset(v17, 0, v16 + 1);
  printLogD();
  memset(v159, 0, 17);
  v161 = 0u;
  memset(v162, 0, sizeof(v162));
  v164 = 0u;
  v165 = 0u;
  memset(v166, 0, sizeof(v166));
  v163 = 0;
  v160 = 0u;
  v157 = 0u;
  LODWORD(v158) = 0;
  LOWORD(v156[0]) = 0;
  v155 = 0;
  LODWORD(v153) = 0;
  v114 = 0;
  printLogD();
  printLogD();
  v18 = 0;
  v19 = v12;
  v20 = v16;
  v108 = a5;
  do
  {
    DHmemset(&v160, 0, 80);
    printLogD();
    v21 = 0;
    v22 = (unsigned __int8)*v19;
    if ( *v19 )
    {
      do
      {
        if ( v22 == 10 )
          break;
        if ( v21 == 81 )
          goto LABEL_77;
        *((_BYTE *)&v160 + v21++) = v22;
        v22 = (unsigned __int8)v19[v21];
      }
      while ( v19[v21] );
    }
    v23 = v21 + 1;
    *((_BYTE *)&v160 + v21) = 0;
    printLogD();
    v13 = sub_1764C((unsigned __int8 *)&v160, (int)v21 + 1, v159, (int *)&v153, &v164, &v114);
    if ( (_WORD)v13 || (v24 = v153, (int)v153 < 2) )
    {
      if ( !(_WORD)v13 )
        goto LABEL_90;
      goto LABEL_78;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ve", v153) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v26 = DHmalloc(v114 + 1);
      *(_QWORD *)s = v26;
      if ( !v26 )
        goto LABEL_97;
      DHmemset(v26, 0, v25 + 1);
      v27 = *(void **)s;
LABEL_29:
      DHmemcpy(v27, &v164, v25);
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "sn", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v28 = v114;
      v29 = DHmalloc(v114 + 1);
      *(_QWORD *)&s[8] = v29;
      if ( !v29 )
        goto LABEL_97;
      DHmemset(v29, 0, v28 + 1);
      DHmemcpy(*(void **)&s[8], &v164, v28);
      HIDWORD(v127) = v28;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "am", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v30 = v114;
      v31 = DHmalloc(v114 + 1);
      *(_QWORD *)&v126 = v31;
      if ( !v31 )
        goto LABEL_97;
      DHmemset(v31, 0, v30 + 1);
      DHmemcpy((void *)v126, &v164, v30);
      DWORD2(v127) = v30;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "dl", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v32 = sub_17524((__int64)&v164, v114, (__int64 **)&v126 + 1);
      if ( !(_WORD)v32 )
        goto LABEL_65;
      v13 = v32;
LABEL_78:
      DHfree(v12);
      sub_172A0((__int64)s);
      printLogD();
      return v13;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ci", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v33 = DHmalloc(v114 + 1);
      *(_QWORD *)&v124 = v33;
      if ( !v33 )
        goto LABEL_97;
      DHmemset(v33, 0, v25 + 1);
      v27 = (void *)v124;
      goto LABEL_29;
    }
    if ( (unsigned int)DHstrnicmp(v159, "rd", v24) )
    {
      if ( !(unsigned int)DHstrnicmp(v159, "tt", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        LODWORD(v125[3]) = 3600 * DHatoi();
        goto LABEL_65;
      }
      if ( !(unsigned int)DHstrnicmp(v159, "mc", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        DWORD2(v128) = DHatoi();
        goto LABEL_65;
      }
      if ( (unsigned int)DHstrnicmp(v159, "ce", v24) )
      {
        if ( (unsigned int)DHstrnicmp(v159, "vp", v24) )
        {
          if ( (unsigned int)DHstrnicmp(v159, "sa", v24) )
          {
            if ( (unsigned int)DHstrnicmp(v159, "sv", v24) )
            {
              v130[4] += v21 + 1;
              DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
              *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
              goto LABEL_65;
            }
            v25 = v114;
            v58 = DHmalloc(v114 + 1);
            v125[2] = v58;
            if ( !v58 )
              goto LABEL_97;
            DHmemset(v58, 0, v25 + 1);
            v27 = (void *)v125[2];
            goto LABEL_29;
          }
          v53 = v114;
          v54 = DHmalloc(v114 + 1);
          v125[1] = v54;
          if ( !v54 )
            goto LABEL_97;
          DHmemset(v54, 0, v53 + 1);
          DHmemcpy((void *)v125[1], &v164, v53);
          v130[3] = v53;
        }
        else
        {
          v130[4] += v21 + 1;
          DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
          *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164, 4);
          v48 = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_u8[4], 2);
          v49 = v48 | ((unsigned __int16)DHatoi() << 16);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (char *)&v164.n128_i32[1] + 2, 2);
          v50 = (unsigned __int16)DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_i8[8], 2);
          v51 = v49 | (DHatoi() << 48) | (v50 << 32);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xA), 2);
          LOWORD(v50) = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xC), 2);
          v52 = (unsigned __int16)v50 | ((unsigned __int16)DHatoi() << 16);
          if ( LOWORD(v130[0]) )
          {
            v107 = v107 & 0xFFFFFFFF00000000LL | v52;
            v130[2] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 2;
          }
          else
          {
            v106 = v106 & 0xFFFFFFFF00000000LL | v52;
            v130[1] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 1;
          }
          printLogD();
          printLogD();
        }
      }
      else
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        if ( ++HIDWORD(v128) > DWORD2(v128) )
        {
LABEL_77:
          printLogD();
          v13 = 65335;
          goto LABEL_78;
        }
        DHmemset(&v160, 0, 80);
        v39 = v114;
        DHmemcpy(&v160, &v164, v114);
        sub_1764C((unsigned __int8 *)&v160, v39 + 1, v159, (int *)&v153, &v164, &v114);
        v40 = v153;
        if ( !(unsigned int)DHstrnicmp(v159, "min", v153) )
        {
          LODWORD(v129) = v129 + 1;
          if ( v164.n128_u8[0] == 48 && v114 == 11 )
          {
            DHmemset(&v157, 0, 20);
            DHstrncpy_s((__int64)&v157, 20, (__int64)v164.n128_i64 + 1, 0xAu);
            DHmemset(&v164, 0, 11);
            DHstrncpy_s((__int64)&v164, 65, (__int64)&v157, 0xAu);
            v114 = 10;
          }
        }
        v41 = *((_QWORD *)&v129 + 1);
        v42 = DHmalloc(40);
        v43 = (__int64)v42;
        if ( v41 )
        {
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, v40 + 1);
          DHstrncpy_s(v43, 16, (__int64)v159, v40);
          v44 = v114;
          v45 = DHmalloc(v114 + 1);
          *(_QWORD *)(v43 + 16) = v45;
          if ( !v45 )
            goto LABEL_97;
          DHmemset(v45, 0, v44 + 1);
          DHstrncpy_s(*(_QWORD *)(v43 + 16), v44 + 1, (__int64)&v164, v44);
          *(_DWORD *)(v43 + 24) = v44;
          *(_QWORD *)(v43 + 32) = 0;
          v46 = *((_QWORD *)&v129 + 1);
          do
          {
            v47 = v46;
            v46 = *(_QWORD *)(v46 + 32);
          }
          while ( v46 );
          *(_QWORD *)(v47 + 32) = v43;
        }
        else
        {
          *((_QWORD *)&v129 + 1) = v42;
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, 16);
          DHstrncpy_s(*((__int64 *)&v129 + 1), 16, (__int64)v159, v40);
          v55 = v114;
          v56 = DHmalloc(v114 + 1);
          *(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL) = v56;
          if ( !v56 )
            goto LABEL_97;
          DHmemset(v56, 0, v55 + 1);
          DHstrncpy_s(*(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL), v40 + 1, (__int64)&v164, v55);
          v57 = *((_QWORD *)&v129 + 1);
          *(_DWORD *)(*((_QWORD *)&v129 + 1) + 24LL) = v55;
          *(_QWORD *)(v57 + 32) = 0;
        }
      }
    }
    else
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      DHmemset(&v160, 0, 80);
      v34 = v114;
      DHmemcpy(&v160, &v164, v114);
      sub_1764C((unsigned __int8 *)&v160, v34 + 1, v159, (int *)&v153, &v164, &v114);
      v35 = v153;
      v36 = DHmalloc((int)v153 + 1);
      *((_QWORD *)&v124 + 1) = v36;
      if ( !v36
        || (DHmemset(v36, 0, v35 + 1),
            DHmemcpy(*((void **)&v124 + 1), v159, v35),
            v37 = v114,
            LODWORD(v128) = v35,
            v38 = DHmalloc(v114 + 1),
            (v125[0] = v38) == 0) )
      {
LABEL_97:
        v13 = 65514;
        goto LABEL_78;
      }
      DHmemset(v38, 0, v37 + 1);
      DHmemcpy((void *)v125[0], &v164, v37);
      DWORD1(v128) = v37;
    }
LABEL_65:
    v59 = v20 - 1;
    v18 += 1 + v21;
    v20 = v20 - 1 - v21;
    v19 = &v12[v18];
  }
  while ( v59 - (int)v21 > 0 );
  printLogD();
LABEL_90:
  printLogD();
  DHfree(v12);
  if ( !v125[0] || !v125[1] || !*(_QWORD *)&s[8] || !(_QWORD)v126 )
  {
    sub_172A0((__int64)s);
    printLogD();
    return 65335;
  }
  printLogD();
  if ( v113 )
  {
    if ( (unsigned int)DHstrnicmp(v113, *(_BYTE **)&s[8], SHIDWORD(v127)) )
    {
LABEL_100:
      sub_172A0((__int64)s);
      goto LABEL_101;
    }
  }
  else if ( (unsigned int)DHstrnicmp("MELON", *(_BYTE **)&s[8], SHIDWORD(v127)) )
  {
    goto LABEL_100;
  }
  printLogD();
  v86 = DHcurrentTime();
  if ( !v86 )
  {
    sub_172A0((__int64)s);
    return 65433;
  }
  v87 = v86;
  printLogD();
  if ( LOWORD(v130[0]) == 1 )
  {
    if ( v87 > v130[1] )
      goto LABEL_105;
LABEL_109:
    printLogD();
    v88 = DHmalloc(50);
    if ( v88 )
    {
      v89 = v88;
      DHmemset(v88, 0, 50);
      if ( (unsigned int)DHGetDeviceID_ConstVal(v89) )
      {
        DHfree(v89);
        sub_172A0((__int64)s);
        DHstrlen(v89);
        printLogD();
        return 65333;
      }
      v90 = DHstrlen(v89);
      if ( v90 > 0x32 || v90 != DWORD1(v128) )
      {
        DHfree(v89);
        sub_172A0((__int64)s);
        printLogD();
        return 65333;
      }
      printLogD();
      printLogD();
      v91 = DHstrnicmp(v89, (_BYTE *)v125[0], SDWORD1(v128));
      DHfree(v89);
      if ( v91 )
      {
        sub_172A0((__int64)s);
        printLogD();
LABEL_101:
        printLogD();
        return 65335;
      }
      printLogD();
      strcpy(v122, "SS MAC-1 Token Generation");
      printLogD();
      DA_DRM_HASH_SHA1Digest(v127, (uint32x4_t *)&v120, v130[4]);
      printLogD();
      v92 = (int8x16_t *)DHmalloc(DWORD1(v128) + 1);
      if ( v92 )
      {
        v93 = v92;
        DHmemset(v92, 0, DWORD1(v128) + 1);
        inverse((int8x16_t *)v125[0], v93, SDWORD1(v128));
        v94 = v130[3] + v128 + 2 * DWORD1(v128);
        v95 = DHmalloc(v94 + 46);
        if ( v95 )
        {
          v96 = (__int64)v95;
          v97 = v94 + 20;
          DHmemset(v95, 0, v94 + 46);
          DHmemcpy((void *)v96, &v120, 20);
          DHmemcpy((void *)(v96 + 20), v125[1], v130[3]);
          v98 = v130[3] + 20;
          DHmemcpy((void *)(v96 + v130[3] + 20), *((const void **)&v124 + 1), v128);
          v99 = v128 + v98;
          DHmemcpy((void *)(v96 + v99), v125[0], SDWORD1(v128));
          v100 = DWORD1(v128) + v99;
          DHmemcpy((void *)(v96 + v100), v93, SDWORD1(v128));
          DHmemcpy((void *)(v96 + DWORD1(v128) + v100), v122, 25);
          printLogD();
          printLogD();
          DA_DRM_HASH_SHA1Digest(v96, (uint32x4_t *)v118, v97 + 25);
          printLogD();
          DHsprintf_s(
            (char *)&v116,
            21,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            (unsigned __int8)v118[0],
            (unsigned __int8)v118[1],
            (unsigned __int8)v118[2],
            (unsigned __int8)v118[3],
            (unsigned __int8)v118[4],
            v118[5]);
          printLogD();
          DHfree(v93);
          DHfree((void *)v96);
          if ( (unsigned int)DHstrncmp((const char *)v125[2], (const char *)&v116, 20) )
          {
            printLogD();
            sub_172A0((__int64)s);
            return 65335;
          }
          printLogD();
          v101 = *((_QWORD *)&v129 + 1);
          if ( *((_QWORD *)&v129 + 1) )
          {
            while ( 1 )
            {
              v102 = sub_173DC(v101, a2);
              if ( (_WORD)v102 )
                break;
              v101 = *(_QWORD *)(v101 + 32);
              if ( !v101 )
                goto LABEL_129;
            }
            v13 = v102;
          }
          else
          {
LABEL_129:
            v103 = DHmalloc(DWORD2(v127) + 1);
            *v109 = (__int64)v103;
            if ( !v103 )
            {
              if ( *a2 )
                ClientIDDestroy((_QWORD *)*a2);
              sub_172A0((__int64)s);
              return 65514;
            }
            DHmemset(v103, 0, DWORD2(v127) + 1);
            DHstrncpy_s(*v109, DWORD2(v127) + 1, v126, DWORD2(v127));
            v104 = *((_QWORD *)&v126 + 1);
            if ( !*((_QWORD *)&v126 + 1) )
            {
LABEL_133:
              *v108 = v125[3];
              sub_172A0((__int64)s);
              return 0;
            }
            while ( 1 )
            {
              v105 = sub_17524(*(_QWORD *)v104, *(_DWORD *)(v104 + 8), a4);
              if ( (_WORD)v105 )
                break;
              v104 = *(_QWORD *)(v104 + 16);
              if ( !v104 )
                goto LABEL_133;
            }
            v13 = v105;
            if ( *a2 )
              ClientIDDestroy((_QWORD *)*a2);
            DHfree(v109);
          }
          sub_172A0((__int64)s);
          return v13;
        }
        DHfree(v93);
      }
    }
    sub_172A0((__int64)s);
    printLogD();
    return 65514;
  }
  if ( v87 <= v130[2] && v87 >= v130[1] )
    goto LABEL_109;
LABEL_105:
  sub_172A0((__int64)s);
  printLogD();
  return 65334;
}
// 163FC: variable 'v107' is possibly undefined
// 16530: variable 'v106' is possibly undefined

//----- (00000000000172A0) ----------------------------------------------------
void __fastcall sub_172A0(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x19
  __int64 v15; // x8
  __int64 v16; // x20

  v2 = *(void **)a1;
  if ( v2 )
    DHfree(v2);
  v3 = *(void **)(a1 + 8);
  if ( v3 )
    DHfree(v3);
  v4 = *(void **)(a1 + 16);
  if ( v4 )
    DHfree(v4);
  v5 = *(void **)(a1 + 24);
  if ( v5 )
    DHfree(v5);
  v6 = *(void **)(a1 + 32);
  if ( v6 )
    DHfree(v6);
  v7 = *(void **)(a1 + 40);
  if ( v7 )
    DHfree(v7);
  v8 = *(void **)(a1 + 48);
  if ( v8 )
    DHfree(v8);
  v9 = *(void **)(a1 + 80);
  if ( v9 )
    DHfree(v9);
  v10 = *(void **)(a1 + 64);
  if ( v10 )
    DHfree(v10);
  v11 = *(_QWORD *)(a1 + 72);
  if ( v11 )
  {
    v12 = *(_QWORD *)(v11 + 16);
    if ( v12 )
    {
      do
      {
        v13 = v12;
        if ( *(_QWORD *)v11 )
          DHfree(*(void **)v11);
        *(_QWORD *)v11 = 0;
        DHfree((void *)v11);
        v12 = *(_QWORD *)(v13 + 16);
        v11 = v13;
      }
      while ( v12 );
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 72);
    }
    if ( *(_QWORD *)v13 )
      DHfree(*(void **)v13);
    *(_QWORD *)v13 = 0;
    DHfree((void *)v13);
  }
  v14 = *(_QWORD *)(a1 + 120);
  if ( v14 )
  {
    v15 = *(_QWORD *)(v14 + 32);
    if ( v15 )
    {
      do
      {
        v16 = v15;
        DHfree(*(void **)(v14 + 16));
        DHfree((void *)v14);
        v15 = *(_QWORD *)(v16 + 32);
        v14 = v16;
      }
      while ( v15 );
    }
    else
    {
      v16 = v14;
    }
    DHfree(*(void **)(v16 + 16));
    DHfree((void *)v16);
  }
}

//----- (00000000000173DC) ----------------------------------------------------
__int64 __fastcall sub_173DC(__int64 a1, __int64 *a2)
{
  void *v4; // x0
  __int64 v5; // x19
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 result; // x0

  v4 = DHmalloc(81);
  if ( !v4 )
    return 65514;
  v5 = (__int64)v4;
  DHmemset(v4, 0, 16);
  DHmemset((void *)(v5 + 16), 0, 51);
  *(_QWORD *)(v5 + 72) = 0;
  DHstrncpy_s(v5, 16, a1, 0x10u);
  DHmemset((void *)(v5 + 16), 0, 51);
  DHstrncpy_s(v5 + 16, 51, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
  v6 = *a2;
  if ( *a2 )
  {
    do
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 72);
    }
    while ( v6 );
    a2 = (__int64 *)(v7 + 72);
  }
  result = 0;
  *a2 = v5;
  return result;
}

//----- (0000000000017494) ----------------------------------------------------
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  _QWORD *v1; // x8
  _QWORD *v2; // x20
  _QWORD *v3; // x19

  if ( a1 )
  {
    v1 = (_QWORD *)a1[9];
    v2 = a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        DHmemset(v2, 0, 16);
        DHmemset(v2 + 2, 0, 51);
        DHfree(v2);
        v1 = (_QWORD *)v3[9];
        v2 = v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    DHmemset(v3, 0, 16);
    DHmemset(v3 + 2, 0, 51);
    DHfree(v3);
  }
}

//----- (0000000000017524) ----------------------------------------------------
__int64 __fastcall sub_17524(__int64 a1, unsigned int a2, __int64 **a3)
{
  __int64 *v6; // x0
  __int64 *v7; // x19
  void *v8; // x0
  __int64 *v9; // x8
  __int64 *v10; // x9
  __int64 result; // x0

  v6 = (__int64 *)DHmalloc(25);
  if ( !v6 )
    return 65514;
  v7 = v6;
  *v6 = 0;
  v6[2] = 0;
  *((_DWORD *)v6 + 2) = a2;
  v8 = DHmalloc(a2 + 1);
  *v7 = (__int64)v8;
  if ( v8 )
  {
    DHmemset(v8, 0, a2 + 1);
    DHstrncpy_s(*v7, a2 + 1, a1, a2);
    v9 = *a3;
    if ( *a3 )
    {
      do
      {
        v10 = v9;
        v9 = (__int64 *)v9[2];
      }
      while ( v9 );
      result = 0;
      v10[2] = (__int64)v7;
    }
    else
    {
      result = 0;
      *a3 = v7;
    }
  }
  else
  {
    DHfree(v7);
    return 65514;
  }
  return result;
}

//----- (00000000000175DC) ----------------------------------------------------
void __fastcall DomainListDestroy(__int64 a1)
{
  __int64 v1; // x8
  void **v2; // x20
  __int64 v3; // x19

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 16);
    v2 = (void **)a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        if ( *v2 )
          DHfree(*v2);
        *v2 = 0;
        DHfree(v2);
        v1 = *(_QWORD *)(v3 + 16);
        v2 = (void **)v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    if ( *(_QWORD *)v3 )
      DHfree(*(void **)v3);
    *(_QWORD *)v3 = 0;
    DHfree((void *)v3);
  }
}

//----- (000000000001764C) ----------------------------------------------------
__int64 __fastcall sub_1764C(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6)
{
  int v12; // w9
  __int64 v13; // x10
  __int64 v14; // x8
  int v15; // w10
  int v16; // w9
  unsigned __int8 *v17; // x10
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // w10
  __int64 v21; // x11

  *a4 = 0;
  *a6 = 0;
  DHmemset(a3, 0, 16);
  DHmemset(a5, 0, 64);
  printLogD();
  while ( 1 )
  {
    v12 = *a1++;
    if ( v12 == 61 || v12 == 58 )
      break;
    if ( v12 == 32 )
    {
      --a2;
    }
    else
    {
      v13 = *a4;
      if ( (int)v13 >= 17 )
      {
LABEL_16:
        printLogD();
        return 65335;
      }
      *a4 = v13 + 1;
      *((_BYTE *)a3 + v13) = v12;
    }
  }
  *((_BYTE *)a3 + *a4) = 0;
  v14 = 0;
  do
    v15 = a1[v14++];
  while ( v15 == 32 );
  v16 = a2 - *a4;
  if ( ~(_DWORD)v14 + v16 >= 1 )
  {
    v17 = &a1[v14];
    v18 = v16 - v14;
    v19 = v17 - 1;
    do
    {
      v20 = *v19;
      if ( v20 == 32 )
        break;
      v21 = *a6;
      if ( (int)v21 >= 65 )
        goto LABEL_16;
      --v18;
      ++v19;
      *a6 = v21 + 1;
      *((_BYTE *)a5 + v21) = v20;
    }
    while ( v18 > 1 );
  }
  *((_BYTE *)a5 + *a6) = 0;
  printLogD();
  return 0;
}

//----- (00000000000177E0) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (0000000000017900) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsMetaSeek((__int64)v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (0000000000017A20) ----------------------------------------------------
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
  return 0;
}

//----- (0000000000017B00) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x24
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  printLogD();
  v8 = DHfsPfdMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    printLogD();
    if ( (DHfsMetaSeek(*(_QWORD *)(a3 + 8 * v6), 0, 3) & 0x8000000000000000LL) == 0 )
    {
      printLogD();
      return v7;
    }
  }
  return 0;
}

//----- (0000000000017C14) ----------------------------------------------------
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2)
{
  __int64 v2; // x19

  v2 = a2 + 8LL * a1;
  DHfsMetaClose(*(_QWORD **)(v2 + 8));
  *(_QWORD *)(v2 + 8) = -1;
}

//----- (0000000000017C40) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  result = DHfsClose();
  *(_QWORD *)(v2 + 8) = -1;
  return result;
}

//----- (0000000000017C6C) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (0000000000017D9C) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (0000000000017ECC) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  DHfsClose();
  result = 0;
  *(_QWORD *)(v2 + 48) = -1;
  return result;
}

//----- (0000000000017EFC) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_SetFileSize(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (0000000000017F1C) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5)
{
  return (unsigned int)(__int16)DHfs_VF_SetBuffer(*(_QWORD *)(a5 + 8LL * a1 + 8), a2, a3, a4);
}

//----- (0000000000017F3C) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_IsReachedToEndOfFile(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (0000000000017F5C) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4)
{
  return (unsigned int)(__int16)DHfs_VF_ShouldUpdateBuffer(*(_QWORD *)(a4 + 8LL * a1 + 8), a2, a3);
}

//----- (0000000000017F80) ----------------------------------------------------
__int64 __fastcall StrErrorReturn(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -37;
  else
    v1 = -23;
  if ( a1 == 22 )
    return 4294967260LL;
  else
    return v1;
}

//----- (0000000000017FA0) ----------------------------------------------------
__int64 __fastcall StrErrorReturn_uch(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -28;
  else
    v1 = -1;
  if ( a1 == 22 )
    return 4294967269LL;
  else
    return v1;
}

//----- (0000000000017FBC) ----------------------------------------------------
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x1
  FILE *v6; // x0
  FILE *v7; // x22

  ++qword_25CA8;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( !strcmp(a1, "*") )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4AA5;
      else
        v5 = off_212C8[a2 - 1];
      v6 = fopen(a1, v5);
      if ( v6 )
      {
        v7 = v6;
        printLogD();
        v4[1] = v7;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        ++qword_25CB0;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 212C8: using guessed type char *off_212C8[4];
// 25CA8: using guessed type __int64 qword_25CA8;
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (00000000000180E0) ----------------------------------------------------
void *__fastcall DHmalloc(int a1)
{
  void *v1; // x19

  if ( a1 )
  {
    ++qword_25CA8;
    v1 = malloc(a1);
    printLogD();
  }
  else
  {
    printLogD();
    return 0;
  }
  return v1;
}
// 25CA8: using guessed type __int64 qword_25CA8;

//----- (0000000000018150) ----------------------------------------------------
void __fastcall DHfree(void *a1)
{
  printLogD();
  if ( a1 )
  {
    ++qword_25CB0;
    free(a1);
  }
}
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (00000000000181A8) ----------------------------------------------------
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  FILE *v2; // x21

  if ( (unsigned int)(a2 - 1) > 3 )
    v2 = 0;
  else
    v2 = fopen(filename, off_212C8[a2 - 1]);
  printLogD();
  return v2;
}
// 212C8: using guessed type char *off_212C8[4];

//----- (0000000000018220) ----------------------------------------------------
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x22
  int v6; // w0
  FILE *v7; // x0
  FILE *v8; // x22

  printLogD();
  ++qword_25CA8;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( a1 < 1 )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4AA5;
      else
        v5 = off_212C8[a2 - 1];
      printLogD();
      v6 = dup(a1);
      v7 = fdopen(v6, v5);
      if ( v7 )
      {
        v8 = v7;
        rewind(v7);
        printLogD();
        v4[1] = v8;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        printLogD();
        ++qword_25CB0;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 212C8: using guessed type char *off_212C8[4];
// 25CA8: using guessed type __int64 qword_25CA8;
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (000000000001838C) ----------------------------------------------------
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  __int64 v4; // x22
  int v5; // w0
  FILE *v6; // x0
  FILE *v7; // x21

  printLogD();
  if ( (unsigned int)(a2 - 1) <= 3
    && (v4 = *((int *)&unk_7D30 + (unsigned int)(a2 - 1)),
        v5 = dup(a1),
        (v6 = fdopen(v5, (const char *)&unk_7D30 + v4)) != 0) )
  {
    v7 = v6;
    rewind(v6);
    printLogD();
    return v7;
  }
  else
  {
    printLogD();
    return 0;
  }
}

//----- (0000000000018444) ----------------------------------------------------
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  int v2; // w8
  FILE *v3; // x0
  FILE *v4; // x20

  if ( a1 )
  {
    v2 = *(unsigned __int16 *)a1;
    v3 = (FILE *)a1[1];
    if ( v2 )
    {
      fclose(v3);
    }
    else if ( v3 )
    {
      v4 = v3;
      printLogD();
      ++qword_25CB0;
      free(v4);
    }
    printLogD();
    ++qword_25CB0;
    free(a1);
  }
}
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (00000000000184EC) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(result + 28) = a2;
      return 1;
    }
  }
  return result;
}

//----- (000000000001850C) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  _OWORD *v5; // x20
  _QWORD *v6; // x21
  __int64 v7; // x22
  __int64 v8; // x23
  int v9; // w24
  __int64 v10; // x24
  __int64 v11; // x22
  int v12; // w23
  __int64 v13; // x8
  __int128 *v14; // x10
  _OWORD *v15; // x11
  __int64 v16; // x12
  __int128 v17; // q0
  __int128 v18; // q1
  __int64 v19; // x12
  __int64 *v20; // x10
  _QWORD *v21; // x11
  __int64 v22; // x12
  __int64 v23; // t1
  __int64 v24; // x9
  _BYTE *v25; // x10
  char *v26; // x8
  char v27; // t1

  if ( result )
  {
    if ( *(_WORD *)result )
      return 0;
    v6 = (_QWORD *)(result + 8);
    v5 = *(_OWORD **)(result + 8);
    if ( *(_DWORD *)(result + 16) < a3 )
    {
      if ( v5 )
      {
        v7 = result;
        v8 = a2;
        v9 = a4;
        printLogD();
        ++qword_25CB0;
        free(v5);
        a2 = v8;
        result = v7;
        a4 = v9;
        *v6 = 0;
        v6[1] = 0;
      }
      if ( !a3 )
      {
        printLogD();
        result = 0;
        *v6 = 0;
        return result;
      }
      v10 = result;
      v11 = a2;
      v12 = a4;
      ++qword_25CA8;
      v5 = malloc(a3);
      printLogD();
      *v6 = v5;
      if ( !v5 )
        return 0;
      result = v10;
      a4 = v12;
      a2 = v11;
      *(_DWORD *)(v10 + 16) = a3;
    }
    if ( a3 < 1 || !a2 || !v5 )
      goto LABEL_27;
    v13 = 0;
    if ( (unsigned int)a3 >= 8 && (unsigned __int64)v5 - a2 >= 0x20 )
    {
      if ( (unsigned int)a3 < 0x20 )
      {
        v13 = 0;
        goto LABEL_22;
      }
      v13 = a3 & 0x7FFFFFE0;
      v14 = (__int128 *)(a2 + 16);
      v15 = v5 + 1;
      v16 = v13;
      do
      {
        v17 = *(v14 - 1);
        v18 = *v14;
        v16 -= 32;
        v14 += 2;
        *(v15 - 1) = v17;
        *v15 = v18;
        v15 += 2;
      }
      while ( v16 );
      if ( v13 == a3 )
        goto LABEL_27;
      if ( (a3 & 0x18) != 0 )
      {
LABEL_22:
        v19 = v13;
        v13 = a3 & 0x7FFFFFF8;
        v20 = (__int64 *)(a2 + v19);
        v21 = (_QWORD *)((char *)v5 + v19);
        v22 = v19 - v13;
        do
        {
          v23 = *v20++;
          v22 += 8;
          *v21++ = v23;
        }
        while ( v22 );
        if ( v13 == a3 )
          goto LABEL_27;
      }
    }
    v24 = (unsigned int)a3 - v13;
    v25 = (char *)v5 + v13;
    v26 = (char *)(a2 + v13);
    do
    {
      v27 = *v26++;
      --v24;
      *v25++ = v27;
    }
    while ( v24 );
LABEL_27:
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
    return 1;
  }
  return result;
}
// 20: using guessed type __int64;
// 25CA8: using guessed type __int64 qword_25CA8;
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (00000000000186F8) ----------------------------------------------------
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v4; // x4
  __int64 v5; // x9
  __int64 v6; // x10
  _OWORD *v7; // x11
  _OWORD *v8; // x12
  __int128 v9; // q1
  __int64 v10; // x10

  v4 = 0;
  if ( a1 && a3 && a2 >= a4 )
  {
    if ( a4 < 1 )
      return a1;
    v5 = 0;
    if ( (unsigned int)a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( (unsigned int)a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_13;
      }
      v6 = 0;
      v5 = a4 & 0x7FFFFFE0;
      do
      {
        v7 = (_OWORD *)(a3 + v6);
        v8 = (_OWORD *)(a1 + v6);
        v6 += 32;
        v9 = v7[1];
        *v8 = *v7;
        v8[1] = v9;
      }
      while ( v5 != v6 );
      if ( v5 == a4 )
        return a1;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_13:
        v10 = v5;
        v5 = a4 & 0x7FFFFFF8;
        do
        {
          *(_QWORD *)(a1 + v10) = *(_QWORD *)(a3 + v10);
          v10 += 8;
        }
        while ( v5 != v10 );
        if ( v5 == a4 )
          return a1;
        goto LABEL_16;
      }
    }
    do
    {
LABEL_16:
      *(_BYTE *)(a1 + v5) = *(_BYTE *)(a3 + v5);
      ++v5;
    }
    while ( a4 != v5 );
    return a1;
  }
  return v4;
}

//----- (00000000000187B8) ----------------------------------------------------
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  int v2; // w8
  int v3; // w9

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 28);
      v2 = *(_DWORD *)(result + 32);
      result = 1;
      if ( v2 == v3 )
        *a2 = 1;
    }
  }
  return result;
}

//----- (00000000000187E8) ----------------------------------------------------
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  int v3; // w8
  int v4; // w9
  int v5; // w8

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 32);
      v4 = *(_DWORD *)(result + 24);
      if ( v3 < v4 || *(_DWORD *)(result + 20) + v4 <= v3 )
      {
        *a2 = 1;
        v5 = *(_DWORD *)(result + 32);
        result = 1;
        *a3 = v5;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

//----- (0000000000018840) ----------------------------------------------------
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3)
{
  __int64 v3; // x8
  int v5; // w11
  int v6; // w8
  __int64 v7; // x9
  int v8; // w8
  __int64 v9; // x10
  __int64 v10; // x11
  __int64 v11; // x12
  __int64 v12; // x9
  char *v13; // x11
  char *v14; // x10
  char v15; // t1
  bool v16; // cf
  _OWORD *v17; // x13
  __int128 *v18; // x12
  __int64 v19; // x14
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x14
  __int64 v23; // x12
  char *v24; // x13
  __int64 v25; // x14
  __int64 *v26; // x12
  __int64 v27; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_WORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_DWORD *)(a1 + 24);
    v7 = (unsigned int)(v5 - v6);
    if ( v5 - v6 < 0 || (v8 = *(_DWORD *)(a1 + 20), v8 <= (int)v7) )
    {
      LODWORD(v3) = 0;
      return (unsigned int)v3;
    }
    if ( (int)(v7 + a3) <= v8 )
      v3 = a3;
    else
      v3 = (unsigned int)(v8 - v7);
    if ( !ptr )
      goto LABEL_20;
    v9 = *(_QWORD *)(a1 + 8);
    if ( !v9 || (int)v3 < 1 )
      goto LABEL_20;
    if ( (unsigned int)v3 < 8 || (unsigned __int64)&ptr[-v9 - v7] < 0x20 )
    {
      v10 = 0;
LABEL_16:
      v11 = v10 + v7;
      v12 = v10 - v3;
      v13 = &ptr[v10];
      v14 = (char *)(v9 + v11);
      do
      {
        v15 = *v14++;
        v16 = __CFADD__(v12++, 1);
        *v13++ = v15;
      }
      while ( !v16 );
LABEL_19:
      v5 = *(_DWORD *)(a1 + 32);
LABEL_20:
      *(_DWORD *)(a1 + 32) = v5 + v3;
      return (unsigned int)v3;
    }
    if ( (unsigned int)v3 >= 0x20 )
    {
      v10 = v3 & 0x7FFFFFE0;
      v17 = ptr + 16;
      v18 = (__int128 *)(v7 + v9 + 16);
      v19 = v10;
      do
      {
        v20 = *(v18 - 1);
        v21 = *v18;
        v19 -= 32;
        v18 += 2;
        *(v17 - 1) = v20;
        *v17 = v21;
        v17 += 2;
      }
      while ( v19 );
      if ( v10 == v3 )
        goto LABEL_19;
      if ( (v3 & 0x18) == 0 )
        goto LABEL_16;
    }
    else
    {
      v10 = 0;
    }
    v22 = v10;
    v10 = v3 & 0x7FFFFFF8;
    v23 = v22 + v7;
    v24 = &ptr[v22];
    v25 = v22 - v10;
    v26 = (__int64 *)(v9 + v23);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *(_QWORD *)v24 = v27;
      v24 += 8;
    }
    while ( v25 );
    if ( v10 == v3 )
      goto LABEL_19;
    goto LABEL_16;
  }
  LODWORD(v3) = fread(ptr, 1u, (int)a3, *(FILE **)(a1 + 8));
  return (unsigned int)v3;
}

//----- (0000000000018994) ----------------------------------------------------
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3)
{
  return fread(ptr, 1u, a3, stream);
}

//----- (00000000000189B8) ----------------------------------------------------
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3)
{
  if ( a1 && *(_WORD *)a1 )
    return fwrite(ptr, 1u, a3, *(FILE **)(a1 + 8));
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000189F0) ----------------------------------------------------
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3)
{
  return fwrite(ptr, 1u, a3, s);
}

//----- (0000000000018A14) ----------------------------------------------------
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  __int64 v3; // x19
  FILE *v4; // x0
  int v5; // w2
  int v7; // w8

  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
  {
    v3 = a1;
    v4 = *(FILE **)(a1 + 8);
    if ( a3 == 1 )
      v5 = 1;
    else
      v5 = 2 * (a3 == 2);
    if ( (fseek(v4, a2, v5) & 0x80000000) == 0 )
    {
      a1 = v3;
      if ( *(_WORD *)v3 )
        return ftell(*(FILE **)(v3 + 8));
      return *(int *)(a1 + 32);
    }
    return -1;
  }
  switch ( a3 )
  {
    case 3:
      *(_DWORD *)(a1 + 32) = a2;
      return *(int *)(a1 + 32);
    case 2:
      v7 = *(_DWORD *)(a1 + 28);
      goto LABEL_15;
    case 1:
      v7 = *(_DWORD *)(a1 + 32);
LABEL_15:
      *(_DWORD *)(a1 + 32) = v7 + a2;
      break;
  }
  return *(int *)(a1 + 32);
}

//----- (0000000000018ABC) ----------------------------------------------------
__int64 __fastcall DHfsMetaTell(__int64 a1)
{
  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
    return ftell(*(FILE **)(a1 + 8));
  return *(int *)(a1 + 32);
}

//----- (0000000000018AE0) ----------------------------------------------------
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  if ( (unsigned int)(a3 - 1) > 2 || fseek(a1, a2, dword_7D40[a3 - 1]) < 0 )
    return -1;
  else
    return ftell(a1);
}
// 7D40: using guessed type _DWORD dword_7D40[3];

//----- (0000000000018B38) ----------------------------------------------------
__int64 __fastcall DHfsMetaSize(const char *a1)
{
  FILE *v2; // x0
  FILE *v3; // x20
  unsigned int v4; // w19

  if ( !strcmp(a1, "*") )
    return (unsigned int)-1;
  v2 = fopen(a1, "rb");
  if ( !v2 )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = v2;
    fseek(v2, 0, 2);
    v4 = ftell(v3);
    fclose(v3);
  }
  return v4;
}

//----- (0000000000018BA8) ----------------------------------------------------
__int64 __fastcall DHfsSize(const char *a1)
{
  FILE *v1; // x19
  unsigned int v2; // w20

  v1 = fopen(a1, "rb");
  fseek(v1, 0, 2);
  v2 = ftell(v1);
  fseek(v1, 0, 0);
  fclose(v1);
  return v2;
}

//----- (0000000000018C04) ----------------------------------------------------
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return memset(a1, a2, a3);
}

//----- (0000000000018C0C) ----------------------------------------------------
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return memcpy(a1, a2, a3);
}

//----- (0000000000018C14) ----------------------------------------------------
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3)
{
  return memcmp(a1, a2, a3);
}

//----- (0000000000018C1C) ----------------------------------------------------
void *__fastcall DHmemchr(const void *a1, int a2, int a3)
{
  return memchr(a1, a2, a3);
}

//----- (0000000000018C24) ----------------------------------------------------
void DHmemcount()
{
  printLogD();
  printLogD();
}
// 25CA8: using guessed type __int64 qword_25CA8;
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (0000000000018C70) ----------------------------------------------------
size_t __fastcall DHstrlen(const char *a1)
{
  return strlen(a1);
}

//----- (0000000000018C84) ----------------------------------------------------
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  if ( strlen(s) >= a2 )
    return 0xFFFFFFFFLL;
  strcpy(a1, s);
  return 0;
}

//----- (0000000000018CDC) ----------------------------------------------------
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3)
{
  return strncpy(a1, a2, a3);
}

//----- (0000000000018CE4) ----------------------------------------------------
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w8
  __int64 v5; // x8
  __int64 v6; // x9
  __int128 *v8; // x10
  _OWORD *v9; // x11
  __int64 v10; // x12
  __int128 v11; // q0
  __int128 v12; // q1
  __int64 v13; // x12
  __int64 *v14; // x10
  _QWORD *v15; // x11
  __int64 v16; // x12
  __int64 v17; // t1
  _BYTE *v18; // x10
  char *v19; // x11
  __int64 v20; // x8
  char v21; // t1

  v4 = 22;
  if ( !a1 || !a3 )
    return v4;
  if ( a2 < 1 )
    return 34;
  if ( (int)a4 >= 1 )
  {
    v5 = 0;
    v6 = a4;
    if ( a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_15;
      }
      v5 = a4 & 0x7FFFFFE0;
      v8 = (__int128 *)(a3 + 16);
      v9 = (_OWORD *)(a1 + 16);
      v10 = v5;
      do
      {
        v11 = *(v8 - 1);
        v12 = *v8;
        v10 -= 32;
        v8 += 2;
        *(v9 - 1) = v11;
        *v9 = v12;
        v9 += 2;
      }
      while ( v10 );
      if ( v5 == a4 )
        goto LABEL_20;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_15:
        v13 = v5;
        v5 = a4 & 0x7FFFFFF8;
        v14 = (__int64 *)(a3 + v13);
        v15 = (_QWORD *)(a1 + v13);
        v16 = v13 - v5;
        do
        {
          v17 = *v14++;
          v16 += 8;
          *v15++ = v17;
        }
        while ( v16 );
        if ( v5 == a4 )
          goto LABEL_20;
      }
    }
    v18 = (_BYTE *)(a1 + v5);
    v19 = (char *)(a3 + v5);
    v20 = a4 - v5;
    do
    {
      v21 = *v19++;
      --v20;
      *v18++ = v21;
    }
    while ( v20 );
    goto LABEL_20;
  }
  v6 = 0;
LABEL_20:
  v4 = 0;
  *(_BYTE *)(a1 + v6) = 0;
  return v4;
}

//----- (0000000000018DD0) ----------------------------------------------------
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4)
{
  int v5; // w8
  __int64 result; // x0

  v5 = strcmp(a1, s2);
  result = 0;
  *a4 = v5;
  return result;
}

//----- (0000000000018E00) ----------------------------------------------------
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return strncmp(a1, a2, a3);
}

//----- (0000000000018E08) ----------------------------------------------------
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // w8
  int v4; // w10
  int v5; // w9

  if ( a3 < 1 )
    return 0;
  v3 = a3 + 1;
  while ( 1 )
  {
    v4 = (unsigned __int8)*a2;
    v5 = (unsigned __int8)*a1;
    if ( !*a2 || !*a1 )
      break;
    if ( (unsigned int)(v4 - 97) < 0x1A )
      LOBYTE(v4) = v4 - 32;
    if ( (unsigned int)(v5 - 97) < 0x1A )
      LOBYTE(v5) = v5 - 32;
    if ( (unsigned __int8)v5 != (unsigned __int8)v4 )
      break;
    --v3;
    ++a1;
    ++a2;
    if ( v3 <= 1 )
      return 0;
  }
  return (unsigned __int8)(v5 - v4);
}

//----- (0000000000018E7C) ----------------------------------------------------
char *__fastcall DHstrncat(char *a1, const char *a2, int a3)
{
  return strncat(a1, a2, a3);
}

//----- (0000000000018E84) ----------------------------------------------------
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  __int64 result; // x0
  char *v7; // x20
  signed __int64 v9; // x0
  __int64 v10; // x8
  __int64 v11; // x9
  unsigned __int64 v12; // x12
  unsigned __int64 v13; // x11
  char *v14; // x9
  __int64 v15; // x10
  char *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x15
  __int128 v19; // q0
  __int128 v20; // q1
  char *v21; // x10
  char v22; // t1

  result = 22;
  if ( s && a3 )
  {
    if ( a2 < 1 )
      return 34;
    v7 = s;
    LODWORD(v9) = strlen(s);
    if ( a4 < 1 )
    {
      v14 = v7;
    }
    else
    {
      v9 = (int)v9;
      v10 = (int)v9 + a4;
      if ( (int)v9 + 1LL > v10 )
        v11 = (int)v9 + 1LL;
      else
        v11 = (int)v9 + a4;
      v12 = v11 - (int)v9;
      if ( v12 >= 0x20 )
      {
        v14 = v7;
        v15 = a3;
        if ( (unsigned __int64)&v7[(int)v9 - a3] >= 0x20 )
        {
          v13 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = &v7[(int)v9 + 16];
          v17 = (__int128 *)(a3 + 16);
          v9 = (int)v9 + (v12 & 0xFFFFFFFFFFFFFFE0LL);
          v18 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v18 -= 32LL;
            v17 += 2;
            *((_OWORD *)v16 - 1) = v19;
            *(_OWORD *)v16 = v20;
            v16 += 32;
          }
          while ( v18 );
          if ( v12 == v13 )
            goto LABEL_19;
        }
        else
        {
          v13 = 0;
        }
      }
      else
      {
        v13 = 0;
        v14 = v7;
        v15 = a3;
      }
      v21 = (char *)(v15 + v13);
      do
      {
        v22 = *v21++;
        v14[v9++] = v22;
      }
      while ( v9 < v10 );
    }
LABEL_19:
    v14[(int)v9] = 0;
    return 0;
  }
  return result;
}

//----- (0000000000018F9C) ----------------------------------------------------
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  int8x16_t *v3; // x19
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x9
  unsigned __int8 v6; // w12
  bool v7; // cf
  int8x16_t *v8; // x22
  int8x16_t *v9; // x8
  __int64 v10; // x10
  int8x16_t *v11; // x13
  int8x16_t *v12; // x14
  int8x16_t v13; // q0
  int8x16_t v14; // q1
  __int8 v15; // t1
  int8x16_t v17; // [xsp+7h] [xbp-29h] BYREF
  __int64 v18; // [xsp+28h] [xbp-8h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a3 - 37 >= 0xFFFFFFDD )
  {
    v3 = a2;
    v4 = 0;
    v5 = a1;
    do
    {
      if ( v5 % a3 >= 0xA )
        v6 = v5 % a3 + 87;
      else
        v6 = (v5 % a3) | 0x30;
      v7 = v5 >= a3;
      v17.n128_u8[v4++] = v6;
      v5 /= a3;
    }
    while ( v7 );
    v8 = (int8x16_t *)((char *)&v17 + v4);
    if ( !a2 )
    {
      if ( (_DWORD)v4 == -1 )
      {
        printLogD();
        v3 = 0;
      }
      else
      {
        ++qword_25CA8;
        v3 = (int8x16_t *)malloc((int)v4 + 1);
        printLogD();
      }
    }
    v9 = v3;
    if ( v8 <= &v17 )
      goto LABEL_21;
    if ( v4 >= 0x20 )
    {
      if ( v3 >= v8 || (v9 = v3, &v17 >= (int8x16_t *)((char *)v3 + v4)) )
      {
        v10 = 0;
        v9 = (int8x16_t *)((char *)v3 + (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v8 = (int8x16_t *)((char *)&v17 + v4 - (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v11 = v3 + 1;
        do
        {
          v12 = (int8x16_t *)((char *)&v17 + v4 + v10);
          v10 -= 32;
          v13 = vrev64q_s8(v12[-1]);
          v14 = vrev64q_s8(v12[-2]);
          v11[-1] = vextq_s8(v13, v13, 8u);
          *v11 = vextq_s8(v14, v14, 8u);
          v11 += 2;
        }
        while ( -(__int64)(v4 & 0xFFFFFFFFFFFFFFE0LL) != v10 );
        if ( v4 == (v4 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_21;
      }
    }
    else
    {
      v9 = v3;
    }
    do
    {
      v15 = v8[-1].n128_i8[15];
      v8 = (int8x16_t *)((char *)v8 - 1);
      v9->n128_u8[0] = v15;
      v9 = (int8x16_t *)((char *)v9 + 1);
    }
    while ( v8 > &v17 );
LABEL_21:
    v9->n128_u8[0] = 0;
    return v3;
  }
  return 0;
}
// 25CA8: using guessed type __int64 qword_25CA8;

//----- (0000000000019154) ----------------------------------------------------
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return strchr(a1, a2);
}

//----- (000000000001915C) ----------------------------------------------------
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  int v4; // w0
  unsigned __int8 *v5; // x19
  int v6; // w0
  unsigned __int8 *v7; // x21
  int v8; // w23
  int v9; // w0
  int v10; // w24
  size_t v11; // x23
  size_t v12; // x23
  int v13; // w0
  int v15; // w8
  unsigned __int8 *v16; // x9
  int v17; // t1
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // t1
  char *v21; // x0
  const char *v22; // x23

  v4 = strlen(a1);
  if ( v4 == -1 )
  {
    printLogD();
    v5 = 0;
  }
  else
  {
    ++qword_25CA8;
    v5 = (unsigned __int8 *)malloc(v4 + 1);
    printLogD();
  }
  v6 = strlen(a2);
  if ( v6 == -1 )
  {
    printLogD();
    if ( !v5 )
      return 0;
    goto LABEL_16;
  }
  ++qword_25CA8;
  v7 = (unsigned __int8 *)malloc(v6 + 1);
  printLogD();
  if ( !v5 )
    return 0;
  if ( !v7 )
  {
LABEL_16:
    printLogD();
    ++qword_25CB0;
    free(v5);
    return 0;
  }
  v8 = strlen(a1);
  v9 = strlen(a2);
  if ( !a1 )
  {
    v13 = 22;
LABEL_22:
    strerror(v13);
    printLogD();
    return 0;
  }
  v10 = v9;
  if ( (strlen(a1) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v8 >= 1 )
  {
    v11 = v8 & 0x7FFFFFFF;
    memcpy(v5, a1, v11);
    v5[v11] = 0;
    if ( a2 )
      goto LABEL_13;
    goto LABEL_20;
  }
  *v5 = 0;
  if ( !a2 )
  {
LABEL_20:
    v13 = 22;
    goto LABEL_22;
  }
LABEL_13:
  if ( (strlen(a2) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v10 < 1 )
  {
    v12 = 0;
  }
  else
  {
    v12 = v10 & 0x7FFFFFFF;
    memcpy(v7, a2, v12);
  }
  v15 = *v5;
  v7[v12] = 0;
  if ( v15 )
  {
    v16 = v5 + 1;
    do
    {
      if ( (unsigned int)(v15 - 65) <= 0x19 )
        *(v16 - 1) = v15 | 0x20;
      v17 = *v16++;
      v15 = v17;
    }
    while ( v17 );
  }
  v18 = *v7;
  if ( *v7 )
  {
    v19 = v7 + 1;
    do
    {
      if ( (unsigned int)(v18 - 65) <= 0x19 )
        *(v19 - 1) = v18 | 0x20;
      v20 = *v19++;
      v18 = v20;
    }
    while ( v20 );
  }
  v21 = strstr((const char *)v5, (const char *)v7);
  if ( v21 )
    v22 = &a1[v21 - (char *)v5];
  else
    v22 = 0;
  printLogD();
  ++qword_25CB0;
  free(v5);
  printLogD();
  ++qword_25CB0;
  free(v7);
  return v22;
}
// 25CA8: using guessed type __int64 qword_25CA8;
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (0000000000019468) ----------------------------------------------------
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  int v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = (unsigned __int8)*result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned int)(v1 - 65) <= 0x19 )
        *(v2 - 1) = v1 | 0x20;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (000000000001949C) ----------------------------------------------------
_BYTE *__fastcall DHstrupr(_BYTE *result)
{
  char v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = *result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00000000000194D4) ----------------------------------------------------
__int64 DHvsnprintf(char *a1, int a2, char *s, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v9; // [xsp+F8h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 && a2 >= 1 && s && (int)strlen(s) < a2 )
  {
    va_start(va, s);
    va_copy(arg, va);
    vsnprintf(a1, (unsigned int)a2, s, arg);
  }
  return 0;
}

//----- (00000000000195B0) ----------------------------------------------------
__int64 DHsprintf(char *a1, const char *a2, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v5; // [xsp+F8h] [xbp-8h]

  va_start(va, a2);
  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, a2, arg);
  return 0;
}

//----- (0000000000019644) ----------------------------------------------------
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v6; // [xsp+F8h] [xbp-8h]

  va_start(va, format);
  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, format, arg);
  return 0;
}

//----- (00000000000196DC) ----------------------------------------------------
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  unsigned int v2; // w19
  unsigned int v3; // w8
  int v4; // w8
  int v5; // w9
  struct tm v7; // [xsp+0h] [xbp-40h] BYREF
  __int64 v8; // [xsp+38h] [xbp-8h]

  v2 = 0;
  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (a1 & 0xFFFE) <= 0x7F5 )
    v3 = (unsigned __int16)a1;
  else
    v3 = 2037;
  v7.tm_isdst = 0;
  *(_QWORD *)&v7.tm_wday = 0;
  if ( v3 >= 0x7B2 )
  {
    v4 = v3 - 1900;
    v7.tm_hour = HIWORD(a1);
    v7.tm_mday = WORD2(a1);
    v5 = WORD1(a1) - 1;
    if ( (a1 & 0xFFFF0000) == 0 )
      v5 = 0;
    v7.tm_mon = v5;
    v7.tm_year = v4;
    v7.tm_sec = HIWORD(a2);
    v7.tm_min = (unsigned __int16)a2;
    v2 = mktime(&v7);
    printLogD();
  }
  return v2;
}

//----- (000000000001979C) ----------------------------------------------------
__int64 __fastcall DHGetStateInfo(void *a1)
{
  FILE *v2; // x0
  FILE *v3; // x21
  int v4; // w0
  unsigned int v6; // [xsp+4h] [xbp-D5Ch] BYREF
  int v7; // [xsp+8h] [xbp-D58h] BYREF
  _BYTE v8[244]; // [xsp+Ch] [xbp-D54h] BYREF
  __int128 v9; // [xsp+100h] [xbp-C60h] BYREF
  _BYTE v10[32]; // [xsp+110h] [xbp-C50h] BYREF
  int8x16_t src[2]; // [xsp+130h] [xbp-C30h] BYREF
  _QWORD v12[128]; // [xsp+158h] [xbp-C08h] BYREF
  char v13[1024]; // [xsp+558h] [xbp-808h] BYREF
  _BYTE s[1024]; // [xsp+958h] [xbp-408h] BYREF
  __int64 v15; // [xsp+D58h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  v6 = 0;
  v7 = 0;
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  memset(src, 0, sizeof(src));
  v2 = fopen("/data/data/com.skt.skaf.Z000HDRMDS/files/stateInfo.dat", "r");
  if ( v2 )
  {
    v3 = v2;
    printLogD();
    LODWORD(v3) = fread(s, 1u, 0x400u, v3);
    printLogD();
    __memcpy_chk(v13, s, (int)v3, 1024);
    printLogD();
    base64_decode(v13, (__int64)v12, (unsigned int *)&v7);
    printLogD();
    base64_decode("uLZ7EW2RgRj3xG7upVkEUg==", (__int64)v10, &v6);
    printLogD();
    AES_set_decrypt_key();
    AES_cbc_encrypt(v12, src, v7, (__int64)v8, &v9, 0);
    __strlen_chk((const char *)src, 0x20u);
    printLogD();
    v4 = __strlen_chk((const char *)src, 0x20u);
    memcpy(a1, src, v4);
    printLogD();
    return 0;
  }
  else
  {
    printLogD();
    return 0xFFFFFFFFLL;
  }
}
// 1D230: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000199C8) ----------------------------------------------------
__int64 DHcurrentTime_ByLib()
{
  return 0;
}

//----- (00000000000199D0) ----------------------------------------------------
__int64 DHcurrentTime()
{
  unsigned int v0; // w19
  time_t v2; // [xsp+0h] [xbp-10h] BYREF
  __int64 v3; // [xsp+8h] [xbp-8h]

  v3 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = 0;
  v0 = time(&v2);
  printLogD();
  return v0;
}

//----- (0000000000019A40) ----------------------------------------------------
__int64 DHAuthTime_ByLib()
{
  return 0;
}

//----- (0000000000019A48) ----------------------------------------------------
__int64 DHAuthTime_ByFile()
{
  unsigned int v2; // w19
  __int64 v3; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v4; // [xsp+8h] [xbp-98h]
  char v5; // [xsp+Ah] [xbp-96h]
  __int128 v6; // [xsp+10h] [xbp-90h] BYREF
  __int128 v7; // [xsp+20h] [xbp-80h]
  __int128 v8; // [xsp+30h] [xbp-70h]
  __int128 v9; // [xsp+40h] [xbp-60h]
  __int128 v10; // [xsp+50h] [xbp-50h]
  __int128 v11; // [xsp+60h] [xbp-40h]
  __int128 v12; // [xsp+70h] [xbp-30h]
  __int128 v13; // [xsp+80h] [xbp-20h]
  __int64 v14; // [xsp+98h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v5 = 0;
  if ( (DHGetStateInfo(&v6) & 0x80000000) != 0 )
    return 0;
  if ( (unsigned __int16)v7 != 21582 || BYTE2(v7) != 58 )
  {
    fclose(0);
    return 0;
  }
  v3 = *(_QWORD *)((char *)&v7 + 3);
  v4 = *(_WORD *)((char *)&v7 + 11);
  __strlen_chk((const char *)&v3, 0xBu);
  v2 = atoi((const char *)&v3);
  printLogD();
  return v2;
}

//----- (0000000000019B1C) ----------------------------------------------------
__int64 DHAuthTime()
{
  time_t v1; // [xsp+0h] [xbp-10h] BYREF
  __int64 v2; // [xsp+8h] [xbp-8h]

  v2 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  return (unsigned int)time(&v1) - 1600;
}

//----- (0000000000019B68) ----------------------------------------------------
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  int v5; // w21
  __int64 v6; // x8
  int v7; // w9
  __int64 v8; // x9
  __int64 v9; // x10
  char *v10; // x12
  __int64 v11; // x11
  char *v12; // x10
  _BYTE *v13; // x12
  char v14; // t1
  __int128 *v16; // x11
  _OWORD *v17; // x12
  __int64 v18; // x13
  __int128 v19; // q0
  __int128 v20; // q1
  __int64 v21; // x13
  char *v22; // x12
  __int64 *v23; // x11
  __int64 v24; // x13
  _QWORD *v25; // x12
  __int64 v26; // t1
  __int128 v27; // [xsp+8h] [xbp-18h]

  _ReadStatusReg(TPIDR_EL0);
  printLogD();
  if ( !a3 )
  {
    ++qword_25CA8;
    a3 = (__int16 *)malloc(0xEu);
    printLogD();
    if ( !a3 )
      return 0xFFFFFFFFLL;
  }
  v5 = strlen((const char *)a1);
  printLogD();
  if ( v5 != 11 )
  {
    *a3 = v5;
    if ( !a1 )
      return StrErrorReturn(22);
    v8 = (unsigned int)(__int16)v5;
    if ( (int)v8 < 1 )
    {
      v8 = 0;
LABEL_18:
      *((_BYTE *)a3 + v8 + 2) = 0;
      goto LABEL_19;
    }
    if ( (unsigned int)v8 < 8 || (unsigned __int64)((char *)a3 - (char *)a1 + 2) < 0x20 )
    {
      v9 = 0;
LABEL_11:
      v10 = (char *)a3 + v9;
      v11 = v8 - v9;
      v12 = (char *)a1 + v9;
      v13 = v10 + 2;
      do
      {
        v14 = *v12++;
        --v11;
        *v13++ = v14;
      }
      while ( v11 );
      goto LABEL_18;
    }
    if ( (unsigned int)v8 >= 0x20 )
    {
      v9 = v8 & 0x7FFFFFE0;
      v16 = (__int128 *)(a1 + 2);
      v17 = a3 + 9;
      v18 = v9;
      do
      {
        v19 = *(v16 - 1);
        v20 = *v16;
        v18 -= 32;
        v16 += 2;
        *(v17 - 1) = v19;
        *v17 = v20;
        v17 += 2;
      }
      while ( v18 );
      if ( v9 == v8 )
        goto LABEL_18;
      if ( (v5 & 0x18) == 0 )
        goto LABEL_11;
    }
    else
    {
      v9 = 0;
    }
    v21 = v9;
    v9 = v8 & 0x7FFFFFF8;
    v22 = (char *)a3 + v21;
    v23 = (__int64 *)((char *)a1 + v21);
    v24 = v21 - v9;
    v25 = v22 + 2;
    do
    {
      v26 = *v23++;
      v24 += 8;
      *v25++ = v26;
    }
    while ( v24 );
    if ( v9 == v8 )
      goto LABEL_18;
    goto LABEL_11;
  }
  if ( !a1 )
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  v6 = *a1;
  v7 = *(_DWORD *)((char *)a1 + 7);
  *a3 = 10;
  *(_QWORD *)&v27 = v6;
  *(_WORD *)((char *)&v27 + 7) = v7;
  *((_BYTE *)a3 + 12) = 0;
  a3[5] = HIWORD(v7);
  *(_QWORD *)(a3 + 1) = *(_QWORD *)((char *)&v27 + 1);
LABEL_19:
  printLogD();
  return (unsigned int)*a3;
}
// 25CA8: using guessed type __int64 qword_25CA8;

//----- (0000000000019DE4) ----------------------------------------------------
void __fastcall DHFreeClientID(void *a1)
{
  if ( a1 )
  {
    printLogD();
    printLogD();
    ++qword_25CB0;
    free(a1);
  }
}
// 25CB0: using guessed type __int64 qword_25CB0;

//----- (0000000000019E48) ----------------------------------------------------
__int64 DHGetClientID_ByLib()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000019E50) ----------------------------------------------------
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  __int16 *v8; // x24
  __int64 v9; // x22
  __int64 v11; // x8
  char *v12; // x10
  __int64 v13; // x9
  _BYTE *v14; // x8
  char *v15; // x10
  char v16; // t1
  __int128 *v17; // x9
  _OWORD *v18; // x10
  __int64 v19; // x11
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x11
  char *v23; // x9
  _QWORD *v24; // x10
  __int64 v25; // x11
  __int64 *v26; // x9
  __int64 v27; // t1

  printLogD();
  if ( !a4 || (v8 = *a4) == 0 || (v9 = (unsigned int)*v8, !*v8) )
  {
    *a2 = 0;
    return 0xFFFFFFFFLL;
  }
  if ( !strcmp(a1, "min") )
  {
    *a2 = v9;
    if ( !a3 )
    {
      strerror(22);
      printLogD();
      return StrErrorReturn(22);
    }
    if ( (int)v9 < 1 )
    {
      v9 = 0;
LABEL_17:
      *(_BYTE *)(a3 + v9) = 0;
      goto LABEL_18;
    }
    if ( (unsigned int)v9 < 8 || (unsigned __int64)(a3 - (_QWORD)v8 - 2) < 0x20 )
    {
      v11 = 0;
LABEL_12:
      v12 = (char *)v8 + v11;
      v13 = v9 - v11;
      v14 = (_BYTE *)(a3 + v11);
      v15 = v12 + 2;
      do
      {
        v16 = *v15++;
        --v13;
        *v14++ = v16;
      }
      while ( v13 );
      goto LABEL_17;
    }
    if ( (unsigned int)v9 >= 0x20 )
    {
      v11 = v9 & 0x7FE0;
      v17 = (__int128 *)(v8 + 9);
      v18 = (_OWORD *)(a3 + 16);
      v19 = v11;
      do
      {
        v20 = *(v17 - 1);
        v21 = *v17;
        v19 -= 32;
        v17 += 2;
        *(v18 - 1) = v20;
        *v18 = v21;
        v18 += 2;
      }
      while ( v19 );
      if ( v11 == v9 )
        goto LABEL_17;
      if ( (v9 & 0x18) == 0 )
        goto LABEL_12;
    }
    else
    {
      v11 = 0;
    }
    v22 = v11;
    v11 = v9 & 0x7FF8;
    v23 = (char *)v8 + v22;
    v24 = (_QWORD *)(a3 + v22);
    v25 = v22 - v11;
    v26 = (__int64 *)(v23 + 2);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *v24++ = v27;
    }
    while ( v25 );
    if ( v11 == v9 )
      goto LABEL_17;
    goto LABEL_12;
  }
  *a2 = 0;
LABEL_18:
  printLogD();
  return *a2;
}

//----- (000000000001A028) ----------------------------------------------------
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned int v5; // w21
  __int64 v7; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v8; // [xsp+8h] [xbp-98h]
  char v9; // [xsp+Ah] [xbp-96h]
  _OWORD v10[8]; // [xsp+10h] [xbp-90h] BYREF
  __int64 v11; // [xsp+98h] [xbp-8h]

  v11 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  if ( (DHGetStateInfo(v10) & 0x80000000) != 0 )
  {
    return 0;
  }
  else if ( *(_DWORD *)((char *)v10 + 1) == 978209101 )
  {
    v7 = *(_QWORD *)((char *)v10 + 5);
    v8 = *(_WORD *)((char *)v10 + 13);
    v5 = __strlen_chk((const char *)&v7, 0xBu);
    *a2 = v5;
    __strncpy_chk2(a3, &v7, (int)v5, -1, 11);
    printLogD();
  }
  else
  {
    printLogD();
    v5 = 0;
    *a2 = 0;
  }
  return v5;
}
// 1D260: using guessed type __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A144) ----------------------------------------------------
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3)
{
  __int64 v7; // x8
  const char *v8; // x9
  char *v9; // x10
  __int64 v10; // x11
  char v11; // t1

  printLogD();
  if ( strcmp(a1, "min") )
  {
    *a2 = 0;
    return *a2;
  }
  v7 = *a2;
  if ( (int)v7 > 9 )
  {
    if ( a3 )
    {
      strcpy(a3, "1057402191");
      return *a2;
    }
  }
  else if ( a3 )
  {
    if ( (int)v7 < 1 )
    {
      *a3 = 0;
    }
    else
    {
      v8 = "1057402191";
      v9 = a3;
      v10 = *a2;
      do
      {
        v11 = *v8++;
        --v10;
        *v9++ = v11;
      }
      while ( v10 );
      a3[v7] = 0;
    }
    return *a2;
  }
  strerror(22);
  printLogD();
  return StrErrorReturn(22);
}

//----- (000000000001A288) ----------------------------------------------------
__int64 DHGetDeviceID_ByLib()
{
  return 4294967286LL;
}

//----- (000000000001A290) ----------------------------------------------------
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  __int64 result; // x0

  if ( a1 )
  {
    result = 0;
    strcpy(a1, "DIGICAPS1234567890");
  }
  else
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  return result;
}

//----- (000000000001A300) ----------------------------------------------------
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  void *v6; // x21
  uint32x4_t v7; // q0
  const float *v8; // x8
  uint32x4_t v9; // q1
  const float *v10; // x8
  uint32x4_t v11; // q3
  const float *v12; // x8
  uint32x4_t v13; // q4
  unsigned int v14; // w9
  __int128 v15; // [xsp+0h] [xbp-70h] BYREF
  __int64 v16; // [xsp+10h] [xbp-60h] BYREF
  unsigned int v17; // [xsp+18h] [xbp-58h]
  int v18; // [xsp+1Ch] [xbp-54h] BYREF
  _DWORD v19[2]; // [xsp+60h] [xbp-10h] BYREF
  __int64 v20; // [xsp+68h] [xbp-8h]

  v20 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = DHmalloc(a3 + 1);
  DHmemset(v6, 0, a3 + 1);
  DHmemcpy_s((__int64)v6, a3 + 1, a1, a3);
  v17 = 0;
  v15 = xmmword_7C40;
  v16 = 3285377520LL;
  sub_1A510(&v15, a1, a3);
  v19[0] = bswap32(v17);
  v19[1] = bswap32(HIDWORD(v16));
  sub_1A510(&v15, (__int64)&unk_593E, 1u);
  while ( (WORD2(v16) & 0x1F8) != 0x1C0 )
    sub_1A510(&v15, (__int64)&unk_7D4C, 1u);
  sub_1A510(&v15, (__int64)v19, 8u);
  v7 = vld1q_dup_f32((const float *)&v15);
  v8 = (const float *)&v15 + 1;
  v9 = vld1q_dup_f32(v8);
  v10 = (const float *)&v15 + 2;
  v11 = vld1q_dup_f32(v10);
  v12 = (const float *)((unsigned __int64)&v15 | 0xC);
  v13 = vld1q_dup_f32(v12);
  LODWORD(v12) = WORD1(v16);
  v7.n128_u64[0] = vmovn_s32(vshlq_u32(v7, (uint32x4_t)xmmword_7CB0)).n64_u64[0];
  v14 = bswap32((unsigned __int16)v16) >> 16;
  a2[1].n128_u8[0] = BYTE3(v16);
  a2[1].n128_u8[1] = (unsigned __int8)v12;
  v7.n128_u64[0] = vuzp1_s8((int8x8_t)v7.n128_u64[0], (int8x8_t)v7.n128_u64[0]).n64_u64[0];
  a2[1].n128_u16[1] = v14;
  v7.n128_u32[1] = vuzp1_s8(vmovn_s32(vshlq_u32(v9, (uint32x4_t)xmmword_7CB0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0];
  v7.n128_u64[1] = __PAIR64__(
                     vuzp1_s8(vmovn_s32(vshlq_u32(v13, (uint32x4_t)xmmword_7CB0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0],
                     vuzp1_s8(vmovn_s32(vshlq_u32(v11, (uint32x4_t)xmmword_7CB0)), (int8x8_t)v7.n128_u64[0]).n64_u32[0]);
  *a2 = v7;
  DHmemset(&v18, 0, 64);
  DHmemset(&v15, 0, 20);
  DHmemset((char *)&v16 + 4, 0, 8);
  DHmemset(v19, 0, 8);
  DHmemcpy_s(a1, a3 + 1, (__int64)v6, a3);
  DHfree(v6);
}
// 7C40: using guessed type __int128 xmmword_7C40;
// 7CB0: using guessed type __int128 xmmword_7CB0;

//----- (000000000001A510) ----------------------------------------------------
__int64 __fastcall sub_1A510(_DWORD *a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // x8
  __int64 v7; // x24
  int v8; // w9
  unsigned int v9; // w22
  unsigned int v10; // w23
  __int64 v11; // x8

  v3 = (unsigned int)a1[5];
  v7 = (v3 >> 3) & 0x3F;
  v8 = a1[6] + __CFADD__((_DWORD)v3, 8 * a3) + (a3 >> 29);
  a1[5] = v3 + 8 * a3;
  a1[6] = v8;
  if ( (unsigned int)v7 + a3 < 0x40 )
  {
    v9 = 0;
    v11 = (v3 >> 3) & 0x3F;
  }
  else
  {
    v9 = 64 - v7;
    DHmemcpy_s((__int64)a1 + v7 + 28, 64, a2, 64 - v7);
    sub_1A5EC(a1, a1 + 7);
    v10 = v7 ^ 0x7F;
    if ( ((unsigned int)v7 ^ 0x7F) >= a3 )
    {
      v11 = 0;
    }
    else
    {
      do
      {
        sub_1A5EC(a1, (unsigned int *)(a2 + v10 - 63));
        v10 += 64;
      }
      while ( v10 < a3 );
      v11 = 0;
      v9 = v10 - 63;
    }
  }
  return DHmemcpy_s((__int64)a1 + v11 + 28, 64, a2 + v9, a3 - v9);
}

//----- (000000000001A5EC) ----------------------------------------------------
int32x4_t __fastcall sub_1A5EC(_DWORD *a1, unsigned int *a2)
{
  int v2; // w9
  int v3; // w12
  int v4; // w14
  int v5; // w2
  unsigned __int64 v6; // t2
  int v7; // w16
  int v8; // w17
  int v9; // w9
  unsigned int v10; // w10
  unsigned int v11; // w11
  int v12; // w15
  int v13; // w17
  int v14; // w13
  int v15; // w12
  unsigned int v16; // w4
  int v17; // w2
  int v18; // w14
  unsigned int v19; // w15
  int v20; // w17
  int v21; // w9
  int v22; // w3
  int v23; // w16
  int v24; // w5
  int v25; // w6
  int v26; // w14
  int v27; // w11
  unsigned int v28; // w17
  int v29; // w12
  unsigned int v30; // w16
  int v31; // w13
  int v32; // w2
  int v33; // w5
  int v34; // w12
  int v35; // w15
  int v36; // w2
  unsigned int v37; // w20
  int v38; // w5
  int v39; // w21
  int v40; // w9
  unsigned int v41; // w13
  int v42; // w16
  unsigned int v43; // w19
  int v44; // w14
  int v45; // w2
  int v46; // w6
  unsigned int v47; // w12
  int v48; // w3
  int v49; // w6
  int v50; // w7
  int v51; // w14
  int v52; // w21
  int v53; // w5
  int v54; // w7
  int v55; // w3
  unsigned int v56; // w6
  int v57; // w21
  unsigned int v58; // w9
  int v59; // w22
  int v60; // w2
  int v61; // w23
  int v62; // w7
  int v63; // w22
  int v64; // w21
  unsigned int v65; // w5
  int v66; // w7
  int v67; // w23
  unsigned int v68; // w14
  int v69; // w22
  int v70; // w23
  int v71; // w26
  int v72; // w27
  int v73; // w24
  int v74; // w22
  unsigned int v75; // w3
  int v76; // w25
  int v77; // w7
  int v78; // w10
  int v79; // w2
  int v80; // w25
  int v81; // w24
  int v82; // w25
  unsigned int v83; // w7
  int v84; // w13
  int v85; // w21
  int v86; // w26
  int v87; // w23
  int v88; // w25
  int v89; // w2
  int v90; // w27
  int v91; // w23
  int v92; // w25
  int v93; // w21
  int v94; // w11
  int v95; // w25
  int v96; // w22
  int v97; // w11
  int v98; // w4
  int v99; // w22
  int v100; // w25
  int v101; // w23
  int v102; // w4
  int v103; // w24
  int v104; // w25
  int v105; // w4
  int v106; // w15
  int v107; // w24
  int v108; // w22
  int v109; // w25
  int v110; // w8
  int v111; // w15
  int v112; // w25
  int v113; // w8
  int v114; // w24
  int v115; // w26
  int v116; // w17
  int v117; // w16
  int v118; // w21
  int v119; // w25
  int v120; // w26
  int v121; // w23
  int v122; // w21
  int v123; // w20
  int v124; // w23
  int v125; // w16
  int v126; // w26
  int v127; // w12
  int v128; // w23
  int v129; // w22
  int v130; // w13
  int v131; // w26
  int v132; // w27
  int v133; // w23
  int v134; // w20
  int v135; // w19
  int v136; // w23
  int v137; // w24
  int v138; // w25
  int v139; // w13
  int v140; // w9
  int v141; // w23
  int v142; // w13
  int v143; // w19
  int v144; // w13
  int v145; // w16
  int v146; // w24
  int v147; // w6
  int v148; // w13
  int v149; // w16
  int v150; // w6
  int v151; // w23
  int v152; // w24
  int v153; // w26
  int v154; // w6
  int v155; // w24
  int v156; // w14
  int v157; // w6
  int v158; // w26
  int v159; // w16
  int v160; // w5
  int v161; // w16
  int v162; // w5
  int v163; // w24
  int v164; // w6
  int v165; // w19
  int v166; // w25
  int v167; // w23
  int v168; // w5
  int v169; // w24
  int v170; // w23
  int v171; // w26
  int v172; // w3
  int v173; // w19
  int v174; // w24
  int v175; // w3
  int v176; // w7
  int v177; // w19
  int v178; // w23
  int v179; // w24
  int v180; // w6
  int v181; // w19
  int v182; // w10
  int v183; // w24
  int v184; // w25
  int v185; // w27
  int v186; // w6
  int v187; // w7
  int v188; // w2
  int v189; // w6
  int v190; // w10
  int v191; // w6
  int v192; // w26
  int v193; // w24
  int v194; // w6
  int v195; // w11
  int v196; // w24
  int v197; // w26
  int v198; // w27
  int v199; // w4
  int v200; // w2
  int v201; // w23
  int v202; // w11
  int v203; // w24
  int v204; // w25
  int v205; // w24
  int v206; // w2
  int v207; // w15
  int v208; // w24
  int v209; // w23
  int v210; // w25
  int v211; // w10
  int v212; // w17
  int v213; // w24
  int v214; // w10
  int v215; // w25
  int v216; // w26
  int v217; // w15
  int v218; // w21
  int v219; // w15
  int v220; // w21
  int v221; // w25
  int v222; // w11
  int v223; // w24
  int v224; // w10
  int v225; // w25
  int v226; // w27
  int v227; // w22
  int v228; // w12
  int v229; // w21
  int v230; // w11
  int v231; // w20
  int v232; // w23
  int v233; // w25
  int v234; // w26
  int v235; // w27
  int v236; // w21
  int v237; // w23
  int v238; // w13
  int v239; // w24
  int v240; // w26
  int v241; // w22
  int v242; // w25
  int v243; // w23
  int v244; // w9
  int v245; // w23
  int v246; // w25
  int v247; // w26
  int v248; // w20
  int v249; // w24
  int v250; // w16
  int v251; // w24
  int v252; // w25
  int v253; // w26
  int v254; // w21
  int v255; // w23
  int v256; // w14
  int v257; // w23
  int v258; // w25
  int v259; // w26
  int v260; // w22
  int v261; // w24
  int v262; // w5
  int v263; // w24
  int v264; // w25
  int v265; // w26
  int v266; // w20
  int v267; // w23
  int v268; // w3
  int v269; // w23
  int v270; // w25
  int v271; // w26
  int v272; // w21
  int v273; // w24
  int v274; // w19
  int v275; // w24
  int v276; // w25
  int v277; // w26
  int v278; // w22
  int v279; // w23
  int v280; // w7
  int v281; // w23
  int v282; // w25
  int v283; // w26
  int v284; // w20
  int v285; // w24
  int v286; // w6
  int v287; // w24
  int v288; // w25
  int v289; // w26
  int v290; // w21
  int v291; // w23
  int v292; // w4
  int v293; // w23
  int v294; // w25
  int v295; // w26
  int v296; // w22
  int v297; // w24
  int v298; // w2
  int v299; // w24
  int v300; // w25
  int v301; // w26
  int v302; // w20
  int v303; // w23
  int v304; // w17
  int v305; // w23
  int v306; // w25
  int v307; // w26
  int v308; // w21
  int v309; // w24
  int v310; // w15
  int v311; // w25
  int v312; // w24
  int v313; // w26
  int v314; // w23
  int v315; // w10
  int v316; // w22
  int v317; // w23
  int v318; // w20
  int v319; // w25
  int v320; // w26
  int v321; // w20
  int v322; // w11
  int v323; // w22
  int v324; // w25
  int v325; // w26
  int v326; // w21
  int v327; // w11
  int v328; // w12
  int v329; // w21
  int v330; // w26
  int v331; // w24
  int v332; // w25
  int v333; // w26
  int v334; // w28
  int v335; // w27
  int v336; // w21
  int v337; // w12
  int v338; // w25
  int v339; // w26
  int v340; // w13
  int v341; // w9
  int v342; // w26
  int v343; // w16
  int v344; // w23
  int v345; // w25
  int v346; // w22
  int v347; // w16
  int v348; // w22
  int v349; // w25
  int v350; // w9
  int v351; // w24
  int v352; // w14
  int v353; // w9
  int v354; // w26
  int v355; // w9
  int v356; // w24
  int v357; // w12
  int v358; // w5
  int v359; // w22
  int v360; // w23
  int v361; // w24
  int v362; // w9
  int v363; // w3
  int v364; // w9
  int v365; // w19
  int v366; // w23
  int v367; // w22
  unsigned int v368; // w5
  int v369; // w22
  int v370; // w3
  int v371; // w26
  int v372; // w25
  int v373; // w7
  int v374; // w19
  int v375; // w26
  int v376; // w25
  unsigned int v377; // w3
  unsigned int v378; // w6
  int v379; // w24
  int v380; // w22
  int v381; // w23
  int v382; // w19
  int v383; // w25
  unsigned int v384; // w4
  int v385; // w22
  unsigned int v386; // w2
  int v387; // w24
  int v388; // w23
  int v389; // w7
  unsigned int v390; // w17
  int v391; // w22
  int v392; // w26
  unsigned int v393; // w15
  int v394; // w24
  int v395; // w23
  int v396; // w19
  unsigned int v397; // w10
  int v398; // w22
  int v399; // w25
  int v400; // w23
  int v401; // w24
  unsigned int v402; // w7
  int v403; // w23
  int v404; // w24
  int v405; // w20
  unsigned int v406; // w11
  int v407; // w22
  int v408; // w26
  int v409; // w24
  unsigned int v410; // w19
  int v411; // w21
  int v412; // w23
  int v413; // w24
  int v414; // w22
  unsigned int v415; // w13
  int v416; // w23
  int v417; // w25
  unsigned int v418; // w16
  int v419; // w24
  int v420; // w20
  int v421; // w26
  int v422; // w21
  int v423; // w14
  int v424; // w12
  int v425; // w21
  unsigned int v426; // w20
  int v427; // w5
  unsigned int v428; // w24
  int v429; // w23
  unsigned int v430; // w12
  unsigned int v431; // w11
  int v432; // w4
  int v433; // w22
  unsigned __int32 v434; // w2
  int32x4_t v435; // q0
  unsigned int v436; // w9
  int32x4_t v437; // q1
  int32x4_t result; // q0

  v2 = a1[1];
  v4 = a1[2];
  v3 = a1[3];
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v5 = v6 >> 27;
  v7 = v3 & ~v2;
  v8 = v4 & v2;
  HIDWORD(v6) = v2;
  LODWORD(v6) = v2;
  v9 = v6 >> 2;
  v10 = bswap32(*a2);
  v11 = bswap32(a2[1]);
  v12 = v5 + a1[4] + v10 + (v8 | v7) + 1518500249;
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v13 = v6 >> 27;
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v14 = v6 >> 2;
  v15 = v3 + v11 + (v9 & *a1 | v4 & ~*a1) + 1518500249 + v13;
  v16 = bswap32(a2[2]);
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v17 = v6 >> 2;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v18 = v4 + v16 + (v14 & v12 | v9 & ~v12) + 1518500249 + (v6 >> 27);
  v19 = bswap32(a2[3]);
  v20 = v9 + v19;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v21 = v6 >> 2;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v22 = v6 >> 27;
  v23 = v20 + (v17 & v15 | v14 & ~v15);
  v24 = v17 & ~v18;
  v25 = v21 & v18;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v26 = v6 >> 2;
  v27 = v19 ^ v11;
  v28 = bswap32(a2[4]);
  v29 = v23 + 1518500249 + v22;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v30 = bswap32(a2[5]);
  v31 = v14 + v28 + (v25 | v24) + 1518500249 + (v6 >> 27);
  v32 = v17 + v30 + (v26 & v29 | v21 & ~v29);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v33 = v6 >> 27;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v34 = v6 >> 2;
  v35 = v30 ^ v19;
  v36 = v32 + 1518500249 + v33;
  v37 = bswap32(a2[6]);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v38 = v6 >> 2;
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v39 = v21 + v37 + (v34 & v31 | v26 & ~v31) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v40 = v6 >> 2;
  v41 = bswap32(a2[7]);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v42 = v41 ^ v30;
  v43 = bswap32(a2[8]);
  v44 = v26 + v41 + (v38 & v36 | v34 & ~v36) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v45 = v6 >> 2;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v46 = v34 + v43 + (v40 & v39 | v38 & ~v39) + 1518500249;
  v47 = bswap32(a2[9]);
  v48 = v46 + (v6 >> 27);
  v49 = v45 & v44 | v40 & ~v44;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v50 = v6 >> 27;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v51 = v6 >> 2;
  v52 = v51 & v48;
  v53 = v38 + v47 + v49 + 1518500249 + v50;
  v54 = v45 & ~v48;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v55 = v6 >> 2;
  v56 = bswap32(a2[10]);
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v57 = v56 + v40 + (v52 | v54) + 1518500249 + (v6 >> 27);
  v58 = bswap32(a2[11]);
  v59 = v58 + v45;
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v60 = v6 >> 2;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v61 = v6 >> 27;
  v62 = v59 + (v55 & v53 | v51 & ~v53);
  v63 = v60 & v57 | v55 & ~v57;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v64 = v6 >> 2;
  v65 = bswap32(a2[12]);
  v66 = v62 + 1518500249 + v61;
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v67 = v65 + v51 + v63 + 1518500249;
  v68 = bswap32(a2[13]);
  v69 = v67 + (v6 >> 27);
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v70 = v6 >> 2;
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v71 = v64 & ~v69;
  v72 = v70 & v69;
  v73 = v68 + v55 + (v64 & v66 | v60 & ~v66) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v74 = v6 >> 2;
  v75 = bswap32(a2[14]);
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v76 = v6 >> 27;
  v77 = v70 & ~v73;
  HIDWORD(v6) = v16 ^ v10 ^ v43 ^ v68;
  LODWORD(v6) = HIDWORD(v6);
  v78 = v6 >> 31;
  v79 = v75 + v60 + (v72 | v71) + 1518500249 + v76;
  v80 = v74 & v73;
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v81 = v6 >> 2;
  v82 = v80 | v77;
  v83 = bswap32(a2[15]);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v84 = v47 ^ v41 ^ v83;
  v85 = v83 + v64 + v82 + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v86 = v6 >> 2;
  v87 = v78 + v70 + (v81 & v79 | v74 & ~v79);
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v88 = v6 >> 27;
  HIDWORD(v6) = v27 ^ v47 ^ v75;
  LODWORD(v6) = HIDWORD(v6);
  v89 = v6 >> 31;
  v90 = v86 & v85;
  v91 = v87 + 1518500249 + v88;
  v92 = v81 & ~v85;
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v93 = v6 >> 2;
  v94 = v90 | v92;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v95 = v6 >> 27;
  v96 = v89 + v74 + v94 + 1518500249;
  HIDWORD(v6) = v28 ^ v16 ^ v56 ^ v83;
  LODWORD(v6) = HIDWORD(v6);
  v97 = v6 >> 31;
  v98 = v86 & ~v91;
  v99 = v96 + v95;
  v100 = v93 & v91;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v101 = v6 >> 2;
  v102 = v97 + v81 + (v100 | v98);
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v103 = v6 >> 27;
  v104 = v102 + 1518500249;
  HIDWORD(v6) = v35 ^ v58 ^ v78;
  LODWORD(v6) = HIDWORD(v6);
  v105 = v6 >> 31;
  v106 = v101 & v99 | v93 & ~v99;
  v107 = v104 + v103;
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v108 = v6 >> 2;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v109 = v6 >> 27;
  v110 = v105 + v86 + v106 + 1518500249;
  HIDWORD(v6) = v37 ^ v28 ^ v65 ^ v89;
  LODWORD(v6) = HIDWORD(v6);
  v111 = v6 >> 31;
  v112 = v110 + v109;
  v113 = v108 ^ v101 ^ v107;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v114 = v6 >> 2;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v115 = v6 >> 27;
  HIDWORD(v6) = v42 ^ v68 ^ v97;
  LODWORD(v6) = HIDWORD(v6);
  v116 = v6 >> 31;
  v117 = v111 + v93 + v113 + 1859775393 + v115;
  v118 = v114 ^ v108 ^ v112;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v119 = v6 >> 2;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v120 = v6 >> 27;
  v121 = v116 + v101 + v118 + 1859775393;
  HIDWORD(v6) = v43 ^ v37 ^ v75 ^ v105;
  LODWORD(v6) = HIDWORD(v6);
  v122 = v6 >> 31;
  v123 = v121 + v120;
  v124 = v119 ^ v114 ^ v117;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v125 = v6 >> 2;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v126 = v6 >> 27;
  HIDWORD(v6) = v58 ^ v47 ^ v89 ^ v122;
  LODWORD(v6) = HIDWORD(v6);
  v127 = v6 >> 31;
  v128 = v122 + v108 + v124 + 1859775393;
  HIDWORD(v6) = v84 ^ v111;
  LODWORD(v6) = v84 ^ v111;
  v129 = v6 >> 31;
  v130 = v128 + v126;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v131 = v6 >> 2;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v132 = v6 >> 27;
  v133 = v129 + v114 + (v125 ^ v119 ^ v123) + 1859775393;
  HIDWORD(v6) = v56 ^ v43 ^ v78 ^ v116;
  LODWORD(v6) = HIDWORD(v6);
  v134 = v6 >> 31;
  v135 = v133 + v132;
  v136 = v131 ^ v125 ^ v130;
  v137 = v134 + v119;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v138 = v6 >> 2;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v139 = v6 >> 27;
  HIDWORD(v6) = v68 ^ v58 ^ v105 ^ v134;
  LODWORD(v6) = HIDWORD(v6);
  v140 = v6 >> 31;
  v141 = v137 + v136 + 1859775393 + v139;
  v142 = v138 ^ v131 ^ v135;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v143 = v6 >> 2;
  v144 = v127 + v125 + v142;
  v145 = v65 ^ v56 ^ v97 ^ v129;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v146 = v6 >> 27;
  v147 = v144 + 1859775393;
  HIDWORD(v6) = v145;
  LODWORD(v6) = v145;
  v148 = v6 >> 31;
  v149 = v147 + v146;
  v150 = v143 ^ v138 ^ v141;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v151 = v6 >> 2;
  v152 = v148 + v131;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v153 = v6 >> 27;
  v154 = v152 + v150;
  v155 = v151 ^ v143 ^ v149;
  HIDWORD(v6) = v83 ^ v68 ^ v116 ^ v148;
  LODWORD(v6) = HIDWORD(v6);
  v156 = v6 >> 31;
  v157 = v154 + 1859775393 + v153;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v158 = v6 >> 2;
  v159 = v75 ^ v65 ^ v111;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v160 = v6 >> 27;
  HIDWORD(v6) = v159 ^ v127;
  LODWORD(v6) = v159 ^ v127;
  v161 = v6 >> 31;
  v162 = v140 + v138 + v155 + 1859775393 + v160;
  v163 = v158 ^ v151 ^ v157;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v164 = v6 >> 2;
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v165 = v161 + v143 + v163 + 1859775393 + (v6 >> 27);
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v166 = v6 >> 2;
  v167 = v156 + v151 + (v164 ^ v158 ^ v162) + 1859775393;
  HIDWORD(v6) = v78 ^ v75 ^ v122 ^ v140;
  LODWORD(v6) = HIDWORD(v6);
  v168 = v6 >> 31;
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v169 = v168 + v158;
  v170 = v167 + (v6 >> 27);
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v171 = v6 >> 2;
  v172 = v169 + (v166 ^ v164 ^ v165);
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v173 = v6 >> 27;
  v174 = v172 + 1859775393;
  HIDWORD(v6) = v89 ^ v83 ^ v129 ^ v161;
  LODWORD(v6) = HIDWORD(v6);
  v175 = v6 >> 31;
  v176 = v174 + v173;
  v177 = v171 ^ v166 ^ v170;
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v178 = v6 >> 2;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v179 = v6 >> 27;
  v180 = v175 + v164 + v177;
  HIDWORD(v6) = v97 ^ v78 ^ v134 ^ v156;
  LODWORD(v6) = HIDWORD(v6);
  v181 = v6 >> 31;
  v182 = v180 + 1859775393 + v179;
  v183 = v181 + v166;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v184 = v6 >> 2;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v185 = v6 >> 27;
  v186 = v183 + (v178 ^ v171 ^ v176);
  HIDWORD(v6) = v105 ^ v89 ^ v127 ^ v168;
  LODWORD(v6) = HIDWORD(v6);
  v187 = v6 >> 31;
  v188 = v186 + 1859775393 + v185;
  v189 = v184 ^ v178 ^ v182;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v190 = v6 >> 2;
  v191 = v187 + v171 + v189;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v192 = v6 >> 27;
  v193 = v191 + 1859775393;
  HIDWORD(v6) = v111 ^ v97 ^ v148 ^ v175;
  LODWORD(v6) = HIDWORD(v6);
  v194 = v6 >> 31;
  v195 = v193 + v192;
  v196 = v190 ^ v184 ^ v188;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v197 = v6 >> 2;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v198 = v6 >> 27;
  HIDWORD(v6) = v116 ^ v105 ^ v140 ^ v181;
  LODWORD(v6) = HIDWORD(v6);
  v199 = v6 >> 31;
  v200 = v197 ^ v190 ^ v195;
  v201 = v194 + v178 + v196 + 1859775393 + v198;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v202 = v6 >> 2;
  v203 = v199 + v184;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v204 = v6 >> 27;
  v205 = v203 + v200 + 1859775393;
  HIDWORD(v6) = v122 ^ v111 ^ v161 ^ v187;
  LODWORD(v6) = HIDWORD(v6);
  v206 = v6 >> 31;
  v207 = v205 + v204;
  v208 = v202 ^ v197 ^ v201;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v209 = v6 >> 2;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v210 = v6 >> 27;
  v211 = v206 + v190 + v208;
  HIDWORD(v6) = v129 ^ v116 ^ v156 ^ v194;
  LODWORD(v6) = HIDWORD(v6);
  v212 = v6 >> 31;
  v213 = v209 ^ v202 ^ v207;
  v214 = v211 + 1859775393 + v210;
  v215 = v212 + v197;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v216 = v6 >> 2;
  v217 = v134 ^ v122 ^ v168;
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v218 = v6 >> 27;
  HIDWORD(v6) = v217 ^ v199;
  LODWORD(v6) = v217 ^ v199;
  v219 = v6 >> 31;
  v220 = v215 + v213 + 1859775393 + v218;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v221 = v6 >> 27;
  v222 = v219 + v202 + (v216 ^ v209 ^ v214);
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v223 = v6 >> 2;
  HIDWORD(v6) = v127 ^ v129 ^ v175 ^ v206;
  LODWORD(v6) = HIDWORD(v6);
  v224 = v6 >> 31;
  v225 = v222 + 1859775393 + v221;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v226 = v6 >> 27;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v227 = v6 >> 2;
  HIDWORD(v6) = v140 ^ v127 ^ v187 ^ v219;
  LODWORD(v6) = HIDWORD(v6);
  v228 = v6 >> 31;
  v229 = v224 + v209 + (v223 ^ v216 ^ v220) + 1859775393 + v226;
  HIDWORD(v6) = v148 ^ v134 ^ v181 ^ v212;
  LODWORD(v6) = HIDWORD(v6);
  v230 = v6 >> 31;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v231 = v6 >> 2;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v232 = v6 >> 27;
  v233 = v230 + v216 + ((v225 | v227) & v223 | v225 & v227);
  v234 = (v229 | v231) & v227;
  v235 = v229 & v231;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v236 = v6 >> 2;
  v237 = v233 - 1894007588 + v232;
  HIDWORD(v6) = v161 ^ v148 ^ v194 ^ v224;
  LODWORD(v6) = HIDWORD(v6);
  v238 = v6 >> 31;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v239 = v228 + v223 + (v234 | v235) - 1894007588 + (v6 >> 27);
  v240 = v238 + v227;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v241 = v6 >> 2;
  v242 = (v237 | v236) & v231 | v237 & v236;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v243 = v6 >> 27;
  HIDWORD(v6) = v156 ^ v140 ^ v199 ^ v230;
  LODWORD(v6) = HIDWORD(v6);
  v244 = v6 >> 31;
  v245 = v240 + v242 - 1894007588 + v243;
  v246 = (v239 | v241) & v236 | v239 & v241;
  v247 = v244 + v231;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v248 = v6 >> 2;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v249 = v6 >> 27;
  HIDWORD(v6) = v168 ^ v161 ^ v206 ^ v228;
  LODWORD(v6) = HIDWORD(v6);
  v250 = v6 >> 31;
  v251 = v247 + v246 - 1894007588 + v249;
  v252 = (v245 | v248) & v241 | v245 & v248;
  v253 = v250 + v236;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v254 = v6 >> 2;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v255 = v6 >> 27;
  HIDWORD(v6) = v175 ^ v156 ^ v212 ^ v238;
  LODWORD(v6) = HIDWORD(v6);
  v256 = v6 >> 31;
  v257 = v253 + v252 - 1894007588 + v255;
  v258 = (v251 | v254) & v248 | v251 & v254;
  v259 = v256 + v241;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v260 = v6 >> 2;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v261 = v6 >> 27;
  HIDWORD(v6) = v181 ^ v168 ^ v219 ^ v244;
  LODWORD(v6) = HIDWORD(v6);
  v262 = v6 >> 31;
  v263 = v259 + v258 - 1894007588 + v261;
  v264 = (v257 | v260) & v254 | v257 & v260;
  v265 = v262 + v248;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v266 = v6 >> 2;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v267 = v6 >> 27;
  HIDWORD(v6) = v187 ^ v175 ^ v224 ^ v250;
  LODWORD(v6) = HIDWORD(v6);
  v268 = v6 >> 31;
  v269 = v265 + v264 - 1894007588 + v267;
  v270 = (v263 | v266) & v260 | v263 & v266;
  v271 = v268 + v254;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v272 = v6 >> 2;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v273 = v6 >> 27;
  HIDWORD(v6) = v194 ^ v181 ^ v230 ^ v256;
  LODWORD(v6) = HIDWORD(v6);
  v274 = v6 >> 31;
  v275 = v271 + v270 - 1894007588 + v273;
  v276 = (v269 | v272) & v266 | v269 & v272;
  v277 = v274 + v260;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v278 = v6 >> 2;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v279 = v6 >> 27;
  HIDWORD(v6) = v199 ^ v187 ^ v228 ^ v262;
  LODWORD(v6) = HIDWORD(v6);
  v280 = v6 >> 31;
  v281 = v277 + v276 - 1894007588 + v279;
  v282 = (v275 | v278) & v272 | v275 & v278;
  v283 = v280 + v266;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v284 = v6 >> 2;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v285 = v6 >> 27;
  HIDWORD(v6) = v206 ^ v194 ^ v238 ^ v268;
  LODWORD(v6) = HIDWORD(v6);
  v286 = v6 >> 31;
  v287 = v283 + v282 - 1894007588 + v285;
  v288 = (v281 | v284) & v278 | v281 & v284;
  v289 = v286 + v272;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v290 = v6 >> 2;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v291 = v6 >> 27;
  HIDWORD(v6) = v212 ^ v199 ^ v244 ^ v274;
  LODWORD(v6) = HIDWORD(v6);
  v292 = v6 >> 31;
  v293 = v289 + v288 - 1894007588 + v291;
  v294 = (v287 | v290) & v284 | v287 & v290;
  v295 = v292 + v278;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v296 = v6 >> 2;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v297 = v6 >> 27;
  HIDWORD(v6) = v219 ^ v206 ^ v250 ^ v280;
  LODWORD(v6) = HIDWORD(v6);
  v298 = v6 >> 31;
  v299 = v295 + v294 - 1894007588 + v297;
  v300 = (v293 | v296) & v290 | v293 & v296;
  v301 = v298 + v284;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v302 = v6 >> 2;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v303 = v6 >> 27;
  HIDWORD(v6) = v224 ^ v212 ^ v256 ^ v286;
  LODWORD(v6) = HIDWORD(v6);
  v304 = v6 >> 31;
  v305 = v301 + v300 - 1894007588 + v303;
  v306 = (v299 | v302) & v296 | v299 & v302;
  v307 = v304 + v290;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v308 = v6 >> 2;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v309 = v6 >> 27;
  HIDWORD(v6) = v230 ^ v219 ^ v262 ^ v292;
  LODWORD(v6) = HIDWORD(v6);
  v310 = v6 >> 31;
  v311 = v307 + v306 - 1894007588 + v309;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v312 = v6 >> 2;
  v313 = (v305 | v308) & v302 | v305 & v308;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v314 = v6 >> 27;
  HIDWORD(v6) = v228 ^ v224 ^ v268 ^ v298;
  LODWORD(v6) = HIDWORD(v6);
  v315 = v6 >> 31;
  v316 = v310 + v296 + v313 - 1894007588 + v314;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v317 = v6 >> 2;
  v318 = v315 + v302 + ((v311 | v312) & v308 | v311 & v312);
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v319 = v6 >> 27;
  v320 = v318 - 1894007588;
  HIDWORD(v6) = v238 ^ v230 ^ v274 ^ v304;
  LODWORD(v6) = HIDWORD(v6);
  v321 = v6 >> 31;
  v322 = (v316 | v317) & v312 | v316 & v317;
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v323 = v6 >> 2;
  v324 = v320 + v319;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v325 = v6 >> 27;
  v326 = v321 + v308 + v322 - 1894007588;
  HIDWORD(v6) = v244 ^ v228 ^ v280 ^ v310;
  LODWORD(v6) = HIDWORD(v6);
  v327 = v6 >> 31;
  v328 = v326 + v325;
  v329 = (v324 | v323) & v317 | v324 & v323;
  v330 = v327 + v312;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v331 = v6 >> 2;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v332 = v6 >> 27;
  v333 = v330 + v329 - 1894007588;
  v334 = v328 & v331;
  v335 = (v328 | v331) & v323;
  HIDWORD(v6) = v250 ^ v238 ^ v286 ^ v315;
  LODWORD(v6) = HIDWORD(v6);
  v336 = v6 >> 31;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v337 = v6 >> 2;
  v338 = v333 + v332;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v339 = v6 >> 27;
  HIDWORD(v6) = v256 ^ v244 ^ v292 ^ v321;
  LODWORD(v6) = HIDWORD(v6);
  v340 = v6 >> 31;
  v341 = v262 ^ v250 ^ v298;
  v342 = v336 + v317 + (v335 | v334) - 1894007588 + v339;
  v343 = (v338 | v337) & v331 | v338 & v337;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v344 = v6 >> 2;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v345 = v6 >> 27;
  v346 = v340 + v323 + v343;
  HIDWORD(v6) = v341 ^ v327;
  LODWORD(v6) = v341 ^ v327;
  v347 = v6 >> 31;
  v348 = v346 - 1894007588 + v345;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v349 = v6 >> 2;
  v350 = v347 + v331;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v351 = v6 >> 27;
  HIDWORD(v6) = v268 ^ v256 ^ v304 ^ v336;
  LODWORD(v6) = HIDWORD(v6);
  v352 = v6 >> 31;
  v353 = v350 + (v344 ^ v337 ^ v342) - 899497514;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v354 = v6 >> 2;
  v355 = v353 + v351;
  v356 = v352 + v337;
  HIDWORD(v6) = v274 ^ v262 ^ v310 ^ v340;
  LODWORD(v6) = HIDWORD(v6);
  v357 = v6 >> 31;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v358 = v356 + (v349 ^ v344 ^ v348) - 899497514 + (v6 >> 27);
  v359 = v357 + v344 + (v354 ^ v349 ^ v355);
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v360 = v6 >> 27;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v361 = v6 >> 2;
  v362 = v280 ^ v268 ^ v315 ^ v347;
  v363 = v286 ^ v274;
  HIDWORD(v6) = v362;
  LODWORD(v6) = v362;
  v364 = v6 >> 31;
  v365 = v359 - 899497514 + v360;
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v366 = v6 >> 2;
  v367 = v361 ^ v354 ^ v358;
  HIDWORD(v6) = v363 ^ v321 ^ v352;
  LODWORD(v6) = HIDWORD(v6);
  v368 = v6 >> 31;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v369 = v364 + v349 + v367 - 899497514 + (v6 >> 27);
  v370 = v368 + v354 + (v366 ^ v361 ^ v365);
  v371 = v292 ^ v280 ^ v327;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v372 = v6 >> 27;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v373 = v6 >> 2;
  v374 = v371 ^ v357;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v375 = v6 >> 2;
  v376 = v370 - 899497514 + v372;
  HIDWORD(v6) = v374;
  LODWORD(v6) = v374;
  v377 = v6 >> 31;
  HIDWORD(v6) = v298 ^ v286 ^ v336 ^ v364;
  LODWORD(v6) = HIDWORD(v6);
  v378 = v6 >> 31;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v379 = v377 + v361 + (v373 ^ v366 ^ v369) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v380 = v6 >> 27;
  v381 = v378 + v366 + (v375 ^ v373 ^ v376) - 899497514;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v382 = v6 >> 2;
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v383 = v6 >> 2;
  HIDWORD(v6) = v304 ^ v292 ^ v340 ^ v368;
  LODWORD(v6) = HIDWORD(v6);
  v384 = v6 >> 31;
  v385 = v381 + v380;
  HIDWORD(v6) = v310 ^ v298 ^ v347 ^ v377;
  LODWORD(v6) = HIDWORD(v6);
  v386 = v6 >> 31;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v387 = v384 + v373 + (v382 ^ v375 ^ v379) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v388 = v6 >> 27;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v389 = v6 >> 2;
  HIDWORD(v6) = v315 ^ v304 ^ v352 ^ v378;
  LODWORD(v6) = HIDWORD(v6);
  v390 = v6 >> 31;
  v391 = v386 + v375 + (v383 ^ v382 ^ v385) - 899497514 + v388;
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v392 = v6 >> 2;
  HIDWORD(v6) = v321 ^ v310 ^ v357 ^ v384;
  LODWORD(v6) = HIDWORD(v6);
  v393 = v6 >> 31;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v394 = v390 + v382 + (v389 ^ v383 ^ v387) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v395 = v6 >> 27;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v396 = v6 >> 2;
  HIDWORD(v6) = v327 ^ v315 ^ v364 ^ v386;
  LODWORD(v6) = HIDWORD(v6);
  v397 = v6 >> 31;
  v398 = v393 + v383 + (v392 ^ v389 ^ v391) - 899497514 + v395;
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v399 = v6 >> 2;
  v400 = v396 ^ v392 ^ v394;
  v401 = v397 + v389;
  HIDWORD(v6) = v336 ^ v321 ^ v368 ^ v390;
  LODWORD(v6) = HIDWORD(v6);
  v402 = v6 >> 31;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v403 = v401 + v400 - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v404 = v6 >> 27;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v405 = v6 >> 2;
  HIDWORD(v6) = v340 ^ v327 ^ v377 ^ v393;
  LODWORD(v6) = HIDWORD(v6);
  v406 = v6 >> 31;
  v407 = v402 + v392 + (v399 ^ v396 ^ v398) - 899497514 + v404;
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v408 = v6 >> 2;
  v409 = v406 + v396;
  HIDWORD(v6) = v347 ^ v336 ^ v378 ^ v397;
  LODWORD(v6) = HIDWORD(v6);
  v410 = v6 >> 31;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v411 = v409 + (v405 ^ v399 ^ v403) - 899497514 + (v6 >> 27);
  v412 = v410 + v399 + (v408 ^ v405 ^ v407);
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v413 = v6 >> 27;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v414 = v6 >> 2;
  HIDWORD(v6) = v352 ^ v340 ^ v384 ^ v402;
  LODWORD(v6) = HIDWORD(v6);
  v415 = v6 >> 31;
  v416 = v412 - 899497514 + v413;
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v417 = v6 >> 2;
  HIDWORD(v6) = v357 ^ v347 ^ v386 ^ v406;
  LODWORD(v6) = HIDWORD(v6);
  v418 = v6 >> 31;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v419 = v415 + v405 + (v414 ^ v408 ^ v411) - 899497514 + (v6 >> 27);
  v420 = v418 + v408 + (v417 ^ v414 ^ v416);
  v421 = v364 ^ v352;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v422 = v6 >> 27;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v423 = v6 >> 2;
  v424 = v368 ^ v357 ^ v393;
  *a2 = v368;
  a2[1] = v377;
  v425 = v420 - 899497514 + v422;
  HIDWORD(v6) = v421 ^ v390 ^ v410;
  LODWORD(v6) = HIDWORD(v6);
  v426 = v6 >> 31;
  v427 = v423 ^ v417 ^ v419;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v428 = v6 >> 2;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v429 = v6 >> 27;
  a2[2] = v378;
  a2[3] = v384;
  HIDWORD(v6) = v424 ^ v415;
  LODWORD(v6) = v424 ^ v415;
  v430 = v6 >> 31;
  a2[4] = v386;
  a2[5] = v390;
  a2[8] = v402;
  a2[9] = v406;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v431 = v6 >> 2;
  v432 = v426 + v414 + v427 - 899497514 + v429;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v433 = v6 >> 27;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v434 = v6 >> 2;
  a2[6] = v393;
  a2[7] = v397;
  a2[10] = v410;
  a2[11] = v415;
  v435.n128_u32[0] = v430 + v417 + (v428 ^ v423 ^ v425) - 899497514 + v433;
  HIDWORD(v6) = v377 ^ v364 ^ v397 ^ v418;
  LODWORD(v6) = HIDWORD(v6);
  v436 = v6 >> 31;
  a2[12] = v418;
  a2[13] = v426;
  a2[14] = v430;
  a2[15] = v436;
  v435.n128_u32[1] = v434;
  v437 = *(int32x4_t *)(a1 + 1);
  v435.n128_u64[1] = __PAIR64__(v428, v431);
  HIDWORD(v6) = v435.n128_u32[0];
  LODWORD(v6) = v435.n128_u32[0];
  *a1 = *a1 + v436 + v423 + (v431 ^ v428 ^ v432) - 899497514 + (v6 >> 27);
  result = vaddq_s32(v435, v437);
  *(int32x4_t *)(a1 + 1) = result;
  return result;
}

//----- (000000000001B5E0) ----------------------------------------------------
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5)
{
  int v5; // w11
  __int64 v6; // x8
  _BYTE *v7; // x10
  unsigned int v8; // t1

  v5 = (int)a4;
  *a5 = 0;
  if ( a3 )
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *a2++;
      --v6;
      *v7 = a0123456789abcd[(unsigned __int64)v8 >> 4];
      v5 = (_DWORD)v7 + 2;
      v7[1] = a0123456789abcd[v8 & 0xF];
      v7 += 2;
    }
    while ( v6 );
  }
  *a5 = v5 - (_DWORD)a4;
}

//----- (000000000001B634) ----------------------------------------------------
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3)
{
  *a3 = 0;
}

//----- (000000000001B63C) ----------------------------------------------------
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  int v4; // w11
  __int64 v5; // x8
  _BYTE *v6; // x10
  unsigned int v7; // t1

  v4 = (int)a3;
  *a4 = 0;
  if ( a2 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      v7 = *result++;
      --v5;
      *v6 = a0123456789abcd[(unsigned __int64)v7 >> 4];
      v4 = (_DWORD)v6 + 2;
      v6[1] = a0123456789abcd[v7 & 0xF];
      v6 += 2;
    }
    while ( v5 );
  }
  *a4 = v4 - (_DWORD)a3;
  return result;
}

//----- (000000000001B690) ----------------------------------------------------
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  if ( a6 )
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (__fastcall *)(_QWORD *, _QWORD *, __int64))AES_encrypt);
  else
    CRYPTO_cbc128_decrypt(
      (__int64)a1,
      a2,
      a3,
      a4,
      (unsigned __int64)a5,
      (__int64 (__fastcall *)(int8x16_t *, int8x16_t *, __int64))AES_decrypt);
}

//----- (000000000001B6AC) ----------------------------------------------------
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w8
  int v4; // w8
  unsigned int v6; // w8
  unsigned int v7; // w9
  unsigned int v8; // w10
  unsigned int v9; // w11
  __int64 v10; // x9
  unsigned int *v11; // x14
  unsigned __int64 v12; // x16
  int v13; // w1
  int v14; // w0
  int v15; // w17
  unsigned int v16; // w12
  __int64 v17; // x13
  unsigned int *i; // x0
  int v19; // w2
  unsigned int v20; // w12
  __int64 v21; // x13
  unsigned int *j; // x0
  int v23; // w2
  int v24; // w3
  int v25; // w4

  v3 = -1;
  if ( a1 && a3 )
  {
    if ( a2 != 128 && a2 != 256 && a2 != 192 )
      return 4294967294LL;
    if ( a2 == 128 )
    {
      v4 = 10;
    }
    else if ( a2 == 192 )
    {
      v4 = 12;
    }
    else
    {
      v4 = 14;
    }
    a3[60] = v4;
    v6 = bswap32(*a1);
    *a3 = v6;
    v7 = bswap32(a1[1]);
    a3[1] = v7;
    v8 = bswap32(a1[2]);
    a3[2] = v8;
    v9 = bswap32(a1[3]);
    a3[3] = v9;
    if ( a2 == 128 )
    {
      v10 = 0;
      v11 = a3 + 4;
      do
      {
        v12 = *(v11 - 1);
        v13 = *(_DWORD *)((char *)&unk_8D50 + v10);
        v10 += 4;
        v6 ^= (byte_7D50[4 * BYTE2(v12) + 3] << 24)
            ^ (byte_8150[4 * BYTE1(v12) + 2] << 16)
            ^ (byte_8550[4 * (unsigned __int8)v12 + 1] << 8)
            ^ byte_8950[(v12 >> 22) & 0x3FC]
            ^ v13;
        v14 = *(v11 - 3) ^ v6;
        v15 = *(v11 - 2) ^ v14;
        *v11 = v6;
        v11[1] = v14;
        v11[2] = v15;
        v11[3] = v15 ^ v12;
        v11 += 4;
      }
      while ( v10 != 40 );
    }
    else
    {
      a3[4] = bswap32(a1[4]);
      v16 = bswap32(a1[5]);
      a3[5] = v16;
      if ( a2 == 192 )
      {
        v17 = 0;
        for ( i = a3 + 11; ; i += 6 )
        {
          v6 ^= (byte_7D50[4 * BYTE2(v16) + 3] << 24)
              ^ (byte_8150[4 * BYTE1(v16) + 2] << 16)
              ^ (byte_8550[4 * (unsigned __int8)v16 + 1] << 8)
              ^ byte_8950[4 * HIBYTE(v16)]
              ^ *(_DWORD *)((char *)&unk_8D50 + v17);
          v7 ^= v6;
          v8 ^= v7;
          *(i - 5) = v6;
          *(i - 4) = v7;
          v9 ^= v8;
          *(i - 3) = v8;
          *(i - 2) = v9;
          if ( v17 == 28 )
            break;
          v17 += 4;
          v19 = *(i - 7) ^ v9;
          v16 ^= v19;
          *(i - 1) = v19;
          *i = v16;
        }
      }
      else
      {
        a3[6] = bswap32(a1[6]);
        v20 = bswap32(a1[7]);
        a3[7] = v20;
        v21 = 0;
        for ( j = a3 + 8; ; j += 8 )
        {
          v6 ^= (byte_7D50[4 * BYTE2(v20) + 3] << 24)
              ^ (byte_8150[4 * BYTE1(v20) + 2] << 16)
              ^ (byte_8550[4 * (unsigned __int8)v20 + 1] << 8)
              ^ byte_8950[4 * HIBYTE(v20)]
              ^ *(_DWORD *)((char *)&unk_8D50 + v21);
          v7 ^= v6;
          v8 ^= v7;
          *j = v6;
          j[1] = v7;
          v9 ^= v8;
          j[2] = v8;
          j[3] = v9;
          if ( v21 == 24 )
            break;
          v21 += 4;
          v23 = *(j - 4)
              ^ (byte_7D50[4 * HIBYTE(v9) + 3] << 24)
              ^ (byte_8150[4 * BYTE2(v9) + 2] << 16)
              ^ (byte_8550[4 * BYTE1(v9) + 1] << 8)
              ^ byte_8950[4 * (unsigned __int8)v9];
          v24 = *(j - 2);
          v25 = *(j - 3) ^ v23;
          j[4] = v23;
          j[5] = v25;
          v20 ^= v24 ^ v25;
          j[6] = v24 ^ v25;
          j[7] = v20;
        }
      }
    }
    return 0;
  }
  return v3;
}
// 1B8D0: conditional instruction was optimized away because w1.4==100
// 7D50: using guessed type unsigned __int8 byte_7D50[1024];
// 8150: using guessed type unsigned __int8 byte_8150[1024];
// 8550: using guessed type unsigned __int8 byte_8550[1024];
// 8950: using guessed type unsigned __int8 byte_8950[1024];

//----- (000000000001B9D0) ----------------------------------------------------
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  __int64 result; // x0
  int v5; // w9
  int v6; // w10
  unsigned int *v7; // x9
  __int64 v8; // x8
  __int64 v9; // x11
  unsigned int *v10; // x10
  __int64 v11; // x11
  unsigned int v12; // w13
  bool v13; // cc
  unsigned int v14; // w13
  unsigned int v15; // w13
  unsigned int v16; // w13
  int *v17; // x11
  int v18; // w13
  unsigned __int64 v19; // x15
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x2
  __int64 v22; // x0
  __int64 v23; // x1
  __int64 v24; // x16
  __int64 v25; // x17
  __int64 v26; // x0
  unsigned __int64 v27; // x1
  __int64 v28; // x16
  __int64 v29; // x15
  __int64 v30; // x17
  __int64 v31; // x0
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x17
  __int64 v34; // x0
  __int64 v35; // x16
  __int64 v36; // x1

  result = private_AES_set_encrypt_key(a1, a2, a3);
  if ( (result & 0x80000000) == 0 )
  {
    v5 = a3[60];
    if ( v5 >= 1 )
    {
      v6 = 4 * v5;
      v7 = a3 + 2;
      v8 = 0;
      v9 = v6;
      v10 = &a3[v6 + 2];
      v11 = v9 - 4;
      do
      {
        v12 = *(v7 - 2);
        v8 += 4;
        v13 = v8 < v11;
        v11 -= 4;
        *(v7 - 2) = *(v10 - 2);
        *(v10 - 2) = v12;
        v14 = *(v7 - 1);
        *(v7 - 1) = *(v10 - 1);
        *(v10 - 1) = v14;
        v15 = *v7;
        *v7 = *v10;
        *v10 = v15;
        v16 = v7[1];
        v7[1] = v10[1];
        v7 += 4;
        v10[1] = v16;
        v10 -= 4;
      }
      while ( v13 );
      if ( (int)a3[60] >= 2 )
      {
        v17 = (int *)(a3 + 7);
        v18 = 1;
        do
        {
          v19 = (unsigned int)*(v17 - 3);
          v20 = (unsigned int)*(v17 - 2);
          ++v18;
          v21 = v20 >> 22;
          v22 = BYTE2(v20);
          v23 = BYTE1(v20);
          v24 = 4LL * (unsigned __int8)*(v17 - 2);
          *(v17 - 3) = dword_9178[byte_8950[4 * BYTE2(v19)]]
                     ^ dword_8D78[byte_8950[(v19 >> 22) & 0x3FC]]
                     ^ dword_9578[byte_8950[4 * BYTE1(v19)]]
                     ^ dword_9978[byte_8950[4 * (unsigned __int8)*(v17 - 3)]];
          v25 = byte_8950[4 * v22];
          v26 = byte_8950[4 * v23];
          v27 = (unsigned int)*(v17 - 1);
          LODWORD(v19) = dword_9178[v25]
                       ^ dword_8D78[byte_8950[v21 & 0x3FC]]
                       ^ dword_9578[v26]
                       ^ dword_9978[byte_8950[v24]];
          v28 = 4LL * (unsigned __int8)*(v17 - 1);
          *(v17 - 2) = v19;
          v29 = byte_8950[(v27 >> 22) & 0x3FC];
          v30 = byte_8950[4 * BYTE2(v27)];
          v31 = byte_8950[4 * BYTE1(v27)];
          v32 = (unsigned int)*v17;
          LODWORD(v29) = dword_9178[v30] ^ dword_8D78[v29];
          v33 = v32 >> 22;
          LODWORD(v28) = dword_9578[v31] ^ dword_9978[byte_8950[v28]];
          v34 = BYTE2(v32);
          LODWORD(v29) = v29 ^ v28;
          v35 = BYTE1(v32);
          v36 = (unsigned __int8)*v17;
          *(v17 - 1) = v29;
          *v17 = dword_9178[byte_8950[4 * v34]]
               ^ dword_8D78[byte_8950[v33 & 0x3FC]]
               ^ dword_9578[byte_8950[4 * v35]]
               ^ dword_9978[byte_8950[4 * v36]];
          v17 += 4;
        }
        while ( v18 < (int)a3[60] );
      }
    }
    return 0;
  }
  return result;
}
// 8950: using guessed type unsigned __int8 byte_8950[1024];
// 8D78: using guessed type _DWORD dword_8D78[256];
// 9178: using guessed type _DWORD dword_9178[256];
// 9578: using guessed type _DWORD dword_9578[256];
// 9978: using guessed type _DWORD dword_9978[256];

//----- (000000000001BC0C) ----------------------------------------------------
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w5
  unsigned int v4; // w16
  _DWORD *v5; // x14
  unsigned int v6; // w15
  unsigned int v7; // w17
  int i; // w13
  unsigned int v9; // w7
  int v10; // w0
  unsigned int v11; // w3
  int v12; // w17
  unsigned int v13; // w25
  unsigned int v14; // w21
  unsigned int v15; // w15
  unsigned int v16; // w22
  unsigned int v17; // w19
  int v18; // w6
  __int64 result; // x0
  int v20; // w24
  int v21; // w25
  int v22; // w5
  int v23; // w22
  int v24; // w23
  int v25; // w24
  int v26; // w26
  int v27; // w17
  int v28; // w0
  _DWORD *v29; // x12

  v3 = bswap32(*a1) ^ *a3;
  v4 = bswap32(a1[1]) ^ a3[1];
  v5 = a3 + 6;
  v6 = bswap32(a1[2]) ^ a3[2];
  v7 = bswap32(a1[3]) ^ a3[3];
  for ( i = ((int)a3[60] >> 1) - 1; ; --i )
  {
    v9 = *(_DWORD *)&byte_8950[4 * BYTE2(v4)]
       ^ *(_DWORD *)&byte_8550[4 * HIBYTE(v3)]
       ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v6)]
       ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v7]
       ^ *(v5 - 2);
    v10 = BYTE2(v7);
    v11 = *(_DWORD *)&byte_8950[4 * BYTE2(v6)]
        ^ *(_DWORD *)&byte_8550[4 * HIBYTE(v4)]
        ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v7)]
        ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v3]
        ^ *(v5 - 1);
    v12 = *(_DWORD *)&byte_8950[4 * BYTE2(v3)]
        ^ *(_DWORD *)&byte_8550[4 * HIBYTE(v7)]
        ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v4)]
        ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v6];
    v13 = HIBYTE(v9);
    v14 = HIBYTE(v11);
    v15 = *(_DWORD *)&byte_8950[4 * v10]
        ^ *(_DWORD *)&byte_8550[4 * HIBYTE(v6)]
        ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v3)]
        ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v4]
        ^ *v5;
    v16 = v12 ^ v5[1];
    v17 = HIBYTE(v15);
    v18 = BYTE2(v16);
    result = HIBYTE(v16);
    if ( !i )
      break;
    v20 = *(_DWORD *)&byte_8950[4 * BYTE2(v11)] ^ *(_DWORD *)&byte_8550[4 * v13];
    v21 = *(_DWORD *)&byte_7D50[4 * BYTE1(v16)];
    v22 = v20
        ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v15)]
        ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))];
    v23 = v5[2];
    v24 = v5[3];
    v25 = v5[4];
    v26 = v5[5];
    v27 = *(_DWORD *)&byte_8950[4 * BYTE2(v9)] ^ *(_DWORD *)&byte_8550[4 * (unsigned int)result];
    v28 = *(_DWORD *)&byte_7D50[4 * BYTE1(v11)] ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v15];
    v5 += 8;
    v3 = v22 ^ v23;
    v4 = *(_DWORD *)&byte_8950[4 * BYTE2(v15)]
       ^ *(_DWORD *)&byte_8550[4 * v14]
       ^ v21
       ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v9]
       ^ v24;
    v6 = *(_DWORD *)&byte_8950[4 * v18]
       ^ *(_DWORD *)&byte_8550[4 * v17]
       ^ *(_DWORD *)&byte_7D50[4 * BYTE1(v9)]
       ^ *(_DWORD *)&byte_8150[4 * (unsigned __int8)v11]
       ^ v25;
    v7 = v27 ^ v28 ^ v26;
  }
  v29 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_7D50[4 * v13 + 3] << 24)
         | (byte_8150[4 * BYTE2(v11) + 2] << 16)
         | (byte_8550[4 * BYTE1(v15) + 1] << 8)
         | byte_8950[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))])
        ^ v29[8]);
  a2[1] = bswap32(
            ((byte_7D50[4 * v14 + 3] << 24)
           | (byte_8150[4 * BYTE2(v15) + 2] << 16)
           | (byte_8550[4 * BYTE1(v16) + 1] << 8)
           | byte_8950[4 * (unsigned __int8)v9])
          ^ v29[9]);
  a2[2] = bswap32(
            ((byte_7D50[4 * v17 + 3] << 24)
           | (byte_8150[4 * BYTE2(v16) + 2] << 16)
           | (byte_8550[4 * BYTE1(v9) + 1] << 8)
           | byte_8950[4 * (unsigned __int8)v11])
          ^ v29[10]);
  a2[3] = bswap32(
            ((byte_7D50[4 * (unsigned int)result + 3] << 24)
           | (byte_8150[4 * BYTE2(v9) + 2] << 16)
           | (byte_8550[4 * BYTE1(v11) + 1] << 8)
           | byte_8950[4 * (unsigned __int8)v15])
          ^ v29[11]);
  return result;
}
// 7D50: using guessed type unsigned __int8 byte_7D50[1024];
// 8150: using guessed type unsigned __int8 byte_8150[1024];
// 8550: using guessed type unsigned __int8 byte_8550[1024];
// 8950: using guessed type unsigned __int8 byte_8950[1024];

//----- (000000000001BF48) ----------------------------------------------------
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w13
  unsigned int v4; // w17
  unsigned int v5; // w16
  _DWORD *v6; // x15
  unsigned int v7; // w0
  unsigned int v8; // w3
  int v9; // w14
  unsigned int v10; // w4
  unsigned __int64 v11; // x9
  int v12; // w5
  int v13; // w6
  int v14; // w7
  unsigned __int64 v15; // x16
  unsigned __int64 result; // x0
  unsigned __int64 v17; // x3
  int v18; // w7
  int v19; // w4
  int v20; // w5
  int v21; // w6
  int v22; // w19
  int v23; // w9
  _DWORD *v24; // x8

  v3 = a1[3];
  v4 = bswap32(*a1) ^ *a3;
  v5 = bswap32(a1[1]) ^ a3[1];
  v6 = a3 + 6;
  v7 = bswap32(a1[2]) ^ a3[2];
  v8 = bswap32(v3) ^ a3[3];
  v9 = ((int)a3[60] >> 1) - 1;
  while ( 1 )
  {
    v10 = *(v6 - 1);
    v11 = dword_9178[BYTE2(v8)]
        ^ dword_8D78[HIBYTE(v4)]
        ^ (unsigned int)(dword_9578[BYTE1(v7)] ^ dword_9978[(unsigned __int8)v5])
        ^ *(v6 - 2);
    v12 = BYTE2(v5);
    v13 = dword_9178[BYTE2(v4)] ^ dword_8D78[HIBYTE(v5)] ^ dword_9578[BYTE1(v8)] ^ dword_9978[(unsigned __int8)v7];
    v14 = dword_9178[BYTE2(v7)] ^ dword_8D78[HIBYTE(v8)] ^ dword_9578[BYTE1(v5)] ^ dword_9978[(unsigned __int8)v4];
    v15 = v13 ^ v10;
    result = dword_9178[v12]
           ^ dword_8D78[HIBYTE(v7)]
           ^ (unsigned int)(dword_9578[BYTE1(v4)] ^ dword_9978[(unsigned __int8)v8])
           ^ *v6;
    v17 = (unsigned int)v14 ^ v6[1];
    if ( !v9 )
      break;
    --v9;
    v18 = v6[3];
    v19 = dword_9178[BYTE2(v11)] ^ dword_8D78[BYTE3(v15)] ^ dword_9578[BYTE1(v17)] ^ dword_9978[(unsigned __int8)result];
    v4 = dword_9178[BYTE2(v17)]
       ^ dword_8D78[BYTE3(v11)]
       ^ dword_9578[BYTE1(result)]
       ^ dword_9978[(unsigned __int8)v15]
       ^ v6[2];
    v20 = dword_9178[BYTE2(v15)] ^ dword_8D78[BYTE3(result)] ^ dword_9578[BYTE1(v11)] ^ dword_9978[(unsigned __int8)v17];
    v21 = v6[4];
    v22 = v6[5];
    v23 = dword_9178[BYTE2(result)] ^ dword_8D78[BYTE3(v17)] ^ dword_9578[BYTE1(v15)] ^ dword_9978[(unsigned __int8)v11];
    v6 += 8;
    v5 = v19 ^ v18;
    v7 = v20 ^ v21;
    v8 = v23 ^ v22;
  }
  v24 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_9D78[v11 >> 24] << 24)
         | (byte_9D78[BYTE2(v17)] << 16)
         | (byte_9D78[BYTE1(result)] << 8)
         | byte_9D78[(unsigned __int8)(v13 ^ v10)])
        ^ v24[8]);
  a2[1] = bswap32(
            ((byte_9D78[v15 >> 24] << 24)
           | (byte_9D78[BYTE2(v11)] << 16)
           | (byte_9D78[BYTE1(v17)] << 8)
           | byte_9D78[(unsigned __int8)result])
          ^ v24[9]);
  a2[2] = bswap32(
            ((byte_9D78[result >> 24] << 24)
           | (byte_9D78[BYTE2(v15)] << 16)
           | (byte_9D78[BYTE1(v11)] << 8)
           | byte_9D78[(unsigned __int8)v17])
          ^ v24[10]);
  a2[3] = bswap32(
            ((byte_9D78[v17 >> 24] << 24)
           | (byte_9D78[BYTE2(result)] << 16)
           | (byte_9D78[BYTE1(v15)] << 8)
           | byte_9D78[(unsigned __int8)v11])
          ^ v24[11]);
  return result;
}
// 8D78: using guessed type _DWORD dword_8D78[256];
// 9178: using guessed type _DWORD dword_9178[256];
// 9578: using guessed type _DWORD dword_9578[256];
// 9978: using guessed type _DWORD dword_9978[256];
// 9D78: using guessed type unsigned __int8 byte_9D78[256];

//----- (000000000001C26C) ----------------------------------------------------
const char *AES_options()
{
  return "aes(partial)";
}

//----- (000000000001C280) ----------------------------------------------------
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  unsigned __int64 v9; // x22
  _QWORD *v12; // x8
  _QWORD *v13; // x25
  __int64 i; // x9
  unsigned __int64 v15; // x9
  __int64 v16; // x10
  long double result; // q0

  v9 = a3;
  v12 = a5;
  if ( a3 >= 0x10 )
  {
    do
    {
      v13 = a2;
      *a2 = *v12 ^ *a1;
      a2[1] = v12[1] ^ a1[1];
      a6(a2, a2, a4);
      v9 -= 16LL;
      a1 += 2;
      a2 += 2;
      v12 = v13;
    }
    while ( v9 > 0xF );
    v12 = a2 - 2;
  }
  if ( v9 )
  {
    for ( i = 0; i != v9; ++i )
      *((_BYTE *)a2 + i) = *((_BYTE *)v12 + i) ^ *((_BYTE *)a1 + i);
    if ( (unsigned __int64)(i - 1) <= 0xE )
    {
      if ( v9 > 8 || (unsigned __int64)((char *)a2 - (char *)v12) < 0x20 )
        goto LABEL_19;
      v15 = 16 - v9;
      *(_QWORD *)((char *)a2 + v9) = *(_QWORD *)((char *)v12 + v9);
      v16 = (16 - v9) & 0x18;
      if ( v16 != 8 )
        *(_QWORD *)((char *)a2 + v9 + 8) = *(_QWORD *)((char *)v12 + v9 + 8);
      v9 += v16;
      if ( v15 != v16 )
      {
LABEL_19:
        do
        {
          *((_BYTE *)a2 + v9) = *((_BYTE *)v12 + v9);
          ++v9;
        }
        while ( v9 != 16 );
      }
    }
    a6(a2, a2, a4);
  }
  else
  {
    a2 = v12;
  }
  result = *(long double *)a2;
  *a5 = *(_OWORD *)a2;
  return result;
}

//----- (000000000001C3D4) ----------------------------------------------------
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  int8x16_t *v9; // x22
  unsigned __int64 v10; // x20
  int8x16_t *v11; // x25
  _QWORD *n128_u64; // x27
  int8x16_t *v13; // x21
  __int64 v14; // x10
  __int64 v15; // x8
  _OWORD *v16; // x8
  __int64 v17; // x10
  unsigned __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x9
  int8x16_t *v21; // x21
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x10
  unsigned __int64 v25; // x13
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x14
  int8x16_t *v30; // x12
  unsigned __int64 v31; // x15
  bool v33; // w10
  bool v35; // w11
  bool v37; // w13
  bool v39; // w12
  int8x16_t *v41; // x10
  int8x16_t *v42; // x11
  int8x16_t *v43; // x12
  int8x16_t *v44; // x13
  unsigned __int64 v45; // x14
  int8x16_t v46; // q1
  int8x16_t v47; // q2
  int8x16_t v48; // q4
  int8x16_t v49; // q5
  int8x16_t v50; // q0
  int8x16_t v51; // q1
  __int128 *v52; // x11
  _OWORD *v53; // x12
  unsigned __int64 v54; // x13
  __int128 v55; // q0
  __int128 v56; // q1
  unsigned __int64 v57; // x13
  unsigned __int64 v58; // x10
  __int64 *v59; // x12
  _QWORD *v60; // x13
  __int64 v61; // t1
  unsigned __int64 v62; // x8
  _BYTE *v63; // x9
  char *v64; // x10
  char v65; // t1
  _QWORD v66[2]; // [xsp+8h] [xbp-18h] BYREF
  __int64 v67; // [xsp+18h] [xbp-8h] BYREF

  v9 = (int8x16_t *)result;
  v10 = a3;
  v67 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (int8x16_t *)result != a2 )
  {
    v11 = a2;
    if ( a3 < 0x10 )
    {
      v16 = (_OWORD *)a5;
    }
    else
    {
      n128_u64 = (_QWORD *)a5;
      do
      {
        v13 = v9;
        result = a6(v9, v11, a4);
        v14 = v11->n128_i64[1];
        v10 -= 16LL;
        ++v9;
        v11->n128_u64[0] ^= *n128_u64;
        v15 = n128_u64[1];
        n128_u64 = v13->n128_u64;
        v11->n128_u64[1] = v14 ^ v15;
        ++v11;
      }
      while ( v10 > 0xF );
      v16 = v9[-1].n128_u64;
    }
    v21 = v9;
    v9 = v11;
    *(_OWORD *)a5 = *v16;
LABEL_11:
    if ( !v10 )
      return result;
    goto LABEL_12;
  }
  if ( a3 >= 0x10 )
  {
    do
    {
      result = a6(v9, (int8x16_t *)v66, a4);
      v17 = v66[1];
      v10 -= 16LL;
      v18 = v9->n128_u64[0];
      v9->n128_u64[0] = *(_QWORD *)a5 ^ v66[0];
      v19 = *(_QWORD *)(a5 + 8);
      *(_QWORD *)a5 = v18;
      v20 = v9->n128_i64[1];
      v9->n128_u64[1] = v19 ^ v17;
      v21 = ++v9;
      *(_QWORD *)(a5 + 8) = v20;
    }
    while ( v10 > 0xF );
    goto LABEL_11;
  }
  v21 = (int8x16_t *)result;
  if ( !a3 )
    return result;
LABEL_12:
  result = a6(v21, (int8x16_t *)v66, a4);
  v22 = 17 - v10;
  if ( v10 < 0x20 )
  {
    v23 = 0;
    goto LABEL_14;
  }
  v29 = (unsigned __int64)v9->n128_u64 + v10;
  v30 = (int8x16_t *)((char *)v66 + v10);
  v31 = a5 + v10;
  v33 = v9 < (int8x16_t *)((char *)v21 + v10) && (unsigned __int64)v21 < v29;
  v35 = v9 < v30 && (unsigned __int64)v66 < v29;
  v23 = 0;
  v37 = (unsigned __int64)v21->n128_u64 + v10 > a5 && (unsigned __int64)v21 < v31;
  v39 = (unsigned __int64)v30 > a5 && (unsigned __int64)v66 < v31;
  if ( v29 > a5 && (unsigned __int64)v9 < v31 )
    goto LABEL_14;
  if ( v33 )
    goto LABEL_14;
  if ( v35 )
    goto LABEL_14;
  if ( v37 )
    goto LABEL_14;
  if ( v39 )
    goto LABEL_14;
  v23 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  v41 = v21 + 1;
  v22 |= v10 & 0xFFFFFFFFFFFFFFE0LL;
  v42 = (int8x16_t *)&v67;
  v43 = v9 + 1;
  v44 = (int8x16_t *)(a5 + 16);
  v45 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v45 -= 32LL;
    v46 = v42[-1];
    v47 = *v42;
    v42 += 2;
    v48 = v41[-1];
    v49 = *v41;
    v41 += 2;
    v50 = veorq_s8(v44[-1], v46);
    v51 = veorq_s8(*v44, v47);
    v44[-1] = v48;
    *v44 = v49;
    v44 += 2;
    v43[-1] = v50;
    *v43 = v51;
    v43 += 2;
  }
  while ( v45 );
  if ( v23 != v10 )
  {
LABEL_14:
    v24 = 0;
    v25 = a5 + v23;
    do
    {
      result = v21->n128_u8[v23 + v24];
      v9->n128_u8[v23 + v24] = *(_BYTE *)(v25 + v24) ^ *((_BYTE *)v66 + v23 + v24);
      *(_BYTE *)(v25 + v24++) = result;
    }
    while ( v23 - v10 + v24 );
    v26 = v22 + v24 - 1;
    if ( v23 + v24 - 1 > 0xE )
      return result;
    goto LABEL_17;
  }
  v26 = v23 - v10 + 16;
  if ( v23 - 1 > 0xE )
    return result;
LABEL_17:
  v27 = 16 - v10;
  if ( 16 - v10 < 8 || a5 - (unsigned __int64)v21 < 0x20 )
    goto LABEL_70;
  if ( v27 < 0x20 )
  {
    v28 = 0;
    goto LABEL_65;
  }
  v28 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  v52 = (__int128 *)((char *)&v21[1] + v10);
  v53 = (_OWORD *)(a5 + v10 + 16);
  v54 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v55 = *(v52 - 1);
    v56 = *v52;
    v54 -= 32LL;
    v52 += 2;
    *(v53 - 1) = v55;
    *v53 = v56;
    v53 += 2;
  }
  while ( v54 );
  if ( v27 != v28 )
  {
    if ( (v27 & 0x18) == 0 )
    {
      v10 += v28;
      goto LABEL_70;
    }
LABEL_65:
    v57 = v10 + v28;
    v10 += v27 & 0xFFFFFFFFFFFFFFF8LL;
    v58 = v28 - (v27 & 0xFFFFFFFFFFFFFFF8LL);
    v59 = (__int64 *)((char *)v21 + v57);
    v60 = (_QWORD *)(a5 + v57);
    do
    {
      v61 = *v59++;
      v58 += 8LL;
      *v60++ = v61;
    }
    while ( v58 );
    if ( v27 == (v27 & 0xFFFFFFFFFFFFFFF8LL) )
      return result;
LABEL_70:
    v62 = v26 - v10;
    v63 = (_BYTE *)(a5 + v10);
    v64 = (char *)v21 + v10;
    do
    {
      v65 = *v64++;
      --v62;
      *v63++ = v65;
    }
    while ( v62 );
  }
  return result;
}

//----- (000000000001C738) ----------------------------------------------------
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4)
{
  int v4; // w10
  char v5; // w14
  unsigned __int64 v6; // x15
  bool v7; // vf
  char v8; // w12
  _BYTE *v9; // x16
  unsigned int v10; // w11
  unsigned __int64 v11; // x12
  int v12; // w14
  char v13; // w13

  if ( a3 >= 1 )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( (unsigned int)a3 >= 3 )
        v10 = 3;
      else
        v10 = a3;
      v11 = *result << 16;
      if ( a3 == 1 || (v11 = (unsigned int)v11 | (result[1] << 8), a3 == 2) )
      {
        v12 = 0;
        if ( a3 == 1 )
        {
          v13 = 61;
LABEL_14:
          v5 = 61;
          goto LABEL_4;
        }
      }
      else
      {
        v12 = 1;
        v11 = (unsigned int)v11 | result[2];
      }
      v13 = aAbcdefghijklmn[((unsigned __int64)(unsigned int)v11 >> 6) & 0x3F];
      if ( !v12 )
        goto LABEL_14;
      v5 = aAbcdefghijklmn[v11 & 0x3F];
LABEL_4:
      v6 = (unsigned int)v11;
      result += v10;
      v7 = __OFSUB__(a3, v10);
      a3 -= v10;
      v8 = aAbcdefghijklmn[(v11 >> 12) & 0x3F];
      v9 = (_BYTE *)(a2 + v4);
      v4 += 4;
      LOBYTE(v6) = aAbcdefghijklmn[v6 >> 18];
      v9[2] = v13;
      v9[1] = v8;
      *v9 = v6;
      v9[3] = v5;
      if ( (a3 < 0) ^ v7 | (a3 == 0) )
      {
        *a4 = v4;
        return result;
      }
    }
  }
  *a4 = 0;
  return result;
}
// 1C7D4: conditional instruction was optimized away because w14.4==0
// 1C7EC: conditional instruction was optimized away because w2.4 is in (==0|>=3u)

//----- (000000000001C81C) ----------------------------------------------------
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  int v2; // w9
  int v3; // w8
  int v4; // w10
  int v5; // w9
  int v6; // w11
  int v7; // w10
  int v8; // w12
  int v9; // w11
  __int64 result; // x0
  int v11; // w9
  unsigned int v12; // w13
  unsigned int v13; // w8
  __int16 v14; // w10

  v2 = *a1;
  v3 = v2 - 65;
  if ( (unsigned int)(v2 - 65) > 0x19 )
  {
    if ( (unsigned int)(v2 - 97) > 0x19 )
    {
      if ( (unsigned int)(v2 - 48) > 9 )
      {
        switch ( v2 )
        {
          case '+':
            v3 = 62;
            break;
          case '=':
            v3 = -1;
            break;
          case '/':
            v3 = 63;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v3 = v2 + 4;
      }
    }
    else
    {
      v3 = v2 - 71;
    }
  }
  v4 = a1[1];
  v5 = v4 - 65;
  if ( (unsigned int)(v4 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v4 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v4 - 48) >= 0xA )
      {
        switch ( v4 )
        {
          case '+':
            v5 = 62;
            break;
          case '/':
            v5 = 63;
            break;
          case '=':
            v5 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v5 = v4 + 4;
      }
    }
    else
    {
      v5 = v4 - 71;
    }
  }
  v6 = a1[2];
  v7 = v6 - 65;
  if ( (unsigned int)(v6 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v6 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v6 - 48) >= 0xA )
      {
        switch ( v6 )
        {
          case '+':
            v7 = 62;
            break;
          case '/':
            v7 = 63;
            break;
          case '=':
            v7 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v7 = v6 + 4;
      }
    }
    else
    {
      v7 = v6 - 71;
    }
  }
  v8 = a1[3];
  v9 = v8 - 65;
  if ( (unsigned int)(v8 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v8 - 97) < 0x1A )
    {
      v9 = v8 - 71;
      goto LABEL_21;
    }
    if ( (unsigned int)(v8 - 48) < 0xA )
    {
      v9 = v8 + 4;
      goto LABEL_21;
    }
    switch ( v8 )
    {
      case '+':
        v9 = 62;
        goto LABEL_21;
      case '/':
        v9 = 63;
        goto LABEL_21;
      case '=':
        v9 = -1;
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  result = 0;
  if ( v3 != -1 && v5 != -1 )
  {
    if ( v7 == -1 && v9 != -1 )
      return 0;
    v11 = v5 << 12;
    v12 = (v11 | (unsigned int)(v3 << 18)) >> 16;
    if ( v7 == -1 )
      v13 = 1;
    else
      v13 = 2;
    if ( v9 == -1 )
      result = v13;
    else
      result = 3;
    *a2 = v12;
    if ( v9 != -1 || v7 != -1 )
    {
      v14 = (_WORD)v7 << 6;
      a2[1] = (unsigned __int16)(v14 & 0xF00 | v11) >> 8;
      if ( v9 == -1 )
      {
        return v13;
      }
      else
      {
        result = 3;
        a2[2] = v9 & 0x3F | v14;
      }
    }
  }
  return result;
}

//----- (000000000001CA48) ----------------------------------------------------
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  size_t result; // x0
  int v7; // w22
  __int64 v8; // x24
  unsigned int v9; // w23

  result = DHstrlen(a1);
  if ( (int)result < 1 )
  {
    v9 = 0;
LABEL_7:
    *a3 = v9;
  }
  else
  {
    v7 = result;
    v8 = 0;
    v9 = 0;
    while ( 1 )
    {
      result = base64_decode_atom((unsigned __int8 *)&a1[v8], (_BYTE *)(a2 + v9));
      if ( !(_DWORD)result )
        break;
      v8 += 4;
      v9 += result;
      if ( v7 <= (int)v8 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (000000000001CAC0) ----------------------------------------------------
void sub_1CAC0()
{
  JUMPOUT(0);
}
// 1CAD0: control flows out of bounds to 0

//----- (000000000001CB00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  return DHGetClientID_BySetVal(a1, a2, a3, a4);
}

//----- (000000000001CB10) ----------------------------------------------------
// attributes: thunk
void __fastcall DHFreeClientID(void *a1)
{
  DHFreeClientID(a1);
}

//----- (000000000001CB20) ----------------------------------------------------
// attributes: thunk
__int64 DRM_SetClientID()
{
  return DRM_SetClientID();
}

//----- (000000000001CB30) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmalloc(int a1)
{
  return DHmalloc(a1);
}

//----- (000000000001CB40) ----------------------------------------------------
// attributes: thunk
__int64 DA_DRA_SetClientID()
{
  return DA_DRA_SetClientID();
}
// 17F7C: using guessed type __int64 DA_DRA_SetClientID(void);

//----- (000000000001CB50) ----------------------------------------------------
// attributes: thunk
void printLogD()
{
  printLogD();
}

//----- (000000000001CB60) ----------------------------------------------------
// attributes: thunk
__int64 DRM_Init()
{
  return DRM_Init();
}

//----- (000000000001CB70) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return DHmemset(a1, a2, a3);
}

//----- (000000000001CB80) ----------------------------------------------------
// attributes: thunk
void DRM_Destroy()
{
  DRM_Destroy();
}

//----- (000000000001CB90) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfree(void *a1)
{
  DHfree(a1);
}

//----- (000000000001CBA0) ----------------------------------------------------
// attributes: thunk
void DHmemcount()
{
  DHmemcount();
}

//----- (000000000001CBB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  return DRM_Open_Pfd(a1, a2, a3);
}

//----- (000000000001CBC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3)
{
  return DA_DRA_MetaFilePfdOpen(a1, a2, a3);
}

//----- (000000000001CBD0) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2)
{
  DA_DRA_MetaFileClose(a1, a2);
}

//----- (000000000001CBE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_DCFParser(__int64 a1, __int64 a2, int *a3)
{
  return DA_DRA_DCFParser(a1, a2, a3);
}

//----- (000000000001CBF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  return DHstrnicmp(a1, a2, a3);
}

//----- (000000000001CC00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  return ClusterAuthentication(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001CC10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsMetaTell(__int64 a1)
{
  return DHfsMetaTell(a1);
}

//----- (000000000001CC20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  return DHmemcpy_s(a1, a2, a3, a4);
}

//----- (000000000001CC30) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  DA_DRA_DCFDestroy(a1);
}

//----- (000000000001CC50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  return DHstrncpy_s(a1, a2, a3, a4);
}

//----- (000000000001CC70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall StrErrorReturn(int a1)
{
  return StrErrorReturn(a1);
}

//----- (000000000001CC80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Path(const char *a1, int a2, __int16 a3)
{
  return DRM_Open_Path(a1, a2, a3);
}

//----- (000000000001CC90) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DHstrlen(const char *a1)
{
  return DHstrlen(a1);
}

//----- (000000000001CCA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3)
{
  return DA_DRA_MetaFileOpen(a1, a2, a3);
}

//----- (000000000001CCB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Close(unsigned __int16 a1)
{
  return DRM_Close(a1);
}

//----- (000000000001CCC0) ----------------------------------------------------
// attributes: thunk
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  ClientIDDestroy(a1);
}

//----- (000000000001CCD0) ----------------------------------------------------
// attributes: thunk
void __fastcall DomainListDestroy(__int64 a1)
{
  DomainListDestroy(a1);
}

//----- (000000000001CCE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3)
{
  return DRM_Read(a1, a2, a3);
}

//----- (000000000001CCF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3)
{
  return DHfsMetaRead(a1, ptr, a3);
}

//----- (000000000001CD00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  return DHfsMetaSeek(a1, a2, a3);
}

//----- (000000000001CD10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  return DRM_Seek(a1, a2, a3);
}

//----- (000000000001CD20) ----------------------------------------------------
// attributes: thunk
__int64 AES_set_decrypt_key()
{
  return AES_set_decrypt_key();
}
// 1C27C: using guessed type __int64 AES_set_decrypt_key(void);

//----- (000000000001CD30) ----------------------------------------------------
// attributes: thunk
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  AES_cbc_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001CD40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  return checkDomain(a1, a2, a3);
}

//----- (000000000001CD50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3)
{
  return GetClientID(a1, a2, a3);
}

//----- (000000000001CD60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  return compute_eTarget(a1, a2, a3, a4);
}

//----- (000000000001CD70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eServiceCode(unsigned __int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5)
{
  return compute_eServiceCode(a1, a2, a3, a4, a5);
}

//----- (000000000001CD80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        const char *a6,
        __int16 a7)
{
  return compute_eAuthCode(a1, a2, a3, a4, a5, a6, a7);
}

//----- (000000000001CD90) ----------------------------------------------------
// attributes: thunk
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  return DHstristr(a1, a2);
}

//----- (000000000001CDA0) ----------------------------------------------------
// attributes: thunk
__int64 DHatoi()
{
  return DHatoi();
}
// 18F98: using guessed type __int64 DHatoi(void);

//----- (000000000001CDB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5)
{
  return get_SSEBaseStream(a1, a2, a3, a4, a5);
}

//----- (000000000001CDC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetContentInfo(unsigned __int16 a1, int **a2)
{
  return DRM_GetContentInfo(a1, a2);
}

//----- (000000000001CDD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  return DA_DRA_GetDCFHeader(a1, a2);
}

//----- (000000000001CDE0) ----------------------------------------------------
// attributes: thunk
__int64 DHAuthTime()
{
  return DHAuthTime();
}

//----- (000000000001CDF0) ----------------------------------------------------
// attributes: thunk
__int64 DHcurrentTime()
{
  return DHcurrentTime();
}

//----- (000000000001CE00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3)
{
  return DRM_GetUnsupportedValue(a1, a2, a3);
}

//----- (000000000001CE10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  return DRM_GetDCFMetaDataEncodingType(a1);
}

//----- (000000000001CE40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, const char *a3, __int64 a4, __int16 a5)
{
  return compute_SSKey(a1, a2, a3, a4, a5);
}

//----- (000000000001CE50) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  return DHstrlwr(result);
}

//----- (000000000001CE60) ----------------------------------------------------
// attributes: thunk
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return DHstrchr(a1, a2);
}

//----- (000000000001CE70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  return DHmktime(a1, a2);
}

//----- (000000000001CE80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  return DHstrncat_s(s, a2, a3, a4);
}

//----- (000000000001CE90) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  return inverse(result, a2, a3);
}

//----- (000000000001CEA0) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  DA_DRM_HASH_SHA1Digest(a1, a2, a3);
}

//----- (000000000001CEB0) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  return DHultoa(a1, a2, a3);
}

//----- (000000000001CEC0) ----------------------------------------------------
// attributes: thunk
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  return PP_HexEncode_A(result, a2, a3, a4);
}

//----- (000000000001CED0) ----------------------------------------------------
// attributes: thunk
__int64 DHstrstr()
{
  return DHstrstr();
}
// 19150: using guessed type __int64 DHstrstr(void);

//----- (000000000001CEE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetID3HeaderDataSize(__int64 a1, int *a2)
{
  return DRM_GetID3HeaderDataSize(a1, a2);
}

//----- (000000000001CEF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3)
{
  return DHmemcmp(a1, a2, a3);
}

//----- (000000000001CF00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetBufferSizeForAlbumArt(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  return DRM_GetBufferSizeForAlbumArt(a1, a2, a3);
}

//----- (000000000001CF10) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemchr(const void *a1, int a2, int a3)
{
  return DHmemchr(a1, a2, a3);
}

//----- (000000000001CF20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return DHstrncmp(a1, a2, a3);
}

//----- (000000000001CF30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetMetaTextValueFromID3(__int64 a1, char *a2, __int64 *a3, int *a4)
{
  return DRM_GetMetaTextValueFromID3(a1, a2, a3, a4);
}

//----- (000000000001CF40) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall DHstrupr(_BYTE *result)
{
  return DHstrupr(result);
}

//----- (000000000001CFB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  return DHstrcpy_s(a1, a2, s);
}

//----- (000000000001CFC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  return DHGetDeviceID_ConstVal(a1);
}

//----- (000000000001CFD0) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return DHmemcpy(a1, a2, a3);
}

//----- (000000000001CFE0) ----------------------------------------------------
// attributes: thunk
__int64 DHstrcat()
{
  return DHstrcat();
}
// 18E78: using guessed type __int64 DHstrcat(void);

//----- (000000000001CFF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9)
{
  return DHsprintf_s(a1, a2, format);
}

//----- (000000000001D000) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  return DHfsOpen(filename, a2);
}

//----- (000000000001D010) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  return DHfsSeek(a1, a2, a3);
}

//----- (000000000001D020) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  return DHfsMetaOpen(a1, a2);
}

//----- (000000000001D030) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  return DHfsPfdOpen(a1, a2);
}

//----- (000000000001D040) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  return DHfsPfdMetaOpen(a1, a2);
}

//----- (000000000001D050) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  DHfsMetaClose(a1);
}

//----- (000000000001D060) ----------------------------------------------------
// attributes: thunk
__int64 DHfsClose()
{
  return DHfsClose();
}
// 184E8: using guessed type __int64 DHfsClose(void);

//----- (000000000001D070) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  return DHfs_VF_SetFileSize(result, a2);
}

//----- (000000000001D080) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  return DHfs_VF_SetBuffer(result, a2, a3, a4);
}

//----- (000000000001D090) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  return DHfs_VF_IsReachedToEndOfFile(result, a2);
}

//----- (000000000001D0A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  return DHfs_VF_ShouldUpdateBuffer(result, a2, a3);
}

//----- (000000000001D0B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  return DHSetClientID(a1, a2, a3);
}

//----- (000000000001D220) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetStateInfo(void *a1)
{
  return DHGetStateInfo(a1);
}

//----- (000000000001D240) ----------------------------------------------------
// attributes: thunk
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  return base64_decode(a1, a2, a3);
}

//----- (000000000001D270) ----------------------------------------------------
// attributes: thunk
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  return CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001D280) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  return CRYPTO_cbc128_decrypt(result, a2, a3, a4, a5, a6);
}

//----- (000000000001D290) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_encrypt_key(a1, a2, a3);
}

//----- (000000000001D2A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_decrypt_key(a1, a2, a3);
}

//----- (000000000001D2B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  return base64_decode_atom(a1, a2);
}

// nfuncs=337 queued=251 decompiled=251 lumina nreq=0 worse=0 better=0
// ALL OK, 251 function(s) have been successfully decompiled
