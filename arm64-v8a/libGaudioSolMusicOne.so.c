/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_2E9D0();
void sub_2E9E0();
__int64 sub_2E9E8();
__int64 (*__fastcall sub_2E9F0(__int64 (*result)(void)))(void);
__int64 __fastcall sub_2EA04(void *a1);
__int64 __fastcall sub_2EA20(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::queue<st_event *>::~queue(__int64);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getVersion(__int64 *a1);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1create(__int64 a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1destroy(__int64 *a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1setup(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1update(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_flush(__int64 a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_reset(__int64 a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_process___3S_3SI(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_process___3F_3FI(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getBooleanParameter(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getIntParameter(__int64 a1, __int64 a2, __int64 a3);
float __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getFloatParameter(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2Z(__int64 *a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2I(__int64 *a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2F(__int64 *a1, __int64 a2, __int64 a3, float a4);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getLatency(__int64 a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1getCaps(__int64 *a1, __int64 a2);
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setProfile(__int64 a1, __int64 a2, __int64 a3);
void __fastcall std::queue<st_event *>::~queue(__int64 a1);
__int64 sub_311DC();
__int64 __fastcall GSMO_GET_VERSION(_QWORD *a1);
__int64 __fastcall GSMO_CREATE(_QWORD *a1);
__int64 __fastcall GSMO_DESTROY(void **a1);
__int64 __fastcall GSMO_SETUP(unsigned int *a1, _DWORD *a2, __int64 a3);
__int64 __fastcall checkValidConfig(__int64 a1, _DWORD *a2);
__int64 __fastcall checkValidParams(__int64 a1, _DWORD *a2, __int64 a3);
__int64 __fastcall GSMO_RESET(__int64 a1);
long double __fastcall copy_params(__int64 a1, __int64 a2);
__int64 __fastcall process(unsigned int *a1, void *a2, char *a3);
__int64 __fastcall update(__int64 a1, double a2);
__int64 __fastcall GSMO_FLUSH(__int64 a1);
__int64 __fastcall GSMO_UPDATE(__int64 a1, __int64 a2);
__int64 __fastcall GSMO_PROCESS(unsigned int *a1, __int64 a2, int16x4_t *s, unsigned int a4, unsigned int *a5);
__int64 __fastcall GSMO_SET_PARAMETER(_BYTE *a1, char *s1, _DWORD *a3);
__int64 __fastcall GSMO_GET_PARAMETER(__int64 a1, char *s1, float *a3);
__int64 __fastcall GSMO_GET_CAPS(__int64 a1, _DWORD *a2);
__int64 __fastcall GSMO_GET_LATENCY(__int64 a1, _DWORD *a2);
__int64 __fastcall GSMO_SET_PROFILE(__int64 a1, char *s);
__int64 __fastcall lm1_wrapper_decode(__int64 a1, unsigned int a2, __int64 a3);
__int64 AES_init_ctx(void); // weak
__int64 __fastcall sub_33CF4(_BYTE *a1, _BYTE *a2);
long double __fastcall AES_init_ctx_iv(__int64 a1, _BYTE *a2, long double *a3);
long double __fastcall AES_ctx_set_iv(__int64 a1, long double *a2);
__int64 __fastcall AES_ECB_encrypt(_BYTE *a1, unsigned __int8 *a2);
__int64 __fastcall sub_33E50(unsigned __int8 *a1, _BYTE *a2);
__int64 __fastcall AES_ECB_decrypt(_BYTE *a1, unsigned __int8 *a2);
__int64 __fastcall sub_34230(unsigned __int8 *a1, _BYTE *a2);
long double __fastcall AES_CBC_encrypt_buffer(_BYTE *a1, _BYTE *a2, unsigned int a3);
__int64 __fastcall AES_CBC_decrypt_buffer(__int64 result, __int64 a2, unsigned int a3);
__int64 __fastcall AES_CTR_xcrypt_buffer(__int64 result, _BYTE *a2, unsigned int a3);
__int64 __fastcall sub_34DB4(__int64 result, _BYTE *a2, __int64 a3);
char *__fastcall base64_encode(unsigned __int8 *a1, size_t a2, _QWORD *a3);
_BYTE *__fastcall base64_decode(unsigned __int8 *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall static_resampler_get_internal_sample_rate(int a1, int *a2);
long double __fastcall resampler_create(_QWORD *a1);
__int64 __fastcall resampler_destroy(__int64 *a1);
void *__fastcall sub_354E0(__int64 a1);
void __fastcall resampler_setup(unsigned int *a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5);
__int64 __fastcall resampler_run_external_to_internal(unsigned int *a1, void *src, void *dest);
__int64 __fastcall resampler_run_internal_to_external(__int64 a1, const void *a2, char *dest);
__int64 __fastcall resampler_get_external_samples(__int64 a1, _DWORD *a2);
__int64 __fastcall resampler_get_internal_samples(__int64 a1, _DWORD *a2);
__int64 __fastcall resampler_get_internal_sample_rate(__int64 a1, _DWORD *a2);
__int64 __fastcall resampler_get_latency(__int64 a1, int *a2);
long double __fastcall dynamic_queue_create(_QWORD *a1);
__int64 __fastcall dynamic_queue_destroy(__int64 *a1);
__int64 __fastcall sub_3642C(_QWORD *a1);
__int64 __fastcall dynamic_queue_setup(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7, size_t n);
__int64 __fastcall sub_36618(__int64 a1);
__int64 __fastcall dynamic_queue_process(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall dynamic_queue_process_planar(unsigned int *a1, __int64 a2, __int64 a3, signed int a4);
__int64 __fastcall dynamic_queue_process_s16(unsigned int *a1, __int64 a2, int16x4_t *a3, unsigned int a4);
__int64 __fastcall dynamic_queue_process_s16_planar(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall dynamic_queue_flush(__int64 a1);
__int64 __fastcall dynamic_queue_reset(__int64 a1);
__int64 __fastcall dynamic_queue_get_latency(__int64 a1, _DWORD *a2);
long double __fastcall channel_layout_converter_create(_QWORD *a1);
__int64 __fastcall channel_layout_converter_destroy(void **a1);
__int64 __fastcall channel_layout_converter_setup(unsigned int *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
__int64 __fastcall channel_layout_converter_process(unsigned int *a1, unsigned __int64 a2, unsigned __int64 a3, double a4);
__int64 __fastcall channel_layout_converter_flush(__int64 a1);
__int64 __fastcall channel_layout_converter_reset(__int64 a1);
long double __fastcall iir_create(_QWORD *a1);
__int64 __fastcall iir_destroy(__int64 *a1);
__int64 __fastcall iir_flush(__int64 a1);
__int64 __fastcall iir_reset(__int64 a1);
__int64 __fastcall iir_setup(__int64 a1, size_t n, int a3, int a4, float *a5, float *a6);
__int64 __fastcall iir_update(__int64 a1, float *a2, float *a3, double a4);
__int64 __fastcall iir_process(unsigned int *a1, __int64 a2, __int64 a3);
__int64 __fastcall iir_process_inplace(unsigned int *a1, __int64 a2);
long double __fastcall sln_create(_QWORD *a1);
__int64 __fastcall sln_destroy(__int64 *a1);
__int64 __fastcall sln_flush(__int64 a1);
__int64 __fastcall sub_382B8(unsigned int *a1);
__int64 __fastcall sln_reset(__int64 a1);
__int64 __fastcall sln_setup(__int64 a1, int a2, int a3, unsigned int a4, unsigned __int64 a5);
__int64 __fastcall sln_sol_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sln_process_inplace(int *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sln_update(__int64 a1, float a2);
__int64 __fastcall sln_lra_control(__int64 a1, float a2);
__int64 __fastcall sln_process(__int64 a1, __int64 a2, __int64 a3, double a4, double a5);
void __fastcall sln_get_integrateloudness(__int64 a1);
long double __fastcall eleq_create(_QWORD *a1);
__int64 __fastcall eleq_destroy(__int64 *a1);
void __fastcall sub_38B98(__int64 a1);
__int64 __fastcall eleq_flush(__int64 a1);
__int64 __fastcall eleq_reset(__int64 a1);
__int64 __fastcall eleq_setup(unsigned int *a1, unsigned int a2, unsigned int a3, size_t n);
__int64 __fastcall eleq_update(__int64 a1, char a2, double a3, float a4, float a5, float a6, float a7);
__int64 __fastcall eleq_process(int *a1, __int64 a2, __int64 a3);
__int64 __fastcall eleq_bypass(unsigned int *a1, const void *a2, void *dest);
long double __fastcall graphic_equalizer_create(_QWORD *a1);
__int64 __fastcall graphic_equalizer_destroy(__int64 *a1);
void __fastcall sub_39358(__int64 a1);
__int64 __fastcall graphic_equalizer_flush(__int64 a1);
long double __fastcall sub_3946C(__int64 a1);
__int64 __fastcall graphic_equalizer_reset(__int64 a1);
__int64 __fastcall graphic_equalizer_setup(__int64 a1, int a2, int a3, int a4, size_t n);
__int64 __fastcall graphic_equalizer_update(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall graphic_equalizer_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall graphic_equalizer_process_inplace(__int64 a1, __int64 a2);
__int64 __fastcall gain_create(_QWORD *a1);
__int64 __fastcall gain_destroy(void **a1);
__int64 __fastcall gain_flush(__int64 a1);
__int64 __fastcall gain_reset(__int64 a1);
__int64 __fastcall gain_setup(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall gain_update(__int64 a1, float a2);
__int64 __fastcall gain_process(__int64 a1, float32x4_t *a2, float32x4_t *a3, double a4, double a5, double a6);
__int64 __fastcall gain_process_inplace(__int64 a1, unsigned __int64 a2, double a3, long double a4, float32x4_t a5);
long double __fastcall spatial_upmix_create(_QWORD *a1);
__int64 __fastcall spatial_upmix_destroy(__int64 *a1);
void __fastcall sub_3A180(__int64 a1);
__int64 __fastcall spatial_upmix_flush(__int64 a1);
__int64 __fastcall sub_3A248(__int64 a1);
__int64 __fastcall spatial_upmix_reset(__int64 a1);
__int64 __fastcall spatial_upmix_setup(__int64 a1, int a2, int a3, int a4, size_t n, float a6);
__int64 __fastcall spatial_upmix_update(__int64 a1, unsigned int a2, float a3);
float __fastcall spatial_upmix_process(__int64 a1, float *a2, unsigned __int64 a3);
__int64 __fastcall spatial_upmix_set_tuning_params(__int64 a1, float a2, float a3);
__int64 __fastcall spatial_upmix_bypass(__int64 a1, _DWORD *a2, __int64 a3);
__int64 __fastcall spatial_upmix_offSetting(__int64 a1);
__int64 __fastcall spatial_upmix_delay_sample_count(__int64 a1, _DWORD *a2);
long double __fastcall drc_create(_QWORD *a1);
__int64 __fastcall drc_destroy(__int64 *a1);
__int64 __fastcall drc_flush(__int64 a1);
__int64 __fastcall drc_reset(__int64 a1);
__int64 __fastcall drc_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4);
__int64 __fastcall drc_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9);
__int64 __fastcall drc_process(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_3B568(unsigned int *a1, __int64 a2);
__int64 __fastcall drc_bypass(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall drc_delay_sample_count(__int64 a1, _DWORD *a2);
long double __fastcall boost_gain_create(_QWORD *a1);
__int64 __fastcall boost_gain_destroy(void **a1);
__int64 __fastcall boost_gain_flush(__int64 a1);
__int64 __fastcall boost_gain_reset(__int64 a1);
__int64 __fastcall boost_gain_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4);
__int64 __fastcall boost_gain_update(__int64 a1, char a2, float a3, float a4, float a5, float a6);
__int64 __fastcall boost_gain_process(int *a1, float32x4_t *src, float32x4_t *dest);
long double __fastcall compressor_create(_QWORD *a1);
__int64 __fastcall compressor_destroy(__int64 *a1);
__int64 __fastcall compressor_flush(__int64 a1);
void *__fastcall sub_3C2A0(unsigned int *a1);
__int64 __fastcall compressor_reset(__int64 a1);
__int64 __fastcall compressor_setup(unsigned int *a1, size_t n, unsigned int a3, unsigned int a4);
__int64 __fastcall compressor_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7);
__int64 __fastcall compressor_process(unsigned int *a1, float *a2, __int64 a3);
void __fastcall sub_3C8CC(unsigned int *a1, float *a2);
__int64 __fastcall compressor_process_inplace(unsigned int *a1, float *a2);
long double __fastcall limiter_create(_QWORD *a1);
__int64 __fastcall limiter_destroy(__int64 *a1);
__int64 __fastcall limiter_reset(__int64 a1);
__int64 __fastcall limiter_flush(__int64 a1);
void *__fastcall sub_3CD08(int *a1);
__int64 __fastcall limiter_setup(__int64 a1, size_t n, int a3, int a4, float a5);
__int64 __fastcall limiter_update(__int64 a1, float a2);
__int64 __fastcall limiter_process(float *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall limiter_process_inplace(unsigned int *a1, __int64 a2);
__int64 __fastcall limiter_bypass(__int64 a1, const void *a2, void *a3);
__int64 __fastcall limiter_delay_sample_count(__int64 a1, _DWORD *a2);
void __fastcall hann_window(float32x4_t *a1, unsigned int a2, double a3);
void __fastcall sine_window(int32x4_t *a1, unsigned int a2, double a3);
float __fastcall wrap_degree(float a1);
__int64 __fastcall wrap_degree_with_magnitude(float *a1, float *a2, unsigned int a3);
float __fastcall convert_frequency_to_absolute_value(float32x2_t *a1, unsigned __int64 *a2, unsigned int a3);
float __fastcall convert_frequency_to_absolute_value_real(float32x2_t *a1, unsigned __int64 *a2, unsigned int a3);
__int64 __fastcall greatest_common_divisor(int a1, int a2);
__int64 __fastcall circular_buffer_create(_QWORD *a1);
__int64 __fastcall circular_buffer_destroy(void **a1);
__int64 __fastcall circular_buffer_init(__int64 a1, unsigned int a2);
__int64 __fastcall circular_buffer_free(__int64 a1);
__int64 __fastcall circular_buffer_clear(__int64 a1);
__int64 __fastcall circular_buffer_enqueue(__int64 a1, float a2);
__int64 __fastcall circular_buffer_enqueueForce(unsigned int *a1, float a2);
__int64 __fastcall circular_buffer_dequeue(int *a1);
__int64 __fastcall circular_buffer_dequeue_count(int *a1, unsigned int a2);
__int64 __fastcall circular_buffer_dequeue_data(unsigned int *a1, _DWORD *a2);
__int64 __fastcall circular_buffer_dequeue_data_count(int *a1, char *dest, unsigned int a3);
__int64 __fastcall circular_buffer_readFront(unsigned int *a1, char *dest, unsigned int a3);
__int64 __fastcall circular_buffer_readBack(__int64 a1, _DWORD *a2, unsigned int a3);
__int64 __fastcall circular_buffer_readAll(unsigned int *a1, char *dest, _DWORD *a3);
__int64 __fastcall circular_buffer_size(__int64 a1);
long double __fastcall loudness_measure_create(_QWORD *a1);
__int64 __fastcall loudness_measure_destroy(void ***a1);
void __fastcall sub_3E1A8(void **a1);
__int64 __fastcall loudness_measure_flush(__int64 a1);
__int64 __fastcall sub_3E2D0(__int64 a1);
__int64 __fastcall loudness_measure_reset(__int64 a1);
__int64 __fastcall loudness_measure_setup(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned __int64 a5);
__int64 __fastcall loudness_measure_process(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_3EAE8(__int64 a1);
float __fastcall loudness_measure_getIntegratedLoudnessWithEnergyWeighting(__int64 a1);
void __fastcall loudness_measure_getIntegratedLoudness(__int64 a1);
float __fastcall loudness_measure_getInstantLoudness(__int64 a1);
void __fastcall loudness_measure_getLRA(__int64 a1);
__int64 __fastcall loudness_measure_getFramewiseGainArray(__int64 a1, float *a2, float a3);
__int64 __fastcall sub_3F9E8(float *a1, float *a2);
__int64 __fastcall loudness_measure_get_frameLength(__int64 a1);
__int64 __fastcall peak_setup(__int64 a1, unsigned int a2, unsigned int a3, int a4, int a5);
__int64 __fastcall peak_update(__int64 a1, unsigned int a2, int a3, float a4, float a5, float a6);
long double __fastcall reverb_create(_QWORD *a1);
__int64 __fastcall reverb_destroy(__int64 *a1);
void __fastcall sub_3FE98(_QWORD *a1);
__int64 __fastcall reverb_flush(__int64 a1);
__int64 __fastcall sub_3FFF8(__int64 a1);
__int64 __fastcall reverb_reset(__int64 a1);
__int64 __fastcall reverb_setup(__int64 a1, int a2, __int64 a3, int a4, int a5);
__int64 __fastcall reverb_update(__int64 a1, __int64 a2, float a3);
__int64 __fastcall reverb_process(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall reverb_bypass(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall reverb_bypass_inplace(__int64 a1, unsigned __int64 a2);
long double __fastcall allpass_create(_QWORD *a1);
__int64 __fastcall allpass_destroy(__int64 *a1);
__int64 __fastcall allpass_flush(__int64 a1);
__int64 __fastcall allpass_reset(__int64 a1);
__int64 __fastcall allpass_setup(__int64 a1, int a2, int a3, size_t n, float a5);
__int64 __fastcall allpass_update(__int64 a1, float a2);
__int64 __fastcall allpass_process(unsigned int *a1, float *a2, __int64 a3);
__int64 __fastcall allpass_process_inplace(unsigned int *a1, __int64 a2);
long double __fastcall comb_create(_QWORD *a1);
__int64 __fastcall comb_destroy(__int64 *a1);
__int64 __fastcall comb_flush(__int64 a1);
__int64 __fastcall comb_reset(__int64 a1);
__int64 __fastcall comb_setup(__int64 a1, int a2, int a3, size_t n, float a5);
__int64 __fastcall comb_update(__int64 a1, float a2);
__int64 __fastcall comb_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall comb_process_acc(__int64 a1, __int64 a2, __int64 a3);
long double __fastcall spatializer_create(_QWORD *a1);
__int64 __fastcall spatializer_destroy(__int64 *a1);
void __fastcall sub_41D80(_QWORD *a1);
__int64 __fastcall spatializer_flush(__int64 a1);
void *__fastcall sub_42098(__int64 a1);
__int64 __fastcall spatializer_reset(__int64 a1);
__int64 __fastcall spatializer_setup(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall spatializer_update(__int64 a1, unsigned int a2, unsigned int a3);
__int64 __fastcall spatializer_process(__int64 a1, const float *a2, __int64 a3);
__int64 __fastcall spatializer_bypass(__int64 a1, _DWORD *a2, __int64 a3);
__int64 __fastcall spatializer_offSetting(__int64 a1);
__int64 __fastcall spatializer_delay_sample_count(__int64 a1, _DWORD *a2);
float __fastcall sub_43BF4(__int64 a1, const void *a2, unsigned int a3, float32x2_t *a4);
long double __fastcall fft_create(_QWORD *a1);
__int64 __fastcall fft_destroy(__int64 *a1);
unsigned __int64 __fastcall fft_setup(__int64 a1, unsigned int a2);
void *__fastcall fft_forward(__int64 a1, const void *a2, void *a3);
void *__fastcall fft_forward_inplace(__int64 a1, void *a2);
int8x16_t __fastcall fft_forward_aligned(__int64 a1, float32x4_t *a2, float32x4_t *a3, long double a4, long double a5, long double a6, long double a7, long double a8);
float __fastcall fft_backward(__int64 a1, const void *a2, unsigned __int64 a3);
float __fastcall fft_backward_inplace(__int64 a1, float32x4_t *a2);
void __fastcall fft_backward_aligned(__int64 a1, float32x4_t *a2, float32x4_t *a3, long double a4, long double a5, long double a6, long double a7, long double a8);
void *__fastcall fft_forward_ordered(__int64 a1, const void *a2, void *a3);
void *__fastcall fft_forward_ordered_inplace(__int64 a1, void *a2);
int8x16_t __fastcall fft_forward_ordered_aligned(__int64 a1, float32x4_t *a2, float32x4_t *a3, long double a4, long double a5, long double a6, long double a7, long double a8);
float __fastcall fft_backward_ordered(__int64 a1, const void *a2, unsigned __int64 a3);
float __fastcall fft_backward_ordered_inplace(__int64 a1, float32x4_t *a2);
void __fastcall fft_backward_ordered_aligned(__int64 a1, float32x4_t *a2, float32x4_t *a3, long double a4, long double a5, long double a6, long double a7, long double a8);
void *__fastcall fft_convolve(__int64 a1, const void *a2, const void *a3, void *a4);
float __fastcall fft_convolve_aligned(__int64 a1, float *a2, float *a3, void *s);
void *__fastcall fft_convolve_acc(__int64 a1, const void *a2, const void *a3, void *a4);
float __fastcall fft_convolve_acc_aligned(__int64 a1, float *a2, float *a3, float *a4, double a5);
void *__fastcall fft_forward_reorder(__int64 a1, const void *a2, void *a3);
int8x16_t __fastcall fft_forward_reorder_aligned(__int64 a1, int32x4_t *a2, int8x16_t *a3, int8x16_t a4);
void *__fastcall fft_backward_reorder(__int64 a1, const void *a2, void *a3);
int8x16_t __fastcall fft_backward_reorder_aligned(__int64 a1, int32x4_t *a2, int8x16_t *a3, int8x16_t a4);
__int64 __fastcall fft_get_size(__int64 a1);
void *__fastcall fft_shift(char *a1, char *dest, unsigned int a3);
void *__fastcall fft_shift_inplace(void **a1, char *a2, unsigned int a3);
__int64 validate_pffft_simd();
unsigned __int64 __fastcall pffft_aligned_malloc(__int64 a1);
void __fastcall pffft_aligned_free(__int64 a1);
__int64 pffft_simd_size();
void __fastcall cffti1_ps(int a1, __int64 a2, int *a3);
float32x4_t *__fastcall cfftf1_ps(int a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6, int a7, double a8, double a9, double a10, double a11, long double a12);
__int64 __fastcall sub_44F9C(__int64 result, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, float a9, double a10, double a11, double a12, double a13);
__int64 __fastcall sub_452B0(__int64 result, int a2, float32x4_t *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, double a8);
__int64 __fastcall sub_45558(__int64 result, int a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, float32x4_t a6, double a7, double a8, double a9, float32x4_t a10);
__int64 __fastcall sub_456CC(__int64 result, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, float a7, double a8);
int32x4_t *__fastcall pffft_new_setup(int a1, unsigned __int32 a2);
void __fastcall pffft_destroy_setup(_QWORD *ptr);
int8x16_t __fastcall pffft_zreorder(int *a1, int32x4_t *a2, int8x16_t *a3, int a4, int8x16_t result);
float32x4_t __fastcall pffft_cplx_finalize(int a1, int32x4_t *a2, float32x4_t *a3, float32x4_t *a4);
__int64 __fastcall pffft_cplx_preprocess(__int64 result, float32x4_t *a2, float *a3, float32x4_t *a4);
int8x16_t __fastcall pffft_transform_internal(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, int a6, long double a7, long double a8, long double a9, long double a10, long double a11);
float32x4_t *__fastcall sub_46B74(int a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, __int64 a6);
int32x4_t __fastcall sub_473E4(int a1, __int64 a2, float32x4_t *a3, float32x4_t *a4);
float __fastcall sub_47698(int a1, float32x4_t *a2, float *a3, float32x4_t *a4);
float32x4_t *__fastcall sub_47A0C(int a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6);
float __fastcall pffft_zconvolve_accumulate(__int64 a1, float *a2, float *a3, float *a4, double a5);
int8x16_t __fastcall pffft_transform(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, long double a6, long double a7, long double a8, long double a9, long double a10);
int8x16_t __fastcall pffft_transform_ordered(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, long double a6, long double a7, long double a8, long double a9, long double a10);
float32x4_t *__fastcall sub_48380(float32x4_t *result, int a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6, __int64 a7);
float32x4_t __fastcall sub_48770(int a1, int a2, float32x4_t *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_4893C(__int64 result, int a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_48D14(__int64 result, int a2, __int64 a3, float32x4_t *a4, __int64 a5);
_QWORD *__fastcall dataTracker_init(_QWORD *result);
_QWORD *__fastcall dataTracker_initAll(_QWORD *result, unsigned int a2);
__int64 __fastcall dataTracker_start(__int64 result, __int64 a2);
__int64 __fastcall dataTracker_getLength(__int64 a1);
__int64 __fastcall dataTracker_consume(__int64 result, unsigned __int64 a2);
__int64 __fastcall dataTracker_consumeAll(__int64 result, unsigned int a2, unsigned __int64 a3);
_QWORD *__fastcall dataTracker_stop(_QWORD *result);
__int64 __fastcall convertErrorCode(unsigned int a1);
__int64 __fastcall readUInt32(__int64 a1);
__int64 __fastcall readUInt16(__int64 a1);
__int64 __fastcall readUInt8(__int64 a1);
float __fastcall readFloat(__int64 a1);
__int64 __fastcall readFlexibleAsUInt64(__int64 a1);
unsigned __int64 __fastcall readFlexibleAsUInt32(__int64 a1);
unsigned __int64 __fastcall readFlexibleAsUInt16(__int64 a1);
unsigned __int64 __fastcall readFlexibleAsUInt8(__int64 a1);
__int64 __fastcall skip(__int64 result, unsigned __int64 a2);
__int64 __fastcall lm1_decode(_QWORD *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall lm1_free(__int64 a1);
void __fastcall std::mutex::~mutex(pthread_mutex_t *this);
void __fastcall __noreturn sub_4A7CC(void *a1);
unsigned __int64 std::get_unexpected(void);
void __noreturn std::terminate(void); // idb
void __fastcall __noreturn sub_4A834(void (*a1)(void));
void __noreturn std::unexpected(void); // idb
unsigned __int64 std::get_terminate(void);
void __fastcall __noreturn sub_4A880(void (*a1)(void));
unsigned __int64 std::get_new_handler(void);
void __noreturn sub_4A8C4();
void __noreturn sub_4AA14();
unsigned __int64 __fastcall std::set_unexpected(void (__noreturn *a1)());
unsigned __int64 __fastcall std::set_terminate(void (__noreturn *a1)());
unsigned __int64 __fastcall std::set_new_handler(void (*a1)(void));
void __fastcall sub_4AAC0(void *ptr);
void sub_4AAC8();
_QWORD *_cxa_get_globals();
_QWORD *_cxa_get_globals_fast();
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
const char *__fastcall std::exception::what(std::exception *this);
void __fastcall std::bad_exception::~bad_exception(std::bad_exception *this); // idb
const char *__fastcall std::bad_exception::what(std::bad_exception *this);
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this);
void __fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *this); // idb
const char *__fastcall std::bad_alloc::what(std::bad_alloc *this);
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *this);
void __fastcall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this); // idb
const char *__fastcall std::bad_array_new_length::what(std::bad_array_new_length *this);
void __noreturn sub_4AC40(const char *a1, ...);
void __fastcall sub_4AD48(std::type_info *a1);
__int64 sub_4AD50();
void sub_4AD58();
void sub_4AD60();
void __fastcall sub_4AD68(std::type_info *a1);
void __fastcall sub_4AD94(std::type_info *a1);
void __fastcall sub_4ADC0(std::type_info *a1);
void __fastcall sub_4ADEC(std::type_info *a1);
void __fastcall sub_4AE18(std::type_info *a1);
void __fastcall sub_4AE44(std::type_info *a1);
void __fastcall sub_4AE70(std::type_info *a1);
void __fastcall sub_4AE9C(std::type_info *a1);
void __fastcall sub_4AEC8(std::type_info *a1);
void __fastcall sub_4AEF4(std::type_info *a1);
bool __fastcall sub_4AF20(__int64 a1, __int64 a2);
__int64 sub_4AF38();
__int64 sub_4AF44();
bool __fastcall sub_4AF50(__int64 a1, __int64 a2);
__int64 __fastcall sub_4AF68(__int64 a1, _QWORD *lpsrc, __int64 *a3);
void *_dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
__int64 __fastcall sub_4B16C(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_4B1E0(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_4B260(__int64 result, __int64 a2, char *a3, __int64 a4);
_BYTE *__fastcall sub_4B42C(__int64 a1, const char **lpsrc);
__int64 __fastcall sub_4B4E4(__int64 a1, _QWORD *lpsrc, _QWORD **a3);
_DWORD *__fastcall sub_4B970(__int64 a1, _QWORD *lpsrc, _QWORD *a3);
__int64 __fastcall sub_4BB20(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5);
__int64 __fastcall sub_4BEC8(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5);
__int64 __fastcall sub_4C0B4(__int64 result, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_4C218(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6);
__int64 __fastcall sub_4C448(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6);
__int64 __fastcall sub_4C594(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6);
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *this);
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this); // idb
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this); // idb
const char *__fastcall std::bad_cast::what(std::bad_cast *this);
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *this);
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this); // idb
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this); // idb
const char *__fastcall std::bad_typeid::what(std::bad_typeid *this);
void __noreturn _cxa_pure_virtual(void);
void __noreturn _cxa_deleted_virtual(void);
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
void __fastcall sub_4CD90(_QWORD *a1);
__int64 __fastcall sub_4CE60(__int64 a1, char *s1, __int64 a3);
unsigned __int8 *__fastcall sub_4CEF0(unsigned __int8 **a1, size_t a2);
unsigned __int8 *__fastcall sub_4D97C(unsigned __int8 **a1, char a2);
_QWORD *__fastcall sub_4DA08(__int64 a1, char *s, __int64 *a3);
unsigned __int8 **__fastcall sub_4DAC4(__int64 a1, size_t a2);
_QWORD *__fastcall sub_4ECA0(__int64 a1, size_t a2);
char *__fastcall sub_4F358(_QWORD *a1);
_QWORD *__fastcall sub_4F5F4(_QWORD *result, __int64 *size);
_OWORD *__fastcall sub_4F6AC(__int64 a1, __int128 *a2);
char *__fastcall sub_4F750(_QWORD *a1, unsigned __int64 a2);
char *__fastcall sub_4F884(__int64 a1, __int64 *a2, __int64 *a3, __int128 *a4, __int64 *a5, int *a6, char *a7);
void __fastcall sub_4F96C(_QWORD *a1);
_QWORD *__fastcall sub_4FB50(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_4FC04(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_4FCB8(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_4FD6C(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_4FE20(__int64 a1, __int64 *a2);
__int64 __fastcall sub_4FED4(__int64 a1);
_QWORD *__fastcall sub_500AC(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_50160(__int64 a1, __int64 *a2, __int64 *a3);
_QWORD *__fastcall sub_5020C(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_502C0(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_50374(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_50428(__int64 a1, __int64 *a2);
__int64 __fastcall sub_504DC(__int64 a1, __int64 *a2);
__int64 sub_506AC();
__int64 sub_506B8();
__int64 sub_506C4();
void sub_506D0();
__int64 __fastcall sub_506D8(_QWORD *a1, void **a2);
void sub_507C0();
__int64 sub_507C8();
void __fastcall sub_507D8(void *a1);
__int64 __fastcall sub_507E0(__int64 a1, void **a2);
void __fastcall sub_5095C(void *a1);
__int64 __fastcall sub_50964(const char **a1);
_OWORD *__fastcall sub_50B10(__int64 a1, __int128 *a2);
_QWORD *__fastcall sub_50BB4(_QWORD *result, void **a2);
__int64 __fastcall sub_50C4C(__int64 a1);
void __fastcall sub_50C5C(void *a1);
__int64 __fastcall sub_50C64(__int64 a1, _QWORD *a2);
void __fastcall sub_50D90(void *a1);
unsigned __int8 **__fastcall sub_50D98(const char **a1, _BYTE *a2, _BYTE *a3);
char *__fastcall sub_50F00(_QWORD *a1, char a2);
_QWORD *__fastcall sub_514E0(__int64 a1, __int64 *a2, __int64 *a3);
_QWORD *__fastcall sub_5158C(__int64 a1, size_t size);
__int64 __fastcall sub_51900(__int64 a1);
unsigned __int8 **__fastcall sub_51A40(__int64 a1);
unsigned __int8 **__fastcall sub_51CFC(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_52238(_QWORD *result, __int64 *size);
bool __fastcall sub_523A0(__int64 a1);
bool __fastcall sub_52438(__int64 a1);
bool __fastcall sub_524D0(__int64 a1);
__int64 __fastcall sub_52568(__int64 result);
__int64 __fastcall sub_525CC(__int64 result);
__int64 __fastcall sub_5262C(__int64 result);
void __fastcall sub_5268C(void *a1);
char *__fastcall sub_52694(__int64 a1);
__int64 __fastcall sub_537A8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4);
_QWORD *__fastcall sub_53868(__int64 a1, __int64 *a2, __int64 *a3, _WORD *a4);
__int64 __fastcall sub_53928(__int64 a1, __int64 *a2, __int128 *a3, __int64 *a4, _WORD *a5);
__int64 __fastcall sub_539F4(__int64 a1, __int128 *a2, __int64 *a3, __int128 *a4, char a5, char a6, __int16 *a7);
__int64 __fastcall sub_53AE8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4);
__int64 __fastcall sub_53BA8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4);
_QWORD *__fastcall sub_53C68(__int64 a1, __int64 *a2, __int64 *a3, __int64 *a4, _WORD *a5);
char *__fastcall sub_54C24(const char **a1);
__int64 __fastcall sub_552C4(__int64 a1);
__int64 __fastcall sub_55520(__int64 a1, __int128 *a2);
_QWORD *__fastcall sub_5573C(__int64 a1, __int64 *a2, _WORD *a3);
_QWORD *__fastcall sub_55B54(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_55BF8(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_55C9C(__int64 a1, __int64 *a2);
_OWORD *__fastcall sub_55D54(__int64 a1, __int128 *a2);
__int64 __fastcall sub_55DF4(__int64 a1, __int64 *a2, __int128 *a3);
_QWORD *__fastcall sub_55F50(__int64 a1, __int64 *a2);
__int64 __fastcall sub_565E0(__int64 a1, __int64 *a2, __int128 *a3, __int64 *a4, _WORD *a5);
char *__fastcall sub_566AC(__int64 a1, __int64 a2);
void __fastcall sub_56988(void *a1);
_BYTE *__fastcall sub_56990(__int64 *a1, __int64 a2, int a3, char a4);
_QWORD *__fastcall sub_56B08(__int64 a1, __int128 *a2, __int64 *a3, _WORD *a4);
_BYTE *__fastcall sub_56BCC(__int64 a1, void **a2);
void __fastcall sub_56C7C(void *a1);
void *__fastcall sub_56C84(__int64 a1, void **a2);
void __fastcall sub_56D34(void *a1);
_BYTE *__fastcall sub_56D3C(__int64 a1, __int64 a2);
void __fastcall sub_56E48(void *a1);
_BYTE *__fastcall sub_56E50(__int64 a1, void **a2);
void __fastcall sub_56F14(void *a1);
char *__fastcall sub_56F1C(__int64 a1, __int64 a2);
void __fastcall sub_57454(void *a1);
__int64 __fastcall sub_5745C(__int64 a1, char **a2);
void __fastcall sub_57640(void *a1);
char *__fastcall sub_57648(_QWORD *a1, __int64 a2);
void __fastcall sub_5785C(void *a1);
_BYTE *__fastcall sub_57864(_QWORD *a1, __int64 a2);
void __fastcall sub_57B34(void *a1);
_BYTE *__fastcall sub_57B3C(__int64 a1, void **a2);
void __fastcall sub_57C60(void *a1);
char *__fastcall sub_57C68(__int64 a1, __int64 a2);
void __fastcall sub_57E98(void *a1);
char *__fastcall sub_57EA0(_QWORD *a1, char **a2);
void __fastcall sub_580C4(void *a1);
_QWORD *__fastcall sub_580CC(__int64 a1, __int64 a2, __int64 a3);
char *__fastcall sub_58270(__int64 a1, int a2);
_QWORD *__fastcall sub_58314(__int64 a1, __int64 *a2);
const char **__fastcall sub_58468(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_58B80(__int64 a1, __int64 *a2);
__int64 __fastcall sub_58C24(__int64 a1, __int64 *a2, __int128 *a3);
_QWORD *__fastcall sub_58CD0(_QWORD *result, char **a2);
void __fastcall sub_58FA8(void *a1);
_BYTE *__fastcall sub_58FB0(_BYTE *result, void **a2);
void __fastcall sub_5906C(void *a1);
void *__fastcall sub_59074(void *result, void **a2);
void __fastcall sub_59238(void *a1);
void *__fastcall sub_59240(void *result, void **a2);
void __fastcall sub_594C0(void *a1);
void *__fastcall sub_594C8(void *result, void **a2);
void __fastcall sub_598CC(void *a1);
char *__fastcall sub_598D4(__int64 a1, void **a2);
void __fastcall sub_599E4(void *a1);
__int64 *__fastcall sub_599EC(const char **a1);
void __fastcall sub_59ED0(_QWORD *a1);
char *__fastcall sub_59F4C(__int64 a1, char **a2);
void __fastcall sub_5A09C(void *a1);
__int64 __fastcall sub_5A0A4(_QWORD *a1, size_t size);
char *__fastcall sub_5A20C(char *result, _QWORD *a2);
void __fastcall sub_5A418(void *a1);
char *__fastcall sub_5A420(__int64 a1, void **a2);
__int64 __fastcall sub_5A4B0(__int64 a1, __int64 a2);
void __fastcall sub_5A518(void *a1);
__int64 __fastcall sub_5A520(__int64 a1, __int64 *a2);
__int64 __fastcall sub_5A5F0(__int64 a1, __int64 a2);
void __fastcall sub_5A668(void *a1);
char *__fastcall sub_5A670(__int64 a1, __int64 a2);
__int64 __fastcall sub_5A860(__int64 a1, __int64 a2);
void __fastcall sub_5A8C8(void *a1);
char *__fastcall sub_5A8D0(__int64 a1, void **a2);
__int64 __fastcall sub_5A968(__int64 a1);
void __fastcall sub_5A97C(void *a1);
_BYTE *__fastcall sub_5A984(_QWORD *a1, char **a2);
void __fastcall sub_5AAE4(void *a1);
_BYTE *__fastcall sub_5AAEC(_QWORD *a1, __int64 a2);
char *__fastcall sub_5AE60(__int64 a1, void **a2);
void __fastcall sub_5AF60(void *a1);
char *__fastcall sub_5AF68(_QWORD *a1, char **a2);
void __fastcall sub_5B180(void *a1);
_OWORD *__fastcall sub_5B188(__int64 a1, __int128 *a2);
char *__fastcall sub_5B22C(__int64 a1, void **a2);
void sub_5B31C();
void __fastcall sub_5B324(void *a1);
_BYTE *__fastcall sub_5B32C(__int64 a1, __int64 a2);
void __fastcall sub_5B754(void *a1);
char *__fastcall sub_5B75C(char ***a1);
__int64 __fastcall sub_5B890(__int64 a1, char **a2);
void __fastcall sub_5BA50(void *a1);
__int64 __fastcall sub_5BA58(__int64 a1, char **a2);
void __fastcall sub_5BCB4(void *a1);
__int64 __fastcall sub_5BCBC(_QWORD *a1, char **a2);
void __fastcall sub_5BF2C(void *a1);
_BYTE *__fastcall sub_5BF34(_QWORD *a1, void **a2);
void __fastcall sub_5C138(void *a1);
_BYTE *__fastcall sub_5C140(__int64 a1, __int64 a2);
void __fastcall sub_5C35C(void *a1);
_OWORD *__fastcall sub_5C364(__int64 a1, __int128 *a2);
char *__fastcall sub_5C408(_QWORD *a1, char **a2);
void __fastcall sub_5C704(void *a1);
_BYTE *__fastcall sub_5C70C(__int64 a1, __int64 a2);
void __fastcall sub_5C88C(void *a1);
_BYTE *__fastcall sub_5C894(_BYTE *result, void **a2);
void __fastcall sub_5C9A0(void *a1);
__int64 __fastcall sub_5C9A8(__int64 a1, void **a2);
void __fastcall sub_5CA80(void *a1);
unsigned __int8 **__fastcall sub_5CA88(unsigned __int8 **a1, size_t a2);
__int64 __fastcall sub_5CBDC(__int64 a1);
__int64 __fastcall sub_5CCD4(__int64 a1);
__int64 __fastcall sub_5CF24(__int64 a1, void **a2);
__int64 __fastcall sub_5D030(__int64 a1);
void __fastcall sub_5D044(void *a1);
__int64 __fastcall sub_5D04C(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_5D424(__int64 a1, _QWORD *a2);
void __fastcall sub_5D4B4(void *a1);
__int64 __fastcall sub_5D4BC(__int64 a1, void **a2);
void __fastcall sub_5D598(void *a1);
__int64 __fastcall sub_5D5A0(__int64 a1, void **a2);
void __fastcall sub_5D680(void *a1);
__int64 __fastcall sub_5D688(__int64 a1, void **a2);
__int64 __fastcall sub_5D750(__int64 a1);
void __fastcall sub_5D764(void *a1);
unsigned __int8 **__fastcall sub_5D76C(__int64 a1, unsigned __int8 **a2);
void __fastcall sub_5D8FC(__int64 a1, void **a2);
void __fastcall sub_5DB00(__int64 a1);
__int64 sub_5DB4C();
char *sub_5DB70();
void __fastcall sub_5DC1C(void *a1);
char *__fastcall sub_5DC24(__int64 *a1, void **a2);
char *__fastcall sub_5DE70(__int64 a1);
void __fastcall sub_5DEA0(void *a1);
char *__fastcall sub_5DEA8(__int64 a1, char **a2);
void __fastcall sub_5E00C(void *a1);
char *__fastcall sub_5E014(__int64 a1, __int64 a2);
void __fastcall sub_5E1F0(void *a1);
char *__fastcall sub_5E1F8(__int64 a1, __int64 *a2, char a3, int a4);
_BYTE *__fastcall sub_5E2BC(__int64 a1, char **a2);
void __fastcall sub_5E3C4(void *a1);
__int64 __fastcall sub_5E3CC(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_5E4D4(__int64 a1);
void __fastcall sub_5E4E8(void *a1);
__int64 __fastcall sub_5E4F0(__int64 a1, void **a2);
__int64 __fastcall sub_5E5FC(__int64 a1);
void __fastcall sub_5E610(void *a1);
unsigned __int8 *__fastcall sub_5E618(unsigned __int8 *result, unsigned __int8 *a2);
_QWORD *__fastcall sub_5E6C8(__int64 a1, char *s);
_QWORD *__fastcall sub_5E778(__int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_5E824(__int64 a1, void **a2);
void __fastcall sub_5E930(void *a1);
__int64 __fastcall sub_5E938(__int64 a1, __int64 a2);
__int64 __fastcall sub_5E9A4(__int64 a1, __int64 a2);
__int64 __fastcall sub_5EA10(__int64 a1, __int64 a2);
__int64 __fastcall sub_5EA7C(__int64 result, __int64 a2);
__int64 __fastcall sub_5EAC8(__int64 result, __int64 a2);
__int64 __fastcall sub_5EB14(__int64 result, __int64 a2);
void __fastcall sub_5EB60(void *a1);
_BYTE *__fastcall sub_5EB68(__int64 a1, __int64 a2);
void __fastcall sub_5ED2C(void *a1);
__int64 __fastcall sub_5ED34(__int64 a1, __int64 a2);
__int64 __fastcall sub_5EDE8(__int64 a1);
void __fastcall sub_5EDFC(void *a1);
_BYTE *__fastcall sub_5EE04(_BYTE *result, void **a2);
void __fastcall sub_5EF10(void *a1);
char *__fastcall sub_5EF18(__int64 a1, char **a2);
void __fastcall sub_5F0DC(void *a1);
__int64 sub_5F0E4();
__int64 sub_5F0F0();
__int64 __fastcall sub_5F0FC(__int64 a1, _QWORD *a2);
char *__fastcall sub_5F210(__int64 a1, __int64 a2);
void __fastcall sub_5F68C(void *a1);
char *__fastcall sub_5F694(_QWORD *a1, char **a2);
void __fastcall sub_5F810(void *a1);
char *__fastcall sub_5F818(const char **a1);
__int64 *__fastcall sub_5FE28(const char **a1);
_QWORD *__fastcall sub_60450(__int64 a1, __int64 *a2);
char *__fastcall sub_604F4(__int64 a1, _QWORD *a2, char a3);
char *__fastcall sub_605A8(const char **a1);
char *__fastcall sub_608B8(const char **a1);
_QWORD *__fastcall sub_60A30(__int64 a1, __int64 *a2);
char *__fastcall sub_60AE0(__int64 a1, __int64 *a2, int *a3);
_QWORD *__fastcall sub_60BA0(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_60C54(__int64 a1, __int64 *a2);
char *__fastcall sub_60D08(__int64 a1, __int64 a2);
void __fastcall sub_60E5C(void *a1);
char *__fastcall sub_60E64(__int64 a1, __int64 a2);
void __fastcall sub_610A0(void *a1);
__int64 sub_610A8();
__int64 sub_610B4();
_BYTE *__fastcall sub_610C0(__int64 a1, _QWORD *a2);
char *__fastcall sub_6114C(__int64 a1, __int64 a2);
void __fastcall sub_61604(void *a1);
char *__fastcall sub_6160C(_QWORD *a1, char **a2);
void __fastcall sub_61788(void *a1);
char *__fastcall sub_61790(_QWORD *a1, char **a2);
void __fastcall sub_61908(void *a1);
__int64 __fastcall sub_61910(__int64 a1);
__int64 __fastcall sub_61940(__int64 a1);
__int64 __fastcall sub_61970(__int64 a1);
__int64 __fastcall sub_619A0(__int64 a1, void **a2);
__int64 __fastcall sub_61B28(__int64 a1);
void __fastcall sub_61B3C(void *a1);
__int64 __fastcall sub_61B44(__int64 a1, void **a2);
void __fastcall sub_61C1C(void *a1);
char *__fastcall sub_61C24(__int64 a1, __int64 a2);
void __fastcall sub_61E00(void *a1);
_QWORD *__fastcall sub_61E08(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_61EAC(__int64 a1, __int64 *a2, __int64 *a3);
char *__fastcall sub_61F58(__int64 a1, char **a2);
void __fastcall sub_6207C(void *a1);
char *__fastcall sub_62084(__int64 a1, char **a2);
void __fastcall sub_621E4(void *a1);
_QWORD *__fastcall sub_621EC(__int64 a1, __int64 *a2, __int64 *a3);
__int64 sub_62294();
__int64 sub_622A0();
__int64 __fastcall sub_622AC(__int64 a1);
__int64 __fastcall sub_622C0(__int64 a1, __int64 a2);
void __fastcall sub_62470(void *a1);
_QWORD *__fastcall sub_62478(__int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_62530(__int64 a1);
char *__fastcall sub_62560(__int64 a1, char **a2);
__int64 __fastcall sub_62734(__int64 a1, _QWORD *a2);
void __fastcall sub_62820(void *a1);
__int64 __fastcall sub_62828(_QWORD *a1, char **a2);
void __fastcall sub_62964(void *a1);
__int64 __fastcall sub_6296C(__int64 a1);
char *__fastcall sub_6299C(__int64 a1, char **a2);
__int64 __fastcall sub_62CCC(__int64 a1, _QWORD *a2);
void __fastcall sub_62E1C(void *a1);
__int64 __fastcall sub_62E24(__int64 a1);
__int64 __fastcall sub_62E54(__int64 result, char **a2);
__int64 __fastcall sub_63094(__int64 result, _QWORD *a2);
void __fastcall sub_631D4(void *a1);
__int64 __fastcall sub_631DC(__int64 a1, unsigned int a2, __int64 a3);
void *__fastcall sub_6337C(__int64 a1, void **a2);
void __fastcall sub_63428(void *a1);
void *__fastcall operator new(size_t a1);
void *__fastcall operator new(size_t a1, const std::nothrow_t *a2);
void *__fastcall operator new[](size_t a1);
void *__fastcall operator new[](size_t a1, const std::nothrow_t *a2);
void __fastcall operator delete(void *ptr); // idb
void __fastcall operator delete(void *a1, const std::nothrow_t *a2); // idb
void __fastcall operator delete(void *a1);
void __fastcall operator delete[](void *a1); // idb
void __fastcall operator delete[](void *a1, const std::nothrow_t *a2); // idb
void __fastcall operator delete[](void *a1);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
void *__fastcall operator new[](size_t a1, unsigned __int64 a2);
void *__fastcall operator new[](size_t a1, unsigned __int64 a2);
void __fastcall operator delete(void *ptr);
void __fastcall operator delete(void *ptr);
void __fastcall operator delete(void *ptr);
void __fastcall operator delete[](void *ptr);
void __fastcall operator delete[](void *ptr);
void __fastcall operator delete[](void *ptr);
__int64 __fastcall sub_6368C(__int64 a1);
bool __fastcall sub_63698(_QWORD *a1);
void *_cxa_allocate_exception(size_t thrown_size);
void *_cxa_begin_catch(void *);
void _cxa_free_exception(void *);
long double _cxa_allocate_dependent_exception();
void __fastcall _cxa_free_dependent_exception(char *ptr);
void __noreturn _cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
void __fastcall __noreturn sub_63910(__int64 a1);
void *_cxa_get_exception_ptr(void *);
void _cxa_end_catch(void);
void __fastcall _cxa_decrement_exception_refcount(__int64 a1);
struct type_info *_cxa_current_exception_type(void);
void __noreturn _cxa_rethrow(void);
unsigned __int64 __fastcall _cxa_increment_exception_refcount(unsigned __int64 result);
__int64 _cxa_current_primary_exception();
_QWORD *__fastcall _cxa_rethrow_primary_exception(_QWORD *result);
void __fastcall sub_63DC4(int a1, __int64 a2);
bool _cxa_uncaught_exception();
_QWORD *_cxa_uncaught_exceptions();
int *__fastcall sub_63EA8(size_t a1);
int *__fastcall sub_63F04(__int64 a1);
void __fastcall sub_640A0(char *ptr);
__int64 __fastcall _gxx_personality_v0(int a1, int a2, __int64 a3, unsigned __int16 *a4, __int64 a5);
__int64 __fastcall sub_6443C(__int64 result, int a2, char a3, unsigned __int16 *a4, __int64 a5);
void __noreturn _cxa_call_unexpected(void *);
unsigned __int64 __fastcall sub_64B84(unsigned __int16 **a1, unsigned __int8 a2, __int64 a3);
bool __fastcall sub_64D50(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, unsigned __int16 *a5, void *a6, __int64 a7);
float __fastcall sub_64E70(float a1, float a2, float a3, float a4);
_QWORD *__fastcall _emutls_get_address(size_t *a1);
__int64 sub_65510();
__int64 sub_65548();
void __fastcall sub_65584(_QWORD *pointer);
unsigned __int64 __fastcall sub_65610(unsigned __int64 a1, atomic_ullong *a2);
__int64 sub_6563C();
unsigned __int64 __fastcall sub_656D4(unsigned __int64 result, __int64 a2);
void sub_65B0C();
unsigned __int64 __fastcall sub_65BB0(unsigned __int64 a1, atomic_ullong *a2);
// __int64 __usercall sub_65BE0@<X0>(_QWORD *a1@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, __int64 a4@<X3>, __int64 a5@<X4>, __int64 a6@<X5>, __int64 a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, double a10@<D0>, double a11@<D1>, double a12@<D2>, double a13@<D3>, double a14@<D4>, double a15@<D5>, double a16@<D6>, double a17@<D7>);
__int64 __fastcall sub_65CD8(_OWORD *a1, __int64 a2, _QWORD *a3);
// void __usercall __noreturn sub_65E10(_QWORD *a1@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, __int64 a4@<X3>, __int64 a5@<X4>, __int64 a6@<X5>, __int64 a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, double a10@<D0>, double a11@<D1>, double a12@<D2>, double a13@<D3>, double a14@<D4>, double a15@<D5>, double a16@<D6>, double a17@<D7>);
__int64 __fastcall sub_65E98(_OWORD *a1, __int64 a2, _QWORD *a3, __int64 (__fastcall *a4)(__int64, __int64, _QWORD, _QWORD *, __int64, __int64), __int64 a5);
__int64 __fastcall sub_65F8C(__int64 a1);
__int64 __fastcall sub_65FC0(__int64 a1);
__int64 __fastcall sub_65FF4(__int64 result);
__int64 __fastcall sub_66010(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_66018(__int64 a1);
__int64 __fastcall sub_66048(__int64 a1, __int64 a2);
__int64 __fastcall sub_66058(__int64 a1, _OWORD *a2);
__int64 __fastcall sub_66104(__int64 a1, unsigned int a2, __int64 *a3);
__int64 __fastcall sub_66180(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_6626C(__int64 a1);
__int64 __fastcall sub_66280(__int64 a1);
__int64 __fastcall sub_66294(__int64 a1, __int64 a2);
__int64 __fastcall sub_662D4(__int64 a1);
const char *__fastcall sub_662FC(__int64 a1, unsigned int *a2, _QWORD *a3, __int64 a4, char a5);
const char *__fastcall sub_6648C(__int64 a1, unsigned int *a2, __int64 a3);
void sub_6674C();
void sub_66754();
bool __fastcall sub_6675C(__int64 a1, unsigned int a2);
__int64 __fastcall sub_6679C(_QWORD *a1, unsigned int a2);
_QWORD *__fastcall sub_668BC(_QWORD *result, unsigned int a2, __int64 a3);
bool __fastcall sub_669DC(__int64 a1, int a2);
double __fastcall sub_669F0(__int64 a1, int a2);
__int64 __fastcall sub_66A00(__int64 result, int a2, double a3);
__int64 __fastcall sub_66A10(__int64 a1, char a2);
long double __fastcall sub_66AE8(__int64 a1, __int64 a2);
__int64 __fastcall sub_66B2C(__int64 a1);
__int64 __fastcall sub_66B38(__int64 a1);
__int64 __fastcall sub_66B44(__int64 a1);
__int64 __fastcall sub_66B70(__int64 a1, char a2);
const char *__fastcall sub_66DF0(__int64 a1, int a2);
__int64 __fastcall sub_66DFC(__int64 a1);
__int64 __fastcall sub_66F20(__int64 a1, __int64 a2, unsigned int *a3, __int64 *a4, _BYTE *a5, char a6);
__int64 __fastcall sub_673DC(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int a5, _BYTE *dest);
__int64 __fastcall sub_67EF0(__int64 a1, unsigned __int8 **a2, __int64 *a3);
__int64 __fastcall sub_67FEC(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_681E8(__int64 a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 a4, __int64 a5);
__int64 __fastcall sub_6850C(unsigned __int8 **a1, unsigned __int8 *a2);
__int64 __fastcall sub_686DC(unsigned __int8 *a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall sub_690A0(__int64 a1, unsigned __int64 a2, __int64 *a3, unsigned int a4);
__int64 __fastcall sub_69388(unsigned __int64 *a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_69528(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3, __int64 a4, unsigned __int8 *a5, _QWORD *a6, _BYTE *a7);
__int64 __fastcall sub_696F0(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3, int a4, _QWORD *a5, __int64 a6);
__int64 __fastcall sub_698BC(char a1);
const char *__fastcall sub_699A4(int a1);
__int64 __fastcall sub_699D4(__int64 a1);
// __int64 __usercall sub_69A64@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, __int64 a3@<X2>, __int64 a4@<X3>, __int64 a5@<X4>, __int64 a6@<X5>, __int64 a7@<X6>, __int64 a8@<X7>, __int64 a9@<X8>, double a10@<D0>, double a11@<D1>, double a12@<D2>, double a13@<D3>, double a14@<D4>, double a15@<D5>, double a16@<D6>, double a17@<D7>, __int64 a18);
void sub_69B00();
// int __cxa_finalize(void *);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// __int64 __fastcall __register_atfork(_QWORD, _QWORD, _QWORD, _QWORD); weak
void *__fastcall operator new(size_t a1);
__int64 __fastcall GSMO_GET_VERSION(_QWORD *a1);
void __fastcall operator delete(void *a1); // idb
__int64 __fastcall GSMO_CREATE(_QWORD *a1);
__int64 __fastcall GSMO_DESTROY(void **a1);
void *__fastcall operator new[](size_t a1);
void __fastcall operator delete[](void *a1); // idb
__int64 __fastcall GSMO_SETUP(unsigned int *a1, _DWORD *a2, __int64 a3);
__int64 __fastcall GSMO_UPDATE(__int64 a1, __int64 a2);
__int64 __fastcall GSMO_FLUSH(__int64 a1);
__int64 __fastcall GSMO_RESET(__int64 a1);
__int64 __fastcall GSMO_PROCESS(unsigned int *a1, __int64 a2, int16x4_t *s, unsigned int a4, unsigned int *a5);
__int64 __fastcall GSMO_GET_PARAMETER(__int64 a1, char *s1, float *a3);
__int64 __fastcall GSMO_SET_PARAMETER(_BYTE *a1, char *s1, _DWORD *a3);
__int64 __fastcall GSMO_GET_LATENCY(__int64 a1, _DWORD *a2);
__int64 __fastcall GSMO_GET_CAPS(__int64 a1, _DWORD *a2);
__int64 __fastcall GSMO_SET_PROFILE(__int64 a1, char *s);
__int64 __fastcall AES_ECB_decrypt(_BYTE *a1, unsigned __int8 *a2);
__int64 AES_init_ctx();
__int64 __fastcall _checkValidConfig(__int64 a1, _DWORD *a2);
__int64 __fastcall _checkValidParams(__int64 a1, _DWORD *a2, __int64 a3);
long double __fastcall _copy_params(__int64 a1, __int64 a2);
__int64 __fastcall _update(__int64 a1, double a2);
// int atoi(const char *nptr);
_BYTE *__fastcall base64_decode(unsigned __int8 *a1, __int64 a2, _QWORD *a3);
long double __fastcall boost_gain_create(_QWORD *a1);
__int64 __fastcall boost_gain_destroy(void **a1);
__int64 __fastcall boost_gain_flush(__int64 a1);
__int64 __fastcall boost_gain_process(int *a1, float32x4_t *src, float32x4_t *dest);
__int64 __fastcall boost_gain_reset(__int64 a1);
__int64 __fastcall boost_gain_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4);
__int64 __fastcall boost_gain_update(__int64 a1, char a2, float a3, float a4, float a5, float a6);
// float __fastcall cabsf(float); weak
long double __fastcall channel_layout_converter_create(_QWORD *a1);
__int64 __fastcall channel_layout_converter_destroy(void **a1);
__int64 __fastcall channel_layout_converter_flush(__int64 a1);
__int64 __fastcall channel_layout_converter_process(unsigned int *a1, unsigned __int64 a2, unsigned __int64 a3, double a4);
__int64 __fastcall channel_layout_converter_reset(__int64 a1);
__int64 __fastcall channel_layout_converter_setup(unsigned int *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
long double __fastcall compressor_create(_QWORD *a1);
__int64 __fastcall compressor_destroy(__int64 *a1);
__int64 __fastcall compressor_flush(__int64 a1);
__int64 __fastcall compressor_process(unsigned int *a1, float *a2, __int64 a3);
__int64 __fastcall compressor_reset(__int64 a1);
__int64 __fastcall compressor_setup(unsigned int *a1, size_t n, unsigned int a3, unsigned int a4);
__int64 __fastcall compressor_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7);
__int64 __fastcall drc_bypass(__int64 a1, __int64 a2, __int64 a3);
long double __fastcall drc_create(_QWORD *a1);
__int64 __fastcall drc_delay_sample_count(__int64 a1, _DWORD *a2);
__int64 __fastcall drc_destroy(__int64 *a1);
__int64 __fastcall drc_flush(__int64 a1);
__int64 __fastcall drc_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall drc_reset(__int64 a1);
__int64 __fastcall drc_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4);
__int64 __fastcall drc_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9);
long double __fastcall dynamic_queue_create(_QWORD *a1);
__int64 __fastcall dynamic_queue_destroy(__int64 *a1);
__int64 __fastcall dynamic_queue_flush(__int64 a1);
__int64 __fastcall dynamic_queue_get_latency(__int64 a1, _DWORD *a2);
__int64 __fastcall dynamic_queue_process(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall dynamic_queue_process_planar(unsigned int *a1, __int64 a2, __int64 a3, signed int a4);
__int64 __fastcall dynamic_queue_process_s16(unsigned int *a1, __int64 a2, int16x4_t *a3, unsigned int a4);
__int64 __fastcall dynamic_queue_process_s16_planar(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall dynamic_queue_reset(__int64 a1);
__int64 __fastcall dynamic_queue_setup(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7, size_t n);
long double __fastcall eleq_create(_QWORD *a1);
__int64 __fastcall eleq_destroy(__int64 *a1);
__int64 __fastcall eleq_flush(__int64 a1);
__int64 __fastcall eleq_process(int *a1, __int64 a2, __int64 a3);
__int64 __fastcall eleq_reset(__int64 a1);
__int64 __fastcall eleq_setup(unsigned int *a1, unsigned int a2, unsigned int a3, size_t n);
__int64 __fastcall eleq_update(__int64 a1, char a2, double a3, float a4, float a5, float a6, float a7);
// void free(void *ptr);
__int64 __fastcall gain_create(_QWORD *a1);
__int64 __fastcall gain_destroy(void **a1);
__int64 __fastcall gain_flush(__int64 a1);
__int64 __fastcall gain_process(__int64 a1, float32x4_t *a2, float32x4_t *a3, double a4, double a5, double a6);
__int64 __fastcall gain_reset(__int64 a1);
__int64 __fastcall gain_setup(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall gain_update(__int64 a1, float a2);
long double __fastcall graphic_equalizer_create(_QWORD *a1);
__int64 __fastcall graphic_equalizer_destroy(__int64 *a1);
__int64 __fastcall graphic_equalizer_flush(__int64 a1);
__int64 __fastcall graphic_equalizer_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall graphic_equalizer_reset(__int64 a1);
__int64 __fastcall graphic_equalizer_setup(__int64 a1, int a2, int a3, int a4, size_t n);
__int64 __fastcall graphic_equalizer_update(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
long double __fastcall iir_create(_QWORD *a1);
__int64 __fastcall iir_destroy(__int64 *a1);
__int64 __fastcall iir_flush(__int64 a1);
__int64 __fastcall iir_process(unsigned int *a1, __int64 a2, __int64 a3);
__int64 __fastcall iir_reset(__int64 a1);
__int64 __fastcall iir_setup(__int64 a1, size_t n, int a3, int a4, float *a5, float *a6);
__int64 __fastcall limiter_bypass(__int64 a1, const void *a2, void *a3);
long double __fastcall limiter_create(_QWORD *a1);
__int64 __fastcall limiter_delay_sample_count(__int64 a1, _DWORD *a2);
__int64 __fastcall limiter_destroy(__int64 *a1);
__int64 __fastcall limiter_flush(__int64 a1);
__int64 __fastcall limiter_process(float *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall limiter_reset(__int64 a1);
__int64 __fastcall limiter_setup(__int64 a1, size_t n, int a3, int a4, float a5);
__int64 __fastcall lm1_wrapper_decode(__int64 a1, unsigned int a2, __int64 a3);
// float log10f(float x);
float __fastcall loudness_measure_getInstantLoudness(__int64 a1);
void __fastcall loudness_measure_getIntegratedLoudness(__int64 a1);
// void *malloc(size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// void *memset(void *s, int c, size_t n);
// float powf(float x, float y);
long double __fastcall resampler_create(_QWORD *a1);
__int64 __fastcall resampler_destroy(__int64 *a1);
__int64 __fastcall resampler_get_external_samples(__int64 a1, _DWORD *a2);
__int64 __fastcall resampler_get_internal_samples(__int64 a1, _DWORD *a2);
__int64 __fastcall resampler_get_latency(__int64 a1, int *a2);
__int64 __fastcall resampler_run_external_to_internal(unsigned int *a1, void *src, void *dest);
__int64 __fastcall resampler_run_internal_to_external(__int64 a1, const void *a2, char *dest);
void __fastcall resampler_setup(unsigned int *a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5);
// void sincosf(float x, float *sinx, float *cosx);
long double __fastcall sln_create(_QWORD *a1);
__int64 __fastcall sln_destroy(__int64 *a1);
__int64 __fastcall sln_flush(__int64 a1);
__int64 __fastcall sln_reset(__int64 a1);
__int64 __fastcall sln_setup(__int64 a1, int a2, int a3, unsigned int a4, unsigned __int64 a5);
__int64 __fastcall sln_sol_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall spatial_upmix_bypass(__int64 a1, _DWORD *a2, __int64 a3);
long double __fastcall spatial_upmix_create(_QWORD *a1);
__int64 __fastcall spatial_upmix_delay_sample_count(__int64 a1, _DWORD *a2);
__int64 __fastcall spatial_upmix_destroy(__int64 *a1);
__int64 __fastcall spatial_upmix_flush(__int64 a1);
float __fastcall spatial_upmix_process(__int64 a1, float *a2, unsigned __int64 a3);
__int64 __fastcall spatial_upmix_reset(__int64 a1);
__int64 __fastcall spatial_upmix_setup(__int64 a1, int a2, int a3, int a4, size_t n, float a6);
__int64 __fastcall spatial_upmix_update(__int64 a1, unsigned int a2, float a3);
__int64 __fastcall static_resampler_get_internal_sample_rate(int a1, int *a2);
// int strcmp(const char *s1, const char *s2);
// size_t strlen(const char *s);
// float tanf(float x);
__int64 __fastcall lm1_decode(_QWORD *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall lm1_free(__int64 a1);
// void __noreturn exit(int status);
__int64 __fastcall circular_buffer_clear(__int64 a1);
__int64 __fastcall circular_buffer_create(_QWORD *a1);
__int64 __fastcall circular_buffer_dequeue_data(unsigned int *a1, _DWORD *a2);
__int64 __fastcall circular_buffer_destroy(void **a1);
__int64 __fastcall circular_buffer_enqueue(__int64 a1, float a2);
__int64 __fastcall circular_buffer_free(__int64 a1);
__int64 __fastcall circular_buffer_init(__int64 a1, unsigned int a2);
__int64 __fastcall circular_buffer_size(__int64 a1);
__int64 __fastcall greatest_common_divisor(int a1, int a2);
__int64 __fastcall iir_process_inplace(unsigned int *a1, __int64 a2);
__int64 __fastcall iir_update(__int64 a1, float *a2, float *a3, double a4);
long double __fastcall loudness_measure_create(_QWORD *a1);
__int64 __fastcall loudness_measure_destroy(void ***a1);
__int64 __fastcall loudness_measure_getFramewiseGainArray(__int64 a1, float *a2, float a3);
__int64 __fastcall loudness_measure_get_frameLength(__int64 a1);
__int64 __fastcall loudness_measure_process(unsigned int *a1, __int64 a2);
__int64 __fastcall loudness_measure_setup(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned __int64 a5);
__int64 __fastcall peak_setup(__int64 a1, unsigned int a2, unsigned int a3, int a4, int a5);
__int64 __fastcall peak_update(__int64 a1, unsigned int a2, int a3, float a4, float a5, float a6);
long double __fastcall reverb_create(_QWORD *a1);
__int64 __fastcall reverb_destroy(__int64 *a1);
__int64 __fastcall reverb_process(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall reverb_setup(__int64 a1, int a2, __int64 a3, int a4, int a5);
__int64 __fastcall reverb_update(__int64 a1, __int64 a2, float a3);
__int64 __fastcall spatializer_bypass(__int64 a1, _DWORD *a2, __int64 a3);
long double __fastcall spatializer_create(_QWORD *a1);
__int64 __fastcall spatializer_delay_sample_count(__int64 a1, _DWORD *a2);
__int64 __fastcall spatializer_destroy(__int64 *a1);
__int64 __fastcall spatializer_offSetting(__int64 a1);
__int64 __fastcall spatializer_process(__int64 a1, const float *a2, __int64 a3);
__int64 __fastcall spatializer_setup(__int64 a1, int a2, int a3, int a4);
__int64 __fastcall spatializer_update(__int64 a1, unsigned int a2, unsigned int a3);
// float expf(float x);
// void *memmove(void *dest, const void *src, size_t n);
// float cosf(float x);
// float fmodf(float x, float y);
// float sinf(float x);
__int64 __fastcall circular_buffer_dequeue(int *a1);
__int64 __fastcall circular_buffer_dequeue_data_count(int *a1, char *dest, unsigned int a3);
__int64 __fastcall circular_buffer_enqueueForce(unsigned int *a1, float a2);
__int64 __fastcall circular_buffer_readAll(unsigned int *a1, char *dest, _DWORD *a3);
__int64 __fastcall circular_buffer_readFront(unsigned int *a1, char *dest, unsigned int a3);
void __fastcall loudness_measure_getLRA(__int64 a1);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double pow(double x, double y);
// void sincos(double x, double *sinx, double *cosx);
// double tan(double x);
long double __fastcall comb_create(_QWORD *a1);
__int64 __fastcall comb_destroy(__int64 *a1);
__int64 __fastcall comb_flush(__int64 a1);
__int64 __fastcall comb_process(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall comb_process_acc(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall comb_setup(__int64 a1, int a2, int a3, size_t n, float a5);
__int64 __fastcall comb_update(__int64 a1, float a2);
long double __fastcall allpass_create(_QWORD *a1);
__int64 __fastcall allpass_destroy(__int64 *a1);
__int64 __fastcall allpass_flush(__int64 a1);
__int64 __fastcall allpass_process_inplace(unsigned int *a1, __int64 a2);
__int64 __fastcall allpass_setup(__int64 a1, int a2, int a3, size_t n, float a5);
float __fastcall fft_backward_ordered(__int64 a1, const void *a2, unsigned __int64 a3);
long double __fastcall fft_create(_QWORD *a1);
__int64 __fastcall fft_destroy(__int64 *a1);
void *__fastcall fft_forward_ordered(__int64 a1, const void *a2, void *a3);
unsigned __int64 __fastcall fft_setup(__int64 a1, unsigned int a2);
void __fastcall pffft_aligned_free(__int64 a1);
unsigned __int64 __fastcall pffft_aligned_malloc(__int64 a1);
void __fastcall pffft_destroy_setup(_QWORD *ptr);
int32x4_t *__fastcall pffft_new_setup(int a1, unsigned __int32 a2);
__int64 pffft_simd_size();
int8x16_t __fastcall pffft_transform(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, long double a6, long double a7, long double a8, long double a9, long double a10);
int8x16_t __fastcall pffft_transform_ordered(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, long double a6, long double a7, long double a8, long double a9, long double a10);
float __fastcall pffft_zconvolve_accumulate(__int64 a1, float *a2, float *a3, float *a4, double a5);
int8x16_t __fastcall pffft_zreorder(int *a1, int32x4_t *a2, int8x16_t *a3, int a4, int8x16_t result);
float32x4_t *__fastcall cfftf1_ps(int a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6, int a7, double a8, double a9, double a10, double a11, long double a12);
void __fastcall cffti1_ps(int a1, __int64 a2, int *a3);
int8x16_t __fastcall pffft_transform_internal(__int64 a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, int a5, int a6, long double a7, long double a8, long double a9, long double a10, long double a11);
// int printf(const char *format, ...);
__int64 __fastcall _readFlexibleAsUInt64(__int64 a1);
// void *calloc(size_t nmemb, size_t size);
// void __noreturn longjmp(struct __jmp_buf_tag env[1], int val);
// int setjmp(jmp_buf env);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
void *__cxa_begin_catch(void *);
void __noreturn std::terminate(void); // idb
_QWORD *__cxa_get_globals();
_QWORD *__cxa_get_globals_fast();
unsigned __int64 std::get_unexpected(void);
unsigned __int64 std::get_terminate(void);
unsigned __int64 std::get_new_handler(void);
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
_QWORD *__fastcall __emutls_get_address(size_t *a1);
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this);
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this); // idb
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this); // idb
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int fputc(int c, FILE *stream);
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
// __int64 __fastcall android_set_abort_message(_QWORD); weak
// void openlog(const char *ident, int option, int facility);
// void syslog(int pri, const char *fmt, ...);
// void closelog(void);
// void __noreturn abort(void);
void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
// __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void *realloc(void *ptr, size_t size);
// int fprintf(FILE *stream, const char *format, ...);
// void *memchr(const void *s, int c, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
void *__cxa_allocate_exception(size_t thrown_size);
void __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
void __cxa_end_catch(void);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
// int posix_memalign(void **memptr, size_t alignment, size_t size);
void *__fastcall operator new[](size_t a1, unsigned __int64 a2);
void __fastcall operator delete(void *ptr);
void __fastcall operator delete[](void *ptr);
void __noreturn __cxa_rethrow(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *pthread_getspecific(pthread_key_t key);
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// int pthread_key_delete(pthread_key_t key);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// unsigned __int64 getauxval(unsigned __int64 type);
// __int64 __fastcall __system_property_get(_QWORD, _QWORD); weak
// int fflush(FILE *stream);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// __pid_t getpid(void);
// __int64 syscall(__int64 sysno, ...);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_8 = '\0'; // weak
__int16 word_10 = 3; // weak
__int64 qword_18 = 0LL; // weak
__int64 qword_28 = 461776LL; // weak
int dword_30 = 0; // weak
__int16 word_34 = 64; // weak
__int16 word_38 = 9; // weak
int dword_40 = 6; // weak
__int64 qword_48 = 64LL; // weak
int *off_50[4] = { &dword_40, &dword_40, &qword_1F8, &qword_1F8 }; // weak
int dword_7C = 5; // weak
__int64 qword_80 = 0LL; // weak
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
__int128 xmmword_168F0 = 0x4100000042C80000BEA2E8BA3DAF8AF9LL; // weak
__int128 xmmword_16900 = 0x40400000C04000003F0000003F000000LL; // weak
__int128 xmmword_16910 = 0xA000000080000000500000003LL; // weak
__int128 xmmword_16920 = 0x3F8000003F80000000000000C1C00000LL; // weak
__int128 xmmword_16930 = 0x3200000026000000140000000DLL; // weak
__int128 xmmword_16940 = 0x3000000020000000100000000LL; // weak
__int128 xmmword_16950 = 0xC1000000C1F00000C2C80000BF800000LL; // weak
__int128 xmmword_16960 = 0x2580000012C000000960000004BLL; // weak
__int128 xmmword_16980 = 0x3F8000003F8000003F8000003F800000LL; // weak
__int128 xmmword_16990 = 0x3F8000003F8000003F8000003F800000LL; // weak
int dword_169A8[] = { 1034914553 }; // weak
_BYTE byte_169E8[256] =
{
  99,
  124,
  119,
  123,
  -14,
  107,
  111,
  -59,
  48,
  1,
  103,
  43,
  -2,
  -41,
  -85,
  118,
  -54,
  -126,
  -55,
  125,
  -6,
  89,
  71,
  -16,
  -83,
  -44,
  -94,
  -81,
  -100,
  -92,
  114,
  -64,
  -73,
  -3,
  -109,
  38,
  54,
  63,
  -9,
  -52,
  52,
  -91,
  -27,
  -15,
  113,
  -40,
  49,
  21,
  4,
  -57,
  35,
  -61,
  24,
  -106,
  5,
  -102,
  7,
  18,
  128,
  -30,
  -21,
  39,
  -78,
  117,
  9,
  -125,
  44,
  26,
  27,
  110,
  90,
  -96,
  82,
  59,
  -42,
  -77,
  41,
  -29,
  47,
  -124,
  83,
  -47,
  0,
  -19,
  32,
  -4,
  -79,
  91,
  106,
  -53,
  -66,
  57,
  74,
  76,
  88,
  -49,
  -48,
  -17,
  -86,
  -5,
  67,
  77,
  51,
  -123,
  69,
  -7,
  2,
  127,
  80,
  60,
  -97,
  -88,
  81,
  -93,
  64,
  -113,
  -110,
  -99,
  56,
  -11,
  -68,
  -74,
  -38,
  33,
  16,
  -1,
  -13,
  -46,
  -51,
  12,
  19,
  -20,
  95,
  -105,
  68,
  23,
  -60,
  -89,
  126,
  61,
  100,
  93,
  25,
  115,
  96,
  -127,
  79,
  -36,
  34,
  42,
  -112,
  -120,
  70,
  -18,
  -72,
  20,
  -34,
  94,
  11,
  -37,
  -32,
  50,
  58,
  10,
  73,
  6,
  36,
  92,
  -62,
  -45,
  -84,
  98,
  -111,
  -107,
  -28,
  121,
  -25,
  -56,
  55,
  109,
  -115,
  -43,
  78,
  -87,
  108,
  86,
  -12,
  -22,
  101,
  122,
  -82,
  8,
  -70,
  120,
  37,
  46,
  28,
  -90,
  -76,
  -58,
  -24,
  -35,
  116,
  31,
  75,
  -67,
  -117,
  -118,
  112,
  62,
  -75,
  102,
  72,
  3,
  -10,
  14,
  97,
  53,
  87,
  -71,
  -122,
  -63,
  29,
  -98,
  -31,
  -8,
  -104,
  17,
  105,
  -39,
  -114,
  -108,
  -101,
  30,
  -121,
  -23,
  -50,
  85,
  40,
  -33,
  -116,
  -95,
  -119,
  13,
  -65,
  -26,
  66,
  104,
  65,
  -103,
  45,
  15,
  -80,
  84,
  -69,
  22
}; // weak
_BYTE byte_16AE8[11] = { -115, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 }; // weak
_BYTE byte_16AF3[257] =
{
  82,
  9,
  106,
  -43,
  48,
  54,
  -91,
  56,
  -65,
  64,
  -93,
  -98,
  -127,
  -13,
  -41,
  -5,
  124,
  -29,
  57,
  -126,
  -101,
  47,
  -1,
  -121,
  52,
  -114,
  67,
  68,
  -60,
  -34,
  -23,
  -53,
  84,
  123,
  -108,
  50,
  -90,
  -62,
  35,
  61,
  -18,
  76,
  -107,
  11,
  66,
  -6,
  -61,
  78,
  8,
  46,
  -95,
  102,
  40,
  -39,
  36,
  -78,
  118,
  91,
  -94,
  73,
  109,
  -117,
  -47,
  37,
  114,
  -8,
  -10,
  100,
  -122,
  104,
  -104,
  22,
  -44,
  -92,
  92,
  -52,
  93,
  101,
  -74,
  -110,
  108,
  112,
  72,
  80,
  -3,
  -19,
  -71,
  -38,
  94,
  21,
  70,
  87,
  -89,
  -115,
  -99,
  -124,
  -112,
  -40,
  -85,
  0,
  -116,
  -68,
  -45,
  10,
  -9,
  -28,
  88,
  5,
  -72,
  -77,
  69,
  6,
  -48,
  44,
  30,
  -113,
  -54,
  63,
  15,
  2,
  -63,
  -81,
  -67,
  3,
  1,
  19,
  -118,
  107,
  58,
  -111,
  17,
  65,
  79,
  103,
  -36,
  -22,
  -105,
  -14,
  -49,
  -50,
  -16,
  -76,
  -26,
  115,
  -106,
  -84,
  116,
  34,
  -25,
  -83,
  53,
  -123,
  -30,
  -7,
  55,
  -24,
  28,
  117,
  -33,
  110,
  71,
  -15,
  26,
  113,
  29,
  41,
  -59,
  -119,
  111,
  -73,
  98,
  14,
  -86,
  24,
  -66,
  27,
  -4,
  86,
  62,
  75,
  -58,
  -46,
  121,
  32,
  -102,
  -37,
  -64,
  -2,
  120,
  -51,
  90,
  -12,
  31,
  -35,
  -88,
  51,
  -120,
  7,
  -57,
  49,
  -79,
  18,
  16,
  89,
  39,
  128,
  -20,
  95,
  96,
  81,
  127,
  -87,
  25,
  -75,
  74,
  13,
  45,
  -27,
  122,
  -97,
  -109,
  -55,
  -100,
  -17,
  -96,
  -32,
  59,
  77,
  -82,
  42,
  -11,
  -80,
  -56,
  -21,
  -69,
  60,
  -125,
  83,
  -103,
  97,
  23,
  43,
  4,
  126,
  -70,
  119,
  -42,
  38,
  -31,
  105,
  20,
  99,
  85,
  33,
  12,
  125,
  0
}; // weak
_UNKNOWN unk_16BF4; // weak
_UNKNOWN unk_16C24; // weak
_UNKNOWN unk_16C54; // weak
_UNKNOWN unk_16C84; // weak
_UNKNOWN unk_16CB4; // weak
_UNKNOWN unk_16CE4; // weak
_UNKNOWN unk_16D14; // weak
_UNKNOWN unk_16D2C; // weak
_UNKNOWN unk_16D44; // weak
_UNKNOWN unk_16D5C; // weak
_UNKNOWN unk_16D74; // weak
_UNKNOWN unk_16DA4; // weak
_UNKNOWN unk_16DD4; // weak
_UNKNOWN unk_16E04; // weak
_UNKNOWN unk_16E34; // weak
_UNKNOWN unk_16E64; // weak
_UNKNOWN unk_16E94; // weak
_UNKNOWN unk_16EC4; // weak
_UNKNOWN multiChnIdx; // weak
_DWORD dmxGains[4] = { 1065353216, 1060437492, 1060437492, 1060437492 }; // weak
_UNKNOWN unk_16F30; // weak
_DWORD dword_16F60[12] = { 1, 2, 1, 1, 5, 6, 1, 8, 1, 1, 1, 12 }; // weak
_UNKNOWN unk_16FB0; // weak
_UNKNOWN unk_17140; // weak
__int128 xmmword_172DC = 0x44FA00004448000043B9000042C80000LL; // weak
__int128 xmmword_172F0 = 0x4416000043C800004348000042C80000LL; // weak
__int128 xmmword_1730C = 0x437A000042FA0000427C000041F80000LL; // weak
__int128 xmmword_1731C = 0x457A000044FA0000447A000043FA0000LL; // weak
float kExponentialWeightTable[441] =
{
  1.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.625,
  0.375,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.5102,
  0.30612,
  0.18367,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.45956,
  0.27574,
  0.16544,
  0.099265,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.43373,
  0.26024,
  0.15614,
  0.093685,
  0.056211,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.41958,
  0.25175,
  0.15105,
  0.090628,
  0.054377,
  0.032626,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.41152,
  0.24691,
  0.14815,
  0.088888,
  0.053333,
  0.032,
  0.0192,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40683,
  0.2441,
  0.14646,
  0.087876,
  0.052726,
  0.031635,
  0.018981,
  0.011389,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40407,
  0.24244,
  0.14547,
  0.08728,
  0.052368,
  0.031421,
  0.018852,
  0.011311,
  0.0067869,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40243,
  0.24146,
  0.14488,
  0.086926,
  0.052155,
  0.031293,
  0.018776,
  0.011266,
  0.0067593,
  0.0040556,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40146,
  0.24087,
  0.14452,
  0.086715,
  0.052029,
  0.031217,
  0.01873,
  0.011238,
  0.0067429,
  0.0040458,
  0.0024275,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40087,
  0.24052,
  0.14431,
  0.086588,
  0.051953,
  0.031172,
  0.018703,
  0.011222,
  0.0067331,
  0.0040399,
  0.0024239,
  0.0014544,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40052,
  0.24031,
  0.14419,
  0.086513,
  0.051908,
  0.031145,
  0.018687,
  0.011212,
  0.0067272,
  0.0040364,
  0.0024218,
  0.0014531,
  0.00087185,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40031,
  0.24019,
  0.14411,
  0.086468,
  0.051881,
  0.031128,
  0.018677,
  0.011206,
  0.0067237,
  0.0040342,
  0.0024205,
  0.0014523,
  0.0008714,
  0.00052284,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40019,
  0.24011,
  0.14407,
  0.086441,
  0.051864,
  0.031119,
  0.018671,
  0.011203,
  0.0067216,
  0.004033,
  0.0024198,
  0.0014519,
  0.00087112,
  0.00052267,
  0.0003136,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40011,
  0.24007,
  0.14404,
  0.086424,
  0.051855,
  0.031113,
  0.018668,
  0.011201,
  0.0067204,
  0.0040322,
  0.0024193,
  0.0014516,
  0.00087096,
  0.00052257,
  0.00031354,
  0.00018813,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40007,
  0.24004,
  0.14402,
  0.086415,
  0.051849,
  0.031109,
  0.018666,
  0.011199,
  0.0067196,
  0.0040318,
  0.0024191,
  0.0014514,
  0.00087086,
  0.00052252,
  0.00031351,
  0.00018811,
  0.00011286,
  0.0,
  0.0,
  0.0,
  0.0,
  0.40004,
  0.24002,
  0.14401,
  0.086409,
  0.051845,
  0.031107,
  0.018664,
  0.011199,
  0.0067191,
  0.0040315,
  0.0024189,
  0.0014513,
  0.0008708,
  0.00052248,
  0.00031349,
  0.00018809,
  0.00011286,
  0.000067714,
  0.0,
  0.0,
  0.0,
  0.40002,
  0.24001,
  0.14401,
  0.086405,
  0.051843,
  0.031106,
  0.018664,
  0.011198,
  0.0067189,
  0.0040313,
  0.0024188,
  0.0014513,
  0.00087077,
  0.00052246,
  0.00031348,
  0.00018809,
  0.00011285,
  0.000067711,
  0.000040626,
  0.0,
  0.0,
  0.40001,
  0.24001,
  0.14401,
  0.086403,
  0.051842,
  0.031105,
  0.018663,
  0.011198,
  0.0067187,
  0.0040312,
  0.0024187,
  0.0014512,
  0.00087074,
  0.00052245,
  0.00031347,
  0.00018808,
  0.00011285,
  0.000067709,
  0.000040625,
  0.000024375,
  0.0,
  0.40001,
  0.24001,
  0.144,
  0.086402,
  0.051841,
  0.031105,
  0.018663,
  0.011198,
  0.0067186,
  0.0040312,
  0.0024187,
  0.0014512,
  0.00087073,
  0.00052244,
  0.00031346,
  0.00018808,
  0.00011285,
  0.000067708,
  0.000040625,
  0.000024375,
  0.000014625
}; // weak
float channelWeightList[156] =
{
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  1.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  1.0,
  1.0,
  1.41,
  1.41,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  1.0,
  1.0,
  0.0,
  1.41,
  1.41,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  1.0,
  1.0,
  0.0,
  1.41,
  1.41,
  1.0,
  1.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  1.0,
  1.0,
  1.0,
  0.0,
  1.41,
  1.41,
  1.0,
  1.0,
  1.0,
  1.0,
  1.0,
  1.0
}; // weak
float histogramLookupTable[731] =
{
  1.159e-7,
  1.186e-7,
  1.214e-7,
  1.242e-7,
  1.271e-7,
  1.3e-7,
  1.331e-7,
  1.362e-7,
  1.393e-7,
  1.426e-7,
  1.459e-7,
  1.493e-7,
  1.528e-7,
  1.564e-7,
  1.6e-7,
  1.637e-7,
  1.675e-7,
  1.714e-7,
  1.754e-7,
  1.795e-7,
  1.837e-7,
  1.88e-7,
  1.924e-7,
  1.968e-7,
  2.014e-7,
  2.061e-7,
  2.109e-7,
  2.158e-7,
  2.209e-7,
  2.26e-7,
  2.313e-7,
  2.366e-7,
  2.422e-7,
  2.478e-7,
  2.536e-7,
  2.595e-7,
  2.655e-7,
  2.717e-7,
  2.78e-7,
  2.845e-7,
  2.911e-7,
  2.979e-7,
  3.049e-7,
  3.12e-7,
  3.192e-7,
  3.267e-7,
  3.343e-7,
  3.421e-7,
  3.5e-7,
  3.582e-7,
  3.665e-7,
  3.751e-7,
  3.838e-7,
  3.927e-7,
  4.019e-7,
  4.112e-7,
  4.208e-7,
  4.306e-7,
  4.407e-7,
  4.509e-7,
  4.614e-7,
  4.722e-7,
  4.832e-7,
  4.944e-7,
  5.059e-7,
  5.177e-7,
  5.298e-7,
  5.421e-7,
  5.548e-7,
  5.677e-7,
  5.809e-7,
  5.944e-7,
  6.083e-7,
  6.224e-7,
  6.369e-7,
  6.518e-7,
  6.67e-7,
  6.825e-7,
  6.984e-7,
  7.147e-7,
  7.313e-7,
  7.483e-7,
  7.658e-7,
  7.836e-7,
  8.019e-7,
  8.205e-7,
  8.397e-7,
  8.592e-7,
  8.792e-7,
  8.997e-7,
  9.207e-7,
  9.421e-7,
  9.641e-7,
  9.865e-7,
  0.0000010095,
  0.000001033,
  0.0000010571,
  0.0000010817,
  0.0000011069,
  0.0000011327,
  0.000001159,
  0.000001186,
  0.0000012137,
  0.0000012419,
  0.0000012709,
  0.0000013005,
  0.0000013308,
  0.0000013618,
  0.0000013935,
  0.0000014259,
  0.0000014592,
  0.0000014931,
  0.0000015279,
  0.0000015635,
  0.0000015999,
  0.0000016372,
  0.0000016753,
  0.0000017144,
  0.0000017543,
  0.0000017951,
  0.000001837,
  0.0000018797,
  0.0000019235,
  0.0000019683,
  0.0000020142,
  0.0000020611,
  0.0000021091,
  0.0000021582,
  0.0000022085,
  0.00000226,
  0.0000023126,
  0.0000023665,
  0.0000024216,
  0.000002478,
  0.0000025357,
  0.0000025948,
  0.0000026552,
  0.0000027171,
  0.0000027804,
  0.0000028451,
  0.0000029114,
  0.0000029792,
  0.0000030486,
  0.0000031196,
  0.0000031923,
  0.0000032666,
  0.0000033427,
  0.0000034206,
  0.0000035003,
  0.0000035818,
  0.0000036652,
  0.0000037506,
  0.000003838,
  0.0000039274,
  0.0000040188,
  0.0000041124,
  0.0000042082,
  0.0000043063,
  0.0000044066,
  0.0000045092,
  0.0000046142,
  0.0000047217,
  0.0000048317,
  0.0000049442,
  0.0000050594,
  0.0000051773,
  0.0000052979,
  0.0000054213,
  0.0000055475,
  0.0000056768,
  0.000005809,
  0.0000059443,
  0.0000060828,
  0.0000062244,
  0.0000063694,
  0.0000065178,
  0.0000066696,
  0.000006825,
  0.0000069839,
  0.0000071466,
  0.0000073131,
  0.0000074834,
  0.0000076577,
  0.0000078361,
  0.0000080186,
  0.0000082054,
  0.0000083965,
  0.0000085921,
  0.0000087922,
  0.000008997,
  0.0000092066,
  0.0000094211,
  0.0000096405,
  0.0000098651,
  0.000010095,
  0.00001033,
  0.000010571,
  0.000010817,
  0.000011069,
  0.000011327,
  0.00001159,
  0.00001186,
  0.000012137,
  0.000012419,
  0.000012709,
  0.000013005,
  0.000013308,
  0.000013618,
  0.000013935,
  0.000014259,
  0.000014592,
  0.000014931,
  0.000015279,
  0.000015635,
  0.000015999,
  0.000016372,
  0.000016753,
  0.000017144,
  0.000017543,
  0.000017951,
  0.00001837,
  0.000018798,
  0.000019235,
  0.000019683,
  0.000020142,
  0.000020611,
  0.000021091,
  0.000021582,
  0.000022085,
  0.0000226,
  0.000023126,
  0.000023665,
  0.000024216,
  0.00002478,
  0.000025357,
  0.000025948,
  0.000026552,
  0.000027171,
  0.000027804,
  0.000028451,
  0.000029114,
  0.000029792,
  0.000030486,
  0.000031196,
  0.000031923,
  0.000032666,
  0.000033427,
  0.000034206,
  0.000035003,
  0.000035818,
  0.000036652,
  0.000037506,
  0.00003838,
  0.000039273,
  0.000040188,
  0.000041124,
  0.000042082,
  0.000043063,
  0.000044066,
  0.000045092,
  0.000046142,
  0.000047217,
  0.000048317,
  0.000049442,
  0.000050594,
  0.000051773,
  0.000052979,
  0.000054213,
  0.000055475,
  0.000056768,
  0.00005809,
  0.000059443,
  0.000060828,
  0.000062244,
  0.000063694,
  0.000065178,
  0.000066696,
  0.00006825,
  0.000069839,
  0.000071466,
  0.000073131,
  0.000074834,
  0.000076577,
  0.000078361,
  0.000080186,
  0.000082054,
  0.000083965,
  0.000085921,
  0.000087922,
  0.00008997,
  0.000092066,
  0.000094211,
  0.000096405,
  0.000098651,
  0.00010095,
  0.0001033,
  0.00010571,
  0.00010817,
  0.00011069,
  0.00011327,
  0.0001159,
  0.0001186,
  0.00012137,
  0.00012419,
  0.00012709,
  0.00013005,
  0.00013308,
  0.00013618,
  0.00013935,
  0.00014259,
  0.00014592,
  0.00014931,
  0.00015279,
  0.00015635,
  0.00015999,
  0.00016372,
  0.00016753,
  0.00017144,
  0.00017543,
  0.00017951,
  0.0001837,
  0.00018798,
  0.00019235,
  0.00019683,
  0.00020142,
  0.00020611,
  0.00021091,
  0.00021582,
  0.00022085,
  0.000226,
  0.00023126,
  0.00023665,
  0.00024216,
  0.0002478,
  0.00025357,
  0.00025948,
  0.00026552,
  0.00027171,
  0.00027804,
  0.00028451,
  0.00029114,
  0.00029792,
  0.00030486,
  0.00031196,
  0.00031923,
  0.00032666,
  0.00033427,
  0.00034206,
  0.00035003,
  0.00035818,
  0.00036652,
  0.00037506,
  0.0003838,
  0.00039274,
  0.00040188,
  0.00041124,
  0.00042082,
  0.00043063,
  0.00044066,
  0.00045092,
  0.00046142,
  0.00047217,
  0.00048317,
  0.00049442,
  0.00050594,
  0.00051773,
  0.00052979,
  0.00054213,
  0.00055475,
  0.00056768,
  0.0005809,
  0.00059443,
  0.00060828,
  0.00062244,
  0.00063694,
  0.00065178,
  0.00066696,
  0.0006825,
  0.00069839,
  0.00071466,
  0.00073131,
  0.00074834,
  0.00076577,
  0.00078361,
  0.00080186,
  0.00082054,
  0.00083965,
  0.00085921,
  0.00087922,
  0.0008997,
  0.00092066,
  0.00094211,
  0.00096405,
  0.00098651,
  0.0010095,
  0.001033,
  0.0010571,
  0.0010817,
  0.0011069,
  0.0011327,
  0.001159,
  0.001186,
  0.0012137,
  0.0012419,
  0.0012709,
  0.0013005,
  0.0013308,
  0.0013618,
  0.0013935,
  0.0014259,
  0.0014592,
  0.0014931,
  0.0015279,
  0.0015635,
  0.0015999,
  0.0016372,
  0.0016753,
  0.0017144,
  0.0017543,
  0.0017951,
  0.001837,
  0.0018798,
  0.0019235,
  0.0019683,
  0.0020142,
  0.0020611,
  0.0021091,
  0.0021582,
  0.0022085,
  0.00226,
  0.0023126,
  0.0023665,
  0.0024216,
  0.002478,
  0.0025357,
  0.0025948,
  0.0026552,
  0.0027171,
  0.0027804,
  0.0028451,
  0.0029114,
  0.0029792,
  0.0030486,
  0.0031196,
  0.0031923,
  0.0032666,
  0.0033427,
  0.0034206,
  0.0035003,
  0.0035818,
  0.0036652,
  0.0037506,
  0.003838,
  0.0039274,
  0.0040188,
  0.0041124,
  0.0042082,
  0.0043063,
  0.0044066,
  0.0045092,
  0.0046142,
  0.0047217,
  0.0048317,
  0.0049442,
  0.0050594,
  0.0051773,
  0.0052979,
  0.0054213,
  0.0055475,
  0.0056768,
  0.005809,
  0.0059443,
  0.0060828,
  0.0062244,
  0.0063694,
  0.0065178,
  0.0066696,
  0.006825,
  0.0069839,
  0.0071466,
  0.0073131,
  0.0074834,
  0.0076577,
  0.0078361,
  0.0080186,
  0.0082054,
  0.0083965,
  0.0085921,
  0.0087922,
  0.0089971,
  0.0092066,
  0.0094211,
  0.0096405,
  0.0098651,
  0.010095,
  0.01033,
  0.010571,
  0.010817,
  0.011069,
  0.011327,
  0.01159,
  0.01186,
  0.012137,
  0.012419,
  0.012709,
  0.013005,
  0.013308,
  0.013618,
  0.013935,
  0.014259,
  0.014592,
  0.014931,
  0.015279,
  0.015635,
  0.015999,
  0.016372,
  0.016753,
  0.017144,
  0.017543,
  0.017951,
  0.01837,
  0.018798,
  0.019235,
  0.019683,
  0.020142,
  0.020611,
  0.021091,
  0.021582,
  0.022085,
  0.0226,
  0.023126,
  0.023665,
  0.024216,
  0.02478,
  0.025357,
  0.025948,
  0.026552,
  0.027171,
  0.027804,
  0.028451,
  0.029114,
  0.029792,
  0.030486,
  0.031196,
  0.031923,
  0.032666,
  0.033427,
  0.034206,
  0.035003,
  0.035818,
  0.036652,
  0.037506,
  0.03838,
  0.039274,
  0.040188,
  0.041124,
  0.042082,
  0.043063,
  0.044066,
  0.045092,
  0.046142,
  0.047217,
  0.048317,
  0.049442,
  0.050594,
  0.051773,
  0.052979,
  0.054213,
  0.055475,
  0.056768,
  0.05809,
  0.059443,
  0.060828,
  0.062244,
  0.063694,
  0.065178,
  0.066696,
  0.06825,
  0.069839,
  0.071466,
  0.073131,
  0.074834,
  0.076577,
  0.078361,
  0.080186,
  0.082054,
  0.083965,
  0.085921,
  0.087922,
  0.08997,
  0.092066,
  0.094211,
  0.096405,
  0.098651,
  0.10095,
  0.1033,
  0.10571,
  0.10817,
  0.11069,
  0.11327,
  0.1159,
  0.1186,
  0.12137,
  0.12419,
  0.12709,
  0.13005,
  0.13308,
  0.13618,
  0.13935,
  0.14259,
  0.14592,
  0.14931,
  0.15279,
  0.15635,
  0.15999,
  0.16372,
  0.16753,
  0.17144,
  0.17543,
  0.17951,
  0.1837,
  0.18798,
  0.19235,
  0.19683,
  0.20142,
  0.20611,
  0.21091,
  0.21582,
  0.22085,
  0.226,
  0.23126,
  0.23665,
  0.24216,
  0.2478,
  0.25357,
  0.25948,
  0.26552,
  0.27171,
  0.27804,
  0.28451,
  0.29114,
  0.29792,
  0.30486,
  0.31196,
  0.31923,
  0.32666,
  0.33427,
  0.34206,
  0.35003,
  0.35818,
  0.36652,
  0.37506,
  0.3838,
  0.39274,
  0.40188,
  0.41124,
  0.42082,
  0.43063,
  0.44066,
  0.45092,
  0.46142,
  0.47217,
  0.48317,
  0.49442,
  0.50594,
  0.51773,
  0.52979,
  0.54213,
  0.55475,
  0.56768,
  0.5809,
  0.59443,
  0.60828,
  0.62244,
  0.63694,
  0.65178,
  0.66696,
  0.6825,
  0.69839,
  0.71466,
  0.73131,
  0.74834,
  0.76577,
  0.78361,
  0.80186,
  0.82054,
  0.83965,
  0.85921,
  0.87923,
  0.89971,
  0.92066,
  0.94211,
  0.96405,
  0.98651,
  1.0095,
  1.033,
  1.0571,
  1.0817,
  1.1069,
  1.1327,
  1.159,
  1.186,
  1.2137,
  1.2419,
  1.2709,
  1.3005,
  1.3308,
  1.3618,
  1.3935,
  1.4259,
  1.4592,
  1.4931,
  1.5279,
  1.5635,
  1.5999,
  1.6372,
  1.6753,
  1.7144,
  1.7543,
  1.7951,
  1.837,
  1.8797,
  1.9235,
  1.9683,
  2.0142,
  2.0611,
  2.1091,
  2.1582,
  2.2085,
  2.26,
  2.3126
}; // weak
_UNKNOWN kHrirI44; // weak
_UNKNOWN kHrirC44; // weak
_UNKNOWN kFilt2d44; // weak
_UNKNOWN kAmbI44; // weak
_UNKNOWN kAmbC44; // weak
_UNKNOWN kDir44; // weak
_UNKNOWN kAmbI44b; // weak
_UNKNOWN kAmbC44b; // weak
_UNKNOWN kDir44b; // weak
_UNKNOWN kVoiceFilter44k; // weak
_UNKNOWN kHrirI48; // weak
_UNKNOWN kHrirC48; // weak
_UNKNOWN kFilt2d48; // weak
_UNKNOWN kAmbI48; // weak
_UNKNOWN kAmbC48; // weak
_UNKNOWN kDir48; // weak
_UNKNOWN kAmbI48b; // weak
_UNKNOWN kAmbC48b; // weak
_UNKNOWN kDir48b; // weak
_UNKNOWN kVoiceFilter48k; // weak
_UNKNOWN kWinGateMusic; // weak
_UNKNOWN kWinGateMovie; // weak
_UNKNOWN kWinGateVoice; // weak
_UNKNOWN kWinGateAuto; // weak
_DWORD dword_2244C[5] = { 5, 3, 4, 2, 0 }; // weak
_DWORD dword_22460[5] = { 4, 2, 3, 5, 0 }; // weak
unsigned int dword_2247C[16] = { 0u, 2u, 2u, 2u, 3u, 3u, 3u, 3u, 2u, 2u, 3u, 3u, 2u, 2u, 3u, 3u }; // weak
unsigned int dword_224BC[15] = { 2u, 2u, 2u, 3u, 3u, 3u, 3u, 2u, 2u, 3u, 3u, 2u, 2u, 3u, 3u }; // weak
_UNKNOWN unk_22620; // weak
_UNKNOWN unk_22630; // weak
int dword_23A0C[6] = { -60275, -62328, -62328, -58836, -60744, -60265 }; // weak
_QWORD qword_23A38[13] = { -8LL, -8LL, -2LL, -4LL, -8LL, -8LL, -8LL, -8LL, -8LL, -8LL, -2LL, -4LL, -8LL }; // weak
int dword_23E2C[98] =
{
  -58330,
  -55871,
  -59780,
  -59600,
  -60395,
  -58587,
  -61478,
  -60794,
  -62402,
  -62703,
  -57612,
  -56269,
  -56993,
  -63072,
  -61475,
  -57171,
  -55868,
  -57455,
  -62869,
  -56439,
  -62399,
  -63068,
  -62700,
  -63349,
  -55864,
  -56202,
  -61843,
  -56198,
  -60392,
  -59597,
  -57609,
  -56307,
  -56266,
  -58330,
  -55871,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -62395,
  -58371,
  -55064,
  -64941,
  -63564,
  -56194,
  -62051,
  -61471,
  -56989,
  -59593,
  -60564,
  -61468,
  -61839,
  -62865,
  -57982,
  -59590,
  -60561,
  -60557,
  -54780,
  -57740,
  -60388,
  -61835,
  -58099,
  -57736,
  -57451,
  -62048,
  -58584,
  -62696,
  -54776,
  -62044,
  -56435,
  -57732,
  -58368
}; // weak
_UNKNOWN loc_638A8; // weak
_UNKNOWN *off_6ED00 = &off_6ED00; // weak
char *off_6ED08[14] =
{
  "kSuccess",
  "kNullException",
  "kInvalidProfileKey",
  "kNotInitialized",
  "kNotSupportChannels",
  "kNotSupportSampleRate",
  "kNotSupportSamplesPerBlock",
  "kNotSupportFormat",
  "kNotSupportResampler",
  "kError",
  "kNotSupportParams",
  "kUnlicensedFeature",
  "kError",
  "kInvalidMetadata"
}; // weak
void (__fastcall *off_6ED88[2])(std::exception *__hidden this) = { &std::exception::~exception, &std::bad_alloc::~bad_alloc }; // weak
void (__fastcall *off_6EDB0[2])(std::exception *__hidden this) =
{
  &std::exception::~exception,
  &std::bad_array_new_length::~bad_array_new_length
}; // weak
__int64 *`typeinfo for'std::exception = &off_6F840; // weak
__int64 *`typeinfo for'std::bad_alloc = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__shim_type_info = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__class_type_info = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__pbase_type_info = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_type_info = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__function_type_info = &off_6F890; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info = &off_6F890; // weak
void (__fastcall *off_6FA08[2])(std::bad_cast *__hidden this) = { &std::bad_cast::~bad_cast, &std::bad_cast::~bad_cast }; // weak
void (__fastcall *off_6FA30[2])(std::bad_typeid *__hidden this) = { &std::bad_typeid::~bad_typeid, &std::bad_typeid::~bad_typeid }; // weak
__int64 (__fastcall *off_6FAB8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_506D8,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_507D8,
  &off_6F840
}; // weak
__int64 (__fastcall *off_6FB38[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_507E0,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5095C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_6FBA8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_50BB4,
  &sub_507C0,
  &sub_50C4C,
  &sub_5B31C,
  &sub_50C5C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_6FC18[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_50C64,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_50D90,
  &off_6F890
}; // weak
__int64 (__fastcall *off_6FC88[10])() =
{
  &sub_523A0,
  &sub_52438,
  &sub_524D0,
  &sub_52568,
  &sub_525CC,
  &sub_5262C,
  &sub_507C8,
  &sub_5B31C,
  &sub_5268C,
  &off_6F890
}; // weak
_UNKNOWN unk_6FCE8; // weak
__int64 (__fastcall *off_700D8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_566AC,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_56988,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70148[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_56BCC,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_56C7C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_701B8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_56C84,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_56D34,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70228[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_56D3C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_56E48,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70298[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_56E50,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_56F14,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70308[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_56F1C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_57454,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70378[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5745C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_57640,
  &off_6F890
}; // weak
__int64 (__fastcall *off_703E8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_57648,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5785C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70458[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_57864,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_57B34,
  &off_6F890
}; // weak
__int64 (__fastcall *off_704C8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_57B3C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_57C60,
  &off_6F890
}; // weak
__int64 (__fastcall *off_705A8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_57EA0,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_580C4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70618[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_58CD0,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_58FA8,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70688[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_58FB0,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5906C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70848[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_598D4,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_599E4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_708B8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_59F4C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A09C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70928[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A20C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A418,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70998[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A420,
  &sub_5A4B0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A518,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70A08[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A520,
  &sub_5A5F0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A668,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70A78[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A670,
  &sub_5A860,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A8C8,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70AE8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A8D0,
  &sub_5A968,
  &sub_507C8,
  &sub_5B31C,
  &sub_5A97C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70B58[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5A984,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5AAE4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70BC8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5AE60,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5AF60,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70C38[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5AF68,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5B180,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70CA8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5B22C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5B324,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70D88[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5B890,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5BA50,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70DF8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5BA58,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5BCB4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70E68[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5BCBC,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5BF2C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_70ED8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5BF34,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5C138,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71028[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5C70C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5C88C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71098[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5C894,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5C9A0,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71108[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5C9A8,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5CA80,
  &off_6F890
}; // weak
__int64 (__fastcall *off_711E8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5D424,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5D4B4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71258[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5D4BC,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5D598,
  &off_6F890
}; // weak
__int64 (__fastcall *off_712C8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5D5A0,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5D680,
  &off_6F890
}; // weak
__int64 (__fastcall *off_713A8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5D8FC,
  &sub_507C0,
  &sub_5DB00,
  &sub_5B31C,
  &sub_5DC1C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71430[9])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5DC24,
  &sub_507C0,
  &sub_5DE70,
  &sub_5B31C,
  &sub_5DEA0
}; // weak
__int64 (__fastcall *off_71488[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5DEA8,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5E00C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_714F8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5E014,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5E1F0,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71568[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5E2BC,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5E3C4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_715D8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5E3CC,
  &sub_507C0,
  &sub_5E4D4,
  &sub_5B31C,
  &sub_5E4E8,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71648[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5E4F0,
  &sub_507C0,
  &sub_5E5FC,
  &sub_5B31C,
  &sub_5E610,
  &off_6F890
}; // weak
__int64 (__fastcall *off_716B8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5E824,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5E930,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71728[10])() =
{
  &sub_5E938,
  &sub_5E9A4,
  &sub_5EA10,
  &sub_5EA7C,
  &sub_5EAC8,
  &sub_5EB14,
  &sub_507C8,
  &sub_5B31C,
  &sub_5EB60,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71798[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5EB68,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5ED2C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71808[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5ED34,
  &sub_507C0,
  &sub_5EDE8,
  &sub_5B31C,
  &sub_5EDFC,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71878[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5EE04,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5EF10,
  &off_6F890
}; // weak
__int64 (__fastcall *off_718E8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5EF18,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5F0DC,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71958[10])() =
{
  &sub_5F0E4,
  &sub_506B8,
  &sub_5F0F0,
  &sub_506D0,
  &sub_5F0FC,
  &sub_5F210,
  &sub_507C8,
  &sub_5B31C,
  &sub_5F68C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_719C8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_5F694,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_5F810,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71A38[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_60D08,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_60E5C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71AA8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_60E64,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_610A0,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71B18[10])() =
{
  &sub_610A8,
  &sub_506B8,
  &sub_610B4,
  &sub_506D0,
  &sub_610C0,
  &sub_6114C,
  &sub_507C8,
  &sub_5B31C,
  &sub_61604,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71B88[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_6160C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_61788,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71BF8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_61790,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_61908,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71C68[10])() =
{
  &sub_61910,
  &sub_61940,
  &sub_61970,
  &sub_506D0,
  &sub_619A0,
  &sub_61B28,
  &sub_507C8,
  &sub_5B31C,
  &sub_61B3C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71CD8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_61B44,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_61C1C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71D48[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_61C24,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_61E00,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71DB8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_61F58,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_6207C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71E28[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_62084,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_621E4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71E98[10])() =
{
  &sub_62294,
  &sub_622A0,
  &sub_506C4,
  &sub_506D0,
  &sub_622AC,
  &sub_622C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_62470,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71F08[10])() =
{
  &sub_62530,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_62560,
  &sub_62734,
  &sub_507C8,
  &sub_5B31C,
  &sub_62820,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71F78[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_62828,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_62964,
  &off_6F890
}; // weak
__int64 (__fastcall *off_71FE8[10])() =
{
  &sub_6296C,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_6299C,
  &sub_62CCC,
  &sub_507C8,
  &sub_5B31C,
  &sub_62E1C,
  &off_6F890
}; // weak
__int64 (__fastcall *off_72058[10])() =
{
  &sub_62E24,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_62E54,
  &sub_63094,
  &sub_507C8,
  &sub_5B31C,
  &sub_631D4,
  &off_6F890
}; // weak
__int64 (__fastcall *off_720C8[10])() =
{
  &sub_506AC,
  &sub_506B8,
  &sub_506C4,
  &sub_506D0,
  &sub_6337C,
  &sub_507C0,
  &sub_507C8,
  &sub_5B31C,
  &sub_63428,
  &off_6F890
}; // weak
__int64 (__fastcall *off_72138[8])() =
{
  &sub_6674C,
  &sub_66754,
  &sub_6675C,
  &sub_6679C,
  &sub_668BC,
  &sub_669DC,
  &sub_669F0,
  &sub_66A00
}; // weak
_UNKNOWN ELEQ_EQ44100; // weak
_UNKNOWN ELEQ_EQ48000; // weak
_UNKNOWN kSpatialUpmixNumeratorCoeff48k; // weak
_UNKNOWN kSpatialUpmixDenominatorCoeff48k; // weak
_UNKNOWN kSpatialUpmixNumeratorCoeff44k; // weak
_UNKNOWN kSpatialUpmixDenominatorCoeff44k; // weak
int kSpatialUpmixDelayFilterGain = 1061158912; // weak
int dword_7887C = 1061158912; // weak
int dword_78880 = 1061158912; // weak
int dword_78884 = 1061158912; // weak
int kSpatialUpmixAllpassFilterGain = 1061997773; // weak
int dword_7888C = 1036831949; // weak
__int128 kSpatialUpmixLeftDelay = 0x147000001F30000017B000001C9LL; // weak
__int128 kSpatialUpmixRightDelay = 0x185000001BB0000015B000001EBLL; // weak
int kSpatialUpmixLeftAllpassDelay = 79; // weak
int dword_788B4 = 929; // weak
int kSpatialUpmixRightAllpassDelay = 59; // weak
int dword_788BC = 983; // weak
int kSpatialUpmixNumeratorCoeffReverb48k = 1043732615; // weak
int kSpatialUpmixDenominatorCoeffReverb48k = 1065353216; // weak
int kSpatialUpmixNumeratorCoeffReverb44k = 1043732615; // weak
int kSpatialUpmixDenominatorCoeffReverb44k = 1065353216; // weak
__int64 (__fastcall *_cxa_terminate_handler)() = &sub_4A8C4; // weak
void (__fastcall __noreturn *_cxa_unexpected_handler)() = &sub_4AA14; // weak
char *off_78908 = "uncaught"; // weak
size_t qword_78910[4] = { 16uLL, 8uLL, 0uLL, 0uLL }; // weak
_UNKNOWN *off_78930 = &unk_78DA0; // weak
_UNKNOWN *off_78938 = &unk_78DA0; // weak
_UNKNOWN *off_78940 = &_cxa_finalize; // weak
struct __jmp_buf_tag _excBuf; // weak
_UNKNOWN lock_; // weak
__int128 xmmword_78A78; // weak
__int128 xmmword_78A88; // weak
__int128 xmmword_78A98; // weak
int dword_78AA8; // weak
int dword_78AAC; // weak
int dword_78AB0; // weak
char byte_78AB4; // weak
int iir_wrapper_coeffs; // weak
int dword_78ABC; // weak
int dword_78AC0; // weak
int dword_78AC4; // weak
int dword_78AC8; // weak
int dword_78ACC; // weak
__int64 _cxa_new_handler; // weak
__int64 qword_78AE0; // weak
pthread_mutex_t stru_78AE8; // weak
char byte_78B10[12]; // weak
int dword_78B1C; // weak
char byte_78D10; // weak
int dword_78D14; // weak
pthread_once_t dword_78D18[2]; // weak
__int64 qword_78D20; // weak
pthread_mutex_t stru_78D28; // weak
char byte_78D50; // weak
__int64 qword_78D58; // weak
_UNKNOWN unk_78D60; // weak
pthread_rwlock_t stru_78D64; // weak
_UNKNOWN unk_78DA0; // weak
// extern _UNKNOWN _sF; weak


//----- (000000000002E9D0) ----------------------------------------------------
__int64 sub_2E9D0()
{
  return __cxa_finalize(&off_6ED00);
}
// 6ED00: using guessed type _UNKNOWN *off_6ED00;

//----- (000000000002E9E0) ----------------------------------------------------
void sub_2E9E0()
{
  ;
}

//----- (000000000002E9E8) ----------------------------------------------------
__int64 sub_2E9E8()
{
  return sub_65510();
}

//----- (000000000002E9F0) ----------------------------------------------------
__int64 (*__fastcall sub_2E9F0(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (000000000002EA04) ----------------------------------------------------
__int64 __fastcall sub_2EA04(void *a1)
{
  return __cxa_atexit((void (*)(void *))sub_2E9F0, a1, &off_6ED00);
}
// 6ED00: using guessed type _UNKNOWN *off_6ED00;

//----- (000000000002EA20) ----------------------------------------------------
__int64 __fastcall sub_2EA20(__int64 a1, __int64 a2, __int64 a3)
{
  return __register_atfork(a1, a2, a3, &off_6ED00);
}
// 69B40: using guessed type __int64 __fastcall __register_atfork(_QWORD, _QWORD, _QWORD, _QWORD);
// 6ED00: using guessed type _UNKNOWN *off_6ED00;

//----- (000000000002EA34) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getVersion(__int64 *a1)
{
  const char **v2; // x19
  __int64 v3; // x8
  const char *v4; // x1
  __int64 v5; // x20

  v2 = (const char **)operator new(8u);
  *v2 = 0;
  if ( (unsigned int)GSMO_GET_VERSION(v2) == -1 )
  {
    v3 = *a1;
    v4 = "n/a";
  }
  else
  {
    v3 = *a1;
    v4 = *v2;
  }
  v5 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v3 + 1336))(a1, v4);
  operator delete(v2);
  return v5;
}

//----- (000000000002EAA0) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1create(__int64 a1, __int64 a2)
{
  unsigned int v4; // w20
  __int64 v5; // x0
  __int64 v6; // x0
  const char *v7; // x20
  __int64 v8; // x21
  __int64 v9; // x0
  _QWORD v11[2]; // [xsp+0h] [xbp-10h] BYREF

  v11[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11[0] = 0;
  v4 = GSMO_CREATE(v11);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 248LL))(a1, a2);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v5,
         "instance_",
         "J");
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 880LL))(a1, a2, v6, v11[0]);
  if ( v4 > 0xD )
    v7 = "kError";
  else
    v7 = off_6ED08[v4];
  v8 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
         a1,
         "com/gaudiolab/sol/android/ErrorCode");
  v9 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
         a1,
         v8,
         v7,
         "I");
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v8, v9);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000002EBC8) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1destroy(__int64 *a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x0
  unsigned int v6; // w0
  __int64 v7; // x8
  unsigned int v8; // w21
  __int64 v9; // x0
  __int64 v10; // x0
  const char *v11; // x20
  __int64 v12; // x21
  __int64 v13; // x0
  void *v15[2]; // [xsp+0h] [xbp-10h] BYREF

  v15[1] = *(void **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 248))(a1);
  v5 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v4, "instance_", "J");
  v15[0] = (void *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v5);
  if ( v15[0] )
  {
    v6 = GSMO_DESTROY(v15);
    v7 = *a1;
    v8 = v6;
    v15[0] = 0;
    v9 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v7 + 248))(a1, a2);
    v10 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
            a1,
            v9,
            "instance_",
            "J");
    (*(void (__fastcall **)(__int64 *, __int64, __int64, void *))(*a1 + 880))(a1, a2, v10, v15[0]);
    if ( v8 > 0xD )
      v11 = "kError";
    else
      v11 = off_6ED08[v8];
  }
  else
  {
    v11 = "kSuccess";
  }
  v12 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
  v13 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v12, v11, "I");
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v12, v13);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000002ED4C) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1setup(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // x8
  __int64 v7; // x20
  __int64 v8; // x0
  __int64 v9; // x0
  int v10; // w23
  __int64 v11; // x0
  __int64 v12; // x0
  int v13; // w24
  __int64 v14; // x0
  __int64 v15; // x0
  int v16; // w25
  __int64 v17; // x0
  __int64 v18; // x0
  int v19; // w26
  __int64 v20; // x0
  __int64 v21; // x0
  int v22; // w0
  __int64 v23; // x8
  __int64 (__fastcall *v24)(__int64 *, __int64); // x8
  __int64 v25; // x0
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x0
  int v29; // w24
  __int64 v30; // x0
  __int64 v31; // x0
  int v32; // w25
  __int64 v33; // x0
  __int64 v34; // x0
  int v35; // w26
  __int64 v36; // x0
  __int64 v37; // x0
  float v38; // s8
  __int64 v39; // x0
  __int64 v40; // x0
  float v41; // s9
  __int64 v42; // x0
  __int64 v43; // x0
  __int64 v44; // x0
  __int64 v45; // x0
  float v46; // s10
  __int64 v47; // x0
  __int64 v48; // x0
  char v49; // w27
  __int64 v50; // x0
  __int64 v51; // x0
  float v52; // s11
  __int64 v53; // x0
  __int64 v54; // x0
  float v55; // s12
  __int64 v56; // x0
  __int64 v57; // x0
  __int64 v58; // x22
  __int64 v59; // x0
  __int64 v60; // x0
  float v61; // s0
  __int64 v62; // x0
  __int64 v63; // x0
  __int64 v64; // x0
  __int64 v65; // x20
  __int64 v66; // x0
  __int64 (__fastcall *v67)(__int64 *, __int64, __int64); // x3
  __int64 v68; // x8
  __int64 v69; // x0
  __int64 v70; // x0
  int v71; // w0
  size_t v72; // x20
  unsigned int v73; // w23
  void *v74; // x0
  __int64 v75; // x8
  void *v76; // x24
  __int64 v77; // x0
  __int64 v78; // x0
  __int64 v79; // x0
  __int64 v80; // x21
  _BYTE *v81; // x20
  unsigned __int64 v82; // x8
  __int64 v83; // x0
  __int64 v84; // x0
  unsigned int *v85; // x0
  unsigned int v86; // w21
  const char *v87; // x20
  __int64 v89; // x21
  __int64 v90; // x0
  _BYTE v92[4]; // [xsp+18h] [xbp-A8h] BYREF
  int v93; // [xsp+1Ch] [xbp-A4h]
  int v94; // [xsp+20h] [xbp-A0h]
  int v95; // [xsp+24h] [xbp-9Ch]
  float v96; // [xsp+28h] [xbp-98h]
  float v97; // [xsp+2Ch] [xbp-94h]
  int v98; // [xsp+30h] [xbp-90h]
  __int64 v99; // [xsp+38h] [xbp-88h]
  float v100; // [xsp+40h] [xbp-80h]
  char v101; // [xsp+44h] [xbp-7Ch]
  int v102; // [xsp+48h] [xbp-78h]
  float v103; // [xsp+4Ch] [xbp-74h]
  float v104; // [xsp+50h] [xbp-70h]
  float v105; // [xsp+54h] [xbp-6Ch]
  void *v106; // [xsp+58h] [xbp-68h]
  unsigned int v107; // [xsp+60h] [xbp-60h]
  _DWORD v108[6]; // [xsp+68h] [xbp-58h] BYREF
  __int64 v109; // [xsp+80h] [xbp-40h]

  v109 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v5 = *a1;
  if ( !a3 || !a4 )
  {
    v65 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v5 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v66 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v65,
            "kNullException",
            "I");
    v67 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200);
    return v67(a1, v65, v66);
  }
  v7 = a3;
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v5 + 248))(a1, a3);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
         a1,
         v8,
         "numInputChannels",
         "I");
  v10 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, v7, v9);
  v11 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, v7);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v11,
          "numOutputChannels",
          "I");
  v13 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, v7, v12);
  v14 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, v7);
  v15 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v14,
          "sampleRate",
          "I");
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, v7, v15);
  v17 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, v7);
  v18 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v17,
          "samplesPerBlock",
          "I");
  v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, v7, v18);
  v20 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, v7);
  v21 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v20, "format", "I");
  v22 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, v7, v21);
  v23 = *a1;
  v108[4] = v22;
  v108[0] = v10;
  v108[1] = v13;
  v24 = *(__int64 (__fastcall **)(__int64 *, __int64))(v23 + 248);
  v108[2] = v16;
  v108[3] = v19;
  v25 = v24(a1, a4);
  v26 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v25,
          "isEnable",
          "Z");
  LOBYTE(v10) = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 768))(a1, a4, v26);
  v27 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v28 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v27,
          "preferenceFeatures",
          "I");
  v29 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v28);
  v30 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v31 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v30, "lscType", "I");
  v32 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v31);
  v33 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v34 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v33, "lcoType", "I");
  v35 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v34);
  v36 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v37 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v36,
          "targetLoudness",
          "F");
  v38 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v37);
  v39 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v40 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v39,
          "environmentOffset",
          "F");
  v41 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v40);
  v42 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v43 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v42,
          "equalizerBandCount",
          "I");
  LODWORD(v7) = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v43);
  v44 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v45 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v44,
          "equalizerGlobalGainDb",
          "F");
  v46 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v45);
  v47 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v48 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v47,
          "equalizerLoudnessEnabled",
          "Z");
  v49 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 768))(a1, a4, v48);
  v50 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v51 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v50,
          "eleqVolume",
          "F");
  v52 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v51);
  v53 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v54 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v53,
          "volumeGain",
          "F");
  v55 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v54);
  v56 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v57 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v56,
          "upmixGenre",
          "I");
  v58 = (*(unsigned int (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v57);
  v59 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
  v60 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v59,
          "reverbIntensity",
          "F");
  v61 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a4, v60);
  v92[0] = v10;
  v93 = v29;
  v94 = v32;
  v95 = v35;
  v96 = v38;
  v97 = v41;
  v98 = v7;
  v100 = v46;
  v101 = v49;
  v104 = v52;
  v105 = v55;
  v102 = v58;
  v103 = v61;
  v106 = 0;
  if ( (_DWORD)v7 )
  {
    v62 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a4);
    v63 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
            a1,
            v62,
            "equalizerBandGainDb",
            "[F");
    v64 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 760))(a1, a4, v63);
    v58 = v64;
    if ( v64 )
      v64 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1512))(a1, v64, 0);
  }
  else
  {
    v64 = 0;
  }
  v68 = *a1;
  v99 = v64;
  v69 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v68 + 248))(a1, a4);
  v70 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v69,
          "metadataLength",
          "I");
  v71 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a4, v70);
  v107 = v71;
  if ( v71 < 1 )
  {
    v81 = 0;
  }
  else
  {
    v72 = (unsigned int)v71;
    v73 = v71;
    v74 = operator new[]((unsigned int)v71);
    v75 = *a1;
    v76 = v74;
    v106 = v74;
    v77 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v75 + 248))(a1, a4);
    v78 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
            a1,
            v77,
            "metadata",
            "[B");
    v79 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 760))(a1, a4, v78);
    if ( v79 )
    {
      v80 = v79;
      v81 = operator new[](v72);
      (*(void (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD, _BYTE *))(*a1 + 1600))(a1, v80, 0, v73, v81);
      v82 = 0;
      do
      {
        *((_BYTE *)v106 + v82) = v81[v82];
        ++v82;
      }
      while ( v82 < v107 );
    }
    else
    {
      operator delete[](v76);
      v81 = 0;
      v106 = 0;
    }
  }
  v83 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a2);
  v84 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v83,
          "instance_",
          "J");
  v85 = (unsigned int *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v84);
  if ( !v85 )
  {
    v65 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v66 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v65,
            "kNullException",
            "I");
    v67 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200);
    return v67(a1, v65, v66);
  }
  v86 = GSMO_SETUP(v85, v108, (__int64)v92);
  if ( v81 )
    operator delete[](v81);
  if ( v106 )
  {
    operator delete[](v106);
    v106 = 0;
  }
  if ( v99 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 1576))(a1, v58, v99, 2);
  if ( v86 > 0xD )
    v87 = "kError";
  else
    v87 = off_6ED08[v86];
  v89 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
  v90 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v89, v87, "I");
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v89, v90);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000002F774) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1update(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // x8
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x0
  __int64 v10; // x0
  int v11; // w23
  __int64 v12; // x0
  __int64 v13; // x0
  int v14; // w25
  __int64 v15; // x0
  __int64 v16; // x0
  int v17; // w26
  __int64 v18; // x0
  __int64 v19; // x0
  float v20; // s8
  __int64 v21; // x0
  __int64 v22; // x0
  float v23; // s9
  __int64 v24; // x0
  __int64 v25; // x0
  __int64 v26; // x22
  __int64 v27; // x0
  __int64 v28; // x0
  float v29; // s10
  __int64 v30; // x0
  __int64 v31; // x0
  char v32; // w27
  __int64 v33; // x0
  __int64 v34; // x0
  float v35; // s11
  __int64 v36; // x0
  __int64 v37; // x0
  float v38; // s12
  __int64 v39; // x0
  __int64 v40; // x0
  int v41; // w24
  __int64 v42; // x0
  __int64 v43; // x0
  float v44; // s0
  __int64 v45; // x0
  __int64 v46; // x0
  __int64 v47; // x0
  __int64 v48; // x20
  __int64 v49; // x0
  __int64 (__fastcall *v50)(__int64 *, __int64, __int64); // x3
  __int64 v51; // x8
  __int64 v52; // x0
  __int64 v53; // x0
  int v54; // w0
  size_t v55; // x24
  unsigned int v56; // w23
  void *v57; // x0
  __int64 v58; // x8
  void *v59; // x25
  __int64 v60; // x0
  __int64 v61; // x0
  __int64 v62; // x0
  __int64 v63; // x26
  _BYTE *v64; // x21
  unsigned __int64 v65; // x8
  __int64 v66; // x0
  __int64 v67; // x0
  __int64 v68; // x0
  unsigned int v69; // w20
  const char *v70; // x20
  __int64 v72; // x21
  __int64 v73; // x0
  char v74; // [xsp+Ch] [xbp-94h]
  _BYTE v75[4]; // [xsp+18h] [xbp-88h] BYREF
  int v76; // [xsp+1Ch] [xbp-84h]
  int v77; // [xsp+20h] [xbp-80h]
  int v78; // [xsp+24h] [xbp-7Ch]
  float v79; // [xsp+28h] [xbp-78h]
  float v80; // [xsp+2Ch] [xbp-74h]
  int v81; // [xsp+30h] [xbp-70h]
  __int64 v82; // [xsp+38h] [xbp-68h]
  float v83; // [xsp+40h] [xbp-60h]
  char v84; // [xsp+44h] [xbp-5Ch]
  int v85; // [xsp+48h] [xbp-58h]
  float v86; // [xsp+4Ch] [xbp-54h]
  float v87; // [xsp+50h] [xbp-50h]
  float v88; // [xsp+54h] [xbp-4Ch]
  void *v89; // [xsp+58h] [xbp-48h]
  unsigned int v90; // [xsp+60h] [xbp-40h]
  __int64 v91; // [xsp+68h] [xbp-38h]

  v91 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = *a1;
  if ( !a3 )
  {
    v48 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v4 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v49 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v48,
            "kNullException",
            "I");
    v50 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200);
    return v50(a1, v48, v49);
  }
  v7 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v4 + 248))(a1, a3);
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v7, "isEnable", "Z");
  v74 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 768))(a1, a3, v8);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v10 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v9,
          "preferenceFeatures",
          "I");
  v11 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v10);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v13 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v12, "lscType", "I");
  v14 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v13);
  v15 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v15, "lcoType", "I");
  v17 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v16);
  v18 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v18,
          "targetLoudness",
          "F");
  v20 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v19);
  v21 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v22 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v21,
          "environmentOffset",
          "F");
  v23 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v22);
  v24 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v25 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v24,
          "equalizerBandCount",
          "I");
  v26 = (*(unsigned int (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v25);
  v27 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v28 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v27,
          "equalizerGlobalGainDb",
          "F");
  v29 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v28);
  v30 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v31 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v30,
          "equalizerLoudnessEnabled",
          "Z");
  v32 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 768))(a1, a3, v31);
  v33 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v34 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v33,
          "eleqVolume",
          "F");
  v35 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v34);
  v36 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v37 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v36,
          "volumeGain",
          "F");
  v38 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v37);
  v39 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v40 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v39,
          "upmixGenre",
          "I");
  v41 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v40);
  v42 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
  v43 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v42,
          "reverbIntensity",
          "F");
  v44 = (*(float (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 816))(a1, a3, v43);
  v76 = v11;
  v77 = v14;
  v78 = v17;
  v79 = v20;
  v80 = v23;
  v75[0] = v74;
  v81 = v26;
  v83 = v29;
  v84 = v32;
  v87 = v35;
  v88 = v38;
  v85 = v41;
  v86 = v44;
  v89 = 0;
  if ( (_DWORD)v26 )
  {
    v45 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a3);
    v46 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
            a1,
            v45,
            "equalizerBandGainDb",
            "[F");
    v47 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 760))(a1, a3, v46);
    v26 = v47;
    if ( v47 )
      v47 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1512))(a1, v47, 0);
  }
  else
  {
    v47 = 0;
  }
  v51 = *a1;
  v82 = v47;
  v52 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v51 + 248))(a1, a3);
  v53 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v52,
          "metadataLength",
          "I");
  v54 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 800))(a1, a3, v53);
  v90 = v54;
  if ( v54 < 1 )
  {
    v64 = 0;
  }
  else
  {
    v55 = (unsigned int)v54;
    v56 = v54;
    v57 = operator new[]((unsigned int)v54);
    v58 = *a1;
    v59 = v57;
    v89 = v57;
    v60 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v58 + 248))(a1, a3);
    v61 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
            a1,
            v60,
            "metadata",
            "[B");
    v62 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 760))(a1, a3, v61);
    if ( v62 )
    {
      v63 = v62;
      v64 = operator new[](v55);
      (*(void (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD, _BYTE *))(*a1 + 1600))(a1, v63, 0, v56, v64);
      v65 = 0;
      do
      {
        *((_BYTE *)v89 + v65) = v64[v65];
        ++v65;
      }
      while ( v65 < v90 );
    }
    else
    {
      operator delete[](v59);
      v64 = 0;
      v89 = 0;
    }
  }
  v66 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 248))(a1, a2);
  v67 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v66,
          "instance_",
          "J");
  v68 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v67);
  if ( !v68 )
  {
    v48 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v49 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v48,
            "kNullException",
            "I");
    v50 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200);
    return v50(a1, v48, v49);
  }
  v69 = GSMO_UPDATE(v68, (__int64)v75);
  if ( v64 )
    operator delete[](v64);
  if ( v89 )
  {
    operator delete[](v89);
    v89 = 0;
  }
  if ( v82 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64))(*a1 + 1576))(a1, v26, v82, 2);
  if ( v69 > 0xD )
    v70 = "kError";
  else
    v70 = off_6ED08[v69];
  v72 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
  v73 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v72, v70, "I");
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v72, v73);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000002FFFC) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_flush(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x0
  unsigned int v7; // w0
  const char *v8; // x20
  __int64 v9; // x20
  __int64 v10; // x2
  __int64 v12; // x21
  __int64 v13; // x2

  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v4,
         "instance_",
         "J");
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v5);
  if ( v6 )
  {
    v7 = GSMO_FLUSH(v6);
    if ( v7 > 0xD )
      v8 = "kError";
    else
      v8 = off_6ED08[v7];
    v12 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
            a1,
            "com/gaudiolab/sol/android/ErrorCode");
    v13 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v12,
            v8,
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v12, v13);
  }
  else
  {
    v9 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
           a1,
           "com/gaudiolab/sol/android/ErrorCode");
    v10 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v9,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v9, v10);
  }
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000003013C) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_reset(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x0
  unsigned int v7; // w0
  const char *v8; // x20
  __int64 v9; // x20
  __int64 v10; // x2
  __int64 v12; // x21
  __int64 v13; // x2

  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v4,
         "instance_",
         "J");
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v5);
  if ( v6 )
  {
    v7 = GSMO_RESET(v6);
    if ( v7 > 0xD )
      v8 = "kError";
    else
      v8 = off_6ED08[v7];
    v12 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
            a1,
            "com/gaudiolab/sol/android/ErrorCode");
    v13 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v12,
            v8,
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v12, v13);
  }
  else
  {
    v9 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
           a1,
           "com/gaudiolab/sol/android/ErrorCode");
    v10 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v9,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v9, v10);
  }
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000003027C) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_process___3S_3SI(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned int a5)
{
  __int64 v6; // x8
  __int64 v11; // x23
  __int64 v12; // x0
  __int64 v13; // x8
  int16x4_t *v14; // x24
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned int *v17; // x0
  unsigned int v18; // w22
  const char *v19; // x20
  __int64 v20; // x20
  __int64 v21; // x0
  __int64 v23; // x21
  __int64 v24; // x0
  unsigned int v25; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v26; // [xsp+8h] [xbp-8h]

  v26 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = *a1;
  if ( !a3 || !a4 )
    goto LABEL_7;
  v11 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v6 + 1488))(a1, a3, 0);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1488))(a1, a4, 0);
  v13 = *a1;
  v14 = (int16x4_t *)v12;
  v25 = 0;
  v15 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v13 + 248))(a1, a2);
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v15,
          "instance_",
          "J");
  v17 = (unsigned int *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v16);
  if ( !v17 )
  {
    v6 = *a1;
LABEL_7:
    v20 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v6 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v21 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v20,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v20, v21);
  }
  v18 = GSMO_PROCESS(v17, v11, v14, a5, &v25);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1552))(a1, a3, v11, 0);
  (*(void (__fastcall **)(__int64 *, __int64, int16x4_t *, _QWORD))(*a1 + 1552))(a1, a4, v14, 0);
  if ( v18 > 0xD )
    v19 = "kError";
  else
    v19 = off_6ED08[v18];
  v23 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
  v24 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v23, v19, "I");
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v23, v24);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (00000000000304C4) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_process___3F_3FI(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned int a5)
{
  __int64 v6; // x8
  __int64 v11; // x23
  __int64 v12; // x0
  __int64 v13; // x8
  int16x4_t *v14; // x24
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned int *v17; // x0
  unsigned int v18; // w22
  const char *v19; // x20
  __int64 v20; // x20
  __int64 v21; // x0
  __int64 v23; // x21
  __int64 v24; // x0
  unsigned int v25; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v26; // [xsp+8h] [xbp-8h]

  v26 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = *a1;
  if ( !a3 || !a4 )
    goto LABEL_7;
  v11 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v6 + 1512))(a1, a3, 0);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1512))(a1, a4, 0);
  v13 = *a1;
  v14 = (int16x4_t *)v12;
  v25 = 0;
  v15 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v13 + 248))(a1, a2);
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(
          a1,
          v15,
          "instance_",
          "J");
  v17 = (unsigned int *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v16);
  if ( !v17 )
  {
    v6 = *a1;
LABEL_7:
    v20 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v6 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v21 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v20,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v20, v21);
  }
  v18 = GSMO_PROCESS(v17, v11, v14, a5, &v25);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1576))(a1, a3, v11, 0);
  (*(void (__fastcall **)(__int64 *, __int64, int16x4_t *, _QWORD))(*a1 + 1576))(a1, a4, v14, 0);
  if ( v18 > 0xD )
    v19 = "kError";
  else
    v19 = off_6ED08[v18];
  v23 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
  v24 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v23, v19, "I");
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v23, v24);
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (000000000003070C) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getBooleanParameter(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x20
  char *v9; // x22
  float v11; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v12; // [xsp+8h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v6,
         "instance_",
         "J");
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v7);
  v9 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  LOBYTE(v11) = 0;
  GSMO_GET_PARAMETER(v8, v9, &v11);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, a3, v9);
  return LOBYTE(v11);
}

//----- (0000000000030800) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getIntParameter(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x20
  char *v9; // x22
  unsigned int v11; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v12; // [xsp+8h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v6,
         "instance_",
         "J");
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v7);
  v9 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  v11 = 0;
  GSMO_GET_PARAMETER(v8, v9, (float *)&v11);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, a3, v9);
  return v11;
}

//----- (00000000000308F4) ----------------------------------------------------
float __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getFloatParameter(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x20
  char *v9; // x22
  float v11; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v12; // [xsp+8h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v6,
         "instance_",
         "J");
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v7);
  v9 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  v11 = 0.0;
  GSMO_GET_PARAMETER(v8, v9, &v11);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, a3, v9);
  return v11;
}

//----- (00000000000309E8) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2Z(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        char a4)
{
  __int64 v7; // x8
  __int64 v8; // x0
  __int64 v9; // x0
  _BYTE *v10; // x21
  char *v11; // x22
  int v13; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v14; // [xsp+8h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  LOBYTE(v13) = a4;
  v8 = (*(__int64 (__fastcall **)(__int64 *))(v7 + 248))(a1);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v8, "instance_", "J");
  v10 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v9);
  v11 = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1352))(a1, a3, 0);
  GSMO_SET_PARAMETER(v10, v11, &v13);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*a1 + 1360))(a1, a3, v11);
}

//----- (0000000000030AD8) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2I(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        int a4)
{
  __int64 v7; // x8
  __int64 v8; // x0
  __int64 v9; // x0
  _BYTE *v10; // x21
  char *v11; // x22
  int v13; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v14; // [xsp+8h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  v13 = a4;
  v8 = (*(__int64 (__fastcall **)(__int64 *))(v7 + 248))(a1);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v8, "instance_", "J");
  v10 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v9);
  v11 = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1352))(a1, a3, 0);
  GSMO_SET_PARAMETER(v10, v11, &v13);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*a1 + 1360))(a1, a3, v11);
}

//----- (0000000000030BC8) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setParameter__Ljava_lang_String_2F(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        float a4)
{
  __int64 v7; // x8
  __int64 v8; // x0
  __int64 v9; // x0
  _BYTE *v10; // x21
  char *v11; // x22
  float v13; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v14; // [xsp+8h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  v13 = a4;
  v8 = (*(__int64 (__fastcall **)(__int64 *))(v7 + 248))(a1);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v8, "instance_", "J");
  v10 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v9);
  v11 = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1352))(a1, a3, 0);
  GSMO_SET_PARAMETER(v10, v11, &v13);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*a1 + 1360))(a1, a3, v11);
}

//----- (0000000000030CB8) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_getLatency(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x0
  unsigned int v8; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v9; // [xsp+8h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v4,
         "instance_",
         "J");
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v5);
  v8 = 0;
  GSMO_GET_LATENCY(v6, &v8);
  return v8;
}

//----- (0000000000030D60) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne__1getCaps(__int64 *a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 v5; // x0
  __int64 v6; // x0
  __int64 v7; // x0
  const char *v8; // x20
  __int64 result; // x0
  __int64 v10; // x20
  __int64 v11; // x0
  __int64 v12; // x21
  __int64 v13; // x0
  unsigned int v14; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v15; // [xsp+8h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = *a1;
  v14 = 0;
  v5 = (*(__int64 (__fastcall **)(__int64 *))(v4 + 248))(a1);
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 752))(a1, v5, "instance_", "J");
  v7 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 808))(a1, a2, v6);
  if ( v7 )
  {
    v8 = "kNullException";
    switch ( (unsigned int)GSMO_GET_CAPS(v7, &v14) )
    {
      case 0u:
        return v14;
      case 1u:
        goto LABEL_16;
      case 2u:
        v8 = "kInvalidProfileKey";
        goto LABEL_16;
      case 3u:
        v8 = "kNotInitialized";
        goto LABEL_16;
      case 4u:
        v8 = "kNotSupportChannels";
        goto LABEL_16;
      case 5u:
        v8 = "kNotSupportSampleRate";
        goto LABEL_16;
      case 6u:
        v8 = "kNotSupportSamplesPerBlock";
        goto LABEL_16;
      case 7u:
        v8 = "kNotSupportFormat";
        goto LABEL_16;
      case 8u:
        v8 = "kNotSupportResampler";
        goto LABEL_16;
      case 0xAu:
        v8 = "kNotSupportParams";
        goto LABEL_16;
      case 0xBu:
        v8 = "kUnlicensedFeature";
        goto LABEL_16;
      case 0xDu:
        v8 = "kInvalidMetadata";
        goto LABEL_16;
      default:
        v8 = "kError";
LABEL_16:
        v12 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
        v13 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(a1, v12, v8, "I");
        result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v12, v13);
        break;
    }
  }
  else
  {
    v10 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/gaudiolab/sol/android/ErrorCode");
    v11 = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 1152))(
            a1,
            v10,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 1200))(a1, v10, v11);
  }
  return result;
}

//----- (0000000000030F88) ----------------------------------------------------
__int64 __fastcall Java_com_gaudiolab_sol_android_SolMusicOne_setProfile(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x21
  char *v10; // x22
  unsigned int v11; // w21
  const char *v12; // x20
  __int64 v13; // x20
  __int64 v14; // x2
  __int64 v16; // x21
  __int64 v17; // x2

  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 248LL))(a1);
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 752LL))(
         a1,
         v6,
         "instance_",
         "J");
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 808LL))(a1, a2, v7);
  if ( v8 )
  {
    v9 = v8;
    v10 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
    v11 = GSMO_SET_PROFILE(v9, v10);
    (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, a3, v10);
    if ( v11 > 0xD )
      v12 = "kError";
    else
      v12 = off_6ED08[v11];
    v16 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
            a1,
            "com/gaudiolab/sol/android/ErrorCode");
    v17 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v16,
            v12,
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v16, v17);
  }
  else
  {
    v13 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
            a1,
            "com/gaudiolab/sol/android/ErrorCode");
    v14 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 1152LL))(
            a1,
            v13,
            "kNullException",
            "I");
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1200LL))(a1, v13, v14);
  }
}
// 6ED08: using guessed type char *off_6ED08[14];

//----- (0000000000031110) ----------------------------------------------------
void __fastcall std::queue<st_event *>::~queue(__int64 a1)
{
  void **v1; // x20
  void **v2; // x21
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x8
  __int64 v6; // x8
  void *v7; // t1
  __int64 v8; // x8
  __int64 v9; // x9

  v1 = *(void ***)(a1 + 8);
  v2 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v2 - (char *)v1;
  if ( (unsigned __int64)((char *)v2 - (char *)v1) >= 0x11 )
  {
    do
    {
      operator delete(*v1);
      v2 = *(void ***)(a1 + 16);
      v1 = (void **)(*(_QWORD *)(a1 + 8) + 8LL);
      v4 = (char *)v2 - (char *)v1;
      *(_QWORD *)(a1 + 8) = v1;
    }
    while ( (unsigned __int64)((char *)v2 - (char *)v1) > 0x10 );
  }
  v5 = v4 >> 3;
  if ( v5 == 1 )
  {
    v6 = 256;
    goto LABEL_7;
  }
  if ( v5 == 2 )
  {
    v6 = 512;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if ( v1 != v2 )
  {
    do
    {
      v7 = *v1++;
      operator delete(v7);
    }
    while ( v1 != v2 );
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if ( v8 != v9 )
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
}

//----- (00000000000311DC) ----------------------------------------------------
__int64 sub_311DC()
{
  __cxa_atexit((void (*)(void *))std::mutex::~mutex, &lock_, &off_6ED00);
  xmmword_78A78 = 0u;
  xmmword_78A88 = 0u;
  xmmword_78A98 = 0u;
  return __cxa_atexit((void (*)(void *))std::queue<st_event *>::~queue, &xmmword_78A78, &off_6ED00);
}
// 6ED00: using guessed type _UNKNOWN *off_6ED00;
// 78A78: using guessed type __int128 xmmword_78A78;
// 78A88: using guessed type __int128;
// 78A98: using guessed type __int128 xmmword_78A98;

//----- (0000000000031234) ----------------------------------------------------
__int64 __fastcall GSMO_GET_VERSION(_QWORD *a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 1;
  result = 0;
  *a1 = "v3.7.0 (8ea30ea)";
  return result;
}

//----- (0000000000031258) ----------------------------------------------------
__int64 __fastcall GSMO_CREATE(_QWORD *a1)
{
  _QWORD *v2; // x19

  if ( !a1 )
    return 1;
  v2 = malloc(0x1D8u);
  *a1 = v2;
  v2[58] = 0;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((_OWORD *)v2 + 18) = 0u;
  *((_OWORD *)v2 + 19) = 0u;
  *((_OWORD *)v2 + 20) = 0u;
  *((_OWORD *)v2 + 21) = 0u;
  *((_OWORD *)v2 + 22) = 0u;
  *((_OWORD *)v2 + 23) = 0u;
  *((_OWORD *)v2 + 24) = 0u;
  *((_OWORD *)v2 + 25) = 0u;
  *((_OWORD *)v2 + 26) = 0u;
  *((_OWORD *)v2 + 27) = 0u;
  *((_OWORD *)v2 + 28) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 11) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  resampler_create(v2 + 13);
  dynamic_queue_create(v2 + 14);
  channel_layout_converter_create(v2 + 15);
  iir_create(v2 + 16);
  v2[37] = 0x3EB3333300000000LL;
  sln_create(v2 + 17);
  eleq_create(v2 + 18);
  graphic_equalizer_create(v2 + 19);
  v2[39] = malloc(0x34u);
  gain_create(v2 + 20);
  spatial_upmix_create(v2 + 21);
  gain_create(v2 + 22);
  gain_create(v2 + 23);
  drc_create(v2 + 24);
  gain_create(v2 + 25);
  boost_gain_create(v2 + 26);
  compressor_create(v2 + 27);
  gain_create(v2 + 28);
  gain_create(v2 + 29);
  gain_create(v2 + 30);
  limiter_create(v2 + 31);
  sln_create(v2 + 32);
  return 0;
}

//----- (00000000000313F8) ----------------------------------------------------
__int64 __fastcall GSMO_DESTROY(void **a1)
{
  void *v1; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  __int64 result; // x0

  if ( !a1 )
    return 1;
  v1 = *a1;
  if ( !*a1 )
    return 1;
  v3 = (void *)*((_QWORD *)v1 + 7);
  if ( v3 )
    free(v3);
  v4 = (void *)*((_QWORD *)v1 + 55);
  if ( v4 )
  {
    free(v4);
    *((_QWORD *)v1 + 55) = 0;
  }
  resampler_destroy((__int64 *)v1 + 13);
  v5 = (void *)*((_QWORD *)v1 + 33);
  if ( v5 )
  {
    free(v5);
    *((_QWORD *)v1 + 33) = 0;
  }
  v6 = (void *)*((_QWORD *)v1 + 34);
  if ( v6 )
  {
    free(v6);
    *((_QWORD *)v1 + 34) = 0;
  }
  dynamic_queue_destroy((__int64 *)v1 + 14);
  channel_layout_converter_destroy((void **)v1 + 15);
  iir_destroy((__int64 *)v1 + 16);
  sln_destroy((__int64 *)v1 + 17);
  eleq_destroy((__int64 *)v1 + 18);
  graphic_equalizer_destroy((__int64 *)v1 + 19);
  v7 = (void *)*((_QWORD *)v1 + 39);
  if ( v7 )
  {
    free(v7);
    *((_QWORD *)v1 + 39) = 0;
  }
  v8 = (void *)*((_QWORD *)v1 + 40);
  if ( v8 )
  {
    free(v8);
    *((_QWORD *)v1 + 40) = 0;
  }
  gain_destroy((void **)v1 + 20);
  spatial_upmix_destroy((__int64 *)v1 + 21);
  gain_destroy((void **)v1 + 22);
  gain_destroy((void **)v1 + 23);
  drc_destroy((__int64 *)v1 + 24);
  gain_destroy((void **)v1 + 25);
  boost_gain_destroy((void **)v1 + 26);
  compressor_destroy((__int64 *)v1 + 27);
  gain_destroy((void **)v1 + 28);
  gain_destroy((void **)v1 + 29);
  gain_destroy((void **)v1 + 30);
  limiter_destroy((__int64 *)v1 + 31);
  sln_destroy((__int64 *)v1 + 32);
  if ( *a1 )
  {
    free(*a1);
    *a1 = 0;
  }
  result = 0;
  *a1 = 0;
  return result;
}

//----- (000000000003153C) ----------------------------------------------------
__int64 __fastcall GSMO_SETUP(unsigned int *a1, _DWORD *a2, __int64 a3)
{
  __int64 result; // x0
  int v7; // w0
  int v8; // w8
  __int128 v9; // q0
  __int64 v10; // x24
  unsigned int v11; // w25
  void *v12; // x0
  unsigned int v13; // w22
  unsigned int v14; // w2
  unsigned int v15; // w21
  unsigned int v16; // w23
  __int64 v17; // x22
  __int64 v18; // x8
  size_t v19; // x26
  void *v20; // x0
  int v21; // w5
  __int64 v22; // x8
  unsigned int v23; // w23
  float v24; // s0
  float v25; // s2
  float v26; // s0
  int32x2_t v27; // d4
  __int64 v28; // x8
  void *v29; // x0
  __int64 v30; // x8
  __int64 v31; // x0
  double v32; // d0
  unsigned __int64 v33; // [xsp+0h] [xbp-80h] BYREF
  int v34; // [xsp+8h] [xbp-78h]
  float v35[3]; // [xsp+Ch] [xbp-74h] BYREF
  __int64 v36; // [xsp+18h] [xbp-68h]

  result = 1;
  v36 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        result = _checkValidConfig(1, a2);
        if ( !(_DWORD)result )
        {
          result = _checkValidParams((__int64)a1, a2, a3);
          if ( !(_DWORD)result )
          {
            v7 = lm1_wrapper_decode(*(_QWORD *)(a3 + 64), *(_DWORD *)(a3 + 72), (__int64)(a1 + 83));
            v8 = *((unsigned __int8 *)a1 + 466);
            *((_BYTE *)a1 + 464) = v7 == 0;
            if ( v8 )
              GSMO_RESET((__int64)a1);
            v9 = *(_OWORD *)a2;
            a1[4] = a2[4];
            *(_OWORD *)a1 = v9;
            _copy_params((__int64)(a1 + 6), a3);
            v10 = *a1;
            v11 = a1[1];
            *((_BYTE *)a1 + 465) = 0;
            v12 = malloc(4 * v10);
            v13 = a1[2];
            *((_QWORD *)a1 + 55) = v12;
            dword_78AA8 = (unsigned int)(float)((float)v13 * 60.0);
            dword_78AAC = (unsigned int)(float)((float)v13 + (float)v13);
            memset(v12, 0, 4 * v10);
            static_resampler_get_internal_sample_rate(v13, (int *)a1 + 73);
            v14 = a1[2];
            v15 = a1[73];
            v16 = (unsigned int)(float)((float)((float)((float)v14 / (float)v15) * 512.0) + 0.5);
            resampler_setup(*((unsigned int **)a1 + 13), v10, v14, v16, v11);
            resampler_get_external_samples(*((_QWORD *)a1 + 13), a1 + 71);
            resampler_get_internal_samples(*((_QWORD *)a1 + 13), a1 + 72);
            v17 = a1[72];
            if ( (unsigned int)v10 <= v11 )
              v18 = v11;
            else
              v18 = (unsigned int)v10;
            v19 = 4 * v17 * v18;
            *((_QWORD *)a1 + 33) = malloc(v19);
            v20 = malloc(v19);
            v21 = a1[3];
            v22 = *((_QWORD *)a1 + 14);
            *((_QWORD *)a1 + 34) = v20;
            dynamic_queue_setup(v22, (__int64)a1, (__int64)process, v10, v11, v21, v16, v21 != 0);
            if ( v11 == 2 )
              v23 = 2;
            else
              v23 = v10;
            channel_layout_converter_setup(*((unsigned int **)a1 + 15), v10, v11, v17, v10 == v11);
            v24 = tanf((float)(200.0 / (float)v15) * 3.1416);
            v25 = v24 * v24;
            v26 = v24 * 1.4142;
            v27.n64_f32[0] = v25 + (float)(v26 + 1.0);
            v35[1] = (float)((float)(v25 + -1.0) + (float)(v25 + -1.0)) / v27.n64_f32[0];
            v35[2] = (float)(v25 + (float)(1.0 - v26)) / v27.n64_f32[0];
            v35[0] = 1.0;
            v33 = vdiv_f32((float32x2_t)0xC00000003F800000LL, vdup_lane_s32(v27, 0)).n64_u64[0];
            v34 = v33;
            iir_setup(*((_QWORD *)a1 + 16), v23, v17, 2, v35, (float *)&v33);
            sln_setup(*((_QWORD *)a1 + 17), v23, v15, v17, 0);
            eleq_setup(*((unsigned int **)a1 + 18), v23, v15, (unsigned int)v17);
            graphic_equalizer_setup(*((_QWORD *)a1 + 19), v23, v15, v17, *(unsigned int *)(a3 + 24));
            v28 = (unsigned int)((double)(unsigned int)((double)v15 * 0.5) * 0.05 + 1.0);
            a1[82] = v28;
            v29 = malloc(4 * v28);
            v30 = *((_QWORD *)a1 + 20);
            *((_QWORD *)a1 + 40) = v29;
            a1[108] = 1065353216;
            gain_setup(v30, v23, v17, 1);
            if ( v23 == 2 )
              spatial_upmix_setup(*((_QWORD *)a1 + 21), 2, v15, v17, *(unsigned int *)(a3 + 48), *(float *)(a3 + 52));
            gain_setup(*((_QWORD *)a1 + 22), v23, v17, 1);
            gain_setup(*((_QWORD *)a1 + 23), v23, v17, 1);
            drc_setup(*((_QWORD *)a1 + 24), v23, v15, v17);
            gain_setup(*((_QWORD *)a1 + 25), v23, v17, 1);
            boost_gain_setup(*((_QWORD *)a1 + 26), v23, v15, v17);
            compressor_setup(*((unsigned int **)a1 + 27), v23, v15, v17);
            gain_setup(*((_QWORD *)a1 + 28), v23, v17, 1);
            gain_setup(*((_QWORD *)a1 + 29), v23, v17, 1);
            v31 = *((_QWORD *)a1 + 30);
            a1[107] = 1065353216;
            gain_setup(v31, v23, v17, 1);
            limiter_setup(*((_QWORD *)a1 + 31), v23, v15, v17, 0.99);
            sln_setup(*((_QWORD *)a1 + 32), v23, v15, v17, 0);
            a1[70] = v23;
            *((_BYTE *)a1 + 466) = 1;
            _update((__int64)a1, v32);
            if ( *((_BYTE *)a1 + 464) )
              return 0;
            else
              return 13;
          }
        }
      }
    }
  }
  return result;
}
// 3178C: variable 'v27' is possibly undefined
// 31984: variable 'v32' is possibly undefined
// 78AA8: using guessed type int dword_78AA8;
// 78AAC: using guessed type int dword_78AAC;

//----- (00000000000319D0) ----------------------------------------------------
__int64 __fastcall checkValidConfig(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0
  int v3; // w8
  int v4; // w8
  int v5; // w8

  result = 4;
  switch ( *a2 )
  {
    case 1:
      if ( (unsigned int)(a2[1] - 1) < 2 )
        goto LABEL_13;
      return 4;
    case 2:
      if ( a2[1] == 2 )
        goto LABEL_13;
      return 4;
    case 6:
      if ( (a2[1] | 4) != 6 )
        return 4;
      goto LABEL_13;
    case 8:
      v3 = a2[1];
      if ( v3 != 2 && v3 != 8 )
        return 4;
      goto LABEL_13;
    case 0xC:
      v4 = a2[1];
      if ( v4 != 12 && v4 != 2 )
        return 4;
LABEL_13:
      v5 = a2[2];
      result = 5;
      if ( v5 <= 31999 )
      {
        if ( v5 <= 11999 )
        {
          if ( v5 == 6000 || v5 == 8000 || v5 == 11025 )
            goto LABEL_40;
        }
        else if ( v5 > 22049 )
        {
          if ( v5 == 22050 || v5 == 24000 )
            goto LABEL_40;
        }
        else if ( v5 == 12000 || v5 == 16000 )
        {
          goto LABEL_40;
        }
      }
      else if ( v5 > 88199 )
      {
        if ( v5 > 176399 )
        {
          if ( v5 == 192000 || v5 == 176400 )
            goto LABEL_40;
        }
        else if ( v5 == 88200 || v5 == 96000 )
        {
          goto LABEL_40;
        }
      }
      else
      {
        if ( v5 <= 47999 )
        {
          if ( v5 != 32000 && v5 != 44100 )
            return result;
LABEL_40:
          if ( a2[3] > 0x8000u )
            return 6;
          if ( a2[4] >= 4u )
            return 7;
          return 0;
        }
        if ( v5 == 48000 || v5 == 64000 )
          goto LABEL_40;
      }
      return result;
    default:
      return result;
  }
}

//----- (0000000000031BC0) ----------------------------------------------------
__int64 __fastcall checkValidParams(__int64 a1, _DWORD *a2, __int64 a3)
{
  int v3; // w8
  __int64 result; // x0
  float v5; // s1
  float v6; // s1
  __int64 v7; // x8
  float *v8; // x9
  float v9; // s3
  float v10; // s3
  float v11; // s1
  float v12; // s1
  float v13; // s1
  int v14; // w8

  v3 = *(_DWORD *)(a3 + 4);
  if ( (v3 & ~*(_DWORD *)(a1 + 456)) != 0 )
    return 11;
  if ( (v3 & 4) != 0 && *a2 != 2 )
    return 10;
  if ( *(_DWORD *)(a3 + 8) > 4u || *(_DWORD *)(a3 + 12) > 1u )
    return 0xFFFFFFFFLL;
  v5 = *(float *)(a3 + 16);
  result = 0xFFFFFFFFLL;
  if ( fabsf(v5) != INFINITY )
  {
    result = 0xFFFFFFFFLL;
    if ( v5 >= -30.0 && v5 <= -10.0 )
    {
      v6 = *(float *)(a3 + 20);
      result = 0xFFFFFFFFLL;
      if ( fabsf(v6) != INFINITY )
      {
        result = 0xFFFFFFFFLL;
        if ( v6 >= -6.0 && v6 <= 6.0 )
        {
          v7 = *(unsigned int *)(a3 + 24);
          result = 0xFFFFFFFFLL;
          if ( (unsigned int)v7 <= 0xA && ((1 << v7) & 0x4A8) != 0 )
          {
            v8 = *(float **)(a3 + 32);
            if ( v8 )
            {
              while ( 1 )
              {
                v9 = *v8;
                result = 0xFFFFFFFFLL;
                if ( fabsf(*v8) == INFINITY )
                  break;
                result = 0xFFFFFFFFLL;
                if ( v9 < -12.0 || v9 > 12.0 )
                  break;
                --v7;
                ++v8;
                if ( !v7 )
                {
                  v10 = *(float *)(a3 + 40);
                  result = 0xFFFFFFFFLL;
                  if ( fabsf(v10) == INFINITY )
                    return result;
                  result = 0xFFFFFFFFLL;
                  if ( v10 < -12.0 || v10 > 12.0 )
                    return result;
                  if ( *(_DWORD *)(a3 + 48) > 6u )
                    return 0xFFFFFFFFLL;
                  v11 = *(float *)(a3 + 52);
                  result = 0xFFFFFFFFLL;
                  if ( fabsf(v11) == INFINITY )
                    return result;
                  result = 0xFFFFFFFFLL;
                  if ( v11 < -0.00000011921 )
                    return result;
                  if ( v11 > 5.0 )
                    return result;
                  v12 = *(float *)(a3 + 60);
                  result = 0xFFFFFFFFLL;
                  if ( v12 < -0.00000011921 )
                    return result;
                  if ( fabsf(v12) == INFINITY )
                    return result;
                  v13 = *(float *)(a3 + 56);
                  result = 0xFFFFFFFFLL;
                  if ( fabsf(v13) == INFINITY )
                    return result;
                  result = 0xFFFFFFFFLL;
                  if ( v13 < -30.0 || v13 > 0.00000011921 )
                    return result;
                  v14 = *(_DWORD *)(a3 + 72);
                  if ( v14 < 0 )
                    return 0xFFFFFFFFLL;
                  return v14 && !*(_QWORD *)(a3 + 64);
                }
              }
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000031E28) ----------------------------------------------------
__int64 __fastcall GSMO_RESET(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  __int64 result; // x0

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 466) )
    return 3;
  v2 = *(void **)(a1 + 440);
  if ( v2 )
  {
    free(v2);
    *(_QWORD *)(a1 + 440) = 0;
  }
  v3 = *(void **)(a1 + 264);
  if ( v3 )
  {
    free(v3);
    *(_QWORD *)(a1 + 264) = 0;
  }
  v4 = *(void **)(a1 + 272);
  if ( v4 )
  {
    free(v4);
    *(_QWORD *)(a1 + 272) = 0;
  }
  dynamic_queue_reset(*(_QWORD *)(a1 + 112));
  channel_layout_converter_reset(*(_QWORD *)(a1 + 120));
  iir_reset(*(_QWORD *)(a1 + 128));
  sln_reset(*(_QWORD *)(a1 + 136));
  eleq_reset(*(_QWORD *)(a1 + 144));
  graphic_equalizer_reset(*(_QWORD *)(a1 + 152));
  v5 = *(void **)(a1 + 320);
  if ( v5 )
  {
    free(v5);
    *(_QWORD *)(a1 + 320) = 0;
  }
  gain_reset(*(_QWORD *)(a1 + 160));
  spatial_upmix_reset(*(_QWORD *)(a1 + 168));
  gain_reset(*(_QWORD *)(a1 + 176));
  gain_reset(*(_QWORD *)(a1 + 184));
  drc_reset(*(_QWORD *)(a1 + 192));
  gain_reset(*(_QWORD *)(a1 + 200));
  boost_gain_reset(*(_QWORD *)(a1 + 208));
  compressor_reset(*(_QWORD *)(a1 + 216));
  gain_reset(*(_QWORD *)(a1 + 224));
  gain_reset(*(_QWORD *)(a1 + 232));
  gain_reset(*(_QWORD *)(a1 + 240));
  limiter_reset(*(_QWORD *)(a1 + 248));
  sln_reset(*(_QWORD *)(a1 + 256));
  result = 0;
  *(_BYTE *)(a1 + 466) = 0;
  return result;
}

//----- (0000000000031F40) ----------------------------------------------------
long double __fastcall copy_params(__int64 a1, __int64 a2)
{
  void *v3; // x0
  __int64 v5; // x21
  void *v6; // x0
  long double result; // q0

  v3 = *(void **)(a1 + 32);
  if ( v3 )
    free(v3);
  v5 = *(unsigned int *)(a2 + 24);
  v6 = malloc(4 * v5);
  *(_QWORD *)(a1 + 32) = v6;
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = v5;
  memcpy(v6, *(const void **)(a2 + 32), 4LL * *(unsigned int *)(a2 + 24));
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 44) = *(_BYTE *)(a2 + 44);
  result = *(long double *)(a2 + 48);
  *(long double *)(a1 + 48) = result;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  return result;
}

//----- (0000000000031FD4) ----------------------------------------------------
__int64 __fastcall process(unsigned int *a1, void *a2, char *a3)
{
  _BOOL4 v5; // w24
  unsigned int v6; // w27
  unsigned int v7; // w19
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x22
  unsigned int v10; // w25
  double v11; // d0
  float v12; // s0
  bool v13; // w28
  float32x4_t *v14; // x23
  float32x4_t *v15; // x24
  double v16; // d0
  double v17; // d1
  double v18; // d2
  float32x4_t *v19; // x22
  float v20; // s8
  __int64 v21; // x0
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d0
  double v26; // d1
  double v27; // d2
  __int64 v28; // x24
  __int128 v29; // q0
  __int128 v30; // q1
  double v31; // d2
  __int64 v32; // x8
  __int64 v33; // x10
  __int64 v34; // x11
  unsigned int v35; // w12
  __int64 v36; // x9
  unsigned int v37; // w15
  __int64 v38; // x17
  unsigned int v39; // w16
  __int64 v40; // x0
  float v41; // s1
  float v42; // s0
  __int64 v43; // x16
  __int64 v44; // x17
  float v45; // s0
  float v46; // s1
  float v47; // s0
  unsigned __int64 v48; // x9
  __int64 v49; // x11
  unsigned __int32 *v50; // x9
  int v51; // w10
  __int64 v52; // x8
  unsigned __int32 v53; // w11
  float32x4_t *v54; // x24
  bool v55; // w23
  unsigned int v56; // w26
  bool v57; // w19
  float32x4_t *v58; // x28
  unsigned int v59; // w21
  unsigned int v60; // w27
  float32x4_t *v61; // x25
  float32x4_t *v62; // x23
  char *v63; // x26
  bool v64; // w22
  float32x4_t *v65; // x24
  __int64 v66; // x10
  _OWORD *v67; // x12
  __int64 v68; // x13
  __int128 *v69; // x14
  float v70; // s0
  float v71; // s8
  float InstantLoudness; // s0
  __int64 v73; // x8
  double v74; // d0
  double v75; // d1
  double v76; // d2
  double v77; // d3
  double v78; // d4
  float32x4_t *v79; // x22
  unsigned int v80; // w19
  double v81; // d0
  double v82; // d1
  double v83; // d2
  double v84; // d3
  double v85; // d4
  __int64 v86; // x9
  float32x4_t *v87; // x10
  float32x4_t v88; // q1
  float32x4_t v89; // q2
  float32x4_t v90; // q3
  __int64 v91; // x11
  float32x4_t v92; // q5
  float *v93; // x10
  __int64 v94; // x8
  unsigned int v96; // w8
  __int64 v97; // x8
  __int64 v98; // x10
  __int64 v99; // x11
  unsigned int v100; // w12
  __int64 v101; // x9
  unsigned int v102; // w15
  __int64 v103; // x17
  unsigned int v104; // w16
  __int64 v105; // x0
  float v106; // s1
  float v107; // s0
  __int64 v108; // x16
  __int64 v109; // x17
  float v110; // s0
  float v111; // s1
  float v112; // s0
  unsigned __int64 v113; // x9
  __int64 v114; // x11
  unsigned __int32 *v115; // x9
  int v116; // w10
  __int64 v117; // x8
  unsigned __int32 v118; // w11
  __int64 v119; // x10
  _OWORD *v120; // x12
  __int64 v121; // x13
  __int128 *v122; // x14
  char v123; // [xsp+8h] [xbp-78h]
  bool v124; // [xsp+Ch] [xbp-74h]
  char *v125; // [xsp+10h] [xbp-70h]
  _BOOL4 v126; // [xsp+1Ch] [xbp-64h]

  if ( *((_BYTE *)a1 + 24) )
    v5 = *((_BYTE *)a1 + 464) != 0;
  else
    v5 = 0;
  v6 = a1[72];
  v7 = a1[1];
  resampler_run_external_to_internal(*((unsigned int **)a1 + 13), a2, *((void **)a1 + 33));
  v9 = *((_QWORD *)a1 + 33);
  v8 = *((_QWORD *)a1 + 34);
  v10 = a1[7];
  channel_layout_converter_process(*((unsigned int **)a1 + 15), v9, v8, v11);
  v125 = a3;
  if ( *((float *)a1 + 74) <= *((float *)a1 + 75)
    || (v12 = *((float *)a1 + 83), *((float *)a1 + 10) <= (float)(v12 + 16.0)) )
  {
    v13 = !v5;
LABEL_10:
    v14 = (float32x4_t *)v9;
    v9 = v8;
    goto LABEL_11;
  }
  v13 = !v5;
  if ( v12 >= -35.0 || !v5 )
    goto LABEL_10;
  iir_process(*((unsigned int **)a1 + 16), v8, v9);
  v13 = 0;
  v14 = (float32x4_t *)v8;
LABEL_11:
  if ( (v10 & 0x20) != 0 && !v13 && (a1[114] & 0x20) != 0 )
    sln_sol_process(*((_QWORD *)a1 + 17), v9, (__int64)v14);
  v126 = v5;
  if ( (v10 & 1) != 0 && !v13 && (a1[114] & 1) != 0 )
  {
    eleq_process(*((int **)a1 + 18), v9, (__int64)v14);
    v15 = (float32x4_t *)v9;
  }
  else
  {
    v15 = v14;
    v14 = (float32x4_t *)v9;
  }
  v124 = (v10 & 2) == 0 || v13;
  if ( (v10 & 2) != 0 && !v13 && (a1[114] & 2) != 0 )
  {
    graphic_equalizer_process(*((_QWORD *)a1 + 19), (__int64)v14, (__int64)v15);
    if ( (a1[114] & 2) == 0 )
    {
      v19 = v14;
      v14 = v15;
      goto LABEL_24;
    }
    gain_process(*((_QWORD *)a1 + 20), v15, v14, v16, v17, v18);
  }
  v19 = v15;
LABEL_24:
  v20 = (float)v6;
  if ( (v10 & 4) == 0 || v13 )
  {
    spatial_upmix_bypass(*((_QWORD *)a1 + 21), v14, (__int64)v19);
LABEL_31:
    v28 = (__int64)v19;
LABEL_32:
    drc_bypass(*((_QWORD *)a1 + 24), v28, (__int64)v14);
    v32 = *a1;
    if ( !*((_BYTE *)a1 + 465) )
    {
      if ( (_DWORD)v32 )
      {
        v33 = *((_QWORD *)a1 + 55);
        v34 = v6 - 1;
        v35 = v6 - 2;
        v36 = 0;
        v37 = *a1;
        do
        {
          v14->n128_u32[v36] = *(_DWORD *)(v33 + 4 * v36);
          if ( v6 != 1 )
          {
            if ( (_DWORD)v32 != 1 || -2 - (int)v36 < v35 || (unsigned __int64)(v34 - 1) >> 32 || ~(_DWORD)v36 < v35 )
            {
              v43 = 0;
              LODWORD(v44) = v36;
              do
              {
                v45 = v14->n128_f32[(unsigned int)v44];
                v44 = (unsigned int)(v32 + v44);
                LODWORD(v31) = v14->n128_u32[v44];
                v46 = (float)(unsigned int)v43 / v20;
                v47 = (float)(1.0 - v46) * v45;
                ++v43;
                *(float *)&v30 = v46 * *(float *)&v31;
                *(float *)&v29 = *(float *)&v30 + v47;
                v14->n128_u32[v44] = v29;
              }
              while ( v34 != v43 );
            }
            else
            {
              LODWORD(v29) = v14->n128_u32[v36];
              v38 = 0;
              v39 = v37;
              do
              {
                v40 = v39;
                LODWORD(v31) = v14->n128_u32[v40];
                v41 = (float)(unsigned int)v38++ / v20;
                v42 = (float)(1.0 - v41) * *(float *)&v29;
                *(float *)&v30 = v41 * *(float *)&v31;
                *(float *)&v29 = *(float *)&v30 + v42;
                ++v39;
                v14->n128_u32[v40] = v29;
              }
              while ( v34 != v38 );
            }
          }
          ++v36;
          ++v37;
        }
        while ( v36 != v32 );
      }
      *((_BYTE *)a1 + 465) = 1;
    }
    if ( !(_DWORD)v32 )
      goto LABEL_53;
    v48 = *((_QWORD *)a1 + 55);
    if ( (unsigned int)v32 >= 8 )
    {
      v66 = (unsigned int)v32 * (v6 - 1);
      v49 = 0;
      if ( ~(_DWORD)v66 < (unsigned int)(v32 - 1) || (unsigned __int64)(v32 - 1) >> 32 )
        goto LABEL_51;
      if ( v48 >= (unsigned __int64)v14->n128_u64 + 4 * v32 + 4 * v66
        || (unsigned __int64)v14->n128_u64 + 4 * (unsigned int)v66 >= v48 + 4 * v32 )
      {
        v49 = (unsigned int)v32 & 0xFFFFFFF8;
        v67 = (_OWORD *)(v48 + 16);
        v68 = v49;
        do
        {
          v69 = (__int128 *)((char *)v14 + 4 * (unsigned int)v66);
          v29 = *v69;
          v30 = v69[1];
          v68 -= 8;
          LODWORD(v66) = v66 + 8;
          *(v67 - 1) = *v69;
          *v67 = v30;
          v67 += 2;
        }
        while ( v68 );
        if ( v49 == v32 )
          goto LABEL_53;
        goto LABEL_51;
      }
    }
    v49 = 0;
LABEL_51:
    v50 = (unsigned __int32 *)(v48 + 4 * v49);
    v51 = v49 + v32 * (v6 - 1);
    v52 = v32 - v49;
    do
    {
      v53 = v14->n128_u32[v51];
      --v52;
      ++v51;
      *v50++ = v53;
    }
    while ( v52 );
LABEL_53:
    v19 = (float32x4_t *)v28;
    v54 = v14;
    v55 = (v10 & 0x20) == 0 || v13;
    v56 = v7;
    goto LABEL_54;
  }
  v21 = *((_QWORD *)a1 + 21);
  if ( (a1[114] & 4) != 0 )
  {
    *(float *)&v22 = spatial_upmix_process(v21, (float *)v14, (unsigned __int64)v19);
    if ( (a1[114] & 4) == 0 )
      goto LABEL_31;
  }
  else
  {
    spatial_upmix_bypass(v21, v14, (__int64)v19);
    if ( (a1[114] & 4) == 0 )
      goto LABEL_31;
  }
  gain_process(*((_QWORD *)a1 + 22), v19, v14, v22, v23, v24);
  if ( (a1[114] & 4) == 0 )
  {
    v28 = (__int64)v14;
    v14 = v19;
    goto LABEL_32;
  }
  v96 = a1[18];
  if ( v96 == 2 || v96 == 6 && *((_BYTE *)a1 + 424) )
  {
    gain_process(*((_QWORD *)a1 + 23), v14, v19, v25, v26, v27);
    v54 = v14;
  }
  else
  {
    v54 = v19;
    v19 = v14;
  }
  v55 = (v10 & 0x20) == 0 || v13;
  v56 = v7;
  drc_process(*((_QWORD *)a1 + 24), (__int64)v19, (__int64)v54);
  v97 = *a1;
  if ( *((_BYTE *)a1 + 465) == 1 )
  {
    if ( (_DWORD)v97 )
    {
      v98 = *((_QWORD *)a1 + 55);
      v99 = v6 - 1;
      v100 = v6 - 2;
      v101 = 0;
      v102 = *a1;
      do
      {
        v54->n128_u32[v101] = *(_DWORD *)(v98 + 4 * v101);
        if ( v6 != 1 )
        {
          if ( (_DWORD)v97 != 1 || -2 - (int)v101 < v100 || (unsigned __int64)(v99 - 1) >> 32 || ~(_DWORD)v101 < v100 )
          {
            v108 = 0;
            LODWORD(v109) = v101;
            do
            {
              v110 = v54->n128_f32[(unsigned int)v109];
              v109 = (unsigned int)(v97 + v109);
              LODWORD(v31) = v54->n128_u32[v109];
              v111 = (float)(unsigned int)v108 / v20;
              v112 = (float)(1.0 - v111) * v110;
              ++v108;
              *(float *)&v30 = v111 * *(float *)&v31;
              *(float *)&v29 = *(float *)&v30 + v112;
              v54->n128_u32[v109] = v29;
            }
            while ( v99 != v108 );
          }
          else
          {
            LODWORD(v29) = v54->n128_u32[v101];
            v103 = 0;
            v104 = v102;
            do
            {
              v105 = v104;
              LODWORD(v31) = v54->n128_u32[v105];
              v106 = (float)(unsigned int)v103++ / v20;
              v107 = (float)(1.0 - v106) * *(float *)&v29;
              *(float *)&v30 = v106 * *(float *)&v31;
              *(float *)&v29 = *(float *)&v30 + v107;
              ++v104;
              v54->n128_u32[v105] = v29;
            }
            while ( v99 != v103 );
          }
        }
        ++v101;
        ++v102;
      }
      while ( v101 != v97 );
    }
    *((_BYTE *)a1 + 465) = 0;
  }
  if ( (_DWORD)v97 )
  {
    v113 = *((_QWORD *)a1 + 55);
    if ( (unsigned int)v97 < 8 )
      goto LABEL_124;
    v119 = (unsigned int)v97 * (v6 - 1);
    v114 = 0;
    if ( ~(_DWORD)v119 < (unsigned int)(v97 - 1) || (unsigned __int64)(v97 - 1) >> 32 )
      goto LABEL_125;
    if ( v113 < (unsigned __int64)v54->n128_u64 + 4 * v97 + 4 * v119
      && (unsigned __int64)v54->n128_u64 + 4 * (unsigned int)v119 < v113 + 4 * v97 )
    {
LABEL_124:
      v114 = 0;
LABEL_125:
      v115 = (unsigned __int32 *)(v113 + 4 * v114);
      v116 = v114 + v97 * (v6 - 1);
      v117 = v97 - v114;
      do
      {
        v118 = v54->n128_u32[v116];
        --v117;
        ++v116;
        *v115++ = v118;
      }
      while ( v117 );
      goto LABEL_54;
    }
    v114 = (unsigned int)v97 & 0xFFFFFFF8;
    v120 = (_OWORD *)(v113 + 16);
    v121 = v114;
    do
    {
      v122 = (__int128 *)((char *)v54 + 4 * (unsigned int)v119);
      v29 = *v122;
      v30 = v122[1];
      v121 -= 8;
      LODWORD(v119) = v119 + 8;
      *(v120 - 1) = *v122;
      *v120 = v30;
      v120 += 2;
    }
    while ( v121 );
    if ( v114 != v97 )
      goto LABEL_125;
  }
LABEL_54:
  v123 = v10;
  if ( (v10 & 8) != 0 && !v13 && (a1[114] & 8) != 0 )
  {
    v57 = v13;
    v58 = (float32x4_t *)v8;
    v59 = v6;
    v60 = v56;
    gain_process(*((_QWORD *)a1 + 25), v54, v19, *(double *)&v29, *(double *)&v30, v31);
    v61 = v54;
    if ( v55 )
      goto LABEL_57;
  }
  else
  {
    v57 = v13;
    v58 = (float32x4_t *)v8;
    v59 = v6;
    v60 = v56;
    v61 = v19;
    v19 = v54;
    if ( v55 )
    {
LABEL_57:
      v62 = v19;
      v63 = v125;
      v64 = v124;
      v65 = v61;
      goto LABEL_75;
    }
  }
  if ( (a1[114] & 0x20) != 0
    && (loudness_measure_getIntegratedLoudness(*(_QWORD *)(*((_QWORD *)a1 + 17) + 80LL)),
        v71 = v70,
        InstantLoudness = loudness_measure_getInstantLoudness(*(_QWORD *)(*((_QWORD *)a1 + 17) + 80LL)),
        boost_gain_update(*((_QWORD *)a1 + 26), 0, v71, InstantLoudness, *((float *)a1 + 10), 8.5),
        a1[9]) )
  {
    boost_gain_process(*((int **)a1 + 26), v19, v61);
    v62 = v19;
  }
  else
  {
    v62 = v61;
    v61 = v19;
  }
  v63 = v125;
  v64 = v124;
  if ( (a1[114] & 0x20) != 0 && a1[9] )
  {
    compressor_process(*((unsigned int **)a1 + 27), (float *)v61, (__int64)v62);
    v65 = v61;
  }
  else
  {
    v65 = v62;
    v62 = v61;
  }
LABEL_75:
  if ( (v123 & 0x10) != 0 && !v57 && (a1[114] & 0x10) != 0 )
    v73 = 56;
  else
    v73 = 58;
  gain_process(*(_QWORD *)&a1[v73], v62, v65, *(double *)&v29, *(double *)&v30, v31);
  if ( !v64 && (a1[114] & 2) != 0 )
  {
    gain_process(*((_QWORD *)a1 + 30), v65, v62, v74, v75, v76);
    v79 = v65;
  }
  else
  {
    v79 = v62;
    v62 = v65;
  }
  if ( (v123 & 0x40) != 0 && !v57 && (a1[114] & 0x40) != 0 )
  {
    limiter_bypass(*((_QWORD *)a1 + 31), v62, v79);
    limiter_process(*((float **)a1 + 31), (__int64)v62, (__int64)v79, v81, v82, v83, v84, v85);
    v80 = v60 * v59;
    if ( !v126 )
    {
LABEL_90:
      if ( v62 != v58 )
        goto LABEL_92;
      goto LABEL_91;
    }
  }
  else
  {
    limiter_process(*((float **)a1 + 31), (__int64)v62, (__int64)v79, v74, v75, v76, v77, v78);
    limiter_bypass(*((_QWORD *)a1 + 31), v62, v79);
    v80 = v60 * v59;
    if ( !v126 )
      goto LABEL_90;
  }
  if ( !*((_BYTE *)a1 + 448) )
    goto LABEL_90;
  sln_sol_process(*((_QWORD *)a1 + 32), (__int64)v79, (__int64)v62);
  if ( v62 != v58 )
    goto LABEL_92;
LABEL_91:
  memcpy(v58, v79, 4LL * v80);
LABEL_92:
  if ( !v80 )
    goto LABEL_100;
  if ( v80 <= 7 )
  {
    v86 = 0;
LABEL_98:
    v93 = (float *)v58 + v86;
    v94 = v80 - v86;
    do
    {
      --v94;
      *v93 = (float)((float)(fabsf(*v93 + 0.99999) - fabsf(*v93 + -0.99999)) + 0.0) * 0.5;
      ++v93;
    }
    while ( v94 );
    goto LABEL_100;
  }
  v86 = v80 & 0xFFFFFFF8;
  v87 = v58 + 1;
  v88 = vdupq_n_s32(0x3F7FFF58u);
  v89 = vdupq_n_s32(0xBF7FFF58);
  v90.n128_u64[0] = 0x3F0000003F000000LL;
  v90.n128_u64[1] = 0x3F0000003F000000LL;
  v91 = v86;
  do
  {
    v91 -= 8;
    v92 = vmulq_f32(
            vaddq_f32(vsubq_f32(vabsq_f32(vaddq_f32(*v87, v88)), vabsq_f32(vaddq_f32(*v87, v89))), (float32x4_t)0LL),
            v90);
    v87[-1] = vmulq_f32(
                vaddq_f32(
                  vsubq_f32(vabsq_f32(vaddq_f32(v87[-1], v88)), vabsq_f32(vaddq_f32(v87[-1], v89))),
                  (float32x4_t)0LL),
                v90);
    *v87 = v92;
    v87 += 2;
  }
  while ( v91 );
  if ( v86 != v80 )
    goto LABEL_98;
LABEL_100:
  resampler_run_internal_to_external(*((_QWORD *)a1 + 13), *((const void **)a1 + 34), v63);
  return 0;
}
// 32274: conditional instruction was optimized away because x14.8==0
// 327EC: conditional instruction was optimized away because x14.8==0
// 32044: variable 'v11' is possibly undefined
// 32168: variable 'v16' is possibly undefined
// 32168: variable 'v17' is possibly undefined
// 32168: variable 'v18' is possibly undefined
// 321C8: variable 'v22' is possibly undefined
// 321C8: variable 'v23' is possibly undefined
// 321C8: variable 'v24' is possibly undefined
// 32434: variable 'v29' is possibly undefined
// 32434: variable 'v30' is possibly undefined
// 32434: variable 'v31' is possibly undefined
// 32458: variable 'v70' is possibly undefined
// 32548: variable 'v74' is possibly undefined
// 32548: variable 'v75' is possibly undefined
// 32548: variable 'v76' is possibly undefined
// 32578: variable 'v77' is possibly undefined
// 32578: variable 'v78' is possibly undefined
// 325D4: variable 'v81' is possibly undefined
// 325D4: variable 'v82' is possibly undefined
// 325D4: variable 'v83' is possibly undefined
// 325D4: variable 'v84' is possibly undefined
// 325D4: variable 'v85' is possibly undefined
// 32748: variable 'v25' is possibly undefined
// 32748: variable 'v26' is possibly undefined
// 32748: variable 'v27' is possibly undefined

//----- (0000000000032934) ----------------------------------------------------
__int64 __fastcall update(__int64 a1, double a2)
{
  float v2; // s3
  int v4; // w8
  float v5; // s2
  float v6; // s1
  float v7; // s4
  unsigned __int64 v8; // x1
  float v9; // s10
  float32x4_t *v10; // x9
  float v16; // s8
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x21
  float32x4_t v19; // q0
  float32x4_t v20; // q1
  __int64 v21; // x9
  float *v22; // x25
  float *v23; // x26
  unsigned __int64 v24; // x27
  float v25; // s11
  float v26; // s14
  double v27; // d10
  float v28; // s0
  float v29; // s2
  float v30; // s3
  float v31; // s0
  float v32; // s15
  float v33; // s1
  float v34; // s14
  float v35; // s0
  float v36; // s11
  float v37; // s0
  unsigned int v38; // w10
  __int64 v39; // x9
  __int64 v40; // x12
  __int64 v41; // x13
  float v42; // s0
  unsigned __int64 v43; // x14
  unsigned __int64 v44; // x8
  float v45; // s0
  __int64 v46; // x11
  __int8 *v47; // x9
  float v48; // s1
  float v49; // s2
  unsigned __int64 v50; // x12
  float v51; // s0
  float v52; // s0
  bool v53; // w8
  unsigned int v54; // w1
  float v55; // s0
  __int64 v56; // x0
  float v57; // s0
  float v58; // s2
  float v59; // s1
  float v60; // s0
  float v61; // s0
  float v62; // s1
  float v63; // s0
  int v64; // w8
  _BOOL8 v65; // x8
  float *v66; // x8
  float v67; // s8
  float v68; // s0
  float v69; // s5
  float v71; // s13
  float v72; // s14
  float v73; // s12
  float v74; // s0
  float v75; // s1
  float v76; // s11
  float v77; // s15
  int v78; // w8
  float v79; // s0
  float v80; // s1
  float v81; // s2
  float v82; // s2
  float v83; // s1
  float v84; // s0
  float v85; // s1
  float v86; // s0
  float cosx; // [xsp+38h] [xbp-158h] BYREF
  float sinx; // [xsp+3Ch] [xbp-154h] BYREF
  float v91; // [xsp+40h] [xbp-150h] BYREF
  float v92; // [xsp+44h] [xbp-14Ch] BYREF
  int v93; // [xsp+48h] [xbp-148h]
  __int128 v94; // [xsp+4Ch] [xbp-144h]
  __int128 v95; // [xsp+5Ch] [xbp-134h]
  __int128 v96; // [xsp+6Ch] [xbp-124h]
  int v97; // [xsp+7Ch] [xbp-114h]
  float32x4_t v98; // [xsp+80h] [xbp-110h]
  float32x4_t v99; // [xsp+90h] [xbp-100h]
  float32x4_t v100; // [xsp+A0h] [xbp-F0h]
  float v101; // [xsp+B0h] [xbp-E0h]
  _OWORD v102[2]; // [xsp+C0h] [xbp-D0h] BYREF
  __int64 v103; // [xsp+E0h] [xbp-B0h]
  __int64 v104; // [xsp+E8h] [xbp-A8h]

  v2 = 0.0;
  v104 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4 = *(_DWORD *)(a1 + 28);
  v5 = *(float *)(a1 + 80);
  *(float *)(a1 + 296) = *(float *)(a1 + 380) + (float)(*(float *)(a1 + 376) + (float)(*(float *)(a1 + 372) + 0.0));
  if ( (v4 & 0x30) != 0 )
    v6 = *(float *)(a1 + 40);
  else
    v6 = -11.5;
  v7 = -7.0;
  if ( (v4 & 0x10) != 0 && *(_DWORD *)(a1 + 32) )
  {
    v2 = *(float *)(a1 + 364);
    v7 = *(float *)(a1 + 336);
  }
  LODWORD(a2) = 7.0;
  eleq_update(*(_QWORD *)(a1 + 144), 1, a2, v6, v5, v2, v7);
  v8 = *(_QWORD *)(a1 + 56);
  v102[0] = xmmword_16980;
  v102[1] = xmmword_16990;
  v103 = 0x3F8000003F800000LL;
  graphic_equalizer_update(*(_QWORD *)(a1 + 152), v8, (unsigned __int64)v102);
  v9 = 20.0;
  if ( *(_BYTE *)(a1 + 68) )
  {
    v10 = *(float32x4_t **)(a1 + 312);
    __asm { FMOV            V0.4S, #1.0 }
    v16 = 1.0;
    *v10 = _Q0;
    v10[1] = _Q0;
    v10[2] = _Q0;
    v10[3].n128_u32[0] = 1065353216;
    if ( *(_DWORD *)(a1 + 48) )
    {
      LODWORD(v17) = *(_DWORD *)(a1 + 328);
      v18 = 0;
      while ( 1 )
      {
        v21 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 152) + 56LL) + 8 * v18);
        v22 = *(float **)(v21 + 32);
        v23 = *(float **)(v21 + 40);
        if ( (_DWORD)v17 )
        {
          memset(*(void **)(a1 + 320), 0, 4LL * (unsigned int)v17);
          LODWORD(v17) = *(_DWORD *)(a1 + 328);
        }
        if ( (_DWORD)v17 )
        {
          v24 = 0;
          do
          {
            v25 = *v23;
            v26 = *v22;
            v27 = (float)(unsigned int)v17;
            v28 = (double)(unsigned int)v24 * 3.14159265 / v27;
            sincosf(v28, &sinx, &cosx);
            v29 = v23[1];
            v30 = v22[1];
            v31 = cosx - (float)(sinx * 0.0);
            v32 = 0.0 - (float)(v30 * sinx);
            v33 = v31 * v29;
            v34 = v26 + (float)(v31 * v30);
            v35 = (double)(unsigned int)v24 * 6.28318531 / v27;
            *(float *)&v27 = 0.0 - (float)(v29 * sinx);
            v36 = v25 + v33;
            sincosf(v35, &v92, &v91);
            v37 = sub_64E70(
                    v36 + (float)((float)(v91 - (float)(v92 * 0.0)) * v23[2]),
                    *(float *)&v27 - (float)(v23[2] * v92),
                    v34 + (float)((float)(v91 - (float)(v92 * 0.0)) * v22[2]),
                    v32 - (float)(v22[2] * v92));
            *(float *)(*(_QWORD *)(a1 + 320) + 4 * v24) = cabsf(v37);
            v17 = *(unsigned int *)(a1 + 328);
            ++v24;
          }
          while ( v24 < v17 );
        }
        v38 = 0;
        v39 = 0;
        v94 = xmmword_16910;
        v93 = 0;
        v97 = 1202;
        v101 = 0.0;
        v95 = xmmword_16930;
        v96 = xmmword_16960;
        v98 = 0u;
        v99 = 0u;
        v100 = 0u;
        do
        {
          v40 = v39 + 1;
          v41 = (unsigned int)*(&v93 + v39 + 1);
          v42 = 0.0;
          if ( (unsigned int)v41 > v38 )
          {
            v43 = v38;
            v42 = 0.0;
            if ( v38 < (unsigned __int64)(unsigned int)v17 )
              goto LABEL_22;
            while ( v41 != ++v43 )
            {
              if ( v43 < (unsigned int)v17 )
LABEL_22:
                v42 = v42
                    + (float)(*(float *)(*(_QWORD *)(a1 + 320) + 4 * v43) * *(float *)(*(_QWORD *)(a1 + 320) + 4 * v43));
            }
          }
          v98.n128_f32[v39] = v42 / (float)((unsigned int)v41 - v38);
          v38 = v41;
          ++v39;
        }
        while ( v40 != 13 );
        v10 = *(float32x4_t **)(a1 + 312);
        ++v18;
        v19 = vmulq_f32(v98, *v10);
        v20 = vmulq_f32(v99, v10[1]);
        *v10 = v19;
        v10[1] = v20;
        v10[2] = vmulq_f32(v100, v10[2]);
        v10[3].n128_f32[0] = v101 * v10[3].n128_f32[0];
        if ( v18 >= *(unsigned int *)(a1 + 48) )
        {
          v9 = 20.0;
          v44 = *(unsigned int *)(a1 + 368);
          if ( !(_DWORD)v44 )
            goto LABEL_32;
          goto LABEL_27;
        }
      }
    }
    v19.n128_u32[0] = 1.0;
    v44 = *(unsigned int *)(a1 + 368);
    if ( !(_DWORD)v44 )
      goto LABEL_32;
LABEL_27:
    v45 = (float)(*(float *)(a1 + 372) * v19.n128_f32[0]) + 0.0;
    if ( (_DWORD)v44 != 1 )
    {
      v46 = 0;
      v47 = &v10->n128_i8[4];
      do
      {
        v48 = *(float *)&v47[4 * v46];
        v49 = *(float *)(a1 + 376 + 4 * v46);
        v50 = v46 + 2;
        ++v46;
        v45 = v45 + (float)(v49 * v48);
      }
      while ( v50 < v44 );
    }
    if ( v45 > 0.00000011921 )
    {
      v51 = log10f(v45);
      v16 = powf(10.0, (float)(v51 * -10.0) / v9);
    }
LABEL_32:
    *(float *)(a1 + 432) = v16;
  }
  else
  {
    *(_DWORD *)(a1 + 432) = 1065353216;
  }
  v52 = powf(10.0, *(float *)(a1 + 64) / v9);
  gain_update(*(_QWORD *)(a1 + 160), v52);
  if ( *(_DWORD *)(a1 + 280) == 2 )
  {
    v53 = (*(_BYTE *)(a1 + 28) & 4) == 0 || (*(_BYTE *)(a1 + 456) & 4) == 0;
    v54 = *(_DWORD *)(a1 + 72);
    v55 = *(float *)(a1 + 76);
    v56 = *(_QWORD *)(a1 + 168);
    *(_BYTE *)(a1 + 465) = v53;
    spatial_upmix_update(v56, v54, v55);
  }
  v57 = *(float *)(a1 + 332);
  v58 = *(float *)(a1 + 44);
  v59 = v57 + v58;
  if ( (*(_BYTE *)(a1 + 28) & 0x10) != 0 && *(_DWORD *)(a1 + 32) )
    v59 = v58 + fmaxf(*(float *)(a1 + 40), v57);
  v60 = 1.0;
  switch ( *(_DWORD *)(a1 + 72) )
  {
    case 1:
    case 2:
    case 6:
      v63 = fmaxf(fminf(v59 - *(float *)(a1 + 336), 0.0), -2.0) + 2.0;
      goto LABEL_47;
    case 3:
      v61 = fmaxf(fminf(v59 - *(float *)(a1 + 336), 0.0), -1.1);
      v62 = 1.1;
      goto LABEL_45;
    case 5:
      v61 = fmaxf(fminf(v59 - *(float *)(a1 + 336), 0.0), -4.0);
      v62 = 4.0;
LABEL_45:
      v63 = v61 + v62;
LABEL_47:
      v60 = powf(10.0, v63 / -20.0);
      break;
    default:
      break;
  }
  gain_update(*(_QWORD *)(a1 + 176), v60);
  gain_update(*(_QWORD *)(a1 + 184), 1.1);
  v64 = *(_DWORD *)(a1 + 72);
  v65 = v64 == 2 || v64 == 6 && *(_BYTE *)(a1 + 424);
  v66 = (float *)&dword_169A8[8 * v65];
  drc_update(*(_QWORD *)(a1 + 192), *v66, v66[1], v66[2], v66[3], v66[4], v66[5], v66[6], v66[7]);
  v67 = 1.0;
  gain_update(*(_QWORD *)(a1 + 200), 1.0);
  v68 = *(float *)(a1 + 40);
  v69 = 0.0;
  if ( v68 > -20.0 )
  {
    if ( v68 > -13.0 || v68 <= -20.0 )
      v69 = 2.0;
    else
      v69 = 1.0;
  }
  compressor_update(*(_QWORD *)(a1 + 216), 0.002, 0.01, -30.0, 0.4, 10.0, v69);
  v72 = *(float *)(a1 + 40);
  v71 = *(float *)(a1 + 44);
  v73 = *(float *)(a1 + 332);
  v74 = *(float *)(a1 + 336);
  v75 = *(float *)(a1 + 340);
  v76 = *(float *)(a1 + 344);
  v77 = *(float *)(a1 + 348);
  v78 = *(_DWORD *)(a1 + 32) - 1;
  *(_DWORD *)(a1 + 428) = 1065353216;
  switch ( v78 )
  {
    case 0:
      v79 = v72 + v71;
      goto LABEL_69;
    case 1:
      v85 = powf((float)(v72 + 18.0) / 10.0, 0.33333) * 0.707;
      v86 = sqrtf(v76 + v76);
      if ( v72 >= -10.0 && v76 != 0.0 )
        v85 = v85 + (float)(0.25 / v86);
      if ( (float)(v72 - v77) < (float)((float)(v72 + 10.0) / 3.0) || v72 <= v73 )
        v85 = 0.0;
      v83 = (float)((float)(v71 + (float)(v72 + (float)(v86 * v85))) - v73) / v9;
      v84 = 10.0;
      goto LABEL_80;
    case 2:
      v80 = v72 + v71;
      v81 = fminf(fminf(v72 + v71, v74), -10.0);
      if ( v73 <= (float)(v72 + v71) )
        v80 = v73;
      if ( v73 <= -10.0 )
        v80 = v81;
      v82 = fmaxf(v80, v73);
      if ( v74 == 0.0 )
        v79 = v82;
      else
        v79 = v80;
LABEL_69:
      v83 = (float)(v79 - v73) / v9;
      v84 = 10.0;
LABEL_80:
      v67 = powf(v84, v83);
      break;
    case 3:
      v67 = fminf(1.0 / (float)(v75 + 0.00001), powf(10.0, (float)((float)(v72 + v71) - v73) / v9));
      break;
    default:
      if ( v73 < -10.0 && v74 != 0.0 )
        v67 = powf(10.0, (float)(fmaxf(fminf(v71 + v73, v74), v73) - v73) / v9);
      *(float *)(a1 + 428) = v67;
      break;
  }
  gain_update(*(_QWORD *)(a1 + 224), v67);
  gain_update(*(_QWORD *)(a1 + 232), *(float *)(a1 + 428));
  return gain_update(*(_QWORD *)(a1 + 240), *(float *)(a1 + 432));
}
// 16910: using guessed type __int128 xmmword_16910;
// 16930: using guessed type __int128 xmmword_16930;
// 16960: using guessed type __int128 xmmword_16960;
// 16980: using guessed type __int128 xmmword_16980;
// 16990: using guessed type __int128;
// 169A8: using guessed type int dword_169A8[];
// 69D60: using guessed type float __fastcall cabsf(float);

//----- (0000000000033114) ----------------------------------------------------
__int64 __fastcall GSMO_FLUSH(__int64 a1)
{
  double v2; // d0

  if ( !a1 )
    return 1;
  if ( !*(_BYTE *)(a1 + 466) )
    return 3;
  dynamic_queue_flush(*(_QWORD *)(a1 + 112));
  channel_layout_converter_flush(*(_QWORD *)(a1 + 120));
  iir_flush(*(_QWORD *)(a1 + 128));
  sln_flush(*(_QWORD *)(a1 + 136));
  eleq_flush(*(_QWORD *)(a1 + 144));
  graphic_equalizer_flush(*(_QWORD *)(a1 + 152));
  gain_flush(*(_QWORD *)(a1 + 160));
  spatial_upmix_flush(*(_QWORD *)(a1 + 168));
  gain_flush(*(_QWORD *)(a1 + 176));
  gain_flush(*(_QWORD *)(a1 + 184));
  drc_flush(*(_QWORD *)(a1 + 192));
  gain_flush(*(_QWORD *)(a1 + 200));
  boost_gain_flush(*(_QWORD *)(a1 + 208));
  compressor_flush(*(_QWORD *)(a1 + 216));
  gain_flush(*(_QWORD *)(a1 + 224));
  gain_flush(*(_QWORD *)(a1 + 232));
  gain_flush(*(_QWORD *)(a1 + 240));
  limiter_flush(*(_QWORD *)(a1 + 248));
  sln_flush(*(_QWORD *)(a1 + 256));
  _update(a1, v2);
  return 0;
}
// 331CC: variable 'v2' is possibly undefined

//----- (00000000000331F0) ----------------------------------------------------
__int64 __fastcall GSMO_UPDATE(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  long double v5; // q0

  result = 1;
  if ( a1 && a2 )
  {
    if ( *(_BYTE *)(a1 + 466) )
    {
      result = _checkValidParams(a1, (_DWORD *)a1, a2);
      if ( !(_DWORD)result )
      {
        *(_BYTE *)(a1 + 464) = (unsigned int)lm1_wrapper_decode(*(_QWORD *)(a2 + 64), *(_DWORD *)(a2 + 72), a1 + 332) == 0;
        v5 = _copy_params(a1 + 24, a2);
        _update(a1, *(double *)&v5);
        if ( *(_BYTE *)(a1 + 464) )
          return 0;
        else
          return 13;
      }
    }
    else
    {
      return 3;
    }
  }
  return result;
}

//----- (0000000000033280) ----------------------------------------------------
__int64 __fastcall GSMO_PROCESS(unsigned int *a1, __int64 a2, int16x4_t *s, unsigned int a4, unsigned int *a5)
{
  unsigned int v5; // w8
  unsigned int v8; // w10

  v5 = 1;
  if ( !a1 || !a2 || !s )
    return v5;
  if ( !a4 )
    return 0;
  if ( !*((_BYTE *)a1 + 466) )
    return 3;
  if ( a1[113] )
    goto LABEL_7;
  v8 = dword_78AB0 + a4;
  dword_78AB0 += a4;
  if ( byte_78AB4 == 1 )
  {
    if ( dword_78AAC < v8 )
    {
      byte_78AB4 = 0;
      dword_78AB0 = 0;
      goto LABEL_7;
    }
  }
  else
  {
    if ( dword_78AA8 >= v8 )
    {
LABEL_7:
      switch ( a1[4] )
      {
        case 0u:
          dynamic_queue_process(*((unsigned int **)a1 + 14), a2, (__int64)s, a4);
          v5 = 0;
          if ( a5 )
            goto LABEL_26;
          break;
        case 1u:
          dynamic_queue_process_planar(*((unsigned int **)a1 + 14), a2, (__int64)s, a4);
          v5 = 0;
          if ( a5 )
            goto LABEL_26;
          break;
        case 2u:
          dynamic_queue_process_s16(*((unsigned int **)a1 + 14), a2, s, a4);
          v5 = 0;
          if ( a5 )
            goto LABEL_26;
          break;
        case 3u:
          dynamic_queue_process_s16_planar(*((unsigned int **)a1 + 14), a2, (__int64)s, a4);
          goto LABEL_25;
        default:
LABEL_25:
          v5 = 0;
          if ( a5 )
LABEL_26:
            *a5 = a4;
          break;
      }
      return v5;
    }
    byte_78AB4 = 1;
    dword_78AB0 = 0;
  }
  if ( a5 )
    *a5 = a4;
  memset(s, 0, 4 * a4 * (unsigned __int64)*a1);
  return 0;
}
// 78AA8: using guessed type int dword_78AA8;
// 78AAC: using guessed type int dword_78AAC;
// 78AB0: using guessed type int dword_78AB0;
// 78AB4: using guessed type char byte_78AB4;

//----- (00000000000333E4) ----------------------------------------------------
__int64 __fastcall GSMO_SET_PARAMETER(_BYTE *a1, char *s1, _DWORD *a3)
{
  __int64 result; // x0

  result = 1;
  if ( a1 && s1 && a3 )
  {
    if ( a1[466] )
    {
      if ( !strcmp(s1, "loudnorm.enableLoudnessMeasure") )
      {
        if ( (a1[456] & 0x30) != 0 )
        {
          result = 0;
          a1[448] = *a3 != 0;
        }
        else
        {
          return 11;
        }
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 3;
    }
  }
  return result;
}

//----- (000000000003346C) ----------------------------------------------------
__int64 __fastcall GSMO_GET_PARAMETER(__int64 a1, char *s1, float *a3)
{
  __int64 result; // x0
  float v7; // s0
  float v8; // s0
  float v9; // s8
  float v10; // s0
  int v11; // w8
  __int64 v12; // x8

  result = 1;
  if ( a1 && s1 && a3 )
  {
    if ( !*(_BYTE *)(a1 + 466) )
      return 3;
    if ( !strcmp(s1, "volume.attenuationOnly") )
    {
      if ( (*(_BYTE *)(a1 + 456) & 0x10) == 0 )
        return 11;
      if ( !*(_BYTE *)(a1 + 464) )
        return 13;
      v7 = powf(10.0, (float)((float)(*(float *)(a1 + 40) + *(float *)(a1 + 44)) - *(float *)(a1 + 332)) / 20.0);
      result = 0;
      v8 = fminf(v7, 1.0);
    }
    else
    {
      if ( !strcmp(s1, "volume.basic") )
      {
        if ( (*(_BYTE *)(a1 + 456) & 0x10) == 0 )
          return 11;
        if ( !*(_BYTE *)(a1 + 464) )
          return 13;
        v8 = powf(10.0, (float)((float)(*(float *)(a1 + 40) + *(float *)(a1 + 44)) - *(float *)(a1 + 332)) / 20.0);
        goto LABEL_37;
      }
      if ( strcmp(s1, "volume.transparent") )
      {
        if ( strcmp(s1, "loudnorm.inputIntegratedLoudness") )
        {
          if ( strcmp(s1, "loudnorm.calculatedGainDb") )
          {
            if ( strcmp(s1, "loudnorm.outputIntegratedLoudness") )
              return 12;
            if ( (*(_BYTE *)(a1 + 456) & 0x30) != 0 )
            {
              if ( !*(_BYTE *)(a1 + 448) )
                return 0xFFFFFFFFLL;
              v12 = *(_QWORD *)(a1 + 256);
              goto LABEL_36;
            }
            return 11;
          }
          if ( (*(_BYTE *)(a1 + 456) & 0x10) == 0 )
            return 11;
          if ( *(_BYTE *)(a1 + 464) )
          {
            result = 0;
            v8 = (float)(*(float *)(a1 + 40) + *(float *)(a1 + 44)) - *(float *)(a1 + 332);
            goto LABEL_38;
          }
          return 13;
        }
        if ( (*(_BYTE *)(a1 + 456) & 0x30) == 0 )
          return 11;
        v11 = *(_DWORD *)(a1 + 28);
        if ( (v11 & 0x20) != 0 )
        {
          v12 = *(_QWORD *)(a1 + 136);
LABEL_36:
          loudness_measure_getIntegratedLoudness(*(_QWORD *)(v12 + 80));
          goto LABEL_37;
        }
        v8 = 0.0;
        if ( (v11 & 0x10) != 0 )
        {
          if ( !*(_BYTE *)(a1 + 464) )
            return 13;
          v8 = *(float *)(a1 + 332);
        }
LABEL_37:
        result = 0;
        goto LABEL_38;
      }
      if ( (*(_BYTE *)(a1 + 456) & 0x10) == 0 )
        return 11;
      if ( !*(_BYTE *)(a1 + 464) )
        return 13;
      v9 = 1.0 / (float)(*(float *)(a1 + 340) + 0.00001);
      v10 = powf(10.0, (float)((float)(*(float *)(a1 + 40) + *(float *)(a1 + 44)) - *(float *)(a1 + 332)) / 20.0);
      result = 0;
      v8 = fminf(v9, v10);
    }
LABEL_38:
    *a3 = v8;
  }
  return result;
}
// 33688: variable 'v8' is possibly undefined

//----- (00000000000336A8) ----------------------------------------------------
__int64 __fastcall GSMO_GET_CAPS(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0

  result = 1;
  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 456);
    }
  }
  return result;
}

//----- (00000000000336C8) ----------------------------------------------------
__int64 __fastcall GSMO_GET_LATENCY(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0
  float v5; // s0
  float v6; // s1
  _BOOL4 v7; // w23
  float v8; // s8
  int v9; // w22
  int v10; // w8
  int v11; // w22
  int v12; // w8
  float v13; // s0
  int v14; // w8
  int v15; // w22
  int v16; // s0
  int v17; // w22
  int v18; // w9
  int v19; // w8
  int v20; // [xsp+4h] [xbp-3Ch] BYREF
  __int64 v21; // [xsp+8h] [xbp-38h]

  result = 1;
  v21 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a1 || !a2 )
    return result;
  if ( !*(_BYTE *)(a1 + 466) )
    return 3;
  v5 = (float)*(unsigned int *)(a1 + 8);
  v6 = (float)*(unsigned int *)(a1 + 292);
  if ( *(_BYTE *)(a1 + 24) )
    v7 = *(_DWORD *)(a1 + 72) != 0;
  else
    v7 = 0;
  v20 = 0;
  v8 = v5 / v6;
  dynamic_queue_get_latency(*(_QWORD *)(a1 + 112), &v20);
  v9 = v20;
  v20 = 0;
  resampler_get_latency(*(_QWORD *)(a1 + 104), &v20);
  v10 = v20;
  v20 = 0;
  v11 = v10 + v9;
  spatial_upmix_delay_sample_count(*(_QWORD *)(a1 + 168), &v20);
  v12 = *(_DWORD *)(a1 + 8);
  if ( v12 != 8000 && v12 != 32000 && v12 != 16000 )
  {
    v13 = v8 * (float)v20;
    goto LABEL_15;
  }
  if ( v7 )
  {
    v13 = (float)(v8 * (float)v20) / 2.3;
LABEL_15:
    v14 = (int)v13;
    v20 = (int)v13;
    goto LABEL_16;
  }
  v14 = 0;
  v20 = 0;
LABEL_16:
  v20 = 0;
  v15 = v11 + v14;
  drc_delay_sample_count(*(_QWORD *)(a1 + 192), &v20);
  v16 = v20;
  v20 = 0;
  v17 = v15 + (int)(float)(v8 * (float)v16);
  limiter_delay_sample_count(*(_QWORD *)(a1 + 248), &v20);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = v17 + (int)(float)(v8 * (float)v20);
  if ( v18 == 64000 )
  {
    ++v19;
  }
  else if ( v18 == 32000 )
  {
    v19 += 2;
  }
  result = 0;
  *a2 = v19;
  return result;
}

//----- (0000000000033898) ----------------------------------------------------
__int64 __fastcall GSMO_SET_PROFILE(__int64 a1, char *s)
{
  size_t v4; // x0
  _BYTE *v5; // x0
  size_t v6; // x22
  void *v7; // x20
  _BYTE *v8; // x21
  int v9; // w8
  __int64 v10; // x8
  int v12; // w9
  int v13; // w9
  int v14; // w9
  int v15; // w9
  int v16; // w9
  unsigned int v17; // w19
  int v18; // w9
  int v19; // w9
  int v20; // w9
  int v21; // w9
  int v22; // w9
  int v23; // w9
  size_t v24; // [xsp+8h] [xbp-128h] BYREF
  char nptr[8]; // [xsp+10h] [xbp-120h] BYREF
  __int64 v26; // [xsp+18h] [xbp-118h]
  _BYTE v27[192]; // [xsp+20h] [xbp-110h] BYREF
  char v28[24]; // [xsp+E0h] [xbp-50h] BYREF
  __int64 v29; // [xsp+F8h] [xbp-38h]

  v29 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a1 )
    return 1;
  if ( !s )
    return 2;
  if ( !strlen(s) )
    return 2;
  strcpy(v28, "gaudiolab1968!!!");
  v4 = strlen(s);
  v5 = base64_decode((unsigned __int8 *)s, v4, &v24);
  if ( !v5 )
    return 2;
  v6 = v24;
  v7 = v5;
  v8 = malloc((unsigned int)v24);
  *v8 = 0;
  memcpy(v8, v7, v6);
  AES_init_ctx();
  AES_ECB_decrypt(v27, v8);
  if ( *v8 == 103 || v8[1] == 117 || v8[2] == 100 )
  {
    *(_DWORD *)(a1 + 452) = (unsigned __int8)v8[3] - 48;
    v9 = (unsigned __int8)v8[4];
    *(_QWORD *)nptr = 0;
    v26 = 0;
    if ( v9 == 45 )
    {
      v10 = 0;
    }
    else
    {
      nptr[0] = v9;
      v10 = 1;
    }
    v12 = (unsigned __int8)v8[5];
    if ( v12 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      *(_BYTE *)((unsigned __int64)nptr | v10) = v12;
      v10 = (unsigned int)(v10 + 1);
    }
    v13 = (unsigned __int8)v8[6];
    if ( v13 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      *(_BYTE *)((unsigned __int64)nptr | v10) = v13;
      v10 = (unsigned int)(v10 + 1);
    }
    v14 = (unsigned __int8)v8[7];
    if ( v14 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      *(_BYTE *)((unsigned __int64)nptr | v10) = v14;
      LODWORD(v10) = v10 + 1;
    }
    v15 = (unsigned __int8)v8[8];
    if ( v15 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v15;
      LODWORD(v10) = v10 + 1;
    }
    v16 = (unsigned __int8)v8[9];
    if ( v16 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v16;
      LODWORD(v10) = v10 + 1;
    }
    v18 = (unsigned __int8)v8[10];
    if ( v18 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v18;
      LODWORD(v10) = v10 + 1;
    }
    v19 = (unsigned __int8)v8[11];
    if ( v19 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v19;
      LODWORD(v10) = v10 + 1;
    }
    v20 = (unsigned __int8)v8[12];
    if ( v20 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v20;
      LODWORD(v10) = v10 + 1;
    }
    v21 = (unsigned __int8)v8[13];
    if ( v21 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v21;
      LODWORD(v10) = v10 + 1;
    }
    v22 = (unsigned __int8)v8[14];
    if ( v22 == 45 )
    {
      if ( (_DWORD)v10 )
        goto LABEL_56;
    }
    else
    {
      nptr[(unsigned int)v10] = v22;
      LODWORD(v10) = v10 + 1;
    }
    v23 = (unsigned __int8)v8[15];
    if ( v23 != 45 )
    {
      nptr[(unsigned int)v10] = v23;
      goto LABEL_57;
    }
    if ( !(_DWORD)v10 )
    {
LABEL_57:
      v17 = 0;
      goto LABEL_58;
    }
LABEL_56:
    *(_DWORD *)(a1 + 456) = atoi(nptr);
    goto LABEL_57;
  }
  v17 = 2;
LABEL_58:
  free(v8);
  free(v7);
  return v17;
}

//----- (0000000000033B74) ----------------------------------------------------
__int64 __fastcall lm1_wrapper_decode(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v5; // x9
  unsigned __int64 v6; // x8
  int v7; // w10
  __int64 v8; // x9
  unsigned __int64 v9; // x10
  __int64 v10; // x10
  const float *v11; // x11
  unsigned __int128 *v12; // x12
  unsigned __int64 v13; // x13
  const float *v14; // x14
  unsigned __int128 v15; // q0
  unsigned __int128 v16; // q2
  int *v17; // x9
  int v18; // t1
  _QWORD v19[2]; // [xsp+0h] [xbp-20h] BYREF

  v19[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v19[0] = 0;
  if ( (unsigned int)lm1_decode(v19, a1, a2) )
    return 1;
  v5 = *(__int64 *)((char *)off_50 + v19[0]);
  v6 = *((unsigned __int8 *)&dword_40 + v5);
  *(_DWORD *)a3 = *(_DWORD *)((char *)&qword_18 + v5);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)&word_38 + v5);
  *(_DWORD *)(a3 + 8) = *(int *)((char *)&dword_7C + v5);
  *(_QWORD *)(a3 + 12) = *(__int64 *)((char *)&qword_28 + v5);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)((char *)&word_34 + v5);
  *(int32x2_t *)(a3 + 24) = vrev64_s32(*(int32x2_t *)((char *)&qword_80 + v5));
  v7 = *(int *)((char *)&dword_30 + v5);
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_DWORD *)(a3 + 32) = v7;
  *(_DWORD *)(a3 + 36) = v6;
  *(_DWORD *)(a3 + 88) = 0;
  if ( (_DWORD)v6 )
  {
    v8 = *(__int64 *)((char *)&qword_48 + v5);
    if ( (unsigned int)v6 > 8 && (a3 + 40 >= v8 + 8 * v6 || a3 + 4 * v6 + 40 <= v8 + 4) )
    {
      v10 = v6 & 7;
      if ( (v6 & 7) == 0 )
        v10 = 8;
      v9 = v6 - v10;
      v11 = (const float *)(v8 + 36);
      v12 = (unsigned __int128 *)(a3 + 56);
      v13 = v9;
      do
      {
        v14 = v11 - 8;
        v15 = (unsigned __int128)vld2q_f32(v11);
        v16 = (unsigned __int128)vld2q_f32(v14);
        v11 += 16;
        v13 -= 8LL;
        *(v12 - 1) = v16;
        *v12 = v15;
        v12 += 2;
      }
      while ( v13 );
    }
    else
    {
      v9 = 0;
    }
    v17 = (int *)(v8 + 8 * v9 + 4);
    do
    {
      v18 = *v17;
      v17 += 2;
      *(_DWORD *)(a3 + 40 + 4 * v9++) = v18;
    }
    while ( v9 < v6 );
  }
  *(_BYTE *)(a3 + 92) = *((_BYTE *)&qword_28 + v19[0]) | 2;
  lm1_free((__int64)v19);
  return 0;
}
// 18: using guessed type __int64;
// 28: using guessed type __int64 qword_28;
// 30: using guessed type int;
// 34: using guessed type __int16;
// 38: using guessed type __int16;
// 40: using guessed type int dword_40;
// 48: using guessed type __int64;
// 50: using guessed type int *off_50[4];
// 7C: using guessed type int;
// 80: using guessed type __int64 qword_80;

//----- (0000000000033CF4) ----------------------------------------------------
__int64 __fastcall sub_33CF4(_BYTE *a1, _BYTE *a2)
{
  __int64 v2; // x9
  _BYTE *v3; // x8
  __int64 result; // x0
  char v5; // w13
  char v6; // w15
  __int64 v7; // x12
  __int64 v8; // x13
  __int64 v9; // x14
  __int64 v10; // x15
  char v11; // w16

  v2 = 4;
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  a1[10] = a2[10];
  a1[11] = a2[11];
  a1[12] = a2[12];
  a1[13] = a2[13];
  a1[14] = a2[14];
  v3 = a1 + 19;
  a1[15] = a2[15];
  do
  {
    v7 = (unsigned __int8)*(v3 - 7);
    v8 = (unsigned __int8)*(v3 - 6);
    v9 = (unsigned __int8)*(v3 - 5);
    v10 = (unsigned __int8)*(v3 - 4);
    if ( (v2 & 3) == 0 )
    {
      v11 = byte_169E8[v8];
      LOBYTE(v8) = byte_169E8[v9];
      LOBYTE(v9) = byte_169E8[v10];
      LOBYTE(v10) = byte_169E8[v7];
      LOBYTE(v7) = byte_16AE8[(unsigned int)v2 >> 2] ^ v11;
    }
    result = (unsigned __int8)*(v3 - 17);
    ++v2;
    v5 = *(v3 - 18) ^ v8;
    v6 = *(v3 - 16) ^ v10;
    *(v3 - 3) = *(v3 - 19) ^ v7;
    *(v3 - 2) = v5;
    *(v3 - 1) = result ^ v9;
    *v3 = v6;
    v3 += 4;
  }
  while ( v2 != 44 );
  return result;
}
// 169E8: using guessed type _BYTE byte_169E8[256];
// 16AE8: using guessed type _BYTE byte_16AE8[11];

//----- (0000000000033E08) ----------------------------------------------------
long double __fastcall AES_init_ctx_iv(__int64 a1, _BYTE *a2, long double *a3)
{
  long double result; // q0

  sub_33CF4((_BYTE *)a1, a2);
  result = *a3;
  *(long double *)(a1 + 176) = *a3;
  return result;
}

//----- (0000000000033E34) ----------------------------------------------------
long double __fastcall AES_ctx_set_iv(__int64 a1, long double *a2)
{
  long double result; // q0

  result = *a2;
  *(long double *)(a1 + 176) = *a2;
  return result;
}

//----- (0000000000033E40) ----------------------------------------------------
__int64 __fastcall AES_ECB_encrypt(_BYTE *a1, unsigned __int8 *a2)
{
  return sub_33E50(a2, a1);
}

//----- (0000000000033E50) ----------------------------------------------------
__int64 __fastcall sub_33E50(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 v2; // w10
  unsigned __int8 v3; // w12
  unsigned __int8 v4; // w13
  unsigned __int8 v5; // w11
  unsigned __int8 v6; // w9
  unsigned __int8 v7; // w15
  unsigned __int8 v8; // w16
  unsigned __int8 v9; // w8
  unsigned __int8 v10; // w17
  unsigned __int8 v13; // w9
  unsigned int v14; // w21
  unsigned __int8 v15; // w10
  unsigned __int8 v16; // w14
  unsigned __int8 v17; // w13
  unsigned __int8 v18; // w12
  unsigned __int8 v19; // w13
  unsigned __int8 v20; // w15
  unsigned __int8 v21; // w0
  unsigned __int8 v22; // w2
  unsigned __int8 v23; // w3
  unsigned __int8 v24; // w17
  char v25; // w16
  unsigned __int8 v26; // w1
  unsigned __int8 v27; // w4
  unsigned __int8 v28; // w5
  unsigned __int8 v29; // w16
  unsigned __int8 v30; // w6
  unsigned __int8 v31; // w0
  unsigned __int8 v32; // w1
  unsigned __int8 v33; // w2
  unsigned __int8 v34; // w3
  unsigned __int8 v35; // w4
  unsigned __int8 v36; // w5
  __int64 v37; // x7
  __int64 v38; // x24
  __int64 v39; // x25
  __int64 v40; // x26
  __int64 v41; // x27
  __int64 v42; // x28
  __int64 v43; // x30
  unsigned __int8 v44; // w10
  unsigned __int8 v45; // w5
  unsigned __int8 v46; // w1
  unsigned __int8 v47; // w15
  unsigned __int8 v48; // w14
  unsigned __int8 v49; // w9
  unsigned __int8 v50; // w4
  __int64 result; // x0
  unsigned __int8 v52; // w17
  unsigned __int8 v53; // w13
  unsigned __int8 v54; // w11
  unsigned __int8 v55; // w3
  unsigned __int8 v56; // w2
  unsigned __int8 v57; // w16
  unsigned __int8 v58; // w12
  unsigned __int8 v59; // w8
  __int64 i; // x12
  char v61; // w15
  char v62; // w16
  char v63; // w17
  char v64; // w11
  char v65; // w14
  char v66; // w8
  unsigned __int8 *v67; // x13

  v2 = a1[1];
  v3 = a1[3];
  v4 = a1[4];
  v5 = *a1 ^ *a2;
  *a1 = v5;
  v6 = a1[2];
  v7 = a1[5];
  v8 = a1[7];
  v9 = v2 ^ a2[1];
  a1[1] = v9;
  v10 = a1[8];
  v13 = v6 ^ a2[2];
  a1[2] = v13;
  v14 = 1;
  v15 = v3 ^ a2[3];
  a1[3] = v15;
  v16 = v4 ^ a2[4];
  a1[4] = v16;
  v17 = a1[6];
  v18 = v7 ^ a2[5];
  a1[5] = v18;
  v19 = v17 ^ a2[6];
  a1[6] = v19;
  v20 = v8 ^ a2[7];
  a1[7] = v20;
  v21 = a1[9];
  v22 = a1[11];
  v23 = a1[12];
  v24 = v10 ^ a2[8];
  a1[8] = v24;
  v25 = a2[9];
  v26 = a1[10];
  v27 = a1[13];
  v28 = a1[14];
  v29 = v21 ^ v25;
  a1[9] = v29;
  v30 = a1[15];
  v31 = v26 ^ a2[10];
  a1[10] = v31;
  v32 = v22 ^ a2[11];
  a1[11] = v32;
  v33 = v23 ^ a2[12];
  a1[12] = v33;
  v34 = v27 ^ a2[13];
  a1[13] = v34;
  v35 = v28 ^ a2[14];
  a1[14] = v35;
  v36 = v30 ^ a2[15];
  a1[15] = v36;
  while ( 1 )
  {
    v37 = v13;
    v38 = v31;
    v39 = v35;
    v40 = v15;
    v41 = v20;
    v42 = v32;
    v43 = v36;
    v44 = byte_169E8[v5];
    v45 = byte_169E8[v16];
    v46 = byte_169E8[v24];
    v47 = byte_169E8[v33];
    v48 = byte_169E8[v9];
    v49 = byte_169E8[v18];
    v50 = byte_169E8[v29];
    result = (unsigned __int8)byte_169E8[v34];
    v52 = byte_169E8[v37];
    v53 = byte_169E8[v19];
    v54 = byte_169E8[v38];
    v55 = byte_169E8[v39];
    v56 = byte_169E8[v40];
    v57 = byte_169E8[v41];
    v58 = byte_169E8[v42];
    v59 = byte_169E8[v43];
    *a1 = v44;
    a1[4] = v45;
    a1[8] = v46;
    a1[12] = v47;
    a1[1] = v49;
    a1[5] = v50;
    a1[9] = result;
    a1[13] = v48;
    a1[2] = v54;
    a1[10] = v52;
    a1[6] = v55;
    a1[14] = v53;
    a1[3] = v59;
    a1[15] = v58;
    a1[11] = v57;
    a1[7] = v56;
    if ( (unsigned __int8)v14 > 9u )
      break;
    for ( i = 0; ; i += 4 )
    {
      v61 = v54 ^ v49;
      v62 = v59 ^ v54;
      v63 = v59 ^ v44;
      v64 = v49 ^ v44 ^ v54;
      v65 = v59 ^ v49 ^ v44 ^ (2 * v62);
      v66 = v64 ^ v59;
      v67 = &a1[i];
      v67[2] = v65 ^ ((unsigned int)v62 >> 7) & 0x1B;
      *v67 = v44 ^ (2 * (v49 ^ v44)) ^ ((unsigned int)(char)(v49 ^ v44) >> 7) & 0x1B ^ v66;
      v67[1] = v49 ^ (2 * v61) ^ v66 ^ ((unsigned int)v61 >> 7) & 0x1B;
      v67[3] = v64 ^ (2 * v63) ^ ((unsigned int)v63 >> 7) & 0x1B;
      if ( i == 12 )
        break;
      v44 = v67[4];
      v49 = v67[5];
      v54 = v67[6];
      v59 = v67[7];
    }
    sub_34DB4(v14, a1, (__int64)a2);
    v5 = *a1;
    v16 = a1[4];
    v24 = a1[8];
    v33 = a1[12];
    v9 = a1[1];
    v18 = a1[5];
    v29 = a1[9];
    v34 = a1[13];
    v13 = a1[2];
    v19 = a1[6];
    v31 = a1[10];
    v35 = a1[14];
    v15 = a1[3];
    v20 = a1[7];
    v32 = a1[11];
    v36 = a1[15];
    ++v14;
  }
  *a1 = a2[160] ^ v44;
  a1[1] = a2[161] ^ v49;
  a1[2] = a2[162] ^ v54;
  a1[3] = a2[163] ^ v59;
  a1[4] = a2[164] ^ v45;
  a1[5] = a2[165] ^ v50;
  a1[6] = a2[166] ^ v55;
  a1[7] = a2[167] ^ v56;
  a1[8] = a2[168] ^ v46;
  a1[9] = a2[169] ^ result;
  a1[10] = a2[170] ^ v52;
  a1[11] = a2[171] ^ v57;
  a1[12] = a2[172] ^ v47;
  a1[13] = a2[173] ^ v48;
  a1[14] = a2[174] ^ v53;
  a1[15] = a2[175] ^ v58;
  return result;
}
// 169E8: using guessed type _BYTE byte_169E8[256];

//----- (0000000000034220) ----------------------------------------------------
__int64 __fastcall AES_ECB_decrypt(_BYTE *a1, unsigned __int8 *a2)
{
  return sub_34230(a2, a1);
}

//----- (0000000000034230) ----------------------------------------------------
__int64 __fastcall sub_34230(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 v2; // w10
  unsigned __int8 v3; // w11
  unsigned __int8 v4; // w12
  unsigned __int8 v5; // w15
  unsigned __int8 v6; // w9
  unsigned __int8 v8; // w13
  unsigned __int8 v9; // w10
  unsigned __int8 v10; // w14
  unsigned __int8 v11; // w16
  unsigned __int8 v12; // w17
  unsigned __int8 v13; // w9
  unsigned int v15; // w21
  unsigned __int8 v16; // w8
  unsigned __int8 v17; // w1
  unsigned __int8 v18; // w12
  unsigned __int8 v19; // w13
  unsigned __int8 v20; // w11
  unsigned __int8 v21; // w12
  unsigned __int8 v22; // w4
  unsigned __int8 v23; // w0
  unsigned __int8 v24; // w2
  unsigned __int8 v25; // w3
  unsigned __int8 v26; // w16
  unsigned __int8 v27; // w6
  unsigned __int8 v28; // w17
  unsigned __int8 v29; // w0
  unsigned __int8 v30; // w14
  unsigned __int8 v31; // w5
  unsigned __int8 v32; // w2
  unsigned __int8 v33; // w3
  unsigned __int8 v34; // w2
  unsigned __int8 v35; // w0
  __int64 v36; // x6
  __int64 v37; // x7
  __int64 v38; // x23
  __int64 v39; // x24
  unsigned __int8 v40; // w5
  unsigned __int8 v41; // w1
  unsigned __int8 v42; // w15
  unsigned __int8 v43; // w11
  unsigned __int8 v44; // w4
  unsigned __int8 v45; // w0
  unsigned __int8 v46; // w14
  unsigned __int8 v47; // w10
  unsigned __int8 v48; // w3
  unsigned __int8 v49; // w17
  unsigned __int8 v50; // w13
  unsigned __int8 v51; // w9
  unsigned __int8 v52; // w2
  unsigned __int8 v53; // w16
  unsigned __int8 v54; // w12
  unsigned __int8 v55; // w8
  int16x4_t v56; // d3
  int16x4_t v57; // d4
  int8x8_t v58; // d0
  int16x4_t v59; // d1
  int8x8_t v60; // d2
  int8x8_t v61; // d5
  int8x8_t v62; // d20
  int8x8_t v63; // d21
  int8x8_t v64; // d19
  int8x8_t v65; // d18
  int16x4_t v66; // d17
  int8x8_t v67; // d2
  int8x8_t v68; // d24
  int8x8_t v69; // d16
  int8x8_t v70; // d19
  int16x4_t v71; // d23
  int8x8_t v72; // d22
  int8x8_t v73; // d5
  int8x8_t v74; // d7
  int8x8_t v75; // d18
  int8x8_t v76; // d24
  int8x8_t v77; // d3
  int8x8_t v78; // d21
  int8x8_t v79; // d4
  int8x8_t v80; // d6
  int8x8_t v81; // d22
  int8x8_t v82; // d20
  int8x8_t v83; // d17
  int8x8_t v84; // d23
  int8x8_t v85; // d4
  int8x8_t v86; // d0
  int8x8_t v87; // d6
  int8x8_t v88; // d17
  int8x8_t v89; // d2
  int8x8_t v90; // d18
  int8x8_t v91; // d1
  int8x8_t v92; // d3
  int8x8_t v93; // d7
  int8x8_t v94; // d1
  int8x8_t v95; // d0
  int8x8_t v96; // d2
  int8x8_t v97; // d5
  int8x8_t v98; // d6
  int8x8_t v99; // d0
  int8x8_t v100; // d1
  unsigned __int64 v101; // d2
  unsigned __int64 v102; // d3
  __int128 v103; // q0
  unsigned __int64 v104; // d1
  char v105; // w16
  char v106; // w0
  char v107; // w2
  char v108; // w4
  __int64 result; // x0

  v2 = a1[1];
  v3 = a1[3];
  v4 = a1[4];
  v5 = *a1 ^ a2[160];
  *a1 = v5;
  v6 = a1[2];
  v8 = a1[5];
  v9 = v2 ^ a2[161];
  a1[1] = v9;
  v10 = a1[7];
  v11 = a1[8];
  v12 = a1[9];
  v13 = v6 ^ a2[162];
  a1[2] = v13;
  v15 = 9;
  v16 = v3 ^ a2[163];
  a1[3] = v16;
  v17 = v4 ^ a2[164];
  a1[4] = v17;
  v18 = a1[6];
  v19 = v8 ^ a2[165];
  a1[5] = v19;
  v20 = v18 ^ a2[166];
  a1[6] = v20;
  v21 = v10 ^ a2[167];
  a1[7] = v21;
  v22 = v11 ^ a2[168];
  a1[8] = v22;
  v23 = a1[10];
  v24 = a1[11];
  v25 = a1[13];
  v26 = v12 ^ a2[169];
  a1[9] = v26;
  v27 = a1[15];
  v28 = v23 ^ a2[170];
  a1[10] = v28;
  v29 = a1[12];
  v30 = v24 ^ a2[171];
  a1[11] = v30;
  v31 = v29 ^ a2[172];
  a1[12] = v31;
  v32 = a1[14];
  v33 = v25 ^ a2[173];
  a1[13] = v33;
  v34 = v32 ^ a2[174];
  a1[14] = v34;
  v35 = v27 ^ a2[175];
  a1[15] = v35;
  while ( 1 )
  {
    v36 = v31;
    v37 = v20;
    v38 = v30;
    v39 = v35;
    v40 = byte_16AF3[v5];
    v41 = byte_16AF3[v17];
    v42 = byte_16AF3[v22];
    v43 = byte_16AF3[v36];
    v44 = byte_16AF3[v33];
    v45 = byte_16AF3[v9];
    v46 = byte_16AF3[v19];
    v47 = byte_16AF3[v26];
    v48 = byte_16AF3[v28];
    v49 = byte_16AF3[v34];
    v50 = byte_16AF3[v13];
    v51 = byte_16AF3[v37];
    v52 = byte_16AF3[v21];
    v53 = byte_16AF3[v38];
    v54 = byte_16AF3[v39];
    v55 = byte_16AF3[v16];
    *a1 = v40;
    a1[4] = v41;
    a1[8] = v42;
    a1[12] = v43;
    a1[1] = v44;
    a1[5] = v45;
    a1[9] = v46;
    a1[13] = v47;
    a1[2] = v48;
    a1[6] = v49;
    a1[10] = v50;
    a1[14] = v51;
    a1[3] = v52;
    a1[7] = v53;
    a1[11] = v54;
    a1[15] = v55;
    if ( !(_BYTE)v15 )
      break;
    sub_34DB4(v15--, a1, (__int64)a2);
    v56.n64_u16[0] = (unsigned __int8)*(_OWORD *)a1;
    v57.n64_u16[0] = (unsigned __int8)BYTE1(*(_OWORD *)a1);
    v58.n64_u16[0] = (unsigned __int8)BYTE2(*(_OWORD *)a1);
    v59.n64_u16[0] = BYTE3(*(_OWORD *)a1);
    v56.n64_u16[1] = (unsigned __int8)BYTE4(*(_QWORD *)a1);
    v57.n64_u16[1] = (unsigned __int8)((unsigned __int16)WORD2(*(_QWORD *)a1) >> 8);
    v58.n64_u16[1] = (unsigned __int8)BYTE6(*(_QWORD *)a1);
    v59.n64_u16[1] = (unsigned __int8)HIBYTE(*(_QWORD *)a1);
    v56.n64_u16[2] = (unsigned __int8)*((_QWORD *)a1 + 1);
    v57.n64_u16[2] = (unsigned __int8)BYTE1(*((_QWORD *)a1 + 1));
    v58.n64_u16[2] = (unsigned __int8)BYTE2(*((_QWORD *)a1 + 1));
    v59.n64_u16[2] = BYTE3(*((_QWORD *)a1 + 1));
    v56.n64_u16[3] = (unsigned __int8)BYTE12(*(_OWORD *)a1);
    v57.n64_u16[3] = (unsigned __int8)((unsigned __int16)WORD6(*(_OWORD *)a1) >> 8);
    v58.n64_u16[3] = (unsigned __int8)BYTE14(*(_OWORD *)a1);
    v59.n64_u16[3] = (unsigned __int8)HIBYTE(*(_OWORD *)a1);
    v60.n64_u64[0] = vshl_n_s16(v56, 1u).n64_u64[0];
    v61.n64_u64[0] = vshl_n_s16(v57, 1u).n64_u64[0];
    v62.n64_u64[0] = veor_s8(v58, v57).n64_u64[0];
    v63.n64_u64[0] = veor_s8(v58, v56).n64_u64[0];
    v64.n64_u64[0] = vshl_n_s16(v59, 1u).n64_u64[0];
    v65.n64_u64[0] = vshl_n_s16(v58, 1u).n64_u64[0];
    v66.n64_u64[0] = vshl_n_s16(v60, 8u).n64_u64[0];
    v67.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v56, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       v60).n64_u64[0];
    v68.n64_u64[0] = vshr_n_s16(vshr_n_s16(vshl_n_s16(v64, 8u), 8u), 7u).n64_u64[0];
    v69.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v59, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       v64).n64_u64[0];
    v70.n64_u64[0] = vshl_n_s16(v67, 1u).n64_u64[0];
    v71.n64_u64[0] = vshr_n_s16(vshl_n_s16(v65, 8u), 8u).n64_u64[0];
    v72.n64_u64[0] = vshr_n_s16(vshr_n_s16(vshl_n_s16(v61, 8u), 8u), 7u).n64_u64[0];
    v73.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v57, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       v61).n64_u64[0];
    v74.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v58, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       v65).n64_u64[0];
    v75.n64_u64[0] = vand_s8(v68, (int8x8_t)0x1B001B001B001BLL).n64_u64[0];
    v76.n64_u64[0] = vshl_n_s16(v69, 1u).n64_u64[0];
    v77.n64_u64[0] = veor_s8(v69, veor_s8(v57, v56)).n64_u64[0];
    v78.n64_u64[0] = veor_s8(v63, v59).n64_u64[0];
    v79.n64_u64[0] = vand_s8(vshr_n_s16(vshr_n_s16(v66, 8u), 7u), (int8x8_t)0x1B001B001B001BLL).n64_u64[0];
    v80.n64_u64[0] = vand_s8(v72, (int8x8_t)0x1B001B001B001BLL).n64_u64[0];
    v81.n64_u64[0] = vshl_n_s16(v73, 1u).n64_u64[0];
    v82.n64_u64[0] = veor_s8(veor_s8(v62, v67), v59).n64_u64[0];
    v83.n64_u64[0] = vand_s8(vshr_n_s16(v71, 7u), (int8x8_t)0x1B001B001B001BLL).n64_u64[0];
    v84.n64_u64[0] = vshl_n_s16(v74, 1u).n64_u64[0];
    v85.n64_u64[0] = veor_s8(v70, v79).n64_u64[0];
    v86.n64_u64[0] = veor_s8(veor_s8(v77, v58), v67).n64_u64[0];
    v87.n64_u64[0] = veor_s8(v81, v80).n64_u64[0];
    v88.n64_u64[0] = veor_s8(v84, v83).n64_u64[0];
    v89.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v70, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       vshl_n_s16(v85, 1u)).n64_u64[0];
    v90.n64_u64[0] = veor_s8(v76, v75).n64_u64[0];
    v91.n64_u64[0] = veor_s8(veor_s8(veor_s8(v77, v59), v85), v74).n64_u64[0];
    v92.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v81, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       vshl_n_s16(v87, 1u)).n64_u64[0];
    v93.n64_u64[0] = veor_s8(veor_s8(veor_s8(veor_s8(v78, v73), v74), v87), v89).n64_u64[0];
    v94.n64_u64[0] = veor_s8(v91, v89).n64_u64[0];
    v95.n64_u64[0] = veor_s8(veor_s8(v86, v87), v89).n64_u64[0];
    v96.n64_u64[0] = veor_s8(veor_s8(veor_s8(veor_s8(v82, v73), v85), v89), v88).n64_u64[0];
    v97.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v84, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       vshl_n_s16(v88, 1u)).n64_u64[0];
    v98.n64_u64[0] = veor_s8(
                       vand_s8(vshr_n_s16(vshr_n_s16(vshl_n_s16(v76, 8u), 8u), 7u), (int8x8_t)0x1B001B001B001BLL),
                       vshl_n_s16(v90, 1u)).n64_u64[0];
    v99.n64_u64[0] = veor_s8(veor_s8(v95, v92), v90).n64_u64[0];
    v100.n64_u64[0] = veor_s8(veor_s8(v94, v88), v92).n64_u64[0];
    v101 = veor_s8(veor_s8(veor_s8(v96, v92), v97), v98).n64_u64[0];
    v102 = veor_s8(veor_s8(veor_s8(veor_s8(v93, v92), v90), v97), v98).n64_u64[0];
    *(int8x8_t *)&v103 = veor_s8(veor_s8(v99, v97), v98);
    v104 = veor_s8(veor_s8(v100, v97), v98).n64_u64[0];
    v105 = BYTE6(v103);
    v106 = BYTE4(v103);
    v107 = BYTE2(v103);
    v108 = v103;
    LOBYTE(v103) = v101;
    BYTE1(v103) = v102;
    BYTE2(v103) = v104;
    BYTE3(v103) = v108;
    BYTE4(v103) = BYTE2(v101);
    BYTE5(v103) = BYTE2(v102);
    BYTE6(v103) = BYTE2(v104);
    BYTE7(v103) = v107;
    BYTE8(v103) = BYTE4(v101);
    BYTE9(v103) = BYTE4(v102);
    BYTE10(v103) = BYTE4(v104);
    BYTE11(v103) = v106;
    BYTE12(v103) = BYTE6(v101);
    BYTE13(v103) = BYTE6(v102);
    BYTE14(v103) = BYTE6(v104);
    HIBYTE(v103) = v105;
    *(_OWORD *)a1 = v103;
    v33 = a1[13];
    v26 = a1[9];
    v19 = a1[5];
    v9 = a1[1];
    v13 = a1[2];
    v28 = a1[10];
    v20 = a1[6];
    v34 = a1[14];
    v16 = a1[3];
    v21 = a1[7];
    v30 = a1[11];
    v35 = a1[15];
    v5 = *a1;
    v17 = a1[4];
    v22 = a1[8];
    v31 = a1[12];
  }
  *a1 = *a2 ^ v40;
  a1[1] = a2[1] ^ v44;
  a1[2] = a2[2] ^ v48;
  a1[3] = a2[3] ^ v52;
  a1[4] = a2[4] ^ v41;
  a1[5] = a2[5] ^ v45;
  result = (unsigned __int8)a2[6];
  a1[6] = result ^ v49;
  a1[7] = a2[7] ^ v53;
  a1[8] = a2[8] ^ v42;
  a1[9] = a2[9] ^ v46;
  a1[10] = a2[10] ^ v50;
  a1[11] = a2[11] ^ v54;
  a1[12] = a2[12] ^ v43;
  a1[13] = a2[13] ^ v47;
  a1[14] = a2[14] ^ v51;
  a1[15] = a2[15] ^ v55;
  return result;
}
// 16AF3: using guessed type _BYTE byte_16AF3[257];

//----- (0000000000034818) ----------------------------------------------------
long double __fastcall AES_CBC_encrypt_buffer(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _OWORD *v3; // x21
  long double *v4; // x8
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x23
  _BYTE *v9; // x8
  _BYTE *v10; // x24
  _BYTE *v11; // x0
  long double result; // q0

  v3 = a1 + 176;
  v4 = (long double *)(a1 + 176);
  if ( a3 )
  {
    v7 = 0;
    v8 = a3;
    v9 = a1 + 176;
    v10 = a2;
    do
    {
      v11 = &a2[v7];
      *v11 = a2[v7] ^ *v9;
      v11[1] = a2[v7 + 1] ^ v9[1];
      v11[2] = a2[v7 + 2] ^ v9[2];
      v11[3] = a2[v7 + 3] ^ v9[3];
      v11[4] = a2[v7 + 4] ^ v9[4];
      v11[5] = a2[v7 + 5] ^ v9[5];
      v11[6] = a2[v7 + 6] ^ v9[6];
      v11[7] = a2[v7 + 7] ^ v9[7];
      v11[8] = a2[v7 + 8] ^ v9[8];
      v11[9] = a2[v7 + 9] ^ v9[9];
      v11[10] = a2[v7 + 10] ^ v9[10];
      v11[11] = a2[v7 + 11] ^ v9[11];
      v11[12] = a2[v7 + 12] ^ v9[12];
      v11[13] = a2[v7 + 13] ^ v9[13];
      v11[14] = a2[v7 + 14] ^ v9[14];
      v11[15] = a2[v7 + 15] ^ v9[15];
      sub_33E50(&a2[v7], a1);
      v7 += 16LL;
      v9 = v10;
      v10 += 16;
    }
    while ( v7 < v8 );
    v4 = (long double *)&a2[v7 - 16];
  }
  result = *v4;
  *v3 = *(_OWORD *)v4;
  return result;
}

//----- (0000000000034998) ----------------------------------------------------
__int64 __fastcall AES_CBC_decrypt_buffer(__int64 result, __int64 a2, unsigned int a3)
{
  _BYTE *v4; // x20
  unsigned __int64 v5; // x23
  unsigned __int64 v6; // x24
  _OWORD *v7; // x25
  _BYTE *v8; // x21
  __int128 v9; // [xsp+0h] [xbp-60h]

  _ReadStatusReg(TPIDR_EL0);
  if ( a3 )
  {
    v4 = (_BYTE *)result;
    v5 = 0;
    v6 = a3;
    v7 = (_OWORD *)(result + 176);
    do
    {
      v8 = (_BYTE *)(a2 + v5);
      v9 = *(_OWORD *)(a2 + v5);
      result = sub_34230((unsigned __int8 *)(a2 + v5), v4);
      v5 += 16LL;
      *v8 ^= v4[176];
      v8[1] ^= v4[177];
      v8[2] ^= v4[178];
      v8[3] ^= v4[179];
      v8[4] ^= v4[180];
      v8[5] ^= v4[181];
      v8[6] ^= v4[182];
      v8[7] ^= v4[183];
      v8[8] ^= v4[184];
      v8[9] ^= v4[185];
      v8[10] ^= v4[186];
      v8[11] ^= v4[187];
      v8[12] ^= v4[188];
      v8[13] ^= v4[189];
      v8[14] ^= v4[190];
      v8[15] ^= v4[191];
      *v7 = v9;
    }
    while ( v5 < v6 );
  }
  return result;
}

//----- (0000000000034B34) ----------------------------------------------------
__int64 __fastcall AES_CTR_xcrypt_buffer(__int64 result, _BYTE *a2, unsigned int a3)
{
  _BYTE *v4; // x20
  unsigned __int8 *v5; // x22
  __int64 v6; // x23
  _BYTE *v7; // x24
  _BYTE *v8; // x25
  _BYTE *v9; // x26
  _BYTE *v10; // x27
  int v11; // w10
  unsigned __int8 v12; // w9
  int v13; // w8
  _BYTE *v14; // x9
  _BYTE *v15; // [xsp+8h] [xbp-C8h]
  _BYTE *v16; // [xsp+10h] [xbp-C0h]
  _BYTE *v17; // [xsp+18h] [xbp-B8h]
  _BYTE *v18; // [xsp+20h] [xbp-B0h]
  _BYTE *v19; // [xsp+28h] [xbp-A8h]
  _BYTE *v20; // [xsp+30h] [xbp-A0h]
  _BYTE *v21; // [xsp+38h] [xbp-98h]
  _BYTE *v22; // [xsp+40h] [xbp-90h]
  _BYTE *v23; // [xsp+48h] [xbp-88h]
  _BYTE *v24; // [xsp+50h] [xbp-80h]
  _BYTE *v25; // [xsp+58h] [xbp-78h]
  unsigned __int8 v26[24]; // [xsp+60h] [xbp-70h] BYREF
  __int64 v27; // [xsp+78h] [xbp-58h]

  v27 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a3 )
  {
    v25 = (_BYTE *)(result + 187);
    v24 = (_BYTE *)(result + 186);
    v23 = (_BYTE *)(result + 185);
    v22 = (_BYTE *)(result + 184);
    v21 = (_BYTE *)(result + 183);
    v20 = (_BYTE *)(result + 182);
    v19 = (_BYTE *)(result + 181);
    v18 = (_BYTE *)(result + 180);
    v17 = (_BYTE *)(result + 179);
    v4 = (_BYTE *)result;
    v5 = (unsigned __int8 *)(result + 176);
    v6 = a3;
    v7 = (_BYTE *)(result + 191);
    v8 = (_BYTE *)(result + 190);
    v9 = (_BYTE *)(result + 189);
    v10 = (_BYTE *)(result + 188);
    v16 = (_BYTE *)(result + 178);
    v15 = (_BYTE *)(result + 177);
LABEL_6:
    *(_OWORD *)v26 = *(_OWORD *)v5;
    result = sub_33E50(v26, v4);
    v13 = (unsigned __int8)v4[191];
    v14 = v7;
    if ( v13 != 255 )
      goto LABEL_3;
    *v7 = 0;
    v13 = (unsigned __int8)*v8;
    v14 = v8;
    if ( v13 != 255 )
      goto LABEL_3;
    *v8 = 0;
    v13 = (unsigned __int8)*v9;
    v14 = v9;
    if ( v13 != 255 )
      goto LABEL_3;
    *v9 = 0;
    v13 = (unsigned __int8)*v10;
    v14 = v10;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v25;
    *v10 = 0;
    v13 = (unsigned __int8)*v25;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v24;
    *v25 = 0;
    v13 = (unsigned __int8)*v24;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v23;
    *v24 = 0;
    v13 = (unsigned __int8)*v23;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v22;
    *v23 = 0;
    v13 = (unsigned __int8)*v22;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v21;
    *v22 = 0;
    v13 = (unsigned __int8)*v21;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v20;
    *v21 = 0;
    v13 = (unsigned __int8)*v20;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v19;
    *v20 = 0;
    v13 = (unsigned __int8)*v19;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v18;
    *v19 = 0;
    v13 = (unsigned __int8)*v18;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v17;
    *v18 = 0;
    v13 = (unsigned __int8)*v17;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v16;
    *v17 = 0;
    v13 = (unsigned __int8)*v16;
    if ( v13 != 255 )
      goto LABEL_3;
    v14 = v15;
    *v16 = 0;
    v13 = (unsigned __int8)*v15;
    if ( v13 == 255 && (v14 = v5, *v15 = 0, v13 = *v5, v13 == 255) )
    {
      v11 = 0;
      *v5 = 0;
    }
    else
    {
LABEL_3:
      v11 = 0;
      *v14 = v13 + 1;
    }
    while ( 1 )
    {
      v12 = v26[v11];
      --v6;
      ++v11;
      *a2++ ^= v12;
      if ( !v6 )
        break;
      if ( v11 == 16 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (0000000000034DB4) ----------------------------------------------------
__int64 __fastcall sub_34DB4(__int64 result, _BYTE *a2, __int64 a3)
{
  *a2 ^= *(_BYTE *)(a3 + 16LL * (unsigned __int8)result);
  a2[1] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 1));
  a2[2] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 2));
  a2[3] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 3));
  a2[4] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 4));
  a2[5] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 5));
  a2[6] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 6));
  a2[7] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 7));
  a2[8] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 8));
  a2[9] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 9));
  a2[10] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xA));
  a2[11] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xB));
  a2[12] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xC));
  a2[13] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xD));
  a2[14] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xE));
  a2[15] ^= *(_BYTE *)(a3 + ((16LL * (unsigned __int8)result) | 0xF));
  return result;
}

//----- (0000000000034F38) ----------------------------------------------------
char *__fastcall base64_encode(unsigned __int8 *a1, size_t a2, _QWORD *a3)
{
  size_t v3; // x8
  char *result; // x0
  __int64 v7; // x21
  int v8; // w9
  unsigned __int8 *v9; // x11
  char *v10; // x8
  unsigned __int64 v11; // x13
  unsigned __int64 v12; // x14
  unsigned __int64 v13; // x13
  unsigned __int64 v14; // x11
  char v15; // w12
  __int64 v16; // x11
  char v17; // w10
  unsigned __int64 v18; // x12

  v3 = 4 * a2 / 3 + (4 * a2 / 3 + 4) / 0x48 + 5;
  if ( v3 < a2 )
    return 0;
  v7 = a2;
  result = (char *)malloc(v3);
  if ( result )
  {
    v8 = 0;
    if ( v7 < 3 )
    {
      v10 = result;
    }
    else
    {
      v9 = &a1[v7];
      v10 = result;
      do
      {
        v11 = *a1;
        v8 += 4;
        *v10 = aAbcdefghijklmn[v11 >> 2];
        v12 = a1[1];
        v10[1] = aAbcdefghijklmn[(16 * (int)v11) & 0x30LL | (v12 >> 4)];
        v13 = a1[2];
        a1 += 3;
        LOBYTE(v12) = aAbcdefghijklmn[(4 * (int)v12) & 0x3CLL | (v13 >> 6)];
        LOBYTE(v13) = aAbcdefghijklmn[v13 & 0x3F];
        v10[2] = v12;
        v10[3] = v13;
        if ( v8 < 72 )
        {
          v10 += 4;
        }
        else
        {
          v8 = 0;
          v10[4] = 10;
          v10 += 5;
        }
        v7 = v9 - a1;
      }
      while ( v9 - a1 > 2 );
    }
    if ( v7 )
    {
      v14 = *a1;
      v15 = aAbcdefghijklmn[v14 >> 2];
      v16 = (16 * (int)v14) & 0x30LL;
      *v10 = v15;
      if ( v7 == 1 )
      {
        v10[1] = aAbcdefghijklmn[v16];
        v17 = 61;
      }
      else
      {
        v18 = a1[1];
        v17 = aAbcdefghijklmn[(4 * (int)v18) & 0x3CLL];
        v10[1] = aAbcdefghijklmn[v16 | (v18 >> 4)];
      }
      v10[2] = v17;
      v10[3] = 61;
      v10 += 4;
      v8 += 4;
    }
    if ( v8 )
      *v10++ = 10;
    *v10 = 0;
    if ( a3 )
      *a3 = v10 - result;
  }
  return result;
}

//----- (00000000000350DC) ----------------------------------------------------
_BYTE *__fastcall base64_decode(unsigned __int8 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // x20
  unsigned __int8 *v5; // x21
  __int64 v6; // x8
  __int128 v7; // q0
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x8
  _BYTE *result; // x0
  __int64 v11; // x9
  __int64 v12; // x10
  unsigned __int8 *v13; // x11
  unsigned __int64 v14; // x13
  __int64 v15; // x14
  unsigned int v16; // t1
  int v17; // w15
  __int64 v18; // x10
  unsigned __int8 *v19; // x8
  unsigned int v20; // t1
  _BYTE *v21; // x8
  int v22; // w9
  __int64 v23; // x12
  __int64 v24; // x14
  int v25; // w13
  char v26; // w14
  int v27; // w12
  char v28; // [xsp+Ch] [xbp-144h]
  unsigned __int8 v29; // [xsp+Dh] [xbp-143h]
  unsigned __int8 v30; // [xsp+Eh] [xbp-142h]
  char v31; // [xsp+Fh] [xbp-141h]
  _OWORD v32[3]; // [xsp+10h] [xbp-140h]
  __int128 v33; // [xsp+40h] [xbp-110h]
  __int128 v34; // [xsp+50h] [xbp-100h]
  __int128 v35; // [xsp+60h] [xbp-F0h]
  __int128 v36; // [xsp+70h] [xbp-E0h]
  __int128 v37; // [xsp+80h] [xbp-D0h]
  __int128 v38; // [xsp+90h] [xbp-C0h]
  __int128 v39; // [xsp+A0h] [xbp-B0h]
  __int128 v40; // [xsp+B0h] [xbp-A0h]
  __int128 v41; // [xsp+C0h] [xbp-90h]
  __int128 v42; // [xsp+D0h] [xbp-80h]
  __int128 v43; // [xsp+E0h] [xbp-70h]
  __int128 v44; // [xsp+F0h] [xbp-60h]
  __int128 v45; // [xsp+100h] [xbp-50h]
  __int64 v46; // [xsp+118h] [xbp-38h]

  v4 = a2;
  v5 = a1;
  v46 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = 0;
  *(_QWORD *)&v7 = 0x8080808080808080LL;
  *((_QWORD *)&v7 + 1) = 0x8080808080808080LL;
  v32[0] = v7;
  v32[1] = v7;
  v32[2] = v7;
  v33 = v7;
  v34 = v7;
  v35 = v7;
  v36 = v7;
  v37 = v7;
  v38 = v7;
  v39 = v7;
  v40 = v7;
  v41 = v7;
  v42 = v7;
  v43 = v7;
  v44 = v7;
  v45 = v7;
  do
  {
    *((_BYTE *)v32 + (unsigned __int8)aAbcdefghijklmn[v6]) = v6;
    ++v6;
  }
  while ( v6 != 64 );
  BYTE13(v33) = 0;
  if ( !a2 )
    return 0;
  if ( a2 == 1 )
  {
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v9 = a2 & 0xFFFFFFFFFFFFFFFELL;
    v11 = 0;
    v12 = 0;
    v13 = a1 + 1;
    v14 = a2 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v15 = *(v13 - 1);
      v16 = *v13;
      v13 += 2;
      v17 = *((unsigned __int8 *)v32 + v16);
      if ( *((unsigned __int8 *)v32 + v15) != 128 )
        ++v11;
      if ( v17 != 128 )
        ++v12;
      v14 -= 2LL;
    }
    while ( v14 );
    v8 = v12 + v11;
    if ( v9 == a2 )
      goto LABEL_18;
  }
  v18 = a2 - v9;
  v19 = &a1[v9];
  do
  {
    v20 = *v19++;
    if ( *((unsigned __int8 *)v32 + v20) != 128 )
      ++v8;
    --v18;
  }
  while ( v18 );
LABEL_18:
  result = 0;
  if ( !v8 )
    return result;
  if ( (v8 & 3) != 0 )
    return result;
  result = malloc(3 * (v8 >> 2));
  if ( !result )
    return result;
  v21 = result;
  if ( !v4 )
    goto LABEL_34;
  v22 = 0;
  v23 = 0;
  v21 = result;
  while ( 1 )
  {
    v24 = *v5;
    v25 = *((unsigned __int8 *)v32 + v24);
    if ( v25 == 128 )
      goto LABEL_23;
    *(&v28 + v23++) = v25;
    if ( (_DWORD)v24 == 61 )
      ++v22;
    if ( v23 != 4 )
      goto LABEL_23;
    v26 = v31 | (v30 << 6);
    v27 = (v30 >> 2) | (16 * v29);
    *v21 = (v29 >> 4) | (4 * v28);
    v21[1] = v27;
    v21[2] = v26;
    if ( v22 )
      break;
    v23 = 0;
    v21 += 3;
LABEL_23:
    --v4;
    ++v5;
    if ( !v4 )
      goto LABEL_34;
  }
  if ( v22 == 1 )
  {
    v21 += 2;
LABEL_34:
    *a3 = v21 - result;
  }
  else
  {
    if ( v22 == 2 )
    {
      ++v21;
      goto LABEL_34;
    }
    free(result);
    return 0;
  }
  return result;
}

//----- (00000000000352FC) ----------------------------------------------------
__int64 __fastcall static_resampler_get_internal_sample_rate(int a1, int *a2)
{
  int v3; // w9
  bool v4; // cc
  __int64 result; // x0
  int v6; // w10

  v3 = 48000;
  v4 = a1 <= 31999;
  result = 3;
  if ( !v4 )
  {
    if ( a1 <= 88199 )
    {
      if ( a1 <= 47999 )
      {
        if ( a1 != 32000 )
        {
          if ( a1 != 44100 )
            return result;
          goto LABEL_26;
        }
LABEL_27:
        result = 0;
        *a2 = v3;
        return result;
      }
      if ( a1 == 48000 )
        goto LABEL_27;
      v6 = 64000;
      goto LABEL_22;
    }
    if ( a1 > 176399 )
    {
      if ( a1 == 192000 )
        goto LABEL_27;
      if ( a1 != 176400 )
        return result;
    }
    else if ( a1 != 88200 )
    {
      v6 = 96000;
      goto LABEL_22;
    }
LABEL_26:
    v3 = 44100;
    goto LABEL_27;
  }
  if ( a1 <= 11999 )
  {
    if ( a1 == 6000 || a1 == 8000 )
      goto LABEL_27;
    if ( a1 == 11025 )
      goto LABEL_26;
    return result;
  }
  if ( a1 <= 22049 )
  {
    if ( a1 == 12000 )
      goto LABEL_27;
    v6 = 16000;
    goto LABEL_22;
  }
  if ( a1 == 22050 )
    goto LABEL_26;
  v6 = 24000;
LABEL_22:
  if ( a1 == v6 )
    goto LABEL_27;
  return result;
}

//----- (000000000003542C) ----------------------------------------------------
long double __fastcall resampler_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x90u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[7] = 0u;
    v2[8] = 0u;
    v2[5] = 0u;
    v2[6] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (0000000000035494) ----------------------------------------------------
__int64 __fastcall resampler_destroy(__int64 *a1)
{
  __int64 v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  result = (__int64)sub_354E0(v2);
  if ( !(_DWORD)result )
  {
    result = *a1;
    if ( *a1 )
    {
      free((void *)result);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

//----- (00000000000354E0) ----------------------------------------------------
void *__fastcall sub_354E0(__int64 a1)
{
  void *result; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0

  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    return 0;
  result = (void *)iir_destroy((__int64 *)(a1 + 120));
  if ( !(_DWORD)result )
  {
    result = (void *)iir_destroy((__int64 *)(a1 + 128));
    if ( !(_DWORD)result )
    {
      v3 = *(void **)(a1 + 80);
      if ( v3 )
      {
        free(v3);
        *(_QWORD *)(a1 + 80) = 0;
      }
      v4 = *(void **)(a1 + 88);
      if ( v4 )
      {
        free(v4);
        *(_QWORD *)(a1 + 88) = 0;
      }
      if ( !*(_BYTE *)(a1 + 40) )
        return 0;
      result = (void *)iir_destroy((__int64 *)(a1 + 136));
      if ( !(_DWORD)result )
      {
        v5 = *(void **)(a1 + 96);
        if ( v5 )
        {
          free(v5);
          *(_QWORD *)(a1 + 96) = 0;
        }
        v6 = *(void **)(a1 + 104);
        if ( v6 )
        {
          free(v6);
          *(_QWORD *)(a1 + 104) = 0;
        }
        result = *(void **)(a1 + 112);
        if ( result )
        {
          free(result);
          result = 0;
          *(_QWORD *)(a1 + 112) = 0;
        }
      }
    }
  }
  return result;
}

//----- (0000000000035594) ----------------------------------------------------
void __fastcall resampler_setup(unsigned int *a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v5; // w20
  unsigned int v10; // w9
  unsigned int v11; // w8
  int v12; // w10
  float v13; // s1
  float v14; // s0
  float v20; // s0
  float v21; // s2
  char *v22; // x12
  char *v23; // x10
  char *v24; // x11
  char *v25; // x12
  float v26; // s1
  __int128 v27; // q1
  __int128 v28; // q2
  __int128 v29; // q2
  __int128 v30; // q3
  float v31; // s2
  float v32; // s0
  int v33; // w0
  int v34; // w0
  void *v35; // x0
  __int64 v36; // x8
  size_t v37; // x20
  void *v38; // x0
  int v39; // w0
  void *v40; // x0
  size_t v41; // x20
  void *v42; // x0
  size_t v43; // x20
  void *v44; // x0
  size_t v45; // x20

  if ( !a1 )
    return;
  v5 = a2;
  if ( !a2 || *((_BYTE *)a1 + 42) && (unsigned int)sub_354E0((__int64)a1) )
    return;
  v10 = 48000;
  if ( a5 )
    v11 = a5;
  else
    v11 = v5;
  a1[7] = a4;
  *(_WORD *)((char *)a1 + 41) = 0;
  *((_BYTE *)a1 + 40) = 1;
  *a1 = v5;
  a1[1] = v11;
  a1[2] = a3;
  if ( a3 > 31999 )
  {
    if ( a3 <= 88199 )
    {
      if ( a3 <= 47999 )
      {
        if ( a3 == 32000 )
          goto LABEL_36;
        if ( a3 != 44100 )
          return;
        goto LABEL_35;
      }
      if ( a3 == 48000 )
        goto LABEL_36;
      v12 = 64000;
      goto LABEL_31;
    }
    if ( a3 > 176399 )
    {
      if ( a3 == 192000 )
        goto LABEL_36;
      if ( a3 != 176400 )
        return;
      goto LABEL_35;
    }
    if ( a3 != 88200 )
    {
      v12 = 96000;
      goto LABEL_31;
    }
    goto LABEL_35;
  }
  if ( a3 <= 11999 )
  {
    if ( a3 == 6000 || a3 == 8000 )
      goto LABEL_36;
    if ( a3 != 11025 )
      return;
    goto LABEL_35;
  }
  if ( a3 <= 22049 )
  {
    if ( a3 == 12000 )
      goto LABEL_36;
    v12 = 16000;
    goto LABEL_31;
  }
  if ( a3 == 22050 )
  {
LABEL_35:
    v10 = 44100;
    goto LABEL_36;
  }
  v12 = 24000;
LABEL_31:
  if ( a3 != v12 )
    return;
LABEL_36:
  v13 = (float)v10;
  a1[3] = v10;
  if ( a3 <= 31999 )
  {
    v20 = (float)(unsigned int)a3;
    if ( a3 <= 11999 )
    {
      if ( a3 == 6000 || a3 == 8000 )
      {
LABEL_57:
        v14 = v13 / v20;
        v24 = (char *)&unk_16D74;
        v25 = (char *)&unk_16DA4;
LABEL_65:
        a1[8] = 1065353216;
        *(_QWORD *)&v27 = v24;
        *(_QWORD *)&v28 = v25;
        *((_QWORD *)&v27 + 1) = v24 + 24;
        *((_QWORD *)&v28 + 1) = v25 + 24;
        *((float *)a1 + 9) = v14;
        goto LABEL_66;
      }
    }
    else
    {
      if ( a3 <= 22049 )
      {
        if ( a3 != 12000 && a3 != 16000 )
          return;
        goto LABEL_57;
      }
      if ( a3 != 22050 )
      {
        if ( a3 != 24000 )
          return;
        goto LABEL_57;
      }
    }
    v14 = v13 / v20;
    v24 = (char *)&unk_16E94;
    v25 = (char *)&unk_16EC4;
    goto LABEL_65;
  }
  v14 = 1.0;
  if ( a3 <= 88199 )
  {
    __asm { FMOV            V2.2S, #1.0 }
    if ( !(_NF ^ _VF | _ZF) )
    {
      if ( a3 != 48000 )
      {
        if ( a3 != 64000 )
          return;
        v21 = 64000.0;
        v22 = (char *)&unk_16CB4;
        v23 = (char *)&unk_16CE4;
        goto LABEL_70;
      }
LABEL_63:
      v26 = 1.0;
      v14 = 1.0;
      *((_QWORD *)a1 + 4) = _D2;
      goto LABEL_71;
    }
    if ( a3 != 32000 )
    {
      if ( a3 != 44100 )
        return;
      goto LABEL_63;
    }
    a1[8] = 1065353216;
    v14 = v13 / 32000.0;
    *(_QWORD *)&v27 = &unk_16D14;
    *(_QWORD *)&v28 = &unk_16D44;
    *((_QWORD *)&v27 + 1) = &unk_16D2C;
    *((float *)a1 + 9) = v14;
    *((_QWORD *)&v28 + 1) = &unk_16D5C;
LABEL_66:
    *((_OWORD *)a1 + 3) = v27;
    *((_OWORD *)a1 + 4) = v28;
    v26 = 1.0;
    goto LABEL_71;
  }
  if ( a3 > 176399 )
  {
    if ( a3 == 176400 )
    {
      v21 = 176400.0;
      v22 = (char *)&unk_16DD4;
      v23 = (char *)&unk_16E04;
    }
    else
    {
      v21 = 192000.0;
      v22 = (char *)&unk_16BF4;
      v23 = (char *)&unk_16C24;
    }
  }
  else if ( a3 == 88200 )
  {
    v21 = 88200.0;
    v22 = (char *)&unk_16E34;
    v23 = (char *)&unk_16E64;
  }
  else
  {
    if ( a3 != 96000 )
      return;
    v21 = 96000.0;
    v22 = (char *)&unk_16C54;
    v23 = (char *)&unk_16C84;
  }
LABEL_70:
  v26 = v21 / v13;
  a1[9] = 1065353216;
  *(_QWORD *)&v29 = v22;
  *(_QWORD *)&v30 = v23;
  *((_QWORD *)&v29 + 1) = v22 + 24;
  *((_QWORD *)&v30 + 1) = v23 + 24;
  *((float *)a1 + 8) = v26;
  *((_OWORD *)a1 + 3) = v29;
  *((_OWORD *)a1 + 4) = v30;
LABEL_71:
  v31 = (float)a4;
  *((_BYTE *)a1 + 40) = 0;
  a1[6] = 0;
  a1[4] = a4;
  if ( v10 >= a3 )
    v32 = v14 * v31;
  else
    v32 = v31 / v26;
  if ( (unsigned int)v32 > a4 )
    a4 = (unsigned int)v32;
  a1[5] = (unsigned int)v32;
  if ( v10 == a3 )
  {
    *((_BYTE *)a1 + 41) = 1;
LABEL_78:
    *((_BYTE *)a1 + 42) = 1;
    return;
  }
  if ( v11 >= v5 )
    v5 = v11;
  iir_create((_QWORD *)a1 + 15);
  if ( !v33 )
  {
    iir_create((_QWORD *)a1 + 16);
    if ( !v34
      && !(unsigned int)iir_setup(*((_QWORD *)a1 + 15), *a1, a4, 5, *((float **)a1 + 9), *((float **)a1 + 8))
      && !(unsigned int)iir_setup(*((_QWORD *)a1 + 16), a1[1], a4, 5, *((float **)a1 + 9), *((float **)a1 + 8)) )
    {
      v35 = (void *)*((_QWORD *)a1 + 10);
      v36 = a4 * v5;
      v37 = 4 * v36;
      if ( v35 || (v35 = malloc(4 * v36), (*((_QWORD *)a1 + 10) = v35) != 0) )
      {
        memset(v35, 0, v37);
        v38 = (void *)*((_QWORD *)a1 + 11);
        if ( v38 || (v38 = malloc(v37), (*((_QWORD *)a1 + 11) = v38) != 0) )
        {
          memset(v38, 0, v37);
          if ( !*((_BYTE *)a1 + 40) )
            goto LABEL_78;
          iir_create((_QWORD *)a1 + 17);
          if ( v39
            || (unsigned int)iir_setup(*((_QWORD *)a1 + 17), *a1, a1[4], 5, *((float **)a1 + 7), *((float **)a1 + 6)) )
          {
            return;
          }
          v40 = (void *)*((_QWORD *)a1 + 12);
          if ( v40 )
          {
            v41 = 4 * a1[4] * (unsigned __int64)*a1;
          }
          else
          {
            v41 = 4 * a1[4] * (unsigned __int64)*a1;
            v40 = malloc(v41);
            *((_QWORD *)a1 + 12) = v40;
            if ( !v40 )
              goto LABEL_103;
          }
          memset(v40, 0, v41);
          v42 = (void *)*((_QWORD *)a1 + 13);
          if ( v42 )
          {
            v43 = 4 * a1[4] * (unsigned __int64)*a1;
          }
          else
          {
            v43 = 4 * a1[4] * (unsigned __int64)*a1;
            v42 = malloc(v43);
            *((_QWORD *)a1 + 13) = v42;
            if ( !v42 )
              goto LABEL_103;
          }
          memset(v42, 0, v43);
          v44 = (void *)*((_QWORD *)a1 + 14);
          if ( v44 )
          {
            v45 = 4 * a1[6] * (unsigned __int64)*a1;
LABEL_102:
            memset(v44, 0, v45);
            goto LABEL_78;
          }
          v45 = 4 * a1[6] * (unsigned __int64)*a1;
          v44 = malloc(v45);
          *((_QWORD *)a1 + 14) = v44;
          if ( v44 )
            goto LABEL_102;
        }
      }
LABEL_103:
      exit(1);
    }
  }
}
// 3582C: conditional instruction was optimized away because w21.4==2B11
// 358BC: conditional instruction was optimized away because w21.4==2EE00
// 35A4C: variable 'v33' is possibly undefined
// 35A58: variable 'v34' is possibly undefined
// 35B0C: variable 'v39' is possibly undefined

//----- (0000000000035C10) ----------------------------------------------------
__int64 __fastcall resampler_run_external_to_internal(unsigned int *a1, void *src, void *dest)
{
  unsigned int v7; // w8
  unsigned int v8; // w9
  unsigned int v9; // w10
  __int64 v10; // x13
  __int64 v11; // x12
  unsigned int v12; // w14
  float v13; // s1
  unsigned int v14; // w8
  unsigned __int64 v15; // x9
  unsigned int v16; // w10
  __int64 v17; // x12
  float v18; // s0
  unsigned __int64 v19; // x11
  unsigned int v20; // w13
  float v21; // s1
  unsigned __int64 v22; // x10
  unsigned __int64 v23; // x11
  unsigned int v24; // w9
  __int64 v25; // x15
  __int64 v26; // x16
  unsigned __int64 v27; // x14
  unsigned int v28; // w17
  __int64 v29; // x0
  int v30; // w1
  __int64 v31; // x14
  unsigned int v32; // w15
  unsigned __int64 v33; // x16
  int v34; // w17
  unsigned int v35; // w0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 42) )
    return 9;
  if ( *((_BYTE *)a1 + 41) )
  {
    memcpy(dest, src, 4 * a1[7] * (unsigned __int64)*a1);
  }
  else
  {
    v7 = *a1;
    if ( *a1 )
    {
      v8 = 0;
      v9 = (unsigned int)(float)(*((float *)a1 + 9) * (float)a1[4]);
      if ( v9 )
        goto LABEL_11;
      while ( ++v8 < v7 )
      {
        if ( v9 )
        {
LABEL_11:
          v10 = *((_QWORD *)a1 + 10);
          v11 = 0;
          v12 = v8;
          do
          {
            v13 = (float)(unsigned int)v11++;
            *(_DWORD *)(v10 + 4LL * v12) = *((_DWORD *)src + v8 + v7 * (int)(float)(v13 / *((float *)a1 + 9)));
            v12 += v7;
          }
          while ( v9 != v11 );
        }
      }
    }
    iir_process(*((unsigned int **)a1 + 15), *((_QWORD *)a1 + 10), *((_QWORD *)a1 + 11));
    v14 = *a1;
    if ( *a1 )
    {
      v15 = a1[5];
      v16 = 0;
      if ( (_DWORD)v15 )
        goto LABEL_18;
      while ( ++v16 < v14 )
      {
        if ( (_DWORD)v15 )
        {
LABEL_18:
          v17 = *((_QWORD *)a1 + 11);
          v18 = *((float *)a1 + 8);
          v19 = 0;
          v20 = v16;
          do
          {
            v21 = v18 * (float)(unsigned int)v19++;
            *((_DWORD *)dest + v20) = *(_DWORD *)(v17 + 4LL * (v16 + v14 * (int)v21));
            v20 += v14;
          }
          while ( v19 < v15 );
        }
      }
    }
    if ( *((_BYTE *)a1 + 40) )
    {
      if ( v14 )
      {
        v22 = a1[6];
        v23 = a1[4];
        v24 = 0;
        if ( (_DWORD)v22 )
          goto LABEL_27;
        while ( 1 )
        {
          if ( (unsigned int)v22 < (unsigned int)v23 )
          {
            v31 = *((_QWORD *)a1 + 13);
            v32 = v24;
            v33 = v22;
            do
            {
              v34 = *((_DWORD *)src + v32);
              ++v33;
              v35 = v22 * v14 + v32;
              v32 += v14;
              *(_DWORD *)(v31 + 4LL * v35) = v34;
            }
            while ( v33 < v23 );
          }
          if ( ++v24 == v14 )
            break;
          if ( (_DWORD)v22 )
          {
LABEL_27:
            v25 = *((_QWORD *)a1 + 13);
            v26 = *((_QWORD *)a1 + 14);
            v27 = 0;
            v28 = v24;
            do
            {
              v29 = 4LL * v28;
              ++v27;
              *(_DWORD *)(v25 + v29) = *(_DWORD *)(v26 + v29);
              v30 = *((_DWORD *)src + v14 * ((_DWORD)v23 - (_DWORD)v22) + v28);
              v28 += v14;
              *(_DWORD *)(v26 + v29) = v30;
            }
            while ( v27 < v22 );
          }
        }
      }
      iir_process(*((unsigned int **)a1 + 17), *((_QWORD *)a1 + 13), *((_QWORD *)a1 + 12));
    }
  }
  return 0;
}

//----- (0000000000035E18) ----------------------------------------------------
__int64 __fastcall resampler_run_internal_to_external(__int64 a1, const void *a2, char *dest)
{
  unsigned int v6; // w8
  unsigned int v7; // w9
  unsigned int v8; // w10
  __int64 v9; // x13
  __int64 v10; // x12
  unsigned int v11; // w14
  float v12; // s1
  unsigned int v13; // w8
  unsigned __int64 v14; // x9
  int v15; // w10
  __int64 v16; // x12
  float v17; // s0
  unsigned __int64 v18; // x11
  int v19; // w13
  int v20; // w14
  unsigned __int64 v21; // x10
  __int64 v22; // x9
  __int64 v23; // x15
  unsigned __int64 v24; // x16
  unsigned int v25; // w17
  __int64 v26; // x0
  __int64 v27; // x16
  unsigned int v28; // w17
  __int64 v29; // x0
  float32x4_t *v30; // x1
  float32x4_t *v31; // x0
  float32x4_t v32; // q1
  unsigned __int64 v33; // x10
  unsigned int v34; // w9
  unsigned __int64 v35; // x17
  int v36; // w0
  float v37; // s0
  int v38; // s1
  __int64 v39; // x0
  unsigned int v40; // w1
  __int64 v41; // x2
  float v42; // s0
  __int64 v43; // x17
  float v44; // s1
  _BOOL4 v45; // w3
  _BOOL4 v46; // w4
  _BOOL4 v47; // w5
  _BOOL4 v48; // w7

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 42) )
  {
    if ( *(_BYTE *)(a1 + 41) )
    {
      memcpy(dest, a2, 4 * *(unsigned int *)(a1 + 28) * (unsigned __int64)*(unsigned int *)(a1 + 4));
      return 0;
    }
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
    {
      v7 = 0;
      v8 = (unsigned int)(float)(*(float *)(a1 + 32) * (float)*(unsigned int *)(a1 + 20));
      if ( v8 )
        goto LABEL_12;
      while ( ++v7 < v6 )
      {
        if ( v8 )
        {
LABEL_12:
          v9 = *(_QWORD *)(a1 + 80);
          v10 = 0;
          v11 = v7;
          do
          {
            v12 = (float)(unsigned int)v10++;
            *(_DWORD *)(v9 + 4LL * v11) = *((_DWORD *)a2 + v7 + v6 * (int)(float)(v12 / *(float *)(a1 + 32)));
            v11 += v6;
          }
          while ( v8 != v10 );
        }
      }
    }
    iir_process(*(unsigned int **)(a1 + 128), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88));
    v13 = *(_DWORD *)(a1 + 4);
    if ( !v13 )
      return 0;
    v14 = *(unsigned int *)(a1 + 16);
    v15 = 0;
    if ( (_DWORD)v14 )
      goto LABEL_19;
    while ( ++v15 < v13 )
    {
      if ( (_DWORD)v14 )
      {
LABEL_19:
        v16 = *(_QWORD *)(a1 + 88);
        v17 = *(float *)(a1 + 36);
        v18 = 0;
        v19 = v15;
        do
        {
          v20 = *(_DWORD *)(v16 + 4LL * (v15 + v13 * (int)(float)(v17 * (float)(unsigned int)v18++)));
          *(_DWORD *)&dest[4 * v19] = v20;
          v19 += v13;
        }
        while ( v18 < v14 );
      }
    }
    if ( *(_BYTE *)(a1 + 40) )
    {
      v21 = *(unsigned int *)(a1 + 16);
      v22 = 0;
      if ( (_DWORD)v21 )
        goto LABEL_26;
      while ( 1 )
      {
        do
        {
          if ( (_DWORD)++v22 == v13 )
            goto LABEL_40;
        }
        while ( !(_DWORD)v21 );
LABEL_26:
        v23 = *(_QWORD *)(a1 + 96);
        if ( (unsigned int)v21 <= 7 )
          break;
        v24 = 0;
        if ( v13 == 1 && ~(_DWORD)v22 >= (unsigned int)(v21 - 1) && !((v21 - 1) >> 32) )
        {
          if ( (unsigned __int64)&dest[4 * v22] < v23 + 4 * (v22 + v21)
            && v23 + 4 * v22 < (unsigned __int64)&dest[4 * v22 + 4 * v21] )
          {
            break;
          }
          v27 = (unsigned int)v21 & 0xFFFFFFF8;
          v28 = v22;
          do
          {
            v29 = 4LL * v28;
            v30 = (float32x4_t *)(v23 + v29);
            v31 = (float32x4_t *)&dest[v29];
            v27 -= 8;
            v28 += 8 * v13;
            v32 = vaddq_f32(v30[1], v31[1]);
            *v31 = vaddq_f32(*v30, *v31);
            v31[1] = v32;
          }
          while ( v27 );
          v24 = (unsigned int)v21 & 0xFFFFFFF8;
          if ( v24 == v21 )
            continue;
        }
LABEL_33:
        v25 = v22 + v13 * v24;
        do
        {
          v26 = 4LL * v25;
          ++v24;
          v25 += v13;
          *(float *)&dest[v26] = *(float *)(v23 + v26) + *(float *)&dest[v26];
        }
        while ( v24 < v21 );
      }
      v24 = 0;
      goto LABEL_33;
    }
LABEL_40:
    v33 = *(unsigned int *)(a1 + 16);
    v34 = 0;
    if ( (_DWORD)v33 )
      goto LABEL_43;
    while ( 1 )
    {
      do
      {
        if ( ++v34 == v13 )
          return 0;
      }
      while ( !(_DWORD)v33 );
LABEL_43:
      if ( (_DWORD)v33 == 1 )
        break;
      v35 = 0;
      if ( v13 == 1 && ~v34 >= (int)v33 - 1 )
      {
        v39 = (unsigned int)v33 & 0xFFFFFFFE;
        v40 = v34;
        if ( !((v33 - 1) >> 32) )
        {
          do
          {
            v41 = 4LL * v40;
            v42 = *(float *)&dest[v41];
            v43 = 4LL * (v40 + 1);
            v44 = *(float *)&dest[v43];
            v45 = v42 <= 0.9999;
            v46 = v44 <= 0.9999;
            v47 = v42 < -0.9999;
            v48 = v44 < -0.9999;
            if ( !v45 || v42 < -0.9999 )
              v42 = 0.9999;
            if ( !v46 || v44 < -0.9999 )
              v44 = 0.9999;
            if ( v47 && v45 )
              v42 = -0.9999;
            if ( v48 && v46 )
              v44 = -0.9999;
            v39 -= 2;
            v40 += 2 * v13;
            *(float *)&dest[v41] = v42;
            *(float *)&dest[v43] = v44;
          }
          while ( v39 );
          v35 = (unsigned int)v33 & 0xFFFFFFFE;
          if ( v35 == v33 )
            continue;
        }
      }
LABEL_45:
      v36 = v34 + v13 * v35;
      do
      {
        v37 = *(float *)&dest[4 * v36];
        v38 = 1065351538;
        if ( v37 <= 0.9999 )
        {
          v38 = -1082132110;
          if ( v37 >= -0.9999 )
            v38 = *(_DWORD *)&dest[4 * v36];
        }
        ++v35;
        *(_DWORD *)&dest[4 * v36] = v38;
        v36 += v13;
      }
      while ( v35 < v33 );
    }
    v35 = 0;
    goto LABEL_45;
  }
  return 9;
}
// 35F60: conditional instruction was optimized away because w8.4!=0
// 36058: conditional instruction was optimized away because w8.4!=0

//----- (00000000000361A8) ----------------------------------------------------
__int64 __fastcall resampler_get_external_samples(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 42) )
    return 9;
  v2 = *(_DWORD *)(a1 + 16);
  result = 0;
  *a2 = v2;
  return result;
}

//----- (00000000000361D8) ----------------------------------------------------
__int64 __fastcall resampler_get_internal_samples(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 42) )
    return 9;
  v2 = *(_DWORD *)(a1 + 20);
  result = 0;
  *a2 = v2;
  return result;
}

//----- (0000000000036208) ----------------------------------------------------
__int64 __fastcall resampler_get_internal_sample_rate(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 42) )
    return 9;
  v2 = *(_DWORD *)(a1 + 12);
  result = 0;
  *a2 = v2;
  return result;
}

//----- (0000000000036238) ----------------------------------------------------
__int64 __fastcall resampler_get_latency(__int64 a1, int *a2)
{
  int v2; // w8
  int v3; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 42) )
    return 9;
  if ( !a2 )
    return 0xFFFFFFFFLL;
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 <= 23999 )
  {
    if ( v2 > 11999 )
    {
      if ( v2 != 12000 && v2 != 16000 && v2 != 22050 )
        goto LABEL_31;
    }
    else if ( v2 != 6000 && v2 != 8000 && v2 != 11025 )
    {
      goto LABEL_31;
    }
    goto LABEL_24;
  }
  if ( v2 <= 88199 )
  {
    if ( v2 != 24000 )
    {
      if ( v2 == 32000 || v2 == 64000 )
      {
        v3 = 3;
        goto LABEL_25;
      }
LABEL_31:
      v3 = 0;
      goto LABEL_25;
    }
LABEL_24:
    v3 = 1;
    goto LABEL_25;
  }
  if ( v2 > 176399 )
  {
    if ( v2 == 176400 )
    {
      v3 = 11;
      goto LABEL_25;
    }
    if ( v2 == 192000 )
    {
      v3 = 12;
      goto LABEL_25;
    }
    goto LABEL_31;
  }
  if ( v2 == 88200 )
  {
    v3 = 5;
    goto LABEL_25;
  }
  if ( v2 != 96000 )
    goto LABEL_31;
  v3 = 6;
LABEL_25:
  result = 0;
  *a2 = v3;
  return result;
}

//----- (0000000000036384) ----------------------------------------------------
long double __fastcall dynamic_queue_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x50u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (00000000000363E4) ----------------------------------------------------
__int64 __fastcall dynamic_queue_destroy(__int64 *a1)
{
  _QWORD *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_3642C(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003642C) ----------------------------------------------------
__int64 __fastcall sub_3642C(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void **v4; // x20
  __int64 result; // x0
  void **v6; // x19
  __int64 v7; // t1

  v2 = (void *)a1[4];
  if ( v2 )
  {
    free(v2);
    a1[4] = 0;
  }
  v3 = (void *)a1[5];
  if ( v3 )
  {
    free(v3);
    a1[5] = 0;
  }
  v4 = (void **)(a1 + 6);
  result = circular_buffer_free(a1[6]);
  if ( !(_DWORD)result )
  {
    v7 = a1[7];
    v6 = (void **)(a1 + 7);
    result = circular_buffer_free(v7);
    if ( !(_DWORD)result )
    {
      result = circular_buffer_destroy(v4);
      if ( !(_DWORD)result )
        return circular_buffer_destroy(v6);
    }
  }
  return result;
}

//----- (00000000000364A0) ----------------------------------------------------
__int64 __fastcall dynamic_queue_setup(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7, size_t n)
{
  int v11; // w22
  __int64 result; // x0
  void *v17; // x0
  __int64 v18; // x8
  size_t v19; // x22
  unsigned int v20; // w20
  void *v21; // x0
  size_t v22; // x20
  int v23; // w21
  int v24; // w22

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a4 )
    return 1;
  if ( !a5 )
    return 0xFFFFFFFFLL;
  if ( !a7 )
    return 4;
  v11 = n;
  if ( !a6 && (_DWORD)n == 1 )
    return 4;
  if ( *(_DWORD *)(a1 + 24) )
    sub_3642C((_QWORD *)a1);
  v17 = *(void **)(a1 + 32);
  v18 = (unsigned int)(a7 * a4);
  *(_DWORD *)(a1 + 16) = v11;
  v19 = 4 * v18;
  *(_DWORD *)a1 = a4;
  *(_DWORD *)(a1 + 4) = a5;
  *(_DWORD *)(a1 + 8) = a6;
  *(_DWORD *)(a1 + 12) = a7;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  if ( !v17 )
  {
    v17 = malloc(4 * v18);
    *(_QWORD *)(a1 + 32) = v17;
    if ( !v17 )
      goto LABEL_24;
  }
  v20 = a7 * a5;
  memset(v17, 0, v19);
  v21 = *(void **)(a1 + 40);
  if ( !v21 )
  {
    v22 = 4LL * v20;
    v21 = malloc(v22);
    *(_QWORD *)(a1 + 40) = v21;
    if ( v21 )
      goto LABEL_18;
LABEL_24:
    exit(1);
  }
  v22 = 4LL * v20;
LABEL_18:
  memset(v21, 0, v22);
  result = circular_buffer_create((_QWORD *)(a1 + 48));
  if ( !(_DWORD)result )
  {
    result = circular_buffer_create((_QWORD *)(a1 + 56));
    if ( !(_DWORD)result )
    {
      v23 = *(_DWORD *)(a1 + 12);
      v24 = *(_DWORD *)(a1 + 4);
      result = circular_buffer_init(*(_QWORD *)(a1 + 48), 2 * *(_DWORD *)a1 * v23);
      if ( !(_DWORD)result )
      {
        result = circular_buffer_init(*(_QWORD *)(a1 + 56), 2 * v23 * v24);
        if ( !(_DWORD)result )
        {
          result = sub_36618(a1);
          if ( !(_DWORD)result )
            *(_DWORD *)(a1 + 24) = 1;
        }
      }
    }
  }
  return result;
}

//----- (0000000000036618) ----------------------------------------------------
__int64 __fastcall sub_36618(__int64 a1)
{
  int v1; // w8
  __int64 v3; // x20
  __int64 result; // x0
  unsigned int v5; // w20
  int v6; // w21
  int v7; // w22
  int v8; // w21
  int v9; // w21

  v1 = *(_DWORD *)(a1 + 12);
  v3 = (unsigned int)(*(_DWORD *)(a1 + 4) * v1);
  memset(*(void **)(a1 + 32), 0, 4LL * (unsigned int)(v1 * *(_DWORD *)a1));
  memset(*(void **)(a1 + 40), 0, 4 * v3);
  result = circular_buffer_clear(*(_QWORD *)(a1 + 48));
  if ( !(_DWORD)result )
  {
    result = circular_buffer_clear(*(_QWORD *)(a1 + 56));
    if ( !(_DWORD)result )
    {
      v5 = *(_DWORD *)(a1 + 12);
      if ( *(_DWORD *)(a1 + 16) == 1 )
      {
        v6 = (*(_DWORD *)(a1 + 8) - 1) % v5 + 1;
        v7 = v6 - greatest_common_divisor(v5, v6);
        v5 = *(_DWORD *)(a1 + 12) - v6;
      }
      else
      {
        v7 = 0;
      }
      if ( *(_DWORD *)a1 * v7 )
      {
        v8 = 0;
        while ( 1 )
        {
          result = circular_buffer_enqueue(*(_QWORD *)(a1 + 48), 0.0);
          if ( (_DWORD)result )
            break;
          if ( ++v8 >= (unsigned int)(*(_DWORD *)a1 * v7) )
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        if ( *(_DWORD *)(a1 + 4) * v5 )
        {
          v9 = 0;
          while ( 1 )
          {
            result = circular_buffer_enqueue(*(_QWORD *)(a1 + 56), 0.0);
            if ( (_DWORD)result )
              break;
            if ( ++v9 >= *(_DWORD *)(a1 + 4) * v5 )
              goto LABEL_14;
          }
        }
        else
        {
LABEL_14:
          result = 0;
          *(_DWORD *)(a1 + 20) = v5 + v7;
        }
      }
    }
  }
  return result;
}

//----- (0000000000036738) ----------------------------------------------------
__int64 __fastcall dynamic_queue_process(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v5; // w19
  unsigned int v8; // w25
  unsigned int v9; // w28
  unsigned int v10; // w23
  unsigned int v11; // w24
  unsigned int v12; // w27
  unsigned int v13; // w26
  unsigned int v14; // w8
  unsigned int v15; // w24
  unsigned int v16; // w0
  unsigned int v17; // w8
  unsigned int v18; // w9
  int v19; // w23
  unsigned int i; // w24
  unsigned int v21; // w11
  unsigned int v22; // w0
  unsigned int v23; // w9
  unsigned int v24; // w8
  int v25; // w28
  unsigned int j; // w24
  unsigned int v27; // w28
  unsigned int v28; // w8
  unsigned int k; // w24
  unsigned int v30; // w10
  float v32; // [xsp+14h] [xbp-5Ch] BYREF
  __int64 v33; // [xsp+18h] [xbp-58h]

  v33 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 )
  {
    if ( a1[6] )
    {
      v5 = a4;
      if ( a4 )
      {
        v8 = 0;
        v9 = 0;
        v10 = 0;
        while ( 1 )
        {
          v11 = a1[3];
          if ( v5 >= v11 )
            v12 = a1[3];
          else
            v12 = v5;
          v13 = v12 + v9;
          if ( v9 < v12 + v9 )
          {
            v14 = *a1;
            if ( *a1 )
            {
LABEL_13:
              v15 = 0;
              do
              {
                v32 = *(float *)(a2 + 4LL * (v15 + v9 * v14));
                circular_buffer_enqueue(*((_QWORD *)a1 + 6), v32);
                v14 = *a1;
                ++v15;
              }
              while ( v15 < *a1 );
            }
            while ( ++v9 < v13 )
            {
              if ( v14 )
                goto LABEL_13;
            }
            v11 = a1[3];
          }
          v16 = circular_buffer_size(*((_QWORD *)a1 + 6));
          v17 = *a1;
          if ( v11 <= v16 / *a1 )
          {
            v18 = a1[3];
            if ( v18 )
            {
              v19 = 0;
              if ( v17 )
              {
LABEL_22:
                for ( i = 0; i < v17; ++i )
                {
                  circular_buffer_dequeue_data(*((unsigned int **)a1 + 6), &v32);
                  v17 = *a1;
                  v21 = i + v19 * *a1;
                  *(float *)(*((_QWORD *)a1 + 4) + 4LL * v21) = v32;
                }
                v18 = a1[3];
              }
              while ( ++v19 < v18 )
              {
                if ( v17 )
                  goto LABEL_22;
              }
            }
            v22 = (*((__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))a1 + 9))(
                    *((_QWORD *)a1 + 8),
                    *((_QWORD *)a1 + 4),
                    *((_QWORD *)a1 + 5));
            v23 = a1[3];
            v10 = v22;
            if ( v23 )
            {
              v24 = a1[1];
              v25 = 0;
              if ( v24 )
              {
LABEL_29:
                for ( j = 0; j < v24; ++j )
                {
                  v32 = *(float *)(*((_QWORD *)a1 + 5) + 4LL * (j + v25 * v24));
                  circular_buffer_enqueue(*((_QWORD *)a1 + 7), v32);
                  v24 = a1[1];
                }
                v23 = a1[3];
              }
              while ( ++v25 < v23 )
              {
                if ( v24 )
                  goto LABEL_29;
              }
            }
          }
          v27 = v12 + v8;
          v5 -= v12;
          if ( v8 < v12 + v8 )
          {
            v28 = a1[1];
            if ( v28 )
            {
LABEL_36:
              for ( k = 0; k < v28; ++k )
              {
                circular_buffer_dequeue_data(*((unsigned int **)a1 + 7), &v32);
                v28 = a1[1];
                v30 = k + v8 * v28;
                *(float *)(a3 + 4LL * v30) = v32;
              }
            }
            while ( ++v8 < v27 )
            {
              if ( v28 )
                goto LABEL_36;
            }
          }
          v8 = v27;
          v9 = v13;
          if ( !v5 )
            return v10;
        }
      }
      return 0;
    }
    else
    {
      return 9;
    }
  }
  else
  {
    return (unsigned int)-1;
  }
}

//----- (0000000000036984) ----------------------------------------------------
__int64 __fastcall dynamic_queue_process_planar(unsigned int *a1, __int64 a2, __int64 a3, signed int a4)
{
  __int64 v5; // x26
  _DWORD *v9; // x21
  _DWORD *v10; // x22
  int v11; // w25
  unsigned __int64 v12; // x10
  __int64 v13; // x13
  unsigned __int64 v14; // x13
  int v15; // w8
  unsigned int v16; // w9
  int v17; // w16
  __int64 v18; // x17
  bool v19; // w17
  bool v20; // w0
  __int64 v21; // x17
  unsigned int v22; // w0
  unsigned int v23; // w1
  int v24; // w3
  int v25; // w2
  int v26; // w0
  unsigned int v27; // w1
  __int64 v28; // x17
  int v29; // w2
  __int64 result; // x0
  unsigned __int64 v31; // x10
  __int64 v32; // x14
  unsigned __int64 v33; // x14
  int v34; // w8
  unsigned int v35; // w9
  int v36; // w17
  unsigned __int64 v37; // x0
  bool v38; // w1
  __int64 v39; // x0
  unsigned int v40; // w1
  unsigned int v41; // w2
  int v42; // w3
  int v43; // w4
  unsigned int v44; // w5
  unsigned int v45; // w1
  int v46; // w2

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a1[6] )
    return 9;
  v5 = *a1;
  v9 = malloc(4LL * (unsigned int)(v5 * a4));
  v10 = malloc(4LL * a1[1] * a4);
  v11 = 2 * a4;
  if ( a4 )
  {
    v12 = v5 - 1;
    if ( a4 >= 0 )
      v13 = (unsigned int)a4;
    else
      v13 = (unsigned int)-a4;
    v14 = v13 * (unsigned int)(v5 - 1);
    v15 = 0;
    v16 = 0;
    v17 = 1;
    if ( (_DWORD)v5 )
      goto LABEL_10;
    while ( 1 )
    {
      do
      {
        ++v16;
        v17 += v5;
        v15 += v5;
        if ( v16 == a4 )
          goto LABEL_23;
      }
      while ( !(_DWORD)v5 );
LABEL_10:
      if ( (_DWORD)v5 == 1 )
        break;
      v19 = (unsigned int)v14 > ~v16;
      if ( a4 < 0 )
        v19 = v16 < (unsigned int)v14;
      v20 = v19 || HIDWORD(v12) != 0 || HIDWORD(v14) != 0;
      v18 = 0;
      if ( !v20 && ~((unsigned int)v5 * v16) >= (unsigned int)v12 && !HIDWORD(v12) )
      {
        v21 = (unsigned int)v5 & 0xFFFFFFFE;
        v22 = v17;
        v23 = v16;
        do
        {
          v24 = *(_DWORD *)(a2 + 4LL * v23);
          v25 = *(_DWORD *)(a2 + 4LL * (a4 + v23));
          v23 += v11;
          v21 -= 2;
          v9[v22 - 1] = v24;
          v9[v22] = v25;
          v22 += 2;
        }
        while ( v21 );
        v18 = (unsigned int)v5 & 0xFFFFFFFE;
        if ( v18 == v5 )
          continue;
      }
LABEL_20:
      v26 = v15 + v18;
      v27 = v16 + a4 * v18;
      v28 = v5 - v18;
      do
      {
        v29 = *(_DWORD *)(a2 + 4LL * v27);
        --v28;
        v27 += a4;
        v9[v26++] = v29;
      }
      while ( v28 );
    }
    v18 = 0;
    goto LABEL_20;
  }
LABEL_23:
  result = dynamic_queue_process(a1, (__int64)v9, (__int64)v10, a4);
  if ( !(_DWORD)result )
  {
    if ( a4 )
    {
      v31 = a1[1];
      if ( a4 >= 0 )
        v32 = (unsigned int)a4;
      else
        v32 = (unsigned int)-a4;
      v33 = v32 * (unsigned int)(v31 - 1);
      v34 = 0;
      v35 = 0;
      v36 = 1;
      if ( (_DWORD)v31 )
        goto LABEL_31;
      while ( 1 )
      {
        do
        {
          ++v35;
          v36 += v31;
          v34 += v31;
          if ( v35 == a4 )
            goto LABEL_46;
        }
        while ( !(_DWORD)v31 );
LABEL_31:
        if ( (_DWORD)v31 == 1 )
          break;
        v38 = (unsigned int)v33 > ~v35;
        if ( a4 < 0 )
          v38 = v35 < (unsigned int)v33;
        v37 = 0;
        if ( ~((unsigned int)v31 * v35) >= (int)v31 - 1 && !((v31 - 1) >> 32) && !v38 && HIDWORD(v33) == 0 )
        {
          v39 = (unsigned int)v31 & 0xFFFFFFFE;
          v40 = v35;
          v41 = v36;
          do
          {
            v42 = v10[v41 - 1];
            v43 = v10[v41];
            v44 = a4 + v40;
            v41 += 2;
            v39 -= 2;
            *(_DWORD *)(a3 + 4LL * v40) = v42;
            v40 += v11;
            *(_DWORD *)(a3 + 4LL * v44) = v43;
          }
          while ( v39 );
          v37 = (unsigned int)v31 & 0xFFFFFFFE;
          if ( v37 == v31 )
            continue;
        }
LABEL_41:
        v45 = v35 + a4 * v37;
        do
        {
          v46 = v10[(unsigned int)(v34 + v37++)];
          *(_DWORD *)(a3 + 4LL * v45) = v46;
          v45 += a4;
        }
        while ( v37 < v31 );
      }
      v37 = 0;
      goto LABEL_41;
    }
LABEL_46:
    free(v9);
    free(v10);
    return 0;
  }
  return result;
}
// 369FC: conditional instruction was optimized away because w19.4!=0
// 36B24: conditional instruction was optimized away because w19.4!=0

//----- (0000000000036C68) ----------------------------------------------------
__int64 __fastcall dynamic_queue_process_s16(unsigned int *a1, __int64 a2, int16x4_t *a3, unsigned int a4)
{
  __int64 v8; // x25
  float32x4_t *v9; // x20
  float32x4_t *v10; // x21
  __int64 v11; // x8
  __int64 result; // x0
  unsigned __int64 *v13; // x9
  float32x4_t *v14; // x10
  float32x4_t v15; // q0
  __int64 v16; // x11
  int16x4_t v17; // d1
  int16x4_t v18; // d2
  __int16 *v19; // x9
  float *v20; // x10
  __int64 v21; // x8
  int v22; // t1
  unsigned int v23; // w8
  unsigned __int64 v24; // x9
  float32x4_t *v25; // x10
  int16x4_t *v26; // x11
  float32x4_t v27; // q0
  unsigned __int64 v28; // x12
  float32x4_t v29; // q1
  float32x4_t v30; // q2

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a1[6] )
    return 9;
  v8 = *a1 * a4;
  v9 = (float32x4_t *)malloc(4 * v8);
  v10 = (float32x4_t *)malloc(4LL * a1[1] * a4);
  if ( (_DWORD)v8 )
  {
    if ( (unsigned int)v8 <= 7 )
    {
      v11 = 0;
LABEL_11:
      v19 = (__int16 *)(a2 + 2 * v11);
      v20 = (float *)v9 + v11;
      v21 = v8 - v11;
      do
      {
        v22 = *v19++;
        --v21;
        *v20++ = (float)v22 * 0.000030518;
      }
      while ( v21 );
      goto LABEL_13;
    }
    v11 = (unsigned int)v8 & 0xFFFFFFF8;
    v13 = (unsigned __int64 *)(a2 + 8);
    v14 = v9 + 1;
    v15.n128_u64[0] = 0x3800000038000000LL;
    v15.n128_u64[1] = 0x3800000038000000LL;
    v16 = v11;
    do
    {
      v17.n64_u64[0] = *(v13 - 1);
      v18.n64_u64[0] = *v13;
      v13 += 2;
      v16 -= 8;
      v14[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(v17)), v15);
      *v14 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(v18)), v15);
      v14 += 2;
    }
    while ( v16 );
    if ( v11 != v8 )
      goto LABEL_11;
  }
LABEL_13:
  result = dynamic_queue_process(a1, (__int64)v9, (__int64)v10, a4);
  if ( (_DWORD)result )
    return result;
  v23 = a1[1] * a4;
  if ( v23 )
  {
    if ( v23 > 7 )
    {
      v24 = v23 & 0xFFFFFFF8;
      v25 = v10 + 1;
      v26 = a3 + 1;
      v27 = vdupq_n_s32(0x46FFFE00u);
      v28 = v24;
      do
      {
        v29 = v25[-1];
        v30 = *v25;
        v25 += 2;
        v28 -= 8LL;
        v26[-1].n64_u64[0] = vmovn_s32(vcvtq_s32_f32(vmulq_f32(v29, v27))).n64_u64[0];
        v26->n64_u64[0] = vmovn_s32(vcvtq_s32_f32(vmulq_f32(v30, v27))).n64_u64[0];
        v26 += 2;
      }
      while ( v28 );
      if ( v24 == v23 )
        goto LABEL_21;
    }
    else
    {
      v24 = 0;
    }
    do
    {
      a3->n64_u16[v24] = (int)(float)(v10->n128_f32[v24] * 32767.0);
      ++v24;
    }
    while ( v24 < v23 );
  }
LABEL_21:
  free(v9);
  free(v10);
  return 0;
}

//----- (0000000000036E40) ----------------------------------------------------
__int64 __fastcall dynamic_queue_process_s16_planar(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v5; // x26
  _DWORD *v9; // x21
  float *v10; // x22
  float32x4_t v11; // q1
  int v12; // w25
  int v13; // w8
  unsigned int v14; // w9
  unsigned __int64 v15; // x10
  float32x4_t v16; // q0
  __int64 v17; // x13
  __int64 v18; // x13
  int v19; // w14
  unsigned int v20; // w15
  unsigned __int64 *v21; // x16
  int16x4_t v22; // d1
  int16x4_t v23; // d2
  float32x4_t *v24; // x16
  int v25; // w14
  unsigned int v26; // w15
  __int64 v27; // x13
  __int64 result; // x0
  unsigned __int64 v29; // x10
  int v30; // w8
  unsigned int v31; // w12
  unsigned int v32; // w9
  float32x4_t v33; // q0
  unsigned __int64 v34; // x15
  __int64 v35; // x15
  unsigned int v36; // w16
  int v37; // w17
  float32x4_t *v38; // x0
  float32x4_t v39; // q1
  float32x4_t v40; // q2
  int16x4_t *v41; // x0
  unsigned int v42; // w16
  float v43; // s1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a1[6] )
    return 9;
  v5 = *a1;
  v9 = malloc(4LL * (unsigned int)v5 * a4);
  v10 = (float *)malloc(4LL * a1[1] * a4);
  v12 = 8 * a4;
  if ( a4 )
  {
    v13 = 0;
    v14 = 0;
    v15 = v5 - 1;
    v16.n128_u64[0] = 0x3800000038000000LL;
    v16.n128_u64[1] = 0x3800000038000000LL;
    if ( (_DWORD)v5 )
      goto LABEL_7;
    while ( 1 )
    {
      do
      {
        ++v14;
        v13 += v5;
        if ( v14 == a4 )
          goto LABEL_20;
      }
      while ( !(_DWORD)v5 );
LABEL_7:
      if ( (unsigned int)v5 <= 7 )
        break;
      v17 = 0;
      if ( a4 == 1
        && ~v14 >= (unsigned int)v15
        && !HIDWORD(v15)
        && ~((unsigned int)v5 * v14) >= (unsigned int)v15
        && !HIDWORD(v15) )
      {
        v18 = (unsigned int)v5 & 0xFFFFFFF8;
        v19 = v13;
        v20 = v14;
        do
        {
          v21 = (unsigned __int64 *)(a2 + 2LL * v20);
          v22.n64_u64[0] = *v21;
          v23.n64_u64[0] = v21[1];
          v24 = (float32x4_t *)&v9[v19];
          v20 += v12;
          v18 -= 8;
          v11 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(v22)), v16);
          v19 += 8;
          *v24 = v11;
          v24[1] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(v23)), v16);
        }
        while ( v18 );
        v17 = (unsigned int)v5 & 0xFFFFFFF8;
        if ( v17 == v5 )
          continue;
      }
LABEL_17:
      v25 = v13 + v17;
      v26 = v14 + a4 * v17;
      v27 = v5 - v17;
      do
      {
        v11.n128_u16[0] = *(_WORD *)(a2 + 2LL * v26);
        --v27;
        v26 += a4;
        v11.n128_u64[0] = vmovl_s16((int16x4_t)v11.n128_u64[0]).n128_u64[0];
        v11.n128_f32[0] = (float)v11.n128_i32[0] * 0.000030518;
        v9[v25++] = v11.n128_u32[0];
      }
      while ( v27 );
    }
    v17 = 0;
    goto LABEL_17;
  }
LABEL_20:
  result = dynamic_queue_process(a1, (__int64)v9, (__int64)v10, a4);
  if ( !(_DWORD)result )
  {
    if ( a4 )
    {
      v29 = a1[1];
      v30 = 0;
      v31 = v29 - 1;
      v32 = 0;
      v33 = vdupq_n_s32(0x46FFFE00u);
      if ( (_DWORD)v29 )
        goto LABEL_25;
      while ( 1 )
      {
        do
        {
          ++v32;
          v30 += v29;
          if ( v32 == a4 )
            goto LABEL_39;
        }
        while ( !(_DWORD)v29 );
LABEL_25:
        if ( (unsigned int)v29 <= 7 )
          break;
        v34 = 0;
        if ( ~((unsigned int)v29 * v32) >= v31 && !((v29 - 1) >> 32) && a4 == 1 && ~v32 >= v31 )
        {
          v35 = (unsigned int)v29 & 0xFFFFFFF8;
          v36 = v32;
          v37 = v30;
          do
          {
            v38 = (float32x4_t *)&v10[v37];
            v39 = *v38;
            v40 = v38[1];
            v41 = (int16x4_t *)(a3 + 2LL * v36);
            v37 += 8;
            v35 -= 8;
            v36 += v12;
            v41->n64_u64[0] = vmovn_s32(vcvtq_s32_f32(vmulq_f32(v39, v33))).n64_u64[0];
            v41[1].n64_u64[0] = vmovn_s32(vcvtq_s32_f32(vmulq_f32(v40, v33))).n64_u64[0];
          }
          while ( v35 );
          v34 = (unsigned int)v29 & 0xFFFFFFF8;
          if ( v34 == v29 )
            continue;
        }
LABEL_34:
        v42 = v32 + a4 * v34;
        do
        {
          v43 = v10[(unsigned int)(v30 + v34++)];
          *(_WORD *)(a3 + 2LL * v42) = (int)(float)(v43 * 32767.0);
          v42 += a4;
        }
        while ( v34 < v29 );
      }
      v34 = 0;
      goto LABEL_34;
    }
LABEL_39:
    free(v9);
    free(v10);
    return 0;
  }
  return result;
}
// 37034: conditional instruction was optimized away because x14.8==0
// 36F84: variable 'v11' is possibly undefined

//----- (00000000000370F4) ----------------------------------------------------
__int64 __fastcall dynamic_queue_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 24) )
    return sub_36618(a1);
  return 9;
}

//----- (0000000000037114) ----------------------------------------------------
__int64 __fastcall dynamic_queue_reset(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_DWORD *)(a1 + 24) )
    return 9;
  *(_DWORD *)(a1 + 24) = 0;
  return sub_3642C((_QWORD *)a1);
}

//----- (0000000000037138) ----------------------------------------------------
__int64 __fastcall dynamic_queue_get_latency(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 24) )
  {
    if ( a2 )
    {
      v2 = *(_DWORD *)(a1 + 20);
      result = 0;
      *a2 = v2;
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return 9;
}

//----- (000000000003716C) ----------------------------------------------------
long double __fastcall channel_layout_converter_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( !*a1 )
  {
    v2 = malloc(0x20u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  return result;
}

//----- (00000000000371C0) ----------------------------------------------------
__int64 __fastcall channel_layout_converter_destroy(void **a1)
{
  void *v2; // x0
  __int64 result; // x0

  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  free(v2);
  result = 0;
  *a1 = 0;
  return result;
}

//----- (00000000000371F8) ----------------------------------------------------
__int64 __fastcall channel_layout_converter_setup(
        unsigned int *a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        unsigned int a5)
{
  unsigned int v5; // w8
  signed int v6; // w9
  __int64 v7; // x9
  unsigned int v8; // w11
  signed int v9; // w9

  v5 = 1;
  if ( a2 <= 0xC && ((1 << a2) & 0x1166) != 0 )
  {
    v5 = 1;
    if ( a3 <= 0xC && ((1 << a3) & 0x1166) != 0 )
    {
      v6 = a2 - 1;
      a1[7] = 0;
      *a1 = a2;
      a1[1] = a3;
      a1[2] = a4;
      a1[5] = a5;
      if ( a2 - 1 <= 0xB && ((0x8B3u >> v6) & 1) != 0 )
      {
        v7 = 4LL * v6;
        v8 = *(_DWORD *)((char *)dword_16F60 + v7);
        LODWORD(v7) = *(_DWORD *)((char *)&unk_16F30 + v7);
        a1[3] = v8;
        a1[6] = v7;
      }
      v9 = a3 - 1;
      if ( a3 - 1 <= 0xB && ((0x8B3u >> v9) & 1) != 0 )
        a1[4] = dword_16F60[v9];
      v5 = 0;
      a1[7] = 1;
    }
  }
  return v5;
}
// 16F60: using guessed type _DWORD dword_16F60[12];

//----- (00000000000372B0) ----------------------------------------------------
__int64 __fastcall channel_layout_converter_process(
        unsigned int *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        double a4)
{
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  __int64 result; // x0
  unsigned int v8; // w9
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x11
  unsigned int v11; // w12
  unsigned int v12; // w13
  int v13; // w14
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x11
  bool v16; // w5
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x13
  __int64 v19; // x17
  unsigned int *v20; // x19
  __int64 v21; // x7
  __int64 v22; // x19
  __int64 v23; // x22
  int v24; // w20
  unsigned int v25; // w21
  __int64 v26; // x22
  __int64 v27; // x23
  float v28; // s1
  int v29; // w20
  float32x4_t v30; // q1
  unsigned int v31; // w21
  __int64 v32; // x22
  const float *v33; // x23
  float *v34; // x23
  float32x4_t v35; // q5
  unsigned int v36; // w8
  unsigned __int64 v37; // x9
  __int64 v38; // x10
  int v39; // w11
  unsigned int v40; // w9
  unsigned __int64 v41; // x8
  unsigned __int64 v42; // x9
  unsigned int v43; // w10
  __int64 v44; // x11
  int v45; // w12
  unsigned int v46; // w12
  unsigned __int64 v47; // x9
  unsigned int v48; // w10
  __int64 v49; // x12
  float v50; // s0
  float v51; // s0
  __int128 *v52; // x10
  _OWORD *v53; // x11
  unsigned __int64 v54; // x12
  __int128 v55; // q0
  __int128 v56; // q1
  __int128 *v57; // x10
  _OWORD *v58; // x11
  unsigned __int64 v59; // x12
  __int128 v60; // q0
  __int128 v61; // q1
  __int64 v62; // x10
  int v63; // w11
  unsigned __int64 v64; // x11
  bool v65; // w12
  bool v66; // w10
  unsigned __int64 v67; // x11
  __int64 v68; // x10
  unsigned __int64 v69; // x11
  unsigned __int64 v70; // x12
  unsigned __int64 v71; // x13
  unsigned __int64 v72; // x15
  unsigned __int64 v73; // x16
  float *v74; // x14
  float *v75; // x15
  unsigned __int64 v76; // x11
  bool v77; // w12
  bool v78; // w10
  unsigned __int64 v79; // x11
  __int64 v80; // x10
  float32x4_t v81; // q0
  unsigned __int64 v82; // x12
  float32x4_t *v83; // x13
  float32x4_t v84; // t1
  float *v85; // x14
  float32x4x2_t v86; // 0:q0.16,16:q1.16
  float32x4x2_t v87; // 0:q1.16,16:q2.16
  float32x4x2_t v88; // 0:q2.16,16:q3.16
  float32x4x2_t v89; // 0:q3.16,16:q4.16
  float32x4x2_t v90; // 0:q6.16,16:q7.16

  if ( !a1[7] )
    return 9;
  if ( a1[5] == 1 )
  {
    if ( a1[4] == 1 )
    {
      v5 = a1[2];
      if ( (_DWORD)v5 )
      {
        if ( (unsigned int)v5 >= 8 )
        {
          if ( a2 + 4 * v5 <= a3 || a3 + 4 * v5 <= a2 )
          {
            v6 = (unsigned int)v5 & 0xFFFFFFF8;
            v57 = (__int128 *)(a2 + 16);
            v58 = (_OWORD *)(a3 + 16);
            v59 = v6;
            do
            {
              v60 = *(v57 - 1);
              v61 = *v57;
              v57 += 2;
              v59 -= 8LL;
              *(v58 - 1) = v60;
              *v58 = v61;
              v58 += 2;
            }
            while ( v59 );
            if ( v6 == v5 )
              return 0;
          }
          else
          {
            v6 = 0;
          }
        }
        else
        {
          v6 = 0;
        }
        do
        {
          v62 = 4 * v6;
          v63 = *(_DWORD *)(a2 + 4 * v6++);
          *(_DWORD *)(a3 + v62) = v63;
        }
        while ( v6 < v5 );
      }
    }
    else
    {
      v36 = a1[2] * a1[3];
      if ( v36 )
      {
        if ( v36 > 7 && (a2 + 4LL * v36 <= a3 || a3 + 4LL * v36 <= a2) )
        {
          v37 = v36 & 0xFFFFFFF8;
          v52 = (__int128 *)(a2 + 16);
          v53 = (_OWORD *)(a3 + 16);
          v54 = v37;
          do
          {
            v55 = *(v52 - 1);
            v56 = *v52;
            v52 += 2;
            v54 -= 8LL;
            *(v53 - 1) = v55;
            *v53 = v56;
            v53 += 2;
          }
          while ( v54 );
          if ( v37 == v36 )
            return 0;
        }
        else
        {
          v37 = 0;
        }
        do
        {
          v38 = 4 * v37;
          v39 = *(_DWORD *)(a2 + 4 * v37++);
          *(_DWORD *)(a3 + v38) = v39;
        }
        while ( v37 < v36 );
      }
    }
    return 0;
  }
  v8 = a1[3];
  result = 1;
  switch ( v8 )
  {
    case 1u:
      v40 = a1[4];
      v41 = a1[2];
      if ( v40 == 1 )
      {
        if ( !(_DWORD)v41 )
          return 0;
        if ( (unsigned int)v41 >= 8 )
        {
          v64 = v41 - 1;
          v65 = __CFADD__((_DWORD)v64, (_DWORD)v64);
          v42 = 0;
          v66 = v64 >> 61 != 0;
          if ( HIDWORD(v64) )
            goto LABEL_42;
          if ( v65 )
            goto LABEL_42;
          v67 = 8 * v64;
          if ( v67 > ~a3 || v66 || v67 > ~(a3 + 4) || v66 )
            goto LABEL_42;
          if ( a3 + 8 * v41 <= a2 || a2 + 4 * v41 <= a3 )
          {
            v42 = (unsigned int)v41 & 0xFFFFFFF8;
            v68 = 0;
            v69 = a3 - 4;
            v70 = v42;
            v71 = a2;
            do
            {
              v86.val[0] = *(float32x4_t *)v71;
              v88.val[0] = *(float32x4_t *)(v71 + 16);
              v71 += 32LL;
              v72 = ((unsigned __int64)((unsigned int)v68 >> 4) << 6) | 4;
              v73 = ((unsigned __int64)((unsigned int)v68 >> 4) << 6) | 0x24;
              v68 += 16;
              v70 -= 8LL;
              v74 = (float *)(v69 + v72);
              v75 = (float *)(v69 + v73);
              v86.val[1] = v86.val[0];
              v88.val[1] = v88.val[0];
              vst2q_f32(v74, v86);
              vst2q_f32(v75, v88);
            }
            while ( v70 );
            if ( v42 == v41 )
              return 0;
            goto LABEL_42;
          }
        }
        v42 = 0;
LABEL_42:
        v43 = 2 * v42;
        do
        {
          v44 = 4 * v42;
          v45 = *(_DWORD *)(a2 + 4 * v42++);
          result = 0;
          *(_DWORD *)(a3 + 4LL * v43) = v45;
          v46 = v43 + 1;
          v43 += 2;
          *(_DWORD *)(a3 + 4LL * v46) = *(_DWORD *)(a2 + v44);
        }
        while ( v42 < v41 );
        return result;
      }
      if ( !(_DWORD)v41 )
        return 0;
      if ( (unsigned int)v41 <= 3 )
        goto LABEL_50;
      v76 = v41 - 1;
      v77 = __CFADD__((_DWORD)v76, (_DWORD)v76);
      v47 = 0;
      v78 = v76 >> 61 != 0;
      if ( !HIDWORD(v76) && !v77 )
      {
        v79 = 8 * v76;
        if ( v79 <= ~a3 && !v78 && v79 <= ~(a3 + 4) && !v78 )
        {
          if ( a3 + 8 * v41 > a2 && a2 + 4 * v41 > a3 )
          {
LABEL_50:
            v47 = 0;
          }
          else
          {
            v47 = (unsigned int)v41 & 0xFFFFFFFC;
            v80 = 0;
            v81 = vdupq_n_s32(0x3F34FDF4u);
            v82 = v47;
            v83 = (float32x4_t *)a2;
            do
            {
              v84 = *v83++;
              v87.val[0] = vmulq_f32(v84, v81);
              v82 -= 4LL;
              v85 = (float *)(a3
                            - 4
                            + ((32 * (((unsigned __int64)((unsigned int)v80 & 0xFFFFFFF8) >> 3) & 0x1FFFFFFF)) | 4));
              v87.val[1] = v87.val[0];
              v80 += 8;
              vst2q_f32(v85, v87);
            }
            while ( v82 );
            if ( v47 == v41 )
              return 0;
          }
        }
      }
      v48 = 2 * v47;
      do
      {
        v49 = 4 * v47;
        v50 = *(float *)(a2 + 4 * v47++);
        result = 0;
        *(float *)(a3 + 4LL * v48) = v50 * 0.707;
        v51 = *(float *)(a2 + v49);
        LODWORD(v49) = v48 + 1;
        v48 += 2;
        *(float *)(a3 + 4LL * (unsigned int)v49) = v51 * 0.707;
      }
      while ( v47 < v41 );
      return result;
    case 6u:
    case 8u:
    case 0xCu:
      v9 = a1[2];
      if ( (_DWORD)v9 )
      {
        v10 = 0;
        v11 = 1;
        v12 = 1;
        do
        {
          ++v10;
          *(_DWORD *)(a3 + 4LL * (v11 - 1)) = *(_DWORD *)(a2 + 4LL * (v12 - 1));
          v13 = *(_DWORD *)(a2 + 4LL * v12);
          v12 += v8;
          *(_DWORD *)(a3 + 4LL * v11) = v13;
          v11 += 2;
        }
        while ( v10 < v9 );
      }
      v14 = a1[6];
      if ( (unsigned int)v14 < 2 )
        return 0;
      v15 = v9 - 1;
      v16 = __CFADD__((_DWORD)v15, (_DWORD)v15);
      v17 = a3 + 8 * v9;
      v18 = a2 + 4 * v9;
      v19 = 1;
      if ( !(_DWORD)v9 )
        goto LABEL_17;
      break;
    default:
      return result;
  }
  while ( 1 )
  {
    v20 = (unsigned int *)((char *)&multiChnIdx + 4 * v19);
    LODWORD(a4) = dmxGains[v19];
    v21 = *v20;
    v22 = v20[4];
    if ( (unsigned int)v9 >= 4 )
    {
      v23 = 0;
      if ( ~(_DWORD)v22 >= (unsigned int)v15
        && ~(_DWORD)v21 >= (unsigned int)v15
        && v8 == 1
        && (v9 - 1) >> 32 == 0
        && !v16
        && 8 * v15 <= ~(a3 + 4)
        && v15 >> 61 == 0
        && 8 * v15 <= ~a3
        && v15 >> 61 == 0
        && (v18 + 4 * v22 <= a3 || a2 + 4 * v22 >= v17)
        && (v18 + 4 * v21 <= a3 || a2 + 4 * v21 >= v17) )
      {
        v29 = 0;
        v30 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
        v31 = 1;
        v32 = (unsigned int)v9 & 0xFFFFFFFC;
        do
        {
          v33 = (const float *)(a3 + 4LL * (v31 - 1));
          v89 = vld2q_f32(v33);
          v90.val[0] = vaddq_f32(v89.val[0], vmulq_f32(v30, *(float32x4_t *)(a2 + 4LL * (unsigned int)(v21 + v29))));
          v34 = (float *)(a3 - 4 + 4LL * v31);
          v35 = vmulq_f32(v30, *(float32x4_t *)(a2 + 4LL * (unsigned int)(v22 + v29)));
          v29 += 4 * v8;
          v32 -= 4;
          v90.val[1] = vaddq_f32(v89.val[1], v35);
          v31 += 8;
          vst2q_f32(v34, v90);
        }
        while ( v32 );
        v23 = (unsigned int)v9 & 0xFFFFFFFC;
        if ( v23 == v9 )
          goto LABEL_17;
      }
    }
    else
    {
      v23 = 0;
    }
    v24 = v8 * v23;
    v25 = 2 * v23;
    v26 = v9 - v23;
    do
    {
      --v26;
      *(float *)(a3 + 4LL * v25) = *(float *)(a3 + 4LL * v25)
                                 + (float)(*(float *)&a4 * *(float *)(a2 + 4LL * (unsigned int)(v21 + v24)));
      v27 = 4LL * (v25 + 1);
      v28 = *(float *)&a4 * *(float *)(a2 + 4LL * (unsigned int)(v22 + v24));
      v24 += v8;
      v25 += 2;
      *(float *)(a3 + v27) = *(float *)(a3 + v27) + v28;
    }
    while ( v26 );
    do
    {
LABEL_17:
      if ( ++v19 >= v14 )
        return 0;
    }
    while ( !(_DWORD)v9 );
  }
}
// 16F20: using guessed type _DWORD dmxGains[4];

//----- (00000000000378A8) ----------------------------------------------------
__int64 __fastcall channel_layout_converter_flush(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 28) )
    return 0;
  else
    return 9;
}

//----- (00000000000378BC) ----------------------------------------------------
__int64 __fastcall channel_layout_converter_reset(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 28) )
    return 0;
  else
    return 9;
}

//----- (00000000000378D0) ----------------------------------------------------
long double __fastcall iir_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x30u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (000000000003792C) ----------------------------------------------------
__int64 __fastcall iir_destroy(__int64 *a1)
{
  _QWORD *v1; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = (void *)v1[2];
  if ( v3 )
    free(v3);
  v4 = (void *)v1[3];
  v1[2] = 0;
  if ( v4 )
    free(v4);
  v5 = (void *)v1[4];
  v1[3] = 0;
  if ( v5 )
    free(v5);
  v6 = (void *)v1[5];
  v1[4] = 0;
  if ( v6 )
    free(v6);
  v1[5] = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (00000000000379B0) ----------------------------------------------------
__int64 __fastcall iir_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    return 9;
  memset(*(void **)(a1 + 16), 0, 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1));
  memset(*(void **)(a1 + 24), 0, 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1));
  return 0;
}

//----- (0000000000037A2C) ----------------------------------------------------
__int64 __fastcall iir_reset(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    return 9;
  v2 = *(void **)(a1 + 16);
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 0;
  if ( v3 )
    free(v3);
  v4 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = 0;
  if ( v4 )
    free(v4);
  v5 = *(void **)(a1 + 40);
  *(_QWORD *)(a1 + 32) = 0;
  if ( v5 )
    free(v5);
  result = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (0000000000037AAC) ----------------------------------------------------
__int64 __fastcall iir_setup(__int64 a1, size_t n, int a3, int a4, float *a5, float *a6)
{
  __int64 result; // x0
  int v9; // w22
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  __int64 v18; // x8
  size_t v19; // x22
  void *v20; // x0
  size_t v21; // x22
  void *v22; // x0
  size_t v23; // x22
  void *v24; // x0
  size_t v25; // x22
  double v26; // d0

  result = 0xFFFFFFFFLL;
  if ( a1 && a4 )
  {
    v9 = n;
    if ( !(_DWORD)n )
      return 1;
    if ( a3 )
    {
      if ( *(_BYTE *)(a1 + 8) )
      {
        v13 = *(void **)(a1 + 16);
        if ( v13 )
          free(v13);
        v14 = *(void **)(a1 + 24);
        *(_QWORD *)(a1 + 16) = 0;
        if ( v14 )
          free(v14);
        v15 = *(void **)(a1 + 32);
        *(_QWORD *)(a1 + 24) = 0;
        if ( v15 )
          free(v15);
        v16 = *(void **)(a1 + 40);
        *(_QWORD *)(a1 + 32) = 0;
        if ( v16 )
          free(v16);
        *(_QWORD *)(a1 + 40) = 0;
      }
      v17 = *(void **)(a1 + 16);
      v18 = (unsigned int)((a4 + 1) * v9);
      *(_DWORD *)a1 = v9;
      *(_DWORD *)(a1 + 4) = a3;
      v19 = 4 * v18;
      *(_DWORD *)(a1 + 12) = a4;
      if ( v17 || (v17 = malloc(4 * v18), (*(_QWORD *)(a1 + 16) = v17) != 0) )
      {
        memset(v17, 0, v19);
        v20 = *(void **)(a1 + 24);
        if ( v20 )
        {
          v21 = 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1);
        }
        else
        {
          v21 = 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1);
          v20 = malloc(v21);
          *(_QWORD *)(a1 + 24) = v20;
          if ( !v20 )
            goto LABEL_30;
        }
        memset(v20, 0, v21);
        v22 = *(void **)(a1 + 32);
        if ( v22 )
        {
          v23 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1);
        }
        else
        {
          v23 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1);
          v22 = malloc(v23);
          *(_QWORD *)(a1 + 32) = v22;
          if ( !v22 )
            goto LABEL_30;
        }
        memset(v22, 0, v23);
        v24 = *(void **)(a1 + 40);
        if ( v24 )
        {
          v25 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1);
LABEL_29:
          memset(v24, 0, v25);
          memset(*(void **)(a1 + 16), 0, 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1));
          memset(*(void **)(a1 + 24), 0, 4LL * (unsigned int)((*(_DWORD *)(a1 + 12) + 1) * *(_DWORD *)a1));
          *(_BYTE *)(a1 + 8) = 1;
          return iir_update(a1, a5, a6, v26);
        }
        v25 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1);
        v24 = malloc(v25);
        *(_QWORD *)(a1 + 40) = v24;
        if ( v24 )
          goto LABEL_29;
      }
LABEL_30:
      exit(1);
    }
    return 4;
  }
  return result;
}
// 37CC0: variable 'v26' is possibly undefined

//----- (0000000000037CCC) ----------------------------------------------------
__int64 __fastcall iir_update(__int64 a1, float *a2, float *a3, double a4)
{
  __int64 result; // x0
  float v7; // s1
  float v8; // s0
  __int64 v9; // x10
  float *v10; // x8
  float *v11; // x9
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x4
  unsigned __int64 v16; // x16
  unsigned __int64 v17; // x5
  unsigned __int64 v18; // x6
  float32x4_t v19; // q1
  float32x4_t *v20; // x14
  float32x4_t *v21; // x15
  float32x4_t *v22; // x16
  float32x4_t *v23; // x17
  unsigned __int64 v24; // x0
  float32x4_t v25; // q2
  float32x4_t v26; // q3
  float32x4_t v27; // q2
  float32x4_t v28; // q3
  __int64 v29; // x11
  float v30; // s1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 && a3 )
  {
    v7 = *a2;
    v8 = fabsf(*a2 + -1.0);
    if ( fabsf(*a2) <= 0.00001 && v8 > 0.00001 )
      return 0xFFFFFFFFLL;
    if ( v8 <= 0.00001 )
    {
      memcpy(*(void **)(a1 + 32), a2, 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1));
      memcpy(*(void **)(a1 + 40), a3, 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + 1));
    }
    else
    {
      v9 = *(unsigned int *)(a1 + 12);
      if ( (_DWORD)v9 != -1 )
      {
        v10 = *(float **)(a1 + 32);
        v11 = *(float **)(a1 + 40);
        *(float *)&a4 = 1.0 / (float)(v7 + 0.00001);
        *v10 = *(float *)&a4 * v7;
        *v11 = *(float *)&a4 * *a3;
        if ( (_DWORD)v9 )
        {
          v12 = v9 + 1;
          v13 = v12 - 1;
          if ( v12 - 1 < 8 )
          {
            v14 = 1;
            do
            {
LABEL_25:
              v29 = v14;
              v30 = a2[v14++];
              result = 0;
              v10[v29] = *(float *)&a4 * v30;
              v11[v29] = *(float *)&a4 * a3[v29];
            }
            while ( v14 < v12 );
            return result;
          }
          v15 = (unsigned __int64)&v11[v12];
          v16 = (unsigned __int64)&v10[v12];
          v17 = (unsigned __int64)&a2[v12];
          v18 = (unsigned __int64)&a3[v12];
          v14 = 1;
          if ( (unsigned __int64)(v10 + 1) < v15 && (unsigned __int64)(v11 + 1) < v16 )
            goto LABEL_25;
          if ( (unsigned __int64)(v10 + 1) < v17 && (unsigned __int64)(a2 + 1) < v16 )
            goto LABEL_25;
          if ( (unsigned __int64)(v10 + 1) < v18 && (unsigned __int64)(a3 + 1) < v16 )
            goto LABEL_25;
          if ( (unsigned __int64)(v11 + 1) < v17 && (unsigned __int64)(a2 + 1) < v15 )
            goto LABEL_25;
          if ( (unsigned __int64)(v11 + 1) < v18 && (unsigned __int64)(a3 + 1) < v15 )
            goto LABEL_25;
          v19 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
          v20 = (float32x4_t *)(a2 + 5);
          v21 = (float32x4_t *)(v11 + 5);
          v22 = (float32x4_t *)(v10 + 5);
          v14 = v13 & 0xFFFFFFFFFFFFFFF8LL | 1;
          v23 = (float32x4_t *)(a3 + 5);
          v24 = v13 & 0xFFFFFFFFFFFFFFF8LL;
          do
          {
            v25 = v20[-1];
            v26 = *v20;
            v24 -= 8LL;
            v20 += 2;
            v22[-1] = vmulq_f32(v19, v25);
            *v22 = vmulq_f32(v19, v26);
            v27 = v23[-1];
            v28 = *v23;
            v22 += 2;
            v23 += 2;
            v21[-1] = vmulq_f32(v19, v27);
            *v21 = vmulq_f32(v19, v28);
            v21 += 2;
          }
          while ( v24 );
          if ( v13 != (v13 & 0xFFFFFFFFFFFFFFF8LL) )
            goto LABEL_25;
        }
      }
    }
    return 0;
  }
  return result;
}

//----- (0000000000037F1C) ----------------------------------------------------
__int64 __fastcall iir_process(unsigned int *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x9
  unsigned int v6; // w11
  unsigned int v7; // w13
  float *v8; // x14
  __int64 v9; // x15
  __int64 v10; // x16
  unsigned __int64 v11; // x12
  __int64 v12; // x17
  unsigned int v13; // w7
  int i; // w19
  __int64 v15; // x20
  __int64 v16; // x22
  __int64 v17; // x7
  float v18; // w19
  float v19; // s0
  __int64 v20; // x20
  unsigned int v21; // w21
  float *v22; // x22
  float *v23; // x19
  __int64 v24; // x23
  float v25; // t1
  float v26; // s1
  float v27; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 8) )
    return 9;
  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    v4 = a1[1];
    v5 = 0;
    v6 = *a1;
    if ( (_DWORD)v4 )
      goto LABEL_7;
    while ( 1 )
    {
      ++v5;
      ++v6;
      if ( v5 >= v3 )
        break;
      if ( (_DWORD)v4 )
      {
LABEL_7:
        v7 = a1[3];
        v8 = (float *)*((_QWORD *)a1 + 5);
        v9 = *((_QWORD *)a1 + 2);
        v10 = *((_QWORD *)a1 + 3);
        v11 = 0;
        v12 = v7 + 1;
        do
        {
          v13 = v7;
          for ( i = v5; v13; *(_DWORD *)(v10 + v16) = *(_DWORD *)(v10 + v15) )
          {
            v15 = 4LL * ((unsigned int)v3 * (v7 - 1) + i);
            v16 = 4LL * ((unsigned int)v3 * v7 + i);
            --v13;
            *(_DWORD *)(v9 + v16) = *(_DWORD *)(v9 + v15);
            i -= v3;
          }
          v17 = (unsigned int)(v5 + v3 * v11);
          v18 = *(float *)(a2 + 4LL * (unsigned int)v17);
          *(float *)(v9 + 4 * v5) = v18;
          v19 = *v8 * v18;
          if ( (unsigned int)v12 >= 2 )
          {
            v20 = v12 - 1;
            v21 = v6;
            v22 = v8 + 1;
            v23 = (float *)(*((_QWORD *)a1 + 4) + 4LL);
            do
            {
              v24 = 4LL * v21;
              v25 = *v22++;
              v26 = v25;
              v27 = *v23++;
              --v20;
              v21 += v3;
              v19 = v19 + (float)((float)(v26 * *(float *)(v9 + v24)) - (float)(v27 * *(float *)(v10 + v24)));
            }
            while ( v20 );
          }
          ++v11;
          *(float *)(v10 + 4 * v5) = v19;
          *(float *)(a3 + 4 * v17) = v19;
        }
        while ( v11 < v4 );
      }
    }
  }
  return 0;
}

//----- (0000000000038068) ----------------------------------------------------
__int64 __fastcall iir_process_inplace(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x10
  unsigned __int64 v4; // x9
  unsigned int v5; // w11
  unsigned int v6; // w13
  float *v7; // x14
  __int64 v8; // x15
  __int64 v9; // x16
  unsigned __int64 v10; // x12
  __int64 v11; // x17
  unsigned int v12; // w6
  int i; // w7
  __int64 v14; // x19
  __int64 v15; // x21
  __int64 v16; // x6
  float v17; // w7
  float v18; // s0
  __int64 v19; // x19
  unsigned int v20; // w20
  float *v21; // x21
  float *v22; // x7
  __int64 v23; // x22
  float v24; // t1
  float v25; // s1
  float v26; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 8) )
    return 9;
  v2 = *a1;
  if ( (_DWORD)v2 )
  {
    v3 = a1[1];
    v4 = 0;
    v5 = *a1;
    if ( (_DWORD)v3 )
      goto LABEL_7;
    while ( 1 )
    {
      ++v4;
      ++v5;
      if ( v4 >= v2 )
        break;
      if ( (_DWORD)v3 )
      {
LABEL_7:
        v6 = a1[3];
        v7 = (float *)*((_QWORD *)a1 + 5);
        v8 = *((_QWORD *)a1 + 2);
        v9 = *((_QWORD *)a1 + 3);
        v10 = 0;
        v11 = v6 + 1;
        do
        {
          v12 = v6;
          for ( i = v4; v12; *(_DWORD *)(v9 + v15) = *(_DWORD *)(v9 + v14) )
          {
            v14 = 4LL * ((unsigned int)v2 * (v6 - 1) + i);
            v15 = 4LL * ((unsigned int)v2 * v6 + i);
            --v12;
            *(_DWORD *)(v8 + v15) = *(_DWORD *)(v8 + v14);
            i -= v2;
          }
          v16 = (unsigned int)(v4 + v2 * v10);
          v17 = *(float *)(a2 + 4LL * (unsigned int)v16);
          *(float *)(v8 + 4 * v4) = v17;
          v18 = *v7 * v17;
          if ( (unsigned int)v11 >= 2 )
          {
            v19 = v11 - 1;
            v20 = v5;
            v21 = v7 + 1;
            v22 = (float *)(*((_QWORD *)a1 + 4) + 4LL);
            do
            {
              v23 = 4LL * v20;
              v24 = *v21++;
              v25 = v24;
              v26 = *v22++;
              --v19;
              v20 += v2;
              v18 = v18 + (float)((float)(v25 * *(float *)(v8 + v23)) - (float)(v26 * *(float *)(v9 + v23)));
            }
            while ( v19 );
          }
          ++v10;
          *(float *)(v9 + 4 * v4) = v18;
          *(float *)(a2 + 4 * v16) = v18;
        }
        while ( v10 < v3 );
      }
    }
  }
  return 0;
}

//----- (00000000000381AC) ----------------------------------------------------
long double __fastcall sln_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x58u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[10] = 0;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)v2 = 0u;
  }
  return result;
}

//----- (0000000000038210) ----------------------------------------------------
__int64 __fastcall sln_destroy(__int64 *a1)
{
  __int64 v1; // x20
  void *v3; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  iir_destroy((__int64 *)(v1 + 64));
  iir_destroy((__int64 *)(v1 + 72));
  loudness_measure_destroy((void ***)(v1 + 80));
  v3 = *(void **)(v1 + 56);
  if ( v3 )
  {
    free(v3);
    *(_QWORD *)(v1 + 56) = 0;
  }
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003827C) ----------------------------------------------------
__int64 __fastcall sln_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 32) )
    return 9;
  sub_382B8((unsigned int *)a1);
  return 0;
}

//----- (00000000000382B8) ----------------------------------------------------
__int64 __fastcall sub_382B8(unsigned int *a1)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x9
  unsigned __int64 i; // x10
  _OWORD *v5; // x11
  unsigned __int64 v11; // x12
  float v12; // s9
  float v13; // s0
  float v14; // s3
  float v15; // s1
  float v16; // s0
  float v17; // s4
  float v18; // s0
  float v19; // s1
  float v20; // s0
  float v21; // s3
  unsigned __int64 v23; // [xsp+8h] [xbp-78h] BYREF
  int v24; // [xsp+10h] [xbp-70h]
  float v25[3]; // [xsp+14h] [xbp-6Ch] BYREF
  float v26[3]; // [xsp+20h] [xbp-60h] BYREF
  float v27[3]; // [xsp+2Ch] [xbp-54h] BYREF
  __int64 v28; // [xsp+38h] [xbp-48h]

  v28 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = a1[4];
  *(_OWORD *)(a1 + 9) = xmmword_16920;
  a1[13] = 0;
  a1[3] = 0;
  if ( (_DWORD)v2 )
  {
    v3 = *((_QWORD *)a1 + 7);
    if ( (unsigned int)v2 <= 7 )
    {
      for ( i = 0; i < v2; ++i )
LABEL_7:
        *(_DWORD *)(v3 + 4 * i) = 1065353216;
      goto LABEL_8;
    }
    i = (unsigned int)v2 & 0xFFFFFFF8;
    v5 = (_OWORD *)(v3 + 16);
    __asm { FMOV            V0.4S, #1.0 }
    v11 = i;
    do
    {
      *(v5 - 1) = _Q0;
      *v5 = _Q0;
      v11 -= 8LL;
      v5 += 2;
    }
    while ( v11 );
    if ( i != v2 )
      goto LABEL_7;
  }
LABEL_8:
  v12 = (float)a1[1];
  v13 = tanf((float)(1682.0 / v12) * 3.1416);
  v14 = v13 * 1.2587;
  v15 = v13 * v13;
  v16 = v13 / 0.70718;
  v17 = v15 + (float)(v16 + 1.0);
  v27[1] = (float)((float)(v15 + -1.0) + (float)(v15 + -1.0)) / v17;
  v27[2] = (float)(v15 + (float)(1.0 - v16)) / v17;
  v26[0] = (float)(v15 + (float)((float)(v14 / 0.70718) + 1.5849)) / v17;
  v26[1] = (float)((float)(v15 + -1.5849) + (float)(v15 + -1.5849)) / v17;
  v27[0] = 1.0;
  v26[2] = (float)(v15 + (float)(1.5849 - (float)(v14 / 0.70718))) / v17;
  v18 = tanf((float)(38.135 / v12) * 3.1416);
  v19 = v18 * v18;
  v20 = v18 / 0.50033;
  v21 = v19 + (float)(v20 + 1.0);
  v24 = 1065353216;
  v25[0] = 1.0;
  v25[1] = (float)((float)(v19 + -1.0) + (float)(v19 + -1.0)) / v21;
  v25[2] = (float)(v19 + (float)(1.0 - v20)) / v21;
  v23 = 0xC00000003F800000LL;
  iir_setup(*((_QWORD *)a1 + 8), *a1, a1[2], 2, v27, v26);
  iir_setup(*((_QWORD *)a1 + 9), *a1, a1[2], 2, v25, (float *)&v23);
  return loudness_measure_setup(*((_QWORD *)a1 + 10), *a1, a1[1], a1[2], *((_QWORD *)a1 + 3));
}
// 16920: using guessed type __int128 xmmword_16920;

//----- (00000000000384F8) ----------------------------------------------------
__int64 __fastcall sln_reset(__int64 a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 32) )
    return 9;
  iir_destroy((__int64 *)(a1 + 64));
  iir_destroy((__int64 *)(a1 + 72));
  loudness_measure_destroy((void ***)(a1 + 80));
  v2 = *(void **)(a1 + 56);
  if ( v2 )
  {
    free(v2);
    *(_QWORD *)(a1 + 56) = 0;
  }
  result = 0;
  *(_BYTE *)(a1 + 32) = 0;
  return result;
}

//----- (0000000000038560) ----------------------------------------------------
__int64 __fastcall sln_setup(__int64 a1, int a2, int a3, unsigned int a4, unsigned __int64 a5)
{
  __int64 result; // x0
  void *v7; // x0
  size_t v8; // x20

  if ( !a1 || *(_BYTE *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 3;
  if ( !a4 )
    return 4;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  *(_DWORD *)a1 = a2;
  *(_QWORD *)(a1 + 24) = a5;
  *(_DWORD *)(a1 + 16) = a5 / a4 + 20;
  iir_create((_QWORD *)(a1 + 64));
  iir_create((_QWORD *)(a1 + 72));
  loudness_measure_create((_QWORD *)(a1 + 80));
  v7 = *(void **)(a1 + 56);
  if ( v7 )
  {
    v8 = 4LL * *(unsigned int *)(a1 + 16);
  }
  else
  {
    v8 = 4LL * *(unsigned int *)(a1 + 16);
    v7 = malloc(v8);
    *(_QWORD *)(a1 + 56) = v7;
    if ( !v7 )
      exit(1);
  }
  memset(v7, 0, v8);
  sub_382B8((unsigned int *)a1);
  result = 0;
  *(_BYTE *)(a1 + 32) = 1;
  return result;
}

//----- (000000000003863C) ----------------------------------------------------
__int64 __fastcall sln_sol_process(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 32) )
    return 9;
  iir_process(*(unsigned int **)(a1 + 64), a2, a3);
  iir_process_inplace(*(unsigned int **)(a1 + 72), a3);
  loudness_measure_process(*(unsigned int **)(a1 + 80), a3);
  return 0;
}

//----- (00000000000386A0) ----------------------------------------------------
__int64 __fastcall sln_process_inplace(
        int *a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 v10; // x9
  float v11; // w10
  float v12; // s3
  unsigned int v13; // w8
  __int64 v15; // x12
  unsigned int v16; // w11
  int32x4_t v17; // q1
  float32x4_t v18; // q3
  float32x4_t v19; // q5
  int32x4_t v20; // q6
  __int64 v21; // x17
  float32x4_t v22; // q16
  __int64 v23; // x17
  unsigned int v24; // w2
  int32x4_t v25; // q17
  float32x4_t *v26; // x3
  float32x4_t v27; // q19
  float32x4_t v28; // q18
  float32x4_t v29; // q18
  unsigned int v30; // w2
  __int64 v31; // x3
  float v32; // s16

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 32) )
    return 9;
  v10 = (unsigned int)a1[3];
  if ( (unsigned int)v10 < a1[4] )
  {
    v11 = *(float *)(*((_QWORD *)a1 + 7) + 4 * v10);
    v12 = v11;
    *((float *)a1 + 12) = v11;
    v13 = *a1;
    if ( !*a1 )
      goto LABEL_23;
    goto LABEL_9;
  }
  v12 = *((float *)a1 + 12);
  v11 = v12;
  v13 = *a1;
  if ( *a1 )
  {
LABEL_9:
    LODWORD(a3) = a1[11];
    v15 = (unsigned int)a1[2];
    *(float *)&a7 = (float)(v12 - *(float *)&a3) / (float)(unsigned int)v15;
    v16 = 0;
    v17.n128_u64[0] = 0x400000004LL;
    v17.n128_u64[1] = 0x400000004LL;
    v18 = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
    v19 = vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    v20.n128_u64[0] = 0x800000008LL;
    v20.n128_u64[1] = 0x800000008LL;
    if ( (_DWORD)v15 )
      goto LABEL_12;
    while ( 1 )
    {
      do
      {
        if ( ++v16 >= v13 )
          goto LABEL_23;
      }
      while ( !(_DWORD)v15 );
LABEL_12:
      LODWORD(a10) = a1[13];
      if ( (unsigned int)v15 <= 7 )
        break;
      v21 = 0;
      if ( v13 == 1 && ~v16 >= (int)v15 - 1 && !((unsigned __int64)(v15 - 1) >> 32) )
      {
        v22 = vdupq_lane_s32(*(int32x2_t *)&a10, 0);
        v23 = (unsigned int)v15 & 0xFFFFFFF8;
        v24 = v16;
        v25 = (int32x4_t)xmmword_16940;
        do
        {
          v26 = (float32x4_t *)(a2 + 4LL * v24);
          v27 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v19, vcvtq_f32_u32(v25))), v22);
          v28 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v19, vcvtq_f32_u32(vaddq_s32(v25, v17)))), v22);
          v25 = vaddq_s32(v25, v20);
          v23 -= 8;
          v29 = vmulq_f32(v26[1], v28);
          v24 += 8 * v13;
          *v26 = vmulq_f32(*v26, v27);
          v26[1] = v29;
        }
        while ( v23 );
        v21 = (unsigned int)v15 & 0xFFFFFFF8;
        if ( v21 == v15 )
          continue;
      }
LABEL_20:
      v30 = v16 + v13 * v21;
      do
      {
        v31 = 4LL * v30;
        v32 = *(float *)&a3 + (float)(*(float *)&a7 * (float)(unsigned int)v21++);
        v30 += v13;
        *(float *)(a2 + v31) = *(float *)(a2 + v31) * (float)(v32 * *(float *)&a10);
      }
      while ( v15 != v21 );
    }
    v21 = 0;
    goto LABEL_20;
  }
LABEL_23:
  *((float *)a1 + 11) = v11;
  a1[3] = v10 + 1;
  return 0;
}
// 16940: using guessed type __int128 xmmword_16940;

//----- (0000000000038834) ----------------------------------------------------
__int64 __fastcall sln_update(__int64 a1, float a2)
{
  __int64 v3; // x0
  float v4; // s1
  float v5; // s0
  float v6; // s0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 32) )
    return 9;
  v3 = *(_QWORD *)(a1 + 80);
  *(float *)(a1 + 36) = a2;
  loudness_measure_getIntegratedLoudness(v3);
  v4 = *(float *)(a1 + 36);
  *(float *)(a1 + 40) = v5;
  v6 = powf(10.0, (float)(v4 - v5) / 20.0);
  result = 0;
  *(float *)(a1 + 52) = v6;
  return result;
}
// 38860: variable 'v5' is possibly undefined

//----- (000000000003889C) ----------------------------------------------------
__int64 __fastcall sln_lra_control(__int64 a1, float a2)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 32) )
  {
    if ( (unsigned int)loudness_measure_get_frameLength(*(_QWORD *)(a1 + 80)) )
    {
      loudness_measure_getFramewiseGainArray(*(_QWORD *)(a1 + 80), *(float **)(a1 + 56), a2);
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  return 9;
}

//----- (0000000000038900) ----------------------------------------------------
__int64 __fastcall sln_process(__int64 a1, __int64 a2, __int64 a3, double a4, double a5)
{
  __int64 v5; // x9
  int v6; // w10
  unsigned int v7; // w8
  unsigned int v8; // w8
  __int64 v9; // x11
  __int64 v10; // x10
  float32x4_t v11; // q2
  int32x4_t v12; // q3
  __int64 v13; // x3
  __int64 v14; // x5
  unsigned __int64 v15; // x7
  unsigned __int64 v16; // x6
  bool v17; // cf
  unsigned __int64 v18; // x5
  bool v19; // w19
  const float *v20; // x3
  const float *v21; // x4
  float32x4_t v22; // q4
  float32x4_t v23; // q5
  __int64 v24; // x3
  unsigned int v25; // w4
  int32x4_t v26; // q6
  __int64 v27; // x5
  float32x4_t v28; // q7
  unsigned int v29; // w4
  __int64 v30; // x5
  float v31; // s5

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 32) )
    {
      v5 = *(unsigned int *)(a1 + 12);
      if ( (unsigned int)v5 >= *(_DWORD *)(a1 + 16) )
      {
        LODWORD(a5) = *(_DWORD *)(a1 + 48);
        v6 = LODWORD(a5);
        v7 = *(_DWORD *)a1;
        if ( !*(_DWORD *)a1 )
          goto LABEL_29;
      }
      else
      {
        v6 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v5);
        LODWORD(a5) = v6;
        *(_DWORD *)(a1 + 48) = v6;
        v7 = *(_DWORD *)a1;
        if ( !*(_DWORD *)a1 )
        {
LABEL_29:
          v8 = 0;
          *(_DWORD *)(a1 + 44) = v6;
          *(_DWORD *)(a1 + 12) = v5 + 1;
          return v8;
        }
      }
      v9 = *(unsigned int *)(a1 + 8);
      *(float *)&a5 = (float)(*(float *)&a5 - *(float *)(a1 + 44)) / (float)(unsigned int)v9;
      v10 = 0;
      v11 = vdupq_lane_s32(*(int32x2_t *)&a5, 0);
      v12.n128_u64[0] = 0x400000004LL;
      v12.n128_u64[1] = 0x400000004LL;
      if ( (_DWORD)v9 )
        goto LABEL_12;
      while ( 1 )
      {
        do
        {
          if ( (unsigned int)++v10 >= v7 )
          {
            v6 = *(_DWORD *)(a1 + 48);
            goto LABEL_29;
          }
        }
        while ( !(_DWORD)v9 );
LABEL_12:
        if ( (unsigned int)v9 <= 3 )
          break;
        v13 = 0;
        if ( v7 == 1 && ~(_DWORD)v10 >= (unsigned int)(v9 - 1) && !((unsigned __int64)(v9 - 1) >> 32) )
        {
          v14 = 4 * (v10 + v9);
          v15 = a3 + v14;
          v16 = a3 + 4 * v10;
          v17 = a1 + 52 >= (unsigned __int64)(a3 + v14);
          v18 = a2 + v14;
          v19 = !v17;
          v13 = 0;
          if ( (!v19 || a1 + 53 <= v16) && (v16 >= v18 || a2 + 4 * v10 >= v15) )
          {
            v20 = (const float *)(a1 + 44);
            v21 = (const float *)(a1 + 52);
            v22 = vld1q_dup_f32(v20);
            v23 = vld1q_dup_f32(v21);
            v24 = (unsigned int)v9 & 0xFFFFFFFC;
            v25 = v10;
            v26 = (int32x4_t)xmmword_16940;
            do
            {
              v27 = 4LL * v25;
              v28 = vmulq_f32(*(float32x4_t *)(a2 + v27), vaddq_f32(vmulq_f32(v11, vcvtq_f32_u32(v26)), v22));
              v26 = vaddq_s32(v26, v12);
              v24 -= 4;
              v25 += 4 * v7;
              *(float32x4_t *)(a3 + v27) = vmulq_f32(v23, v28);
            }
            while ( v24 );
            v13 = (unsigned int)v9 & 0xFFFFFFFC;
            if ( v13 == v9 )
              continue;
          }
        }
LABEL_25:
        v29 = v10 + v7 * v13;
        do
        {
          v30 = 4LL * v29;
          v31 = *(float *)&a5 * (float)(unsigned int)v13++;
          v29 += v7;
          *(float *)(a3 + v30) = *(float *)(a1 + 52)
                               * (float)(*(float *)(a2 + v30) * (float)(v31 + *(float *)(a1 + 44)));
        }
        while ( v9 != v13 );
      }
      v13 = 0;
      goto LABEL_25;
    }
    return 9;
  }
  else
  {
    return (unsigned int)-1;
  }
}
// 16940: using guessed type __int128 xmmword_16940;

//----- (0000000000038AE8) ----------------------------------------------------
void __fastcall sln_get_integrateloudness(__int64 a1)
{
  loudness_measure_getIntegratedLoudness(*(_QWORD *)(a1 + 80));
}

//----- (0000000000038AF0) ----------------------------------------------------
long double __fastcall eleq_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x60u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  return result;
}

//----- (0000000000038B50) ----------------------------------------------------
__int64 __fastcall eleq_destroy(__int64 *a1)
{
  __int64 v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_38B98(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0000000000038B98) ----------------------------------------------------
void __fastcall sub_38B98(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0

  v2 = *(void **)(a1 + 72);
  if ( v2 )
  {
    free(v2);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v3 = *(void **)(a1 + 32);
  if ( v3 )
  {
    free(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v4 = *(void **)(a1 + 40);
  if ( v4 )
  {
    free(v4);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v5 = *(void **)(a1 + 48);
  if ( v5 )
  {
    free(v5);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v6 = *(void **)(a1 + 56);
  if ( v6 )
  {
    free(v6);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(void **)(a1 + 64);
  if ( v7 )
  {
    free(v7);
    *(_QWORD *)(a1 + 64) = 0;
  }
  if ( *(_QWORD *)(a1 + 80) )
  {
    iir_destroy((__int64 *)(a1 + 80));
    *(_QWORD *)(a1 + 80) = 0;
  }
  if ( *(_QWORD *)(a1 + 88) )
  {
    iir_destroy((__int64 *)(a1 + 88));
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_BYTE *)(a1 + 16) = 0;
}

//----- (0000000000038C48) ----------------------------------------------------
__int64 __fastcall eleq_flush(__int64 a1)
{
  __int64 v2; // x8

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  iir_flush(*(_QWORD *)(a1 + 80));
  iir_flush(*(_QWORD *)(a1 + 88));
  v2 = *(_QWORD *)(a1 + 32);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 20) = _D0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_QWORD *)v2 = 0;
  memset(*(void **)(a1 + 72), 0, 4LL * (unsigned int)(*(_DWORD *)(a1 + 8) * *(_DWORD *)a1));
  return 0;
}

//----- (0000000000038CC4) ----------------------------------------------------
__int64 __fastcall eleq_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  sub_38B98(a1);
  result = 0;
  *(_BYTE *)(a1 + 16) = 0;
  return result;
}

//----- (0000000000038D0C) ----------------------------------------------------
__int64 __fastcall eleq_setup(unsigned int *a1, unsigned int a2, unsigned int a3, size_t n)
{
  unsigned int v4; // w20
  void *v8; // x0
  __int64 v9; // x8
  size_t v10; // x20
  _OWORD *v11; // x0
  _DWORD *v12; // x0
  _DWORD *v13; // x0
  _DWORD *v14; // x0
  _DWORD *v15; // x0
  __int64 v16; // x8
  double v22; // d0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = n;
  if ( !(_DWORD)n )
    return 4;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 3;
  if ( *((_BYTE *)a1 + 16) )
    sub_38B98((__int64)a1);
  v8 = (void *)*((_QWORD *)a1 + 9);
  a1[2] = v4;
  a1[3] = v4 * a2;
  v9 = v4 * a2;
  v10 = 4 * v9;
  *a1 = a2;
  a1[1] = a3;
  if ( !v8 )
  {
    v8 = malloc(4 * v9);
    *((_QWORD *)a1 + 9) = v8;
    if ( !v8 )
      goto LABEL_24;
  }
  memset(v8, 0, v10);
  v11 = (_OWORD *)*((_QWORD *)a1 + 4);
  if ( !v11 )
  {
    v11 = malloc(0x2Cu);
    *((_QWORD *)a1 + 4) = v11;
    if ( !v11 )
      goto LABEL_24;
  }
  *(_OWORD *)((char *)v11 + 28) = 0u;
  *v11 = 0u;
  v11[1] = 0u;
  v12 = (_DWORD *)*((_QWORD *)a1 + 5);
  if ( !v12 )
  {
    v12 = malloc(0xCu);
    *((_QWORD *)a1 + 5) = v12;
    if ( !v12 )
      goto LABEL_24;
  }
  v12[2] = 0;
  *(_QWORD *)v12 = 0;
  v13 = (_DWORD *)*((_QWORD *)a1 + 6);
  if ( !v13 )
  {
    v13 = malloc(0xCu);
    *((_QWORD *)a1 + 6) = v13;
    if ( !v13 )
      goto LABEL_24;
  }
  v13[2] = 0;
  *(_QWORD *)v13 = 0;
  v14 = (_DWORD *)*((_QWORD *)a1 + 7);
  if ( !v14 )
  {
    v14 = malloc(0xCu);
    *((_QWORD *)a1 + 7) = v14;
    if ( !v14 )
      goto LABEL_24;
  }
  v14[2] = 0;
  *(_QWORD *)v14 = 0;
  v15 = (_DWORD *)*((_QWORD *)a1 + 8);
  if ( !v15 )
  {
    v15 = malloc(0xCu);
    *((_QWORD *)a1 + 8) = v15;
    if ( !v15 )
LABEL_24:
      exit(1);
  }
  v15[2] = 0;
  *(_QWORD *)v15 = 0;
  iir_create((_QWORD *)a1 + 10);
  iir_create((_QWORD *)a1 + 11);
  v16 = *((_QWORD *)a1 + 4);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 5) = _D0;
  *(_DWORD *)(v16 + 8) = 0;
  *(_QWORD *)v16 = 0;
  memset(*((void **)a1 + 9), 0, 4LL * a1[2] * *a1);
  iir_setup(*((_QWORD *)a1 + 10), *a1, a1[2], 2, *((float **)a1 + 7), *((float **)a1 + 5));
  iir_setup(*((_QWORD *)a1 + 11), *a1, a1[2], 2, *((float **)a1 + 8), *((float **)a1 + 6));
  LODWORD(v22) = 7.0;
  *((_BYTE *)a1 + 16) = 1;
  eleq_update((__int64)a1, 0, v22, -24.0, 0.0, 0.0, -7.0);
  return 0;
}
// 38EC4: variable 'v22' is possibly undefined

//----- (0000000000038F04) ----------------------------------------------------
__int64 __fastcall eleq_update(__int64 a1, char a2, double a3, float a4, float a5, float a6, float a7)
{
  __int64 result; // x0
  float v9; // s8
  float v11; // s2
  float v12; // s1
  int v13; // w8
  int v14; // w20
  char *v15; // x10
  char *v16; // x10
  int v17; // w9
  _DWORD *v18; // x8
  __int64 v19; // x2
  _DWORD *v20; // x10
  __int64 v21; // x1
  _DWORD *v22; // x10
  double v23; // d0
  float v24; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a7 <= 0.0 )
  {
    v9 = *(float *)&a3;
    if ( a7 >= -90.0
      && a6 <= 32.0
      && a6 >= -32.0
      && a5 <= 0.0
      && a5 >= -80.0
      && a4 <= 0.0
      && *(float *)&a3 >= 0.0
      && *(float *)&a3 <= 20.0
      && a4 >= -70.0 )
    {
      v11 = fminf(a5, 0.0);
      if ( a2 == 1 )
        v12 = (float)((float)((float)-a4 - v11) + -20.0) + 1.0;
      else
        v12 = fminf((float)(a7 - a4) * 3.0, (float)((float)((float)-a4 - v11) + -20.0) + 1.0);
      *(float *)&a3 = fminf(roundf(fmaxf(v12, 1.0)), 81.0);
      v13 = (int)*(float *)&a3;
      if ( (int)*(float *)&a3 >= 80 )
        v13 = 80;
      if ( v13 <= 1 )
        v14 = 1;
      else
        v14 = v13;
      if ( *(_DWORD *)(a1 + 4) >= 0xB3E3u )
        v15 = (char *)&ELEQ_EQ48000;
      else
        v15 = (char *)&ELEQ_EQ44100;
      v16 = &v15[40 * v14 - 40];
      v17 = *(_DWORD *)v16;
      v18 = *(_DWORD **)(a1 + 32);
      *v18 = *(_DWORD *)v16;
      v18[1] = *((_DWORD *)v16 + 1);
      v18[2] = *((_DWORD *)v16 + 2);
      v18[3] = *((_DWORD *)v16 + 3);
      v18[4] = *((_DWORD *)v16 + 4);
      v18[5] = *((_DWORD *)v16 + 5);
      v18[6] = *((_DWORD *)v16 + 6);
      v18[7] = *((_DWORD *)v16 + 7);
      v18[8] = *((_DWORD *)v16 + 8);
      v18[9] = *((_DWORD *)v16 + 9);
      v19 = *(_QWORD *)(a1 + 40);
      v20 = *(_DWORD **)(a1 + 48);
      *(_DWORD *)v19 = v17;
      *v20 = v18[5];
      *(_DWORD *)(v19 + 4) = v18[1];
      v20[1] = v18[6];
      *(_DWORD *)(v19 + 8) = v18[2];
      v20[2] = v18[7];
      v21 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)v21 = 1065353216;
      v22 = *(_DWORD **)(a1 + 64);
      *v22 = 1065353216;
      *(_DWORD *)(v21 + 4) = v18[3];
      v22[1] = v18[8];
      *(_DWORD *)(v21 + 8) = v18[4];
      v22[2] = v18[9];
      iir_update(*(_QWORD *)(a1 + 80), (float *)v21, (float *)v19, a3);
      iir_update(*(_QWORD *)(a1 + 88), *(float **)(a1 + 64), *(float **)(a1 + 48), v23);
      v24 = powf(
              10.0,
              (float)((float)((float)-a6 - v9) * fmaxf(fminf((float)((float)v14 * 2.3) / -80.0, 0.0), -1.0)) / 20.0);
      result = 0;
      *(float *)(a1 + 20) = v24;
    }
  }
  return result;
}
// 39144: variable 'v23' is possibly undefined

//----- (00000000000391AC) ----------------------------------------------------
__int64 __fastcall eleq_process(int *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x8
  float v6; // s0
  float v7; // s1
  __int64 v8; // x10
  unsigned int v9; // w11
  unsigned __int64 v10; // x9
  float v11; // s2
  __int64 v12; // x12
  unsigned int v13; // w13
  float v14; // s3
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 16) )
    return 9;
  iir_process(*((unsigned int **)a1 + 10), a2, a3);
  iir_process(*((unsigned int **)a1 + 11), a3, *((_QWORD *)a1 + 9));
  v5 = (unsigned int)a1[3];
  v6 = *((float *)a1 + 5);
  if ( (_DWORD)v5 )
  {
    v7 = *((float *)a1 + 6);
    v8 = *((_QWORD *)a1 + 9);
    v9 = *a1;
    v10 = 0;
    v11 = (float)(v6 - v7) / (float)(unsigned int)a1[2];
    do
    {
      v12 = 4 * v10;
      v13 = (unsigned int)v10 / v9;
      v14 = *(float *)(v8 + 4 * v10++);
      *(float *)(a3 + v12) = v14 * (float)(v7 + (float)(v11 * (float)v13));
    }
    while ( v10 < v5 );
  }
  result = 0;
  *((float *)a1 + 6) = v6;
  return result;
}

//----- (0000000000039260) ----------------------------------------------------
__int64 __fastcall eleq_bypass(unsigned int *a1, const void *a2, void *dest)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 16) )
    return 9;
  memcpy(dest, a2, 4 * *a1 * (unsigned __int64)a1[2]);
  return 0;
}

//----- (00000000000392B4) ----------------------------------------------------
long double __fastcall graphic_equalizer_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x40u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  return result;
}

//----- (0000000000039310) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_destroy(__int64 *a1)
{
  __int64 v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_39358(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0000000000039358) ----------------------------------------------------
void __fastcall sub_39358(__int64 a1)
{
  char *v2; // x0
  __int64 v3; // x20
  unsigned __int64 v4; // x21
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0

  v2 = *(char **)(a1 + 56);
  if ( v2 )
  {
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_6;
    v3 = 0;
    v4 = 0;
    do
    {
      iir_destroy((__int64 *)&v2[v3]);
      v2 = *(char **)(a1 + 56);
      ++v4;
      v3 += 8;
    }
    while ( v4 < *(unsigned int *)(a1 + 16) );
    if ( v2 )
    {
LABEL_6:
      free(v2);
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  v5 = *(void **)(a1 + 24);
  if ( v5 )
    free(v5);
  v6 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = 0;
  if ( v6 )
    free(v6);
  v7 = *(void **)(a1 + 40);
  *(_QWORD *)(a1 + 32) = 0;
  if ( v7 )
    free(v7);
  v8 = *(void **)(a1 + 48);
  *(_QWORD *)(a1 + 40) = 0;
  if ( v8 )
    free(v8);
  *(_QWORD *)(a1 + 48) = 0;
}

//----- (0000000000039400) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_flush(__int64 a1)
{
  unsigned __int64 v2; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  if ( *(_DWORD *)(a1 + 16) )
  {
    v2 = 0;
    do
      iir_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v2++));
    while ( v2 < *(unsigned int *)(a1 + 16) );
  }
  sub_3946C(a1);
  return 0;
}

//----- (000000000003946C) ----------------------------------------------------
long double __fastcall sub_3946C(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x8
  long double result; // q0
  _OWORD *v4; // x8
  __int64 v5; // x8

  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 3:
      v1 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v1 + 8) = 1171963904;
      *(_QWORD *)v1 = 0x44BB800042C80000LL;
      break;
    case 5:
      v2 = *(_QWORD *)(a1 + 40);
      result = *(long double *)&xmmword_172DC;
      *(_DWORD *)(v2 + 16) = 1162551296;
      *(_OWORD *)v2 = xmmword_172DC;
      break;
    case 7:
      v4 = *(_OWORD **)(a1 + 40);
      result = *(long double *)((char *)&xmmword_172F0 + 12);
      *(_OWORD *)((char *)v4 + 12) = *(__int128 *)((char *)&xmmword_172F0 + 12);
      *v4 = xmmword_172F0;
      break;
    case 0xA:
      v5 = *(_QWORD *)(a1 + 40);
      result = *(long double *)&xmmword_1730C;
      *(_QWORD *)(v5 + 32) = 0x467A000045FA0000LL;
      *(_OWORD *)v5 = xmmword_1730C;
      *(_OWORD *)(v5 + 16) = xmmword_1731C;
      break;
    default:
      return result;
  }
  return result;
}
// 172DC: using guessed type __int128 xmmword_172DC;
// 172F0: using guessed type __int128 xmmword_172F0;
// 1730C: using guessed type __int128 xmmword_1730C;
// 1731C: using guessed type __int128;

//----- (0000000000039514) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_reset(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  if ( *(_DWORD *)(a1 + 16) )
  {
    v2 = 0;
    do
      iir_reset(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v2++));
    while ( v2 < *(unsigned int *)(a1 + 16) );
  }
  sub_39358(a1);
  result = 0;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}

//----- (0000000000039584) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_setup(__int64 a1, int a2, int a3, int a4, size_t n)
{
  unsigned int v8; // w20
  __int64 result; // x0
  void *v11; // x0
  size_t v12; // x20
  void *v13; // x0
  size_t v14; // x20
  void *v15; // x0
  size_t v16; // x20
  void *v17; // x0
  size_t v18; // x20
  void *v19; // x0
  size_t v20; // x20
  __int64 v21; // x20
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  __int64 v27; // x13
  unsigned __int64 v28; // x20
  unsigned __int64 v29; // x1
  unsigned __int64 v30; // x2
  _OWORD *v31; // x12
  _OWORD *v32; // x13
  unsigned __int64 v38; // x14

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 3;
  if ( !a4 )
    return 4;
  v8 = n;
  result = 0xFFFFFFFFLL;
  if ( (unsigned int)n <= 0xA && ((1 << n) & 0x4A8) != 0 )
  {
    if ( *(_BYTE *)(a1 + 20) )
      sub_39358(a1);
    v11 = *(void **)(a1 + 24);
    *(_DWORD *)(a1 + 8) = a4;
    *(_DWORD *)(a1 + 12) = a4 * a2;
    *(_DWORD *)(a1 + 16) = v8;
    v12 = 4LL * v8;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = a3;
    if ( v11 || (v11 = malloc(v12), (*(_QWORD *)(a1 + 24) = v11) != 0) )
    {
      memset(v11, 0, v12);
      v13 = *(void **)(a1 + 32);
      if ( v13 )
      {
        v14 = 4LL * *(unsigned int *)(a1 + 16);
      }
      else
      {
        v14 = 4LL * *(unsigned int *)(a1 + 16);
        v13 = malloc(v14);
        *(_QWORD *)(a1 + 32) = v13;
        if ( !v13 )
          goto LABEL_44;
      }
      memset(v13, 0, v14);
      v15 = *(void **)(a1 + 40);
      if ( v15 )
      {
        v16 = 4LL * *(unsigned int *)(a1 + 16);
      }
      else
      {
        v16 = 4LL * *(unsigned int *)(a1 + 16);
        v15 = malloc(v16);
        *(_QWORD *)(a1 + 40) = v15;
        if ( !v15 )
          goto LABEL_44;
      }
      memset(v15, 0, v16);
      v17 = *(void **)(a1 + 48);
      if ( v17 )
      {
        v18 = 4LL * *(unsigned int *)(a1 + 16);
      }
      else
      {
        v18 = 4LL * *(unsigned int *)(a1 + 16);
        v17 = malloc(v18);
        *(_QWORD *)(a1 + 48) = v17;
        if ( !v17 )
          goto LABEL_44;
      }
      memset(v17, 0, v18);
      v19 = *(void **)(a1 + 56);
      if ( v19 )
      {
        v20 = 48LL * *(unsigned int *)(a1 + 16);
        goto LABEL_27;
      }
      v20 = 48LL * *(unsigned int *)(a1 + 16);
      v19 = malloc(v20);
      *(_QWORD *)(a1 + 56) = v19;
      if ( v19 )
      {
LABEL_27:
        memset(v19, 0, v20);
        if ( *(_DWORD *)(a1 + 16) )
        {
          v21 = 0;
          v22 = 0;
          do
          {
            iir_create((_QWORD *)(*(_QWORD *)(a1 + 56) + v21));
            ++v22;
            v21 += 8;
          }
          while ( v22 < *(unsigned int *)(a1 + 16) );
        }
        sub_3946C(a1);
        v23 = *(unsigned int *)(a1 + 16);
        if ( !(_DWORD)v23 )
          goto LABEL_38;
        v24 = *(_QWORD *)(a1 + 24);
        v25 = *(_QWORD *)(a1 + 32);
        if ( (unsigned int)v23 > 7 && (v24 >= v25 + 4 * v23 || v25 >= v24 + 4 * v23) )
        {
          v26 = (unsigned int)v23 & 0xFFFFFFF8;
          v31 = (_OWORD *)(v24 + 16);
          v32 = (_OWORD *)(v25 + 16);
          __asm { FMOV            V1.4S, #1.0 }
          v38 = v26;
          do
          {
            *(v31 - 1) = 0u;
            *v31 = 0u;
            *(v32 - 1) = _Q1;
            *v32 = _Q1;
            v31 += 2;
            v38 -= 8LL;
            v32 += 2;
          }
          while ( v38 );
          if ( v26 == v23 )
            goto LABEL_36;
        }
        else
        {
          v26 = 0;
        }
        do
        {
          v27 = 4 * v26++;
          *(_DWORD *)(v24 + v27) = 0;
          *(_DWORD *)(v25 + v27) = 1065353216;
        }
        while ( v26 < v23 );
LABEL_36:
        v28 = 0;
        do
          peak_setup(
            *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v28++),
            *(_DWORD *)a1,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 8),
            2);
        while ( v28 < *(unsigned int *)(a1 + 16) );
LABEL_38:
        v29 = *(_QWORD *)(a1 + 24);
        v30 = *(_QWORD *)(a1 + 32);
        *(_BYTE *)(a1 + 20) = 1;
        graphic_equalizer_update(a1, v29, v30);
        return 0;
      }
    }
LABEL_44:
    exit(1);
  }
  return result;
}
// 397B8: conditional instruction was optimized away because w8.4!=0

//----- (0000000000039858) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_update(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 result; // x0
  float v7; // s2
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x10
  __int64 v10; // x11
  unsigned int v11; // w1
  unsigned int *v12; // x20
  __int64 v13; // x21
  unsigned __int64 v14; // x3
  unsigned __int64 v15; // x15
  unsigned __int64 v16; // x17
  unsigned __int64 v17; // x4
  bool v18; // w5
  bool v19; // w0
  bool v20; // w3
  __int128 *v21; // x12
  _OWORD *v22; // x13
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x16
  __int128 v26; // q0
  __int128 v27; // q1
  __int128 v28; // q0
  __int128 v29; // q1
  int *v30; // x12
  _DWORD *v31; // x10
  int *v32; // x13
  _DWORD *v33; // x9
  __int64 v34; // x11
  int v35; // t1
  int v36; // t1
  float *v37; // x9
  __int64 v38; // x11
  float *v39; // x12
  int v40; // w10
  __int64 i; // x13
  float v42; // s0
  int v43; // w14
  float *v44; // x15
  unsigned __int64 v45; // x16
  float v46; // s1
  float v47; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  v4 = *(unsigned int *)(a1 + 16);
  if ( (_DWORD)v4 )
  {
    v5 = 0;
    result = 0xFFFFFFFFLL;
    do
    {
      v7 = *(float *)(a2 + 4 * v5);
      if ( v7 < -12.0 || v7 > 12.0 )
        return result;
      ++v5;
    }
    while ( v5 < v4 );
    v9 = *(_QWORD *)(a1 + 24);
    v8 = *(_QWORD *)(a1 + 32);
    if ( (unsigned int)v4 > 7 )
    {
      v14 = v8 + 4 * v4;
      v15 = v9 + 4 * v4;
      v16 = a2 + 4 * v4;
      v17 = a3 + 4 * v4;
      v18 = v9 < v14 && v8 < v15;
      v19 = v14 > a2;
      v10 = 0;
      v20 = v14 > a3;
      if ( !v18 && (v9 >= v16 || v15 <= a2) && (v9 >= v17 || v15 <= a3) && (v8 >= v16 || !v19) && (v8 >= v17 || !v20) )
      {
        v10 = (unsigned int)v4 & 0xFFFFFFF8;
        v21 = (__int128 *)(a2 + 16);
        v22 = (_OWORD *)(v9 + 16);
        v23 = (__int128 *)(a3 + 16);
        v24 = (_OWORD *)(v8 + 16);
        v25 = v10;
        do
        {
          v26 = *(v21 - 1);
          v27 = *v21;
          v21 += 2;
          v25 -= 8;
          *(v22 - 1) = v26;
          *v22 = v27;
          v28 = *(v23 - 1);
          v29 = *v23;
          v22 += 2;
          v23 += 2;
          *(v24 - 1) = v28;
          *v24 = v29;
          v24 += 2;
        }
        while ( v25 );
        if ( v10 == v4 )
          goto LABEL_29;
      }
    }
    else
    {
      v10 = 0;
    }
    v30 = (int *)(a2 + 4 * v10);
    v31 = (_DWORD *)(v9 + 4 * v10);
    v32 = (int *)(a3 + 4 * v10);
    v33 = (_DWORD *)(v8 + 4 * v10);
    v34 = v4 - v10;
    do
    {
      v35 = *v30++;
      --v34;
      *v31++ = v35;
      v36 = *v32++;
      *v33++ = v36;
    }
    while ( v34 );
LABEL_29:
    v12 = (unsigned int *)(a1 + 4);
    v11 = *(_DWORD *)(a1 + 4);
    v37 = (float *)&unk_17140;
    if ( v11 < 0xB3E2 )
      v37 = (float *)&unk_16FB0;
    v38 = *(_QWORD *)(a1 + 48);
    v39 = *(float **)(a1 + 24);
    v40 = 0;
    for ( i = 0; i != v4; ++i )
    {
      v42 = 0.0;
      v43 = v40;
      v44 = v39;
      v45 = v4;
      *(_DWORD *)(v38 + 4 * i) = 0;
      do
      {
        v46 = v37[v43];
        v47 = *v44++;
        --v45;
        ++v43;
        v42 = v42 + (float)(v46 * v47);
        *(float *)(v38 + 4 * i) = v42;
      }
      while ( v45 );
      v40 += v4;
    }
    goto LABEL_13;
  }
  v12 = (unsigned int *)(a1 + 4);
  v11 = *(_DWORD *)(a1 + 4);
LABEL_13:
  if ( (_DWORD)v4 )
  {
    v13 = 0;
    while ( 1 )
    {
      peak_update(
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13),
        v11,
        0,
        *(float *)(*(_QWORD *)(a1 + 48) + 4 * v13),
        *(float *)(*(_QWORD *)(a1 + 40) + 4 * v13),
        *(float *)(*(_QWORD *)(a1 + 32) + 4 * v13));
      if ( ++v13 >= (unsigned __int64)*(unsigned int *)(a1 + 16) )
        break;
      v11 = *v12;
    }
  }
  return 0;
}
// 398B0: conditional instruction was optimized away because w8.4!=0
// 39A64: conditional instruction was optimized away because w8.4!=0

//----- (0000000000039AC0) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_process(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  iir_process(**(unsigned int ***)(a1 + 56), a2, a3);
  if ( *(_DWORD *)(a1 + 16) >= 2u )
  {
    v5 = 1;
    do
      iir_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 56) + 8 * v5++), a3);
    while ( v5 < *(unsigned int *)(a1 + 16) );
  }
  return 0;
}

//----- (0000000000039B44) ----------------------------------------------------
__int64 __fastcall graphic_equalizer_process_inplace(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x21

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  if ( *(_DWORD *)(a1 + 16) )
  {
    v4 = 0;
    do
      iir_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 56) + 8 * v4++), a2);
    while ( v4 < *(unsigned int *)(a1 + 16) );
  }
  return 0;
}

//----- (0000000000039BB8) ----------------------------------------------------
__int64 __fastcall gain_create(_QWORD *a1)
{
  __int64 result; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x8

  if ( !a1 || *a1 )
    return 0xFFFFFFFFLL;
  v3 = malloc(0x18u);
  *a1 = v3;
  if ( !v3 )
    exit(1);
  v4 = v3;
  result = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  return result;
}

//----- (0000000000039C10) ----------------------------------------------------
__int64 __fastcall gain_destroy(void **a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  free(v2);
  result = 0;
  *a1 = 0;
  return result;
}

//----- (0000000000039C4C) ----------------------------------------------------
__int64 __fastcall gain_flush(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  result = 0;
  *(_DWORD *)(a1 + 20) = 2139095039;
  return result;
}

//----- (0000000000039C7C) ----------------------------------------------------
__int64 __fastcall gain_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  result = 0;
  *(_BYTE *)(a1 + 12) = 0;
  return result;
}

//----- (0000000000039CA8) ----------------------------------------------------
__int64 __fastcall gain_setup(__int64 a1, int a2, int a3, int a4)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 4;
  result = 0;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  *(_BYTE *)(a1 + 12) = 1;
  *(_QWORD *)(a1 + 16) = 0x7F7FFFFF3F800000LL;
  return result;
}

//----- (0000000000039CF4) ----------------------------------------------------
__int64 __fastcall gain_update(__int64 a1, float a2)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  result = 0;
  *(float *)(a1 + 16) = a2;
  return result;
}

//----- (0000000000039D20) ----------------------------------------------------
__int64 __fastcall gain_process(__int64 a1, float32x4_t *a2, float32x4_t *a3, double a4, double a5, double a6)
{
  float v6; // s0
  float v7; // s1
  unsigned int v8; // w8
  int v9; // w9
  unsigned int v10; // w12
  unsigned int v11; // w10
  unsigned int v12; // w11
  float v13; // s1
  unsigned int v14; // w13
  unsigned int v15; // w14
  unsigned int v16; // w15
  float32x4_t v17; // q3
  unsigned int v18; // w15
  unsigned int v19; // w16
  __int64 v20; // x17
  float32x4_t v21; // q4
  float32x4_t v22; // q5
  float32x4_t *v23; // x17
  __int64 v24; // x16
  unsigned int v26; // w8
  unsigned __int64 v27; // x10
  float32x4_t v28; // q1
  float32x4_t *v29; // x11
  float32x4_t *v30; // x12
  unsigned __int64 v31; // x13
  float32x4_t v32; // q2
  float32x4_t v33; // q3
  __int64 v34; // x11
  float v35; // s1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v6 = *(float *)(a1 + 20);
    if ( v6 != 3.4028e38 )
    {
      v7 = *(float *)(a1 + 16);
      if ( v6 != v7 )
      {
        v8 = *(_DWORD *)(a1 + 4);
        v9 = *(_DWORD *)(a1 + 16);
        if ( v8 )
        {
          v10 = *(_DWORD *)a1;
          v11 = 0;
          v12 = 0;
          v13 = (float)(v7 - v6) / (float)v8;
          v14 = *(_DWORD *)a1 - 1;
          v15 = *(_DWORD *)a1 & 0xFFFFFFF8;
          if ( *(_DWORD *)a1 )
            goto LABEL_10;
          while ( 1 )
          {
            ++v12;
            v11 += v10;
            if ( v12 == v8 )
              break;
            if ( v10 )
            {
LABEL_10:
              v16 = 0;
              *(float *)&a6 = v6 + (float)(v13 * (float)v12);
              if ( v10 < 8 )
                goto LABEL_30;
              if ( v14 > ~(v10 * v12) )
                goto LABEL_30;
              v17 = vdupq_lane_s32(*(int32x2_t *)&a6, 0);
              v18 = v15;
              v19 = v11;
              do
              {
                v20 = 4LL * v19;
                v21 = *(float32x4_t *)((char *)a2 + v20);
                v22 = *(float32x4_t *)((char *)a2 + v20 + 16);
                v18 -= 8;
                v23 = (float32x4_t *)((char *)a3 + v20);
                v19 += 8;
                *v23 = vmulq_f32(v17, v21);
                v23[1] = vmulq_f32(v17, v22);
              }
              while ( v18 );
              v16 = v15;
              if ( v10 != v15 )
              {
LABEL_30:
                do
                {
                  v24 = v11 + v16++;
                  a3->n128_f32[v24] = *(float *)&a6 * a2->n128_f32[v24];
                }
                while ( v16 < v10 );
              }
            }
          }
        }
        goto LABEL_27;
      }
    }
  }
  v26 = *(_DWORD *)(a1 + 4) * *(_DWORD *)a1;
  if ( v26 )
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 16);
    v9 = LODWORD(a4);
    if ( v26 >= 8 )
    {
      v27 = v26 & 0xFFFFFFF8;
      v28 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
      v29 = a2 + 1;
      v30 = a3 + 1;
      v31 = v27;
      do
      {
        v32 = v29[-1];
        v33 = *v29;
        v29 += 2;
        v31 -= 8LL;
        v30[-1] = vmulq_f32(v28, v32);
        *v30 = vmulq_f32(v28, v33);
        v30 += 2;
      }
      while ( v31 );
      if ( v27 == v26 )
        goto LABEL_27;
    }
    else
    {
      v27 = 0;
    }
    do
    {
      v34 = v27;
      v35 = a2->n128_f32[v27++];
      a3->n128_f32[v34] = *(float *)&a4 * v35;
    }
    while ( v27 < v26 );
  }
  else
  {
    v9 = *(_DWORD *)(a1 + 16);
  }
LABEL_27:
  *(_DWORD *)(a1 + 20) = v9;
  return 0;
}

//----- (0000000000039ED4) ----------------------------------------------------
__int64 __fastcall gain_process_inplace(__int64 a1, unsigned __int64 a2, double a3, long double a4, float32x4_t a5)
{
  unsigned __int32 *v5; // x8
  float v6; // s0
  float v7; // s1
  unsigned int v8; // w9
  unsigned int v9; // w13
  unsigned int v10; // w10
  unsigned int v11; // w14
  unsigned int v12; // w11
  float v13; // s0
  unsigned int v14; // w16
  unsigned int v15; // w17
  __int64 v16; // x2
  unsigned int v17; // w17
  unsigned int v18; // w2
  float32x4_t *v19; // x3
  float32x4_t v20; // q4
  __int64 v21; // x2
  unsigned int v23; // w9
  const float *v24; // x8
  unsigned __int64 v25; // x10
  float32x4_t v26; // q0
  float32x4_t *v27; // x11
  unsigned __int64 v28; // x12
  float32x4_t v29; // q2
  __int64 v30; // x11
  float v31; // s1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v5 = (unsigned __int32 *)(a1 + 20);
    v6 = *(float *)(a1 + 20);
    if ( v6 != 3.4028e38 )
    {
      v7 = *(float *)(a1 + 16);
      if ( v6 != v7 )
      {
        v8 = *(_DWORD *)(a1 + 4);
        if ( v8 )
        {
          v9 = *(_DWORD *)a1;
          v10 = 0;
          v11 = *(_DWORD *)a1 - 1;
          v12 = 0;
          v13 = (float)(v7 - v6) / (float)v8;
          v14 = *(_DWORD *)a1 & 0xFFFFFFF8;
          if ( *(_DWORD *)a1 )
            goto LABEL_10;
          while ( 1 )
          {
            do
            {
              do
              {
                ++v12;
                v10 += v9;
                if ( v12 == v8 )
                  goto LABEL_32;
              }
              while ( !v9 );
LABEL_10:
              v15 = 0;
              *(float *)&a4 = v13 * (float)v12;
              if ( v9 < 8 )
                break;
              v16 = v9 * v12;
              if ( v11 > ~(_DWORD)v16 )
                break;
              if ( (unsigned __int64)v5 < a2 + 4LL * v11 + 4 + 4 * v16 && a1 + 21 > a2 + 4 * v16 )
              {
                v15 = 0;
                goto LABEL_18;
              }
              a5.n128_u32[0] = *v5;
              v17 = v14;
              v18 = v10;
              a5 = vdupq_lane_s32((int32x2_t)vaddq_f32(*(float32x4_t *)&a4, a5).n128_u64[0], 0);
              do
              {
                v19 = (float32x4_t *)(a2 + 4LL * v18);
                v17 -= 8;
                v18 += 8;
                v20 = vmulq_f32(a5, v19[1]);
                *v19 = vmulq_f32(a5, *v19);
                v19[1] = v20;
              }
              while ( v17 );
              v15 = v14;
            }
            while ( v9 == v14 );
            do
            {
LABEL_18:
              v21 = 4LL * (v10 + v15++);
              *(float *)(a2 + v21) = (float)(*(float *)&a4 + *(float *)v5) * *(float *)(a2 + v21);
            }
            while ( v15 < v9 );
          }
        }
        goto LABEL_32;
      }
    }
  }
  v23 = *(_DWORD *)(a1 + 4) * *(_DWORD *)a1;
  if ( v23 )
  {
    v24 = (const float *)(a1 + 16);
    if ( v23 >= 8 )
    {
      if ( a1 + 17 <= a2 || (unsigned __int64)v24 >= a2 + 4LL * v23 )
      {
        v26 = vld1q_dup_f32(v24);
        v25 = v23 & 0xFFFFFFF8;
        v27 = (float32x4_t *)(a2 + 16);
        v28 = v25;
        do
        {
          v28 -= 8LL;
          v29 = vmulq_f32(v26, *v27);
          v27[-1] = vmulq_f32(v26, v27[-1]);
          *v27 = v29;
          v27 += 2;
        }
        while ( v28 );
        if ( v25 == v23 )
          goto LABEL_32;
      }
      else
      {
        v25 = 0;
      }
    }
    else
    {
      v25 = 0;
    }
    do
    {
      v30 = 4 * v25;
      v31 = *(float *)(a2 + 4 * v25++);
      *(float *)(a2 + v30) = *v24 * v31;
    }
    while ( v25 < v23 );
  }
LABEL_32:
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 16);
  return 0;
}

//----- (000000000003A0CC) ----------------------------------------------------
long double __fastcall spatial_upmix_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0xB0u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[9] = 0u;
    v2[10] = 0u;
    v2[7] = 0u;
    v2[8] = 0u;
    v2[5] = 0u;
    v2[6] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (000000000003A138) ----------------------------------------------------
__int64 __fastcall spatial_upmix_destroy(__int64 *a1)
{
  __int64 v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_3A180(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003A180) ----------------------------------------------------
void __fastcall sub_3A180(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0

  spatializer_destroy((__int64 *)(a1 + 128));
  reverb_destroy((__int64 *)(a1 + 144));
  iir_destroy((__int64 *)(a1 + 152));
  gain_destroy((void **)(a1 + 160));
  v2 = *(void **)(a1 + 40);
  if ( v2 )
  {
    free(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v3 = *(void **)(a1 + 56);
  if ( v3 )
  {
    free(v3);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v4 = *(void **)(a1 + 80);
  if ( v4 )
  {
    free(v4);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v5 = *(void **)(a1 + 104);
  if ( v5 )
  {
    free(v5);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v6 = *(void **)(a1 + 168);
  if ( v6 )
  {
    free(v6);
    *(_QWORD *)(a1 + 168) = 0;
  }
}

//----- (000000000003A20C) ----------------------------------------------------
__int64 __fastcall spatial_upmix_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  sub_3A248(a1);
  return 0;
}

//----- (000000000003A248) ----------------------------------------------------
__int64 __fastcall sub_3A248(__int64 a1)
{
  __int64 v2; // x2
  int v3; // w8
  int v4; // w11
  int *v5; // x9
  int *v6; // x12
  _DWORD *v7; // x8
  _DWORD *v8; // x11
  _DWORD *v9; // x10
  int *v10; // x13
  int v11; // w12
  int v12; // w9
  int v13; // w2
  __int64 v14; // x0
  float *v15; // x5
  float *v16; // x4

  spatializer_setup(*(_QWORD *)(a1 + 128), 2, *(_DWORD *)a1, *(_DWORD *)(a1 + 4));
  spatializer_update(*(_QWORD *)(a1 + 128), 0, *(_DWORD *)(a1 + 12));
  v2 = *(_QWORD *)(a1 + 168);
  *(_DWORD *)v2 = kSpatialUpmixDelayFilterGain;
  *(_DWORD *)(v2 + 4) = dword_7887C;
  *(_DWORD *)(v2 + 8) = dword_78880;
  *(_DWORD *)(v2 + 12) = dword_78884;
  *(_OWORD *)(v2 + 24) = kSpatialUpmixLeftDelay;
  *(_OWORD *)(v2 + 40) = kSpatialUpmixRightDelay;
  v3 = dword_7888C;
  *(_DWORD *)(v2 + 16) = kSpatialUpmixAllpassFilterGain;
  *(_DWORD *)(v2 + 56) = kSpatialUpmixLeftAllpassDelay;
  v4 = kSpatialUpmixRightAllpassDelay;
  *(_DWORD *)(v2 + 20) = v3;
  *(_DWORD *)(v2 + 60) = dword_788B4;
  *(_DWORD *)(v2 + 64) = v4;
  *(_DWORD *)(v2 + 68) = dword_788BC;
  if ( *(_DWORD *)a1 == 48000 )
  {
    v5 = &kSpatialUpmixDenominatorCoeffReverb48k;
    v6 = &kSpatialUpmixNumeratorCoeffReverb48k;
  }
  else
  {
    if ( *(_DWORD *)a1 != 44100 )
      goto LABEL_6;
    v5 = &kSpatialUpmixDenominatorCoeffReverb44k;
    v6 = &kSpatialUpmixNumeratorCoeffReverb44k;
  }
  v7 = v5 + 2;
  v8 = v5 + 1;
  v9 = v6 + 2;
  v10 = v6 + 1;
  v11 = *v6;
  *(_DWORD *)(v2 + 84) = *v5;
  v12 = *v10;
  *(_DWORD *)(v2 + 72) = v11;
  *(_DWORD *)(v2 + 76) = v12;
  *(_DWORD *)(v2 + 88) = *v8;
  *(_DWORD *)(v2 + 80) = *v9;
  *(_DWORD *)(v2 + 92) = *v7;
LABEL_6:
  *(_QWORD *)(v2 + 96) = 0x3E4CCCCD3F000000LL;
  reverb_setup(*(_QWORD *)(a1 + 144), *(_DWORD *)(a1 + 4), v2, 100, 1);
  v13 = *(_DWORD *)(a1 + 4);
  v14 = *(_QWORD *)(a1 + 152);
  if ( *(_DWORD *)a1 == 48000 )
    v15 = (float *)&kSpatialUpmixNumeratorCoeff48k;
  else
    v15 = (float *)&kSpatialUpmixNumeratorCoeff44k;
  if ( *(_DWORD *)a1 == 48000 )
    v16 = (float *)&kSpatialUpmixDenominatorCoeff48k;
  else
    v16 = (float *)&kSpatialUpmixDenominatorCoeff44k;
  *(_QWORD *)(a1 + 112) = v15;
  *(_QWORD *)(a1 + 120) = v16;
  iir_setup(v14, 2u, v13, 4, v16, v15);
  return gain_setup(*(_QWORD *)(a1 + 160), 2, *(_DWORD *)(a1 + 4), 1);
}
// 78878: using guessed type int kSpatialUpmixDelayFilterGain;
// 7887C: using guessed type int dword_7887C;
// 78880: using guessed type int dword_78880;
// 78884: using guessed type int dword_78884;
// 78888: using guessed type int kSpatialUpmixAllpassFilterGain;
// 7888C: using guessed type int;
// 78890: using guessed type __int128 kSpatialUpmixLeftDelay;
// 788A0: using guessed type __int128 kSpatialUpmixRightDelay;
// 788B0: using guessed type int kSpatialUpmixLeftAllpassDelay;
// 788B4: using guessed type int dword_788B4;
// 788B8: using guessed type int kSpatialUpmixRightAllpassDelay;
// 788BC: using guessed type int dword_788BC;
// 788C0: using guessed type int kSpatialUpmixNumeratorCoeffReverb48k;
// 788CC: using guessed type int kSpatialUpmixDenominatorCoeffReverb48k;
// 788D8: using guessed type int kSpatialUpmixNumeratorCoeffReverb44k;
// 788E4: using guessed type int kSpatialUpmixDenominatorCoeffReverb44k;

//----- (000000000003A404) ----------------------------------------------------
__int64 __fastcall spatial_upmix_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  sub_3A180(a1);
  result = 0;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}

//----- (000000000003A44C) ----------------------------------------------------
__int64 __fastcall spatial_upmix_setup(__int64 a1, int a2, int a3, int a4, size_t n, float a6)
{
  int v7; // w20
  __int64 result; // x0
  void *v12; // x0
  __int64 v13; // x8
  size_t v14; // x20
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  _QWORD *v18; // x0
  unsigned int v19; // w1
  float v20; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v7 = n;
  if ( a3 != 48000 && a3 != 44100 )
    return 3;
  if ( !a4 )
    return 4;
  if ( a2 != 2 )
    return 1;
  result = 0xFFFFFFFFLL;
  if ( a6 <= 5.0 && (unsigned int)n <= 6 && a6 >= 0.0 )
  {
    if ( *(_BYTE *)(a1 + 20) )
      sub_3A180(a1);
    *(_DWORD *)a1 = a3;
    *(_DWORD *)(a1 + 4) = a4;
    *(_DWORD *)(a1 + 12) = v7;
    *(float *)(a1 + 32) = a6;
    if ( !*(_QWORD *)(a1 + 128) )
      spatializer_create((_QWORD *)(a1 + 128));
    if ( !*(_QWORD *)(a1 + 144) )
      reverb_create((_QWORD *)(a1 + 144));
    if ( !*(_QWORD *)(a1 + 152) )
      iir_create((_QWORD *)(a1 + 152));
    if ( !*(_QWORD *)(a1 + 160) )
      gain_create((_QWORD *)(a1 + 160));
    v12 = *(void **)(a1 + 40);
    v13 = (unsigned int)(2 * *(_DWORD *)(a1 + 4));
    v14 = 4 * v13;
    if ( !v12 )
    {
      v12 = malloc(4 * v13);
      *(_QWORD *)(a1 + 40) = v12;
      if ( !v12 )
        goto LABEL_35;
    }
    memset(v12, 0, v14);
    v15 = *(void **)(a1 + 56);
    if ( !v15 )
    {
      v15 = malloc(v14);
      *(_QWORD *)(a1 + 56) = v15;
      if ( !v15 )
        goto LABEL_35;
    }
    memset(v15, 0, v14);
    v16 = *(void **)(a1 + 80);
    if ( !v16 )
    {
      v16 = malloc(v14);
      *(_QWORD *)(a1 + 80) = v16;
      if ( !v16 )
        goto LABEL_35;
    }
    memset(v16, 0, v14);
    v17 = *(void **)(a1 + 104);
    if ( !v17 )
    {
      v17 = malloc(v14);
      *(_QWORD *)(a1 + 104) = v17;
      if ( !v17 )
        goto LABEL_35;
    }
    memset(v17, 0, v14);
    v18 = *(_QWORD **)(a1 + 168);
    if ( !v18 )
    {
      v18 = malloc(0x68u);
      *(_QWORD *)(a1 + 168) = v18;
      if ( !v18 )
LABEL_35:
        exit(1);
    }
    v18[12] = 0;
    *((_OWORD *)v18 + 4) = 0u;
    *((_OWORD *)v18 + 5) = 0u;
    *((_OWORD *)v18 + 2) = 0u;
    *((_OWORD *)v18 + 3) = 0u;
    *(_OWORD *)v18 = 0u;
    *((_OWORD *)v18 + 1) = 0u;
    sub_3A248(a1);
    v19 = *(_DWORD *)(a1 + 12);
    v20 = *(float *)(a1 + 32);
    *(_BYTE *)(a1 + 20) = 1;
    spatial_upmix_update(a1, v19, v20);
    return 0;
  }
  return result;
}

//----- (000000000003A644) ----------------------------------------------------
__int64 __fastcall spatial_upmix_update(__int64 a1, unsigned int a2, float a3)
{
  __int64 result; // x0
  int v5; // w8
  __int64 v6; // x0
  double v7; // d0
  __int64 v8; // x0
  float *v9; // x2
  float *v10; // x1
  __int64 v11; // x0
  __int64 v12; // x1
  int v13; // w8

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a3 <= 5.0 && a2 <= 6 && a3 >= 0.0 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(float *)(a1 + 32) = a3;
    switch ( a2 )
    {
      case 1u:
      case 5u:
        v5 = 1053609165;
        goto LABEL_13;
      case 2u:
        v5 = 1055286886;
        goto LABEL_13;
      case 6u:
        v5 = 1054951342;
LABEL_13:
        *(_DWORD *)(a1 + 24) = v5;
        break;
      default:
        v5 = *(_DWORD *)(a1 + 24);
        break;
    }
    v6 = *(_QWORD *)(a1 + 128);
    *(_DWORD *)(a1 + 28) = v5;
    spatializer_update(v6, 0, a2);
    v8 = *(_QWORD *)(a1 + 152);
    if ( *(_DWORD *)a1 == 48000 )
      v9 = (float *)&kSpatialUpmixNumeratorCoeff48k;
    else
      v9 = (float *)&kSpatialUpmixNumeratorCoeff44k;
    if ( *(_DWORD *)a1 == 48000 )
      v10 = (float *)&kSpatialUpmixDenominatorCoeff48k;
    else
      v10 = (float *)&kSpatialUpmixDenominatorCoeff44k;
    *(_QWORD *)(a1 + 112) = v9;
    *(_QWORD *)(a1 + 120) = v10;
    iir_update(v8, v10, v9, v7);
    if ( *(_DWORD *)(a1 + 12) == 1 )
    {
      if ( *(_BYTE *)(a1 + 20) )
      {
        v11 = *(_QWORD *)(a1 + 144);
        v12 = *(_QWORD *)(a1 + 168);
        v13 = 1053609165;
LABEL_25:
        *(_DWORD *)(a1 + 24) = v13;
        reverb_update(v11, v12, 0.5);
      }
    }
    else if ( *(_BYTE *)(a1 + 20) )
    {
      v11 = *(_QWORD *)(a1 + 144);
      v12 = *(_QWORD *)(a1 + 168);
      v13 = 1055286886;
      goto LABEL_25;
    }
    return 0;
  }
  return result;
}
// 3A738: variable 'v7' is possibly undefined

//----- (000000000003A794) ----------------------------------------------------
float __fastcall spatial_upmix_process(__int64 a1, float *a2, unsigned __int64 a3)
{
  int v4; // w9
  int v5; // w8
  float32x4_t v6; // q0
  unsigned int v9; // w22
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d0
  double v17; // d1
  double v18; // d2
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x1
  __int64 v22; // x11
  unsigned __int64 v23; // x13
  bool v24; // w14
  bool v25; // w13
  __int64 v26; // x12
  __int64 v27; // x13
  float32x4_t v28; // q0
  float32x4_t v29; // q1
  float32x4_t v30; // q2
  float32x4_t v31; // q3
  float32x4_t *v32; // x14
  __int64 v33; // x12
  float v34; // s0
  float v35; // s1
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d0
  double v43; // d1
  double v44; // d2
  float32x4_t *v45; // x10
  float32x4_t *v46; // x9
  __int64 v47; // x11
  unsigned __int64 v48; // x13
  bool v49; // w14
  bool v50; // w13
  float32x4_t *v51; // x12
  float32x4_t *v52; // x13
  float32x4_t *v53; // x14
  __int64 v54; // x15
  float32x4_t v55; // q0
  float32x4_t v56; // q1
  float32x4_t v57; // q2
  float32x4_t v58; // q3
  float *v59; // x10
  float *v60; // x9
  _DWORD *v61; // x12
  __int64 v62; // x8
  float v63; // t1
  float v64; // s0
  float v65; // t1
  double v66; // d0
  double v67; // d1
  double v68; // d2
  double v69; // d3
  double v70; // d4
  double v71; // d5
  double v72; // d0
  double v73; // d1
  double v74; // d2
  float32x4_t *v75; // x10
  float32x4_t *v76; // x9
  __int64 v77; // x11
  unsigned __int64 v78; // x13
  bool v79; // w14
  bool v80; // w13
  float32x4_t *v81; // x12
  float32x4_t *v82; // x13
  float32x4_t *v83; // x14
  __int64 v84; // x15
  float32x4_t v85; // q0
  float32x4_t v86; // q1
  float32x4_t v87; // q2
  float32x4_t v88; // q3
  float *v89; // x10
  float *v90; // x9
  _DWORD *v91; // x12
  __int64 v92; // x8
  float v93; // t1
  float v94; // s0
  float v95; // t1

  if ( a1 && *(_BYTE *)(a1 + 20) )
  {
    v4 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 4);
    v6.n128_f32[0] = (float)(*(float *)(a1 + 28) * 0.96) + (float)(*(float *)(a1 + 24) * 0.04);
    *(_DWORD *)(a1 + 28) = v6.n128_u32[0];
    v9 = 2 * v5;
    switch ( v4 )
    {
      case 0:
        spatializer_bypass(*(_QWORD *)(a1 + 128), a2, a3);
        break;
      case 1:
      case 2:
      case 5:
      case 6:
        spatializer_process(*(_QWORD *)(a1 + 128), a2, *(_QWORD *)(a1 + 80));
        reverb_process(*(_QWORD *)(a1 + 144), (__int64)a2, *(_QWORD *)(a1 + 104), v10, v11, v12, v13, v14, v15);
        gain_update(*(_QWORD *)(a1 + 160), *(float *)(a1 + 28));
        gain_process(*(_QWORD *)(a1 + 160), *(float32x4_t **)(a1 + 104), *(float32x4_t **)(a1 + 104), v16, v17, v18);
        if ( v9 )
        {
          v19 = *(_QWORD *)(a1 + 80);
          v20 = *(_QWORD *)(a1 + 104);
          v21 = *(_QWORD *)(a1 + 56);
          v22 = 0;
          if ( v9 <= 7 )
            goto LABEL_41;
          v23 = v21 + 4LL * v9;
          v24 = v21 < v19 + 4LL * v9 && v19 < v23;
          v25 = v20 < v23;
          if ( v24 )
            goto LABEL_41;
          if ( v21 < v20 + 4LL * v9 && v25 )
            goto LABEL_41;
          v22 = v9 & 0xFFFFFFF8;
          v26 = 0;
          v27 = v22;
          do
          {
            v28 = *(float32x4_t *)(v19 + v26);
            v29 = *(float32x4_t *)(v19 + v26 + 16);
            v30 = *(float32x4_t *)(v20 + v26);
            v31 = *(float32x4_t *)(v20 + v26 + 16);
            v32 = (float32x4_t *)(v21 + v26);
            v27 -= 8;
            v26 += 32;
            *v32 = vaddq_f32(v28, v30);
            v32[1] = vaddq_f32(v29, v31);
          }
          while ( v27 );
          if ( v22 != v9 )
          {
LABEL_41:
            do
            {
              v33 = 4 * v22;
              v34 = *(float *)(v19 + 4 * v22);
              v35 = *(float *)(v20 + 4 * v22++);
              *(float *)(v21 + v33) = v34 + v35;
            }
            while ( v9 != v22 );
          }
        }
        else
        {
          v21 = *(_QWORD *)(a1 + 56);
        }
        iir_process(*(unsigned int **)(a1 + 152), v21, a3);
        break;
      case 3:
        spatializer_bypass(*(_QWORD *)(a1 + 128), a2, *(_QWORD *)(a1 + 80));
        reverb_process(*(_QWORD *)(a1 + 144), (__int64)a2, *(_QWORD *)(a1 + 104), v36, v37, v38, v39, v40, v41);
        gain_update(*(_QWORD *)(a1 + 160), *(float *)(a1 + 32) + 1.5);
        gain_process(*(_QWORD *)(a1 + 160), *(float32x4_t **)(a1 + 104), *(float32x4_t **)(a1 + 104), v42, v43, v44);
        if ( v9 )
        {
          v45 = *(float32x4_t **)(a1 + 80);
          v46 = *(float32x4_t **)(a1 + 104);
          v47 = 0;
          if ( v9 < 8 )
            goto LABEL_25;
          v48 = a3 + 4LL * v9;
          v49 = (unsigned __int64)&v45->n128_u64[v9 / 2] > a3 && (unsigned __int64)v45 < v48;
          v50 = (unsigned __int64)v46 < v48;
          if ( v49 )
            goto LABEL_25;
          if ( (unsigned __int64)&v46->n128_u64[v9 / 2] > a3 && v50 )
            goto LABEL_25;
          v47 = v9 & 0xFFFFFFF8;
          v51 = v45 + 1;
          v52 = v46 + 1;
          v53 = (float32x4_t *)(a3 + 16);
          v54 = v47;
          do
          {
            v55 = v51[-1];
            v56 = *v51;
            v57 = v52[-1];
            v58 = *v52;
            v51 += 2;
            v52 += 2;
            v54 -= 8;
            v6 = vaddq_f32(v55, v57);
            v53[-1] = v6;
            *v53 = vaddq_f32(v56, v58);
            v53 += 2;
          }
          while ( v54 );
          if ( v47 != v9 )
          {
LABEL_25:
            v59 = (float *)v45 + v47;
            v60 = (float *)v46 + v47;
            v61 = (_DWORD *)(a3 + 4 * v47);
            v62 = v9 - v47;
            do
            {
              v63 = *v59++;
              v64 = v63;
              v65 = *v60++;
              --v62;
              v6.n128_f32[0] = v64 + v65;
              *v61++ = v6.n128_u32[0];
            }
            while ( v62 );
          }
        }
        break;
      case 4:
        spatializer_process(*(_QWORD *)(a1 + 128), a2, *(_QWORD *)(a1 + 80));
        reverb_process(*(_QWORD *)(a1 + 144), (__int64)a2, *(_QWORD *)(a1 + 104), v66, v67, v68, v69, v70, v71);
        gain_update(*(_QWORD *)(a1 + 160), *(float *)(a1 + 32) + 1.5);
        gain_process(*(_QWORD *)(a1 + 160), *(float32x4_t **)(a1 + 104), *(float32x4_t **)(a1 + 104), v72, v73, v74);
        if ( v9 )
        {
          v75 = *(float32x4_t **)(a1 + 80);
          v76 = *(float32x4_t **)(a1 + 104);
          v77 = 0;
          if ( v9 < 8 )
            goto LABEL_36;
          v78 = a3 + 4LL * v9;
          v79 = (unsigned __int64)&v75->n128_u64[v9 / 2] > a3 && (unsigned __int64)v75 < v78;
          v80 = (unsigned __int64)v76 < v78;
          if ( v79 )
            goto LABEL_36;
          if ( (unsigned __int64)&v76->n128_u64[v9 / 2] > a3 && v80 )
            goto LABEL_36;
          v77 = v9 & 0xFFFFFFF8;
          v81 = v75 + 1;
          v82 = v76 + 1;
          v83 = (float32x4_t *)(a3 + 16);
          v84 = v77;
          do
          {
            v85 = v81[-1];
            v86 = *v81;
            v87 = v82[-1];
            v88 = *v82;
            v81 += 2;
            v82 += 2;
            v84 -= 8;
            v6 = vaddq_f32(v85, v87);
            v83[-1] = v6;
            *v83 = vaddq_f32(v86, v88);
            v83 += 2;
          }
          while ( v84 );
          if ( v77 != v9 )
          {
LABEL_36:
            v89 = (float *)v75 + v77;
            v90 = (float *)v76 + v77;
            v91 = (_DWORD *)(a3 + 4 * v77);
            v92 = v9 - v77;
            do
            {
              v93 = *v89++;
              v94 = v93;
              v95 = *v90++;
              --v92;
              v6.n128_f32[0] = v94 + v95;
              *v91++ = v6.n128_u32[0];
            }
            while ( v92 );
          }
        }
        break;
      default:
        return v6.n128_f32[0];
    }
  }
  return v6.n128_f32[0];
}
// 3A830: variable 'v10' is possibly undefined
// 3A830: variable 'v11' is possibly undefined
// 3A830: variable 'v12' is possibly undefined
// 3A830: variable 'v13' is possibly undefined
// 3A830: variable 'v14' is possibly undefined
// 3A830: variable 'v15' is possibly undefined
// 3A84C: variable 'v16' is possibly undefined
// 3A84C: variable 'v17' is possibly undefined
// 3A84C: variable 'v18' is possibly undefined
// 3A968: variable 'v36' is possibly undefined
// 3A968: variable 'v37' is possibly undefined
// 3A968: variable 'v38' is possibly undefined
// 3A968: variable 'v39' is possibly undefined
// 3A968: variable 'v40' is possibly undefined
// 3A968: variable 'v41' is possibly undefined
// 3A98C: variable 'v42' is possibly undefined
// 3A98C: variable 'v43' is possibly undefined
// 3A98C: variable 'v44' is possibly undefined
// 3AA80: variable 'v66' is possibly undefined
// 3AA80: variable 'v67' is possibly undefined
// 3AA80: variable 'v68' is possibly undefined
// 3AA80: variable 'v69' is possibly undefined
// 3AA80: variable 'v70' is possibly undefined
// 3AA80: variable 'v71' is possibly undefined
// 3AAA4: variable 'v72' is possibly undefined
// 3AAA4: variable 'v73' is possibly undefined
// 3AAA4: variable 'v74' is possibly undefined
// 3AB58: variable 'v6' is possibly undefined

//----- (000000000003AB90) ----------------------------------------------------
__int64 __fastcall spatial_upmix_set_tuning_params(__int64 a1, float a2, float a3)
{
  __int64 v3; // x8
  __int64 v4; // x1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  v3 = *(_QWORD *)(a1 + 144);
  v4 = *(_QWORD *)(a1 + 168);
  *(float *)(a1 + 24) = (float)(fmaxf(fminf(a2, 1.0), 0.0) * 0.5) + 0.2;
  reverb_update(v3, v4, a3);
  return 0;
}

//----- (000000000003AC08) ----------------------------------------------------
__int64 __fastcall spatial_upmix_bypass(__int64 a1, _DWORD *a2, __int64 a3)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  spatializer_bypass(*(_QWORD *)(a1 + 128), a2, a3);
  return 0;
}

//----- (000000000003AC48) ----------------------------------------------------
__int64 __fastcall spatial_upmix_offSetting(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  spatializer_offSetting(*(_QWORD *)(a1 + 128));
  iir_flush(*(_QWORD *)(a1 + 152));
  gain_update(*(_QWORD *)(a1 + 160), 0.0);
  return 0;
}

//----- (000000000003ACA0) ----------------------------------------------------
__int64 __fastcall spatial_upmix_delay_sample_count(__int64 a1, _DWORD *a2)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 20) )
    return spatializer_delay_sample_count(*(_QWORD *)(a1 + 128), a2);
  return 9;
}

//----- (000000000003ACC4) ----------------------------------------------------
long double __fastcall drc_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x70u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[5] = 0u;
    v2[6] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (000000000003AD28) ----------------------------------------------------
__int64 __fastcall drc_destroy(__int64 *a1)
{
  _QWORD *v1; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = (void *)v1[12];
  if ( v3 )
    free(v3);
  v4 = (void *)v1[11];
  v1[12] = 0;
  if ( v4 )
    free(v4);
  v5 = (void *)v1[13];
  v1[11] = 0;
  if ( v5 )
    free(v5);
  v1[13] = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003AD9C) ----------------------------------------------------
__int64 __fastcall drc_flush(__int64 a1)
{
  int v2; // w8
  __int64 v3; // x9
  unsigned int v10; // w8
  __int64 v11; // x10
  __int64 v12; // x12
  __int64 result; // x0
  _OWORD *v14; // x13
  __int64 v15; // x14
  __int64 v16; // x11
  _DWORD *v17; // x10
  __int64 v18; // x10
  __int64 v19; // x11
  _OWORD *v20; // x12
  __int64 v21; // x13
  __int64 v22; // x9
  _DWORD *v23; // x10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  v3 = *(unsigned int *)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 12);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 56) = _D0;
  __asm { FMOV            V0.4S, #1.0 }
  v10 = v2 + v3;
  if ( v10 )
  {
    v11 = *(_QWORD *)(a1 + 88);
    if ( v10 <= 7 )
    {
      v12 = 0;
LABEL_11:
      v16 = v10 - v12;
      v17 = (_DWORD *)(v11 + 4 * v12);
      do
      {
        --v16;
        *v17++ = 1065353216;
      }
      while ( v16 );
      goto LABEL_13;
    }
    v12 = v10 & 0xFFFFFFF8;
    v14 = (_OWORD *)(v11 + 16);
    v15 = v12;
    do
    {
      *(v14 - 1) = _Q0;
      *v14 = _Q0;
      v15 -= 8;
      v14 += 2;
    }
    while ( v15 );
    if ( v12 != v10 )
      goto LABEL_11;
  }
LABEL_13:
  if ( (_DWORD)v3 )
  {
    v18 = *(_QWORD *)(a1 + 96);
    if ( (unsigned int)v3 > 7 )
    {
      v19 = (unsigned int)v3 & 0xFFFFFFF8;
      v20 = (_OWORD *)(v18 + 16);
      v21 = v19;
      do
      {
        *(v20 - 1) = _Q0;
        *v20 = _Q0;
        v21 -= 8;
        v20 += 2;
      }
      while ( v21 );
      if ( v19 == v3 )
        goto LABEL_21;
    }
    else
    {
      v19 = 0;
    }
    v22 = v3 - v19;
    v23 = (_DWORD *)(v18 + 4 * v19);
    do
    {
      --v22;
      *v23++ = 1065353216;
    }
    while ( v22 );
  }
LABEL_21:
  memset(*(void **)(a1 + 104), 0, 4LL * *(_DWORD *)a1 * v10);
  result = 0;
  *(_DWORD *)(a1 + 80) = -915135504;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (000000000003AEC0) ----------------------------------------------------
__int64 __fastcall drc_reset(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  v2 = *(void **)(a1 + 96);
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 88);
  *(_QWORD *)(a1 + 96) = 0;
  if ( v3 )
    free(v3);
  v4 = *(void **)(a1 + 104);
  *(_QWORD *)(a1 + 88) = 0;
  if ( v4 )
    free(v4);
  result = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}

//----- (000000000003AF30) ----------------------------------------------------
__int64 __fastcall drc_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4)
{
  float v6; // s8
  float v7; // s9
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x23
  __int64 result; // x0
  float v15; // s0
  float v16; // s0
  __int64 v17; // x8
  size_t v18; // x20
  void *v19; // x0
  size_t v20; // x20
  void *v21; // x0
  size_t v22; // x20
  int v23; // w8
  __int64 v24; // x9
  unsigned int v31; // w8
  __int64 v32; // x10
  __int64 v33; // x12
  _OWORD *v34; // x13
  __int64 v35; // x14
  __int64 v36; // x11
  _DWORD *v37; // x10
  __int64 v38; // x10
  __int64 v39; // x11
  _OWORD *v40; // x12
  __int64 v41; // x13
  __int64 v42; // x9
  _DWORD *v43; // x10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 3;
  v6 = (float)a3;
  v7 = roundf((float)a3 * 0.001);
  if ( v7 >= (float)a4 )
    return 4;
  if ( *(_BYTE *)(a1 + 20) )
  {
    v10 = *(void **)(a1 + 96);
    if ( v10 )
      free(v10);
    v11 = *(void **)(a1 + 88);
    *(_QWORD *)(a1 + 96) = 0;
    if ( v11 )
      free(v11);
    v12 = *(void **)(a1 + 104);
    *(_QWORD *)(a1 + 88) = 0;
    if ( v12 )
      free(v12);
    v13 = 0;
    *(_QWORD *)(a1 + 104) = 0;
  }
  else
  {
    v13 = *(void **)(a1 + 104);
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  v15 = expf(-1.0 / (float)(v6 * 0.2));
  *(float *)(a1 + 64) = v15;
  *(float *)(a1 + 68) = 1.0 - v15;
  *(_DWORD *)(a1 + 12) = (unsigned int)v7;
  v16 = expf(-1.0 / (float)(v6 * 0.03));
  v17 = ((unsigned int)v7 + a4) * a2;
  v18 = 4 * v17;
  *(float *)(a1 + 72) = v16;
  *(float *)(a1 + 76) = 1.0 - v16;
  if ( !v13 )
  {
    v13 = malloc(4 * v17);
    *(_QWORD *)(a1 + 104) = v13;
    if ( !v13 )
      goto LABEL_43;
  }
  memset(v13, 0, v18);
  v19 = *(void **)(a1 + 88);
  if ( v19 )
  {
    v20 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 8));
  }
  else
  {
    v20 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 8));
    v19 = malloc(v20);
    *(_QWORD *)(a1 + 88) = v19;
    if ( !v19 )
      goto LABEL_43;
  }
  memset(v19, 0, v20);
  v21 = *(void **)(a1 + 96);
  if ( v21 )
  {
    v22 = 4LL * *(unsigned int *)(a1 + 8);
    goto LABEL_26;
  }
  v22 = 4LL * *(unsigned int *)(a1 + 8);
  v21 = malloc(v22);
  *(_QWORD *)(a1 + 96) = v21;
  if ( !v21 )
LABEL_43:
    exit(1);
LABEL_26:
  memset(v21, 0, v22);
  v24 = *(unsigned int *)(a1 + 8);
  v23 = *(_DWORD *)(a1 + 12);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 56) = _D0;
  __asm { FMOV            V0.4S, #1.0 }
  v31 = v23 + v24;
  if ( !v31 )
    goto LABEL_34;
  v32 = *(_QWORD *)(a1 + 88);
  if ( v31 <= 7 )
  {
    v33 = 0;
LABEL_32:
    v36 = v31 - v33;
    v37 = (_DWORD *)(v32 + 4 * v33);
    do
    {
      --v36;
      *v37++ = 1065353216;
    }
    while ( v36 );
    goto LABEL_34;
  }
  v33 = v31 & 0xFFFFFFF8;
  v34 = (_OWORD *)(v32 + 16);
  v35 = v33;
  do
  {
    *(v34 - 1) = _Q0;
    *v34 = _Q0;
    v35 -= 8;
    v34 += 2;
  }
  while ( v35 );
  if ( v33 != v31 )
    goto LABEL_32;
LABEL_34:
  if ( (_DWORD)v24 )
  {
    v38 = *(_QWORD *)(a1 + 96);
    if ( (unsigned int)v24 > 7 )
    {
      v39 = (unsigned int)v24 & 0xFFFFFFF8;
      v40 = (_OWORD *)(v38 + 16);
      v41 = v39;
      do
      {
        *(v40 - 1) = _Q0;
        *v40 = _Q0;
        v41 -= 8;
        v40 += 2;
      }
      while ( v41 );
      if ( v39 == v24 )
        goto LABEL_42;
    }
    else
    {
      v39 = 0;
    }
    v42 = v24 - v39;
    v43 = (_DWORD *)(v38 + 4 * v39);
    do
    {
      --v42;
      *v43++ = 1065353216;
    }
    while ( v42 );
  }
LABEL_42:
  memset(*(void **)(a1 + 104), 0, 4LL * *(_DWORD *)a1 * v31);
  result = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 80) = -915135504;
  *(_BYTE *)(a1 + 20) = 1;
  *(_OWORD *)(a1 + 24) = xmmword_168F0;
  *(_OWORD *)(a1 + 40) = xmmword_16950;
  return result;
}
// 168F0: using guessed type __int128 xmmword_168F0;
// 16950: using guessed type __int128 xmmword_16950;

//----- (000000000003B224) ----------------------------------------------------
__int64 __fastcall drc_update(
        __int64 a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        float a7,
        float a8,
        float a9)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a9 <= 100.0
    && a9 >= -100.0
    && a8 <= 100.0
    && a8 >= -100.0
    && a7 <= 100.0
    && a7 >= -100.0
    && a6 <= 100.0
    && a6 >= -100.0
    && a5 <= 100.0
    && a5 >= -100.0
    && a4 <= 100.0
    && a4 >= -100.0
    && a3 <= 1.0
    && a2 >= -1.0
    && a2 <= 1.0
    && a3 >= -1.0 )
  {
    result = 0;
    *(float *)(a1 + 24) = a2;
    *(float *)(a1 + 28) = a3;
    *(float *)(a1 + 32) = a4;
    *(float *)(a1 + 36) = a5;
    *(float *)(a1 + 40) = a6;
    *(float *)(a1 + 44) = a7;
    *(float *)(a1 + 48) = a8;
    *(float *)(a1 + 52) = a9;
  }
  return result;
}

//----- (000000000003B348) ----------------------------------------------------
__int64 __fastcall drc_process(__int64 a1, __int64 a2, __int64 a3)
{
  int32x2_t v5; // d0
  __int64 v6; // x8
  float32x4_t *v7; // x9
  __int64 v8; // x10
  unsigned int v10; // w9
  int32x4_t v11; // q2
  float32x4_t v12; // q1
  float32x4_t *v13; // x11
  int32x4_t v14; // q3
  int32x4_t v20; // q5
  __int64 v21; // x12
  float32x4_t v22; // q7
  float32x4_t v23; // q6
  unsigned int v24; // w10
  unsigned int v25; // w11
  unsigned __int64 v26; // x13
  int v27; // w15
  float32x4_t *v28; // x0
  __int64 v29; // x17
  __int64 v30; // x1
  float32x4_t *v31; // x1
  __int64 v32; // x2
  unsigned int v33; // w3
  unsigned int v34; // w4
  float32x4_t *v35; // x5
  float32x4_t v36; // q0
  float32x4_t v37; // q1
  float32x4_t *v38; // x6
  float32x4_t v39; // q1
  float *v40; // x0
  unsigned int v41; // w2
  unsigned int v42; // w3
  __int64 v43; // x1
  float v44; // s0
  float v45; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  sub_3B568((unsigned int *)a1, a2);
  if ( *(_BYTE *)(a1 + 21) == 1 )
  {
    v6 = *(unsigned int *)(a1 + 8);
    if ( !(_DWORD)v6 )
      goto LABEL_15;
    v7 = *(float32x4_t **)(a1 + 96);
    v5.n64_f32[0] = (float)(v7->n128_f32[(unsigned int)(v6 - 1)] + -1.0) / (float)(unsigned int)v6;
    if ( (unsigned int)v6 > 7 )
    {
      v11 = (int32x4_t)xmmword_16940;
      v8 = (unsigned int)v6 & 0xFFFFFFF8;
      v12 = vdupq_lane_s32(v5, 0);
      v13 = v7 + 1;
      v14.n128_u64[0] = 0x400000004LL;
      v14.n128_u64[1] = 0x400000004LL;
      __asm { FMOV            V4.4S, #1.0 }
      v20.n128_u64[0] = 0x800000008LL;
      v20.n128_u64[1] = 0x800000008LL;
      v21 = v8;
      do
      {
        v22 = vaddq_f32(vmulq_f32(v12, vcvtq_f32_u32(v11)), _Q4);
        v23 = vaddq_f32(vmulq_f32(v12, vcvtq_f32_u32(vaddq_s32(v11, v14))), _Q4);
        v11 = vaddq_s32(v11, v20);
        v21 -= 8;
        v13[-1] = v22;
        *v13 = v23;
        v13 += 2;
      }
      while ( v21 );
      if ( v8 == v6 )
      {
LABEL_15:
        *(_BYTE *)(a1 + 21) = 0;
        v10 = *(_DWORD *)a1;
        if ( *(_DWORD *)a1 )
        {
LABEL_16:
          v24 = 0;
          v25 = 0;
          v26 = (unsigned int)v6 - 1LL;
          v27 = *(_DWORD *)(a1 + 12) + v6;
          if ( (_DWORD)v6 )
            goto LABEL_19;
          while ( 1 )
          {
            do
            {
              ++v25;
              v24 += v27;
              if ( v25 >= v10 )
                return 0;
            }
            while ( !(_DWORD)v6 );
LABEL_19:
            v28 = *(float32x4_t **)(a1 + 96);
            v29 = *(_QWORD *)(a1 + 104);
            if ( (unsigned int)v6 <= 7 )
              break;
            v30 = 0;
            if ( ~(v27 * v25) >= (unsigned int)v26
              && !HIDWORD(v26)
              && v10 == 1
              && ~v25 >= (unsigned int)v26
              && !HIDWORD(v26) )
            {
              v31 = v28 + 1;
              v32 = (unsigned int)v6 & 0xFFFFFFF8;
              v33 = v25;
              v34 = v24;
              do
              {
                v35 = (float32x4_t *)(v29 + 4LL * v34);
                v36 = v31[-1];
                v37 = *v31;
                v38 = (float32x4_t *)(a3 + 4LL * v33);
                v31 += 2;
                v34 += 8;
                v32 -= 8;
                v39 = vmulq_f32(v35[1], v37);
                v33 += 8 * v10;
                *v38 = vmulq_f32(*v35, v36);
                v38[1] = v39;
              }
              while ( v32 );
              v30 = (unsigned int)v6 & 0xFFFFFFF8;
              if ( v30 == (unsigned int)v6 )
                continue;
            }
LABEL_29:
            v40 = (float *)v28 + v30;
            v41 = v25 + v10 * v30;
            v42 = v24 + v30;
            v43 = (unsigned int)v6 - v30;
            do
            {
              v44 = *(float *)(v29 + 4LL * v42);
              v45 = *v40++;
              --v43;
              ++v42;
              *(float *)(a3 + 4LL * v41) = v44 * v45;
              v41 += v10;
            }
            while ( v43 );
          }
          v30 = 0;
          goto LABEL_29;
        }
        return 0;
      }
    }
    else
    {
      v8 = 0;
    }
    do
    {
      v7->n128_f32[v8] = (float)(v5.n64_f32[0] * (float)(unsigned int)v8) + 1.0;
      ++v8;
    }
    while ( v6 != v8 );
    goto LABEL_15;
  }
  LODWORD(v6) = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    goto LABEL_16;
  return 0;
}
// 3B3DC: variable 'v5' is possibly undefined
// 16940: using guessed type __int128 xmmword_16940;

//----- (000000000003B568) ----------------------------------------------------
void __fastcall sub_3B568(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  unsigned int v3; // w9
  int v5; // w22
  int v7; // w21
  unsigned __int64 v8; // x23
  char *v9; // x0
  unsigned __int64 v10; // x10
  __int64 v11; // x11
  unsigned __int64 v12; // x9
  unsigned int v13; // w13
  int v14; // w12
  int v15; // w14
  unsigned int v16; // w15
  __int64 v17; // x20
  __int64 v18; // x21
  unsigned __int64 v19; // x8
  __int64 v20; // x9
  unsigned __int64 v21; // x11
  float v22; // s0
  unsigned __int64 v23; // x12
  unsigned int v24; // w14
  float v25; // s1
  __int64 v26; // x24
  signed int v27; // w26
  __int64 v28; // x22
  int v29; // w23
  float v30; // s0
  float v31; // s1
  float v32; // s2
  float v33; // s3
  float v34; // s0
  float v36; // s0
  float v37; // s1
  __int64 v38; // x9
  __int64 v39; // x8
  float v40; // s1
  float v41; // s0
  float v42; // s0

  LODWORD(v2) = a1[2];
  v3 = a1[3];
  v5 = v3 + v2;
  if ( *a1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = (char *)(*((_QWORD *)a1 + 13) + 4LL * (unsigned int)(v5 * v8));
      memcpy(v9, &v9[4 * (unsigned int)v2], 4LL * v3);
      v2 = a1[2];
      v10 = *a1;
      if ( (_DWORD)v2 )
      {
        v11 = *((_QWORD *)a1 + 13);
        v12 = 0;
        v13 = v8;
        v14 = a1[3] + v7;
        do
        {
          v15 = *(_DWORD *)(a2 + 4LL * v13);
          v16 = v14 + v12++;
          v13 += v10;
          *(_DWORD *)(v11 + 4LL * v16) = v15;
        }
        while ( v12 < v2 );
      }
      v3 = a1[3];
      ++v8;
      v7 += v5;
    }
    while ( v8 < v10 );
  }
  memcpy(*((void **)a1 + 11), (const void *)(*((_QWORD *)a1 + 11) + 4LL * (unsigned int)v2), 4LL * v3);
  v17 = a1[2];
  v18 = a1[3];
  if ( (unsigned int)v18 < (int)v17 + (int)v18 )
  {
    v19 = *a1;
    v20 = *((_QWORD *)a1 + 11);
    v21 = a1[3];
    if ( (_DWORD)v19 )
      goto LABEL_13;
LABEL_10:
    v22 = -99999.0;
    while ( 1 )
    {
      *(float *)(v20 + 4 * v21++) = v22;
      if ( v21 >= (unsigned int)(v17 + v18) )
        break;
      if ( !(_DWORD)v19 )
        goto LABEL_10;
LABEL_13:
      v23 = 0;
      v22 = -99999.0;
      v24 = v21;
      do
      {
        v25 = *(float *)(*((_QWORD *)a1 + 13) + 4LL * v24);
        ++v23;
        v24 += v5;
        v22 = fmaxf(v22, fabsf(v25));
      }
      while ( v23 < v19 );
    }
  }
  if ( (_DWORD)v17 )
  {
    v26 = *((_QWORD *)a1 + 12);
    v27 = a1[4];
    v28 = 0;
    v29 = v18 - 1;
    do
    {
      if ( v27-- <= 0 )
      {
        a1[20] = -915135504;
        if ( (_DWORD)v18 )
        {
          v38 = *((_QWORD *)a1 + 11);
          v39 = 0;
          v36 = -1000000.0;
          do
          {
            v40 = *(float *)(v38 + 4LL * (unsigned int)(v28 + v39));
            if ( v40 >= v36 )
            {
              v36 = *(float *)(v38 + 4LL * (unsigned int)(v28 + v39));
              v27 = v39;
              *((float *)a1 + 20) = v40;
            }
            ++v39;
          }
          while ( v18 != v39 );
        }
        else
        {
          v36 = -1000000.0;
        }
      }
      else
      {
        v36 = *((float *)a1 + 20);
        v37 = *(float *)(*((_QWORD *)a1 + 11) + 4LL * (unsigned int)(v29 + v28));
        if ( v37 >= v36 )
        {
          v36 = *(float *)(*((_QWORD *)a1 + 11) + 4LL * (unsigned int)(v29 + v28));
          v27 = v18 - 1;
          *((float *)a1 + 20) = v37;
        }
      }
      v41 = log10f(fmaxf(v36, 0.00001)) * 20.0;
      if ( v41 < *((float *)a1 + 11) )
      {
        v30 = fmaxf(*((float *)a1 + 16) * *((float *)a1 + 14), 0.0);
      }
      else if ( v41 >= *((float *)a1 + 12) )
      {
        if ( v41 >= *((float *)a1 + 13) )
          v42 = *((float *)a1 + 10);
        else
          v42 = *((float *)a1 + 10) + (float)(*((float *)a1 + 7) * (float)(v41 + *((float *)a1 + 9)));
        v30 = fmaxf(v42, (float)(*((float *)a1 + 16) * *((float *)a1 + 14)) + (float)(v42 * *((float *)a1 + 17)));
      }
      else
      {
        v30 = fmaxf(
                *((float *)a1 + 6) * (float)(v41 + *((float *)a1 + 8)),
                (float)(*((float *)a1 + 16) * *((float *)a1 + 14))
              + (float)((float)(v41 + *((float *)a1 + 8)) * (float)(*((float *)a1 + 6) * *((float *)a1 + 17))));
      }
      v31 = *((float *)a1 + 15);
      v32 = *((float *)a1 + 18);
      v33 = *((float *)a1 + 19);
      *((float *)a1 + 14) = v30;
      v34 = (float)(v32 * v31) + (float)(v33 * v30);
      *((float *)a1 + 15) = v34;
      *(float *)(v26 + 4 * v28++) = powf(10.0, v34 / 20.0);
    }
    while ( v28 != v17 );
    a1[4] = v27;
  }
}

//----- (000000000003B87C) ----------------------------------------------------
__int64 __fastcall drc_bypass(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // w8
  __int64 v6; // x11
  __int64 v7; // x17
  unsigned __int64 v8; // x17
  int v9; // w9
  unsigned int v10; // w10
  int v11; // w13
  int v12; // w2
  __int64 v13; // x3
  __int64 v14; // x5
  unsigned int v15; // w4
  unsigned int v16; // w6
  __int64 v17; // x5
  int v18; // w7
  bool v19; // w4
  __int64 v20; // x4
  unsigned int v21; // w5
  unsigned int v22; // w6
  int v23; // w7
  int v24; // w21
  unsigned int v25; // w22
  __int64 result; // x0
  __int64 v27; // x8
  float *v28; // x9
  float v29; // s0
  __int64 i; // x10
  unsigned int v31; // w10
  unsigned int v32; // w11
  unsigned int v33; // w12
  unsigned __int64 v34; // x13
  int v35; // w16
  __int64 v36; // x0
  __int64 v37; // x1
  __int64 v38; // x1
  unsigned int v39; // w2
  unsigned int v40; // w3
  float32x4_t *v41; // x4
  float32x4_t *v42; // x5
  float32x4_t v43; // q0
  float32x4_t v44; // q1
  float32x4_t *v45; // x6
  float32x4_t v46; // q1
  float *v47; // x2
  unsigned int v48; // w3
  unsigned int v49; // w4
  __int64 v50; // x1
  float v51; // s0
  float v52; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  sub_3B568((unsigned int *)a1, a2);
  if ( !*(_BYTE *)(a1 + 21) )
  {
    v27 = *(unsigned int *)(a1 + 8);
    v28 = *(float **)(a1 + 96);
    if ( (_DWORD)v27 )
    {
      v29 = (float)(1.0 - *v28) / (float)(unsigned int)v27;
      *v28 = (float)(v29 * 0.0) + *v28;
      if ( (_DWORD)v27 != 1 )
      {
        for ( i = 1; i != v27; ++i )
          v28[i] = (float)(v29 * (float)(unsigned int)i) + *v28;
      }
    }
    v31 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
    {
LABEL_49:
      result = 0;
      *(_BYTE *)(a1 + 21) = 1;
      return result;
    }
    v32 = 0;
    v33 = 0;
    v34 = v27 - 1;
    v35 = *(_DWORD *)(a1 + 12) + v27;
    if ( (_DWORD)v27 )
      goto LABEL_36;
    while ( 1 )
    {
      do
      {
        ++v33;
        v32 += v35;
        if ( v33 >= v31 )
          goto LABEL_49;
      }
      while ( !(_DWORD)v27 );
LABEL_36:
      v36 = *(_QWORD *)(a1 + 104);
      if ( (unsigned int)v27 <= 7 )
        break;
      v37 = 0;
      if ( ~(v35 * v33) >= (unsigned int)v34 && !HIDWORD(v34) && v31 == 1 && ~v33 >= (unsigned int)v34 && !HIDWORD(v34) )
      {
        v38 = (unsigned int)v27 & 0xFFFFFFF8;
        v39 = v33;
        v40 = v32;
        v41 = (float32x4_t *)(v28 + 4);
        do
        {
          v42 = (float32x4_t *)(v36 + 4LL * v40);
          v43 = v41[-1];
          v44 = *v41;
          v45 = (float32x4_t *)(a3 + 4LL * v39);
          v41 += 2;
          v40 += 8;
          v38 -= 8;
          v46 = vmulq_f32(v42[1], v44);
          v39 += 8 * v31;
          *v45 = vmulq_f32(*v42, v43);
          v45[1] = v46;
        }
        while ( v38 );
        v37 = (unsigned int)v27 & 0xFFFFFFF8;
        if ( v37 == v27 )
          continue;
      }
LABEL_46:
      v47 = &v28[v37];
      v48 = v33 + v31 * v37;
      v49 = v32 + v37;
      v50 = v27 - v37;
      do
      {
        v51 = *(float *)(v36 + 4LL * v49);
        v52 = *v47++;
        --v50;
        ++v49;
        *(float *)(a3 + 4LL * v48) = v51 * v52;
        v48 += v31;
      }
      while ( v50 );
    }
    v37 = 0;
    goto LABEL_46;
  }
  v5 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    v6 = *(unsigned int *)(a1 + 8);
    if ( v5 >= 0 )
      v7 = (unsigned int)v5;
    else
      v7 = (unsigned int)-v5;
    v8 = v7 * (unsigned int)(v6 - 1);
    v9 = 0;
    v10 = 0;
    v11 = *(_DWORD *)(a1 + 12) + v6;
    v12 = 1;
    if ( (_DWORD)v6 )
      goto LABEL_11;
    while ( 1 )
    {
      do
      {
        ++v10;
        v12 += v11;
        v9 += v11;
        if ( v10 >= v5 )
          return 0;
      }
      while ( !(_DWORD)v6 );
LABEL_11:
      v13 = *(_QWORD *)(a1 + 104);
      if ( (_DWORD)v6 == 1 )
        break;
      v19 = v10 < (unsigned int)v8;
      if ( v5 >= 0 )
        v19 = (unsigned int)v8 > ~v10;
      v14 = 0;
      if ( ~(v11 * v10) >= (int)v6 - 1 && !((unsigned __int64)(v6 - 1) >> 32) && !v19 && HIDWORD(v8) == 0 )
      {
        v20 = (unsigned int)v6 & 0xFFFFFFFE;
        v21 = v10;
        v22 = v12;
        do
        {
          v23 = *(_DWORD *)(v13 + 4LL * (v22 - 1));
          v24 = *(_DWORD *)(v13 + 4LL * v22);
          v25 = v5 + v21;
          v22 += 2;
          v20 -= 2;
          *(_DWORD *)(a3 + 4LL * v21) = v23;
          v21 += 2 * v5;
          *(_DWORD *)(a3 + 4LL * v25) = v24;
        }
        while ( v20 );
        v14 = (unsigned int)v6 & 0xFFFFFFFE;
        if ( v14 == v6 )
          continue;
      }
LABEL_13:
      v15 = v10 + v5 * v14;
      v16 = v9 + v14;
      v17 = v6 - v14;
      do
      {
        v18 = *(_DWORD *)(v13 + 4LL * v16);
        --v17;
        ++v16;
        *(_DWORD *)(a3 + 4LL * v15) = v18;
        v15 += v5;
      }
      while ( v17 );
    }
    v14 = 0;
    goto LABEL_13;
  }
  return 0;
}

//----- (000000000003BB74) ----------------------------------------------------
__int64 __fastcall drc_delay_sample_count(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 20) )
    return 9;
  v2 = *(_DWORD *)(a1 + 12);
  result = 0;
  *a2 = v2;
  return result;
}

//----- (000000000003BBA4) ----------------------------------------------------
long double __fastcall boost_gain_create(_QWORD *a1)
{
  _DWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x44u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[16] = 0;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
  }
  return result;
}

//----- (000000000003BC04) ----------------------------------------------------
__int64 __fastcall boost_gain_destroy(void **a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  free(v2);
  result = 0;
  *a1 = 0;
  return result;
}

//----- (000000000003BC40) ----------------------------------------------------
__int64 __fastcall boost_gain_flush(__int64 a1)
{
  float v2; // s1
  float v3; // s0
  bool v4; // zf
  float v5; // s2
  float v6; // s3
  float v7; // s0
  unsigned int v8; // w9
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 64) )
    return 9;
  v2 = (float)*(unsigned int *)(a1 + 8);
  v3 = (float)*(unsigned int *)(a1 + 4);
  v4 = *(_BYTE *)(a1 + 30) == 1;
  v5 = (float)(v2 * 5.0) / v3;
  v6 = -13.0;
  *(_QWORD *)(a1 + 56) = 0xC120000000000000LL;
  v7 = (float)(v2 * 30.0) / v3;
  *(_DWORD *)(a1 + 48) = 1065353216;
  v8 = vcvtps_u32_f32(v5);
  result = 0;
  if ( v4 )
    v6 = -7.0;
  *(_DWORD *)(a1 + 24) = v8;
  *(_WORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = vcvtps_u32_f32(v7);
  *(_DWORD *)(a1 + 16) = 0;
  *(float *)(a1 + 40) = v6;
  return result;
}

//----- (000000000003BCCC) ----------------------------------------------------
__int64 __fastcall boost_gain_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 64) )
    return 9;
  result = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

//----- (000000000003BCF8) ----------------------------------------------------
__int64 __fastcall boost_gain_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a2 )
    return 1;
  if ( !a3 )
    return 3;
  if ( !a4 )
    return 4;
  *(_QWORD *)(a1 + 48) = 1065353216;
  *(_BYTE *)(a1 + 64) = 1;
  result = 0;
  *(_DWORD *)(a1 + 24) = vcvtps_u32_f32((float)((float)a3 * 5.0) / (float)a4);
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a4;
  *(_BYTE *)(a1 + 28) = 0;
  *(_WORD *)(a1 + 29) = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = vcvtps_u32_f32((float)((float)a3 * 30.0) / (float)a4);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 56) = 0xC120000000000000LL;
  *(_QWORD *)(a1 + 40) = 0x41080000C1500000LL;
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000000000003BDA0) ----------------------------------------------------
__int64 __fastcall boost_gain_update(__int64 a1, char a2, float a3, float a4, float a5, float a6)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 64) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a6 <= 20.0 && a6 >= 0.0 && a5 <= 0.0 && a3 >= -80.0 && a3 <= 0.0 && a5 >= -80.0 )
  {
    result = 0;
    *(_BYTE *)(a1 + 30) = a2;
    *(float *)(a1 + 40) = a5;
    *(float *)(a1 + 44) = a6;
    *(float *)(a1 + 32) = a3;
    *(float *)(a1 + 52) = a4;
  }
  return result;
}

//----- (000000000003BE20) ----------------------------------------------------
__int64 __fastcall boost_gain_process(int *a1, float32x4_t *src, float32x4_t *dest)
{
  float v4; // s0
  int v5; // w22
  __int64 v6; // x23
  unsigned int v9; // w9
  unsigned int v10; // w10
  int v11; // w8
  __int64 result; // x0
  float v13; // s1
  unsigned int v14; // w24
  unsigned int v15; // w25
  float v16; // s9
  float v17; // s8
  float v18; // s0
  float v19; // s0
  int32x2_t v20; // d0
  int32x2_t v21; // d1
  int32x2_t v22; // d5
  __int64 v23; // x9
  unsigned int v24; // w8
  int32x4_t v25; // q2
  float32x4_t v26; // q4
  float32x4_t v27; // q6
  int32x4_t v28; // q7
  __int64 v29; // x13
  __int64 v30; // x13
  unsigned int v31; // w14
  int32x4_t v32; // q16
  __int64 v33; // x15
  float32x4_t v34; // q19
  float32x4_t v35; // q20
  float32x4_t v36; // q18
  float32x4_t v37; // q17
  float32x4_t *v38; // x15
  unsigned int v39; // w14
  __int64 v40; // x15
  float v41; // s16
  float32x4_t v42; // q1
  float32x4_t *v43; // x10
  float32x4_t *v44; // x11
  __int64 v45; // x12
  float32x4_t v46; // q2
  float32x4_t v47; // q3
  float *v48; // x10
  float *v49; // x11
  __int64 v50; // x8
  float v51; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 64) )
    return 9;
  v4 = *((float *)a1 + 8);
  v5 = *a1;
  v6 = (unsigned int)a1[1];
  if ( v4 <= -70.0 )
  {
    v11 = 0;
    *((_BYTE *)a1 + 29) = 0;
  }
  else
  {
    v9 = a1[4];
    v10 = a1[6];
    v11 = 1;
    *((_BYTE *)a1 + 29) = 1;
    if ( v9 <= v10 )
    {
      a1[4] = v9 + 1;
      v11 = 1;
    }
  }
  if ( *((_BYTE *)a1 + 30) == 1 )
    v13 = 8.5;
  else
    v13 = *((float *)a1 + 11);
  v14 = v6 * v5;
  *((float *)a1 + 9) = v13;
  if ( !v11 )
  {
    a1[12] = 1065353216;
    memcpy(dest, src, 4LL * v14);
    return 0;
  }
  v15 = a1[4];
  v16 = *((float *)a1 + 10);
  v17 = v16 - v4;
  if ( v15 >= a1[6] )
  {
    v19 = (float)(v17 * 0.1) + (float)(*((float *)a1 + 15) * 0.9);
    *((float *)a1 + 15) = v19;
  }
  else
  {
    v18 = (float)(*((float *)a1 + 14) * 0.75) + (float)(*((float *)a1 + 13) * 0.25);
    if ( v18 == 0.0 )
      v18 = 0.00001;
    *((float *)a1 + 14) = v18;
    v19 = (float)(*((float *)a1 + 15) * 0.25) + (float)(fminf(v17, v16 + (float)(log10f(v18) * -10.0)) * 0.75);
    a1[9] = 1084227584;
    *((float *)a1 + 15) = v19;
    v13 = 5.0;
  }
  v20.n64_f32[0] = fmaxf(powf(10.0, fminf(v13, v19) / 20.0), 0.00001);
  if ( v15 != 1 )
  {
    if ( !v5 )
      goto LABEL_43;
    v21.n64_u32[0] = a1[12];
    v22.n64_f32[0] = (float)(v20.n64_f32[0] - v21.n64_f32[0]) / (float)(unsigned int)(v6 - 1);
    v24 = 0;
    v25.n128_u64[0] = 0x400000004LL;
    v25.n128_u64[1] = 0x400000004LL;
    v26 = vdupq_lane_s32(v21, 0);
    v27 = vdupq_lane_s32(v22, 0);
    v28.n128_u64[0] = 0x800000008LL;
    v28.n128_u64[1] = 0x800000008LL;
    if ( (_DWORD)v6 )
      goto LABEL_27;
    while ( 1 )
    {
      do
      {
        if ( ++v24 == v5 )
          goto LABEL_43;
      }
      while ( !(_DWORD)v6 );
LABEL_27:
      if ( (unsigned int)v6 <= 7 )
        break;
      v29 = 0;
      if ( v5 == 1 && ~v24 >= (int)v6 - 1 && !((unsigned __int64)(v6 - 1) >> 32) )
      {
        v30 = (unsigned int)v6 & 0xFFFFFFF8;
        v31 = v24;
        v32 = (int32x4_t)xmmword_16940;
        do
        {
          v33 = 4LL * v31;
          v34 = *(float32x4_t *)((char *)src + v33);
          v35 = *(float32x4_t *)((char *)src + v33 + 16);
          v36 = vaddq_f32(v26, vmulq_f32(v27, vcvtq_f32_u32(v32)));
          v37 = vaddq_f32(v26, vmulq_f32(v27, vcvtq_f32_u32(vaddq_s32(v32, v25))));
          v32 = vaddq_s32(v32, v28);
          v30 -= 8;
          v38 = (float32x4_t *)((char *)dest + v33);
          v31 += 8 * v5;
          *v38 = vmulq_f32(v36, v34);
          v38[1] = vmulq_f32(v37, v35);
        }
        while ( v30 );
        v29 = (unsigned int)v6 & 0xFFFFFFF8;
        if ( v29 == v6 )
          continue;
      }
LABEL_35:
      v39 = v24 + v5 * v29;
      do
      {
        v40 = v39;
        v41 = v22.n64_f32[0] * (float)(unsigned int)v29++;
        v39 += v5;
        dest->n128_f32[v40] = (float)(v21.n64_f32[0] + v41) * src->n128_f32[v40];
      }
      while ( v6 != v29 );
    }
    v29 = 0;
    goto LABEL_35;
  }
  if ( v14 )
  {
    if ( v14 >= 8 )
    {
      v23 = v14 & 0xFFFFFFF8;
      v42 = vdupq_lane_s32(v20, 0);
      v43 = src + 1;
      v44 = dest + 1;
      v45 = v23;
      do
      {
        v46 = v43[-1];
        v47 = *v43;
        v43 += 2;
        v45 -= 8;
        v44[-1] = vmulq_f32(v42, v46);
        *v44 = vmulq_f32(v42, v47);
        v44 += 2;
      }
      while ( v45 );
      if ( v23 == v14 )
        goto LABEL_43;
    }
    else
    {
      v23 = 0;
    }
    v48 = (float *)src + v23;
    v49 = (float *)dest + v23;
    v50 = v14 - v23;
    do
    {
      v51 = *v48++;
      --v50;
      *v49++ = v20.n64_f32[0] * v51;
    }
    while ( v50 );
  }
LABEL_43:
  result = 0;
  a1[12] = v20.n64_u32[0];
  return result;
}
// 3C020: variable 'v21' is possibly undefined
// 3C024: variable 'v22' is possibly undefined
// 3C10C: variable 'v20' is possibly undefined
// 16940: using guessed type __int128 xmmword_16940;

//----- (000000000003C190) ----------------------------------------------------
long double __fastcall compressor_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x50u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
  }
  return result;
}

//----- (000000000003C1F0) ----------------------------------------------------
__int64 __fastcall compressor_destroy(__int64 *a1)
{
  _QWORD *v1; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = (void *)v1[7];
  if ( v3 )
    free(v3);
  v4 = (void *)v1[8];
  v1[7] = 0;
  if ( v4 )
    free(v4);
  v5 = (void *)v1[9];
  v1[8] = 0;
  if ( v5 )
    free(v5);
  v1[9] = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003C264) ----------------------------------------------------
__int64 __fastcall compressor_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  sub_3C2A0((unsigned int *)a1);
  return 0;
}

//----- (000000000003C2A0) ----------------------------------------------------
void *__fastcall sub_3C2A0(unsigned int *a1)
{
  __int64 v1; // x8
  void *v3; // x0

  v1 = *a1;
  v3 = (void *)*((_QWORD *)a1 + 7);
  a1[3] = 0;
  memset(v3, 0, 4 * v1);
  memset(*((void **)a1 + 8), 0, 4LL * *a1);
  return memset(*((void **)a1 + 9), 0, 4LL * a1[2] * *a1);
}

//----- (000000000003C300) ----------------------------------------------------
__int64 __fastcall compressor_reset(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v2 = *(void **)(a1 + 56);
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 56) = 0;
  if ( v3 )
    free(v3);
  v4 = *(void **)(a1 + 72);
  *(_QWORD *)(a1 + 64) = 0;
  if ( v4 )
    free(v4);
  result = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  return result;
}

//----- (000000000003C370) ----------------------------------------------------
__int64 __fastcall compressor_setup(unsigned int *a1, size_t n, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // w20
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  size_t v12; // x20
  void *v13; // x0
  size_t v14; // x20
  __int64 result; // x0
  void *v16; // x0
  size_t v17; // x20
  float v18; // s0
  float v19; // s8
  float v20; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = n;
  if ( !(_DWORD)n )
    return 1;
  if ( !a3 )
    return 3;
  if ( !a4 )
    return 4;
  if ( *((_BYTE *)a1 + 16) )
  {
    v8 = (void *)*((_QWORD *)a1 + 7);
    if ( v8 )
      free(v8);
    v9 = (void *)*((_QWORD *)a1 + 8);
    *((_QWORD *)a1 + 7) = 0;
    if ( v9 )
      free(v9);
    v10 = (void *)*((_QWORD *)a1 + 9);
    *((_QWORD *)a1 + 8) = 0;
    if ( v10 )
      free(v10);
    *((_QWORD *)a1 + 9) = 0;
  }
  v11 = (void *)*((_QWORD *)a1 + 7);
  *a1 = v4;
  a1[1] = a3;
  v12 = 4LL * v4;
  a1[2] = a4;
  if ( !v11 )
  {
    v11 = malloc(v12);
    *((_QWORD *)a1 + 7) = v11;
    if ( !v11 )
      goto LABEL_32;
  }
  memset(v11, 0, v12);
  v13 = (void *)*((_QWORD *)a1 + 8);
  if ( v13 )
  {
    v14 = 4LL * *a1;
  }
  else
  {
    v14 = 4LL * *a1;
    v13 = malloc(v14);
    *((_QWORD *)a1 + 8) = v13;
    if ( !v13 )
      goto LABEL_32;
  }
  memset(v13, 0, v14);
  v16 = (void *)*((_QWORD *)a1 + 9);
  if ( !v16 )
  {
    v17 = 4LL * a1[2] * *a1;
    v16 = malloc(v17);
    *((_QWORD *)a1 + 9) = v16;
    if ( v16 )
      goto LABEL_25;
LABEL_32:
    exit(1);
  }
  v17 = 4LL * a1[2] * *a1;
LABEL_25:
  memset(v16, 0, v17);
  sub_3C2A0(a1);
  v18 = *((float *)a1 + 5);
  *((_BYTE *)a1 + 16) = 1;
  if ( v18 == 0.0005
    && *((float *)a1 + 6) == 0.032
    && *((float *)a1 + 11) == -3.0
    && *((float *)a1 + 9) == 0.5
    && *((float *)a1 + 12) == 3.0 )
  {
    result = 0;
    a1[13] = -1082130432;
  }
  else
  {
    sub_3C2A0(a1);
    v19 = (float)a1[1];
    *(_QWORD *)(a1 + 5) = 0x3D03126F3A03126FLL;
    a1[13] = -1082130432;
    *((float *)a1 + 8) = expf(-1.0 / (float)(v19 * 0.0005));
    v20 = expf(-1.0 / (float)(v19 * 0.032));
    result = 0;
    *((float *)a1 + 7) = v20;
    *(_OWORD *)(a1 + 9) = xmmword_16900;
  }
  return result;
}
// 16900: using guessed type __int128 xmmword_16900;

//----- (000000000003C5C4) ----------------------------------------------------
__int64 __fastcall compressor_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  __int64 result; // x0
  unsigned int v15; // s0
  float v16; // s10
  float v17; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a7 <= 65.0
    && a7 >= -18.0
    && a6 <= 12.0
    && a6 >= 0.0
    && a5 <= 1.0
    && a5 >= 0.0
    && a4 <= 0.0
    && a4 >= -65.0
    && a3 <= 3.0
    && a2 >= 0.0
    && a2 <= 0.07
    && a3 >= 0.005 )
  {
    if ( *(float *)(a1 + 20) == a2
      && *(float *)(a1 + 24) == a3
      && *(float *)(a1 + 44) == a4
      && *(float *)(a1 + 36) == a5
      && *(float *)(a1 + 48) == a6
      && (*(float *)(a1 + 52) = a7, a7 != 0.0) )
    {
      return 0;
    }
    else
    {
      sub_3C2A0((unsigned int *)a1);
      v15 = *(_DWORD *)(a1 + 4);
      *(float *)(a1 + 52) = a7;
      *(float *)(a1 + 44) = a4;
      *(float *)(a1 + 48) = a6;
      v16 = (float)v15;
      *(float *)(a1 + 20) = a2;
      *(float *)(a1 + 24) = a3;
      *(float *)(a1 + 36) = a5;
      *(float *)(a1 + 32) = expf(-1.0 / (float)((float)v15 * a2));
      v17 = expf(-1.0 / (float)(v16 * a3));
      result = 0;
      *(float *)(a1 + 28) = v17;
      *(float *)(a1 + 40) = 1.0 - a5;
    }
  }
  return result;
}

//----- (000000000003C770) ----------------------------------------------------
__int64 __fastcall compressor_process(unsigned int *a1, float *a2, __int64 a3)
{
  unsigned __int64 v6; // x24
  unsigned __int64 v7; // x26
  __int64 v8; // x27
  float *v9; // x23
  __int64 v10; // x28
  unsigned __int64 v11; // x25
  unsigned int v12; // w19
  __int64 v13; // x20
  __int64 v14; // x8
  float v15; // s0
  float v16; // s0
  __int64 v18; // [xsp+8h] [xbp-78h]
  __int64 v19; // [xsp+18h] [xbp-68h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 16) )
    return 9;
  sub_3C8CC(a1, a2);
  v6 = *a1;
  if ( (_DWORD)v6 )
  {
    v7 = a1[2];
    v8 = 0;
    v9 = a2;
    if ( (_DWORD)v7 )
      goto LABEL_7;
    while ( ++v8 < v6 )
    {
      if ( (_DWORD)v7 )
      {
LABEL_7:
        v10 = *((_QWORD *)a1 + 8);
        v11 = 0;
        v12 = v8;
        v19 = *((_QWORD *)a1 + 9);
        v18 = *((_QWORD *)a1 + 7);
        do
        {
          v13 = 4LL * v12;
          v14 = 4 * v8;
          v15 = fmaxf(
                  *(float *)(v19 + v13),
                  (float)(*((float *)a1 + 7) * *(float *)(v18 + 4 * v8))
                + (float)((float)(1.0 - *((float *)a1 + 7)) * *(float *)(v19 + v13)));
          *(float *)(v18 + v14) = v15;
          v16 = (float)((float)(1.0 - *((float *)a1 + 8)) * v15)
              + (float)(*((float *)a1 + 8) * *(float *)(v10 + 4 * v8));
          *(float *)(v10 + v14) = v16;
          ++v11;
          v12 += v6;
          *(float *)(a3 + v13) = v9[(unsigned __int64)v13 / 4] * powf(10.0, (float)(*((float *)a1 + 13) - v16) / 20.0);
        }
        while ( v11 < v7 );
      }
    }
  }
  return 0;
}

//----- (000000000003C8CC) ----------------------------------------------------
void __fastcall sub_3C8CC(unsigned int *a1, float *a2)
{
  float v2; // s11
  float v5; // s8
  float v6; // s0
  __int64 v7; // x21
  unsigned int v8; // w8
  float *v9; // x22
  float v10; // s13
  __int64 v11; // x23
  float v12; // s1
  float v13; // s0
  float v14; // s14
  float v15; // s0
  float *v16; // x8
  float *v17; // x9
  float v18; // t1
  float v19; // s0
  __int64 v20; // x12

  v2 = *((float *)a1 + 12) * 0.5;
  v5 = powf(10.0, v2 / 20.0);
  v6 = powf(10.0, *((float *)a1 + 11) / 20.0);
  v7 = *a1;
  v8 = a1[2] * v7;
  if ( v8 )
  {
    v9 = (float *)*((_QWORD *)a1 + 9);
    v10 = 1.0 / v6;
    v11 = v8;
    do
    {
      v13 = fmaxf(fabsf(*a2), 0.00001);
      v12 = 0.0;
      if ( (float)(v10 * v13) >= (float)(1.0 / v5) )
      {
        if ( (float)(v10 * v13) > v5 || (v14 = *((float *)a1 + 12), v14 <= 0.0) )
        {
          v12 = (float)((float)(log10f(v13) * 20.0) - *((float *)a1 + 11)) * *((float *)a1 + 10);
        }
        else
        {
          v15 = v2 + (float)((float)(log10f(v13) * 20.0) - *((float *)a1 + 11));
          v12 = (float)(*((float *)a1 + 10) * (float)(v15 * v15)) / (float)(v14 + v14);
        }
      }
      *v9++ = v12;
      --v11;
      ++a2;
    }
    while ( v11 );
  }
  if ( !a1[3] )
  {
    if ( (_DWORD)v7 )
    {
      v16 = (float *)*((_QWORD *)a1 + 9);
      v17 = (float *)*((_QWORD *)a1 + 7);
      do
      {
        v18 = *v16++;
        v19 = v18;
        if ( v18 <= 0.0 )
          v20 = 7;
        else
          v20 = 8;
        --v7;
        *v17++ = v19 * (float)(1.0 - *(float *)&a1[v20]);
      }
      while ( v7 );
    }
    a1[3] = 1;
  }
}

//----- (000000000003CA48) ----------------------------------------------------
__int64 __fastcall compressor_process_inplace(unsigned int *a1, float *a2)
{
  unsigned __int64 v4; // x23
  unsigned __int64 v5; // x25
  __int64 v6; // x22
  __int64 v7; // x27
  __int64 v8; // x26
  unsigned __int64 v9; // x24
  unsigned int v10; // w28
  __int64 v11; // x21
  __int64 v12; // x8
  float v13; // s0
  float v14; // s0
  __int64 v16; // [xsp+8h] [xbp-68h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 16) )
    return 9;
  sub_3C8CC(a1, a2);
  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    v5 = a1[2];
    v6 = 0;
    if ( (_DWORD)v5 )
      goto LABEL_7;
    while ( ++v6 < v4 )
    {
      if ( (_DWORD)v5 )
      {
LABEL_7:
        v7 = *((_QWORD *)a1 + 8);
        v8 = *((_QWORD *)a1 + 7);
        v9 = 0;
        v10 = v6;
        v16 = *((_QWORD *)a1 + 9);
        do
        {
          v11 = v10;
          v12 = 4 * v6;
          v13 = fmaxf(
                  *(float *)(v16 + v11 * 4),
                  (float)(*((float *)a1 + 7) * *(float *)(v8 + 4 * v6))
                + (float)((float)(1.0 - *((float *)a1 + 7)) * *(float *)(v16 + v11 * 4)));
          *(float *)(v8 + v12) = v13;
          v14 = (float)((float)(1.0 - *((float *)a1 + 8)) * v13) + (float)(*((float *)a1 + 8) * *(float *)(v7 + 4 * v6));
          *(float *)(v7 + v12) = v14;
          ++v9;
          v10 += v4;
          a2[v11] = a2[v11] * powf(10.0, (float)(*((float *)a1 + 13) - v14) / 20.0);
        }
        while ( v9 < v5 );
      }
    }
  }
  return 0;
}

//----- (000000000003CB88) ----------------------------------------------------
long double __fastcall limiter_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x48u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[8] = 0;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
  }
  return result;
}

//----- (000000000003CBE8) ----------------------------------------------------
__int64 __fastcall limiter_destroy(__int64 *a1)
{
  _QWORD *v1; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = (void *)v1[5];
  if ( v3 )
    free(v3);
  v4 = (void *)v1[6];
  v1[5] = 0;
  if ( v4 )
    free(v4);
  v5 = (void *)v1[7];
  v1[6] = 0;
  if ( v5 )
    free(v5);
  v1[7] = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003CC5C) ----------------------------------------------------
__int64 __fastcall limiter_reset(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 65) )
    return 9;
  v2 = *(void **)(a1 + 40);
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 48);
  *(_QWORD *)(a1 + 40) = 0;
  if ( v3 )
    free(v3);
  v4 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 48) = 0;
  if ( v4 )
    free(v4);
  result = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  return result;
}

//----- (000000000003CCCC) ----------------------------------------------------
__int64 __fastcall limiter_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 65) )
    return 9;
  sub_3CD08((int *)a1);
  return 0;
}

//----- (000000000003CD08) ----------------------------------------------------
void *__fastcall sub_3CD08(int *a1)
{
  int v1; // w8
  unsigned int v2; // s1
  __int64 v8; // x20
  float v10; // s0
  void *v11; // x0
  _OWORD *v12; // x8

  v1 = *a1;
  v2 = a1[1];
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 5) = _D0;
  v8 = (unsigned int)(32 * v1);
  a1[3] = 31 * v1;
  a1[4] = 0;
  v10 = powf(0.1, 1.0 / (float)(floorf((float)v2 * 0.016688) + 1.0));
  v11 = (void *)*((_QWORD *)a1 + 5);
  a1[8] = 1064188408;
  *((float *)a1 + 7) = v10;
  *((_BYTE *)a1 + 64) = 1;
  memset(v11, 0, 4 * v8);
  v12 = (_OWORD *)*((_QWORD *)a1 + 6);
  *v12 = 0u;
  v12[1] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  v12[4] = 0u;
  v12[5] = 0u;
  v12[6] = 0u;
  v12[7] = 0u;
  v12[8] = 0u;
  v12[9] = 0u;
  v12[10] = 0u;
  v12[11] = 0u;
  v12[12] = 0u;
  v12[13] = 0u;
  v12[14] = 0u;
  v12[15] = 0u;
  return memset(*((void **)a1 + 7), 0, 4LL * (unsigned int)((a1[2] + 31) * *a1));
}

//----- (000000000003CDE0) ----------------------------------------------------
__int64 __fastcall limiter_setup(__int64 a1, size_t n, int a3, int a4, float a5)
{
  int v5; // w20
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  __int64 v14; // x8
  size_t v15; // x20
  _OWORD *v16; // x0
  void *v17; // x0
  size_t v18; // x20
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v5 = n;
  if ( !(_DWORD)n )
    return 1;
  if ( !a3 )
    return 3;
  if ( !a4 )
    return 4;
  if ( *(_BYTE *)(a1 + 65) )
  {
    v10 = *(void **)(a1 + 40);
    if ( v10 )
      free(v10);
    v11 = *(void **)(a1 + 48);
    *(_QWORD *)(a1 + 40) = 0;
    if ( v11 )
      free(v11);
    v12 = *(void **)(a1 + 56);
    *(_QWORD *)(a1 + 48) = 0;
    if ( v12 )
      free(v12);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v13 = *(void **)(a1 + 40);
  v14 = (unsigned int)(32 * v5);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = a3;
  v15 = 4 * v14;
  *(_DWORD *)(a1 + 8) = a4;
  if ( !v13 )
  {
    v13 = malloc(4 * v14);
    *(_QWORD *)(a1 + 40) = v13;
    if ( !v13 )
      goto LABEL_28;
  }
  memset(v13, 0, v15);
  v16 = *(_OWORD **)(a1 + 48);
  if ( !v16 )
  {
    v16 = malloc(0x100u);
    *(_QWORD *)(a1 + 48) = v16;
    if ( !v16 )
      goto LABEL_28;
  }
  v16[14] = 0u;
  v16[15] = 0u;
  v16[12] = 0u;
  v16[13] = 0u;
  v16[10] = 0u;
  v16[11] = 0u;
  v16[8] = 0u;
  v16[9] = 0u;
  v16[6] = 0u;
  v16[7] = 0u;
  v16[4] = 0u;
  v16[5] = 0u;
  v16[2] = 0u;
  v16[3] = 0u;
  *v16 = 0u;
  v16[1] = 0u;
  v17 = *(void **)(a1 + 56);
  if ( v17 )
  {
    v18 = 4LL * (unsigned int)((*(_DWORD *)(a1 + 8) + 31) * *(_DWORD *)a1);
    goto LABEL_24;
  }
  v18 = 4LL * (unsigned int)((*(_DWORD *)(a1 + 8) + 31) * *(_DWORD *)a1);
  v17 = malloc(v18);
  *(_QWORD *)(a1 + 56) = v17;
  if ( !v17 )
LABEL_28:
    exit(1);
LABEL_24:
  memset(v17, 0, v18);
  sub_3CD08((int *)a1);
  result = 0xFFFFFFFFLL;
  *(_BYTE *)(a1 + 65) = 1;
  if ( a5 >= 0.0 && a5 <= 1.0 )
  {
    result = 0;
    *(float *)(a1 + 36) = a5;
  }
  return result;
}

//----- (000000000003CF84) ----------------------------------------------------
__int64 __fastcall limiter_update(__int64 a1, float a2)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 65) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 >= 0.0 && a2 <= 1.0 )
  {
    result = 0;
    *(float *)(a1 + 36) = a2;
  }
  return result;
}

//----- (000000000003CFD0) ----------------------------------------------------
__int64 __fastcall limiter_process(
        float *a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 v8; // x8
  float v9; // s1
  unsigned __int64 v10; // x9
  float v11; // s2
  float v12; // s2
  unsigned int v13; // w8
  __int64 v14; // x11
  __int64 v15; // x12
  unsigned int v16; // w4
  unsigned int v17; // w5
  float v18; // s3
  unsigned int v19; // w9
  unsigned int v20; // w10
  unsigned __int64 v21; // x16
  unsigned int v22; // w3
  unsigned int v23; // w5
  __int64 v24; // x6
  __int64 v25; // x7
  unsigned int v26; // w19
  int v27; // w20
  unsigned int v28; // w4
  float v29; // s3
  __int64 v30; // x6
  float v31; // s4
  float v32; // s5
  __int64 v33; // x4
  __int64 v34; // x4
  __int64 v35; // x5
  int v36; // w5
  float32x4_t v37; // q5
  __int64 v38; // x6
  float32x4_t *v39; // x7
  float32x4_t v40; // q6
  float32x4_t v41; // q7
  float32x4_t *v42; // x7
  __int64 v43; // x6
  float v44; // s5
  unsigned int v45; // w7

  if ( a1 )
  {
    if ( *((_BYTE *)a1 + 65) )
    {
      if ( *((_BYTE *)a1 + 64) )
      {
        v8 = *(unsigned int *)a1;
        v9 = a1[9];
        if ( (_DWORD)v8 )
        {
          v10 = 0;
          v9 = a1[9];
          do
          {
            v11 = *(float *)(a2 + 4 * v10++);
            v12 = fabsf(v11);
            if ( v12 > v9 )
              v9 = v12;
          }
          while ( v10 < v8 );
        }
        a1[6] = a1[9] / v9;
        *((_BYTE *)a1 + 64) = 0;
      }
      v13 = *((_DWORD *)a1 + 2);
      if ( v13 )
      {
        v14 = *(unsigned int *)a1;
        v15 = *((_QWORD *)a1 + 6);
        v16 = *((_DWORD *)a1 + 3);
        v17 = *((_DWORD *)a1 + 4);
        v18 = a1[9];
        v19 = 0;
        v20 = 0;
        v21 = v14 - 1;
        while ( 1 )
        {
          v22 = v17;
          v23 = v16 / (unsigned int)v14 + 32;
          if ( (_DWORD)v14 )
          {
            v24 = *((_QWORD *)a1 + 5);
            v25 = v14;
            v26 = v19;
            do
            {
              v27 = *(_DWORD *)(a2 + 4LL * v26++);
              *(_DWORD *)(v24 + 4LL * v16) = v27;
              if ( COERCE_FLOAT(v27 & 0x7FFFFFFF) > v18 )
                LODWORD(v18) = v27 & 0x7FFFFFFF;
              --v25;
              ++v16;
            }
            while ( v25 );
          }
          v28 = v23 >> 1;
          for ( *(float *)(v15 + 4LL * v23) = v18; v28; *(float *)(v15 + 4 * v30) = v29 )
          {
            v29 = fmaxf(*(float *)(v15 + 4LL * (v23 & 0xFFFFFFFE)), *(float *)(v15 + 4LL * (v23 | 1)));
            if ( v29 == *(float *)(v15 + 4LL * v28) )
              break;
            v30 = v28;
            v23 = v28;
            v28 >>= 1;
          }
          v18 = a1[9];
          v31 = a1[6];
          v32 = v18 / *(float *)(v15 + 4);
          if ( v32 < v31 )
            v32 = fminf(a1[5], (float)((float)(v32 * 10.0) - v31) / 9.0);
          a1[5] = v32;
          if ( v32 >= v31 )
            v33 = 7;
          else
            v33 = 8;
          *(float *)&a8 = (float)(v31 * a1[v33]) + (float)(v32 * (float)(1.0 - a1[v33]));
          a1[6] = *(float *)&a8;
          if ( !(_DWORD)v14 )
            goto LABEL_12;
          v34 = *((_QWORD *)a1 + 5);
          if ( (unsigned int)v14 > 7 )
          {
            v35 = 0;
            if ( ~v22 >= (unsigned int)v21
              && !HIDWORD(v21)
              && ~((unsigned int)v14 * v20) >= (unsigned int)v21
              && !HIDWORD(v21) )
            {
              v36 = 0;
              v37 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
              v38 = (unsigned int)v14 & 0xFFFFFFF8;
              do
              {
                v39 = (float32x4_t *)(v34 + 4LL * (v22 + v36));
                v40 = *v39;
                v41 = v39[1];
                v38 -= 8;
                v42 = (float32x4_t *)(a3 + 4LL * (v19 + v36));
                v36 += 8;
                *v42 = vmulq_f32(v37, v40);
                v42[1] = vmulq_f32(v37, v41);
              }
              while ( v38 );
              v35 = (unsigned int)v14 & 0xFFFFFFF8;
              if ( v35 == v14 )
                goto LABEL_12;
            }
          }
          else
          {
            v35 = 0;
          }
          v43 = v14 - v35;
          do
          {
            v44 = *(float *)(v34 + 4LL * (v22 + (unsigned int)v35));
            v45 = v19 + v35;
            --v43;
            LODWORD(v35) = v35 + 1;
            *(float *)(a3 + 4LL * v45) = *(float *)&a8 * v44;
          }
          while ( v43 );
LABEL_12:
          ++v20;
          v17 = (v22 + (unsigned int)v14) % (32 * (int)v14);
          v19 += v14;
          v16 = v22;
          if ( v20 >= v13 )
          {
            v13 = 0;
            *((_DWORD *)a1 + 3) = v22;
            *((_DWORD *)a1 + 4) = v17;
            return v13;
          }
        }
      }
    }
    else
    {
      return 9;
    }
  }
  else
  {
    return (unsigned int)-1;
  }
  return v13;
}

//----- (000000000003D23C) ----------------------------------------------------
__int64 __fastcall limiter_process_inplace(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  float v3; // s1
  unsigned __int64 v4; // x9
  float v5; // s2
  float v6; // s2
  unsigned int v7; // w8
  __int64 v8; // x11
  __int64 v9; // x12
  unsigned int v10; // w20
  unsigned int v11; // w21
  unsigned int v12; // w9
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x5
  unsigned int v15; // w10
  const float *v16; // x13
  unsigned __int64 v17; // x3
  __int64 v18; // x4
  float v19; // s3
  unsigned int v20; // w19
  unsigned int v21; // w21
  __int64 v22; // x22
  __int64 v23; // x23
  unsigned int v24; // w24
  __int64 v25; // x25
  float v26; // s4
  unsigned int v27; // w20
  float v28; // s3
  __int64 v29; // x22
  float v30; // s3
  float v31; // s4
  __int64 v32; // x20
  float v33; // s3
  __int64 v34; // x20
  int v35; // w22
  __int64 v36; // x21
  __int64 v37; // x22
  float v38; // s4
  unsigned int v39; // w23
  __int64 v40; // x21
  unsigned __int64 v41; // x25
  __int64 v42; // x22
  unsigned __int64 v43; // x24
  bool v44; // cf
  unsigned __int64 v45; // x26
  unsigned __int64 v46; // x21
  char v47; // w22
  bool v48; // w21
  bool v49; // w22
  float32x4_t v50; // q3
  int v51; // w21
  unsigned __int64 v52; // x22
  float32x4_t *v53; // x23
  float32x4_t v54; // q4
  float32x4_t v55; // q5
  float32x4_t *v56; // x23

  if ( a1 )
  {
    if ( *((_BYTE *)a1 + 65) )
    {
      if ( *((_BYTE *)a1 + 64) )
      {
        v2 = *a1;
        v3 = *((float *)a1 + 9);
        if ( (_DWORD)v2 )
        {
          v4 = 0;
          v3 = *((float *)a1 + 9);
          do
          {
            v5 = *(float *)(a2 + 4 * v4++);
            v6 = fabsf(v5);
            if ( v6 > v3 )
              v3 = v6;
          }
          while ( v4 < v2 );
        }
        *((float *)a1 + 6) = *((float *)a1 + 9) / v3;
        *((_BYTE *)a1 + 64) = 0;
      }
      v7 = a1[2];
      if ( v7 )
      {
        v8 = *a1;
        v9 = *((_QWORD *)a1 + 6);
        v10 = a1[3];
        v11 = a1[4];
        v12 = 0;
        v13 = v8 - 1;
        v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFF8LL;
        v15 = 0;
        v16 = (const float *)(a1 + 6);
        v17 = v8 - 2;
        v18 = a2 + 4 * (v8 - 1);
        while ( 1 )
        {
          v19 = *((float *)a1 + 9);
          v20 = v11;
          v21 = v10 / (unsigned int)v8 + 32;
          if ( (_DWORD)v8 )
          {
            v22 = *((_QWORD *)a1 + 5);
            v23 = v8;
            v24 = v12;
            do
            {
              v25 = 4LL * v24++;
              *(_DWORD *)(v22 + 4LL * v10++) = *(_DWORD *)(a2 + v25);
              v26 = fabsf(*(float *)(a2 + v25));
              if ( v26 > v19 )
                v19 = v26;
              --v23;
            }
            while ( v23 );
          }
          v27 = v21 >> 1;
          for ( *(float *)(v9 + 4LL * v21) = v19; v27; *(float *)(v9 + 4 * v29) = v28 )
          {
            v28 = fmaxf(*(float *)(v9 + 4LL * (v21 & 0xFFFFFFFE)), *(float *)(v9 + 4LL * (v21 | 1)));
            if ( v28 == *(float *)(v9 + 4LL * v27) )
              break;
            v29 = v27;
            v21 = v27;
            v27 >>= 1;
          }
          v30 = *((float *)a1 + 6);
          v31 = *((float *)a1 + 9) / *(float *)(v9 + 4);
          if ( v31 < v30 )
            v31 = fminf(*((float *)a1 + 5), (float)((float)(v31 * 10.0) - v30) / 9.0);
          *((float *)a1 + 5) = v31;
          if ( v31 >= v30 )
            v32 = 7;
          else
            v32 = 8;
          v33 = (float)(v30 * *(float *)&a1[v32]) + (float)(v31 * (float)(1.0 - *(float *)&a1[v32]));
          *((float *)a1 + 6) = v33;
          if ( !(_DWORD)v8 )
            goto LABEL_12;
          v34 = *((_QWORD *)a1 + 5);
          v35 = v8 * v15;
          *(float *)(a2 + 4LL * (unsigned int)v8 * v15) = v33 * *(float *)(v34 + 4LL * v20);
          if ( (_DWORD)v8 == 1 )
            goto LABEL_12;
          if ( v13 <= 7 || -2 - v35 < (unsigned int)v17 || HIDWORD(v17) || -2 - v20 < (unsigned int)v17 )
            goto LABEL_29;
          v36 = 1;
          if ( !HIDWORD(v17) )
            break;
LABEL_30:
          v37 = v8 - v36;
          do
          {
            v38 = *(float *)(v34 + 4LL * (v20 + (unsigned int)v36));
            v39 = v12 + v36;
            --v37;
            LODWORD(v36) = v36 + 1;
            *(float *)(a2 + 4LL * v39) = *v16 * v38;
          }
          while ( v37 );
LABEL_12:
          ++v15;
          v11 = (v20 + (unsigned int)v8) % (32 * (int)v8);
          v12 += v8;
          v10 = v20;
          if ( v15 >= v7 )
          {
            v7 = 0;
            a1[3] = v20;
            a1[4] = v11;
            return v7;
          }
        }
        v40 = 4LL * (unsigned int)(v35 + 1);
        v41 = v18 + v40;
        v42 = 4LL * (v20 + 1);
        v43 = a2 + v40;
        v44 = (unsigned __int64)v16 >= v18 + v40;
        v45 = v34 + v42;
        v46 = v34 + 4 * v13 + v42;
        v47 = !v44;
        v48 = v43 < v46;
        if ( ((unsigned __int8)v47 & ((unsigned __int64)a1 + 25 > v43)) == 0 )
        {
          v49 = v48 && v45 < v41;
          v36 = 1;
          if ( !v49 )
          {
            v50 = vld1q_dup_f32(v16);
            v51 = 1;
            v52 = (v8 - 1) & 0xFFFFFFFFFFFFFFF8LL;
            do
            {
              v53 = (float32x4_t *)(v34 + 4LL * (v20 + v51));
              v54 = *v53;
              v55 = v53[1];
              v52 -= 8LL;
              v56 = (float32x4_t *)(a2 + 4LL * (v12 + v51));
              v51 += 8;
              *v56 = vmulq_f32(v50, v54);
              v56[1] = vmulq_f32(v50, v55);
            }
            while ( v52 );
            v36 = v14 | 1;
            if ( v13 == v14 )
              goto LABEL_12;
          }
          goto LABEL_30;
        }
LABEL_29:
        v36 = 1;
        goto LABEL_30;
      }
    }
    else
    {
      return 9;
    }
  }
  else
  {
    return (unsigned int)-1;
  }
  return v7;
}

//----- (000000000003D548) ----------------------------------------------------
__int64 __fastcall limiter_bypass(__int64 a1, const void *a2, void *a3)
{
  size_t v5; // x21
  size_t v6; // x22
  char *v7; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 65) )
    return 9;
  v5 = 4LL * (unsigned int)(31 * *(_DWORD *)a1);
  v6 = 4LL * (unsigned int)(*(_DWORD *)(a1 + 8) * *(_DWORD *)a1);
  memcpy((void *)(*(_QWORD *)(a1 + 56) + v5), a2, v6);
  v7 = *(char **)(a1 + 56);
  memcpy(a3, v7, v6);
  memmove(v7, &v7[v6], v5);
  return 0;
}

//----- (000000000003D5E0) ----------------------------------------------------
__int64 __fastcall limiter_delay_sample_count(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 65) )
    return 9;
  result = 0;
  *a2 = 31;
  return result;
}

//----- (000000000003D60C) ----------------------------------------------------
void __fastcall hann_window(float32x4_t *a1, unsigned int a2, double a3)
{
  __int64 v4; // x20
  __int64 v5; // x21
  float v6; // s2
  uint32x4_t v7; // q0
  __int64 v13; // x22
  float32x4_t *v14; // x23
  int32x4_t v15; // q0
  int32x4_t v16; // q1
  float v17; // s0
  int32x4_t v18; // q1
  float v19; // s0
  int32x4_t v20; // q1
  float32x4_t v21; // q0
  float v22; // s0
  float32x4_t v23; // [xsp+0h] [xbp-B0h]
  float32x4_t v24; // [xsp+10h] [xbp-A0h]
  float32x4_t v25; // [xsp+20h] [xbp-90h]
  float v26; // [xsp+30h] [xbp-80h]
  int32x4_t v27; // [xsp+40h] [xbp-70h]
  float v28; // [xsp+50h] [xbp-60h]
  int32x4_t v29; // [xsp+50h] [xbp-60h]
  int32x4_t v30; // [xsp+50h] [xbp-60h]
  float32x4_t v31; // [xsp+60h] [xbp-50h]

  if ( a2 )
  {
    v4 = a2;
    v26 = (float)a2;
    if ( a2 <= 3 )
    {
      v5 = 0;
      v6 = (float)a2;
      do
      {
LABEL_7:
        v22 = cosf((float)((float)(unsigned int)v5 * 6.2832) / v6);
        v6 = v26;
        a1->n128_f32[v5++] = (float)(1.0 - v22) * 0.5;
      }
      while ( v4 != v5 );
      return;
    }
    *(float *)&a3 = (float)a2;
    v25 = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
    v7 = (uint32x4_t)xmmword_16940;
    v5 = a2 & 0xFFFFFFFC;
    v24 = vdupq_n_s32(0x40C90FDBu);
    __asm { FMOV            V1.4S, #1.0 }
    v13 = v5;
    v14 = a1;
    v23 = _Q1;
    do
    {
      v27 = v7;
      v31 = vdivq_f32(vmulq_f32(vcvtq_f32_u32(v7), v24), v25);
      v28 = cosf(v31.n128_f32[1]);
      v15.n128_f32[0] = cosf(v31.n128_f32[0]);
      v16 = v15;
      v16.n128_f32[1] = v28;
      v29 = v16;
      v17 = cosf(v31.n128_f32[2]);
      v18 = v29;
      v18.n128_f32[2] = v17;
      v30 = v18;
      v19 = cosf(v31.n128_f32[3]);
      v20 = v30;
      v13 -= 4;
      v20.n128_f32[3] = v19;
      v21 = vsubq_f32(v23, v20);
      v20.n128_u64[0] = 0x3F0000003F000000LL;
      v20.n128_u64[1] = 0x3F0000003F000000LL;
      *v14++ = vmulq_f32(v21, v20);
      v20.n128_u64[0] = 0x400000004LL;
      v20.n128_u64[1] = 0x400000004LL;
      v7 = vaddq_s32(v27, v20);
    }
    while ( v13 );
    v6 = v26;
    if ( v5 != v4 )
      goto LABEL_7;
  }
}
// 3D6B8: variable 'v15' is possibly undefined
// 16940: using guessed type __int128 xmmword_16940;

//----- (000000000003D784) ----------------------------------------------------
void __fastcall sine_window(int32x4_t *a1, unsigned int a2, double a3)
{
  __int64 v4; // x20
  __int64 v5; // x21
  float v6; // s2
  uint32x4_t v7; // q0
  __int64 v8; // x22
  int32x4_t *v9; // x23
  float32x4_t v10; // q1
  int32x4_t v11; // q0
  int32x4_t v12; // q1
  float v13; // s0
  int32x4_t v14; // q1
  float v15; // s0
  int32x4_t v16; // q1
  float v17; // s0
  float32x4_t v18; // [xsp+0h] [xbp-90h]
  float32x4_t v19; // [xsp+10h] [xbp-80h]
  float v20; // [xsp+20h] [xbp-70h]
  int32x4_t v21; // [xsp+30h] [xbp-60h]
  float v22; // [xsp+40h] [xbp-50h]
  int32x4_t v23; // [xsp+40h] [xbp-50h]
  int32x4_t v24; // [xsp+40h] [xbp-50h]
  float32x4_t v25; // [xsp+50h] [xbp-40h]

  if ( a2 )
  {
    v4 = a2;
    v20 = (float)a2;
    if ( a2 <= 3 )
    {
      v5 = 0;
      v6 = (float)a2;
      do
      {
LABEL_7:
        v17 = sinf((float)((float)((float)(unsigned int)v5 + 0.5) * 3.1416) / v6);
        v6 = v20;
        a1->n128_f32[v5++] = v17;
      }
      while ( v4 != v5 );
      return;
    }
    *(float *)&a3 = (float)a2;
    v19 = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
    v7 = (uint32x4_t)xmmword_16940;
    v5 = a2 & 0xFFFFFFFC;
    v8 = v5;
    v9 = a1;
    v18 = vdupq_n_s32(0x40490FDBu);
    do
    {
      v21 = v7;
      v10.n128_u64[0] = 0x3F0000003F000000LL;
      v10.n128_u64[1] = 0x3F0000003F000000LL;
      v25 = vdivq_f32(vmulq_f32(vaddq_f32(vcvtq_f32_u32(v7), v10), v18), v19);
      v22 = sinf(v25.n128_f32[1]);
      v11.n128_f32[0] = sinf(v25.n128_f32[0]);
      v12 = v11;
      v12.n128_f32[1] = v22;
      v23 = v12;
      v13 = sinf(v25.n128_f32[2]);
      v14 = v23;
      v14.n128_f32[2] = v13;
      v24 = v14;
      v15 = sinf(v25.n128_f32[3]);
      v16 = v24;
      v8 -= 4;
      v16.n128_f32[3] = v15;
      *v9++ = v16;
      v16.n128_u64[0] = 0x400000004LL;
      v16.n128_u64[1] = 0x400000004LL;
      v7 = vaddq_s32(v21, v16);
    }
    while ( v8 );
    v6 = v20;
    if ( v5 != v4 )
      goto LABEL_7;
  }
}
// 3D830: variable 'v11' is possibly undefined
// 16940: using guessed type __int128 xmmword_16940;

//----- (000000000003D8E4) ----------------------------------------------------
float __fastcall wrap_degree(float a1)
{
  float v1; // s0
  float v2; // s1

  v1 = fmodf(a1 + 3.1416, 6.2832);
  v2 = -3.1416;
  if ( v1 <= 0.0 )
    v2 = 3.1416;
  return v1 + v2;
}

//----- (000000000003D934) ----------------------------------------------------
__int64 __fastcall wrap_degree_with_magnitude(float *a1, float *a2, unsigned int a3)
{
  unsigned int v3; // w8
  __int64 i; // x9
  float v5; // s1
  float v6; // s0

  v3 = 0;
  if ( a3 )
  {
    for ( i = a3; i; --i )
    {
      v6 = 0.0;
      if ( *a2 == 0.0 )
        goto LABEL_6;
      v6 = *a1 - (float)(roundf(*a1 / 6.2832) * 6.2832);
      if ( v6 >= 3.1416 )
      {
        v5 = -6.2832;
      }
      else
      {
        if ( v6 > -3.1416 )
          goto LABEL_5;
        v5 = 6.2832;
      }
      v6 = v6 + v5;
LABEL_5:
      v3 = 1;
LABEL_6:
      *a1++ = v6;
      ++a2;
    }
  }
  return v3;
}

//----- (000000000003D9D0) ----------------------------------------------------
float __fastcall convert_frequency_to_absolute_value(float32x2_t *a1, unsigned __int64 *a2, unsigned int a3)
{
  unsigned __int64 v3; // d0
  unsigned int v4; // w8
  __int64 v5; // x9
  __int64 v6; // x10

  v3 = vabs_f32((float32x2_t)a1->n64_u64[0]).n64_u64[0];
  *a2 = v3;
  if ( a3 >= 3 )
  {
    v4 = 2;
    do
    {
      v5 = v4;
      v6 = v4 + 1;
      v4 += 2;
      *(float *)&v3 = sqrtf((float)(a1->n64_f32[v5] * a1->n64_f32[v5]) + (float)(a1->n64_f32[v6] * a1->n64_f32[v6]));
      *(_DWORD *)((char *)a2 + v6 * 4) = v3;
      *(_DWORD *)((char *)a2 + v5 * 4) = v3;
    }
    while ( v4 < a3 );
  }
  return *(float *)&v3;
}

//----- (000000000003DA28) ----------------------------------------------------
float __fastcall convert_frequency_to_absolute_value_real(float32x2_t *a1, unsigned __int64 *a2, unsigned int a3)
{
  unsigned __int64 v3; // d0
  unsigned int v4; // w8
  __int64 v5; // x9
  __int64 v6; // x10

  v3 = vabs_f32((float32x2_t)a1->n64_u64[0]).n64_u64[0];
  *a2 = v3;
  if ( a3 >= 3 )
  {
    v4 = 2;
    do
    {
      v5 = v4;
      v6 = v4 + 1;
      v4 += 2;
      *(float *)&v3 = sqrtf((float)(a1->n64_f32[v5] * a1->n64_f32[v5]) + (float)(a1->n64_f32[v6] * a1->n64_f32[v6]));
      *(_DWORD *)((char *)a2 + v5 * 4) = v3;
      *(_DWORD *)((char *)a2 + v6 * 4) = 0;
    }
    while ( v4 < a3 );
  }
  return *(float *)&v3;
}

//----- (000000000003DA80) ----------------------------------------------------
__int64 __fastcall greatest_common_divisor(int a1, int a2)
{
  __int64 result; // x0
  int v4; // w9

  result = 0;
  if ( a1 && a2 )
  {
    if ( a1 >= a2 )
      v4 = a2;
    else
      v4 = a1;
    if ( a1 < a2 )
      a1 = a2;
    do
    {
      result = (unsigned int)v4;
      v4 = a1 % v4;
      a1 = result;
    }
    while ( v4 );
  }
  return result;
}
// 3DA9C: conditional instruction was optimized away because w9.4!=0

//----- (000000000003DAC0) ----------------------------------------------------
__int64 __fastcall circular_buffer_create(_QWORD *a1)
{
  __int64 result; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x8

  if ( !a1 || *a1 )
    return 0xFFFFFFFFLL;
  v3 = malloc(0x18u);
  *a1 = v3;
  if ( !v3 )
    exit(1);
  v4 = v3;
  result = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  return result;
}

//----- (000000000003DB18) ----------------------------------------------------
__int64 __fastcall circular_buffer_destroy(void **a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  free(v2);
  result = 0;
  *a1 = 0;
  return result;
}

//----- (000000000003DB54) ----------------------------------------------------
__int64 __fastcall circular_buffer_init(__int64 a1, unsigned int a2)
{
  __int64 result; // x0
  void *v5; // x0

  result = 0xFFFFFFFFLL;
  if ( a1 && a2 )
  {
    if ( *(_QWORD *)(a1 + 16) )
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      v5 = malloc(4LL * a2);
      *(_QWORD *)(a1 + 16) = v5;
      if ( !v5 )
        exit(1);
      memset(v5, 0, 4LL * a2);
      result = 0;
      *(_DWORD *)(a1 + 8) = a2;
      *(_DWORD *)(a1 + 12) = 0;
    }
  }
  return result;
}

//----- (000000000003DBCC) ----------------------------------------------------
__int64 __fastcall circular_buffer_free(__int64 a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(void **)(a1 + 16);
  if ( !v2 )
    return 9;
  free(v2);
  result = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

//----- (000000000003DC10) ----------------------------------------------------
__int64 __fastcall circular_buffer_clear(__int64 a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(void **)(a1 + 16);
  if ( !v2 )
    return 9;
  memset(v2, 0, 4LL * *(unsigned int *)(a1 + 8));
  result = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (000000000003DC64) ----------------------------------------------------
__int64 __fastcall circular_buffer_enqueue(__int64 a1, float a2)
{
  __int64 v2; // x9
  int v4; // w10
  int v5; // w11
  __int64 result; // x0
  __int64 v7; // x12
  int v8; // w11
  int v9; // w9

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 16);
  if ( !v2 )
    return 9;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 == v4 )
    return 0xFFFFFFFFLL;
  v7 = *(unsigned int *)(a1 + 4);
  result = 0;
  v8 = v5 + 1;
  *(float *)(v2 + 4 * v7) = a2;
  if ( (_DWORD)v7 + 1 == v4 )
    v9 = 0;
  else
    v9 = v7 + 1;
  *(_DWORD *)(a1 + 4) = v9;
  *(_DWORD *)(a1 + 12) = v8;
  return result;
}

//----- (000000000003DCB8) ----------------------------------------------------
__int64 __fastcall circular_buffer_enqueueForce(unsigned int *a1, float a2)
{
  __int64 v2; // x10
  unsigned int v4; // w9
  unsigned int v5; // w11
  __int64 v6; // x11
  __int64 result; // x0
  unsigned int v8; // w10
  unsigned int v9; // w10
  unsigned int v10; // w9
  __int64 v11; // x12
  unsigned int v12; // w9
  unsigned int v13; // w10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *((_QWORD *)a1 + 2);
  if ( !v2 )
    return 9;
  v5 = a1[2];
  v4 = a1[3];
  if ( v4 == v5 )
  {
    v6 = *a1;
    result = 0;
    *(float *)(v2 + 4 * v6) = a2;
    v8 = a1[1];
    if ( v8 + 1 == v4 )
      v9 = 0;
    else
      v9 = v8 + 1;
    if ( (_DWORD)v6 + 1 == v4 )
      v10 = 0;
    else
      v10 = v6 + 1;
    *a1 = v10;
    a1[1] = v9;
  }
  else
  {
    v11 = a1[1];
    result = 0;
    v12 = v4 + 1;
    *(float *)(v2 + 4 * v11) = a2;
    if ( (_DWORD)v11 + 1 == v5 )
      v13 = 0;
    else
      v13 = v11 + 1;
    a1[1] = v13;
    a1[3] = v12;
  }
  return result;
}

//----- (000000000003DD3C) ----------------------------------------------------
__int64 __fastcall circular_buffer_dequeue(int *a1)
{
  int v2; // w9
  int v3; // w10
  int v4; // w11
  __int64 result; // x0
  int v6; // w9
  int v7; // w10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_QWORD *)a1 + 2) )
    return 9;
  v2 = a1[3];
  if ( !v2 )
    return 0xFFFFFFFFLL;
  v3 = *a1;
  v4 = a1[2];
  result = 0;
  v6 = v2 - 1;
  if ( v3 + 1 == v4 )
    v7 = 0;
  else
    v7 = v3 + 1;
  *a1 = v7;
  a1[3] = v6;
  return result;
}

//----- (000000000003DD8C) ----------------------------------------------------
__int64 __fastcall circular_buffer_dequeue_count(int *a1, unsigned int a2)
{
  unsigned int v3; // w9
  bool v4; // cf
  unsigned int v5; // w9
  __int64 result; // x0
  int v7; // w10
  unsigned int v8; // w11
  unsigned int v9; // w10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_QWORD *)a1 + 2) )
    return 9;
  v3 = a1[3];
  v4 = v3 >= a2;
  v5 = v3 - a2;
  if ( !v4 )
    return 0xFFFFFFFFLL;
  v7 = *a1;
  v8 = a1[2];
  result = 0;
  a1[3] = v5;
  v9 = v7 + a2;
  if ( v9 < v8 )
    v8 = 0;
  *a1 = v9 - v8;
  return result;
}

//----- (000000000003DDE0) ----------------------------------------------------
__int64 __fastcall circular_buffer_dequeue_data(unsigned int *a1, _DWORD *a2)
{
  __int64 v2; // x10
  unsigned int v4; // w9
  __int64 v5; // x11
  __int64 result; // x0
  unsigned int v7; // w10
  unsigned int v8; // w10

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *((_QWORD *)a1 + 2);
  if ( !v2 )
    return 9;
  v4 = a1[3];
  if ( !v4 )
    return 0xFFFFFFFFLL;
  v5 = *a1;
  result = 0;
  *a2 = *(_DWORD *)(v2 + 4 * v5);
  v7 = a1[2];
  a1[3] = v4 - 1;
  if ( (_DWORD)v5 + 1 == v7 )
    v8 = 0;
  else
    v8 = v5 + 1;
  *a1 = v8;
  return result;
}

//----- (000000000003DE38) ----------------------------------------------------
__int64 __fastcall circular_buffer_dequeue_data_count(int *a1, char *dest, unsigned int a3)
{
  __int64 v3; // x8
  __int64 result; // x0
  __int64 v7; // x9
  unsigned int v8; // w10
  int v10; // w8
  __int64 v11; // x10
  __int64 v12; // x22
  __int64 v13; // x23
  unsigned int v14; // w9

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = *((_QWORD *)a1 + 2);
  if ( !v3 )
    return 9;
  if ( a1[3] < a3 )
    return 0xFFFFFFFFLL;
  v7 = (unsigned int)*a1;
  v8 = a1[2];
  if ( (unsigned int)v7 + a3 >= v8 )
  {
    v11 = v8 - (unsigned int)v7;
    v12 = 4 * v11;
    v13 = a3 - (unsigned int)v11;
    memcpy(dest, (const void *)(v3 + 4 * v7), 4 * v11);
    memcpy(&dest[v12], *((const void **)a1 + 2), 4 * v13);
    v10 = a3 - a1[2] + *a1;
  }
  else
  {
    memcpy(dest, (const void *)(v3 + 4 * v7), 4LL * a3);
    v10 = *a1 + a3;
  }
  v14 = a1[3];
  result = 0;
  *a1 = v10;
  a1[3] = v14 - a3;
  return result;
}

//----- (000000000003DF18) ----------------------------------------------------
__int64 __fastcall circular_buffer_readFront(unsigned int *a1, char *dest, unsigned int a3)
{
  __int64 v3; // x8
  __int64 v6; // x9
  unsigned int v7; // w10
  const void *v9; // x1
  size_t v10; // x2
  char *v11; // x0
  __int64 v12; // x10
  __int64 v13; // x21
  __int64 v14; // x22

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = *((_QWORD *)a1 + 2);
  if ( !v3 )
    return 9;
  if ( a1[3] < a3 )
    return 0xFFFFFFFFLL;
  v6 = *a1;
  v7 = a1[2];
  if ( (unsigned int)v6 + a3 >= v7 )
  {
    v12 = v7 - (unsigned int)v6;
    v13 = 4 * v12;
    v14 = a3 - (unsigned int)v12;
    memcpy(dest, (const void *)(v3 + 4 * v6), 4 * v12);
    v9 = (const void *)*((_QWORD *)a1 + 2);
    v11 = &dest[v13];
    v10 = 4 * v14;
  }
  else
  {
    v9 = (const void *)(v3 + 4 * v6);
    v10 = 4LL * a3;
    v11 = dest;
  }
  memcpy(v11, v9, v10);
  return 0;
}

//----- (000000000003DFC0) ----------------------------------------------------
__int64 __fastcall circular_buffer_readBack(__int64 a1, _DWORD *a2, unsigned int a3)
{
  __int64 v3; // x8
  __int64 i; // x10
  __int64 v6; // x9

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 16);
  if ( !v3 )
    return 9;
  if ( *(_DWORD *)(a1 + 12) < a3 )
    return 0xFFFFFFFFLL;
  if ( a3 )
  {
    i = *(unsigned int *)(a1 + 4);
    v6 = a3;
    if ( *(_DWORD *)(a1 + 4) )
      goto LABEL_11;
LABEL_8:
    for ( i = (unsigned int)(*(_DWORD *)(a1 + 8) - 1); ; --i )
    {
      --v6;
      *a2++ = *(_DWORD *)(v3 + 4 * i);
      if ( !v6 )
        break;
      if ( i <= 0 )
        goto LABEL_8;
LABEL_11:
      ;
    }
  }
  return 0;
}

//----- (000000000003E02C) ----------------------------------------------------
__int64 __fastcall circular_buffer_readAll(unsigned int *a1, char *dest, _DWORD *a3)
{
  __int64 v3; // x8
  __int64 v5; // x9
  __int64 v7; // x10
  unsigned int v8; // w11
  const void *v9; // x1
  size_t v10; // x2
  char *v11; // x0
  __int64 v13; // x11
  __int64 v14; // x21
  __int64 v15; // x22

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = *((_QWORD *)a1 + 2);
  if ( !v3 )
    return 9;
  v5 = a1[3];
  *a3 = v5;
  v7 = *a1;
  v8 = a1[2];
  if ( (int)v7 + (int)v5 >= v8 )
  {
    v13 = v8 - (unsigned int)v7;
    v14 = 4 * v13;
    v15 = (unsigned int)(v5 - v13);
    memcpy(dest, (const void *)(v3 + 4 * v7), 4 * v13);
    v9 = (const void *)*((_QWORD *)a1 + 2);
    v11 = &dest[v14];
    v10 = 4 * v15;
  }
  else
  {
    v9 = (const void *)(v3 + 4 * v7);
    v10 = 4 * v5;
    v11 = dest;
  }
  memcpy(v11, v9, v10);
  return 0;
}

//----- (000000000003E0CC) ----------------------------------------------------
__int64 __fastcall circular_buffer_size(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 16) )
    return *(unsigned int *)(a1 + 12);
  return 9;
}

//----- (000000000003E0F0) ----------------------------------------------------
long double __fastcall loudness_measure_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0xB8u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[22] = 0;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)v2 = 0u;
  }
  return result;
}

//----- (000000000003E160) ----------------------------------------------------
__int64 __fastcall loudness_measure_destroy(void ***a1)
{
  void **v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_3E1A8(v2);
  result = (__int64)*a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003E1A8) ----------------------------------------------------
void __fastcall sub_3E1A8(void **a1)
{
  void **v2; // x20
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0

  v2 = a1 + 19;
  circular_buffer_free((__int64)a1[19]);
  circular_buffer_destroy(v2);
  circular_buffer_free((__int64)a1[20]);
  circular_buffer_destroy(a1 + 20);
  circular_buffer_free((__int64)a1[21]);
  circular_buffer_destroy(a1 + 21);
  circular_buffer_free((__int64)a1[22]);
  circular_buffer_destroy(a1 + 22);
  v3 = a1[15];
  if ( v3 )
  {
    free(v3);
    a1[15] = 0;
  }
  v4 = a1[16];
  if ( v4 )
  {
    free(v4);
    a1[16] = 0;
  }
  v5 = a1[11];
  if ( v5 )
  {
    free(v5);
    a1[11] = 0;
  }
  v6 = a1[12];
  if ( v6 )
  {
    free(v6);
    a1[12] = 0;
  }
  v7 = a1[13];
  if ( v7 )
  {
    free(v7);
    a1[13] = 0;
  }
  v8 = a1[14];
  if ( v8 )
  {
    free(v8);
    a1[14] = 0;
  }
  v9 = a1[17];
  if ( v9 )
  {
    free(v9);
    a1[17] = 0;
  }
  v10 = a1[18];
  if ( v10 )
  {
    free(v10);
    a1[18] = 0;
  }
}

//----- (000000000003E294) ----------------------------------------------------
__int64 __fastcall loudness_measure_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 48) )
    return 9;
  sub_3E2D0(a1);
  return 0;
}

//----- (000000000003E2D0) ----------------------------------------------------
__int64 __fastcall sub_3E2D0(__int64 a1)
{
  __int64 v1; // x8
  void *v3; // x0
  _QWORD *v4; // x8
  __int64 v5; // x8
  unsigned __int64 v6; // x8
  __int64 v7; // x9
  unsigned __int64 i; // x10
  _OWORD *v9; // x11
  unsigned __int64 v15; // x12
  float v16; // s9
  float v17; // s0
  unsigned int v18; // s1
  __int64 v19; // x0
  float v20; // s1
  float v21; // s0

  v1 = *(unsigned int *)(a1 + 16);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 52) = 0;
  *(_QWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v3 = *(void **)(a1 + 88);
  *(_DWORD *)(a1 + 28) = 9;
  memset(v3, 0, 4 * v1);
  v4 = *(_QWORD **)(a1 + 104);
  *v4 = 0;
  v4[1] = 0;
  v5 = *(_QWORD *)(a1 + 112);
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_DWORD *)(v5 + 80) = 0;
  memset(*(void **)(a1 + 120), 0, 0xB6Cu);
  memset(*(void **)(a1 + 128), 0, 0xB6Cu);
  v6 = *(unsigned int *)(a1 + 40);
  if ( (_DWORD)v6 )
  {
    v7 = *(_QWORD *)(a1 + 144);
    if ( (unsigned int)v6 <= 7 )
    {
      for ( i = 0; i < v6; ++i )
LABEL_7:
        *(_DWORD *)(v7 + 4 * i) = 1065353216;
      goto LABEL_8;
    }
    i = (unsigned int)v6 & 0xFFFFFFF8;
    v9 = (_OWORD *)(v7 + 16);
    __asm { FMOV            V0.4S, #1.0 }
    v15 = i;
    do
    {
      *(v9 - 1) = _Q0;
      *v9 = _Q0;
      v15 -= 8LL;
      v9 += 2;
    }
    while ( v15 );
    if ( i != v6 )
      goto LABEL_7;
  }
LABEL_8:
  v16 = (float)*(unsigned int *)(a1 + 4);
  *(float *)(a1 + 80) = powf(0.1, 1.0 / (float)((float)(v16 * 0.00043446) + 1.0));
  v17 = powf(0.1, 1.0 / (float)((float)(v16 * 0.00001) + 1.0));
  v18 = *(_DWORD *)(a1 + 8);
  *(float *)(a1 + 84) = v17;
  v19 = *(_QWORD *)(a1 + 152);
  v20 = (float)v18;
  v21 = (float)(v16 * 0.1) / v20;
  *(_DWORD *)(a1 + 44) = (unsigned int)v21;
  circular_buffer_init(v19, (unsigned int)(float)((float)(v21 + 1.0) * v20));
  circular_buffer_init(*(_QWORD *)(a1 + 160), 4u);
  circular_buffer_init(*(_QWORD *)(a1 + 168), 0x1Eu);
  return circular_buffer_init(*(_QWORD *)(a1 + 176), 0x1Eu);
}

//----- (000000000003E474) ----------------------------------------------------
__int64 __fastcall loudness_measure_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 48) )
    return 9;
  sub_3E1A8((void **)a1);
  result = 0;
  *(_BYTE *)(a1 + 48) = 0;
  return result;
}

//----- (000000000003E4BC) ----------------------------------------------------
__int64 __fastcall loudness_measure_setup(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        unsigned __int64 a5)
{
  __int64 result; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  size_t v14; // x20
  void *v15; // x0
  size_t v16; // x20
  _QWORD *v17; // x0
  _DWORD *v18; // x0
  void *v19; // x0
  size_t v20; // x20
  void *v21; // x0
  size_t v22; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  result = 1;
  if ( a2 <= 0xC && ((1 << a2) & 0x1166) != 0 )
  {
    if ( !a3 )
      return 3;
    if ( !a4 )
      return 4;
    if ( *(_BYTE *)(a1 + 48) )
      sub_3E1A8((void **)a1);
    *(_DWORD *)(a1 + 4) = a3;
    *(_DWORD *)(a1 + 8) = a4;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 40) = a5 / a4 + 20;
    *(uint32x2_t *)(a1 + 12) = vcvt_u32_f32(vmul_n_f32((float32x2_t)0x3ECCCCCD3DCCCCCDLL, (float)a3));
    circular_buffer_create((_QWORD *)(a1 + 152));
    circular_buffer_create((_QWORD *)(a1 + 160));
    circular_buffer_create((_QWORD *)(a1 + 168));
    circular_buffer_create((_QWORD *)(a1 + 176));
    v11 = *(void **)(a1 + 120);
    if ( v11 || (v11 = malloc(0xB6Cu), (*(_QWORD *)(a1 + 120) = v11) != 0) )
    {
      memset(v11, 0, 0xB6Cu);
      v12 = *(void **)(a1 + 128);
      if ( v12 || (v12 = malloc(0xB6Cu), (*(_QWORD *)(a1 + 128) = v12) != 0) )
      {
        memset(v12, 0, 0xB6Cu);
        v13 = *(void **)(a1 + 88);
        if ( v13 )
        {
          v14 = 4LL * *(unsigned int *)(a1 + 16);
        }
        else
        {
          v14 = 4LL * *(unsigned int *)(a1 + 16);
          v13 = malloc(v14);
          *(_QWORD *)(a1 + 88) = v13;
          if ( !v13 )
            goto LABEL_33;
        }
        memset(v13, 0, v14);
        v15 = *(void **)(a1 + 96);
        if ( v15 )
        {
          v16 = 4LL * *(unsigned int *)(a1 + 12);
        }
        else
        {
          v16 = 4LL * *(unsigned int *)(a1 + 12);
          v15 = malloc(v16);
          *(_QWORD *)(a1 + 96) = v15;
          if ( !v15 )
            goto LABEL_33;
        }
        memset(v15, 0, v16);
        v17 = *(_QWORD **)(a1 + 104);
        if ( v17 || (v17 = malloc(0x10u), (*(_QWORD *)(a1 + 104) = v17) != 0) )
        {
          *v17 = 0;
          v17[1] = 0;
          v18 = *(_DWORD **)(a1 + 112);
          if ( v18 || (v18 = malloc(0x54u), (*(_QWORD *)(a1 + 112) = v18) != 0) )
          {
            v18[20] = 0;
            *((_OWORD *)v18 + 3) = 0u;
            *((_OWORD *)v18 + 4) = 0u;
            *((_OWORD *)v18 + 1) = 0u;
            *((_OWORD *)v18 + 2) = 0u;
            *(_OWORD *)v18 = 0u;
            v19 = *(void **)(a1 + 136);
            if ( v19 )
            {
              v20 = 4LL * *(unsigned int *)(a1 + 40);
            }
            else
            {
              v20 = 4LL * *(unsigned int *)(a1 + 40);
              v19 = malloc(v20);
              *(_QWORD *)(a1 + 136) = v19;
              if ( !v19 )
                goto LABEL_33;
            }
            memset(v19, 0, v20);
            v21 = *(void **)(a1 + 144);
            if ( v21 )
            {
              v22 = 4LL * *(unsigned int *)(a1 + 40);
LABEL_31:
              memset(v21, 0, v22);
              sub_3E2D0(a1);
              result = 0;
              *(_BYTE *)(a1 + 48) = 1;
              return result;
            }
            v22 = 4LL * *(unsigned int *)(a1 + 40);
            v21 = malloc(v22);
            *(_QWORD *)(a1 + 144) = v21;
            if ( v21 )
              goto LABEL_31;
          }
        }
      }
    }
LABEL_33:
    exit(1);
  }
  return result;
}

//----- (000000000003E724) ----------------------------------------------------
__int64 __fastcall loudness_measure_process(unsigned int *a1, __int64 a2)
{
  __int64 v2; // x20
  float v4; // w8
  int v5; // w21
  unsigned __int64 v6; // x8
  float v7; // s0
  __int64 v8; // x0
  unsigned int v9; // w9
  unsigned __int64 v10; // x9
  float v11; // s1
  float v12; // s2
  __int64 result; // x0
  float v14; // s0
  float v15; // s1
  unsigned int v16; // w9
  unsigned int v17; // w0
  unsigned int v18; // w2
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x9
  float v21; // s0
  float v22; // s1
  float v23; // s1
  float v24; // s8
  float v25; // s0
  float v26; // s0
  float *v27; // x8
  float v28; // s0
  float v29; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 48) )
    return 9;
  v4 = *((float *)a1 + 2);
  a1[16] = 0;
  if ( v4 == 0.0 )
  {
    v14 = 0.0;
    v15 = 0.0;
  }
  else
  {
    v2 = a2;
    v5 = 0;
    v6 = *a1;
    if ( (_DWORD)v6 )
      goto LABEL_8;
LABEL_5:
    v7 = 0.0;
    while ( 1 )
    {
      v8 = *((_QWORD *)a1 + 19);
      *((float *)a1 + 16) = v7 + *((float *)a1 + 16);
      circular_buffer_enqueue(v8, v7);
      v9 = a1[2];
      if ( ++v5 >= v9 )
        break;
      v6 = *a1;
      if ( !(_DWORD)v6 )
        goto LABEL_5;
LABEL_8:
      v10 = 0;
      v7 = 0.0;
      do
      {
        v11 = channelWeightList[12 * v6 + v10];
        v12 = *(float *)(v2 + 4LL * (unsigned int)(v6 * v5 + v10++));
        v7 = v7 + (float)(v12 * (float)(v11 * v12));
      }
      while ( v10 < v6 );
    }
    v14 = *((float *)a1 + 16);
    v15 = (float)v9;
    v4 = v14;
  }
  v16 = a1[10];
  *((float *)a1 + 15) = *((float *)a1 + 15) + (float)(v14 / v15);
  if ( v16 > 0x14 )
    *(float *)(*((_QWORD *)a1 + 17) + 4LL * a1[5]) = v4;
  v17 = circular_buffer_size(*((_QWORD *)a1 + 19));
  v18 = a1[3];
  if ( v17 >= v18 )
  {
    circular_buffer_dequeue_data_count(*((int **)a1 + 19), *((char **)a1 + 11), v18);
    v19 = a1[3];
    if ( (_DWORD)v19 )
    {
      v20 = 0;
      v21 = 0.0;
      do
      {
        v22 = *(float *)(*((_QWORD *)a1 + 11) + 4 * v20++);
        v21 = v21 + v22;
      }
      while ( v20 < v19 );
      v23 = (float)(unsigned int)v19;
    }
    else
    {
      v21 = 0.0;
      v23 = 0.0;
    }
    v24 = v21 / v23;
    circular_buffer_enqueue(*((_QWORD *)a1 + 20), v21 / v23);
    circular_buffer_enqueue(*((_QWORD *)a1 + 21), v24);
  }
  if ( (unsigned int)circular_buffer_size(*((_QWORD *)a1 + 20)) == 4 )
  {
    circular_buffer_readFront(*((unsigned int **)a1 + 20), *((char **)a1 + 11), 4u);
    v25 = (float)((float)((float)((float)(**((float **)a1 + 11) + 0.0) + *(float *)(*((_QWORD *)a1 + 11) + 4LL))
                        + *(float *)(*((_QWORD *)a1 + 11) + 8LL))
                + *(float *)(*((_QWORD *)a1 + 11) + 12LL))
        * 0.25;
    if ( v25 <= 0.0 || (v26 = (float)(log10f(v25) * 10.0) + -0.691, v26 <= -70.0) )
      v2 = 0;
    else
      LODWORD(v2) = vcvtps_u32_f32((float)(v26 + 70.0) / 0.1);
    circular_buffer_dequeue(*((int **)a1 + 20));
    ++*(_DWORD *)(*((_QWORD *)a1 + 15) + 4 * v2);
  }
  if ( (unsigned int)circular_buffer_size(*((_QWORD *)a1 + 21)) == 30 )
  {
    circular_buffer_readFront(*((unsigned int **)a1 + 21), *((char **)a1 + 11), 0x1Eu);
    v27 = (float *)*((_QWORD *)a1 + 11);
    v28 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v27 + 0.0) + v27[1]) + v27[2]) + v27[3]) + v27[4]) + v27[5]) + v27[6]) + v27[7]) + v27[8]) + v27[9]) + v27[10]) + v27[11]) + v27[12]) + v27[13]) + v27[14]) + v27[15]) + v27[16]) + v27[17]) + v27[18])
                                                                                                + v27[19])
                                                                                        + v27[20])
                                                                                + v27[21])
                                                                        + v27[22])
                                                                + v27[23])
                                                        + v27[24])
                                                + v27[25])
                                        + v27[26])
                                + v27[27])
                        + v27[28])
                + v27[29])
        / 30.0;
    if ( v28 <= 0.0 || (v29 = (float)(log10f(v28) * 10.0) + -0.691, v29 <= -70.0) )
      v2 = 0;
    else
      LODWORD(v2) = vcvtps_u32_f32((float)(v29 + 70.0) / 0.1);
    circular_buffer_dequeue(*((int **)a1 + 21));
    ++*(_DWORD *)(*((_QWORD *)a1 + 16) + 4 * v2);
  }
  sub_3EAE8((__int64)a1);
  result = 0;
  ++a1[5];
  return result;
}
// 3E950: variable 'v2' is possibly undefined
// 17E1C: using guessed type float channelWeightList[156];

//----- (000000000003EAE8) ----------------------------------------------------
__int64 __fastcall sub_3EAE8(__int64 a1)
{
  unsigned int v1; // w8
  unsigned int *v3; // x0
  float v4; // s0
  unsigned int v5; // w8
  __int64 result; // x0
  __int64 v7; // x20
  float v8; // s0
  __int64 i; // x9
  unsigned int v10; // w10
  float v11; // s1
  float v12; // s0
  float v13; // s0
  unsigned int v14; // w9
  float v15; // s1
  float v16; // s0
  unsigned int v17; // w8
  __int64 v18; // x9
  unsigned int v19; // w10
  float v20; // s1

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 >= (unsigned int)(float)((float)((float)*(unsigned int *)(a1 + 4) * 0.52) / (float)*(unsigned int *)(a1 + 8)) )
  {
    v5 = *(_DWORD *)(a1 + 28);
    if ( v5 )
    {
      result = circular_buffer_enqueueForce(*(unsigned int **)(a1 + 176), *(float *)(a1 + 56));
      --*(_DWORD *)(a1 + 28);
      return result;
    }
    v7 = *(_QWORD *)(a1 + 120);
    v8 = 0.0;
    for ( i = 1; i != 731; ++i )
    {
      v10 = *(_DWORD *)(v7 + i * 4);
      v11 = histogramLookupTable[i];
      v5 += v10;
      v8 = v8 + (float)(v11 * (float)v10);
    }
    if ( !v5 )
    {
      v4 = *(float *)(a1 + 56);
      goto LABEL_18;
    }
    v12 = (float)(v8 * 0.1) / (float)v5;
    if ( v12 <= 0.0 || (v13 = (float)(log10f(v12) * 10.0) + -0.691, v13 <= -70.0) )
    {
      v14 = 0;
    }
    else
    {
      v14 = vcvtps_u32_f32((float)(v13 + 70.0) / 0.1);
      v15 = 0.0;
      v16 = 0.0;
      if ( v14 > 0x2DA )
      {
LABEL_16:
        v4 = v16 / v15;
        *(float *)(a1 + 56) = v4;
LABEL_18:
        v3 = *(unsigned int **)(a1 + 176);
        return circular_buffer_enqueueForce(v3, v4);
      }
    }
    v17 = 0;
    v18 = v14;
    v16 = 0.0;
    do
    {
      v19 = *(_DWORD *)(v7 + v18 * 4);
      v20 = histogramLookupTable[v18++];
      v17 += v19;
      v16 = v16 + (float)(v20 * (float)v19);
    }
    while ( v18 != 731 );
    v15 = (float)v17;
    goto LABEL_16;
  }
  v3 = *(unsigned int **)(a1 + 176);
  v4 = *(float *)(a1 + 60) / (float)((float)v1 + 0.00001);
  *(float *)(a1 + 56) = v4;
  return circular_buffer_enqueueForce(v3, v4);
}
// 1808C: using guessed type float histogramLookupTable[731];

//----- (000000000003ECA0) ----------------------------------------------------
float __fastcall loudness_measure_getIntegratedLoudnessWithEnergyWeighting(__int64 a1)
{
  unsigned int v2; // w11
  unsigned __int64 v3; // x9
  float v4; // s0
  float v5; // s1
  float v6; // s2
  unsigned int v8; // [xsp+4h] [xbp-1Ch] BYREF
  __int64 v9; // [xsp+8h] [xbp-18h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a1 )
    return -1.0;
  if ( !*(_BYTE *)(a1 + 48) )
    return 9.0;
  v8 = 0;
  circular_buffer_readAll(*(unsigned int **)(a1 + 176), *(char **)(a1 + 112), &v8);
  if ( !v8 )
    return -99.0;
  v2 = v8 - 1;
  v3 = 0;
  v4 = 0.0;
  do
  {
    v5 = kExponentialWeightTable[21 * v8 - 21 + v3];
    v6 = *(float *)(*(_QWORD *)(a1 + 112) + 4LL * v2);
    ++v3;
    --v2;
    v4 = v4 + (float)(v5 * v6);
  }
  while ( v3 < v8 );
  if ( v4 > 0.0 )
    return (float)(log10f(v4) * 10.0) + -0.691;
  else
    return -99.0;
}
// 17380: using guessed type float kExponentialWeightTable[441];

//----- (000000000003ED8C) ----------------------------------------------------
void __fastcall loudness_measure_getIntegratedLoudness(__int64 a1)
{
  __int64 v2; // x20
  unsigned int v3; // w8
  float v4; // s0
  __int64 i; // x9
  unsigned int v6; // w10
  float v7; // s1
  float v8; // s0
  float v9; // s0
  unsigned int v10; // w9
  float v11; // s1
  float v12; // s0
  unsigned int v13; // w8
  __int64 v14; // x9
  unsigned int v15; // w10
  float v16; // s1
  float v17; // s0

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 48) )
    {
      v2 = *(_QWORD *)(a1 + 120);
      v3 = 0;
      v4 = 0.0;
      for ( i = 4; i != 2924; i += 4 )
      {
        v6 = *(_DWORD *)(v2 + i);
        v7 = *(float *)((char *)&histogramLookupTable + i);
        v3 += v6;
        v4 = v4 + (float)(v7 * (float)v6);
      }
      if ( v3 )
      {
        v8 = (float)(v4 * 0.1) / (float)v3;
        if ( v8 <= 0.0 || (v9 = (float)(log10f(v8) * 10.0) + -0.691, v9 <= -70.0) )
        {
          v10 = 0;
        }
        else
        {
          v10 = vcvtps_u32_f32((float)(v9 + 70.0) / 0.1);
          v11 = 0.0;
          v12 = 0.0;
          if ( v10 > 0x2DA )
          {
LABEL_16:
            v17 = v12 / v11;
            *(float *)(a1 + 56) = v17;
            if ( v17 > 0.0 )
              log10f(v17);
            return;
          }
        }
        v13 = 0;
        v14 = 4LL * v10;
        v12 = 0.0;
        do
        {
          v15 = *(_DWORD *)(v2 + v14);
          v16 = *(float *)((char *)&histogramLookupTable + v14);
          v14 += 4;
          v13 += v15;
          v12 = v12 + (float)(v16 * (float)v15);
        }
        while ( v14 != 2924 );
        v11 = (float)v13;
        goto LABEL_16;
      }
    }
  }
}

//----- (000000000003EF0C) ----------------------------------------------------
float __fastcall loudness_measure_getInstantLoudness(__int64 a1)
{
  float result; // s0

  if ( !a1 )
    return -1.0;
  if ( !*(_BYTE *)(a1 + 48) )
    return 9.0;
  result = *(float *)(a1 + 64) / (float)*(unsigned int *)(a1 + 8);
  *(float *)(a1 + 64) = result;
  return result;
}

//----- (000000000003EF40) ----------------------------------------------------
void __fastcall loudness_measure_getLRA(__int64 a1)
{
  __int64 v2; // x21
  int v3; // w8
  float v4; // s0
  __int64 i; // x9
  unsigned int v6; // w10
  float v7; // s1
  float v8; // s0
  float v9; // s0
  float v10; // s0
  unsigned int v11; // w8
  int v12; // w10
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x10
  int32x4_t v15; // q0
  int32x4_t *v16; // x12
  unsigned __int64 v17; // x13
  int32x4_t v18; // q1
  int32x4_t v19; // q2
  int32x4_t v20; // q3
  bool v21; // zf
  int v22; // w11
  unsigned int v23; // w9
  int v24; // w10
  int v25; // w9
  int v26; // w11
  int v27; // w12
  int v28; // w10
  int v29; // w11
  int v30; // w12
  unsigned int v31; // w8
  unsigned int v32; // w21
  float v33; // s10
  float v34; // s0

  if ( !a1 )
    return;
  if ( !*(_BYTE *)(a1 + 48) )
    return;
  v2 = *(_QWORD *)(a1 + 128);
  v3 = 0;
  v4 = 0.0;
  for ( i = 1; i != 731; ++i )
  {
    v6 = *(_DWORD *)(v2 + i * 4);
    v7 = histogramLookupTable[i];
    v3 += v6;
    v4 = v4 + (float)(v7 * (float)v6);
  }
  *(_DWORD *)(a1 + 32) = v3;
  if ( !v3 )
    return;
  v8 = (float)(log10f(v4 / (float)v3) * 10.0) + -20.0;
  *(float *)(a1 + 68) = v8;
  v9 = powf(10.0, (float)(v8 + 0.691) / 10.0);
  if ( v9 <= 0.0 || (v10 = (float)(log10f(v9) * 10.0) + -0.691, v10 <= -70.0) )
  {
    v11 = 0;
  }
  else
  {
    v11 = vcvtps_u32_f32((float)(v10 + 70.0) / 0.1);
    if ( v11 > 0x2DA )
    {
      v12 = 0;
      goto LABEL_20;
    }
  }
  v13 = v11;
  v14 = 731LL - v11;
  if ( v14 > 7 )
  {
    v15 = 0u;
    v13 = (v14 & 0xFFFFFFFFFFFFFFF8LL) + v11;
    v16 = (int32x4_t *)(v2 + 4LL * v11 + 16);
    v17 = v14 & 0xFFFFFFFFFFFFFFF8LL;
    v18 = 0u;
    do
    {
      v19 = v16[-1];
      v20 = *v16;
      v17 -= 8LL;
      v16 += 2;
      v15 = vaddq_s32(v19, v15);
      v18 = vaddq_s32(v20, v18);
    }
    while ( v17 );
    v21 = v14 == (v14 & 0xFFFFFFFFFFFFFFF8LL);
    v12 = vaddvq_s32(vaddq_s32(v18, v15));
    if ( v21 )
      goto LABEL_20;
  }
  else
  {
    v12 = 0;
  }
  do
  {
    v22 = *(_DWORD *)(v2 + 4 * v13++);
    v12 += v22;
  }
  while ( v13 != 731 );
LABEL_20:
  *(_DWORD *)(a1 + 36) = v12;
  v23 = v12 - 1;
  v24 = vcvtas_u32_f32((float)((float)(unsigned int)(v12 - 1) * 0.1) + 1.0);
  v25 = vcvtas_u32_f32((float)((float)v23 * 0.95) + 1.0);
  v26 = 0;
  if ( v24 >= 1 )
  {
    do
    {
      v27 = *(_DWORD *)(v2 + 4LL * (v11 + v26++));
      v24 -= v27;
    }
    while ( v24 > 0 );
  }
  v28 = v26 + v11;
  v29 = 0;
  if ( v25 >= 1 )
  {
    do
    {
      v30 = *(_DWORD *)(v2 + 4LL * (v11 + v29++));
      v25 -= v30;
    }
    while ( v25 > 0 );
  }
  v31 = v29 + v11;
  if ( v31 >= 0x2DA )
    v32 = 730;
  else
    v32 = v31;
  v33 = (float)(log10f(histogramLookupTable[v28]) * 10.0) + -0.691;
  v34 = histogramLookupTable[v32];
  *(float *)(a1 + 72) = v33;
  *(float *)(a1 + 76) = (float)(log10f(v34) * 10.0) + -0.691;
}
// 1808C: using guessed type float histogramLookupTable[731];

//----- (000000000003F1D0) ----------------------------------------------------
__int64 __fastcall loudness_measure_getFramewiseGainArray(__int64 a1, float *a2, float a3)
{
  __int64 result; // x0
  int v6; // w26
  float v7; // s15
  float v8; // s0
  float v9; // s0
  unsigned __int64 v10; // x28
  float v11; // s13
  float v12; // s9
  int v13; // w23
  int v14; // w24
  _DWORD *v15; // x25
  __int64 v16; // x27
  float v17; // s14
  unsigned __int64 v18; // x26
  float v19; // s15
  float v20; // s13
  float v21; // s11
  float v22; // s0
  int v23; // w8
  float v24; // s0
  float v25; // s2
  float v26; // s1
  float v27; // s2
  float v28; // s0
  float v29; // s1
  float v30; // s0
  __int64 v31; // x8
  __int64 v32; // x9
  __int64 v33; // x8
  __int64 v34; // x23
  _DWORD *v35; // x9
  unsigned __int64 v36; // x24
  unsigned __int64 v37; // x23
  unsigned int v38; // w8
  __int64 v39; // x24
  float v40; // s0
  int v41; // w8
  float v42; // s0
  unsigned __int64 v43; // x9
  unsigned __int64 v44; // x10
  unsigned __int64 v45; // x8
  __int64 v46; // x10
  float *v47; // x9
  float *v48; // x10
  float v49; // t1
  unsigned __int64 v50; // x28
  unsigned int v51; // w23
  __int64 v52; // x8
  float v53; // s0
  unsigned int v54; // w0
  unsigned int v55; // w2
  __int64 v56; // x8
  float *v57; // x9
  float v58; // s0
  float v59; // t1
  float v60; // s11
  float v61; // s0
  float v62; // s0
  unsigned int v63; // w23
  float *v64; // x8
  float v65; // s0
  float v66; // s0
  float32x4_t *v67; // x14
  float32x4_t *v68; // x12
  unsigned __int64 v69; // x13
  float32x4_t v70; // q0
  float32x4_t v71; // q1
  float32x4_t v72; // q1
  float v73; // [xsp+18h] [xbp-D8h]
  float v74; // [xsp+1Ch] [xbp-D4h]
  float v75; // [xsp+20h] [xbp-D0h]
  int v76; // [xsp+24h] [xbp-CCh]
  _DWORD base[4]; // [xsp+30h] [xbp-C0h] BYREF
  float v79; // [xsp+40h] [xbp-B0h]
  float v80; // [xsp+44h] [xbp-ACh]
  int v81; // [xsp+48h] [xbp-A8h]
  int v82; // [xsp+4Ch] [xbp-A4h]
  int v83; // [xsp+50h] [xbp-A0h]
  int v84; // [xsp+54h] [xbp-9Ch]
  __int64 v85; // [xsp+58h] [xbp-98h]

  v85 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 48) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 && *(_DWORD *)(a1 + 40) != 20 )
  {
    loudness_measure_getLRA(a1);
    v6 = 0;
    v7 = 0.25;
    v73 = a3 + -0.15;
    v74 = a3;
    if ( v8 <= a3 )
      return 0;
    while ( 1 )
    {
      loudness_measure_getLRA(a1);
      v10 = *(unsigned int *)(a1 + 20);
      v11 = v9;
      if ( (_DWORD)v10 )
      {
        v76 = v6;
        v12 = *(float *)(a1 + 72);
        v13 = *(_DWORD *)(a1 + 32);
        v14 = *(_DWORD *)(a1 + 36);
        v16 = *(_QWORD *)(a1 + 136);
        v15 = *(_DWORD **)(a1 + 144);
        v17 = v73 - v9;
        v18 = 0;
        v75 = v9;
        v19 = -(float)(v73 - v9);
        v20 = (float)*(unsigned int *)(a1 + 8);
        v21 = 1.0;
        while ( 1 )
        {
          v24 = log10f(*(float *)(v16 + 4 * v18) / v20) * 10.0;
          if ( v13 == v14 )
          {
            v25 = *(float *)(a1 + 68);
            if ( v24 > v25 )
            {
              v26 = *(float *)(a1 + 76);
              v27 = v17 / (float)((float)(v26 - v25) + 0.00001);
              v28 = v24 - v26;
LABEL_20:
              v29 = v28 * v27;
              goto LABEL_21;
            }
          }
          else
          {
            if ( v24 > v12 )
            {
              v29 = (float)(v24 - *(float *)(a1 + 76))
                  * (float)(v17 / (float)((float)(*(float *)(a1 + 76) - *(float *)(a1 + 72)) + 0.00001));
              goto LABEL_21;
            }
            v25 = *(float *)(a1 + 68);
            v29 = v19;
            if ( v24 > v25 )
              goto LABEL_21;
          }
          v29 = 0.0;
          if ( v24 > -70.0 )
          {
            v27 = v19 / (float)((float)(v25 + 70.0) + 0.00001);
            v28 = v24 + 70.0;
            goto LABEL_20;
          }
LABEL_21:
          v30 = fmaxf(powf(10.0, v29 / 20.0), 0.00031623);
          if ( v30 != INFINITY )
          {
            v31 = 84;
            if ( v30 > v21 )
              v31 = 80;
            v21 = (float)(v21 * *(float *)(a1 + v31)) + (float)(v30 * (float)(1.0 - *(float *)(a1 + v31)));
          }
          v22 = log10f(v21);
          v23 = v18++ + 5;
          *(float *)&v15[v23] = v22 * 20.0;
          if ( v18 >= v10 )
          {
            a3 = v74;
            v11 = v75;
            v6 = v76;
            v7 = 0.25;
            goto LABEL_27;
          }
        }
      }
      v15 = *(_DWORD **)(a1 + 144);
LABEL_27:
      v32 = (unsigned int)(v10 - 1);
      *v15 = v15[5];
      v15[v10] = v15[v32];
      v15[1] = v15[5];
      v15[(unsigned int)(v10 + 1)] = v15[v32];
      v15[2] = v15[5];
      v15[(unsigned int)(v10 + 2)] = v15[v32];
      v15[3] = v15[5];
      v15[(unsigned int)(v10 + 3)] = v15[v32];
      v15[4] = v15[5];
      v15[(unsigned int)(v10 + 4)] = v15[v32];
      if ( (_DWORD)v10 )
      {
        v33 = 0;
        do
        {
          v34 = v33;
          v35 = &v15[v33];
          base[0] = *v35;
          v36 = v33 + 1;
          base[1] = v35[1];
          base[2] = v15[(unsigned int)(v33 + 2)];
          base[3] = v15[(unsigned int)(v33 + 3)];
          v79 = *(float *)&v15[(unsigned int)(v33 + 4)];
          v80 = *(float *)&v15[(unsigned int)(v33 + 5)];
          v81 = v15[(unsigned int)(v33 + 6)];
          v82 = v15[(unsigned int)(v33 + 7)];
          v83 = v15[(unsigned int)(v33 + 8)];
          v84 = v15[(unsigned int)(v33 + 9)];
          qsort(base, 0xAu, 4u, (__compar_fn_t)sub_3F9E8);
          v15 = *(_DWORD **)(a1 + 144);
          v33 = v36;
          *(float *)&v15[v34] = (float)(v79 + v80) * 0.5;
          v37 = *(unsigned int *)(a1 + 20);
        }
        while ( v36 < v37 );
        v38 = v37 - 2;
        if ( (_DWORD)v37 == 2 )
        {
          LODWORD(v37) = 2;
          goto LABEL_35;
        }
      }
      else
      {
        LODWORD(v37) = 0;
        v38 = -2;
      }
      v39 = v38;
      do
      {
        v40 = powf(10.0, *(float *)&v15[v39] / 20.0);
        v41 = v39-- + 1;
        *(float *)&v15[v41] = v40;
      }
      while ( (_DWORD)v39 );
LABEL_35:
      v42 = powf(10.0, *(float *)v15 / 20.0);
      *(float *)v15 = v42;
      *((float *)v15 + 1) = v42;
      if ( !(_DWORD)v37 )
        goto LABEL_43;
      *a2 = v42 * *a2;
      if ( (_DWORD)v37 == 1 )
        goto LABEL_43;
      v43 = (unsigned int)v37 - 1LL;
      if ( v43 > 7 && (a2 + 1 >= (float *)&v15[(unsigned int)v37] || v15 + 1 >= (_DWORD *)&a2[(unsigned int)v37]) )
      {
        v67 = (float32x4_t *)(a2 + 5);
        v44 = v43 & 0xFFFFFFFFFFFFFFF8LL | 1;
        v68 = (float32x4_t *)(v15 + 5);
        v69 = v43 & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v70 = v68[-1];
          v71 = *v68;
          v68 += 2;
          v69 -= 8LL;
          v72 = vmulq_f32(v71, *v67);
          v67[-1] = vmulq_f32(v70, v67[-1]);
          *v67 = v72;
          v67 += 2;
        }
        while ( v69 );
        if ( v43 == (v43 & 0xFFFFFFFFFFFFFFF8LL) )
          goto LABEL_43;
      }
      else
      {
        v44 = 1;
      }
      v45 = (unsigned int)v37 - v44;
      v46 = v44;
      v47 = &a2[v46];
      v48 = (float *)&v15[v46];
      do
      {
        v49 = *v48++;
        --v45;
        *v47 = v49 * *v47;
        ++v47;
      }
      while ( v45 );
LABEL_43:
      circular_buffer_clear(*(_QWORD *)(a1 + 176));
      circular_buffer_clear(*(_QWORD *)(a1 + 152));
      circular_buffer_clear(*(_QWORD *)(a1 + 160));
      circular_buffer_clear(*(_QWORD *)(a1 + 168));
      memset(*(void **)(a1 + 120), 0, 0xB6Cu);
      memset(*(void **)(a1 + 128), 0, 0xB6Cu);
      if ( *(_DWORD *)(a1 + 20) )
      {
        v50 = 0;
        do
        {
          v52 = *(_QWORD *)(a1 + 136);
          v53 = *(float *)&v15[v50] * (float)(*(float *)(v52 + 4 * v50) * *(float *)&v15[v50]);
          *(float *)(v52 + 4 * v50) = v53;
          circular_buffer_enqueue(*(_QWORD *)(a1 + 152), v53);
          v54 = circular_buffer_size(*(_QWORD *)(a1 + 152));
          v55 = *(_DWORD *)(a1 + 44);
          if ( v54 >= v55 )
          {
            circular_buffer_readFront(*(unsigned int **)(a1 + 152), *(char **)(a1 + 88), v55);
            v56 = *(unsigned int *)(a1 + 44);
            if ( (_DWORD)v56 )
            {
              v57 = *(float **)(a1 + 88);
              v58 = 0.0;
              do
              {
                v59 = *v57++;
                --v56;
                v58 = v58 + v59;
              }
              while ( v56 );
            }
            else
            {
              v58 = 0.0;
            }
            v60 = v58 / (float)*(unsigned int *)(a1 + 12);
            circular_buffer_enqueue(*(_QWORD *)(a1 + 160), v60);
            circular_buffer_enqueue(*(_QWORD *)(a1 + 168), v60);
            circular_buffer_dequeue(*(int **)(a1 + 152));
          }
          if ( (unsigned int)circular_buffer_size(*(_QWORD *)(a1 + 160)) == 4 )
          {
            circular_buffer_readFront(*(unsigned int **)(a1 + 160), *(char **)(a1 + 88), 4u);
            v61 = (float)((float)((float)((float)(**(float **)(a1 + 88) + 0.0) + *(float *)(*(_QWORD *)(a1 + 88) + 4LL))
                                + *(float *)(*(_QWORD *)(a1 + 88) + 8LL))
                        + *(float *)(*(_QWORD *)(a1 + 88) + 12LL))
                * v7;
            if ( v61 <= 0.0 || (v62 = (float)(log10f(v61) * 10.0) + -0.691, v62 <= -70.0) )
              v63 = 0;
            else
              v63 = vcvtps_u32_f32((float)(v62 + 70.0) / 0.1);
            circular_buffer_dequeue(*(int **)(a1 + 160));
            ++*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4LL * v63);
          }
          if ( (unsigned int)circular_buffer_size(*(_QWORD *)(a1 + 168)) == 30 )
          {
            circular_buffer_readFront(*(unsigned int **)(a1 + 168), *(char **)(a1 + 88), 0x1Eu);
            v64 = *(float **)(a1 + 88);
            v65 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v64 + 0.0) + v64[1]) + v64[2]) + v64[3]) + v64[4]) + v64[5]) + v64[6]) + v64[7]) + v64[8]) + v64[9]) + v64[10]) + v64[11]) + v64[12]) + v64[13]) + v64[14]) + v64[15]) + v64[16]) + v64[17]) + v64[18]) + v64[19])
                                                                                                + v64[20])
                                                                                        + v64[21])
                                                                                + v64[22])
                                                                        + v64[23])
                                                                + v64[24])
                                                        + v64[25])
                                                + v64[26])
                                        + v64[27])
                                + v64[28])
                        + v64[29])
                / 30.0;
            if ( v65 <= 0.0 || (v66 = (float)(log10f(v65) * 10.0) + -0.691, v66 <= -70.0) )
              v51 = 0;
            else
              v51 = vcvtps_u32_f32((float)(v66 + 70.0) / 0.1);
            circular_buffer_dequeue(*(int **)(a1 + 168));
            ++*(_DWORD *)(*(_QWORD *)(a1 + 128) + 4LL * v51);
          }
          ++v50;
        }
        while ( v50 < *(unsigned int *)(a1 + 20) );
      }
      sub_3EAE8(a1);
      if ( ++v6 == 6 || v11 <= a3 )
        return 0;
    }
  }
  return result;
}
// 3F2A0: variable 'v8' is possibly undefined
// 3F2D4: variable 'v9' is possibly undefined

//----- (000000000003F9E8) ----------------------------------------------------
__int64 __fastcall sub_3F9E8(float *a1, float *a2)
{
  return (unsigned int)(int)(float)(*a1 - *a2);
}

//----- (000000000003F9FC) ----------------------------------------------------
__int64 __fastcall loudness_measure_get_frameLength(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 48) )
    return *(unsigned int *)(a1 + 40);
  return 9;
}

//----- (000000000003FA20) ----------------------------------------------------
__int64 __fastcall peak_setup(__int64 a1, unsigned int a2, unsigned int a3, int a4, int a5)
{
  double v5; // x29
  double v6; // x30
  double v10; // d2
  int v11; // s0
  int v12; // s1
  double cosx; // [xsp+8h] [xbp-38h] BYREF
  double sinx[5]; // [xsp+18h] [xbp-28h] BYREF

  if ( !a1 || !a3 || a5 != 2 )
    return 0xFFFFFFFFLL;
  sinx[3] = v5;
  sinx[4] = v6;
  sincos((float)(200.0 / (float)a3) * 3.14159265, sinx, &cosx);
  v10 = sinx[0] * 0.5 + 1.0;
  *(float *)&v11 = cosx * -2.0 * (1.0 / v10);
  *(float *)&v12 = (1.0 - sinx[0] * 0.5) * (1.0 / v10);
  *(float *)&v10 = v10 * (1.0 / v10);
  iir_wrapper_coeffs = 1065353216;
  dword_78ABC = v11;
  dword_78AC0 = v12;
  dword_78AC4 = LODWORD(v10);
  dword_78AC8 = v11;
  dword_78ACC = v12;
  return iir_setup(a1, a2, a4, 2, (float *)&iir_wrapper_coeffs, (float *)&dword_78AC4);
}
// 3FA3C: variable 'v5' is possibly undefined
// 3FA3C: variable 'v6' is possibly undefined
// 78AB8: using guessed type int iir_wrapper_coeffs;
// 78ABC: using guessed type int dword_78ABC;
// 78AC0: using guessed type int dword_78AC0;
// 78AC4: using guessed type int dword_78AC4;
// 78AC8: using guessed type int dword_78AC8;
// 78ACC: using guessed type int dword_78ACC;

//----- (000000000003FB08) ----------------------------------------------------
__int64 __fastcall peak_update(__int64 a1, unsigned int a2, int a3, float a4, float a5, float a6)
{
  int v7; // w8
  __int64 result; // x0
  double v13; // d9
  double v14; // d1
  double v15; // d2
  double v16; // d1
  double v17; // d3
  int v18; // s0
  int v19; // s4
  double v20; // d0
  double v21; // d10
  double v22; // d0
  double v23; // d3
  double v24; // d2
  double v25; // d5
  double v26; // d0
  double v27; // d3
  double v28; // d1
  double v29; // d5
  int v30; // s2
  double v31; // d6
  double v32; // d1
  double v33; // d0
  int v34; // s4
  int v35; // s3
  int v36; // s2
  double v37; // [xsp+0h] [xbp-40h] BYREF
  double sinx; // [xsp+8h] [xbp-38h] BYREF

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    return 9;
  v7 = *(_DWORD *)(a1 + 12);
  result = 0xFFFFFFFFLL;
  if ( v7 == 2 && a2 && a6 <= 30.0 && a6 >= 0.0 && a5 <= 22000.0 && a4 >= -60.0 && a4 <= 60.0 && a5 >= 1.0 )
  {
    if ( a3 == 1 )
    {
      v21 = tan(a5 * 3.14159265 / (double)a2);
      v22 = pow(10.0, a4 / 20.0);
      v23 = 1.0 / a6;
      v24 = v21 * v21;
      if ( a4 >= 0.0 )
      {
        v31 = v22 * v23 * v21 + 1.0;
        v32 = 1.0 / (v24 + v23 * v21 + 1.0);
        v33 = v24 + 1.0 - v23 * (v22 * v21);
        *(float *)&v34 = (v24 + 1.0 - v23 * v21) * v32;
        *(float *)&v35 = (v24 + v31) * v32;
        *(float *)&v36 = (v24 + -1.0) * (v32 + v32);
        iir_wrapper_coeffs = 1065353216;
        dword_78ABC = v36;
        dword_78AC0 = v34;
        dword_78AC4 = v35;
        dword_78AC8 = v36;
        v20 = v32 * v33;
      }
      else
      {
        v25 = v23 * v21;
        v26 = v23 * (1.0 / v22 * v21);
        v27 = v24 + v23 * v21 + 1.0;
        v28 = 1.0 / (v24 + v26 + 1.0);
        v29 = v24 + 1.0 - v25;
        *(float *)&v26 = (v24 + 1.0 - v26) * v28;
        *(float *)&v30 = (v24 + -1.0) * (v28 + v28);
        *(float *)&v27 = v27 * v28;
        dword_78ABC = v30;
        dword_78AC0 = LODWORD(v26);
        v20 = v29 * v28;
        iir_wrapper_coeffs = 1065353216;
        dword_78AC4 = LODWORD(v27);
        dword_78AC8 = v30;
      }
      goto LABEL_20;
    }
    if ( !a3 )
    {
      v13 = pow(10.0, a4 * 0.025);
      sincos((float)((float)(a5 + a5) / (float)a2) * 3.14159265, &sinx, &v37);
      v14 = sinx / (float)(a6 + a6);
      v15 = v14 / v13;
      v16 = v13 * v14;
      v17 = 1.0 / (v15 + 1.0);
      *(float *)&v18 = v37 * -2.0 * v17;
      *(float *)&v15 = (1.0 - v15) * v17;
      *(float *)&v19 = (v16 + 1.0) * v17;
      iir_wrapper_coeffs = 1065353216;
      dword_78ABC = v18;
      dword_78AC0 = LODWORD(v15);
      dword_78AC4 = v19;
      dword_78AC8 = v18;
      v20 = (1.0 - v16) * v17;
LABEL_20:
      *(float *)&v20 = v20;
      dword_78ACC = LODWORD(v20);
      return iir_update(a1, (float *)&iir_wrapper_coeffs, (float *)&dword_78AC4, v20);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 78AB8: using guessed type int iir_wrapper_coeffs;
// 78ABC: using guessed type int dword_78ABC;
// 78AC0: using guessed type int dword_78AC0;
// 78AC4: using guessed type int dword_78AC4;
// 78AC8: using guessed type int dword_78AC8;
// 78ACC: using guessed type int dword_78ACC;

//----- (000000000003FDF0) ----------------------------------------------------
long double __fastcall reverb_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x48u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[8] = 0;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
  }
  return result;
}

//----- (000000000003FE50) ----------------------------------------------------
__int64 __fastcall reverb_destroy(__int64 *a1)
{
  _QWORD *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_3FE98(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (000000000003FE98) ----------------------------------------------------
void __fastcall sub_3FE98(_QWORD *a1)
{
  __int64 *v2; // x0
  void *v3; // x0
  __int64 *v4; // x0
  void *v5; // x0
  __int64 *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0

  v2 = (__int64 *)a1[6];
  if ( v2 )
  {
    allpass_destroy(v2);
    allpass_destroy((__int64 *)(a1[6] + 8LL));
    allpass_destroy((__int64 *)(a1[6] + 16LL));
    allpass_destroy((__int64 *)(a1[6] + 24LL));
    v3 = (void *)a1[6];
    if ( v3 )
    {
      free(v3);
      a1[6] = 0;
    }
  }
  v4 = (__int64 *)a1[7];
  if ( v4 )
  {
    comb_destroy(v4);
    comb_destroy((__int64 *)(a1[7] + 8LL));
    comb_destroy((__int64 *)(a1[7] + 16LL));
    comb_destroy((__int64 *)(a1[7] + 24LL));
    comb_destroy((__int64 *)(a1[7] + 32LL));
    comb_destroy((__int64 *)(a1[7] + 40LL));
    comb_destroy((__int64 *)(a1[7] + 48LL));
    comb_destroy((__int64 *)(a1[7] + 56LL));
    v5 = (void *)a1[7];
    if ( v5 )
    {
      free(v5);
      a1[7] = 0;
    }
  }
  v6 = (__int64 *)a1[8];
  if ( v6 )
  {
    iir_destroy(v6);
    iir_destroy((__int64 *)(a1[8] + 8LL));
    v7 = (void *)a1[8];
    if ( v7 )
    {
      free(v7);
      a1[8] = 0;
    }
  }
  v8 = (void *)a1[5];
  if ( v8 )
    free(v8);
  v9 = (void *)a1[3];
  a1[5] = 0;
  if ( v9 )
    free(v9);
  v10 = (void *)a1[4];
  a1[3] = 0;
  if ( v10 )
    free(v10);
  a1[4] = 0;
}

//----- (000000000003FFBC) ----------------------------------------------------
__int64 __fastcall reverb_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  sub_3FFF8(a1);
  return 0;
}

//----- (000000000003FFF8) ----------------------------------------------------
__int64 __fastcall sub_3FFF8(__int64 a1)
{
  int v1; // w8

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 )
    memset(*(void **)(a1 + 40), 0, 4LL * (unsigned int)(2 * v1));
  comb_flush(**(_QWORD **)(a1 + 56));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL));
  comb_flush(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL));
  allpass_flush(**(_QWORD **)(a1 + 48));
  allpass_flush(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL));
  allpass_flush(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16LL));
  allpass_flush(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24LL));
  iir_flush(**(_QWORD **)(a1 + 64));
  return iir_flush(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL));
}

//----- (00000000000400D4) ----------------------------------------------------
__int64 __fastcall reverb_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  sub_3FE98((_QWORD *)a1);
  result = 0;
  *(_BYTE *)(a1 + 16) = 0;
  return result;
}

//----- (000000000004011C) ----------------------------------------------------
__int64 __fastcall reverb_setup(__int64 a1, int a2, __int64 a3, int a4, int a5)
{
  _OWORD *v10; // x0
  _OWORD *v11; // x0
  _QWORD *v12; // x0
  int v13; // w8
  void *v14; // x0
  size_t v15; // x21
  void *v17; // x0
  void *v18; // x0
  float v19; // s0
  float v20; // s0
  float v21; // s0
  float v22; // s0
  float v23; // s0
  float v24; // s0
  float v25; // s0
  float v26; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 16) )
    sub_3FE98((_QWORD *)a1);
  if ( !a2 )
    return 4;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = a4;
  v10 = *(_OWORD **)(a1 + 48);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a3 + 100);
  if ( !v10 )
  {
    v10 = malloc(0x20u);
    *(_QWORD *)(a1 + 48) = v10;
    if ( !v10 )
      goto LABEL_47;
  }
  *v10 = 0u;
  v10[1] = 0u;
  allpass_create(*(_QWORD **)(a1 + 48));
  allpass_create((_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL));
  allpass_create((_QWORD *)(*(_QWORD *)(a1 + 48) + 16LL));
  allpass_create((_QWORD *)(*(_QWORD *)(a1 + 48) + 24LL));
  v11 = *(_OWORD **)(a1 + 56);
  if ( !v11 )
  {
    v11 = malloc(0x40u);
    *(_QWORD *)(a1 + 56) = v11;
    if ( !v11 )
      goto LABEL_47;
  }
  v11[2] = 0u;
  v11[3] = 0u;
  *v11 = 0u;
  v11[1] = 0u;
  comb_create(*(_QWORD **)(a1 + 56));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL));
  comb_create((_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL));
  v12 = *(_QWORD **)(a1 + 64);
  if ( !v12 )
  {
    v12 = malloc(0x10u);
    *(_QWORD *)(a1 + 64) = v12;
    if ( !v12 )
      goto LABEL_47;
  }
  *v12 = 0;
  v12[1] = 0;
  iir_create(*(_QWORD **)(a1 + 64));
  iir_create((_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL));
  v13 = *(_DWORD *)(a1 + 12);
  if ( v13 )
  {
    v14 = *(void **)(a1 + 40);
    if ( v14 )
    {
      v15 = 4LL * (unsigned int)(2 * v13);
    }
    else
    {
      v15 = 4LL * (unsigned int)(2 * v13);
      v14 = malloc(v15);
      *(_QWORD *)(a1 + 40) = v14;
      if ( !v14 )
        goto LABEL_47;
    }
    memset(v14, 0, v15);
  }
  if ( (v17 = *(void **)(a1 + 24)) == 0 && (v17 = malloc(0x800u), (*(_QWORD *)(a1 + 24) = v17) == 0)
    || (memset(v17, 0, 0x800u), (v18 = *(void **)(a1 + 32)) == 0)
    && (v18 = malloc(0x800u), (*(_QWORD *)(a1 + 32) = v18) == 0) )
  {
LABEL_47:
    exit(1);
  }
  memset(v18, 0, 0x800u);
  sub_3FFF8(a1);
  iir_setup(**(_QWORD **)(a1 + 64), 1u, *(_DWORD *)(a1 + 4), 2, (float *)(a3 + 84), (float *)(a3 + 72));
  iir_setup(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL), 1u, *(_DWORD *)(a1 + 4), 2, (float *)(a3 + 84), (float *)(a3 + 72));
  if ( *(_DWORD *)(a1 + 8) )
    v19 = 0.775;
  else
    v19 = *(float *)a3;
  comb_setup(**(_QWORD **)(a1 + 56), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 24), v19);
  if ( *(_DWORD *)(a1 + 8) )
    v20 = 0.775;
  else
    v20 = *(float *)a3;
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 40), v20);
  if ( *(_DWORD *)(a1 + 8) )
    v21 = 0.775;
  else
    v21 = *(float *)(a3 + 4);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 28), v21);
  if ( *(_DWORD *)(a1 + 8) )
    v22 = 0.775;
  else
    v22 = *(float *)(a3 + 4);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 44), v22);
  if ( *(_DWORD *)(a1 + 8) )
    v23 = 0.775;
  else
    v23 = *(float *)(a3 + 8);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 32), v23);
  if ( *(_DWORD *)(a1 + 8) )
    v24 = 0.775;
  else
    v24 = *(float *)(a3 + 8);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 48), v24);
  if ( *(_DWORD *)(a1 + 8) )
    v25 = 0.775;
  else
    v25 = *(float *)(a3 + 12);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 36), v25);
  if ( *(_DWORD *)(a1 + 8) )
    v26 = 0.775;
  else
    v26 = *(float *)(a3 + 12);
  comb_setup(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 52), v26);
  allpass_setup(**(_QWORD **)(a1 + 48), 1, *(_DWORD *)(a1 + 4), *(unsigned int *)(a3 + 56), *(float *)(a3 + 16));
  allpass_setup(
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16LL),
    1,
    *(_DWORD *)(a1 + 4),
    *(unsigned int *)(a3 + 64),
    *(float *)(a3 + 16));
  allpass_setup(
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL),
    1,
    *(_DWORD *)(a1 + 4),
    *(unsigned int *)(a3 + 60),
    *(float *)(a3 + 20));
  allpass_setup(
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 24LL),
    1,
    *(_DWORD *)(a1 + 4),
    *(unsigned int *)(a3 + 68),
    *(float *)(a3 + 20));
  *(_BYTE *)(a1 + 16) = 1;
  reverb_update(a1, a3, 0.8);
  return 0;
}

//----- (0000000000040580) ----------------------------------------------------
__int64 __fastcall reverb_update(__int64 a1, __int64 a2, float a3)
{
  int v4; // w9
  __int64 result; // x0
  float v7; // s8
  __int64 v8; // x8
  float v9; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 100);
  if ( !v4 )
  {
    comb_update(**(_QWORD **)(a1 + 56), *(float *)a2);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL), *(float *)a2);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL), *(float *)(a2 + 4));
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL), *(float *)(a2 + 4));
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL), *(float *)(a2 + 8));
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL), *(float *)(a2 + 8));
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL), *(float *)(a2 + 12));
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(float *)(a2 + 12);
    goto LABEL_10;
  }
  result = 0xFFFFFFFFLL;
  if ( a3 >= 0.0 && a3 <= 1.0 )
  {
    v7 = (float)(a3 * 0.35) + 0.6;
    comb_update(**(_QWORD **)(a1 + 56), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL), v7);
    comb_update(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL), v7);
    v8 = *(_QWORD *)(a1 + 56);
    v9 = v7;
LABEL_10:
    comb_update(*(_QWORD *)(v8 + 56), v9);
    return 0;
  }
  return result;
}

//----- (000000000004070C) ----------------------------------------------------
__int64 __fastcall reverb_process(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x8
  unsigned __int64 v11; // x22
  __int64 v14; // x9
  unsigned int v15; // w10
  float v16; // s0
  float v17; // s1
  unsigned __int64 v18; // x8
  __int64 v19; // x1
  unsigned __int64 v20; // x9
  bool v22; // w10
  __int64 v23; // x10
  float32x4_t *v24; // x11
  unsigned __int64 v25; // x12
  const float *v26; // x13
  const float *v27; // x14
  unsigned int v28; // w10
  unsigned int v29; // w11
  float v30; // s2
  __int64 v31; // x9
  unsigned __int64 v32; // x8
  float32x4_t *v33; // x10
  __int64 v34; // x11
  unsigned __int64 v35; // x12
  char *v36; // x10
  unsigned int v37; // w11
  float v38; // s0
  unsigned int v39; // w13
  __int64 v40; // x10
  __int64 v41; // x11
  __int64 v42; // x11
  _DWORD *v43; // x12
  unsigned int v44; // w13
  __int64 v45; // x9
  int v46; // w11
  __int64 v47; // x1
  __int64 v48; // x9
  bool v49; // w10
  __int64 v50; // x10
  float32x4_t *v51; // x11
  __int64 v52; // x12
  const float *v53; // x13
  const float *v54; // x14
  float *v55; // x10
  unsigned int v56; // w11
  __int64 v57; // x8
  float v58; // s2
  float v59; // s1
  __int64 v60; // x8
  unsigned __int64 v61; // x9
  float32x2_t v62; // d7
  unsigned __int64 v63; // x10
  __int64 v64; // x11
  unsigned __int64 v65; // x13
  __int64 v66; // x11
  unsigned __int64 v67; // x10
  float v68; // s0
  __int64 v69; // x12
  __int64 v70; // x10
  unsigned __int64 v71; // x12
  __int64 v72; // x11
  __int64 v73; // x11
  int v74; // w9
  int v75; // w12
  unsigned int v76; // w13
  unsigned __int64 v77; // x15
  __int64 v78; // x13
  unsigned int v79; // w17
  bool v80; // w16
  bool v81; // w14
  unsigned __int64 v82; // x15
  float32x4_t v83; // q0
  float32x4_t v84; // q1
  __int64 v85; // x15
  unsigned int v86; // w13
  float32x4_t *v87; // x16
  unsigned __int64 v88; // x17
  float32x4_t v89; // q2
  unsigned int v90; // w0
  float *v91; // x1
  float *v92; // x0
  unsigned __int64 v93; // x15
  __int64 v94; // x12
  unsigned int v95; // w17
  bool v96; // w16
  bool v97; // w14
  unsigned __int64 v98; // x15
  float32x4_t v99; // q0
  float32x4_t v100; // q1
  unsigned __int64 v101; // x16
  float32x4_t *v102; // x17
  float32x4_t v103; // t1
  const float *v104; // x0
  float *v105; // x0
  _OWORD *v106; // x12
  unsigned int v107; // w13
  __int64 v108; // x14
  _OWORD *v109; // x15
  __int128 v110; // q1
  unsigned int v111; // w12
  __int64 v112; // x13
  unsigned int v113; // w14
  _OWORD *v114; // x15
  __int128 v115; // q1
  _OWORD *v116; // x16
  int32x2_t v117; // [xsp+0h] [xbp-40h]
  int32x2_t v118; // [xsp+10h] [xbp-30h]
  float32x4x2_t v119; // 0:q1.16,16:q2.16
  float32x4x2_t v120; // 0:q1.16,16:q2.16
  float32x4x2_t v121; // 0:q3.16,16:q4.16
  float32x4x2_t v122; // 0:q3.16,16:q4.16
  float32x4x2_t v123; // 0:q3.16,16:q4.16
  float32x4x2_t v124; // 0:q4.16,16:q5.16
  float32x4x2_t v125; // 0:q5.16,16:q6.16
  float32x4x2_t v126; // 0:q6.16,16:q7.16

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  LODWORD(a9) = *(_DWORD *)(a1 + 20);
  v10 = *(unsigned int *)(a1 + 12);
  v11 = *(_QWORD *)(a1 + 40);
  *(float *)&a8 = *(float *)&a9 * 0.0;
  if ( (_DWORD)v10 )
  {
    v14 = 0;
    v15 = 1;
    do
    {
      v16 = *(float *)(v11 + 4 * v14);
      v17 = *(float *)(v11 + 4LL * (unsigned int)(v10 + v14++));
      *(float *)(a3 + 4LL * (v15 - 1)) = (float)(*(float *)&a9 * v16) + (float)(*(float *)&a8 * v17);
      *(float *)(a3 + 4LL * v15) = (float)(*(float *)&a8 * v16) + (float)(*(float *)&a9 * v17);
      v15 += 2;
    }
    while ( v10 != v14 );
  }
  v117.n64_f64[0] = a9;
  v118.n64_f64[0] = a8;
  v18 = *(unsigned int *)(a1 + 4);
  v19 = *(_QWORD *)(a1 + 24);
  if ( (_DWORD)v18 )
  {
    if ( (unsigned int)v18 <= 7 )
    {
      v20 = 0;
LABEL_19:
      v28 = 2 * v20;
      do
      {
        v29 = v28 + 1;
        v30 = *(float *)(a2 + 4LL * v28);
        v28 += 2;
        *(float *)(v19 + 4 * v20++) = v30 + (float)(*(float *)(a2 + 4LL * v29) * 0.0);
      }
      while ( v20 < v18 );
      goto LABEL_21;
    }
    v20 = 0;
    v22 = __CFADD__(v18 - 1, v18 - 1);
    if ( (v18 - 1) >> 32 )
      goto LABEL_19;
    if ( v22 )
      goto LABEL_19;
    v20 = (unsigned int)v18 & 0xFFFFFFF8;
    v23 = 0;
    v24 = (float32x4_t *)(v19 + 16);
    v25 = v20;
    do
    {
      v26 = (const float *)(a2 + ((4 * v23) & 0x3FFFFFFC0LL));
      v27 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v23 >> 4) << 6) | 0x20));
      v119 = vld2q_f32(v26);
      v121 = vld2q_f32(v27);
      v23 += 16;
      v25 -= 8LL;
      v24[-1] = vaddq_f32(v119.val[0], vmulq_f32(v119.val[1], (float32x4_t)0LL));
      *v24 = vaddq_f32(v121.val[0], vmulq_f32(v121.val[1], (float32x4_t)0LL));
      v24 += 2;
    }
    while ( v25 );
    if ( v20 != v18 )
      goto LABEL_19;
  }
LABEL_21:
  comb_process(**(_QWORD **)(a1 + 56), v19, *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  allpass_process_inplace(**(unsigned int ***)(a1 + 48), *(_QWORD *)(a1 + 32));
  allpass_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 48) + 8LL), *(_QWORD *)(a1 + 32));
  iir_process_inplace(**(unsigned int ***)(a1 + 64), *(_QWORD *)(a1 + 32));
  v31 = *(unsigned int *)(a1 + 12);
  v32 = *(unsigned int *)(a1 + 4);
  if ( (unsigned int)v32 > (unsigned int)v31 )
  {
    v33 = *(float32x4_t **)(a1 + 32);
    v34 = v32 - v31;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v32 - v31 <= 7 )
      goto LABEL_23;
    v77 = ~v31 + v32;
    v78 = (unsigned int)(2 * v31);
    v79 = 2 * v77;
    v80 = __CFADD__((_DWORD)v77, (_DWORD)v77);
    v81 = v77 >> 61 != 0;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v79 > ~(_DWORD)v78 )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( HIDWORD(v77) )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v80 )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v79 > ((unsigned int)v78 ^ 0xFFFFFFFE) )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( HIDWORD(v77) )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v80 )
      goto LABEL_23;
    v82 = 8 * v77;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v82 > ~(a3 + 4 * v78) )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v81 )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v82 > ~(a3 + ((8LL * ((unsigned int)v78 >> 1)) | 4uLL)) )
      goto LABEL_23;
    v35 = *(unsigned int *)(a1 + 12);
    if ( v81 )
      goto LABEL_23;
    v83 = vdupq_lane_s32(v117, 0);
    v84 = vdupq_lane_s32(v118, 0);
    v85 = a3 - 4;
    v86 = v78 + 9;
    v35 = (v34 & 0xFFFFFFFFFFFFFFF8LL) + v31;
    v87 = v33 + 1;
    v88 = v34 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      v89 = v87[-1];
      v90 = v86 - 8;
      v91 = (float *)(v85 + 4LL * v86);
      v86 += 16;
      v124.val[0] = vmulq_f32(v83, v89);
      v126.val[0] = vmulq_f32(v83, *v87);
      v88 -= 8LL;
      v92 = (float *)(v85 + 4LL * v90);
      v124.val[1] = vmulq_f32(v84, v89);
      v126.val[1] = vmulq_f32(v84, *v87);
      v87 += 2;
      vst2q_f32(v92, v124);
      vst2q_f32(v91, v126);
    }
    while ( v88 );
    if ( v34 != (v34 & 0xFFFFFFFFFFFFFFF8LL) )
    {
LABEL_23:
      v36 = (char *)v33 - 4 * v31;
      v37 = 2 * v35;
      do
      {
        v38 = *(float *)&v36[4 * v35++];
        v39 = v37 + 1;
        *(float *)(a3 + 4LL * v37) = v117.n64_f32[0] * v38;
        v37 += 2;
        *(float *)(a3 + 4LL * v39) = v118.n64_f32[0] * v38;
      }
      while ( v35 < v32 );
    }
  }
  if ( (_DWORD)v31 )
  {
    v40 = *(_QWORD *)(a1 + 32);
    if ( (unsigned int)v31 <= 7 )
      goto LABEL_31;
    v41 = 0;
    if ( (int)v31 + ~(_DWORD)v32 < (unsigned int)(v31 - 1) || (unsigned __int64)(v31 - 1) >> 32 )
      goto LABEL_32;
    v42 = (unsigned int)(v32 - v31);
    if ( v11 < v40 + 4 * (v31 + v42) && v40 + 4 * (unsigned __int64)(unsigned int)v42 < v11 + 4 * v31 )
    {
LABEL_31:
      v41 = 0;
LABEL_32:
      v43 = (_DWORD *)(v11 + 4 * v41);
      v44 = v32 + v41 - v31;
      v45 = v31 - v41;
      do
      {
        v46 = *(_DWORD *)(v40 + 4LL * v44);
        --v45;
        ++v44;
        *v43++ = v46;
      }
      while ( v45 );
      goto LABEL_34;
    }
    v41 = (unsigned int)v31 & 0xFFFFFFF8;
    v106 = (_OWORD *)(v11 + 16);
    v107 = v32 - v31;
    v108 = v41;
    do
    {
      v109 = (_OWORD *)(v40 + 4LL * v107);
      v110 = v109[1];
      v108 -= 8;
      v107 += 8;
      *(v106 - 1) = *v109;
      *v106 = v110;
      v106 += 2;
    }
    while ( v108 );
    if ( v41 != v31 )
      goto LABEL_32;
  }
LABEL_34:
  v47 = *(_QWORD *)(a1 + 24);
  if ( (_DWORD)v32 )
  {
    if ( (unsigned int)v32 <= 7 )
    {
      v48 = 0;
LABEL_45:
      v55 = (float *)(v47 + 4 * v48);
      v56 = 2 * v48;
      v57 = v32 - v48;
      do
      {
        v58 = *(float *)(a2 + 4LL * (v56 + 1));
        --v57;
        v59 = *(float *)(a2 + 4LL * v56) * 0.0;
        v56 += 2;
        *v55++ = v59 + v58;
      }
      while ( v57 );
      goto LABEL_47;
    }
    v48 = 0;
    v49 = __CFADD__(v32 - 1, v32 - 1);
    if ( (v32 - 1) >> 32 )
      goto LABEL_45;
    if ( v49 )
      goto LABEL_45;
    v48 = (unsigned int)v32 & 0xFFFFFFF8;
    v50 = 0;
    v51 = (float32x4_t *)(v47 + 16);
    v52 = v48;
    do
    {
      v53 = (const float *)(a2 + ((4 * v50) & 0x3FFFFFFC0LL));
      v54 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v50 >> 4) << 6) | 0x20));
      v120 = vld2q_f32(v53);
      v122 = vld2q_f32(v54);
      v50 += 16;
      v52 -= 8;
      v51[-1] = vaddq_f32(vmulq_f32(v120.val[0], (float32x4_t)0LL), v120.val[1]);
      *v51 = vaddq_f32(vmulq_f32(v122.val[0], (float32x4_t)0LL), v122.val[1]);
      v51 += 2;
    }
    while ( v52 );
    if ( v48 != v32 )
      goto LABEL_45;
  }
LABEL_47:
  comb_process(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL), v47, *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 48LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  comb_process_acc(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  allpass_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 48) + 16LL), *(_QWORD *)(a1 + 32));
  allpass_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 48) + 24LL), *(_QWORD *)(a1 + 32));
  iir_process_inplace(*(unsigned int **)(*(_QWORD *)(a1 + 64) + 8LL), *(_QWORD *)(a1 + 32));
  v60 = *(unsigned int *)(a1 + 12);
  v61 = *(unsigned int *)(a1 + 4);
  v62.n64_u32[0] = v118.n64_u32[0];
  if ( (unsigned int)v61 > (unsigned int)v60 )
  {
    v63 = *(_QWORD *)(a1 + 32);
    v64 = v61 - v60;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v61 - v60 <= 3 )
      goto LABEL_49;
    v93 = ~v60 + v61;
    v94 = (unsigned int)(2 * v60);
    v95 = 2 * v93;
    v96 = __CFADD__((_DWORD)v93, (_DWORD)v93);
    v97 = v93 >> 61 != 0;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v95 > ~(_DWORD)v94 )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( HIDWORD(v93) )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v96 )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v95 > ((unsigned int)v94 ^ 0xFFFFFFFE) )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( HIDWORD(v93) )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v96 )
      goto LABEL_49;
    v98 = 8 * v93;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v98 > ~(a3 + ((8LL * ((unsigned int)v94 >> 1)) | 4uLL)) )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v97 )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v98 > ~(a3 + 4 * v94) )
      goto LABEL_49;
    v65 = *(unsigned int *)(a1 + 12);
    if ( v97 )
      goto LABEL_49;
    if ( v63 < a3 + 4 * (v94 + 2 * v61 - 2 * v60) )
    {
      v65 = *(unsigned int *)(a1 + 12);
      if ( a3 + 4 * (unsigned __int64)(unsigned int)v94 < v63 + 4 * v64 )
        goto LABEL_49;
    }
    v99 = vdupq_lane_s32(v118, 0);
    v65 = (v64 & 0xFFFFFFFFFFFFFFFCLL) + v60;
    v100 = vdupq_lane_s32(v117, 0);
    v101 = v64 & 0xFFFFFFFFFFFFFFFCLL;
    v102 = *(float32x4_t **)(a1 + 32);
    do
    {
      v103 = *v102++;
      v104 = (const float *)(a3 + 4LL * (unsigned int)v94);
      v123 = vld2q_f32(v104);
      v125.val[0] = vaddq_f32(v123.val[0], vmulq_f32(v99, v103));
      v101 -= 4LL;
      v105 = (float *)(a3 - 4 + 4LL * (unsigned int)(v94 + 1));
      v125.val[1] = vaddq_f32(vmulq_f32(v100, v103), v123.val[1]);
      LODWORD(v94) = v94 + 8;
      vst2q_f32(v105, v125);
    }
    while ( v101 );
    if ( v64 != (v64 & 0xFFFFFFFFFFFFFFFCLL) )
    {
LABEL_49:
      v66 = 2 * v65;
      v67 = v63 - 4 * v60;
      v62.n64_u32[1] = v117.n64_u32[0];
      do
      {
        v68 = *(float *)(v67 + 4 * v65);
        v69 = 4LL * ((unsigned int)v66 & 0xFFFFFFFE);
        ++v65;
        v66 += 2;
        *(float32x2_t *)(a3 + v69) = vadd_f32(*(float32x2_t *)(a3 + v69), vmul_n_f32(v62, v68));
      }
      while ( v65 < v61 );
    }
  }
  if ( !(_DWORD)v60 )
    return 0;
  v70 = *(_QWORD *)(a1 + 32);
  if ( (unsigned int)v60 > 7 )
  {
    v71 = v60 - 1;
    v72 = 0;
    if ( ~(_DWORD)v60 < (unsigned int)(v60 - 1)
      || HIDWORD(v71)
      || (int)v60 + ~(_DWORD)v61 < (unsigned int)v71
      || HIDWORD(v71) )
    {
      goto LABEL_60;
    }
    v73 = (unsigned int)(v61 - v60);
    if ( v11 + 4 * v60 >= v70 + 4 * (v60 + v73) || v70 + 4 * (unsigned __int64)(unsigned int)v73 >= v11 + 8 * v60 )
    {
      v72 = (unsigned int)v60 & 0xFFFFFFF8;
      v111 = v61 - v60;
      v112 = v72;
      v113 = v60;
      do
      {
        v114 = (_OWORD *)(v70 + 4LL * v111);
        v115 = v114[1];
        v116 = (_OWORD *)(v11 + 4LL * v113);
        v111 += 8;
        v112 -= 8;
        v113 += 8;
        *v116 = *v114;
        v116[1] = v115;
      }
      while ( v112 );
      if ( v72 == v60 )
        return 0;
      goto LABEL_60;
    }
  }
  v72 = 0;
LABEL_60:
  v74 = v61 - v60;
  do
  {
    v75 = *(_DWORD *)(v70 + 4LL * (unsigned int)(v74 + v72));
    v76 = v60 + v72++;
    *(_DWORD *)(v11 + 4LL * v76) = v75;
  }
  while ( v60 != v72 );
  return 0;
}

//----- (0000000000040EB8) ----------------------------------------------------
__int64 __fastcall reverb_bypass(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x8
  unsigned __int64 v4; // x9
  _DWORD *v5; // x10
  __int64 v6; // x11
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x13
  __int64 v9; // x12
  unsigned __int128 *v10; // x14
  unsigned __int64 v11; // x15
  const float *v12; // x16
  const float *v13; // x17
  unsigned __int128 v14; // q0
  unsigned __int128 v15; // q2
  __int64 v16; // x13
  int v17; // w14
  __int64 v18; // x11
  __int64 v19; // x13
  __int64 v20; // x12
  unsigned int v21; // w14
  _DWORD *v22; // x15
  __int64 v23; // x17
  int v24; // w16
  __int64 v25; // x12
  __int64 v26; // x13
  __int64 v27; // x14
  unsigned __int64 v28; // x15
  int *v29; // x16
  unsigned __int64 v30; // x17
  __int64 v31; // x3
  int v32; // w4
  int v33; // w5
  __int64 v34; // x7
  __int64 v35; // x6
  __int64 v36; // x13
  int *v37; // x12
  __int64 v38; // x14
  int v39; // t1
  __int64 v40; // x16
  __int64 v41; // x12
  unsigned __int64 v42; // x13
  unsigned __int64 v43; // x14
  __int64 v44; // x13
  unsigned __int128 *v45; // x15
  unsigned __int64 v46; // x16
  const float *v47; // x17
  const float *v48; // x3
  unsigned __int128 v49; // q0
  unsigned __int128 v50; // q2
  __int64 v51; // x14
  int v52; // w15
  __int64 v53; // x13
  __int64 v54; // x12
  unsigned int v55; // w14
  unsigned int v56; // w15
  __int64 v57; // x16
  int v58; // w17
  __int64 v59; // x10
  __int64 v60; // x12
  __int64 v61; // x13
  unsigned __int64 v62; // x14
  int *v63; // x15
  unsigned __int64 v64; // x16
  int v65; // w0
  int v66; // w17
  unsigned __int64 v67; // x4
  unsigned __int64 v68; // x3
  __int64 v69; // x11
  __int64 v70; // x9
  int *v71; // x8
  int v72; // t1
  unsigned __int64 v73; // x13

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v3 = *(unsigned int *)(a1 + 12);
  v4 = *(unsigned int *)(a1 + 4);
  v5 = *(_DWORD **)(a1 + 40);
  if ( (_DWORD)v4 )
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = 0;
    if ( (unsigned int)v4 >= 9 )
    {
      v8 = (v4 - 1) >> 31;
      if ( !v8 )
      {
        v9 = v4 & 7;
        if ( (v4 & 7) == 0 )
          v9 = 8;
        v7 = v4 - v9;
        v10 = (unsigned __int128 *)(v6 + 16);
        v11 = v7;
        do
        {
          v12 = (const float *)(a2 + ((4 * v8) & 0x3FFFFFFC0LL));
          v13 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v8 >> 4) << 6) | 0x20));
          v14 = (unsigned __int128)vld2q_f32(v12);
          v15 = (unsigned __int128)vld2q_f32(v13);
          v8 += 16LL;
          v11 -= 8LL;
          *(v10 - 1) = v14;
          *v10 = v15;
          v10 += 2;
        }
        while ( v11 );
      }
    }
    v16 = 2 * v7;
    do
    {
      v17 = *(_DWORD *)(a2 + 4LL * ((unsigned int)v16 & 0xFFFFFFFE));
      v16 += 2;
      *(_DWORD *)(v6 + 4 * v7++) = v17;
    }
    while ( v7 < v4 );
  }
  v18 = 2 * v3;
  if ( (_DWORD)v3 )
  {
    v19 = *(_QWORD *)(a1 + 32);
    v20 = 0;
    v21 = v4 - v3;
    v22 = v5;
    do
    {
      v23 = (unsigned int)v20 & 0xFFFFFFFE;
      v20 += 2;
      *(_DWORD *)(a3 + 4 * v23) = *v22;
      v24 = *(_DWORD *)(v19 + 4LL * v21++);
      *v22++ = v24;
    }
    while ( v18 != v20 );
  }
  if ( (unsigned int)v4 > (unsigned int)v3 )
  {
    v25 = *(_QWORD *)(a1 + 32);
    v26 = v4 - v3;
    v27 = v3;
    if ( v4 - v3 <= 1 )
      goto LABEL_22;
    v28 = ~v3 + v4;
    v27 = v3;
    if ( (~(_DWORD)v3 & 0x7FFFFFFFu) < (v28 & 0x7FFFFFFF) )
      goto LABEL_22;
    v27 = v3;
    if ( v28 >> 31 )
      goto LABEL_22;
    v27 = (v26 & 0xFFFFFFFFFFFFFFFELL) + v3;
    v29 = (int *)(v25 + 4);
    v30 = v26 & 0xFFFFFFFFFFFFFFFELL;
    v31 = 2 * v3;
    do
    {
      v32 = *(v29 - 1);
      v33 = *v29;
      v34 = (unsigned int)v31 & 0xFFFFFFFE;
      v29 += 2;
      v30 -= 2LL;
      v35 = ((_DWORD)v31 + 2) & 0xFFFFFFFE;
      v31 += 4;
      *(_DWORD *)(a3 + 4 * v34) = v32;
      *(_DWORD *)(a3 + 4 * v35) = v33;
    }
    while ( v30 );
    if ( v26 != (v26 & 0xFFFFFFFFFFFFFFFELL) )
    {
LABEL_22:
      v36 = 2 * v27;
      v37 = (int *)(v25 + 4 * (v27 - v3));
      v38 = v4 - v27;
      do
      {
        v39 = *v37++;
        v40 = (unsigned int)v36 & 0xFFFFFFFE;
        --v38;
        v36 += 2;
        *(_DWORD *)(a3 + 4 * v40) = v39;
      }
      while ( v38 );
    }
  }
  if ( (_DWORD)v4 )
  {
    v41 = *(_QWORD *)(a1 + 32);
    v42 = 0;
    if ( (unsigned int)v4 >= 9 )
    {
      v43 = (v4 - 1) >> 31;
      if ( !v43 )
      {
        v44 = v4 & 7;
        if ( (v4 & 7) == 0 )
          v44 = 8;
        v42 = v4 - v44;
        v45 = (unsigned __int128 *)(v41 + 16);
        v46 = v42;
        do
        {
          v47 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v43 >> 4) << 6) | 4));
          v48 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v43 >> 4) << 6) | 0x24));
          v49 = (unsigned __int128)vld2q_f32(v47);
          v50 = (unsigned __int128)vld2q_f32(v48);
          v43 += 16LL;
          v46 -= 8LL;
          *(v45 - 1) = v49;
          *v45 = v50;
          v45 += 2;
        }
        while ( v46 );
      }
    }
    v51 = 2 * v42;
    do
    {
      v52 = *(_DWORD *)(a2 + ((8 * (((unsigned __int64)((unsigned int)v51 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4));
      v51 += 2;
      *(_DWORD *)(v41 + 4 * v42++) = v52;
    }
    while ( v42 < v4 );
  }
  if ( (_DWORD)v3 )
  {
    v53 = *(_QWORD *)(a1 + 32);
    v54 = 0;
    v55 = v4 - v3;
    v56 = v3;
    do
    {
      v57 = v56;
      *(_DWORD *)(a3 + ((8 * (((unsigned __int64)((unsigned int)v54 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4)) = v5[v57];
      v58 = *(_DWORD *)(v53 + 4LL * v55);
      v54 += 2;
      ++v56;
      ++v55;
      v5[v57] = v58;
    }
    while ( v18 != v54 );
  }
  if ( (unsigned int)v4 > (unsigned int)v3 )
  {
    v59 = *(_QWORD *)(a1 + 32);
    v60 = v4 - v3;
    v61 = v3;
    if ( v4 - v3 < 2 )
      goto LABEL_43;
    v62 = ~v3 + v4;
    v61 = v3;
    if ( (~(_DWORD)v3 & 0x7FFFFFFFu) < (v62 & 0x7FFFFFFF) )
      goto LABEL_43;
    v61 = v3;
    if ( v62 >> 31 )
      goto LABEL_43;
    v61 = (v60 & 0xFFFFFFFFFFFFFFFELL) + v3;
    v63 = (int *)(v59 + 4);
    v64 = v60 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v66 = *(v63 - 1);
      v65 = *v63;
      v67 = (8 * (((unsigned __int64)((unsigned int)v18 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4;
      v63 += 2;
      v64 -= 2LL;
      v68 = (8 * (((unsigned __int64)(((_DWORD)v18 + 2) & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4;
      v18 += 4;
      *(_DWORD *)(a3 + v67) = v66;
      *(_DWORD *)(a3 + v68) = v65;
    }
    while ( v64 );
    if ( v60 != (v60 & 0xFFFFFFFFFFFFFFFELL) )
    {
LABEL_43:
      v69 = 2 * v61;
      v70 = v4 - v61;
      v71 = (int *)(v59 + 4 * (v61 - v3));
      do
      {
        v72 = *v71++;
        --v70;
        v73 = (8 * (((unsigned __int64)((unsigned int)v69 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4;
        v69 += 2;
        *(_DWORD *)(a3 + v73) = v72;
      }
      while ( v70 );
    }
  }
  return 0;
}

//----- (0000000000041230) ----------------------------------------------------
__int64 __fastcall reverb_bypass_inplace(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  _DWORD *v4; // x10
  unsigned __int64 v5; // x11
  unsigned __int64 v6; // x12
  __int64 v8; // x12
  __int64 v9; // x13
  unsigned __int128 *v10; // x14
  unsigned __int64 v11; // x15
  const float *v12; // x16
  const float *v13; // x17
  unsigned __int128 v14; // q0
  unsigned __int128 v15; // q2
  __int64 v16; // x13
  int v17; // w14
  __int64 v18; // x11
  __int64 v19; // x13
  __int64 v20; // x12
  unsigned int v21; // w14
  _DWORD *v22; // x15
  __int64 v23; // x17
  int v24; // w16
  int *v25; // x12
  __int64 v26; // x13
  __int64 v27; // x14
  int v28; // t1
  __int64 v29; // x16
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x13
  __int64 v32; // x13
  __int64 v33; // x14
  unsigned __int128 *v34; // x15
  unsigned __int64 v35; // x16
  const float *v36; // x17
  const float *v37; // x2
  unsigned __int128 v38; // q0
  unsigned __int128 v39; // q2
  __int64 v40; // x14
  int v41; // w15
  __int64 v42; // x13
  __int64 v43; // x12
  unsigned int v44; // w14
  unsigned int v45; // w15
  __int64 v46; // x16
  int v47; // w17
  int *v48; // x10
  __int64 v49; // x8
  int v50; // t1
  unsigned __int64 v51; // x13

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v2 = *(unsigned int *)(a1 + 12);
  v3 = *(unsigned int *)(a1 + 4);
  v4 = *(_DWORD **)(a1 + 40);
  if ( (_DWORD)v3 )
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = 0;
    if ( (unsigned int)v3 >= 9 && !((v3 - 1) >> 31) )
    {
      if ( v5 >= a2 + 8 * v3 - 4 || v5 + 4 * v3 <= a2 )
      {
        v8 = v3 & 7;
        if ( (v3 & 7) == 0 )
          v8 = 8;
        v6 = v3 - v8;
        v9 = 0;
        v10 = (unsigned __int128 *)(v5 + 16);
        v11 = v6;
        do
        {
          v12 = (const float *)(a2 + ((4 * v9) & 0x3FFFFFFC0LL));
          v13 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v9 >> 4) << 6) | 0x20));
          v14 = (unsigned __int128)vld2q_f32(v12);
          v15 = (unsigned __int128)vld2q_f32(v13);
          v9 += 16;
          v11 -= 8LL;
          *(v10 - 1) = v14;
          *v10 = v15;
          v10 += 2;
        }
        while ( v11 );
      }
      else
      {
        v6 = 0;
      }
    }
    v16 = 2 * v6;
    do
    {
      v17 = *(_DWORD *)(a2 + 4LL * ((unsigned int)v16 & 0xFFFFFFFE));
      v16 += 2;
      *(_DWORD *)(v5 + 4 * v6++) = v17;
    }
    while ( v6 < v3 );
  }
  v18 = 2 * v2;
  if ( (_DWORD)v2 )
  {
    v19 = *(_QWORD *)(a1 + 32);
    v20 = 0;
    v21 = v3 - v2;
    v22 = v4;
    do
    {
      v23 = (unsigned int)v20 & 0xFFFFFFFE;
      v20 += 2;
      *(_DWORD *)(a2 + 4 * v23) = *v22;
      v24 = *(_DWORD *)(v19 + 4LL * v21++);
      *v22++ = v24;
    }
    while ( v18 != v20 );
  }
  if ( (unsigned int)v3 > (unsigned int)v2 )
  {
    v25 = *(int **)(a1 + 32);
    v26 = v3 - v2;
    v27 = 2 * v2;
    do
    {
      v28 = *v25++;
      v29 = (unsigned int)v27 & 0xFFFFFFFE;
      --v26;
      v27 += 2;
      *(_DWORD *)(a2 + 4 * v29) = v28;
    }
    while ( v26 );
  }
  if ( (_DWORD)v3 )
  {
    v30 = *(_QWORD *)(a1 + 32);
    v31 = 0;
    if ( (unsigned int)v3 >= 9 && !((v3 - 1) >> 31) )
    {
      if ( v30 >= a2 + 8 * v3 || a2 + 4 >= v30 + 4 * v3 )
      {
        v32 = v3 & 7;
        if ( (v3 & 7) == 0 )
          v32 = 8;
        v31 = v3 - v32;
        v33 = 0;
        v34 = (unsigned __int128 *)(v30 + 16);
        v35 = v31;
        do
        {
          v36 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v33 >> 4) << 6) | 4));
          v37 = (const float *)(a2 + (((unsigned __int64)((unsigned int)v33 >> 4) << 6) | 0x24));
          v38 = (unsigned __int128)vld2q_f32(v36);
          v39 = (unsigned __int128)vld2q_f32(v37);
          v33 += 16;
          v35 -= 8LL;
          *(v34 - 1) = v38;
          *v34 = v39;
          v34 += 2;
        }
        while ( v35 );
      }
      else
      {
        v31 = 0;
      }
    }
    v40 = 2 * v31;
    do
    {
      v41 = *(_DWORD *)(a2 + ((8 * (((unsigned __int64)((unsigned int)v40 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4));
      v40 += 2;
      *(_DWORD *)(v30 + 4 * v31++) = v41;
    }
    while ( v31 < v3 );
  }
  if ( (_DWORD)v2 )
  {
    v42 = *(_QWORD *)(a1 + 32);
    v43 = 0;
    v44 = v3 - v2;
    v45 = v2;
    do
    {
      v46 = v45;
      *(_DWORD *)(a2 + ((8 * (((unsigned __int64)((unsigned int)v43 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4)) = v4[v46];
      v47 = *(_DWORD *)(v42 + 4LL * v44);
      v43 += 2;
      ++v45;
      ++v44;
      v4[v46] = v47;
    }
    while ( v18 != v43 );
  }
  if ( (unsigned int)v3 > (unsigned int)v2 )
  {
    v48 = *(int **)(a1 + 32);
    v49 = v3 - v2;
    do
    {
      v50 = *v48++;
      --v49;
      v51 = (8 * (((unsigned __int64)((unsigned int)v18 & 0xFFFFFFFE) >> 1) & 0x7FFFFFFF)) | 4;
      v18 += 2;
      *(_DWORD *)(a2 + v51) = v50;
    }
    while ( v49 );
  }
  return 0;
}

//----- (00000000000414D0) ----------------------------------------------------
long double __fastcall allpass_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x28u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[4] = 0;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
  }
  return result;
}

//----- (000000000004152C) ----------------------------------------------------
__int64 __fastcall allpass_destroy(__int64 *a1)
{
  __int64 v1; // x20
  void *v3; // x0
  void *v4; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = *(void **)(v1 + 24);
  if ( v3 )
    free(v3);
  v4 = *(void **)(v1 + 32);
  *(_QWORD *)(v1 + 24) = 0;
  if ( v4 )
    free(v4);
  *(_QWORD *)(v1 + 32) = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0000000000041590) ----------------------------------------------------
__int64 __fastcall allpass_flush(__int64 a1)
{
  __int64 v2; // x8
  void *v3; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  v2 = *(unsigned int *)(a1 + 4);
  v3 = *(void **)(a1 + 24);
  *(_DWORD *)(a1 + 8) = 0;
  memset(v3, 0, 4 * v2);
  memset(*(void **)(a1 + 32), 0, 4LL * *(unsigned int *)(a1 + 4));
  return 0;
}

//----- (00000000000415F8) ----------------------------------------------------
__int64 __fastcall allpass_reset(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  v2 = *(void **)(a1 + 24);
  if ( v2 )
    free(v2);
  v3 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = 0;
  if ( v3 )
    free(v3);
  result = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  return result;
}

//----- (0000000000041658) ----------------------------------------------------
__int64 __fastcall allpass_setup(__int64 a1, int a2, int a3, size_t n, float a5)
{
  __int64 result; // x0
  unsigned int v9; // w20
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  size_t v13; // x20
  void *v14; // x0
  size_t v15; // x20
  __int64 v16; // x8
  void *v17; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 != 1 )
    return 1;
  if ( !a3 )
    return 4;
  result = 0xFFFFFFFFLL;
  if ( a5 <= 1.0 )
  {
    v9 = n;
    if ( (unsigned int)n <= 0x800 && a5 >= 0.0 )
    {
      if ( *(_BYTE *)(a1 + 12) )
      {
        v10 = *(void **)(a1 + 24);
        if ( v10 )
          free(v10);
        v11 = *(void **)(a1 + 32);
        *(_QWORD *)(a1 + 24) = 0;
        if ( v11 )
          free(v11);
        *(_QWORD *)(a1 + 32) = 0;
      }
      v12 = *(void **)(a1 + 24);
      *(_DWORD *)a1 = a3;
      *(_DWORD *)(a1 + 4) = v9;
      v13 = 4LL * v9;
      if ( v12 || (v12 = malloc(v13), (*(_QWORD *)(a1 + 24) = v12) != 0) )
      {
        memset(v12, 0, v13);
        v14 = *(void **)(a1 + 32);
        if ( v14 )
        {
          v15 = 4LL * *(unsigned int *)(a1 + 4);
LABEL_21:
          memset(v14, 0, v15);
          v16 = *(unsigned int *)(a1 + 4);
          v17 = *(void **)(a1 + 24);
          *(_DWORD *)(a1 + 8) = 0;
          memset(v17, 0, 4 * v16);
          memset(*(void **)(a1 + 32), 0, 4LL * *(unsigned int *)(a1 + 4));
          result = 0;
          *(_BYTE *)(a1 + 12) = 1;
          *(float *)(a1 + 16) = a5;
          return result;
        }
        v15 = 4LL * *(unsigned int *)(a1 + 4);
        v14 = malloc(v15);
        *(_QWORD *)(a1 + 32) = v14;
        if ( v14 )
          goto LABEL_21;
      }
      exit(1);
    }
  }
  return result;
}

//----- (00000000000417AC) ----------------------------------------------------
__int64 __fastcall allpass_update(__int64 a1, float a2)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 12) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 >= 0.0 && a2 <= 1.0 )
  {
    result = 0;
    *(float *)(a1 + 16) = a2;
  }
  return result;
}

//----- (00000000000417F0) ----------------------------------------------------
__int64 __fastcall allpass_process(unsigned int *a1, float *a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x10
  unsigned int v6; // w11
  unsigned int v7; // w12
  unsigned __int64 i; // x13
  __int64 v9; // x14
  float v10; // s0
  float v11; // w15
  float v12; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 12) )
    return 9;
  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    v4 = *((_QWORD *)a1 + 3);
    v5 = *((_QWORD *)a1 + 4);
    v7 = a1[1];
    v6 = a1[2];
    for ( i = 0; i < v3; ++i )
    {
      v9 = 4LL * v6;
      v10 = *(float *)(v4 + v9) + (float)((float)(*a2 - *(float *)(v5 + v9)) * *((float *)a1 + 4));
      *(float *)(a3 + 4 * i) = v10;
      *(float *)(v5 + v9) = v10;
      v12 = *a2++;
      v11 = v12;
      if ( v6 + 1 == v7 )
        v6 = 0;
      else
        ++v6;
      *(float *)(v4 + v9) = v11;
    }
    LODWORD(v3) = 0;
    a1[2] = v6;
  }
  return (unsigned int)v3;
}

//----- (0000000000041884) ----------------------------------------------------
__int64 __fastcall allpass_process_inplace(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x9
  __int64 v4; // x10
  unsigned int v5; // w11
  unsigned int v6; // w12
  unsigned __int64 v7; // x13
  __int64 v8; // x14
  __int64 v9; // x15
  float v10; // s1
  float v11; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*((_BYTE *)a1 + 12) )
    return 9;
  v2 = *a1;
  if ( (_DWORD)v2 )
  {
    v3 = *((_QWORD *)a1 + 3);
    v4 = *((_QWORD *)a1 + 4);
    v5 = a1[1];
    v6 = a1[2];
    v7 = 0;
    do
    {
      v8 = 4 * v7;
      v9 = 4LL * v6;
      v10 = *(float *)(a2 + 4 * v7++);
      if ( v6 + 1 == v5 )
        v6 = 0;
      else
        ++v6;
      v11 = *(float *)(v3 + v9) + (float)((float)(v10 - *(float *)(v4 + v9)) * *((float *)a1 + 4));
      *(float *)(a2 + v8) = v11;
      *(float *)(v4 + v9) = v11;
      *(float *)(v3 + v9) = v10;
    }
    while ( v7 < v2 );
    LODWORD(v2) = 0;
    a1[2] = v6;
  }
  return (unsigned int)v2;
}

//----- (0000000000041918) ----------------------------------------------------
long double __fastcall comb_create(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x20u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  return result;
}

//----- (0000000000041970) ----------------------------------------------------
__int64 __fastcall comb_destroy(__int64 *a1)
{
  __int64 v1; // x20
  void *v3; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *a1;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v3 = *(void **)(v1 + 24);
  if ( v3 )
    free(v3);
  *(_QWORD *)(v1 + 24) = 0;
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (00000000000419C4) ----------------------------------------------------
__int64 __fastcall comb_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  memset(*(void **)(a1 + 24), 0, 4LL * *(unsigned int *)(a1 + 8));
  return 0;
}

//----- (0000000000041A10) ----------------------------------------------------
__int64 __fastcall comb_reset(__int64 a1)
{
  void *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v2 = *(void **)(a1 + 24);
  if ( v2 )
    free(v2);
  result = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  return result;
}

//----- (0000000000041A60) ----------------------------------------------------
__int64 __fastcall comb_setup(__int64 a1, int a2, int a3, size_t n, float a5)
{
  __int64 result; // x0
  unsigned int v9; // w20
  void *v10; // x0
  _BOOL4 v11; // w8
  size_t v12; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 != 1 )
    return 1;
  if ( !a3 )
    return 4;
  result = 0xFFFFFFFFLL;
  if ( a5 <= 1.0 )
  {
    v9 = n;
    if ( (unsigned int)n <= 0x800 && a5 >= 0.0 )
    {
      v10 = *(void **)(a1 + 24);
      if ( *(_BYTE *)(a1 + 16) )
      {
        if ( v10 )
          free(v10);
        v10 = 0;
        v11 = 1;
        *(_QWORD *)(a1 + 24) = 0;
      }
      else
      {
        v11 = v10 == 0;
      }
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)(a1 + 8) = v9;
      v12 = 4LL * v9;
      *(float *)(a1 + 20) = a5;
      if ( v11 )
      {
        v10 = malloc(v12);
        *(_QWORD *)(a1 + 24) = v10;
        if ( !v10 )
          exit(1);
      }
      memset(v10, 0, v12);
      memset(*(void **)(a1 + 24), 0, 4LL * *(unsigned int *)(a1 + 8));
      result = 0;
      *(_BYTE *)(a1 + 16) = 1;
      *(float *)(a1 + 20) = a5;
    }
  }
  return result;
}

//----- (0000000000041B68) ----------------------------------------------------
__int64 __fastcall comb_update(__int64 a1, float a2)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 >= 0.0 && a2 <= 1.0 )
  {
    result = 0;
    *(float *)(a1 + 20) = a2;
  }
  return result;
}

//----- (0000000000041BAC) ----------------------------------------------------
__int64 __fastcall comb_process(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  unsigned int v5; // w10
  int v6; // w11
  unsigned __int64 v7; // x12
  __int64 v8; // x13
  float v9; // w14
  __int64 v10; // x15
  float v11; // s0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v3 = *(unsigned int *)(a1 + 4);
  if ( (_DWORD)v3 )
  {
    v4 = *(_QWORD *)(a1 + 24);
    v6 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
    v7 = 0;
    do
    {
      v8 = 4LL * v5;
      v9 = *(float *)(v4 + v8);
      v10 = 4 * v7;
      v11 = *(float *)(a2 + 4 * v7++);
      *(float *)(a3 + v10) = v9;
      if ( v5 + 1 == v6 )
        v5 = 0;
      else
        ++v5;
      *(float *)(v4 + v8) = v11 + (float)(*(float *)(a1 + 20) * v9);
    }
    while ( v7 < v3 );
    LODWORD(v3) = 0;
    *(_DWORD *)(a1 + 12) = v5;
  }
  return (unsigned int)v3;
}

//----- (0000000000041C38) ----------------------------------------------------
__int64 __fastcall comb_process_acc(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  unsigned int v5; // w10
  int v6; // w11
  unsigned __int64 v7; // x12
  __int64 v8; // x14
  __int64 v9; // x13
  float v10; // s0
  float v11; // s1
  float v12; // s2

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 16) )
    return 9;
  v3 = *(unsigned int *)(a1 + 4);
  if ( (_DWORD)v3 )
  {
    v4 = *(_QWORD *)(a1 + 24);
    v6 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
    v7 = 0;
    do
    {
      v8 = 4 * v7;
      v9 = 4LL * v5;
      v10 = *(float *)(a3 + 4 * v7);
      v11 = *(float *)(v4 + v9);
      v12 = *(float *)(a2 + 4 * v7++);
      *(float *)(a3 + v8) = v11 + v10;
      if ( v5 + 1 == v6 )
        v5 = 0;
      else
        ++v5;
      *(float *)(v4 + v9) = v12 + (float)(v11 * *(float *)(a1 + 20));
    }
    while ( v7 < v3 );
    LODWORD(v3) = 0;
    *(_DWORD *)(a1 + 12) = v5;
  }
  return (unsigned int)v3;
}

//----- (0000000000041CC8) ----------------------------------------------------
long double __fastcall spatializer_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0xB8u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[22] = 0;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)v2 = 0u;
  }
  return result;
}

//----- (0000000000041D38) ----------------------------------------------------
__int64 __fastcall spatializer_destroy(__int64 *a1)
{
  _QWORD *v2; // x0
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  sub_41D80(v2);
  result = *a1;
  if ( *a1 )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0000000000041D80) ----------------------------------------------------
void __fastcall sub_41D80(_QWORD *a1)
{
  __int64 *v2; // x0
  __int64 v3; // t1
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void **v14; // x0
  void **v15; // x0
  void **v16; // x0
  void **v17; // x0
  void **v18; // x0
  void **v19; // x0
  void **v20; // x0

  v3 = a1[4];
  v2 = a1 + 4;
  if ( v3 )
    fft_destroy(v2);
  v4 = (void *)a1[5];
  if ( v4 )
  {
    free(v4);
    a1[5] = 0;
  }
  v5 = (void *)a1[6];
  if ( v5 )
  {
    free(v5);
    a1[6] = 0;
  }
  v6 = (void *)a1[10];
  if ( v6 )
  {
    free(v6);
    a1[10] = 0;
  }
  v7 = (void *)a1[11];
  if ( v7 )
  {
    free(v7);
    a1[11] = 0;
  }
  v8 = (void *)a1[12];
  if ( v8 )
  {
    free(v8);
    a1[12] = 0;
  }
  v9 = (void *)a1[7];
  if ( v9 )
  {
    free(v9);
    a1[7] = 0;
  }
  v10 = (void *)a1[8];
  if ( v10 )
  {
    free(v10);
    a1[8] = 0;
  }
  v11 = (void *)a1[9];
  if ( v11 )
  {
    free(v11);
    a1[9] = 0;
  }
  v12 = (void *)a1[13];
  if ( v12 )
  {
    free(v12);
    a1[13] = 0;
  }
  v13 = (void *)a1[15];
  if ( v13 )
  {
    free(v13);
    a1[15] = 0;
  }
  v14 = (void **)a1[16];
  if ( v14 )
  {
    if ( *v14 )
    {
      free(*v14);
      *(_QWORD *)a1[16] = 0;
      v14 = (void **)a1[16];
    }
    if ( v14[1] )
    {
      free(v14[1]);
      *(_QWORD *)(a1[16] + 8LL) = 0;
      v14 = (void **)a1[16];
    }
    if ( v14 )
    {
      free(v14);
      a1[16] = 0;
    }
  }
  v15 = (void **)a1[17];
  if ( v15 )
  {
    if ( *v15 )
    {
      free(*v15);
      *(_QWORD *)a1[17] = 0;
      v15 = (void **)a1[17];
    }
    if ( v15[1] )
    {
      free(v15[1]);
      *(_QWORD *)(a1[17] + 8LL) = 0;
      v15 = (void **)a1[17];
    }
    if ( v15 )
    {
      free(v15);
      a1[17] = 0;
    }
  }
  v16 = (void **)a1[18];
  if ( v16 )
  {
    if ( *v16 )
    {
      free(*v16);
      *(_QWORD *)a1[18] = 0;
      v16 = (void **)a1[18];
    }
    if ( v16[1] )
    {
      free(v16[1]);
      *(_QWORD *)(a1[18] + 8LL) = 0;
      v16 = (void **)a1[18];
    }
    if ( v16 )
    {
      free(v16);
      a1[18] = 0;
    }
  }
  v17 = (void **)a1[19];
  if ( v17 )
  {
    if ( *v17 )
    {
      free(*v17);
      *(_QWORD *)a1[19] = 0;
      v17 = (void **)a1[19];
    }
    if ( v17[1] )
    {
      free(v17[1]);
      *(_QWORD *)(a1[19] + 8LL) = 0;
      v17 = (void **)a1[19];
    }
    if ( v17 )
    {
      free(v17);
      a1[19] = 0;
    }
  }
  v18 = (void **)a1[20];
  if ( v18 )
  {
    if ( *v18 )
    {
      free(*v18);
      *(_QWORD *)a1[20] = 0;
      v18 = (void **)a1[20];
    }
    if ( v18[1] )
    {
      free(v18[1]);
      *(_QWORD *)(a1[20] + 8LL) = 0;
      v18 = (void **)a1[20];
    }
    if ( v18 )
    {
      free(v18);
      a1[20] = 0;
    }
  }
  v19 = (void **)a1[21];
  if ( v19 )
  {
    if ( *v19 )
    {
      free(*v19);
      *(_QWORD *)a1[21] = 0;
      v19 = (void **)a1[21];
    }
    if ( v19[1] )
    {
      free(v19[1]);
      *(_QWORD *)(a1[21] + 8LL) = 0;
      v19 = (void **)a1[21];
    }
    if ( v19 )
    {
      free(v19);
      a1[21] = 0;
    }
  }
  v20 = (void **)a1[22];
  if ( v20 )
  {
    if ( *v20 )
    {
      free(*v20);
      *(_QWORD *)a1[22] = 0;
      v20 = (void **)a1[22];
    }
    if ( v20[1] )
    {
      free(v20[1]);
      *(_QWORD *)(a1[22] + 8LL) = 0;
      v20 = (void **)a1[22];
    }
    if ( v20 )
    {
      free(v20);
      a1[22] = 0;
    }
  }
}

//----- (000000000004205C) ----------------------------------------------------
__int64 __fastcall spatializer_flush(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  sub_42098(a1);
  return 0;
}

//----- (0000000000042098) ----------------------------------------------------
void *__fastcall sub_42098(__int64 a1)
{
  memset(**(void ***)(a1 + 128), 0, 0x1000u);
  memset(**(void ***)(a1 + 136), 0, 0x1000u);
  memset(**(void ***)(a1 + 176), 0, 0x18A0u);
  memset(*(void **)(*(_QWORD *)(a1 + 128) + 8LL), 0, 0x1000u);
  memset(*(void **)(*(_QWORD *)(a1 + 136) + 8LL), 0, 0x1000u);
  memset(*(void **)(*(_QWORD *)(a1 + 176) + 8LL), 0, 0x18A0u);
  memset(*(void **)(a1 + 80), 0, 0x1000u);
  memset(*(void **)(a1 + 88), 0, 0x1000u);
  return memset(*(void **)(a1 + 96), 0, 0x1000u);
}

//----- (0000000000042158) ----------------------------------------------------
__int64 __fastcall spatializer_reset(__int64 a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  sub_41D80((_QWORD *)a1);
  result = 0;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (00000000000421A0) ----------------------------------------------------
__int64 __fastcall spatializer_setup(__int64 a1, int a2, int a3, int a4)
{
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0
  _QWORD *v15; // x0
  _QWORD *v16; // x0
  _QWORD *v17; // x0
  _QWORD *v18; // x0
  _QWORD *v19; // x0
  _QWORD *v20; // x0
  _QWORD *v21; // x0
  __int64 v22; // x20
  void *v23; // x0
  __int64 v24; // x21
  void *v25; // x0
  void *v26; // x0
  __int64 v27; // x21
  void *v28; // x0
  void *v29; // x0
  __int64 v30; // x21
  void *v31; // x0
  void *v32; // x0
  __int64 v33; // x21
  void *v34; // x0
  void *v35; // x0
  __int64 v36; // x21
  void *v37; // x0
  void *v38; // x0
  __int64 v39; // x21
  void *v40; // x0
  void *v41; // x0
  __int64 v42; // x21
  void *v43; // x0
  __int64 v50; // x21
  int32x4_t v51; // q0
  __int64 v52; // x20
  int32x4_t v53; // q0
  int32x4_t v54; // q1
  float v55; // s0
  int32x4_t v56; // q1
  float v57; // s0
  int32x4_t v58; // q1
  float32x4_t v59; // [xsp+0h] [xbp-80h]
  float32x4_t v60; // [xsp+10h] [xbp-70h]
  float32x4_t v61; // [xsp+20h] [xbp-60h]
  int32x4_t v62; // [xsp+30h] [xbp-50h]
  float v63; // [xsp+40h] [xbp-40h]
  int32x4_t v64; // [xsp+40h] [xbp-40h]
  int32x4_t v65; // [xsp+40h] [xbp-40h]
  float32x4_t v66; // [xsp+50h] [xbp-30h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 != 2 )
    return 1;
  if ( a3 != 48000 && a3 != 44100 )
    return 3;
  if ( a4 != 512 )
    return 4;
  if ( *(_BYTE *)(a1 + 24) )
    sub_41D80((_QWORD *)a1);
  *(_DWORD *)a1 = a3;
  fft_create((_QWORD *)(a1 + 32));
  fft_setup(*(_QWORD *)(a1 + 32), 0x400u);
  v6 = *(void **)(a1 + 40);
  if ( !v6 )
  {
    v6 = malloc(0x1000u);
    *(_QWORD *)(a1 + 40) = v6;
    if ( !v6 )
      goto LABEL_63;
  }
  memset(v6, 0, 0x1000u);
  v7 = *(void **)(a1 + 48);
  if ( !v7 )
  {
    v7 = malloc(0x1000u);
    *(_QWORD *)(a1 + 48) = v7;
    if ( !v7 )
      goto LABEL_63;
  }
  memset(v7, 0, 0x1000u);
  v8 = *(void **)(a1 + 80);
  if ( !v8 )
  {
    v8 = malloc(0x1000u);
    *(_QWORD *)(a1 + 80) = v8;
    if ( !v8 )
      goto LABEL_63;
  }
  memset(v8, 0, 0x1000u);
  v9 = *(void **)(a1 + 88);
  if ( !v9 )
  {
    v9 = malloc(0x1000u);
    *(_QWORD *)(a1 + 88) = v9;
    if ( !v9 )
      goto LABEL_63;
  }
  memset(v9, 0, 0x1000u);
  v10 = *(void **)(a1 + 96);
  if ( !v10 )
  {
    v10 = malloc(0x1000u);
    *(_QWORD *)(a1 + 96) = v10;
    if ( !v10 )
      goto LABEL_63;
  }
  memset(v10, 0, 0x1000u);
  v11 = *(void **)(a1 + 56);
  if ( !v11 )
  {
    v11 = malloc(0x1000u);
    *(_QWORD *)(a1 + 56) = v11;
    if ( !v11 )
      goto LABEL_63;
  }
  memset(v11, 0, 0x1000u);
  v12 = *(void **)(a1 + 64);
  if ( !v12 )
  {
    v12 = malloc(0x1000u);
    *(_QWORD *)(a1 + 64) = v12;
    if ( !v12 )
      goto LABEL_63;
  }
  memset(v12, 0, 0x1000u);
  v13 = *(void **)(a1 + 72);
  if ( !v13 )
  {
    v13 = malloc(0x1000u);
    *(_QWORD *)(a1 + 72) = v13;
    if ( !v13 )
      goto LABEL_63;
  }
  memset(v13, 0, 0x1000u);
  v14 = *(void **)(a1 + 120);
  if ( !v14 )
  {
    v14 = malloc(0x1000u);
    *(_QWORD *)(a1 + 120) = v14;
    if ( !v14 )
      goto LABEL_63;
  }
  memset(v14, 0, 0x1000u);
  v15 = *(_QWORD **)(a1 + 128);
  if ( !v15 )
  {
    v15 = malloc(0x10u);
    *(_QWORD *)(a1 + 128) = v15;
    if ( !v15 )
      goto LABEL_63;
  }
  *v15 = 0;
  v15[1] = 0;
  v16 = *(_QWORD **)(a1 + 136);
  if ( !v16 )
  {
    v16 = malloc(0x10u);
    *(_QWORD *)(a1 + 136) = v16;
    if ( !v16 )
      goto LABEL_63;
  }
  *v16 = 0;
  v16[1] = 0;
  v17 = *(_QWORD **)(a1 + 144);
  if ( !v17 )
  {
    v17 = malloc(0x10u);
    *(_QWORD *)(a1 + 144) = v17;
    if ( !v17 )
      goto LABEL_63;
  }
  *v17 = 0;
  v17[1] = 0;
  v18 = *(_QWORD **)(a1 + 152);
  if ( !v18 )
  {
    v18 = malloc(0x10u);
    *(_QWORD *)(a1 + 152) = v18;
    if ( !v18 )
      goto LABEL_63;
  }
  *v18 = 0;
  v18[1] = 0;
  v19 = *(_QWORD **)(a1 + 160);
  if ( !v19 )
  {
    v19 = malloc(0x10u);
    *(_QWORD *)(a1 + 160) = v19;
    if ( !v19 )
      goto LABEL_63;
  }
  *v19 = 0;
  v19[1] = 0;
  v20 = *(_QWORD **)(a1 + 168);
  if ( !v20 )
  {
    v20 = malloc(0x10u);
    *(_QWORD *)(a1 + 168) = v20;
    if ( !v20 )
      goto LABEL_63;
  }
  *v20 = 0;
  v20[1] = 0;
  v21 = *(_QWORD **)(a1 + 176);
  if ( !v21 )
  {
    v21 = malloc(0x10u);
    *(_QWORD *)(a1 + 176) = v21;
    if ( !v21 )
LABEL_63:
      exit(1);
  }
  v22 = 0;
  *v21 = 0;
  v21[1] = 0;
  do
  {
    v24 = *(_QWORD *)(a1 + 128);
    v25 = *(void **)(v24 + v22);
    if ( !v25 )
    {
      v26 = malloc(0x1000u);
      *(_QWORD *)(v24 + v22) = v26;
      if ( !v26 )
        goto LABEL_63;
      v25 = *(void **)(*(_QWORD *)(a1 + 128) + v22);
    }
    memset(v25, 0, 0x1000u);
    v27 = *(_QWORD *)(a1 + 136);
    v28 = *(void **)(v27 + v22);
    if ( !v28 )
    {
      v29 = malloc(0x1000u);
      *(_QWORD *)(v27 + v22) = v29;
      if ( !v29 )
        goto LABEL_63;
      v28 = *(void **)(*(_QWORD *)(a1 + 136) + v22);
    }
    memset(v28, 0, 0x1000u);
    v30 = *(_QWORD *)(a1 + 144);
    v31 = *(void **)(v30 + v22);
    if ( !v31 )
    {
      v32 = malloc(0x1000u);
      *(_QWORD *)(v30 + v22) = v32;
      if ( !v32 )
        goto LABEL_63;
      v31 = *(void **)(*(_QWORD *)(a1 + 144) + v22);
    }
    memset(v31, 0, 0x1000u);
    v33 = *(_QWORD *)(a1 + 152);
    v34 = *(void **)(v33 + v22);
    if ( !v34 )
    {
      v35 = malloc(0x1000u);
      *(_QWORD *)(v33 + v22) = v35;
      if ( !v35 )
        goto LABEL_63;
      v34 = *(void **)(*(_QWORD *)(a1 + 152) + v22);
    }
    memset(v34, 0, 0x1000u);
    v36 = *(_QWORD *)(a1 + 160);
    v37 = *(void **)(v36 + v22);
    if ( !v37 )
    {
      v38 = malloc(0x1000u);
      *(_QWORD *)(v36 + v22) = v38;
      if ( !v38 )
        goto LABEL_63;
      v37 = *(void **)(*(_QWORD *)(a1 + 160) + v22);
    }
    memset(v37, 0, 0x1000u);
    v39 = *(_QWORD *)(a1 + 168);
    v40 = *(void **)(v39 + v22);
    if ( !v40 )
    {
      v41 = malloc(0x1000u);
      *(_QWORD *)(v39 + v22) = v41;
      if ( !v41 )
        goto LABEL_63;
      v40 = *(void **)(*(_QWORD *)(a1 + 168) + v22);
    }
    memset(v40, 0, 0x1000u);
    v42 = *(_QWORD *)(a1 + 176);
    v23 = *(void **)(v42 + v22);
    if ( !v23 )
    {
      v43 = malloc(0x18A0u);
      *(_QWORD *)(v42 + v22) = v43;
      if ( !v43 )
        goto LABEL_63;
      v23 = *(void **)(*(_QWORD *)(a1 + 176) + v22);
    }
    memset(v23, 0, 0x18A0u);
    v22 += 8;
  }
  while ( v22 != 16 );
  sub_42098(a1);
  __asm { FMOV            V0.4S, #1.0 }
  v50 = *(_QWORD *)(a1 + 120);
  v61 = _Q0;
  v51 = (int32x4_t)xmmword_16940;
  v52 = 0;
  v60 = vdupq_n_s32(0x40490FDBu);
  v59 = vdupq_n_s32(0x3A800000u);
  do
  {
    v62 = v51;
    v66 = vmulq_f32(vmulq_f32(vaddq_f32(vcvtq_f32_s32(v51), v61), v60), v59);
    v63 = sinf(v66.n128_f32[1]);
    v53.n128_f32[0] = sinf(v66.n128_f32[0]);
    v54 = v53;
    v54.n128_f32[1] = v63;
    v64 = v54;
    v55 = sinf(v66.n128_f32[2]);
    v56 = v64;
    v56.n128_f32[2] = v55;
    v65 = v56;
    v57 = sinf(v66.n128_f32[3]);
    v58 = v65;
    v58.n128_f32[3] = v57;
    *(int32x4_t *)(v50 + v52) = v58;
    v52 += 16;
    v58.n128_u64[0] = 0x400000004LL;
    v58.n128_u64[1] = 0x400000004LL;
    v51 = vaddq_s32(v62, v58);
  }
  while ( v52 != 4096 );
  *(_BYTE *)(a1 + 24) = 1;
  spatializer_update(a1, 0, 6u);
  return 0;
}
// 42618: variable 'v53' is possibly undefined
// 16940: using guessed type __int128 xmmword_16940;

//----- (00000000000426A0) ----------------------------------------------------
__int64 __fastcall spatializer_update(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // x0
  unsigned int v5; // w9
  int v6; // w10
  const void *v7; // x20
  const void *v8; // x21
  const void *v9; // x1
  float32x2_t *v10; // x3
  const void *v11; // x1
  void *v12; // x8
  _QWORD *v13; // x8
  __int64 v14; // x9
  char *v15; // x8
  unsigned int v16; // w11
  float32x2_t *v17; // x3
  const void *v18; // x1
  unsigned int v19; // w2
  _QWORD *v20; // x8
  __int64 v21; // x9
  char *v22; // x8
  unsigned int v23; // w11
  float32x2_t *v24; // x3
  const void *v25; // x1
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  __int64 v29; // x11
  float32x4_t v30; // q0
  __int64 j; // x10
  __int64 i; // x11
  __int64 v33; // x10
  float32x4_t v34; // q0
  float32x4_t *v35; // x11
  float32x4_t v36; // q2
  float32x4_t *v37; // x11
  float32x4_t v38; // q1
  float32x4_t v39; // q2

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  result = 0xFFFFFFFFLL;
  if ( a2 <= 1 && a3 <= 6 )
  {
    *(_DWORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 12) = a2;
    switch ( a3 )
    {
      case 1u:
      case 4u:
      case 5u:
      case 6u:
        if ( *(_DWORD *)a1 == 44100 )
          v5 = 38;
        else
          v5 = 40;
        goto LABEL_9;
      case 2u:
        v5 = 10;
LABEL_9:
        *(_DWORD *)(a1 + 4) = v5;
        break;
      default:
        v5 = *(_DWORD *)(a1 + 4);
        break;
    }
    v6 = *(_DWORD *)a1;
    *(int32x2_t *)(a1 + 16) = vadd_s32(vdup_n_s32(v5), (int32x2_t)0x40000000600LL);
    if ( v6 == 44100 )
    {
      switch ( a3 )
      {
        case 1u:
        case 4u:
          if ( a2 )
          {
            v7 = &kDir44b;
            v8 = &kAmbC44b;
            v9 = &kAmbI44b;
          }
          else
          {
            v7 = &kDir44;
            v8 = &kAmbC44;
            v9 = &kAmbI44;
          }
LABEL_39:
          sub_43BF4(a1, v9, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, v8, 0x200u, *(float32x2_t **)(a1 + 64));
          sub_43BF4(a1, v7, 0x200u, *(float32x2_t **)(a1 + 72));
          v12 = &kWinGateMovie;
          goto LABEL_48;
        case 2u:
          sub_43BF4(a1, &kHrirI44, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, &kHrirC44, 0x200u, *(float32x2_t **)(a1 + 64));
          v10 = *(float32x2_t **)(a1 + 72);
          v11 = &kFilt2d44;
LABEL_24:
          sub_43BF4(a1, v11, 0x3Du, v10);
          v12 = &kWinGateMusic;
          goto LABEL_48;
        case 5u:
          if ( a2 == 1 )
          {
            sub_43BF4(a1, &kAmbI44b, 0x200u, *(float32x2_t **)(a1 + 56));
            sub_43BF4(a1, &kAmbC44b, 0x200u, *(float32x2_t **)(a1 + 64));
            v24 = *(float32x2_t **)(a1 + 72);
            v25 = &kDir44b;
LABEL_43:
            sub_43BF4(a1, v25, 0x200u, v24);
          }
          else
          {
            sub_43BF4(a1, &kAmbI44, 0x200u, *(float32x2_t **)(a1 + 56));
            sub_43BF4(a1, &kAmbC44, 0x200u, *(float32x2_t **)(a1 + 64));
            v20 = *(_QWORD **)(a1 + 72);
            v21 = 4;
            *v20 = 0x3F8000003F7F7443LL;
            v22 = (char *)v20 + 12;
            do
            {
              v23 = *(_DWORD *)((char *)&kVoiceFilter44k + v21);
              v21 += 4;
              *(_QWORD *)(v22 - 4) = v23;
              v22 += 8;
            }
            while ( v21 != 2048 );
          }
LABEL_44:
          v12 = &kWinGateVoice;
          goto LABEL_48;
        case 6u:
          if ( a2 != 1 )
          {
            sub_43BF4(a1, &kAmbI44, 0x200u, *(float32x2_t **)(a1 + 56));
            sub_43BF4(a1, &kAmbC44, 0x200u, *(float32x2_t **)(a1 + 64));
            v17 = *(float32x2_t **)(a1 + 72);
            v18 = &kFilt2d44;
            v19 = 61;
            goto LABEL_47;
          }
          sub_43BF4(a1, &kAmbI44b, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, &kAmbC44b, 0x200u, *(float32x2_t **)(a1 + 64));
          v17 = *(float32x2_t **)(a1 + 72);
          v18 = &kDir44b;
          break;
        default:
          goto LABEL_49;
      }
    }
    else
    {
      if ( v6 != 48000 )
      {
LABEL_49:
        if ( *(_DWORD *)(a1 + 8) != 5 )
          return 0;
        v26 = *(_QWORD *)(a1 + 56);
        v27 = *(_QWORD *)(a1 + 64);
        if ( *(_DWORD *)(a1 + 12) == 1 )
        {
          v28 = *(_QWORD *)(a1 + 72);
          if ( v26 < v27 + 4096 && v27 < v26 + 4096
            || v26 < v28 + 4096 && v28 < v26 + 4096
            || v27 < v28 + 4096 && v28 < v27 + 4096 )
          {
            for ( i = 0; i != 4096; i += 4 )
            {
              result = 0;
              *(float *)(v26 + i) = *(float *)(v26 + i) * 0.9;
              *(float *)(v27 + i) = *(float *)(v27 + i) * 0.9;
              *(float *)(v28 + i) = *(float *)(v28 + i) * 0.9;
            }
          }
          else
          {
            v29 = 0;
            v30 = vdupq_n_s32(0x3F666666u);
            do
            {
              result = 0;
              *(float32x4_t *)(v26 + v29) = vmulq_f32(*(float32x4_t *)(v26 + v29), v30);
              *(float32x4_t *)(v27 + v29) = vmulq_f32(*(float32x4_t *)(v27 + v29), v30);
              *(float32x4_t *)(v28 + v29) = vmulq_f32(*(float32x4_t *)(v28 + v29), v30);
              v29 += 16;
            }
            while ( v29 != 4096 );
          }
        }
        else if ( v26 >= v27 + 4096 || v27 >= v26 + 4096 )
        {
          v33 = 0;
          v34 = vdupq_n_s32(0x3F666666u);
          do
          {
            v35 = (float32x4_t *)(v26 + v33);
            result = 0;
            v36 = vmulq_f32(*(float32x4_t *)(v26 + v33 + 16), v34);
            *v35 = vmulq_f32(*(float32x4_t *)(v26 + v33), v34);
            v35[1] = v36;
            v37 = (float32x4_t *)(v27 + v33);
            v38 = *(float32x4_t *)(v27 + v33);
            v39 = *(float32x4_t *)(v27 + v33 + 16);
            v33 += 32;
            *v37 = vmulq_f32(v38, v34);
            v37[1] = vmulq_f32(v39, v34);
          }
          while ( v33 != 4096 );
        }
        else
        {
          for ( j = 0; j != 4096; j += 4 )
          {
            result = 0;
            *(float *)(v26 + j) = *(float *)(v26 + j) * 0.9;
            *(float *)(v27 + j) = *(float *)(v27 + j) * 0.9;
          }
        }
        return result;
      }
      switch ( a3 )
      {
        case 1u:
        case 4u:
          if ( a2 )
          {
            v7 = &kDir48b;
            v8 = &kAmbC48b;
            v9 = &kAmbI48b;
          }
          else
          {
            v7 = &kDir48;
            v8 = &kAmbC48;
            v9 = &kAmbI48;
          }
          goto LABEL_39;
        case 2u:
          sub_43BF4(a1, &kHrirI48, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, &kHrirC48, 0x200u, *(float32x2_t **)(a1 + 64));
          v10 = *(float32x2_t **)(a1 + 72);
          v11 = &kFilt2d48;
          goto LABEL_24;
        case 5u:
          if ( a2 == 1 )
          {
            sub_43BF4(a1, &kAmbI48b, 0x200u, *(float32x2_t **)(a1 + 56));
            sub_43BF4(a1, &kAmbC48b, 0x200u, *(float32x2_t **)(a1 + 64));
            v24 = *(float32x2_t **)(a1 + 72);
            v25 = &kDir48b;
            goto LABEL_43;
          }
          sub_43BF4(a1, &kAmbI48, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, &kAmbC48, 0x200u, *(float32x2_t **)(a1 + 64));
          v13 = *(_QWORD **)(a1 + 72);
          v14 = 4;
          *v13 = 0x3F8000003F7F7443LL;
          v15 = (char *)v13 + 12;
          do
          {
            v16 = *(_DWORD *)((char *)&kVoiceFilter48k + v14);
            v14 += 4;
            *(_QWORD *)(v15 - 4) = v16;
            v15 += 8;
          }
          while ( v14 != 2048 );
          goto LABEL_44;
        case 6u:
          if ( a2 != 1 )
          {
            sub_43BF4(a1, &kAmbI48, 0x200u, *(float32x2_t **)(a1 + 56));
            sub_43BF4(a1, &kAmbC48, 0x200u, *(float32x2_t **)(a1 + 64));
            v17 = *(float32x2_t **)(a1 + 72);
            v18 = &kFilt2d48;
            v19 = 61;
            goto LABEL_47;
          }
          sub_43BF4(a1, &kAmbI48b, 0x200u, *(float32x2_t **)(a1 + 56));
          sub_43BF4(a1, &kAmbC48b, 0x200u, *(float32x2_t **)(a1 + 64));
          v17 = *(float32x2_t **)(a1 + 72);
          v18 = &kDir48b;
          break;
        default:
          goto LABEL_49;
      }
    }
    v19 = 512;
LABEL_47:
    sub_43BF4(a1, v18, v19, v17);
    v12 = &kWinGateAuto;
LABEL_48:
    *(_QWORD *)(a1 + 112) = v12;
    goto LABEL_49;
  }
  return result;
}
// 42770: conditional instruction was optimized away because w1.4==1
// 427C8: conditional instruction was optimized away because w1.4==1
// 42894: conditional instruction was optimized away because w1.4==0
// 42908: conditional instruction was optimized away because w1.4==0
// 42958: conditional instruction was optimized away because w1.4==0
// 429CC: conditional instruction was optimized away because w1.4==0

//----- (0000000000042D6C) ----------------------------------------------------
__int64 __fastcall spatializer_process(__int64 a1, const float *a2, __int64 a3)
{
  _QWORD *v4; // x9
  __int64 v6; // x10
  const float *v7; // x11
  _DWORD *v8; // x8
  _OWORD *v9; // x12
  __int128 v10; // q0
  unsigned __int128 v11; // q0
  int v12; // w11
  int v13; // w10
  int v14; // w11
  int v15; // w10
  int v16; // w11
  int v17; // w10
  _DWORD *v18; // x9
  __int64 v19; // x10
  _OWORD *v20; // x11
  const float *v21; // x12
  unsigned __int128 v22; // q0
  int v23; // w11
  int v24; // w12
  int v25; // w10
  int v26; // w11
  int v27; // w10
  int v28; // w10
  char *v29; // x1
  unsigned __int64 v30; // x9
  __int64 v31; // x10
  _DWORD *v32; // x8
  unsigned __int64 v33; // x9
  float32x4_t v34; // q0
  float32x4_t v35; // q1
  float32x4_t v36; // q2
  float32x4_t v37; // q3
  float32x4_t *v38; // x13
  __int64 i; // x10
  unsigned __int64 v41; // x8
  char *v42; // x1
  unsigned __int64 v43; // x9
  __int64 v44; // x10
  unsigned __int64 v45; // x9
  unsigned __int64 v46; // x8
  float32x4_t v47; // q0
  float32x4_t v48; // q1
  float32x4_t v49; // q2
  float32x4_t v50; // q3
  float32x4_t *v51; // x13
  __int64 j; // x10
  float32x2_t v53; // d6
  __int128 v54; // q7
  __int128 v55; // q17
  char **v56; // x6
  float32x2_t **v57; // x10
  __int64 *v58; // x1
  __int64 v59; // x9
  __int64 v60; // x12
  __int64 v61; // x11
  float32x2_t *v62; // x4
  float32x2_t *v63; // x5
  __int64 v64; // x2
  __int64 v65; // x3
  char *v66; // x1
  char *v67; // x6
  __int64 v68; // x8
  __int128 v69; // q16
  __int64 v70; // x7
  float32x2_t v71; // d2
  float32x2_t v72; // d3
  float v73; // s5
  float v74; // s4
  float32x2_t *v75; // x21
  __int128 v76; // q18
  __int64 v77; // x22
  float v78; // s18
  float v79; // s18
  int v80; // w22
  float32x2_t *v81; // x22
  float *v82; // x22
  float v83; // s16
  __int64 v84; // x23
  __int64 v85; // x24
  __int64 v86; // x25
  __int64 v87; // x26
  unsigned int v88; // w22
  __int64 *v89; // x8
  int v90; // w14
  unsigned __int64 v91; // x9
  __int64 v92; // x10
  unsigned __int64 v93; // x11
  unsigned __int64 v94; // x12
  unsigned int v95; // w13
  unsigned __int64 v96; // x1
  unsigned __int64 v97; // x21
  bool v98; // w22
  _BOOL4 v99; // w17
  _BOOL4 v100; // w5
  _BOOL4 v101; // w0
  _BOOL4 v102; // w6
  bool v103; // w1
  __int64 m; // x14
  __int64 v105; // x16
  float32x4_t v106; // q0
  float32x4_t v107; // q1
  __int64 k; // x14
  __int64 v109; // x17
  float v110; // s0
  float v111; // s1
  __int64 v112; // x9
  int *v113; // x10
  int v114; // w11
  int v115; // w12
  _DWORD *v116; // x13
  int v117; // w13
  unsigned __int64 v118; // x9
  __int64 v119; // x8
  unsigned __int64 v120; // x10
  unsigned __int64 v121; // x11
  unsigned int v122; // w12
  unsigned __int64 v123; // x0
  unsigned __int64 v124; // x7
  bool v125; // w20
  _BOOL4 v126; // w16
  _BOOL4 v127; // w4
  _BOOL4 v128; // w17
  _BOOL4 v129; // w5
  bool v130; // w0
  __int64 ii; // x13
  __int64 v132; // x15
  float32x4_t v133; // q0
  float32x4_t v134; // q1
  __int64 n; // x13
  __int64 v136; // x16
  float v137; // s0
  float v138; // s1
  __int64 v139; // x9
  _DWORD *v140; // x10
  int v141; // w11
  int v142; // w12

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  v4 = *(_QWORD **)(a1 + 128);
  v6 = 0;
  v7 = a2;
  v8 = (_DWORD *)*v4;
  do
  {
    v9 = &v8[v6];
    v10 = *(_OWORD *)&v8[v6 + 512];
    v6 += 4;
    *v9 = v10;
    v11 = (unsigned __int128)vld2q_f32(v7);
    v7 += 8;
    v9[128] = v11;
  }
  while ( v6 != 508 );
  v12 = v8[1021];
  v8[508] = v8[1020];
  v13 = *((_DWORD *)a2 + 1016);
  v8[509] = v12;
  v14 = v8[1022];
  v8[1020] = v13;
  v15 = *((_DWORD *)a2 + 1018);
  v8[510] = v14;
  v16 = v8[1023];
  v8[1021] = v15;
  v17 = *((_DWORD *)a2 + 1020);
  v8[511] = v16;
  v8[1022] = v17;
  v8[1023] = *((_DWORD *)a2 + 1022);
  v18 = (_DWORD *)v4[1];
  v19 = 1;
  v20 = v18;
  do
  {
    v21 = &a2[v19];
    v19 += 8;
    *v20 = v20[128];
    v22 = (unsigned __int128)vld2q_f32(v21);
    v20[128] = v22;
    ++v20;
  }
  while ( v19 != 1017 );
  v23 = v18[1021];
  v24 = v18[1022];
  v18[508] = v18[1020];
  v25 = *((_DWORD *)a2 + 1017);
  v18[509] = v23;
  v26 = v18[1023];
  v18[1020] = v25;
  v27 = *((_DWORD *)a2 + 1019);
  v18[510] = v24;
  v18[1021] = v27;
  v28 = *((_DWORD *)a2 + 1021);
  v18[511] = v26;
  v18[1022] = v28;
  v18[1023] = *((_DWORD *)a2 + 1023);
  v29 = *(char **)(a1 + 40);
  v30 = *(_QWORD *)(a1 + 120);
  if ( v29 < (char *)v8 + 4096 && v8 < (_DWORD *)v29 + 1024
    || (unsigned __int64)v29 < v30 + 4096 && v30 < (unsigned __int64)(v29 + 4096) )
  {
    for ( i = 0; i != 1024; ++i )
      *(float *)&v29[i * 4] = *(float *)&v8[i] * *(float *)(v30 + i * 4);
  }
  else
  {
    v31 = 0;
    v32 = v8 + 4;
    v33 = v30 + 16;
    do
    {
      v34 = *(float32x4_t *)&v32[v31 - 4];
      v35 = *(float32x4_t *)&v32[v31];
      v36 = *(float32x4_t *)(v33 + v31 * 4 - 16);
      v37 = *(float32x4_t *)(v33 + v31 * 4);
      v38 = (float32x4_t *)&v29[v31 * 4];
      v31 += 8;
      *v38 = vmulq_f32(v34, v36);
      v38[1] = vmulq_f32(v35, v37);
    }
    while ( v31 != 1024 );
  }
  fft_forward_ordered(*(_QWORD *)(a1 + 32), v29, **(void ***)(a1 + 136));
  v41 = *(_QWORD *)(a1 + 120);
  v42 = *(char **)(a1 + 40);
  v43 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8LL);
  if ( (unsigned __int64)v42 < v43 + 4096 && v43 < (unsigned __int64)(v42 + 4096)
    || (unsigned __int64)v42 < v41 + 4096 && v41 < (unsigned __int64)(v42 + 4096) )
  {
    for ( j = 0; j != 4096; j += 4 )
      *(float *)&v42[j] = *(float *)(v43 + j) * *(float *)(v41 + j);
  }
  else
  {
    v44 = 0;
    v45 = v43 + 16;
    v46 = v41 + 16;
    do
    {
      v47 = *(float32x4_t *)(v45 + v44 - 16);
      v48 = *(float32x4_t *)(v45 + v44);
      v49 = *(float32x4_t *)(v46 + v44 - 16);
      v50 = *(float32x4_t *)(v46 + v44);
      v51 = (float32x4_t *)&v42[v44];
      v44 += 32;
      *v51 = vmulq_f32(v47, v49);
      v51[1] = vmulq_f32(v48, v50);
    }
    while ( v44 != 4096 );
  }
  fft_forward_ordered(*(_QWORD *)(a1 + 32), v42, *(void **)(*(_QWORD *)(a1 + 136) + 8LL));
  v57 = *(float32x2_t ***)(a1 + 136);
  v56 = *(char ***)(a1 + 144);
  v58 = *(__int64 **)(a1 + 152);
  v60 = *(_QWORD *)(a1 + 64);
  v59 = *(_QWORD *)(a1 + 72);
  v61 = *(_QWORD *)(a1 + 56);
  v62 = *v57;
  v63 = v57[1];
  v64 = *v58;
  v65 = v58[1];
  v66 = *v56;
  v67 = v56[1];
  v68 = 0;
  LODWORD(v69) = 0;
  LODWORD(v70) = 1;
  v71.n64_u64[0] = vdup_n_s32(0x3F19999Au).n64_u64[0];
  v72.n64_u64[0] = vdup_n_s32(0x3ECCCCCDu).n64_u64[0];
  v73 = 1.0;
  v74 = 1.0;
  v75 = v63;
  LODWORD(v76) = 0;
  do
  {
    v80 = v70;
    LODWORD(v70) = v68 & 0x7FFFFFFE;
    if ( v68 == 1 )
      v70 = 1;
    else
      v70 = (unsigned int)v70;
    if ( v80 == (_DWORD)v70 )
    {
      v55 = v76;
      goto LABEL_25;
    }
    if ( (_DWORD)v70 )
    {
      if ( v68 == 1 )
        goto LABEL_32;
    }
    else
    {
      v53.n64_u64[0] = vmul_f32((float32x2_t)v62->n64_u64[0], (float32x2_t)v62->n64_u64[0]).n64_u64[0];
      (*(float32x2_t **)(a1 + 80))->n64_u64[0] = vadd_f32(
                                                   vmul_f32(v53, v72),
                                                   vmul_f32((float32x2_t)(*(float32x2_t **)(a1 + 80))->n64_u64[0], v71)).n64_u64[0];
      v75 = v57[1];
      v82 = *(float **)(a1 + 88);
      v83 = v82[1];
      *v82 = (float)(*v82 * 0.6) + (float)((float)(v62->n64_f32[0] * v75->n64_f32[0]) * 0.4);
      v82[1] = (float)(v83 * 0.6) + (float)((float)(v62->n64_f32[1] * v75->n64_f32[1]) * 0.4);
      *(float32x2_t *)&v54 = vmul_f32((float32x2_t)v75->n64_u64[0], (float32x2_t)v75->n64_u64[0]);
      (*(float32x2_t **)(a1 + 96))->n64_u64[0] = vadd_f32(
                                                   vmul_f32(*(float32x2_t *)&v54, v72),
                                                   vmul_f32((float32x2_t)(*(float32x2_t **)(a1 + 96))->n64_u64[0], v71)).n64_u64[0];
      *(float *)&v76 = fabsf(v82[1]);
      if ( v68 == 1 )
      {
LABEL_32:
        v55 = v76;
        LODWORD(v69) = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * v70);
        v81 = (float32x2_t *)(*(_QWORD *)(a1 + 80) + 4 * v70);
        goto LABEL_35;
      }
    }
    v84 = 4 * v70;
    v53.n64_u64[0] = *(unsigned __int64 *)((char *)v62 + 4 * v70);
    v85 = (unsigned int)(v70 + 1);
    *(float32x2_t *)&v69 = vmul_n_f32(v53, v53.n64_f32[0]);
    v81 = (float32x2_t *)(*(_QWORD *)(a1 + 80) + 4 * v70);
    v54 = v69;
    LODWORD(v54) = vmuls_lane_f32(v53.n64_f32[1], v53, 1);
    v53.n64_u32[0] = vadd_f32(*(float32x2_t *)&v69, *(float32x2_t *)&v54).n64_u32[0];
    v81->n64_u64[0] = vadd_f32(
                        vmul_f32((float32x2_t)v81->n64_u64[0], v71),
                        vmul_f32(
                          (float32x2_t)__PAIR64__(
                                         vsub_f32(*(float32x2_t *)&v69, *(float32x2_t *)&v54).n64_u32[1],
                                         v53.n64_u32[0]),
                          v72)).n64_u64[0];
    v86 = *(_QWORD *)(a1 + 88);
    *(float *)(v86 + v84) = (float)(*(float *)(v86 + 4 * v70) * 0.6)
                          + (float)((float)((float)(v62->n64_f32[v70] * v75->n64_f32[v70])
                                          + (float)(v62->n64_f32[v85] * v75->n64_f32[v85]))
                                  * 0.4);
    *(float *)(v86 + v85 * 4) = (float)(*(float *)(v86 + v85 * 4) * 0.6)
                              + (float)((float)((float)(v62->n64_f32[v85] * v75->n64_f32[v70])
                                              - (float)(v62->n64_f32[v70] * v75->n64_f32[v85]))
                                      * 0.4);
    *(float32x2_t *)&v54 = *(float32x2_t *)((char *)v75 + 4 * v70);
    v87 = *(_QWORD *)(a1 + 96);
    *(float32x2_t *)&v55 = vmul_n_f32(*(float32x2_t *)&v54, *(float *)&v54);
    v69 = v55;
    LODWORD(v69) = vmuls_lane_f32(*((float *)&v54 + 1), *(float32x2_t *)&v54, 1);
    *(float32x2_t *)&v54 = vadd_f32(*(float32x2_t *)&v55, *(float32x2_t *)&v69);
    *(float32x2_t *)&v69 = vsub_f32(*(float32x2_t *)&v55, *(float32x2_t *)&v69);
    v55 = v54;
    DWORD1(v55) = DWORD1(v69);
    *(float32x2_t *)&v76 = vmul_f32(*(float32x2_t *)(v87 + 4 * v70), v71);
    *(float32x2_t *)&v69 = vadd_f32(*(float32x2_t *)&v76, vmul_f32(*(float32x2_t *)&v55, v72));
    *(_QWORD *)(v87 + v84) = v69;
    *(float *)&v76 = sqrtf(
                       (float)(*(float *)(v86 + 4 * v70) * *(float *)(v86 + 4 * v70))
                     + (float)(*(float *)(v86 + v85 * 4) * *(float *)(v86 + v85 * 4)));
    LODWORD(v55) = 0;
LABEL_35:
    *(float *)&v76 = (float)((float)((float)(*(float *)&v76 + 0.00001)
                                   / (float)(sqrtf(v81->n64_f32[0] * *(float *)&v69) + 0.00001))
                           * 100.0)
                   + -0.5;
    LODWORD(v69) = 1120272384;
    if ( *(float *)&v76 <= 99.0 )
    {
      LODWORD(v69) = 0;
      if ( *(float *)&v76 >= 0.0 )
        v69 = v76;
    }
    v88 = *(_DWORD *)(a1 + 8);
    LODWORD(v69) = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4LL * (unsigned int)*(float *)&v69);
    if ( v88 <= 6 && ((1 << v88) & 0x72) != 0 )
    {
      if ( v53.n64_f32[0] <= *(float *)&v54 )
      {
        if ( v53.n64_f32[0] < *(float *)&v54 )
        {
          v74 = (float)(v53.n64_f32[0] + 0.00001) / (float)(*(float *)&v54 + 0.00001);
          v73 = 1.0;
        }
      }
      else
      {
        v73 = (float)(*(float *)&v54 + 0.00001) / (float)(v53.n64_f32[0] + 0.00001);
        v74 = 1.0;
      }
    }
LABEL_25:
    v77 = 4 * v68;
    v78 = v62->n64_f32[v68++];
    *(float *)&v66[v77] = (float)(v78 * *(float *)(v61 + 4 * v70))
                        - (float)((float)(v73 * (float)(*(float *)&v69 * v78))
                                * (float)(*(float *)(v61 + 4 * v70) - *(float *)(v59 + 4 * v70)));
    *(float *)(v65 + v77) = (float)(v62->n64_f32[(unsigned __int64)v77 / 4]
                                  - (float)(v73 * (float)(*(float *)&v69 * v78)))
                          * *(float *)(v60 + 4 * v70);
    v79 = v63->n64_f32[(unsigned __int64)v77 / 4];
    *(float *)&v67[v77] = (float)(v79 * *(float *)(v61 + 4 * v70))
                        - (float)((float)(v74 * (float)(*(float *)&v69 * v79))
                                * (float)(*(float *)(v61 + 4 * v70) - *(float *)(v59 + 4 * v70)));
    *(float *)(v64 + v77) = (float)(v63->n64_f32[(unsigned __int64)v77 / 4]
                                  - (float)(v74 * (float)(*(float *)&v69 * v79)))
                          * *(float *)(v60 + 4 * v70);
    v76 = v55;
  }
  while ( v68 != 1024 );
  fft_backward_ordered(*(_QWORD *)(a1 + 32), v66, **(_QWORD **)(a1 + 160));
  fft_backward_ordered(*(_QWORD *)(a1 + 32), **(const void ***)(a1 + 152), **(_QWORD **)(a1 + 168));
  fft_backward_ordered(
    *(_QWORD *)(a1 + 32),
    *(const void **)(*(_QWORD *)(a1 + 144) + 8LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL));
  fft_backward_ordered(
    *(_QWORD *)(a1 + 32),
    *(const void **)(*(_QWORD *)(a1 + 152) + 8LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8LL));
  memmove(
    **(void ***)(a1 + 176),
    (const void *)(**(_QWORD **)(a1 + 176) + 2048LL),
    4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 512));
  memset((void *)(**(_QWORD **)(a1 + 176) + 4LL * *(unsigned int *)(a1 + 20)), 0, 0x800u);
  v89 = *(__int64 **)(a1 + 176);
  v90 = *(_DWORD *)(a1 + 4);
  v91 = *(_QWORD *)(a1 + 120);
  v92 = *v89;
  v93 = **(_QWORD **)(a1 + 160);
  v94 = **(_QWORD **)(a1 + 168);
  v95 = v90 + 512;
  if ( v90 + 1535 < (unsigned int)(v90 + 512) )
    goto LABEL_55;
  v96 = v92 + 4LL * v95;
  v97 = v96 + 4096;
  v98 = v92 + 2048 < v96 + 4096 && v96 < v92 + 6144;
  v99 = v96 < v93 + 4096;
  v100 = v93 < v96 + 4096;
  v101 = v96 < v91 + 4096;
  v102 = v91 < v96 + 4096;
  v103 = v96 < v94 + 4096;
  if ( v98
    || v92 + 2048 < v93 + 4096 && v93 < v92 + 6144
    || v92 + 2048 < v91 + 4096 && v91 < v92 + 6144
    || v92 + 2048 < v94 + 4096 && v94 < v92 + 6144
    || v99 && v100
    || v101 && v102
    || v103 && v94 < v97 )
  {
LABEL_55:
    for ( k = 0; k != 1024; ++k )
    {
      v109 = 4LL * (v95 + (unsigned int)k);
      *(float *)(v92 + 2048 + 4 * k) = *(float *)(v92 + 2048 + 4 * k)
                                     + (float)(*(float *)(v93 + 4 * k) * *(float *)(v91 + 4 * k));
      v110 = *(float *)(v94 + 4 * k);
      v111 = *(float *)(v91 + 4 * k);
      *(float *)(v92 + v109) = *(float *)(v92 + v109) + (float)(v110 * v111);
    }
  }
  else
  {
    for ( m = 0; m != 4096; m += 16 )
    {
      v105 = 4LL * v95;
      *(float32x4_t *)(v92 + 2048 + m) = vaddq_f32(
                                           *(float32x4_t *)(v92 + 2048 + m),
                                           vmulq_f32(*(float32x4_t *)(v93 + m), *(float32x4_t *)(v91 + m)));
      v106 = *(float32x4_t *)(v94 + m);
      v107 = *(float32x4_t *)(v91 + m);
      v95 += 4;
      *(float32x4_t *)(v92 + v105) = vaddq_f32(*(float32x4_t *)(v92 + v105), vmulq_f32(v106, v107));
    }
  }
  v112 = 0;
  v113 = (int *)(v92 + 4);
  do
  {
    v114 = *(v113 - 1);
    v115 = *v113;
    v116 = (_DWORD *)(a3 + v112);
    v112 += 16;
    v113 += 2;
    *v116 = v114;
    v116[2] = v115;
  }
  while ( v112 != 4096 );
  memmove((void *)v89[1], (const void *)(v89[1] + 2048), 4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 512));
  memset((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8LL) + 4LL * *(unsigned int *)(a1 + 20)), 0, 0x800u);
  v117 = *(_DWORD *)(a1 + 4);
  v118 = *(_QWORD *)(a1 + 120);
  v119 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8LL);
  v120 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL);
  v121 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8LL);
  v122 = v117 + 512;
  if ( v117 + 1535 < (unsigned int)(v117 + 512) )
    goto LABEL_70;
  v123 = v119 + 4LL * v122;
  v124 = v123 + 4096;
  v125 = v119 + 2048 < v123 + 4096 && v123 < v119 + 6144;
  v126 = v123 < v120 + 4096;
  v127 = v120 < v123 + 4096;
  v128 = v123 < v118 + 4096;
  v129 = v118 < v123 + 4096;
  v130 = v123 < v121 + 4096;
  if ( v125
    || v119 + 2048 < v120 + 4096 && v120 < v119 + 6144
    || v119 + 2048 < v118 + 4096 && v118 < v119 + 6144
    || v119 + 2048 < v121 + 4096 && v121 < v119 + 6144
    || v126 && v127
    || v128 && v129
    || v130 && v121 < v124 )
  {
LABEL_70:
    for ( n = 0; n != 1024; ++n )
    {
      v136 = 4LL * (v122 + (unsigned int)n);
      *(float *)(v119 + 2048 + 4 * n) = *(float *)(v119 + 2048 + 4 * n)
                                      + (float)(*(float *)(v120 + 4 * n) * *(float *)(v118 + 4 * n));
      v137 = *(float *)(v121 + 4 * n);
      v138 = *(float *)(v118 + 4 * n);
      *(float *)(v119 + v136) = *(float *)(v119 + v136) + (float)(v137 * v138);
    }
  }
  else
  {
    for ( ii = 0; ii != 4096; ii += 16 )
    {
      v132 = 4LL * v122;
      *(float32x4_t *)(v119 + 2048 + ii) = vaddq_f32(
                                             *(float32x4_t *)(v119 + 2048 + ii),
                                             vmulq_f32(*(float32x4_t *)(v120 + ii), *(float32x4_t *)(v118 + ii)));
      v133 = *(float32x4_t *)(v121 + ii);
      v134 = *(float32x4_t *)(v118 + ii);
      v122 += 4;
      *(float32x4_t *)(v119 + v132) = vaddq_f32(*(float32x4_t *)(v119 + v132), vmulq_f32(v133, v134));
    }
  }
  v139 = 0;
  v140 = (_DWORD *)(a3 + 12);
  do
  {
    v142 = *(_DWORD *)(v119 + v139);
    v141 = *(_DWORD *)(v119 + v139 + 4);
    v139 += 8;
    *(v140 - 2) = v142;
    *v140 = v141;
    v140 += 4;
  }
  while ( v139 != 2048 );
  return 0;
}
// 4305C: variable 'v76' is possibly undefined
// 431F0: variable 'v69' is possibly undefined
// 4329C: variable 'v55' is possibly undefined
// 43354: variable 'v53' is possibly undefined
// 43354: variable 'v54' is possibly undefined

//----- (00000000000437E8) ----------------------------------------------------
__int64 __fastcall spatializer_bypass(__int64 a1, _DWORD *a2, __int64 a3)
{
  _QWORD *v4; // x8
  __int64 v6; // x10
  _DWORD *v7; // x9
  _OWORD *v8; // x11
  const float *v9; // x12
  unsigned __int128 v10; // q0
  int v11; // w11
  int v12; // w10
  int v13; // w11
  int v14; // w10
  int v15; // w11
  int v16; // w10
  _DWORD *v17; // x8
  __int64 v18; // x9
  _OWORD *v19; // x10
  const float *v20; // x11
  unsigned __int128 v21; // q0
  int v22; // w10
  int v23; // w9
  int v24; // w10
  int v25; // w9
  int v26; // w10
  int v27; // w9
  __int64 *v28; // x8
  unsigned __int64 v29; // x10
  __int64 v30; // x9
  unsigned __int64 v31; // x11
  unsigned __int64 v32; // x12
  unsigned __int64 v33; // x15
  __int64 v34; // x12
  __int64 v35; // x13
  unsigned __int64 v36; // x11
  float32x4_t v37; // q0
  float32x4_t v38; // q1
  float32x4_t v39; // q3
  float32x4_t v40; // q4
  float32x4_t *v41; // x14
  float32x4_t v42; // q2
  float32x4_t v43; // q5
  __int64 i; // x13
  __int64 v46; // x10
  int *v47; // x9
  int v48; // w11
  int v49; // w12
  _DWORD *v50; // x13
  unsigned __int64 v51; // x9
  __int64 v52; // x8
  unsigned __int64 v53; // x10
  __int64 v54; // x11
  __int64 v55; // x12
  unsigned __int64 v56; // x10
  float32x4_t v57; // q0
  float32x4_t v58; // q1
  float32x4_t v59; // q3
  float32x4_t v60; // q4
  float32x4_t *v61; // x13
  float32x4_t v62; // q2
  float32x4_t v63; // q5
  __int64 j; // x12
  __int64 v65; // x9
  _DWORD *v66; // x10
  int v67; // w11
  int v68; // w12

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  v4 = *(_QWORD **)(a1 + 128);
  v6 = 0;
  v7 = (_DWORD *)*v4;
  v8 = (_OWORD *)*v4;
  do
  {
    v9 = (const float *)&a2[v6];
    v6 += 8;
    *v8 = v8[128];
    v10 = (unsigned __int128)vld2q_f32(v9);
    v8[128] = v10;
    ++v8;
  }
  while ( v6 != 1016 );
  v11 = v7[1021];
  v7[508] = v7[1020];
  v12 = a2[1016];
  v7[509] = v11;
  v13 = v7[1022];
  v7[1020] = v12;
  v14 = a2[1018];
  v7[510] = v13;
  v15 = v7[1023];
  v7[1021] = v14;
  v16 = a2[1020];
  v7[511] = v15;
  v7[1022] = v16;
  v7[1023] = a2[1022];
  v17 = (_DWORD *)v4[1];
  v18 = 1;
  v19 = v17;
  do
  {
    v20 = (const float *)&a2[v18];
    v18 += 8;
    *v19 = v19[128];
    v21 = (unsigned __int128)vld2q_f32(v20);
    v19[128] = v21;
    ++v19;
  }
  while ( v18 != 1017 );
  v22 = v17[1021];
  v17[508] = v17[1020];
  v23 = a2[1017];
  v17[509] = v22;
  v24 = v17[1022];
  v17[1020] = v23;
  v25 = a2[1019];
  v17[510] = v24;
  v26 = v17[1023];
  v17[1021] = v25;
  v27 = a2[1021];
  v17[511] = v26;
  v17[1022] = v27;
  v17[1023] = a2[1023];
  memmove(
    **(void ***)(a1 + 176),
    (const void *)(**(_QWORD **)(a1 + 176) + 2048LL),
    4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 512));
  memset((void *)(**(_QWORD **)(a1 + 176) + 4LL * *(unsigned int *)(a1 + 20)), 0, 0x800u);
  v28 = *(__int64 **)(a1 + 176);
  v29 = *(_QWORD *)(a1 + 120);
  v30 = *v28;
  v31 = **(_QWORD **)(a1 + 128);
  v32 = *v28 + 2048;
  v33 = *v28 + 6144;
  if ( v32 < v31 + 4096 && v31 < v33 || v32 < v29 + 4096 && v29 < v33 )
  {
    for ( i = 0; i != 4096; i += 4 )
      *(float *)(v32 + i) = *(float *)(v32 + i)
                          + (float)(*(float *)(v29 + i) * (float)(*(float *)(v31 + i) * *(float *)(v29 + i)));
  }
  else
  {
    v34 = 0;
    v35 = v30 + 2064;
    v36 = v31 + 16;
    do
    {
      v37 = *(float32x4_t *)(v36 + v34 - 16);
      v38 = *(float32x4_t *)(v36 + v34);
      v39 = *(float32x4_t *)(v29 + v34);
      v40 = *(float32x4_t *)(v29 + v34 + 16);
      v41 = (float32x4_t *)(v35 + v34);
      v42 = *(float32x4_t *)(v35 + v34 - 16);
      v43 = *(float32x4_t *)(v35 + v34);
      v34 += 32;
      v41[-1] = vaddq_f32(v42, vmulq_f32(v39, vmulq_f32(v37, v39)));
      *v41 = vaddq_f32(v43, vmulq_f32(v40, vmulq_f32(v38, v40)));
    }
    while ( v34 != 4096 );
  }
  v46 = 0;
  v47 = (int *)(v30 + 4);
  do
  {
    v48 = *(v47 - 1);
    v49 = *v47;
    v50 = (_DWORD *)(a3 + v46);
    v46 += 16;
    v47 += 2;
    *v50 = v48;
    v50[2] = v49;
  }
  while ( v46 != 4096 );
  memmove((void *)v28[1], (const void *)(v28[1] + 2048), 4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 512));
  memset((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8LL) + 4LL * *(unsigned int *)(a1 + 20)), 0, 0x800u);
  v51 = *(_QWORD *)(a1 + 120);
  v52 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8LL);
  v53 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8LL);
  if ( v52 + 2048 < v53 + 4096 && v53 < v52 + 6144 || v52 + 2048 < v51 + 4096 && v51 < v52 + 6144 )
  {
    for ( j = 0; j != 4096; j += 4 )
      *(float *)(v52 + 2048 + j) = *(float *)(v52 + 2048 + j)
                                 + (float)(*(float *)(v51 + j) * (float)(*(float *)(v53 + j) * *(float *)(v51 + j)));
  }
  else
  {
    v54 = 0;
    v55 = v52 + 2064;
    v56 = v53 + 16;
    do
    {
      v57 = *(float32x4_t *)(v56 + v54 - 16);
      v58 = *(float32x4_t *)(v56 + v54);
      v59 = *(float32x4_t *)(v51 + v54);
      v60 = *(float32x4_t *)(v51 + v54 + 16);
      v61 = (float32x4_t *)(v55 + v54);
      v62 = *(float32x4_t *)(v55 + v54 - 16);
      v63 = *(float32x4_t *)(v55 + v54);
      v54 += 32;
      v61[-1] = vaddq_f32(v62, vmulq_f32(v59, vmulq_f32(v57, v59)));
      *v61 = vaddq_f32(v63, vmulq_f32(v60, vmulq_f32(v58, v60)));
    }
    while ( v54 != 4096 );
  }
  v65 = 0;
  v66 = (_DWORD *)(a3 + 12);
  do
  {
    v68 = *(_DWORD *)(v52 + v65);
    v67 = *(_DWORD *)(v52 + v65 + 4);
    v65 += 8;
    *(v66 - 2) = v68;
    *v66 = v67;
    v66 += 4;
  }
  while ( v65 != 2048 );
  return 0;
}

//----- (0000000000043B64) ----------------------------------------------------
__int64 __fastcall spatializer_offSetting(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 24) )
    return 9;
  memset(*(void **)(a1 + 80), 0, 0x1000u);
  memset(*(void **)(a1 + 88), 0, 0x1000u);
  memset(*(void **)(a1 + 96), 0, 0x1000u);
  return 0;
}

//----- (0000000000043BD0) ----------------------------------------------------
__int64 __fastcall spatializer_delay_sample_count(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0

  result = 0xFFFFFFFFLL;
  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      *a2 += 1024;
    }
  }
  return result;
}

//----- (0000000000043BF4) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall sub_43BF4(__int64 a1, const void *a2, unsigned int a3, float32x2_t *a4)
{
  float32x2_t *v8; // x8
  __int64 v9; // x9
  __int128 v10; // q1 OVERLAPPED
  float32x4_t v11; // q2
  float32x4_t v12; // q3
  float *v13; // x10
  int32x4_t v14; // q2
  int32x4_t v15; // q3
  float32x4_t v16; // q0
  float v17; // s0
  float v18; // s1
  float v19; // s0
  float v20; // s1
  float v21; // s0
  float v22; // s1
  float result; // s0

  memset(*(void **)(a1 + 40), 0, 0x1000u);
  memset(*(void **)(a1 + 48), 0, 0x1000u);
  memcpy(*(void **)(a1 + 40), a2, 4LL * a3);
  fft_forward_ordered(*(_QWORD *)(a1 + 32), *(const void **)(a1 + 40), *(void **)(a1 + 48));
  v8 = *(float32x2_t **)(a1 + 48);
  v9 = 1;
  a4->n64_u64[0] = vabs_f32((float32x2_t)v8->n64_u64[0]).n64_u64[0];
  v10 = 0u;
  do
  {
    v12 = *(float32x4_t *)v8[v9].n64_u64;
    v11 = *(float32x4_t *)v8[v9 + 2].n64_u64;
    v13 = (float *)&a4[v9];
    v9 += 4;
    v14 = vmulq_f32(v11, v11);
    v15 = vmulq_f32(v12, v12);
    v16 = vsqrtq_f32(vaddq_f32(vuzp1q_s32(v15, v14), vuzp2q_s32(v15, v14)));
    vst2q_f32(v13, *(float32x4x2_t *)(&v10 - 1));
  }
  while ( v9 != 509 );
  v17 = v8[509].n64_f32[0];
  v18 = v8[509].n64_f32[1];
  a4[509].n64_u32[1] = 0;
  a4[509].n64_f32[0] = sqrtf((float)(v17 * v17) + (float)(v18 * v18));
  v19 = v8[510].n64_f32[0];
  v20 = v8[510].n64_f32[1];
  a4[510].n64_u32[1] = 0;
  a4[510].n64_f32[0] = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
  v21 = v8[511].n64_f32[0];
  v22 = v8[511].n64_f32[1];
  a4[511].n64_u32[1] = 0;
  result = sqrtf((float)(v21 * v21) + (float)(v22 * v22));
  a4[511].n64_f32[0] = result;
  return result;
}
// 43BF4: fragmented variable at q1.16 may be wrong

//----- (0000000000043D10) ----------------------------------------------------
long double __fastcall fft_create(_QWORD *a1)
{
  _QWORD *v2; // x0
  long double result; // q0

  if ( a1 && !*a1 )
  {
    v2 = malloc(0x28u);
    *a1 = v2;
    if ( !v2 )
      exit(1);
    *(_OWORD *)&result = 0u;
    v2[4] = 0;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
  }
  return result;
}

//----- (0000000000043D6C) ----------------------------------------------------
__int64 __fastcall fft_destroy(__int64 *a1)
{
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  result = *a1;
  if ( !result )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(result + 24) )
  {
    pffft_destroy_setup(*(_QWORD **)(result + 24));
    *(_QWORD *)(*a1 + 24) = 0;
    result = *a1;
  }
  if ( *(_QWORD *)result )
  {
    pffft_aligned_free(*(_QWORD *)result);
    *(_QWORD *)*a1 = 0;
    result = *a1;
  }
  if ( *(_QWORD *)(result + 16) )
  {
    pffft_aligned_free(*(_QWORD *)(result + 16));
    *(_QWORD *)(*a1 + 16) = 0;
    result = *a1;
  }
  if ( *(_QWORD *)(result + 8) )
  {
    pffft_aligned_free(*(_QWORD *)(result + 8));
    *(_QWORD *)(*a1 + 8) = 0;
    result = *a1;
  }
  if ( result )
  {
    free((void *)result);
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0000000000043E1C) ----------------------------------------------------
unsigned __int64 __fastcall fft_setup(__int64 a1, unsigned int a2)
{
  __int64 v3; // x19
  unsigned __int64 result; // x0

  *(_DWORD *)(a1 + 32) = a2;
  *(float *)(a1 + 36) = 1.0 / (float)a2;
  v3 = 4LL * a2;
  *(_QWORD *)(a1 + 24) = pffft_new_setup(a2, 0);
  *(_QWORD *)a1 = pffft_aligned_malloc(v3);
  *(_QWORD *)(a1 + 8) = pffft_aligned_malloc(v3);
  result = pffft_aligned_malloc(v3);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (0000000000043E8C) ----------------------------------------------------
void *__fastcall fft_forward(__int64 a1, const void *a2, void *a3)
{
  long double v5; // q0
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  long double v9; // q4

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_transform(
    *(_QWORD *)(a1 + 24),
    *(float32x4_t **)a1,
    *(float32x4_t **)(a1 + 8),
    *(float32x4_t **)(a1 + 16),
    0,
    v5,
    v6,
    v7,
    v8,
    v9);
  return memcpy(a3, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 43EBC: variable 'v5' is possibly undefined
// 43EBC: variable 'v6' is possibly undefined
// 43EBC: variable 'v7' is possibly undefined
// 43EBC: variable 'v8' is possibly undefined
// 43EBC: variable 'v9' is possibly undefined

//----- (0000000000043EDC) ----------------------------------------------------
void *__fastcall fft_forward_inplace(__int64 a1, void *a2)
{
  long double v4; // q0
  long double v5; // q1
  long double v6; // q2
  long double v7; // q3
  long double v8; // q4

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_transform(
    *(_QWORD *)(a1 + 24),
    *(float32x4_t **)a1,
    *(float32x4_t **)(a1 + 8),
    *(float32x4_t **)(a1 + 16),
    0,
    v4,
    v5,
    v6,
    v7,
    v8);
  return memcpy(a2, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 43F0C: variable 'v4' is possibly undefined
// 43F0C: variable 'v5' is possibly undefined
// 43F0C: variable 'v6' is possibly undefined
// 43F0C: variable 'v7' is possibly undefined
// 43F0C: variable 'v8' is possibly undefined

//----- (0000000000043F2C) ----------------------------------------------------
int8x16_t __fastcall fft_forward_aligned(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        long double a8)
{
  return pffft_transform(*(_QWORD *)(a1 + 24), a2, a3, (float32x4_t *)*(_QWORD *)(a1 + 16), 0, a4, a5, a6, a7, a8);
}

//----- (0000000000043F38) ----------------------------------------------------
float __fastcall fft_backward(__int64 a1, const void *a2, unsigned __int64 a3)
{
  long double v5; // q0
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  long double v9; // q4
  int8x16_t v10; // q0
  unsigned __int64 v11; // x8
  float32x4_t *v12; // x9
  const float *v13; // x10
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x14
  float32x4_t *v16; // x12
  float32x4_t *v17; // x13
  unsigned __int64 v18; // x14
  float32x4_t v19; // q1
  float32x4_t v20; // q2
  __int64 v21; // x12
  float v22; // s1

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  v10.n128_u32[0] = pffft_transform(
                      *(_QWORD *)(a1 + 24),
                      (float32x4_t *)*(_QWORD *)a1,
                      (float32x4_t *)*(_QWORD *)(a1 + 8),
                      (float32x4_t *)*(_QWORD *)(a1 + 16),
                      1,
                      v5,
                      v6,
                      v7,
                      v8,
                      v9).n128_u32[0];
  v11 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v11 )
  {
    v12 = *(float32x4_t **)(a1 + 8);
    v13 = (const float *)(a1 + 36);
    v14 = 0;
    if ( (unsigned int)v11 <= 7 )
      goto LABEL_12;
    v15 = a3 + 4 * v11;
    if ( a1 + 37 > a3 && (unsigned __int64)v13 < v15 )
      goto LABEL_12;
    if ( (unsigned __int64)v12->n128_u64 + 4 * v11 > a3 && (unsigned __int64)v12 < v15 )
      goto LABEL_12;
    v10 = vld1q_dup_f32(v13);
    v14 = (unsigned int)v11 & 0xFFFFFFF8;
    v16 = v12 + 1;
    v17 = (float32x4_t *)(a3 + 16);
    v18 = v14;
    do
    {
      v19 = v16[-1];
      v20 = *v16;
      v16 += 2;
      v18 -= 8LL;
      v17[-1] = vmulq_f32(v10, v19);
      *v17 = vmulq_f32(v10, v20);
      v17 += 2;
    }
    while ( v18 );
    if ( v14 != v11 )
    {
LABEL_12:
      do
      {
        v21 = 4 * v14;
        v22 = v12->n128_f32[v14++];
        v10.n128_f32[0] = *v13 * v22;
        *(_DWORD *)(a3 + v21) = v10.n128_u32[0];
      }
      while ( v14 < v11 );
    }
  }
  return v10.n128_f32[0];
}
// 43F68: variable 'v5' is possibly undefined
// 43F68: variable 'v6' is possibly undefined
// 43F68: variable 'v7' is possibly undefined
// 43F68: variable 'v8' is possibly undefined
// 43F68: variable 'v9' is possibly undefined

//----- (0000000000044030) ----------------------------------------------------
float __fastcall fft_backward_inplace(__int64 a1, float32x4_t *a2)
{
  long double v4; // q0
  long double v5; // q1
  long double v6; // q2
  long double v7; // q3
  long double v8; // q4
  int8x16_t v9; // q0
  unsigned __int64 v10; // x8
  float32x4_t *v11; // x9
  const float *v12; // x10
  unsigned __int64 v13; // x11
  const float *v14; // x14
  float32x4_t *v15; // x12
  float32x4_t *v16; // x13
  unsigned __int64 v17; // x14
  float32x4_t v18; // q1
  float32x4_t v19; // q2
  __int64 v20; // x12
  float v21; // s1

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  v9.n128_u32[0] = pffft_transform(
                     *(_QWORD *)(a1 + 24),
                     (float32x4_t *)*(_QWORD *)a1,
                     (float32x4_t *)*(_QWORD *)(a1 + 8),
                     (float32x4_t *)*(_QWORD *)(a1 + 16),
                     1,
                     v4,
                     v5,
                     v6,
                     v7,
                     v8).n128_u32[0];
  v10 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v10 )
  {
    v11 = *(float32x4_t **)(a1 + 8);
    v12 = (const float *)(a1 + 36);
    v13 = 0;
    if ( (unsigned int)v10 <= 7 )
      goto LABEL_12;
    v14 = (const float *)a2 + v10;
    if ( a1 + 37 > (unsigned __int64)a2 && v12 < v14 )
      goto LABEL_12;
    if ( (float32x4_t *)((char *)v11 + 4 * v10) > a2 && v11 < (float32x4_t *)v14 )
      goto LABEL_12;
    v9 = vld1q_dup_f32(v12);
    v13 = (unsigned int)v10 & 0xFFFFFFF8;
    v15 = v11 + 1;
    v16 = a2 + 1;
    v17 = v13;
    do
    {
      v18 = v15[-1];
      v19 = *v15;
      v15 += 2;
      v17 -= 8LL;
      v16[-1] = vmulq_f32(v9, v18);
      *v16 = vmulq_f32(v9, v19);
      v16 += 2;
    }
    while ( v17 );
    if ( v13 != v10 )
    {
LABEL_12:
      do
      {
        v20 = v13;
        v21 = v11->n128_f32[v13++];
        v9.n128_f32[0] = *v12 * v21;
        a2->n128_u32[v20] = v9.n128_u32[0];
      }
      while ( v13 < v10 );
    }
  }
  return v9.n128_f32[0];
}
// 44060: variable 'v4' is possibly undefined
// 44060: variable 'v5' is possibly undefined
// 44060: variable 'v6' is possibly undefined
// 44060: variable 'v7' is possibly undefined
// 44060: variable 'v8' is possibly undefined

//----- (0000000000044128) ----------------------------------------------------
void __fastcall fft_backward_aligned(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        long double a8)
{
  unsigned __int64 v10; // x8
  const float *v11; // x9
  unsigned __int64 i; // x10
  __int64 v13; // x11
  float v14; // s1
  float32x4_t v15; // q0
  float32x4_t *v16; // x11
  unsigned __int64 v17; // x12
  float32x4_t v18; // q2

  pffft_transform(*(_QWORD *)(a1 + 24), a2, a3, *(float32x4_t **)(a1 + 16), 1, a4, a5, a6, a7, a8);
  v10 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v10 )
  {
    v11 = (const float *)(a1 + 36);
    if ( (unsigned int)v10 <= 7 || a1 + 37 > (unsigned __int64)a3 && v11 < (const float *)a3 + v10 )
    {
      for ( i = 0; i < v10; ++i )
      {
LABEL_6:
        v13 = i;
        v14 = a3->n128_f32[i];
        a3->n128_f32[v13] = *v11 * v14;
      }
      return;
    }
    v15 = vld1q_dup_f32(v11);
    i = (unsigned int)v10 & 0xFFFFFFF8;
    v16 = a3 + 1;
    v17 = i;
    do
    {
      v17 -= 8LL;
      v18 = vmulq_f32(v15, *v16);
      v16[-1] = vmulq_f32(v15, v16[-1]);
      *v16 = v18;
      v16 += 2;
    }
    while ( v17 );
    if ( i != v10 )
      goto LABEL_6;
  }
}

//----- (00000000000441DC) ----------------------------------------------------
void *__fastcall fft_forward_ordered(__int64 a1, const void *a2, void *a3)
{
  long double v5; // q0
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  long double v9; // q4

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_transform_ordered(
    *(_QWORD *)(a1 + 24),
    *(float32x4_t **)a1,
    *(float32x4_t **)(a1 + 8),
    *(float32x4_t **)(a1 + 16),
    0,
    v5,
    v6,
    v7,
    v8,
    v9);
  return memcpy(a3, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 4420C: variable 'v5' is possibly undefined
// 4420C: variable 'v6' is possibly undefined
// 4420C: variable 'v7' is possibly undefined
// 4420C: variable 'v8' is possibly undefined
// 4420C: variable 'v9' is possibly undefined

//----- (000000000004422C) ----------------------------------------------------
void *__fastcall fft_forward_ordered_inplace(__int64 a1, void *a2)
{
  long double v4; // q0
  long double v5; // q1
  long double v6; // q2
  long double v7; // q3
  long double v8; // q4

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_transform_ordered(
    *(_QWORD *)(a1 + 24),
    *(float32x4_t **)a1,
    *(float32x4_t **)(a1 + 8),
    *(float32x4_t **)(a1 + 16),
    0,
    v4,
    v5,
    v6,
    v7,
    v8);
  return memcpy(a2, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 4425C: variable 'v4' is possibly undefined
// 4425C: variable 'v5' is possibly undefined
// 4425C: variable 'v6' is possibly undefined
// 4425C: variable 'v7' is possibly undefined
// 4425C: variable 'v8' is possibly undefined

//----- (000000000004427C) ----------------------------------------------------
int8x16_t __fastcall fft_forward_ordered_aligned(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        long double a8)
{
  return pffft_transform_ordered(
           *(_QWORD *)(a1 + 24),
           a2,
           a3,
           (float32x4_t *)*(_QWORD *)(a1 + 16),
           0,
           a4,
           a5,
           a6,
           a7,
           a8);
}

//----- (0000000000044288) ----------------------------------------------------
float __fastcall fft_backward_ordered(__int64 a1, const void *a2, unsigned __int64 a3)
{
  long double v5; // q0
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  long double v9; // q4
  int8x16_t v10; // q0
  unsigned __int64 v11; // x8
  float32x4_t *v12; // x9
  const float *v13; // x10
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x14
  float32x4_t *v16; // x12
  float32x4_t *v17; // x13
  unsigned __int64 v18; // x14
  float32x4_t v19; // q1
  float32x4_t v20; // q2
  __int64 v21; // x12
  float v22; // s1

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  v10.n128_u32[0] = pffft_transform_ordered(
                      *(_QWORD *)(a1 + 24),
                      (float32x4_t *)*(_QWORD *)a1,
                      (float32x4_t *)*(_QWORD *)(a1 + 8),
                      (float32x4_t *)*(_QWORD *)(a1 + 16),
                      1,
                      v5,
                      v6,
                      v7,
                      v8,
                      v9).n128_u32[0];
  v11 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v11 )
  {
    v12 = *(float32x4_t **)(a1 + 8);
    v13 = (const float *)(a1 + 36);
    v14 = 0;
    if ( (unsigned int)v11 <= 7 )
      goto LABEL_12;
    v15 = a3 + 4 * v11;
    if ( a1 + 37 > a3 && (unsigned __int64)v13 < v15 )
      goto LABEL_12;
    if ( (unsigned __int64)v12->n128_u64 + 4 * v11 > a3 && (unsigned __int64)v12 < v15 )
      goto LABEL_12;
    v10 = vld1q_dup_f32(v13);
    v14 = (unsigned int)v11 & 0xFFFFFFF8;
    v16 = v12 + 1;
    v17 = (float32x4_t *)(a3 + 16);
    v18 = v14;
    do
    {
      v19 = v16[-1];
      v20 = *v16;
      v16 += 2;
      v18 -= 8LL;
      v17[-1] = vmulq_f32(v10, v19);
      *v17 = vmulq_f32(v10, v20);
      v17 += 2;
    }
    while ( v18 );
    if ( v14 != v11 )
    {
LABEL_12:
      do
      {
        v21 = 4 * v14;
        v22 = v12->n128_f32[v14++];
        v10.n128_f32[0] = *v13 * v22;
        *(_DWORD *)(a3 + v21) = v10.n128_u32[0];
      }
      while ( v14 < v11 );
    }
  }
  return v10.n128_f32[0];
}
// 442B8: variable 'v5' is possibly undefined
// 442B8: variable 'v6' is possibly undefined
// 442B8: variable 'v7' is possibly undefined
// 442B8: variable 'v8' is possibly undefined
// 442B8: variable 'v9' is possibly undefined

//----- (0000000000044380) ----------------------------------------------------
float __fastcall fft_backward_ordered_inplace(__int64 a1, float32x4_t *a2)
{
  long double v4; // q0
  long double v5; // q1
  long double v6; // q2
  long double v7; // q3
  long double v8; // q4
  int8x16_t v9; // q0
  unsigned __int64 v10; // x8
  float32x4_t *v11; // x9
  const float *v12; // x10
  unsigned __int64 v13; // x11
  const float *v14; // x14
  float32x4_t *v15; // x12
  float32x4_t *v16; // x13
  unsigned __int64 v17; // x14
  float32x4_t v18; // q1
  float32x4_t v19; // q2
  __int64 v20; // x12
  float v21; // s1

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  v9.n128_u32[0] = pffft_transform_ordered(
                     *(_QWORD *)(a1 + 24),
                     (float32x4_t *)*(_QWORD *)a1,
                     (float32x4_t *)*(_QWORD *)(a1 + 8),
                     (float32x4_t *)*(_QWORD *)(a1 + 16),
                     1,
                     v4,
                     v5,
                     v6,
                     v7,
                     v8).n128_u32[0];
  v10 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v10 )
  {
    v11 = *(float32x4_t **)(a1 + 8);
    v12 = (const float *)(a1 + 36);
    v13 = 0;
    if ( (unsigned int)v10 <= 7 )
      goto LABEL_12;
    v14 = (const float *)a2 + v10;
    if ( a1 + 37 > (unsigned __int64)a2 && v12 < v14 )
      goto LABEL_12;
    if ( (float32x4_t *)((char *)v11 + 4 * v10) > a2 && v11 < (float32x4_t *)v14 )
      goto LABEL_12;
    v9 = vld1q_dup_f32(v12);
    v13 = (unsigned int)v10 & 0xFFFFFFF8;
    v15 = v11 + 1;
    v16 = a2 + 1;
    v17 = v13;
    do
    {
      v18 = v15[-1];
      v19 = *v15;
      v15 += 2;
      v17 -= 8LL;
      v16[-1] = vmulq_f32(v9, v18);
      *v16 = vmulq_f32(v9, v19);
      v16 += 2;
    }
    while ( v17 );
    if ( v13 != v10 )
    {
LABEL_12:
      do
      {
        v20 = v13;
        v21 = v11->n128_f32[v13++];
        v9.n128_f32[0] = *v12 * v21;
        a2->n128_u32[v20] = v9.n128_u32[0];
      }
      while ( v13 < v10 );
    }
  }
  return v9.n128_f32[0];
}
// 443B0: variable 'v4' is possibly undefined
// 443B0: variable 'v5' is possibly undefined
// 443B0: variable 'v6' is possibly undefined
// 443B0: variable 'v7' is possibly undefined
// 443B0: variable 'v8' is possibly undefined

//----- (0000000000044478) ----------------------------------------------------
void __fastcall fft_backward_ordered_aligned(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        long double a8)
{
  unsigned __int64 v10; // x8
  const float *v11; // x9
  unsigned __int64 i; // x10
  __int64 v13; // x11
  float v14; // s1
  float32x4_t v15; // q0
  float32x4_t *v16; // x11
  unsigned __int64 v17; // x12
  float32x4_t v18; // q2

  pffft_transform_ordered(*(_QWORD *)(a1 + 24), a2, a3, *(float32x4_t **)(a1 + 16), 1, a4, a5, a6, a7, a8);
  v10 = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)v10 )
  {
    v11 = (const float *)(a1 + 36);
    if ( (unsigned int)v10 <= 7 || a1 + 37 > (unsigned __int64)a3 && v11 < (const float *)a3 + v10 )
    {
      for ( i = 0; i < v10; ++i )
      {
LABEL_6:
        v13 = i;
        v14 = a3->n128_f32[i];
        a3->n128_f32[v13] = *v11 * v14;
      }
      return;
    }
    v15 = vld1q_dup_f32(v11);
    i = (unsigned int)v10 & 0xFFFFFFF8;
    v16 = a3 + 1;
    v17 = i;
    do
    {
      v17 -= 8LL;
      v18 = vmulq_f32(v15, *v16);
      v16[-1] = vmulq_f32(v15, v16[-1]);
      *v16 = v18;
      v16 += 2;
    }
    while ( v17 );
    if ( i != v10 )
      goto LABEL_6;
  }
}

//----- (000000000004452C) ----------------------------------------------------
void *__fastcall fft_convolve(__int64 a1, const void *a2, const void *a3, void *a4)
{
  double v7; // d0

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  memcpy(*(void **)(a1 + 16), a3, 4LL * *(unsigned int *)(a1 + 32));
  memset(*(void **)(a1 + 8), 0, 4LL * *(unsigned int *)(a1 + 32));
  LODWORD(v7) = 1.0;
  pffft_zconvolve_accumulate(*(_QWORD *)(a1 + 24), *(float **)a1, *(float **)(a1 + 16), *(float **)(a1 + 8), v7);
  return memcpy(a4, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 4458C: variable 'v7' is possibly undefined

//----- (00000000000445B0) ----------------------------------------------------
float __fastcall fft_convolve_aligned(__int64 a1, float *a2, float *a3, void *s)
{
  double v8; // d0

  memset(s, 0, 4LL * *(unsigned int *)(a1 + 32));
  LODWORD(v8) = 1.0;
  return pffft_zconvolve_accumulate(*(_QWORD *)(a1 + 24), a2, a3, (float *)s, v8);
}
// 44604: variable 'v8' is possibly undefined

//----- (0000000000044608) ----------------------------------------------------
void *__fastcall fft_convolve_acc(__int64 a1, const void *a2, const void *a3, void *a4)
{
  double v7; // d0

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  memcpy(*(void **)(a1 + 16), a3, 4LL * *(unsigned int *)(a1 + 32));
  memcpy(*(void **)(a1 + 8), a4, 4LL * *(unsigned int *)(a1 + 32));
  LODWORD(v7) = 1.0;
  pffft_zconvolve_accumulate(*(_QWORD *)(a1 + 24), *(float **)a1, *(float **)(a1 + 16), *(float **)(a1 + 8), v7);
  return memcpy(a4, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 44668: variable 'v7' is possibly undefined

//----- (000000000004468C) ----------------------------------------------------
float __fastcall fft_convolve_acc_aligned(__int64 a1, float *a2, float *a3, float *a4, double a5)
{
  LODWORD(a5) = 1.0;
  return pffft_zconvolve_accumulate(*(_QWORD *)(a1 + 24), a2, a3, a4, a5);
}

//----- (0000000000044698) ----------------------------------------------------
void *__fastcall fft_forward_reorder(__int64 a1, const void *a2, void *a3)
{
  int8x16_t v5; // q0

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_zreorder(*(int **)(a1 + 24), *(int32x4_t **)a1, *(int8x16_t **)(a1 + 8), 0, v5);
  return memcpy(a3, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 446C8: variable 'v5' is possibly undefined

//----- (00000000000446E8) ----------------------------------------------------
int8x16_t __fastcall fft_forward_reorder_aligned(__int64 a1, int32x4_t *a2, int8x16_t *a3, int8x16_t a4)
{
  return pffft_zreorder((int *)*(_QWORD *)(a1 + 24), a2, a3, 0, a4);
}

//----- (00000000000446F4) ----------------------------------------------------
void *__fastcall fft_backward_reorder(__int64 a1, const void *a2, void *a3)
{
  int8x16_t v5; // q0

  memcpy(*(void **)a1, a2, 4LL * *(unsigned int *)(a1 + 32));
  pffft_zreorder(*(int **)(a1 + 24), *(int32x4_t **)a1, *(int8x16_t **)(a1 + 8), 1, v5);
  return memcpy(a3, *(const void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 32));
}
// 44724: variable 'v5' is possibly undefined

//----- (0000000000044744) ----------------------------------------------------
int8x16_t __fastcall fft_backward_reorder_aligned(__int64 a1, int32x4_t *a2, int8x16_t *a3, int8x16_t a4)
{
  return pffft_zreorder((int *)*(_QWORD *)(a1 + 24), a2, a3, 1, a4);
}

//----- (0000000000044750) ----------------------------------------------------
__int64 __fastcall fft_get_size(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (000000000004475C) ----------------------------------------------------
void *__fastcall fft_shift(char *a1, char *dest, unsigned int a3)
{
  size_t v4; // x21
  size_t v5; // x22

  v4 = 4LL * ((a3 + 1) >> 1);
  v5 = 4LL * (a3 >> 1);
  memcpy(dest, &a1[v4], v5);
  return memcpy(&dest[v5], a1, v4);
}

//----- (00000000000447B4) ----------------------------------------------------
void *__fastcall fft_shift_inplace(void **a1, char *a2, unsigned int a3)
{
  __int64 v6; // x10
  size_t v7; // x19
  __int64 v8; // x22

  memcpy(*a1, a2, 4LL * a3);
  v6 = a3 >> 1;
  v7 = 4LL * ((a3 + 1) >> 1);
  v8 = 4 * v6;
  memcpy(a2, (char *)*a1 + v7, 4 * v6);
  return memcpy(&a2[v8], *a1, v7);
}

//----- (0000000000044824) ----------------------------------------------------
__int64 validate_pffft_simd()
{
  printf("VZERO=[%2g %2g %2g %2g]\n", 0.0, 0.0, 0.0, 0.0);
  printf("VADD(4:7,8:11)=[%2g %2g %2g %2g]\n", 12.0, 14.0, 16.0, 18.0);
  printf("VMUL(4:7,8:11)=[%2g %2g %2g %2g]\n", 32.0, 45.0, 60.0, 77.0);
  printf("VMADD(4:7,8:11,0:3)=[%2g %2g %2g %2g]\n", 32.0, 46.0, 62.0, 80.0);
  printf("INTERLEAVE2(4:7,8:11)=[%2g %2g %2g %2g] [%2g %2g %2g %2g]\n", 4.0, 8.0, 5.0, 9.0, 6.0, 10.0, 7.0, 11.0);
  printf("UNINTERLEAVE2(4:7,8:11)=[%2g %2g %2g %2g] [%2g %2g %2g %2g]\n", 4.0, 6.0, 8.0, 10.0, 5.0, 7.0, 9.0, 11.0);
  printf("LD_PS1(15)=[%2g %2g %2g %2g]\n", 15.0, 15.0, 15.0, 15.0);
  printf("VSWAPHL(4:7,8:11)=[%2g %2g %2g %2g]\n", 8.0, 9.0, 6.0, 7.0);
  return printf(
           "VTRANSPOSE4(0:3,4:7,8:11,12:15)=[%2g %2g %2g %2g] [%2g %2g %2g %2g] [%2g %2g %2g %2g] [%2g %2g %2g %2g]\n",
           0.0,
           4.0,
           8.0,
           12.0,
           1.0,
           5.0,
           9.0,
           13.0,
           2.0,
           6.0,
           10.0,
           14.0,
           3.0,
           7.0,
           11.0,
           15.0);
}

//----- (0000000000044A00) ----------------------------------------------------
unsigned __int64 __fastcall pffft_aligned_malloc(__int64 a1)
{
  unsigned __int64 result; // x0
  unsigned __int64 v2; // x8

  result = (unsigned __int64)malloc(a1 + 64);
  if ( result )
  {
    v2 = result;
    result = (result + 64) & 0xFFFFFFFFFFFFFFC0LL;
    *(_QWORD *)(result - 8) = v2;
  }
  return result;
}

//----- (0000000000044A2C) ----------------------------------------------------
void __fastcall pffft_aligned_free(__int64 a1)
{
  if ( a1 )
    free(*(void **)(a1 - 8));
}

//----- (0000000000044A3C) ----------------------------------------------------
__int64 pffft_simd_size()
{
  return 4;
}

//----- (0000000000044A44) ----------------------------------------------------
void __fastcall cffti1_ps(int a1, __int64 a2, int *a3)
{
  __int64 v4; // x8
  __int64 v5; // x10
  int v6; // w13
  int v7; // w16
  unsigned int v8; // w14
  __int64 v9; // x0
  __int64 v10; // x15
  int v11; // w17
  __int64 v12; // x16
  _DWORD *v13; // x1
  _DWORD *v14; // x0
  int v15; // t1
  int32x4_t v16; // q0
  __int64 v17; // x10
  __int64 v18; // x24
  float v19; // s8
  int v20; // w21
  __int64 v21; // x10
  int v22; // w25
  int v23; // w28
  int v24; // w22
  int v25; // w8
  int v26; // w19
  int v27; // w8
  __int64 v28; // x10
  __int64 v29; // x12
  int v30; // w8
  signed int v31; // w26
  float v32; // s1
  __int64 v33; // x27
  float *v34; // x26
  int32x4_t v35; // q1
  float32x4_t v36; // q0
  float64x2_t v37; // q0
  float64x2_t v38; // q0
  float64x2_t v39; // q2
  float64x2_t v40; // q3
  int v41; // w27
  __int64 v42; // x23
  __int64 v43; // x8
  float v44; // s1
  _DWORD *v45; // x8
  __int64 v47; // [xsp+10h] [xbp-180h]
  int *v48; // [xsp+18h] [xbp-178h]
  int v49; // [xsp+24h] [xbp-16Ch]
  __int64 v50; // [xsp+28h] [xbp-168h]
  int v51; // [xsp+54h] [xbp-13Ch]
  int v52; // [xsp+58h] [xbp-138h]
  __int64 v53; // [xsp+68h] [xbp-128h]
  __int64 v54; // [xsp+70h] [xbp-120h]
  __int64 v55; // [xsp+78h] [xbp-118h]
  float32x4_t v56; // [xsp+80h] [xbp-110h]
  float64x2_t v57; // [xsp+A0h] [xbp-F0h]
  float64x2_t x; // [xsp+B0h] [xbp-E0h]
  int32x4_t v59; // [xsp+C0h] [xbp-D0h]
  double v60; // [xsp+D0h] [xbp-C0h]
  float64x2_t v61; // [xsp+D0h] [xbp-C0h]
  double v62; // [xsp+E0h] [xbp-B0h] BYREF
  double v63; // [xsp+E8h] [xbp-A8h] BYREF
  double v64; // [xsp+F0h] [xbp-A0h] BYREF
  double v65; // [xsp+F8h] [xbp-98h] BYREF
  double v66; // [xsp+100h] [xbp-90h] BYREF
  double v67; // [xsp+108h] [xbp-88h] BYREF
  double cosx; // [xsp+110h] [xbp-80h] BYREF
  double sinx; // [xsp+118h] [xbp-78h] BYREF
  double v70[2]; // [xsp+120h] [xbp-70h] BYREF
  double v71; // [xsp+138h] [xbp-58h] BYREF
  float32x4x2_t v72; // 0:q0.16,16:q1.16

  v4 = 0;
  LODWORD(v5) = 0;
  v6 = 5;
  v7 = a1;
  if ( a1 == 1 )
    goto LABEL_4;
LABEL_6:
  v8 = v5 + 2;
  v9 = (int)v5;
  v10 = (__int64)&a3[(int)v5 + 2];
  do
  {
    v11 = v7 / v6;
    if ( v7 != v7 / v6 * v6 )
    {
      LODWORD(v5) = v9;
      break;
    }
    v5 = v9 + 1;
    a3[v9 + 2] = v6;
    if ( v6 == 2 && v9 )
    {
      if ( v5 >= 2 )
      {
        v12 = v8 - 2LL;
        v13 = (_DWORD *)v10;
        v14 = (_DWORD *)v10;
        do
        {
          v15 = *--v14;
          --v12;
          *v13 = v15;
          v13 = v14;
        }
        while ( v12 );
      }
      a3[2] = 2;
    }
    ++v8;
    v10 += 4;
    v9 = v5;
    v7 = v11;
  }
  while ( v11 != 1 );
LABEL_4:
  while ( 1 )
  {
    v6 = dword_2244C[++v4];
    if ( v4 == 4 )
      break;
    if ( v7 != 1 )
      goto LABEL_6;
  }
  *a3 = a1;
  a3[1] = v5;
  if ( (int)v5 >= 1 )
  {
    v47 = (unsigned int)(v5 + 1);
    v16.n128_f64[0] = 6.28318531 / (float)a1;
    v17 = 1;
    LODWORD(v18) = 1;
    v19 = v16.n128_f64[0];
    v20 = 1;
    v48 = a3;
    while ( 1 )
    {
      v21 = v17 + 1;
      v22 = a3[v21];
      v50 = v21;
      v49 = v22 * v20;
      if ( v22 >= 2 )
        break;
LABEL_18:
      a3 = v48;
      v17 = v50;
      v20 = v49;
      if ( v50 == v47 )
        return;
    }
    v23 = 0;
    v24 = 1;
    v25 = 2 * (a1 / (v22 * v20));
    v26 = v25 + 2;
    v27 = v25 + 3;
    if ( v27 <= 6 )
      v27 = 6;
    v53 = ((unsigned int)(v27 - 5) >> 1) + 1;
    v51 = a3[v21];
    v52 = v20;
    while ( 1 )
    {
      v28 = (int)v18;
      v29 = (int)v18 - 1LL;
      v23 += v20;
      *(_DWORD *)(a2 + 4 * v29) = 1065353216;
      *(_DWORD *)(a2 + 4LL * (int)v18) = 0;
      if ( v26 >= 4 )
        break;
LABEL_33:
      if ( v22 >= 6 )
      {
        v45 = (_DWORD *)(a2 + 4LL * (int)v18);
        *(_DWORD *)(a2 + 4 * v29) = *(v45 - 1);
        *(_DWORD *)(a2 + 4 * v28) = *v45;
      }
      if ( ++v24 == v22 )
        goto LABEL_18;
    }
    v54 = (int)v18 - 1LL;
    v55 = (int)v18;
    if ( (unsigned int)v53 >= 4 )
    {
      v16.n128_f32[0] = v19 * (float)v23;
      v56 = vdupq_lane_s32((int32x2_t)v16.n128_u64[0], 0);
      v33 = (unsigned int)v53 & 0xFFFFFFFC;
      v18 = 2 * v33 + (int)v18;
      v16 = (int32x4_t)xmmword_16940;
      v34 = (float *)(a2 + 4 + 4 * v28);
      do
      {
        v59 = v16;
        v35.n128_u64[0] = 0x100000001LL;
        v35.n128_u64[1] = 0x100000001LL;
        v36 = vmulq_f32(v56, vcvtq_f32_s32(vaddq_s32(v16, v35)));
        v57 = vcvt_hight_f64_f32(v36);
        x = vcvtq_f64_f32((float32x2_t)v36.n128_u64[0]);
        sincos(v57.n128_f64[0], &sinx, &cosx);
        v60 = cosx;
        sincos(v57.n128_f64[1], &v71, v70);
        v37.n128_f64[0] = v60;
        v37.n128_f64[1] = v70[0];
        v61 = v37;
        sincos(x.n128_f64[0], &v65, &v64);
        v57.n128_f64[0] = v64;
        sincos(x.n128_f64[1], &v67, &v66);
        v38.n128_u64[0] = v57.n128_u64[0];
        v33 -= 4;
        v38.n128_f64[1] = v66;
        v72.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(v38), v61);
        v39.n128_f64[0] = v65;
        v40.n128_f64[0] = sinx;
        v39.n128_f64[1] = v67;
        v40.n128_f64[1] = v71;
        v72.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(v39), v40);
        vst2q_f32(v34, v72);
        v34 += 8;
        v72.val[1].n128_u64[0] = 0x400000004LL;
        v72.val[1].n128_u64[1] = 0x400000004LL;
        v16 = vaddq_s32(v59, v72.val[1]);
      }
      while ( v33 );
      v31 = (8 * (((unsigned int)v53 & 0xFFFFFFFC) >> 2)) | 4;
      v22 = v51;
      v20 = v52;
      v32 = v19 * (float)v23;
      v30 = v53 & 0xFFFFFFFC;
      if ( (v53 & 0xFFFFFFFC) == v53 )
        goto LABEL_32;
    }
    else
    {
      v30 = 0;
      v31 = 4;
      v18 = (int)v18;
      v32 = v19 * (float)v23;
    }
    v41 = v30 + 1;
    v42 = v18;
    do
    {
      LODWORD(v18) = v42 + 2;
      sincos((float)(v32 * (float)v41), &v63, &v62);
      v16.n128_u32[1] = HIDWORD(v63);
      v43 = a2 + 4 * v42;
      v31 += 2;
      v44 = v62;
      v16.n128_f32[0] = v63;
      *(float *)(v43 + 4) = v44;
      *(_DWORD *)(v43 + 8) = v16.n128_u32[0];
      v32 = v19 * (float)v23;
      ++v41;
      v42 += 2;
    }
    while ( v31 <= v26 );
LABEL_32:
    v29 = v54;
    v28 = v55;
    goto LABEL_33;
  }
}
// 16940: using guessed type __int128 xmmword_16940;
// 2244C: using guessed type _DWORD dword_2244C[5];

//----- (0000000000044E40) ----------------------------------------------------
float32x4_t *__fastcall cfftf1_ps(
        int a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        __int64 a5,
        __int64 a6,
        int a7,
        double a8,
        double a9,
        double a10,
        double a11,
        long double a12)
{
  float32x4_t v12; // q8
  __int64 v13; // x25
  __int64 v16; // x19
  int v18; // w26
  int *v19; // x27
  int v20; // w1
  float32x4_t *v21; // x23
  bool v22; // zf
  int v23; // w22
  int v24; // w28
  unsigned int v25; // w24
  __int64 v26; // kr00_8
  __int64 v27; // x4

  v13 = *(unsigned int *)(a6 + 4);
  if ( (int)v13 >= 1 )
  {
    v16 = a5;
    v18 = 0;
    v12.n128_f32[0] = (float)a7;
    v19 = (int *)(a6 + 8);
    v20 = 1;
    if ( a2 == a4 )
      v21 = a3;
    else
      v21 = a4;
    do
    {
      v23 = *v19;
      v24 = *v19 * v20;
      v25 = 2 * (a1 / v24);
      v26 = a5;
      v27 = v16 + 4LL * v18;
      switch ( *v19 )
      {
        case 2:
          sub_45558(v25, v20, a2, v21, v27, v12, a9, a10, a11, *(float32x4_t *)&a12);
          break;
        case 3:
          sub_456CC(v25, v20, (__int64)a2, (__int64)v21, v27, v16 + 4LL * (int)(v25 + v18), v12.n128_f32[0], a9);
          break;
        case 4:
          sub_452B0(
            v25,
            v20,
            a2,
            (__int64)v21,
            v27,
            v16 + 4LL * (int)(v25 + v18),
            v16 + 4LL * (int)(v25 + v18 + v25),
            v12.n128_f64[0]);
          break;
        case 5:
          sub_44F9C(
            v25,
            v20,
            (__int64)a2,
            (__int64)v21,
            v27,
            v16 + 4LL * (int)(v25 + v18),
            v16 + 4LL * (int)(v25 + v18 + v25),
            v16 + 4LL * (int)(v25 + v18 + v25 + v25),
            v12.n128_f32[0],
            a9,
            a10,
            a11,
            *(double *)&a12);
          break;
        default:
          a5 = v26;
          break;
      }
      v22 = v21 == a4;
      v18 += v25 * (v23 - 1);
      if ( v21 == a4 )
        v21 = a3;
      else
        v21 = a4;
      if ( v22 )
        a2 = a4;
      else
        a2 = a3;
      --v13;
      ++v19;
      v20 = v24;
    }
    while ( v13 );
  }
  return a2;
}
// 44EB0: variable 'a9' is possibly undefined
// 44EF8: variable 'a5' is possibly undefined
// 44F20: variable 'v12' is possibly undefined
// 44F20: variable 'a10' is possibly undefined
// 44F20: variable 'a11' is possibly undefined
// 44F20: variable 'a12' is possibly undefined

//----- (0000000000044F9C) ----------------------------------------------------
__int64 __fastcall sub_44F9C(
        __int64 result,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        float a9,
        double a10,
        double a11,
        double a12,
        double a13)
{
  int v13; // w19
  float *v14; // x11
  float *v15; // x12
  float *v16; // x13
  int v17; // w6
  __int64 v18; // x9
  float *v19; // x10
  __int64 v20; // x14
  __int64 v21; // x16
  int v22; // w21
  float32x4_t v23; // q1
  float32x4_t v24; // q2
  __int64 v25; // x5
  __int64 v26; // x7
  __int64 v27; // x17
  int v28; // w8
  float32x4_t v29; // q3
  float32x4_t v30; // q4
  __int64 v31; // x15
  __int64 v32; // x16
  __int64 v33; // x4
  __int64 v34; // x5
  __int64 v35; // x6
  __int64 v36; // x7
  __int64 v37; // x19
  __int64 v38; // x20
  __int64 v39; // x21
  float *v40; // x22
  float *v41; // x23
  float *v42; // x24
  float *v43; // x25
  float32x4_t v44; // q5
  float32x4_t v45; // q6
  float32x4_t v46; // q7
  float32x4_t v47; // q16
  float32x4_t v48; // q17
  float32x4_t v49; // q18
  float32x4_t v50; // q19
  float32x4_t v51; // q20
  float32x4_t v52; // q22
  float32x4_t v53; // q23
  float32x4_t *v54; // x29
  float32x4_t v55; // q24
  float32x4_t v56; // q25
  float32x4_t v57; // q21
  float32x4_t v58; // q26
  float32x4_t v59; // q6
  float32x4_t v60; // q16
  float32x4_t v61; // q5
  float32x4_t v62; // q7
  float32x4_t v63; // q17
  float32x4_t v64; // q19
  float32x4_t v65; // q20
  float32x4_t v66; // q22
  float32x4_t v67; // q23
  float32x4_t v68; // q18
  float32x4_t v69; // q5
  float32x4_t v70; // q6
  float v71; // s27
  float v72; // s29
  float32x4_t v73; // q17
  float32x4_t v74; // q20
  float v75; // t1
  float32x4_t v76; // q19
  float32x4_t v77; // q22
  float32x4_t v78; // q28
  float32x4_t v79; // q6
  float32x4_t v80; // q20
  float32x4_t v81; // q5
  float32x4_t v82; // q22
  float32x4_t v83; // q17
  float32x4_t v84; // q18
  float32x4_t v85; // q19
  float32x4_t *v86; // x27
  float32x4_t *v87; // x28
  float32x4_t *v88; // x29
  float32x4_t *v89; // x26

  if ( a2 >= 1 )
  {
    v13 = 4 * result;
    v14 = (float *)(a7 + 4);
    v15 = (float *)(a6 + 4);
    v16 = (float *)(a5 + 4);
    v17 = 3 * result;
    v18 = 16LL * (int)result;
    v19 = (float *)(a8 + 4);
    *(float *)&a13 = a9 * 0.58779;
    v20 = (int)result - 1;
    v21 = a4 + 16LL * a2 * (int)result;
    v22 = 3 * result * a2;
    *(float *)&a12 = a9 * 0.95106;
    v23 = vdupq_n_s32(0x3E9E377Au);
    v24 = vdupq_n_s32(0xBF4F1BBD);
    v25 = a4 + 64LL * a2 * (int)result;
    v26 = a4 + 32LL * a2 * (int)result;
    v27 = 80LL * (_DWORD)result;
    result = a3 + 32LL * (_DWORD)result + 16;
    v28 = 0;
    v29 = vdupq_lane_s32(*(int32x2_t *)&a12, 0);
    v30 = vdupq_lane_s32(*(int32x2_t *)&a13, 0);
    v31 = v21 + 16;
    v32 = a3 + 16LL * v17;
    v33 = v18 + a3 + 16;
    v34 = v25 + 16;
    v35 = v26 + 16;
    v36 = a4 + 16LL * v22 + 16;
    v37 = a3 + 16LL * v13;
    if ( (int)v20 >= 1 )
      goto LABEL_5;
    while ( 1 )
    {
      ++v28;
      v34 += v18;
      v36 += v18;
      v35 += v18;
      v31 += v18;
      v32 += v27;
      a4 += v18;
      a3 += v27;
      result += v27;
      v33 += v27;
      v37 += v27;
      if ( v28 == a2 )
        break;
      if ( (int)v20 >= 1 )
      {
LABEL_5:
        v38 = 0;
        v39 = 0;
        v40 = v16;
        v41 = v15;
        v42 = v14;
        v43 = v19;
        do
        {
          v44 = *(float32x4_t *)(v37 + v38);
          v45 = *(float32x4_t *)(v37 + v38 + 16);
          v46 = *(float32x4_t *)(v32 + v38);
          v47 = *(float32x4_t *)(v32 + v38 + 16);
          v48 = *(float32x4_t *)(v33 + v38 - 16);
          v49 = *(float32x4_t *)(v33 + v38);
          v51 = *(float32x4_t *)(result + v38 - 16);
          v50 = *(float32x4_t *)(result + v38);
          v52 = vaddq_f32(v48, v44);
          v53 = vaddq_f32(v51, v46);
          v54 = (float32x4_t *)(a4 + v38);
          *v54 = vaddq_f32(*(float32x4_t *)(a3 + v38), vaddq_f32(v52, v53));
          v55 = vaddq_f32(v49, v45);
          v56 = vaddq_f32(v50, v47);
          v54[1] = vaddq_f32(vaddq_f32(v55, v56), *(float32x4_t *)(a3 + v38 + 16));
          v57 = *(float32x4_t *)(a3 + v38);
          v58 = *(float32x4_t *)(a3 + v38 + 16);
          v59 = vsubq_f32(v49, v45);
          v60 = vsubq_f32(v50, v47);
          v61 = vsubq_f32(v48, v44);
          v62 = vsubq_f32(v51, v46);
          v63 = vaddq_f32(vmulq_f32(v52, v23), vmulq_f32(v53, v24));
          v64 = vaddq_f32(vmulq_f32(v55, v23), vmulq_f32(v56, v24));
          v65 = vaddq_f32(vmulq_f32(v52, v24), vmulq_f32(v53, v23));
          v66 = vaddq_f32(vmulq_f32(v55, v24), vmulq_f32(v56, v23));
          v67 = vaddq_f32(vmulq_f32(v29, v61), vmulq_f32(v30, v62));
          v68 = vaddq_f32(vmulq_f32(v29, v59), vmulq_f32(v30, v60));
          v69 = vsubq_f32(vmulq_f32(v30, v61), vmulq_f32(v29, v62));
          v70 = vsubq_f32(vmulq_f32(v30, v59), vmulq_f32(v29, v60));
          v62.n128_f32[0] = *(v40 - 1);
          v55.n128_f32[0] = *(v41 - 1);
          v71 = *(v42 - 1);
          v72 = *(v43 - 1);
          v73 = vaddq_f32(v63, v57);
          v74 = vaddq_f32(v65, v57);
          v75 = *v43;
          v43 += 2;
          v76 = vaddq_f32(v64, v58);
          v77 = vaddq_f32(v66, v58);
          v60.n128_f32[0] = *v40 * a9;
          v56.n128_f32[0] = *v41 * a9;
          v58.n128_f32[0] = *v42 * a9;
          v78 = vsubq_f32(v74, v70);
          v79 = vaddq_f32(v70, v74);
          v80 = vaddq_f32(v69, v77);
          v81 = vsubq_f32(v77, v69);
          v82 = vaddq_f32(v68, v73);
          v83 = vsubq_f32(v73, v68);
          v84 = vsubq_f32(v76, v67);
          v85 = vaddq_f32(v67, v76);
          v39 += 2;
          v86 = (float32x4_t *)(v31 + v38);
          v87 = (float32x4_t *)(v35 + v38);
          v88 = (float32x4_t *)(v36 + v38);
          v89 = (float32x4_t *)(v34 + v38);
          v38 += 32;
          v42 += 2;
          v41 += 2;
          v40 += 2;
          v86[-1] = vsubq_f32(vmulq_n_f32(v83, v62.n128_f32[0]), vmulq_n_f32(v85, v60.n128_f32[0]));
          *v86 = vaddq_f32(vmulq_n_f32(v85, v62.n128_f32[0]), vmulq_n_f32(v83, v60.n128_f32[0]));
          v87[-1] = vsubq_f32(vmulq_n_f32(v78, v55.n128_f32[0]), vmulq_n_f32(v80, v56.n128_f32[0]));
          *v87 = vaddq_f32(vmulq_n_f32(v80, v55.n128_f32[0]), vmulq_n_f32(v78, v56.n128_f32[0]));
          v88[-1] = vsubq_f32(vmulq_n_f32(v79, v71), vmulq_n_f32(v81, v58.n128_f32[0]));
          *v88 = vaddq_f32(vmulq_n_f32(v81, v71), vmulq_n_f32(v79, v58.n128_f32[0]));
          v89[-1] = vsubq_f32(vmulq_n_f32(v82, v72), vmulq_n_f32(v84, v75 * a9));
          *v89 = vaddq_f32(vmulq_n_f32(v84, v72), vmulq_n_f32(v82, v75 * a9));
        }
        while ( v39 < v20 );
      }
    }
  }
  return result;
}

//----- (00000000000452B0) ----------------------------------------------------
__int64 __fastcall sub_452B0(
        __int64 result,
        int a2,
        float32x4_t *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        double a8)
{
  __int64 v8; // x8
  __int64 v9; // x10
  __int64 v10; // x9
  float32x4_t v11; // q0
  float32x4_t *v12; // x13
  float32x4_t v13; // q2
  float32x4_t v14; // q3
  float32x4_t v15; // q4
  float32x4_t v16; // q5
  float32x4_t v17; // q6
  float32x4_t v18; // q7
  float32x4_t v19; // q16
  __int64 v20; // x15
  float32x4_t v21; // q17
  float32x4_t v22; // q1
  float32x4_t v23; // q3
  float32x4_t v24; // q2
  float32x4_t v25; // q4
  float32x4_t v26; // q18
  float32x4_t v27; // q5
  float32x4_t v28; // q6
  float32x4_t v29; // q4
  float32x4_t v30; // q7
  float32x4_t *v31; // x16
  float *v32; // x12
  unsigned __int32 *v33; // x10
  float *v34; // x11
  __int64 v35; // x14
  int v36; // w9
  float32x4_t v37; // q1
  __int64 v38; // x13
  __int64 v39; // x15
  __int64 v40; // x16
  float32x4_t *v41; // x17
  __int64 v42; // x1
  float32x4_t *v43; // x4
  __int64 v44; // x5
  float32x4_t *v45; // x6
  __int64 v46; // x7
  __int64 v47; // x19
  float *v48; // x20
  float *v49; // x21
  unsigned __int32 *v50; // x22
  float32x4_t v51; // q2
  float32x4_t v52; // q3
  float32x4_t v53; // q4
  float32x4_t v54; // q5
  float32x4_t v55; // q6
  float32x4_t v56; // q7
  float32x4_t v57; // q16
  float32x4_t v58; // q17
  float32x4_t v59; // q18
  float32x4_t v60; // q2
  float32x4_t v61; // q4
  float32x4_t v62; // q3
  float32x4_t v63; // q5
  float32x4_t v64; // q19
  float32x4_t v65; // q6
  float32x4_t v66; // q7
  float32x4_t *v67; // x23
  float32x4_t v68; // q16
  float32x4_t v69; // q5
  float32x4_t v70; // q20
  float32x4_t v71; // q21
  float32x4_t v72; // q22
  float32x4_t v73; // q19
  float32x4_t v74; // q20
  float32x4_t v75; // q17
  float v76; // t1
  float32x4_t *v77; // x23
  float32x4_t v78; // q2
  float32x4_t v79; // q3
  float32x4_t v80; // q4
  float32x4_t *v81; // x23
  float32x4_t v82; // q5
  float32x4_t *v83; // x24

  v8 = a2 * (__int64)(int)result;
  if ( (_DWORD)result == 2 )
  {
    if ( (int)v8 >= 1 )
    {
      v9 = a4 + 16 * v8;
      v10 = 0;
      v11 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
      v12 = (float32x4_t *)(a4 + ((32 * v8) | 0x10));
      do
      {
        v13 = a3[1];
        v14 = a3[4];
        v15 = a3[5];
        v16 = a3[6];
        v17 = a3[7];
        v18 = a3[2];
        v19 = a3[3];
        v20 = 16 * v10;
        v21 = vsubq_f32(*a3, v14);
        v22 = vaddq_f32(*a3, v14);
        v23 = vsubq_f32(v13, v15);
        v24 = vaddq_f32(v13, v15);
        v25 = vsubq_f32(v18, v16);
        v26 = vsubq_f32(v17, v19);
        v27 = vaddq_f32(v18, v16);
        v28 = vaddq_f32(v17, v19);
        v29 = vmulq_f32(v11, v25);
        v30 = vmulq_f32(v11, v26);
        v10 += 2;
        v31 = (float32x4_t *)(a4 + v20);
        *v31 = vaddq_f32(v22, v27);
        v31[1] = vaddq_f32(v24, v28);
        *(float32x4_t *)(v9 + v20) = vaddq_f32(v21, v30);
        *(float32x4_t *)(v9 + 16 + v20) = vaddq_f32(v23, v29);
        v12[-1] = vsubq_f32(v22, v27);
        *v12 = vsubq_f32(v24, v28);
        v12 += 2;
        a3 += 8;
        *(float32x4_t *)(a4 + 48 * v8 + v20) = vsubq_f32(v21, v30);
        *(float32x4_t *)(a4 + 16LL * (3 * (int)v8 + 1) + v20) = vsubq_f32(v23, v29);
      }
      while ( (int)v10 < (int)v8 );
    }
  }
  else if ( (int)v8 >= 1 )
  {
    v32 = (float *)(a5 + 4);
    v33 = (unsigned __int32 *)(a7 + 4);
    v34 = (float *)(a6 + 4);
    v35 = 16LL * (int)result;
    v36 = 0;
    v37 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v38 = (int)result - 1;
    v39 = a4 + 16LL * (int)v8 + 16;
    v40 = 64LL * (_DWORD)result;
    v41 = &a3[3 * (int)result];
    v42 = a4 + 32LL * (_DWORD)v8 + 16;
    v43 = &a3[(unsigned __int64)v35 / 0x10];
    v44 = a4 + 48LL * (_DWORD)v8 + 16;
    v45 = &a3[2 * (int)result];
    if ( (int)v38 >= 1 )
      goto LABEL_10;
    while ( 1 )
    {
      v36 += result;
      v44 += v35;
      v42 += v35;
      v39 += v35;
      v43 = (float32x4_t *)((char *)v43 + v40);
      a4 += v35;
      a3 = (float32x4_t *)((char *)a3 + v40);
      v41 = (float32x4_t *)((char *)v41 + v40);
      v45 = (float32x4_t *)((char *)v45 + v40);
      if ( v36 >= (int)v8 )
        break;
      if ( (int)v38 >= 1 )
      {
LABEL_10:
        v46 = 0;
        v47 = 0;
        v48 = v32;
        v49 = v34;
        v50 = v33;
        do
        {
          v51 = a3[v46];
          v52 = a3[v46 + 1];
          v53 = v45[v46];
          v54 = v45[v46 + 1];
          v55 = v41[v46];
          v56 = v41[v46 + 1];
          v57 = v43[v46];
          v58 = v43[v46 + 1];
          v59 = vsubq_f32(v51, v53);
          v60 = vaddq_f32(v51, v53);
          v61 = vsubq_f32(v52, v54);
          v62 = vaddq_f32(v52, v54);
          v63 = vsubq_f32(v56, v58);
          v64 = vsubq_f32(v57, v55);
          v65 = vaddq_f32(v57, v55);
          v66 = vaddq_f32(v56, v58);
          v67 = (float32x4_t *)(a4 + v46 * 16);
          v68 = vmulq_f32(v37, v64);
          *v67 = vaddq_f32(v60, v65);
          v67[1] = vaddq_f32(v62, v66);
          v64.n128_f32[0] = *(v48 - 1);
          v69 = vmulq_f32(v37, v63);
          v70 = vaddq_f32(v59, v69);
          v71 = vaddq_f32(v61, v68);
          v58.n128_f32[0] = *v48 * *(float *)&a8;
          v72 = vmulq_n_f32(v70, v64.n128_f32[0]);
          v73 = vmulq_n_f32(v71, v64.n128_f32[0]);
          v74 = vmulq_n_f32(v70, v58.n128_f32[0]);
          v75 = vmulq_n_f32(v71, v58.n128_f32[0]);
          v71.n128_f32[0] = *(v49 - 1);
          v76 = *v49;
          v49 += 2;
          v77 = (float32x4_t *)(v39 + v46 * 16);
          v78 = vsubq_f32(v60, v65);
          v79 = vsubq_f32(v62, v66);
          v77[-1] = vsubq_f32(v72, v75);
          *v77 = vaddq_f32(v73, v74);
          v80 = vsubq_f32(v61, v68);
          v65.n128_u32[0] = *(v50 - 1);
          v66.n128_u32[0] = *v50;
          v81 = (float32x4_t *)(v42 + v46 * 16);
          v82 = vsubq_f32(v59, v69);
          v81[-1] = vsubq_f32(vmulq_n_f32(v78, v71.n128_f32[0]), vmulq_n_f32(v79, v76 * *(float *)&a8));
          *v81 = vaddq_f32(vmulq_n_f32(v79, v71.n128_f32[0]), vmulq_n_f32(v78, v76 * *(float *)&a8));
          v47 += 2;
          v83 = (float32x4_t *)(v44 + v46 * 16);
          v46 += 2;
          v50 += 2;
          v48 += 2;
          v83[-1] = vsubq_f32(vmulq_n_f32(v82, v65.n128_f32[0]), vmulq_n_f32(v80, v66.n128_f32[0] * *(float *)&a8));
          *v83 = vaddq_f32(vmulq_n_f32(v80, v65.n128_f32[0]), vmulq_n_f32(v82, v66.n128_f32[0] * *(float *)&a8));
        }
        while ( v47 < v38 );
      }
    }
  }
  return result;
}

//----- (0000000000045558) ----------------------------------------------------
__int64 __fastcall sub_45558(
        __int64 result,
        int a2,
        float32x4_t *a3,
        float32x4_t *a4,
        __int64 a5,
        float32x4_t a6,
        double a7,
        double a8,
        double a9,
        float32x4_t a10)
{
  int v10; // w8
  __int64 v11; // x15
  int v12; // w9
  float32x4_t v13; // q0
  float32x4_t v14; // q1
  __int64 v15; // x11
  int v16; // w9
  float32x4_t *v17; // x10
  __int64 v18; // x12
  float32x4_t *v19; // x13
  __int64 v20; // x14
  float *v21; // x15
  __int64 v22; // x16
  float *v23; // x17
  __int64 v24; // x1
  float32x4_t v25; // q2
  float32x4_t v26; // q5
  float32x4_t v27; // q3
  float v28; // s1
  float32x4_t *v29; // x6
  float32x4_t v30; // q6
  float32x4_t v31; // q2
  float32x4_t v32; // q3
  float v33; // s4
  float32x4_t v34; // q2
  float32x4_t v35; // q3
  float32x4_t v36; // q5
  float32x4_t v37; // q6
  float32x4_t v38; // q4
  float32x4_t v39; // q1
  float32x4_t v40; // q3
  float32x4_t *v41; // x4

  v10 = a2 * result;
  if ( (int)result >= 3 )
  {
    if ( v10 >= 1 )
    {
      v15 = 16LL * (int)result;
      v16 = 0;
      v17 = &a4[v10];
      v18 = (int)result - 1;
      v19 = &a3[(unsigned __int64)v15 / 0x10];
      v20 = 32LL * (_DWORD)result;
      v21 = (float *)(a5 + 4);
      if ( (int)v18 >= 1 )
        goto LABEL_10;
      while ( 1 )
      {
        v16 += result;
        v17 = (float32x4_t *)((char *)v17 + v15);
        v19 = (float32x4_t *)((char *)v19 + v20);
        a4 = (float32x4_t *)((char *)a4 + v15);
        a3 = (float32x4_t *)((char *)a3 + v20);
        if ( v16 >= v10 )
          break;
        if ( (int)v18 >= 1 )
        {
LABEL_10:
          v22 = 0;
          v23 = v21;
          v24 = 1;
          do
          {
            v25 = a3[v24 - 1];
            v26 = a3[v24];
            v27 = v19[v24 - 1];
            v28 = *(v23 - 1);
            a10.n128_f32[0] = *v23;
            v29 = &a4[v24];
            v22 += 2;
            v30 = vsubq_f32(v25, v27);
            v31 = vaddq_f32(v25, v27);
            v32 = v19[v24];
            v29[-1] = v31;
            LODWORD(v33) = vmulq_f32(a6, a10).n128_u32[0];
            v34 = a3[v24];
            v35 = vsubq_f32(v26, v32);
            v36 = vmulq_n_f32(v30, v33);
            v37 = vmulq_n_f32(v30, v28);
            v38 = vmulq_n_f32(v35, v33);
            v39 = vmulq_n_f32(v35, v28);
            v40 = v19[v24];
            v41 = &v17[v24];
            v24 += 2;
            a10 = vsubq_f32(v37, v38);
            v23 += 2;
            *v29 = vaddq_f32(v34, v40);
            v41[-1] = a10;
            *v41 = vaddq_f32(v39, v36);
          }
          while ( v22 < v18 );
        }
      }
    }
  }
  else if ( v10 >= 1 )
  {
    v11 = (int)result + 1;
    v12 = 0;
    do
    {
      v12 += result;
      *a4 = vaddq_f32(*a3, a3[(int)result]);
      a4[v10] = vsubq_f32(*a3, a3[(int)result]);
      a4[1] = vaddq_f32(a3[1], a3[v11]);
      v13 = a3[1];
      v14 = a3[v11];
      a3 += 2 * (int)result;
      a4[v10 + 1] = vsubq_f32(v13, v14);
      a4 += (int)result;
    }
    while ( v12 < v10 );
  }
  return result;
}

//----- (00000000000456CC) ----------------------------------------------------
__int64 __fastcall sub_456CC(
        __int64 result,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        float a7,
        double a8)
{
  int v8; // w8
  __int64 v9; // x10
  __int64 v10; // x13
  __int64 v11; // x14
  int v12; // w9
  float *v13; // x11
  float *v14; // x12
  __int64 v15; // x15
  float32x4_t v16; // q1
  __int64 v17; // x16
  __int64 v18; // x17
  __int64 v19; // x1
  float32x4_t v20; // q2
  __int64 v21; // x4
  __int64 v22; // x5
  float *v23; // x6
  float *v24; // x7
  float32x4_t v25; // q5
  float32x4_t *v26; // x22
  float32x4_t v27; // q3
  float32x4_t v28; // q7
  float32x4_t v29; // q3
  float32x4_t v30; // q4
  float32x4_t v31; // q4
  float v32; // s17
  float v33; // s19
  float32x4_t *v34; // x21
  float v35; // t1
  float32x4_t v36; // q5
  float32x4_t v37; // q7
  float v38; // s16
  float32x4_t v39; // q18
  float32x4_t v40; // q3
  float32x4_t v41; // q7
  float32x4_t v42; // q4
  float32x4_t *v43; // x22

  v8 = a2 * result;
  if ( a2 * (int)result >= 1 )
  {
    v9 = 16LL * (int)result;
    *(float *)&a8 = a7 * 0.86603;
    v10 = (int)result - 1;
    v11 = a4 + 16LL * v8 + 16;
    v12 = 0;
    v13 = (float *)(a6 + 4);
    v14 = (float *)(a5 + 4);
    v15 = a3 + v9;
    v16 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v17 = a4 + 32LL * v8 + 16;
    v18 = a3 + 32LL * (_DWORD)result + 16;
    v19 = 48LL * (_DWORD)result;
    v20.n128_u64[0] = 0xBF000000BF000000LL;
    v20.n128_u64[1] = 0xBF000000BF000000LL;
    if ( (int)v10 >= 1 )
      goto LABEL_5;
    while ( 1 )
    {
      v12 += result;
      v17 += v9;
      v11 += v9;
      v18 += v19;
      a4 += v9;
      a3 += v19;
      v15 += v19;
      if ( v12 >= v8 )
        break;
      if ( (int)v10 >= 1 )
      {
LABEL_5:
        v21 = 0;
        v22 = 0;
        v23 = v14;
        v24 = v13;
        do
        {
          v25 = *(float32x4_t *)(a3 + v21);
          v26 = (float32x4_t *)(a4 + v21);
          v22 += 2;
          v27 = vaddq_f32(*(float32x4_t *)(v15 + v21), *(float32x4_t *)(v18 + v21 - 16));
          *v26 = vaddq_f32(v25, v27);
          v28 = *(float32x4_t *)(a3 + v21 + 16);
          v29 = vaddq_f32(v25, vmulq_f32(v27, v20));
          v30 = vaddq_f32(*(float32x4_t *)(v15 + v21 + 16), *(float32x4_t *)(v18 + v21));
          v26[1] = vaddq_f32(v28, v30);
          v31 = vaddq_f32(v28, vmulq_f32(v30, v20));
          v32 = *(v23 - 1);
          v33 = *(v24 - 1);
          v34 = (float32x4_t *)(v11 + v21);
          v35 = *v24;
          v24 += 2;
          v36 = vmulq_f32(v16, vsubq_f32(*(float32x4_t *)(v15 + v21), *(float32x4_t *)(v18 + v21 - 16)));
          v37 = vmulq_f32(v16, vsubq_f32(*(float32x4_t *)(v15 + v21 + 16), *(float32x4_t *)(v18 + v21)));
          v38 = *v23 * a7;
          v39 = vsubq_f32(v29, v37);
          v40 = vaddq_f32(v29, v37);
          v41 = vaddq_f32(v31, v36);
          v42 = vsubq_f32(v31, v36);
          v43 = (float32x4_t *)(v17 + v21);
          v21 += 32;
          v23 += 2;
          v34[-1] = vsubq_f32(vmulq_n_f32(v39, v32), vmulq_n_f32(v41, v38));
          *v34 = vaddq_f32(vmulq_n_f32(v41, v32), vmulq_n_f32(v39, v38));
          v43[-1] = vsubq_f32(vmulq_n_f32(v40, v33), vmulq_n_f32(v42, v35 * a7));
          *v43 = vaddq_f32(vmulq_n_f32(v42, v33), vmulq_n_f32(v40, v35 * a7));
        }
        while ( v22 < v10 );
      }
    }
  }
  return result;
}

//----- (0000000000045870) ----------------------------------------------------
int32x4_t *__fastcall pffft_new_setup(int a1, unsigned __int32 a2)
{
  int32x4_t *v4; // x0
  int v5; // w8
  int v6; // w8
  int v7; // w20
  int v8; // w23
  int32x4_t *v9; // x25
  void *v10; // x0
  unsigned __int64 v11; // x24
  int v12; // w19
  double v13; // d8
  __int64 v14; // x21
  unsigned int v15; // w19
  double v16; // d13
  float v17; // s0
  unsigned int v18; // w22
  float v19; // s2
  float v20; // s1
  float v21; // s0
  float v22; // s2
  float v23; // s1
  float v24; // s0
  float v25; // s1
  float v26; // s0
  int *v27; // x9
  unsigned int v28; // w20
  double v29; // d13
  float v30; // s0
  unsigned int v31; // w22
  float v32; // s2
  float v33; // s1
  float v34; // s0
  float v35; // s2
  float v36; // s1
  float v37; // s0
  float v38; // s1
  float v39; // s0
  __int64 v40; // x9
  __int64 v41; // x3
  int v42; // w5
  unsigned __int32 *v43; // x4
  int v44; // w13
  int v45; // w16
  unsigned int v46; // w14
  __int64 v47; // x0
  __int64 v48; // x15
  int v49; // w17
  __int64 v50; // x16
  _DWORD *v51; // x1
  _DWORD *v52; // x0
  int v53; // t1
  int32x4_t v54; // q0
  int v55; // w10
  __int64 v56; // x11
  __int64 v57; // x13
  float v58; // s8
  int v59; // w9
  int v60; // w8
  int v61; // w12
  __int64 v62; // x22
  int v63; // w19
  float *v64; // x27
  unsigned int v65; // w26
  int v66; // w8
  __int64 v67; // x10
  float v68; // s1
  __int64 v69; // x21
  float *v70; // x28
  int32x4_t v71; // q1
  float32x4_t v72; // q0
  float64x2_t v73; // q0
  float64x2_t v74; // q0
  float64x2_t v75; // q2
  float64x2_t v76; // q3
  int v77; // w28
  float *v78; // x21
  float v79; // s1
  __int64 v80; // x8
  unsigned __int64 v81; // x10
  __int64 v82; // x9
  unsigned __int32 v83; // w10
  int32x4_t *v84; // x11
  int32x4_t v85; // q0
  __int64 v86; // x12
  int32x4_t v87; // q1
  int32x4_t v88; // q2
  int32x4_t v89; // q3
  int8x16_t v90; // q0
  int32x4_t v91; // q0
  bool v92; // zf
  __int32 v93; // w12
  __int64 v94; // x8
  int v96; // [xsp+10h] [xbp-250h]
  unsigned __int64 v97; // [xsp+20h] [xbp-240h]
  __int64 v98; // [xsp+28h] [xbp-238h]
  int v99; // [xsp+44h] [xbp-21Ch]
  int v100; // [xsp+48h] [xbp-218h]
  int v101; // [xsp+4Ch] [xbp-214h]
  __int64 v102; // [xsp+50h] [xbp-210h]
  int v103; // [xsp+58h] [xbp-208h]
  __int64 v104; // [xsp+90h] [xbp-1D0h]
  __int64 v105; // [xsp+A0h] [xbp-1C0h]
  unsigned __int32 v106; // [xsp+A8h] [xbp-1B8h]
  int v107; // [xsp+ACh] [xbp-1B4h]
  int v108; // [xsp+B0h] [xbp-1B0h]
  int v109; // [xsp+BCh] [xbp-1A4h]
  float32x4_t v110; // [xsp+C0h] [xbp-1A0h]
  float64x2_t v111; // [xsp+E0h] [xbp-180h]
  float64x2_t x; // [xsp+F0h] [xbp-170h]
  int32x4_t v113; // [xsp+100h] [xbp-160h]
  double v114; // [xsp+110h] [xbp-150h]
  float64x2_t v115; // [xsp+110h] [xbp-150h]
  double v116; // [xsp+128h] [xbp-138h] BYREF
  double v117; // [xsp+130h] [xbp-130h] BYREF
  double v118; // [xsp+138h] [xbp-128h] BYREF
  double v119; // [xsp+140h] [xbp-120h] BYREF
  double v120; // [xsp+148h] [xbp-118h] BYREF
  double v121; // [xsp+150h] [xbp-110h] BYREF
  double v122; // [xsp+158h] [xbp-108h] BYREF
  double v123; // [xsp+160h] [xbp-100h] BYREF
  double v124; // [xsp+168h] [xbp-F8h] BYREF
  double v125; // [xsp+170h] [xbp-F0h] BYREF
  double v126; // [xsp+178h] [xbp-E8h] BYREF
  double v127; // [xsp+180h] [xbp-E0h] BYREF
  double v128; // [xsp+188h] [xbp-D8h] BYREF
  double v129; // [xsp+190h] [xbp-D0h] BYREF
  double v130; // [xsp+198h] [xbp-C8h] BYREF
  double v131; // [xsp+1A0h] [xbp-C0h] BYREF
  double cosx; // [xsp+1A8h] [xbp-B8h] BYREF
  double sinx; // [xsp+1B0h] [xbp-B0h] BYREF
  double v134; // [xsp+1B8h] [xbp-A8h] BYREF
  double v135; // [xsp+1C0h] [xbp-A0h] BYREF
  double v136; // [xsp+1C8h] [xbp-98h] BYREF
  double v137[2]; // [xsp+1D0h] [xbp-90h] BYREF
  float32x4x2_t v138; // 0:q0.16,16:q1.16

  v4 = (int32x4_t *)malloc(0x60u);
  if ( a1 >= 0 )
    v5 = a1;
  else
    v5 = a1 + 1;
  v6 = v5 >> 1;
  if ( a2 )
    v7 = a1;
  else
    v7 = v6;
  v8 = v7 / 4;
  v9 = v4;
  v4[4].n128_u32[1] = a2;
  v4->n128_u32[0] = a1;
  v4->n128_u32[1] = v7 / 4;
  v99 = a1;
  v10 = malloc(32LL * (v7 / 4) + 64);
  if ( v10 )
  {
    v11 = ((unsigned __int64)v10 + 64) & 0xFFFFFFFFFFFFFFC0LL;
    *(_QWORD *)(v11 - 8) = v10;
  }
  else
  {
    v11 = 0;
  }
  if ( 6 * v8 >= 0 )
    v12 = 6 * v8;
  else
    v12 = 6 * v8 + 3;
  v13 = (double)v99;
  v14 = v11 + 16LL * (v12 >> 2);
  v9[4].n128_u64[1] = v11;
  v9[5].n128_u64[0] = v11;
  v9[5].n128_u64[1] = v14;
  if ( a2 )
  {
    if ( v7 >= 4 )
    {
      v15 = 0;
      v16 = 0.0;
      do
      {
        v17 = v16 * -6.28318531 / v13;
        sincos(v17, &sinx, &cosx);
        v18 = v15 & 3 | (24 * (v15 >> 2));
        v19 = v16 * -12.5663706 / v13;
        v20 = cosx;
        v21 = sinx;
        *(float *)(v11 + 4LL * v18) = v20;
        *(float *)(v11 + 4LL * (int)(v18 | 4)) = v21;
        sincos(v19, &v135, &v134);
        v22 = v16 * -18.8495559 / v13;
        v23 = v134;
        v24 = v135;
        *(float *)(v11 + 4LL * (v18 + 8)) = v23;
        *(float *)(v11 + 4LL * (int)(v18 + 12)) = v24;
        sincos(v22, v137, &v136);
        ++v15;
        v25 = v136;
        v26 = v137[0];
        v16 = v16 + 1.0;
        *(float *)(v11 + 4LL * (v18 + 16)) = v25;
        *(float *)(v11 + 4LL * (int)(v18 + 20)) = v26;
      }
      while ( v8 != v15 );
    }
    cffti1_ps(v99 / 4, v14, &v9->n128_i32[2]);
    v27 = &v9->n128_i32[3];
    if ( v9->n128_i32[3] >= 1 )
      goto LABEL_55;
    goto LABEL_60;
  }
  if ( v7 >= 4 )
  {
    v28 = 0;
    v29 = 0.0;
    do
    {
      v30 = v29 * -6.28318531 / v13;
      sincos(v30, &v127, &v126);
      v31 = v28 & 3 | (24 * (v28 >> 2));
      v32 = v29 * -12.5663706 / v13;
      v33 = v126;
      v34 = v127;
      *(float *)(v11 + 4LL * v31) = v33;
      *(float *)(v11 + 4LL * (int)(v31 | 4)) = v34;
      sincos(v32, &v129, &v128);
      v35 = v29 * -18.8495559 / v13;
      v36 = v128;
      v37 = v129;
      *(float *)(v11 + 4LL * (v31 + 8)) = v36;
      *(float *)(v11 + 4LL * (int)(v31 + 12)) = v37;
      sincos(v35, &v131, &v130);
      ++v28;
      v38 = v130;
      v39 = v131;
      v29 = v29 + 1.0;
      *(float *)(v11 + 4LL * (v31 + 16)) = v38;
      *(float *)(v11 + 4LL * (int)(v31 + 20)) = v39;
    }
    while ( v8 != v28 );
  }
  v40 = 0;
  LODWORD(v41) = 0;
  v42 = v99 / 4;
  v43 = &v9->n128_u32[2];
  v44 = 4;
  v45 = v99 / 4;
  if ( v99 / 4 == 1 )
    goto LABEL_25;
LABEL_27:
  v46 = v41 + 2;
  v47 = (int)v41;
  v48 = (__int64)&v9[1] + 4 * (int)v41;
  do
  {
    v49 = v45 / v44;
    if ( v45 != v45 / v44 * v44 )
    {
      LODWORD(v41) = v47;
      break;
    }
    v41 = v47 + 1;
    v43[v47 + 2] = v44;
    if ( v44 == 2 && v47 )
    {
      if ( v41 >= 2 )
      {
        v50 = v46 - 2LL;
        v51 = (_DWORD *)v48;
        v52 = (_DWORD *)v48;
        do
        {
          v53 = *--v52;
          --v50;
          *v51 = v53;
          v51 = v52;
        }
        while ( v50 );
      }
      v9[1].n128_u32[0] = 2;
    }
    ++v46;
    v48 += 4;
    v47 = v41;
    v45 = v49;
  }
  while ( v49 != 1 );
LABEL_25:
  while ( 1 )
  {
    v44 = dword_22460[++v40];
    if ( v40 == 4 )
      break;
    if ( v45 != 1 )
      goto LABEL_27;
  }
  v9->n128_u32[3] = v41;
  v27 = &v9->n128_i32[3];
  v9->n128_u32[2] = v42;
  if ( (int)v41 <= 1 )
    goto LABEL_54;
  v96 = v41;
  v54.n128_f64[0] = 6.28318531 / (double)v42;
  v55 = 0;
  v56 = (unsigned int)v41;
  v57 = 1;
  v58 = v54.n128_f64[0];
  v59 = 1;
  v97 = v11 + 16 * ((__int64)v12 >> 2);
  v98 = (unsigned int)v41;
  do
  {
    v61 = v43[++v57];
    v60 = v61 * v59;
    if ( v61 >= 2 )
    {
      v101 = v61 * v59;
      v100 = v61 - 1;
      v102 = v57;
      v103 = v55;
      v62 = v55;
      v63 = 1;
      v64 = (float *)(v97 + 4LL * v55);
      v105 = v42 / v60;
      v65 = (unsigned int)(v42 / v60 - 3) >> 1;
      v104 = v65 + 1;
      v109 = 0;
      v108 = v42 / v60;
      v106 = v43[v57];
      v107 = v59;
      while ( 1 )
      {
        v109 += v59;
        if ( v108 >= 3 )
        {
          if ( (unsigned int)v104 >= 4 )
          {
            v54.n128_f32[0] = v58 * (float)v109;
            v110 = vdupq_lane_s32((int32x2_t)v54.n128_u64[0], 0);
            v69 = (unsigned int)v104 & 0xFFFFFFFC;
            v54 = (int32x4_t)xmmword_16940;
            v70 = v64;
            do
            {
              v113 = v54;
              v71.n128_u64[0] = 0x100000001LL;
              v71.n128_u64[1] = 0x100000001LL;
              v72 = vmulq_f32(v110, vcvtq_f32_s32(vaddq_s32(v54, v71)));
              v111 = vcvt_hight_f64_f32(v72);
              x = vcvtq_f64_f32((float32x2_t)v72.n128_u64[0]);
              sincos(v111.n128_f64[0], &v123, &v122);
              v114 = v122;
              sincos(v111.n128_f64[1], &v125, &v124);
              v73.n128_f64[0] = v114;
              v73.n128_f64[1] = v124;
              v115 = v73;
              sincos(x.n128_f64[0], &v119, &v118);
              v111.n128_f64[0] = v118;
              sincos(x.n128_f64[1], &v121, &v120);
              v74.n128_u64[0] = v111.n128_u64[0];
              v69 -= 4;
              v74.n128_f64[1] = v120;
              v138.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(v74), v115);
              v75.n128_f64[0] = v119;
              v76.n128_f64[0] = v123;
              v75.n128_f64[1] = v121;
              v76.n128_f64[1] = v125;
              v138.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(v75), v76);
              vst2q_f32(v70, v138);
              v70 += 8;
              v138.val[1].n128_u64[0] = 0x400000004LL;
              v138.val[1].n128_u64[1] = 0x400000004LL;
              v54 = vaddq_s32(v113, v138.val[1]);
            }
            while ( v69 );
            v68 = v58 * (float)v109;
            v67 = v62 + 2LL * ((unsigned int)v104 & 0xFFFFFFFC);
            v66 = v104 & 0xFFFFFFFC;
            if ( (v104 & 0xFFFFFFFC) == v104 )
              goto LABEL_43;
          }
          else
          {
            v66 = 0;
            v67 = v62;
            v68 = v58 * (float)v109;
          }
          v77 = v66 - 1;
          v78 = (float *)(v97 + 4 + 4 * v67);
          do
          {
            sincos((float)(v68 * (float)(v77 + 2)), &v117, &v116);
            v54.n128_u32[1] = HIDWORD(v116);
            ++v77;
            v54.n128_f32[0] = v116;
            v79 = v117;
            *(v78 - 1) = v54.n128_f32[0];
            *v78 = v79;
            v68 = v58 * (float)v109;
            v78 += 2;
          }
          while ( v65 != v77 );
        }
LABEL_43:
        v59 = v107;
        ++v63;
        v62 += v105;
        v64 += v105;
        if ( v63 == v106 )
        {
          v57 = v102;
          v43 = &v9->n128_u32[2];
          v42 = v99 / 4;
          v56 = v98;
          v55 = v103 + v108 * v100;
          v60 = v101;
          break;
        }
      }
    }
    v59 = v60;
  }
  while ( v57 != v56 );
  LODWORD(v41) = v96;
  v27 = &v9->n128_i32[3];
LABEL_54:
  if ( (int)v41 < 1 )
  {
LABEL_60:
    v83 = 1;
    goto LABEL_65;
  }
LABEL_55:
  v80 = *v27;
  if ( v80 <= 1 )
    v81 = 1;
  else
    v81 = *v27;
  if ( v81 < 8 )
  {
    v82 = 0;
    v83 = 1;
    goto LABEL_64;
  }
  v82 = v81 & 0x7FFFFFFFFFFFFFF8LL;
  v84 = v9 + 2;
  v85.n128_u64[0] = 0x100000001LL;
  v85.n128_u64[1] = 0x100000001LL;
  v86 = v81 & 0x7FFFFFFFFFFFFFF8LL;
  v87.n128_u64[0] = 0x100000001LL;
  v87.n128_u64[1] = 0x100000001LL;
  do
  {
    v88 = v84[-1];
    v89 = *v84;
    v86 -= 8;
    v84 += 2;
    v85 = vmulq_s32(v88, v85);
    v87 = vmulq_s32(v89, v87);
  }
  while ( v86 );
  v90 = vmulq_s32(v87, v85);
  v91 = vmulq_s32(v90, vextq_s8(v90, v90, 8u));
  v92 = v81 == v82;
  v83 = vmulq_lane_s32(v91, (int32x2_t)v91.n128_u64[0], 1).n128_u32[0];
  if ( !v92 )
  {
    do
    {
LABEL_64:
      v93 = v9[1].n128_i32[v82++];
      v83 *= v93;
    }
    while ( v82 < v80 );
  }
LABEL_65:
  if ( v83 != v99 / 4 )
  {
    v94 = v9[4].n128_i64[1];
    if ( v94 )
      free(*(void **)(v94 - 8));
    free(v9);
    return 0;
  }
  return v9;
}
// 16940: using guessed type __int128 xmmword_16940;
// 22460: using guessed type _DWORD dword_22460[5];

//----- (0000000000045FEC) ----------------------------------------------------
void __fastcall pffft_destroy_setup(_QWORD *ptr)
{
  __int64 v1; // x8

  v1 = ptr[9];
  if ( v1 )
    free(*(void **)(v1 - 8));
  free(ptr);
}

//----- (000000000004601C) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int8x16_t __fastcall pffft_zreorder(int *a1, int32x4_t *a2, int8x16_t *a3, int a4, int8x16_t result)
{
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  int8x16_t *v7; // x11
  int v8; // w12
  int32x4_t v9; // q0
  int32x4_t v10; // q1
  int32x4_t v11; // q2
  __int64 v12; // x9
  int v13; // w8
  int32x4_t *v14; // x10
  int32x4_t *v15; // x12
  __int64 v16; // x13
  int32x4_t v17; // q0
  int32x4_t v18; // q1
  int32x4_t *v19; // x14
  int32x4_t v20; // q0
  int32x4_t v21; // q2
  int32x4_t v22; // q0
  int v23; // w12
  int8x16_t *v24; // x10
  int8x16_t v25; // q0
  int8x16_t v26; // q1
  __int64 v27; // x10
  int32x4_t *v28; // x11
  int8x16_t *v29; // x13
  int v30; // w12
  int8x16_t *v31; // x13
  int8x16_t v32; // q2
  int8x16_t v33; // q3
  int8x16_t v34; // q3
  int32x4_t v35; // q3
  int8x16_t v36; // q1
  int32x4_t v37; // q1
  int8x16_t v38; // t1
  __int64 v39; // x9
  int8x16_t *v40; // x11
  int8x16_t v41; // q1
  unsigned __int64 v42; // x12
  int v43; // w13
  float *v44; // x12
  float *v45; // x13
  float *v46; // x10
  __int64 v47; // x11
  int8x16_t *v48; // x12
  __int64 v49; // x13
  int8x16_t v50; // q0 OVERLAPPED
  int8x16_t v51; // q1
  float *v52; // x14
  float *v53; // x15
  float *v54; // x15
  int8x16_t v55; // q0 OVERLAPPED
  int8x16_t v56; // q1
  float *v57; // x14
  int32x4_t v58; // q1
  int32x4_t v59; // q2
  int v60; // w10
  int8x16_t v61; // q0
  int8x16_t v62; // q1
  int8x16_t v63; // q2
  __int64 v64; // x10
  int8x16_t *v65; // x10
  int v66; // w11
  int32x4_t *v67; // x12
  int32x4_t v68; // q2
  int32x4_t v69; // q3
  int8x16_t v70; // q4
  int8x16_t v71; // q2
  int8x16_t v72; // q3
  int8x16_t v73; // q1
  int8x16_t v74; // q2
  int8x16_t v75; // q0
  int32x4_t v76; // q1
  int32x4_t v77; // q0
  int v78; // w12
  int8x16_t *v79; // x11
  int8x16_t v80; // q0
  int8x16_t v81; // q1
  bool v82; // cc
  int32x4_t *v83; // x9
  int v84; // w8
  int8x16_t *v85; // x10
  int8x16_t v86; // q2
  int8x16_t v87; // q3
  int8x16_t v88; // q3
  int32x4_t v89; // q3
  int8x16_t v90; // q1
  int32x4_t v91; // q1
  int8x16_t v92; // t1
  int8x16_t v93; // q2
  int8x16_t v94; // q0
  int32x4_t v95; // q1
  int32x4_t v96; // q0
  int32x4_t v97; // q2
  int8x16_t v98; // q0
  int32x4_t v99; // q1
  int32x4_t v100; // q2
  __int64 v101; // x10
  int8x16_t v102; // q0
  int8x16_t v103; // q1
  int8x16_t v104; // q2
  int8x16_t *v105; // x10
  int v106; // w8
  int32x4_t *v107; // x9
  int32x4_t v108; // q2
  int32x4_t v109; // q3
  int8x16_t v110; // q4
  int8x16_t v111; // q2
  int8x16_t v112; // q3
  int8x16_t v113; // q1
  int8x16_t v114; // q0
  float32x2x2_t v115; // 0:d2.8,8:d3.8
  float32x2x2_t v116; // 0:d2.8,8:d3.8

  if ( a1[17] )
  {
    v5 = (unsigned int)a1[1];
    if ( a4 )
    {
      if ( (int)v5 >= 1 )
      {
        v6 = 0;
        v7 = a3 + 1;
        do
        {
          v8 = (v6 & 3) * ((unsigned int)v5 >> 2) + ((unsigned int)v6 >> 2);
          v9 = a2[2 * v8];
          v10 = a2[(2 * v8) | 1u];
          ++v6;
          v11 = vuzp1q_s32(v9, v10);
          result = vuzp2q_s32(v9, v10);
          v7[-1] = v11;
          *v7 = result;
          v7 += 2;
        }
        while ( v5 != v6 );
      }
    }
    else if ( (int)v5 >= 1 )
    {
      v39 = 0;
      v40 = a2 + 1;
      do
      {
        result = v40[-1];
        v41 = *v40;
        v42 = (v39 & 3) * (v5 >> 2) + ((unsigned __int64)((unsigned int)v39 & 0xFFFFFFFC) >> 2);
        ++v39;
        v43 = (2 * v42) | 1;
        v115.val[0].n64_u64[0] = vextq_s8(result, result, 8u).n128_u64[0];
        v44 = (float *)&a3[2 * v42];
        v45 = (float *)&a3[v43];
        v115.val[1].n64_u64[0] = vextq_s8(v41, v41, 8u).n128_u64[0];
        v40 += 2;
        vst2_f32(v44, (float32x2x2_t)result);
        vst2_f32(v45, v115);
      }
      while ( v5 != v39 );
    }
  }
  else
  {
    v12 = *a1;
    v13 = (int)v12 / 32;
    if ( a4 )
    {
      if ( (int)v12 >= 32 )
      {
        v14 = a2 + 1;
        v15 = a3 + 5;
        v16 = (unsigned int)((int)v12 / 32);
        do
        {
          v17 = v14[-1];
          v18 = *v14;
          v19 = &v14[4 * v13];
          v14 += 2;
          --v16;
          v15[-5] = vuzp1q_s32(v17, v18);
          v15[-4] = vuzp2q_s32(v17, v18);
          v20 = v19[-1];
          v21 = vuzp1q_s32(v20, *v19);
          v22 = vuzp2q_s32(v20, *v19);
          v15[-1] = v21;
          *v15 = v22;
          v15 += 8;
        }
        while ( v16 );
      }
      if ( (int)v12 >= 0 )
        v23 = v12;
      else
        v23 = v12 + 3;
      v24 = (int32x4_t *)((char *)a2 + 4 * (v23 >> 2));
      v25 = *v24;
      v26 = v24[1];
      v27 = (__int64)a3 + 4 * v12;
      v28 = (int32x4_t *)(v27 - 96);
      if ( (int)v12 < 64 )
      {
        v32 = v25;
      }
      else
      {
        v29 = (int32x4_t *)((char *)a2 + 4 * ((__int64)v23 >> 2));
        v30 = v13 - 1;
        v31 = v29 + 3;
        v32 = v25;
        do
        {
          v33 = v32;
          v32 = v31[-1];
          v34 = vextq_s8(v33, v26, 8u);
          v35 = vextq_s8(v34, v34, 8u);
          --v30;
          v36 = vextq_s8(v26, v32, 8u);
          v37 = vextq_s8(v36, v36, 8u);
          *v28 = vuzp1q_s32(v37, v35);
          v28[1] = vuzp2q_s32(v37, v35);
          v28 -= 8;
          v38 = *v31;
          v31 += 2;
          v26 = v38;
        }
        while ( v30 );
      }
      v74 = vextq_s8(v32, v26, 8u);
      v75 = vextq_s8(v26, v25, 8u);
      v76 = vextq_s8(v74, v74, 8u);
      v77 = vextq_s8(v75, v75, 8u);
      v78 = 3 * v12 + (3 * (int)v12 < 0 ? 3 : 0);
      *v28 = vuzp1q_s32(v77, v76);
      v28[1] = vuzp2q_s32(v77, v76);
      v79 = (int32x4_t *)((char *)a2 + 4 * (3 * (int)v12 / 4));
      v80 = *v79;
      v81 = v79[1];
      v82 = (int)v12 < 64;
      v83 = (int32x4_t *)(v27 - 32);
      if ( v82 )
      {
        v86 = *v79;
      }
      else
      {
        v84 = v13 - 1;
        v85 = (int32x4_t *)((char *)a2 + 4 * ((__int64)v78 >> 2) + 48);
        v86 = *v79;
        do
        {
          v87 = v86;
          v86 = v85[-1];
          v88 = vextq_s8(v87, v81, 8u);
          v89 = vextq_s8(v88, v88, 8u);
          --v84;
          v90 = vextq_s8(v81, v86, 8u);
          v91 = vextq_s8(v90, v90, 8u);
          *v83 = vuzp1q_s32(v91, v89);
          v83[1] = vuzp2q_s32(v91, v89);
          v83 -= 8;
          v92 = *v85;
          v85 += 2;
          v81 = v92;
        }
        while ( v84 );
      }
      v93 = vextq_s8(v86, v81, 8u);
      v94 = vextq_s8(v81, v80, 8u);
      v95 = vextq_s8(v93, v93, 8u);
      v96 = vextq_s8(v94, v94, 8u);
      v97 = vuzp1q_s32(v96, v95);
      result = vuzp2q_s32(v96, v95);
      *v83 = v97;
      v83[1] = result;
    }
    else
    {
      if ( (int)v12 >= 32 )
      {
        v46 = (float *)&a3[1];
        v48 = a2 + 5;
        v49 = (unsigned int)((int)v12 / 32);
        do
        {
          v50 = v48[-5];
          v51 = v48[-4];
          v52 = v46 - 4;
          v53 = v46;
          v46 += 8;
          v116.val[0].n64_u64[0] = vextq_s8(v50, v50, 8u).n128_u64[0];
          v116.val[1].n64_u64[0] = vextq_s8(v51, v51, 8u).n128_u64[0];
          vst2_f32(v52, (float32x2x2_t)v50);
          vst2_f32(v53, v116);
          v47 = 16LL * v13;
          v54 = &v53[v47];
          v55 = v48[-1];
          v56 = *v48;
          --v49;
          v57 = v54 - 4;
          v48 += 8;
          v116.val[0].n64_u64[0] = vextq_s8(v55, v55, 8u).n128_u64[0];
          v116.val[1].n64_u64[0] = vextq_s8(v56, v56, 8u).n128_u64[0];
          vst2_f32(v57, (float32x2x2_t)v55);
          vst2_f32(v54, v116);
        }
        while ( v49 );
      }
      v58 = a2[2];
      v59 = a2[3];
      if ( (int)v12 >= 0 )
        v60 = v12;
      else
        v60 = v12 + 1;
      v61 = vzip1q_s32(v58, v59);
      v62 = vzip2q_s32(v58, v59);
      v63 = vextq_s8(v61, v62, 8u);
      v64 = (__int64)a3 + 4 * (v60 >> 1);
      *(int8x16_t *)(v64 - 16) = vextq_s8(v63, v63, 8u);
      v65 = (int8x16_t *)(v64 - 16);
      if ( (int)v12 < 64 )
      {
        v71 = v62;
      }
      else
      {
        v66 = v13 - 1;
        v67 = a2 + 11;
        do
        {
          v68 = v67[-1];
          v69 = *v67;
          --v66;
          v67 += 8;
          v70 = vzip1q_s32(v68, v69);
          v71 = vzip2q_s32(v68, v69);
          v72 = vextq_s8(v70, v71, 8u);
          v73 = vextq_s8(v62, v70, 8u);
          v65[-2] = vextq_s8(v72, v72, 8u);
          v65 -= 2;
          v65[1] = vextq_s8(v73, v73, 8u);
          v62 = v71;
        }
        while ( v66 );
      }
      v98 = vextq_s8(v71, v61, 8u);
      v65[-1] = vextq_s8(v98, v98, 8u);
      v99 = a2[6];
      v100 = a2[7];
      v101 = (__int64)a3 + 4 * v12;
      v102 = vzip1q_s32(v99, v100);
      v103 = vzip2q_s32(v99, v100);
      v104 = vextq_s8(v102, v103, 8u);
      *(int8x16_t *)(v101 - 16) = vextq_s8(v104, v104, 8u);
      v105 = (int8x16_t *)(v101 - 16);
      if ( (int)v12 < 64 )
      {
        v111 = v103;
      }
      else
      {
        v106 = v13 - 1;
        v107 = a2 + 15;
        do
        {
          v108 = v107[-1];
          v109 = *v107;
          --v106;
          v107 += 8;
          v110 = vzip1q_s32(v108, v109);
          v111 = vzip2q_s32(v108, v109);
          v112 = vextq_s8(v110, v111, 8u);
          v113 = vextq_s8(v103, v110, 8u);
          v105[-2] = vextq_s8(v112, v112, 8u);
          v105 -= 2;
          v105[1] = vextq_s8(v113, v113, 8u);
          v103 = v111;
        }
        while ( v106 );
      }
      v114 = vextq_s8(v111, v102, 8u);
      result = vextq_s8(v114, v114, 8u);
      v105[-1] = result;
    }
  }
  return result;
}
// 461C9: failed to expand linear variable q0.16
// 461E9: failed to expand linear variable q0.16
// 4601C: fragmented variable at q0.16 may be wrong

//----- (00000000000463B8) ----------------------------------------------------
float32x4_t __fastcall pffft_cplx_finalize(int a1, int32x4_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  __int64 v4; // x8
  int32x4_t *v5; // x9
  float32x4_t *v6; // x10
  int32x4_t v7; // q0
  int32x4_t v8; // q1
  int32x4_t v9; // q2
  int32x4_t v10; // q3
  int32x4_t v11; // q5
  int32x4_t v12; // q6
  int32x4_t v13; // q7
  float32x4_t v14; // q16
  float32x4_t v15; // q17
  float32x4_t v16; // q18
  float32x4_t v17; // q19
  float32x4_t v18; // q21
  int32x4_t v19; // q22
  int32x4_t v20; // q0
  int32x4_t v21; // q4
  int32x4_t v22; // q2
  int32x4_t v23; // q6
  int32x4_t v24; // q1
  int32x4_t v25; // q5
  int32x4_t v26; // q3
  float32x4_t v27; // q7
  float32x4_t v28; // q4
  float32x4_t v29; // q22
  float32x4_t v30; // q0
  float32x4_t v31; // q2
  float32x4_t v32; // q5
  float32x4_t v33; // q6
  float32x4_t v34; // q1
  float32x4_t v35; // q3
  float32x4_t v36; // q4
  float32x4_t v37; // q17
  float32x4_t v38; // q5
  float32x4_t v39; // q16
  float32x4_t v40; // q22
  float32x4_t v41; // q20
  float32x4_t v42; // q6
  float32x4_t v43; // q18
  float32x4_t v44; // q4
  float32x4_t v45; // q3
  float32x4_t v46; // q5
  float32x4_t v47; // q6
  float32x4_t v48; // q0
  float32x4_t v49; // q1
  float32x4_t v50; // q16
  float32x4_t v51; // q5
  float32x4_t v52; // q7
  float32x4_t v53; // q0
  float32x4_t v54; // q4
  float32x4_t v55; // q2
  float32x4_t v56; // q6
  float32x4_t v57; // q1
  float32x4_t v58; // q19
  float32x4_t result; // q0

  if ( a1 >= 4 )
  {
    v4 = (unsigned int)a1 >> 2;
    v5 = a2 + 4;
    v6 = a4 + 3;
    do
    {
      v7 = v5[-4];
      v8 = v5[-3];
      v9 = v5[-2];
      v10 = v5[-1];
      v11 = v5[1];
      v12 = v5[2];
      v13 = v5[3];
      v14 = v6[-3];
      v15 = v6[-2];
      v16 = v6[-1];
      v18 = v6[1];
      v17 = v6[2];
      v19 = vzip1q_s32(v7, *v5);
      v20 = vzip2q_s32(v7, *v5);
      v21 = vzip1q_s32(v9, v12);
      v22 = vzip2q_s32(v9, v12);
      v23 = vzip1q_s32(v8, v11);
      v24 = vzip2q_s32(v8, v11);
      v25 = vzip1q_s32(v10, v13);
      v26 = vzip2q_s32(v10, v13);
      v27 = vzip1q_s32(v19, v21);
      v28 = vzip2q_s32(v19, v21);
      v29 = vzip1q_s32(v20, v22);
      v30 = vzip2q_s32(v20, v22);
      v31 = vzip1q_s32(v23, v25);
      v32 = vzip2q_s32(v23, v25);
      v33 = vzip1q_s32(v24, v26);
      v34 = vzip2q_s32(v24, v26);
      v35 = vmulq_f32(v28, v15);
      v36 = vmulq_f32(v28, v14);
      v37 = vmulq_f32(v15, v32);
      v38 = vmulq_f32(v32, v14);
      v39 = vmulq_f32(v29, *v6);
      v40 = vmulq_f32(v29, v16);
      v41 = vmulq_f32(v33, *v6);
      v42 = vmulq_f32(v33, v16);
      v43 = vmulq_f32(v30, v17);
      v44 = vsubq_f32(v36, v37);
      v45 = vaddq_f32(v35, v38);
      v46 = vsubq_f32(v40, v41);
      v47 = vaddq_f32(v39, v42);
      v48 = vsubq_f32(vmulq_f32(v30, v18), vmulq_f32(v34, v17));
      v49 = vaddq_f32(v43, vmulq_f32(v34, v18));
      v50 = vaddq_f32(v27, v46);
      v51 = vsubq_f32(v27, v46);
      v52 = vaddq_f32(v44, v48);
      v53 = vsubq_f32(v44, v48);
      v54 = vaddq_f32(v31, v47);
      v55 = vsubq_f32(v31, v47);
      v56 = vaddq_f32(v45, v49);
      v57 = vsubq_f32(v45, v49);
      v58 = vsubq_f32(v55, v53);
      result = vaddq_f32(v55, v53);
      --v4;
      v5 += 8;
      v6 += 6;
      *a3 = vaddq_f32(v50, v52);
      a3[1] = vaddq_f32(v54, v56);
      a3[2] = vaddq_f32(v51, v57);
      a3[3] = v58;
      a3[4] = vsubq_f32(v50, v52);
      a3[5] = vsubq_f32(v54, v56);
      a3[6] = vsubq_f32(v51, v57);
      a3[7] = result;
      a3 += 8;
    }
    while ( v4 );
  }
  return result;
}

//----- (00000000000464D8) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall pffft_cplx_preprocess(__int64 result, float32x4_t *a2, float *a3, float32x4_t *a4)
{
  __int64 v4; // x8
  float32x4_t *v5; // x9
  float32x4_t *v6; // x10
  float32x4_t v7; // q0
  float32x4_t v8; // q1
  float32x4_t v9; // q2
  float32x4_t v10; // q3
  float32x4_t v11; // q5
  float32x4_t v12; // q6
  float32x4_t v13; // q7
  float32x4_t v14; // q16
  float32x4_t v15; // q17
  float32x4_t v16; // q18
  float32x4_t v17; // q19 OVERLAPPED
  float32x4_t v18; // q21
  float32x4_t v19; // q22
  float32x4_t v20; // q0
  float32x4_t v21; // q4
  float32x4_t v22; // q2
  float32x4_t v23; // q6
  float32x4_t v24; // q1
  float32x4_t v25; // q5
  float32x4_t v26; // q3
  int32x4_t v27; // q7
  float32x4_t v28; // q4
  int32x4_t v29; // q22
  float32x4_t v30; // q5
  float32x4_t v31; // q6
  float32x4_t v32; // q0
  float32x4_t v33; // q3
  float32x4_t v34; // q1
  float32x4_t v35; // q2
  float32x4_t v36; // q6
  float32x4_t v37; // q17
  float32x4_t v38; // q3
  float32x4_t v39; // q16
  float32x4_t v40; // q4
  float32x4_t v41; // q20
  float32x4_t v42; // q5
  float32x4_t v43; // q18
  int32x4_t v44; // q2
  int32x4_t v45; // q3
  int32x4_t v46; // q6
  int32x4_t v47; // q4
  int32x4_t v48; // q0 OVERLAPPED
  int8x16_t v49; // q16 OVERLAPPED
  float *v50; // x11
  int32x4_t v51; // q1
  int8x16_t v52; // q17
  int8x16_t v53; // q16 OVERLAPPED
  int8x16_t v54; // q17
  float *v55; // x11
  float *v56; // x11
  int8x16_t v57; // q16 OVERLAPPED
  float *v58; // x11
  int8x16_t v59; // q17
  int8x16_t v60; // q3 OVERLAPPED
  float *v61; // x11
  int8x16_t v62; // q4
  float *v63; // x11
  float *v64; // x11

  if ( (int)result >= 4 )
  {
    v4 = (unsigned int)result >> 2;
    v5 = a2 + 4;
    v6 = a4 + 3;
    do
    {
      v7 = v5[-4];
      v8 = v5[-3];
      v9 = v5[-2];
      v10 = v5[-1];
      v11 = v5[1];
      v12 = v5[2];
      v13 = v5[3];
      v14 = v6[-3];
      v15 = v6[-2];
      v16 = v6[-1];
      v18 = v6[1];
      v17 = v6[2];
      v19 = vaddq_f32(v7, *v5);
      v20 = vsubq_f32(v7, *v5);
      v21 = vaddq_f32(v9, v12);
      v22 = vsubq_f32(v9, v12);
      v23 = vaddq_f32(v8, v11);
      v24 = vsubq_f32(v8, v11);
      v25 = vaddq_f32(v10, v13);
      v26 = vsubq_f32(v10, v13);
      v27 = vaddq_f32(v19, v21);
      v28 = vsubq_f32(v19, v21);
      v29 = vaddq_f32(v23, v25);
      v30 = vsubq_f32(v23, v25);
      v31 = vsubq_f32(v20, v26);
      v32 = vaddq_f32(v20, v26);
      v33 = vaddq_f32(v24, v22);
      v34 = vsubq_f32(v24, v22);
      v35 = vmulq_f32(v15, v31);
      v36 = vmulq_f32(v31, v14);
      v37 = vmulq_f32(v33, v15);
      v38 = vmulq_f32(v33, v14);
      v39 = vmulq_f32(v28, *v6);
      v40 = vmulq_f32(v28, v16);
      v41 = vmulq_f32(v30, *v6);
      v42 = vmulq_f32(v30, v16);
      v43 = vmulq_f32(v32, v17);
      v44 = vsubq_f32(v38, v35);
      v45 = vaddq_f32(v41, v40);
      v46 = vaddq_f32(v37, v36);
      v47 = vsubq_f32(v42, v39);
      v48 = vaddq_f32(vmulq_f32(v34, v17), vmulq_f32(v32, v18));
      v49 = vzip1q_s32(v27, v45);
      v50 = a3;
      v51 = vsubq_f32(vmulq_f32(v34, v18), v43);
      v52 = vzip1q_s32(v46, v48);
      v43.n128_u64[0] = vextq_s8(v49, v49, 8u).n128_u64[0];
      vst2_f32(v50, (float32x2x2_t)v49);
      v50 += 4;
      v17.n128_u64[0] = vextq_s8(v52, v52, 8u).n128_u64[0];
      v53 = vzip1q_s32(v29, v47);
      v54 = vzip1q_s32(v44, v51);
      vst2_f32(v50, (float32x2x2_t)v53);
      v55 = a3 + 8;
      vst2_f32(v55, *(float32x2x2_t *)((char *)&v17 - 8));
      v43.n128_u64[0] = vextq_s8(v53, v53, 8u).n128_u64[0];
      v56 = a3 + 12;
      v17.n128_u64[0] = vextq_s8(v54, v54, 8u).n128_u64[0];
      v57 = vzip2q_s32(v27, v45);
      vst2_f32(v56, *(float32x2x2_t *)((char *)&v17 - 8));
      v58 = a3 + 16;
      v59 = vzip2q_s32(v46, v48);
      v60 = vzip2q_s32(v29, v47);
      vst2_f32(v58, (float32x2x2_t)v57);
      v61 = a3 + 20;
      v62 = vzip2q_s32(v44, v51);
      v48.n128_u64[0] = vextq_s8(v57, v57, 8u).n128_u64[0];
      vst2_f32(v61, (float32x2x2_t)v60);
      v63 = a3 + 24;
      v51.n128_u64[0] = vextq_s8(v59, v59, 8u).n128_u64[0];
      vst2_f32(v63, (float32x2x2_t)v48);
      v48.n128_u64[0] = vextq_s8(v60, v60, 8u).n128_u64[0];
      v64 = a3 + 28;
      --v4;
      v5 += 8;
      v6 += 6;
      v51.n128_u64[0] = vextq_s8(v62, v62, 8u).n128_u64[0];
      a3 += 32;
      vst2_f32(v64, (float32x2x2_t)v48);
    }
    while ( v4 );
  }
  return result;
}
// 4658D: failed to expand linear variable q16.16
// 465A9: failed to expand linear variable q16.16
// 46505: failed to expand linear variable q19.16
// 465C9: failed to expand linear variable q16.16
// 465D9: failed to expand linear variable q3.16
// 46589: failed to expand linear variable q0.16

//----- (0000000000046624) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int8x16_t __fastcall pffft_transform_internal(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        int a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10,
        long double a11)
{
  unsigned __int64 v12; // x19
  int v15; // w25
  __int64 v16; // x9
  float32x4_t *v17; // x10
  __int64 v18; // x22
  int v19; // w9
  float32x4_t *v20; // x24
  __int64 v21; // x27
  int8x16_t *v22; // x23
  float32x4_t *v23; // x23
  float32x4_t *v24; // x3
  unsigned __int64 v25; // x8
  float32x4_t *v26; // x9
  float32x4_t *v27; // x10
  float32x4_t v28; // q0
  float32x4_t v29; // q1
  float32x4_t v30; // q2
  float32x4_t v31; // q3
  float32x4_t v32; // q5
  float32x4_t v33; // q6
  float32x4_t v34; // q7
  float32x4_t v35; // q16
  float32x4_t v36; // q17
  float32x4_t v37; // q18
  float32x4_t v38; // q19 OVERLAPPED
  float32x4_t v39; // q21
  float32x4_t v40; // q22
  float32x4_t v41; // q0
  float32x4_t v42; // q4
  float32x4_t v43; // q2
  float32x4_t v44; // q6
  float32x4_t v45; // q1
  float32x4_t v46; // q5
  float32x4_t v47; // q3
  int32x4_t v48; // q7
  float32x4_t v49; // q4
  int32x4_t v50; // q22
  float32x4_t v51; // q5
  float32x4_t v52; // q6
  float32x4_t v53; // q0
  float32x4_t v54; // q3
  float32x4_t v55; // q1
  float32x4_t v56; // q2
  float32x4_t v57; // q6
  float32x4_t v58; // q17
  float32x4_t v59; // q3
  float32x4_t v60; // q16
  float32x4_t v61; // q4
  float32x4_t v62; // q20
  float32x4_t v63; // q5
  float32x4_t v64; // q18
  int32x4_t v65; // q3
  int32x4_t v66; // q6
  int32x4_t v67; // q4
  int8x16_t v68; // q16 OVERLAPPED
  float *v69; // x11
  int8x16_t v70; // q17
  int8x16_t v71; // q16 OVERLAPPED
  int8x16_t v72; // q17
  float *v73; // x11
  float *v74; // x11
  int8x16_t v75; // q16 OVERLAPPED
  float *v76; // x11
  int8x16_t v77; // q17
  float *v78; // x11
  float *v79; // x11
  float *v80; // x11
  float32x4_t *v81; // x25
  float32x4_t *v82; // x8
  long double *n128_u64; // x10
  long double *v84; // x11
  unsigned __int64 v85; // x12
  int32x4_t v86; // q0
  float32x4_t *v87; // x0
  int8x16_t result; // q0 OVERLAPPED
  _BOOL4 v89; // w22
  float32x4_t *v90; // x8
  unsigned __int64 v91; // x9
  __int64 v92; // x10
  __int64 v93; // x11
  int32x4_t v94; // q0
  int32x4_t v95; // q1
  int32x4_t v96; // q2
  int32x4_t v97; // q3
  int32x4_t v98; // q5
  int32x4_t v99; // q6
  int32x4_t v100; // q7
  float32x4_t v101; // q16
  float32x4_t v102; // q17
  float32x4_t v103; // q18
  float32x4_t v104; // q19
  float32x4_t v105; // q21
  int32x4_t v106; // q22
  int32x4_t v107; // q0
  int32x4_t v108; // q4
  int32x4_t v109; // q2
  int32x4_t v110; // q6
  int32x4_t v111; // q1
  int32x4_t v112; // q5
  int32x4_t v113; // q3
  float32x4_t v114; // q7
  float32x4_t v115; // q4
  float32x4_t v116; // q22
  float32x4_t v117; // q0
  float32x4_t v118; // q2
  float32x4_t v119; // q5
  float32x4_t v120; // q6
  float32x4_t v121; // q1
  float32x4_t v122; // q3
  float32x4_t v123; // q4
  float32x4_t v124; // q17
  float32x4_t v125; // q5
  float32x4_t v126; // q16
  float32x4_t v127; // q22
  float32x4_t v128; // q20
  float32x4_t v129; // q6
  float32x4_t v130; // q18
  float32x4_t v131; // q4
  float32x4_t v132; // q3
  float32x4_t v133; // q5
  float32x4_t v134; // q6
  float32x4_t v135; // q0
  float32x4_t v136; // q1
  float32x4_t v137; // q16
  float32x4_t v138; // q5
  float32x4_t v139; // q7
  float32x4_t v140; // q0
  float32x4_t v141; // q4
  float32x4_t v142; // q2
  float32x4_t v143; // q6
  float32x4_t v144; // q1
  float32x4_t v145; // q19
  int v146; // w8
  float32x4_t *v147; // x0
  float *v148; // x11
  unsigned __int64 v149; // x9
  float *v150; // x10
  float *v151; // x12
  int8x16_t v152; // t1
  int8x16_t v153; // q1
  float32x4_t *v154; // x0
  float32x4_t *v155; // x9
  float32x4_t *v156; // x8
  int8x16_t *v157; // x9
  int8x16_t v158; // q1
  _QWORD v160[3]; // [xsp+8h] [xbp-68h]
  float32x2x2_t v161; // 0:d2.8,8:d3.8

  v160[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v12 = *(unsigned int *)(a1 + 4);
  v15 = 2 * v12;
  if ( a4 )
    v16 = 1;
  else
    v16 = (unsigned int)(2 * v12);
  v17 = (float32x4_t *)&v160[-2 * v16 - 1];
  v18 = a1 + 8;
  v19 = *(_DWORD *)(a1 + 12) & 1;
  if ( a4 )
    v20 = a4;
  else
    v20 = v17;
  v160[0] = a3;
  v160[1] = v20;
  if ( !a5 )
  {
    v82 = (float32x4_t *)v160[v19 == a6];
    if ( *(_DWORD *)(a1 + 68) )
    {
      if ( (int)v12 >= 1 )
      {
        n128_u64 = (long double *)v82[1].n128_u64;
        v84 = (long double *)a2[1].n128_u64;
        v85 = v12;
        do
        {
          v86 = *(int32x4_t *)(v84 - 1);
          a8 = *v84;
          --v85;
          v84 += 2;
          a9 = COERCE_LONG_DOUBLE(vuzp1q_s32(v86, *(int32x4_t *)&a8));
          a7 = COERCE_LONG_DOUBLE(vuzp2q_s32(v86, *(int32x4_t *)&a8));
          *(n128_u64 - 1) = a9;
          *n128_u64 = a7;
          n128_u64 += 2;
        }
        while ( v85 );
      }
      v87 = cfftf1_ps(
              v12,
              v82,
              (float32x4_t *)v160[v19 != a6],
              v82,
              *(_QWORD *)(a1 + 88),
              v18,
              -1,
              *(double *)&a7,
              *(double *)&a8,
              *(double *)&a9,
              *(double *)&a10,
              a11);
      v89 = v87 != a3;
      if ( (int)v12 >= 4 )
      {
        v90 = (float32x4_t *)v160[v87 == a3];
        v91 = v12 >> 2;
        v92 = v160[v87 != a3] + 64LL;
        v93 = *(_QWORD *)(a1 + 80) + 48LL;
        do
        {
          v94 = *(int32x4_t *)(v92 - 64);
          v95 = *(int32x4_t *)(v92 - 48);
          v96 = *(int32x4_t *)(v92 - 32);
          v97 = *(int32x4_t *)(v92 - 16);
          v98 = *(int32x4_t *)(v92 + 16);
          v99 = *(int32x4_t *)(v92 + 32);
          v100 = *(int32x4_t *)(v92 + 48);
          v101 = *(float32x4_t *)(v93 - 48);
          v102 = *(float32x4_t *)(v93 - 32);
          v103 = *(float32x4_t *)(v93 - 16);
          v105 = *(float32x4_t *)(v93 + 16);
          v104 = *(float32x4_t *)(v93 + 32);
          v106 = vzip1q_s32(v94, *(int32x4_t *)v92);
          v107 = vzip2q_s32(v94, *(int32x4_t *)v92);
          v108 = vzip1q_s32(v96, v99);
          v109 = vzip2q_s32(v96, v99);
          v110 = vzip1q_s32(v95, v98);
          v111 = vzip2q_s32(v95, v98);
          v112 = vzip1q_s32(v97, v100);
          v113 = vzip2q_s32(v97, v100);
          v114 = vzip1q_s32(v106, v108);
          v115 = vzip2q_s32(v106, v108);
          v116 = vzip1q_s32(v107, v109);
          v117 = vzip2q_s32(v107, v109);
          v118 = vzip1q_s32(v110, v112);
          v119 = vzip2q_s32(v110, v112);
          v120 = vzip1q_s32(v111, v113);
          v121 = vzip2q_s32(v111, v113);
          v122 = vmulq_f32(v115, v102);
          v123 = vmulq_f32(v115, v101);
          v124 = vmulq_f32(v102, v119);
          v125 = vmulq_f32(v119, v101);
          v126 = vmulq_f32(v116, *(float32x4_t *)v93);
          v127 = vmulq_f32(v116, v103);
          v128 = vmulq_f32(v120, *(float32x4_t *)v93);
          v129 = vmulq_f32(v120, v103);
          v130 = vmulq_f32(v117, v104);
          v131 = vsubq_f32(v123, v124);
          v132 = vaddq_f32(v122, v125);
          v133 = vsubq_f32(v127, v128);
          v134 = vaddq_f32(v126, v129);
          v135 = vsubq_f32(vmulq_f32(v117, v105), vmulq_f32(v121, v104));
          v136 = vaddq_f32(v130, vmulq_f32(v121, v105));
          v137 = vaddq_f32(v114, v133);
          v138 = vsubq_f32(v114, v133);
          v139 = vaddq_f32(v131, v135);
          v140 = vsubq_f32(v131, v135);
          v141 = vaddq_f32(v118, v134);
          v142 = vsubq_f32(v118, v134);
          v143 = vaddq_f32(v132, v136);
          v144 = vsubq_f32(v132, v136);
          v145 = vsubq_f32(v142, v140);
          result = vaddq_f32(v142, v140);
          --v91;
          v92 += 128;
          v93 += 96;
          *v90 = vaddq_f32(v137, v139);
          v90[1] = vaddq_f32(v141, v143);
          v90[2] = vaddq_f32(v138, v144);
          v90[3] = v145;
          v90[4] = vsubq_f32(v137, v139);
          v90[5] = vsubq_f32(v141, v143);
          v90[6] = vsubq_f32(v138, v144);
          v90[7] = result;
          v90 += 8;
        }
        while ( v91 );
      }
      v146 = v87 == a3;
      if ( !a6 )
        goto LABEL_32;
    }
    else
    {
      v154 = sub_46B74(v15, a2, v82, (float32x4_t *)v160[v19 != a6], *(float32x4_t **)(a1 + 88), v18);
      v89 = v154 != a3;
      result = sub_473E4(v12, v160[v154 != a3], (float32x4_t *)v160[v154 == a3], (float32x4_t *)*(_QWORD *)(a1 + 80));
      v146 = !v89;
      if ( !a6 )
        goto LABEL_32;
    }
    result = pffft_zreorder((int *)a1, (int32x4_t *)v160[v146], (int8x16_t *)v160[v89], 0, result);
    v146 = v89;
    goto LABEL_32;
  }
  v21 = (v19 != a6) ^ (unsigned int)(v160[v19 != a6] == (_QWORD)a2);
  if ( a6 )
  {
    v22 = (int8x16_t *)v160[(unsigned int)v21];
    *(_QWORD *)&a7 = pffft_zreorder((int *)a1, a2, v22, 1, *(int8x16_t *)&a7).n128_u64[0];
    v21 = (unsigned int)v21 ^ 1;
    a2 = v22;
  }
  v23 = (float32x4_t *)v160[(unsigned int)v21];
  v24 = *(float32x4_t **)(a1 + 80);
  if ( !*(_DWORD *)(a1 + 68) )
  {
    sub_47698(v12, a2, (float *)v160[(unsigned int)v21], v24);
    v146 = sub_47A0C(v15, v23, a3, v20, *(_QWORD *)(a1 + 88), v18) != a3;
    goto LABEL_32;
  }
  if ( (int)v12 < 4 )
  {
    v81 = a3;
  }
  else
  {
    v25 = v12 >> 2;
    v26 = a2 + 4;
    v27 = v24 + 3;
    do
    {
      v28 = v26[-4];
      v29 = v26[-3];
      v30 = v26[-2];
      v31 = v26[-1];
      v32 = v26[1];
      v33 = v26[2];
      v34 = v26[3];
      v35 = v27[-3];
      v36 = v27[-2];
      v37 = v27[-1];
      v39 = v27[1];
      v38 = v27[2];
      v40 = vaddq_f32(v28, *v26);
      v41 = vsubq_f32(v28, *v26);
      v42 = vaddq_f32(v30, v33);
      v43 = vsubq_f32(v30, v33);
      v44 = vaddq_f32(v29, v32);
      v45 = vsubq_f32(v29, v32);
      v46 = vaddq_f32(v31, v34);
      v47 = vsubq_f32(v31, v34);
      v48 = vaddq_f32(v40, v42);
      v49 = vsubq_f32(v40, v42);
      v50 = vaddq_f32(v44, v46);
      v51 = vsubq_f32(v44, v46);
      v52 = vsubq_f32(v41, v47);
      v53 = vaddq_f32(v41, v47);
      v54 = vaddq_f32(v45, v43);
      v55 = vsubq_f32(v45, v43);
      v56 = vmulq_f32(v36, v52);
      v57 = vmulq_f32(v52, v35);
      v58 = vmulq_f32(v54, v36);
      v59 = vmulq_f32(v54, v35);
      v60 = vmulq_f32(v49, *v27);
      v61 = vmulq_f32(v49, v37);
      v62 = vmulq_f32(v51, *v27);
      v63 = vmulq_f32(v51, v37);
      v64 = vmulq_f32(v53, v38);
      a9 = COERCE_LONG_DOUBLE(vsubq_f32(v59, v56));
      v65 = vaddq_f32(v62, v61);
      v66 = vaddq_f32(v58, v57);
      v67 = vsubq_f32(v63, v60);
      a7 = COERCE_LONG_DOUBLE(vaddq_f32(vmulq_f32(v55, v38), vmulq_f32(v53, v39)));
      v68 = vzip1q_s32(v48, v65);
      v69 = (float *)v23;
      a8 = COERCE_LONG_DOUBLE(vsubq_f32(vmulq_f32(v55, v39), v64));
      v70 = vzip1q_s32(v66, *(int32x4_t *)&a7);
      v64.n128_u64[0] = vextq_s8(v68, v68, 8u).n128_u64[0];
      vst2_f32(v69, (float32x2x2_t)v68);
      v69 += 4;
      v38.n128_u64[0] = vextq_s8(v70, v70, 8u).n128_u64[0];
      v71 = vzip1q_s32(v50, v67);
      v72 = vzip1q_s32(*(int32x4_t *)&a9, *(int32x4_t *)&a8);
      vst2_f32(v69, (float32x2x2_t)v71);
      v73 = (float *)&v23[2];
      vst2_f32(v73, *(float32x2x2_t *)((char *)&v38 - 8));
      v64.n128_u64[0] = vextq_s8(v71, v71, 8u).n128_u64[0];
      v74 = (float *)&v23[3];
      v38.n128_u64[0] = vextq_s8(v72, v72, 8u).n128_u64[0];
      v75 = vzip2q_s32(v48, v65);
      vst2_f32(v74, *(float32x2x2_t *)((char *)&v38 - 8));
      v76 = (float *)&v23[4];
      v77 = vzip2q_s32(v66, *(int32x4_t *)&a7);
      a10 = COERCE_LONG_DOUBLE(vzip2q_s32(v50, v67));
      vst2_f32(v76, (float32x2x2_t)v75);
      v78 = (float *)&v23[5];
      a11 = COERCE_LONG_DOUBLE(vzip2q_s32(*(int32x4_t *)&a9, *(int32x4_t *)&a8));
      *(_QWORD *)&a7 = vextq_s8(v75, v75, 8u).n128_u64[0];
      vst2_f32(v78, *(float32x2x2_t *)&a10);
      v79 = (float *)&v23[6];
      *(_QWORD *)&a8 = vextq_s8(v77, v77, 8u).n128_u64[0];
      vst2_f32(v79, *(float32x2x2_t *)&a7);
      *(_QWORD *)&a7 = vextq_s8(*(int8x16_t *)&a10, *(int8x16_t *)&a10, 8u).n128_u64[0];
      v80 = (float *)&v23[7];
      --v25;
      v26 += 8;
      v27 += 6;
      *(_QWORD *)&a8 = vextq_s8(*(int8x16_t *)&a11, *(int8x16_t *)&a11, 8u).n128_u64[0];
      v23 += 8;
      vst2_f32(v80, *(float32x2x2_t *)&a7);
    }
    while ( v25 );
    v23 = (float32x4_t *)v160[v21];
    v81 = (float32x4_t *)v160[0];
  }
  v147 = cfftf1_ps(
           v12,
           v23,
           v81,
           v20,
           *(_QWORD *)(a1 + 88),
           v18,
           1,
           *(double *)&a7,
           *(double *)&a8,
           *(double *)&a9,
           *(double *)&a10,
           a11);
  v146 = v147 != v81;
  if ( (int)v12 >= 1 )
  {
    v148 = (float *)(v160[v147 != v81] + 16LL);
    v149 = v12;
    v150 = v148;
    do
    {
      v151 = v148 - 4;
      result = *(int8x16_t *)(v148 - 4);
      v152 = *(int8x16_t *)v150;
      v150 += 8;
      v153 = v152;
      v161.val[0].n64_u64[0] = vextq_s8(result, result, 8u).n128_u64[0];
      --v149;
      v161.val[1].n64_u64[0] = vextq_s8(v153, v153, 8u).n128_u64[0];
      vst2_f32(v151, (float32x2x2_t)result);
      vst2_f32(v148, v161);
      v148 = v150;
    }
    while ( v149 );
LABEL_32:
    v155 = (float32x4_t *)v160[v146];
    if ( v155 != a3 && (int)v12 >= 1 )
    {
      v156 = a3 + 1;
      v157 = v155 + 1;
      do
      {
        result = v157[-1];
        v158 = *v157;
        --v12;
        v157 += 2;
        v156[-1] = result;
        *v156 = v158;
        v156 += 2;
      }
      while ( v12 );
    }
  }
  return result;
}
// 46795: failed to expand linear variable q16.16
// 467B1: failed to expand linear variable q16.16
// 4670D: failed to expand linear variable q19.16
// 467D1: failed to expand linear variable q16.16
// 46624: fragmented variable at q0.16 may be wrong
// 46624: fragmented variable at q3.16 may be wrong

//----- (0000000000046B74) ----------------------------------------------------
float32x4_t *__fastcall sub_46B74(
        int a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        float32x4_t *a5,
        __int64 a6)
{
  __int64 v6; // x8
  float32x4_t *v8; // x2
  float32x4_t v9; // q26
  __int64 v10; // x11
  int v11; // w12
  __int64 v12; // x14
  float32x4_t v13; // q25
  float32x4_t v14; // q27
  float32x4_t v15; // q28
  float32x4_t *v16; // x24
  float32x4_t v17; // q29
  float32x4_t v18; // q30
  __int64 v19; // x26
  bool v20; // zf
  float32x4_t *v21; // x10
  int v22; // w8
  int v23; // w13
  float32x4_t *v24; // kr08_8
  __int64 v25; // kr20_8
  int v26; // w10
  __int64 v27; // x17
  __int64 v28; // x10
  __int64 v29; // x5
  float32x4_t *v30; // x6
  float32x4_t v31; // q0
  float32x4_t v32; // q1
  float32x4_t v33; // q2
  float32x4_t v34; // q3
  __int64 v35; // x12
  float32x4_t *v36; // x13
  __int64 v37; // x14
  float32x4_t *v38; // x17
  float32x4_t *v39; // x1
  __int64 v40; // x5
  __int64 v41; // x6
  float *v42; // x7
  float *v43; // x19
  __int64 v44; // x20
  __int64 v45; // x21
  float v46; // s0
  float v47; // s2
  float32x4_t v48; // q4
  float32x4_t v49; // q5
  float32x4_t v50; // q6
  float32x4_t v51; // q7
  float32x4_t *v52; // x23
  float32x4_t v53; // q16
  float32x4_t v54; // q4
  float32x4_t v55; // q1
  float32x4_t v56; // q0
  float32x4_t v57; // q5
  float32x4_t v58; // q6
  float32x4_t v59; // q3
  float32x4_t v60; // q2
  float32x4_t v61; // q7
  float32x4_t v62; // q1
  float32x4_t v63; // q3
  float32x4_t v64; // q4
  float32x4_t v65; // q6
  float32x4_t v66; // q0
  float32x4_t v67; // q2
  float32x4_t v68; // q5
  float32x4_t v69; // q0
  float32x4_t v70; // q2
  float32x4_t *v71; // x22
  float32x4_t v72; // q1
  float32x4_t v73; // q4
  float32x4_t v74; // q0
  float32x4_t v75; // q2
  int v76; // w14
  int v77; // w8
  __int64 v78; // x3
  int v79; // w15
  __int64 v80; // x17
  __int64 v81; // x1
  __int64 v82; // x5
  __int64 v83; // x6
  __int64 v84; // x7
  __int64 v85; // x9
  __int64 v86; // x20
  float32x4_t v87; // q0
  float32x4_t v88; // q1
  float32x4_t v89; // q2
  float32x4_t v90; // q3
  float32x4_t v91; // q4
  float32x4_t v92; // q5
  float32x4_t v93; // q0
  float32x4_t v94; // q1
  float32x4_t v95; // q2
  float32x4_t *v96; // x23
  float32x4_t *v97; // x23
  __int64 v98; // x6
  __int64 v99; // x14
  __int64 v100; // x19
  __int64 v101; // x21
  __int64 v102; // x14
  __int64 v103; // x15
  __int64 v104; // x16
  int v105; // w25
  float32x4_t *v106; // x7
  int v107; // w19
  float32x4_t *v108; // x22
  float32x4_t *v109; // x8
  __int64 v110; // x12
  __int64 v111; // x13
  __int64 v112; // x2
  __int64 v113; // x5
  float32x4_t *v114; // x6
  float32x4_t *v115; // x7
  float32x4_t *v116; // x30
  float32x4_t *v117; // x23
  __int64 v118; // x28
  __int64 v119; // x20
  __int64 v120; // x0
  __int8 *v121; // x21
  __int64 v122; // x22
  int v123; // w1
  int v124; // w17
  __int64 v125; // x10
  float v126; // s0
  float v127; // s1
  float v128; // s2
  float v129; // s3
  float v130; // s4
  float v131; // s5
  float v132; // s6
  float v133; // s7
  float32x4_t v134; // q16
  float32x4_t v135; // q17
  float32x4_t v136; // q18
  float32x4_t v137; // q19
  float32x4_t v138; // q20
  float32x4_t v139; // q21
  float32x4_t v140; // q22
  float32x4_t v141; // q23
  float32x4_t v142; // q24
  float32x4_t v143; // q0
  float32x4_t v144; // q16
  float32x4_t v145; // q1
  float32x4_t v146; // q17
  float32x4_t v147; // q2
  float32x4_t v148; // q18
  float32x4_t v149; // q3
  float32x4_t v150; // q19
  float32x4_t v151; // q4
  float32x4_t v152; // q20
  float32x4_t v153; // q5
  float32x4_t v154; // q21
  float32x4_t v155; // q16
  float32x4_t v156; // q0
  float32x4_t v157; // q1
  float32x4_t v158; // q2
  float32x4_t v159; // q4
  float32x4_t v160; // q6
  float32x4_t v161; // q7
  float32x4_t v162; // q3
  float32x4_t v163; // q5
  float32x4_t v164; // q17
  float32x4_t v165; // q6
  float32x4_t v166; // q16
  float32x4_t v167; // q1
  float32x4_t v168; // q7
  float32x4_t v169; // q2
  float32x4_t v170; // q4
  float32x4_t v171; // q3
  float32x4_t *v172; // x26
  float32x4_t v173; // q5
  float32x4_t v174; // q18
  float32x4_t v175; // q19
  float32x4_t v176; // q21
  float32x4_t v177; // q22
  float32x4_t v178; // q5
  float32x4_t *v179; // x11
  float32x4_t v180; // q19
  float32x4_t v181; // q1
  float32x4_t v182; // q3
  float32x4_t v183; // q0
  float32x4_t v184; // q2
  float32x4_t v185; // q1
  float32x4_t v187; // [xsp+0h] [xbp-110h]
  float32x4_t v188; // [xsp+10h] [xbp-100h]
  float32x4_t v189; // [xsp+20h] [xbp-F0h]
  float32x4_t v190; // [xsp+30h] [xbp-E0h]
  float32x4_t v191; // [xsp+40h] [xbp-D0h]
  float32x4_t *v192; // [xsp+58h] [xbp-B8h]
  __int64 v193; // [xsp+60h] [xbp-B0h]
  int v194; // [xsp+68h] [xbp-A8h]
  int v195; // [xsp+6Ch] [xbp-A4h]
  float32x4_t *v196; // [xsp+70h] [xbp-A0h]
  __int8 *v199; // [xsp+88h] [xbp-88h]
  __int64 v200; // [xsp+90h] [xbp-80h]
  int v201; // [xsp+9Ch] [xbp-74h]
  __int64 v202; // [xsp+A0h] [xbp-70h]
  int v203; // [xsp+A8h] [xbp-68h]
  float32x4_t *v204; // [xsp+B0h] [xbp-60h]

  v6 = *(unsigned int *)(a6 + 4);
  v8 = a2;
  if ( (int)v6 >= 1 )
  {
    v192 = a5;
    v193 = v6 + 1;
    v199 = &a5->n128_i8[4];
    v194 = v6 + 2;
    v9 = vdupq_n_s32(0x3F5DB3D7u);
    v10 = 1064532081;
    v11 = a1 - 1;
    v12 = 1;
    v13.n128_u64[0] = 0xBF000000BF000000LL;
    v13.n128_u64[1] = 0xBF000000BF000000LL;
    v14 = vdupq_n_s32(0x3E9E377Au);
    v15 = vdupq_n_s32(0xBF4F1BBD);
    if ( a2 == a4 )
      v16 = a3;
    else
      v16 = a4;
    v17 = vdupq_n_s32(0x3F737871u);
    v18 = vdupq_n_s32(0x3F167918u);
    LODWORD(v19) = a1;
    v190 = v14;
    v191 = v9;
    v188 = v17;
    v189 = v15;
    v187 = v18;
    v196 = a3;
    v195 = a1;
    do
    {
      v21 = (float32x4_t *)(unsigned int)(a1 / (int)v19);
      v200 = v12;
      v22 = *(_DWORD *)(a6 + 4LL * (v194 - (int)v12));
      v19 = (unsigned int)((int)v19 / v22);
      v23 = v22 - 1;
      v203 = v11 - (_DWORD)v21 * (v22 - 1);
      v204 = v21;
      v24 = a5;
      v25 = v10;
      v10 = (__int64)v192;
      v26 = 2 * v19;
      a5 = (float32x4_t *)((char *)v192 + 4 * v203);
      switch ( v22 )
      {
        case 2:
          sub_48770((int)v204, v19, v8, (__int64)v16, (__int64)a5);
          goto LABEL_7;
        case 3:
          if ( (int)v19 >= 1 )
          {
            v27 = v26;
            v28 = 16LL * (int)v204;
            v10 = 48LL * (int)v204;
            a5 = v16;
            v29 = (unsigned int)v19;
            v30 = v8;
            do
            {
              v31 = v30[(int)v19 * (__int64)(int)v204];
              v32 = *(float32x4_t *)((char *)v30 + v28 * v27);
              v33 = *v30;
              v30 = (float32x4_t *)((char *)v30 + v28);
              --v29;
              v34 = vaddq_f32(v31, v32);
              *a5 = vaddq_f32(v33, v34);
              a5[2 * (int)v204] = vmulq_f32(vsubq_f32(v32, v31), v9);
              a5[(int)v204 + (__int64)((int)v204 - 1)] = vaddq_f32(v33, vmulq_f32(v34, v13));
              a5 = (float32x4_t *)((char *)a5 + v10);
            }
            while ( v29 );
            if ( (_DWORD)v204 != 1 )
            {
              v35 = 0;
              v36 = &v16[2 * (int)v204];
              v37 = ((__int64)(int)v204 << 33) - 0x300000000LL;
              v38 = &v8[(int)v204 * v27];
              v39 = &v8[(int)v19 * (__int64)(int)v204];
              a5 = v16;
              do
              {
                if ( (int)v204 >= 3 )
                {
                  v40 = 0;
                  v41 = 0xFFFFFFFFFFFFFFELL;
                  v42 = (float *)&v199[4 * v203 + 4 * (int)v204];
                  v43 = (float *)&v199[4 * v203];
                  v44 = v37;
                  v45 = 2;
                  do
                  {
                    v46 = *(v43 - 1);
                    v47 = *(v42 - 1);
                    v48 = v39[v40 + 1];
                    v49 = v39[v40 + 2];
                    v50 = v38[v40 + 1];
                    v51 = v38[v40 + 2];
                    v52 = &a5[v40];
                    v53 = vmulq_n_f32(v48, *v43);
                    v54 = vmulq_n_f32(v48, v46);
                    v55 = vmulq_n_f32(v49, *v43);
                    v56 = vmulq_n_f32(v49, v46);
                    v57 = vmulq_n_f32(v50, *v42);
                    v58 = vmulq_n_f32(v50, v47);
                    v59 = vmulq_n_f32(v51, *v42);
                    v60 = vmulq_n_f32(v51, v47);
                    v61 = v8[v40 + 1];
                    v62 = vaddq_f32(v54, v55);
                    v63 = vaddq_f32(v58, v59);
                    v64 = vaddq_f32(v62, v63);
                    v52[1] = vaddq_f32(v61, v64);
                    v65 = v8[v40 + 2];
                    v66 = vsubq_f32(v56, v53);
                    v67 = vsubq_f32(v60, v57);
                    v68 = vaddq_f32(v66, v67);
                    v69 = vmulq_f32(vsubq_f32(v66, v67), v9);
                    v70 = vaddq_f32(v61, vmulq_f32(v64, v13));
                    v71 = &v36[v40];
                    v52[2] = vaddq_f32(v65, v68);
                    v72 = vmulq_f32(vsubq_f32(v63, v62), v9);
                    v73 = vaddq_f32(v69, v70);
                    v74 = vsubq_f32(v70, v69);
                    v75 = vaddq_f32(v65, vmulq_f32(v68, v13));
                    v45 += 2;
                    v71[1] = v73;
                    *(float32x4_t *)((char *)v16 + (v44 >> 28)) = v74;
                    v44 -= 0x200000000LL;
                    v43 += 2;
                    v40 += 2;
                    v71[2] = vaddq_f32(v72, v75);
                    v36[v41] = vsubq_f32(v72, v75);
                    v41 -= 2;
                    v42 += 2;
                  }
                  while ( v45 < (int)v204 );
                }
                ++v35;
                v36 = (float32x4_t *)((char *)v36 + v10);
                v37 += (unsigned __int64)(unsigned int)(3 * (_DWORD)v204) << 32;
                v38 = (float32x4_t *)((char *)v38 + v28);
                v39 = (float32x4_t *)((char *)v39 + v28);
                a5 = (float32x4_t *)((char *)a5 + v10);
                v8 = (float32x4_t *)((char *)v8 + v28);
              }
              while ( v35 != (unsigned int)v19 );
            }
          }
          break;
        case 4:
          sub_48380(
            v204,
            v19,
            v8,
            v16,
            (__int64)a5,
            (__int64)v192 + 4 * v203 + 4 * (int)v204,
            (__int64)v192 + 4 * v203 + 4 * (int)v204 + 4 * (int)v204);
LABEL_7:
          v18 = v187;
          v17 = v188;
          v15 = v189;
          v14 = v190;
          v9 = v191;
          v13.n128_u64[0] = 0xBF000000BF000000LL;
          v13.n128_u64[1] = 0xBF000000BF000000LL;
          break;
        case 5:
          v10 = (unsigned int)(v19 + 1);
          v76 = (6 * (_DWORD)v204) | 1;
          v77 = -v76;
          v78 = ~((int)v10 * (int)v204);
          v79 = 4 * v19;
          if ( (int)v19 >= 1 )
          {
            v80 = (unsigned int)v10 - 1LL;
            v81 = (__int64)&v8[((int)v19 + 1LL) * (int)v204 + 1];
            a5 = &v8[(v79 | 1LL) * (int)v204 + 1];
            v82 = (__int64)&v8[(v26 | 1LL) * (int)v204 + 1];
            v83 = (__int64)&v8[(3 * (int)v19 + 1LL) * (int)v204 + 1];
            v84 = (__int64)&v8[(5 * (int)v19 + 1LL) * (int)v204 + 1];
            v85 = 16LL * (int)v204;
            v86 = (__int64)&v16[v77 + 1];
            do
            {
              v87 = *(float32x4_t *)(v84 + 16 * v78);
              v88 = *(float32x4_t *)(v82 + 16 * v78);
              v89 = a5[v78];
              v90 = *(float32x4_t *)(v83 + 16 * v78);
              v91 = *(float32x4_t *)(v81 + 16 * v78);
              v92 = vaddq_f32(v87, v88);
              v93 = vsubq_f32(v87, v88);
              v94 = vaddq_f32(v89, v90);
              v95 = vsubq_f32(v89, v90);
              v96 = (float32x4_t *)(v86 + ((__int64)(int)v204 << 7) - 16);
              *(float32x4_t *)(v86 + 96LL * (int)v204) = vaddq_f32(v91, vaddq_f32(v92, v94));
              *v96 = vaddq_f32(v91, vaddq_f32(vmulq_f32(v92, v14), vmulq_f32(v94, v15)));
              v96[1] = vaddq_f32(vmulq_f32(v93, v17), vmulq_f32(v95, v18));
              v97 = (float32x4_t *)(v86 + 160LL * (int)v204 - 16);
              --v80;
              v81 += v85;
              v83 += v85;
              a5 = (float32x4_t *)((char *)a5 + v85);
              v82 += v85;
              v84 += v85;
              v86 += 80LL * (int)v204;
              *v97 = vaddq_f32(v91, vaddq_f32(vmulq_f32(v92, v15), vmulq_f32(v94, v14)));
              v97[1] = vsubq_f32(vmulq_f32(v93, v18), vmulq_f32(v95, v17));
            }
            while ( v80 );
          }
          if ( (_DWORD)v204 != 1 && (int)v19 >= 1 )
          {
            v98 = v79;
            v202 = (unsigned int)v10;
            v201 = 5 * (_DWORD)v204;
            v10 = 6;
            v99 = v76 - 1;
            v100 = 8LL * (int)v204 - v99;
            v101 = 6LL * (int)v204 - v99;
            v102 = (__int64)&v16[10LL * (int)v204 - v99 + 1];
            v103 = (__int64)&v16[v100 + 1];
            v104 = (__int64)&v16[v101 + 1];
            LODWORD(v101) = v203 + (_DWORD)v204 + (_DWORD)v204;
            v105 = 10 * (_DWORD)v204 - 2;
            v106 = &v8[v78 + ((int)v19 + 1LL) * (int)v204];
            v107 = 8 * (_DWORD)v204 - 2;
            v108 = v8 + 3;
            v109 = &v16[v77];
            v110 = 4LL * v11 - 4LL * (int)v204 * v23;
            v111 = 16LL * (int)v204;
            v112 = 80LL * (int)v204;
            a5 = &v108[v78 + (v98 | 1) * (int)v204];
            v113 = 4LL * (int)v101;
            v114 = &v108[v78 + (v26 | 1LL) * (int)v204];
            v115 = v106 + 2;
            v116 = &v108[v78 + (5 * (int)v19 + 1LL) * (int)v204];
            v117 = &v108[v78 + (3 * (int)v19 + 1LL) * (int)v204];
            v118 = 4LL * ((int)v101 + (int)v204);
            v119 = 1;
            do
            {
              v120 = v19;
              if ( (int)v204 >= 3 )
              {
                v121 = v199;
                v122 = 0;
                v123 = v107;
                v124 = v105;
                v125 = 3;
                do
                {
                  v126 = *(float *)&v121[v110 - 4];
                  v127 = *(float *)&v121[v110];
                  v128 = *(float *)&v121[4 * v203 - 4 + 4 * (int)v204];
                  v129 = *(float *)&v121[4 * v203 + 4 * (int)v204];
                  v130 = *(float *)&v121[v113 - 4];
                  v131 = *(float *)&v121[v113];
                  v132 = *(float *)&v121[v118 - 4];
                  v133 = *(float *)&v121[v118];
                  v135 = v114[v122 - 1];
                  v134 = v114[v122];
                  v137 = v117[v122 - 1];
                  v136 = v117[v122];
                  v139 = a5[v122 - 1];
                  v138 = a5[v122];
                  v141 = v116[v122 - 1];
                  v140 = v116[v122];
                  v142 = vmulq_n_f32(v134, v126);
                  v143 = vmulq_n_f32(v135, v126);
                  v144 = vmulq_n_f32(v134, v127);
                  v145 = vmulq_n_f32(v135, v127);
                  v146 = vmulq_n_f32(v136, v128);
                  v147 = vmulq_n_f32(v137, v128);
                  v148 = vmulq_n_f32(v136, v129);
                  v149 = vmulq_n_f32(v137, v129);
                  v150 = vmulq_n_f32(v138, v130);
                  v151 = vmulq_n_f32(v139, v130);
                  v152 = vmulq_n_f32(v138, v131);
                  v153 = vmulq_n_f32(v139, v131);
                  v154 = vmulq_n_f32(v140, v132);
                  v155 = vaddq_f32(v144, v143);
                  v156 = v115[v122];
                  v157 = vsubq_f32(v145, v142);
                  v158 = vaddq_f32(v148, v147);
                  v159 = vaddq_f32(v152, v151);
                  v160 = vaddq_f32(vmulq_n_f32(v140, v133), vmulq_n_f32(v141, v132));
                  v161 = vsubq_f32(vmulq_n_f32(v141, v133), v154);
                  v162 = vsubq_f32(v149, v146);
                  v163 = vsubq_f32(v153, v150);
                  v164 = vaddq_f32(v155, v160);
                  v165 = vsubq_f32(v160, v155);
                  v166 = vsubq_f32(v157, v161);
                  v167 = vaddq_f32(v157, v161);
                  v168 = vaddq_f32(v158, v159);
                  v169 = vsubq_f32(v159, v158);
                  v170 = vsubq_f32(v162, v163);
                  v171 = vaddq_f32(v162, v163);
                  v172 = (float32x4_t *)(v104 + v122 * 16);
                  *v172 = vaddq_f32(v156, vaddq_f32(v168, v164));
                  v173 = vaddq_f32(v156, vaddq_f32(vmulq_f32(v168, v15), vmulq_f32(v164, v14)));
                  v174 = v115[v122 + 1];
                  v175 = vaddq_f32(vmulq_f32(v170, v18), vmulq_f32(v166, v17));
                  v176 = vaddq_f32(vmulq_f32(v169, v18), vmulq_f32(v165, v17));
                  v177 = vsubq_f32(v173, v175);
                  v178 = vaddq_f32(v175, v173);
                  v172[1] = vsubq_f32(v174, vaddq_f32(v171, v167));
                  v179 = (float32x4_t *)(v103 + v122 * 16);
                  v180 = vsubq_f32(v174, vaddq_f32(vmulq_f32(v171, v15), vmulq_f32(v167, v14)));
                  *v179 = v177;
                  v109[v123] = v178;
                  v179[1] = vaddq_f32(v176, v180);
                  v109[v123 + 1] = vsubq_f32(v176, v180);
                  v181 = vaddq_f32(vmulq_f32(v171, v14), vmulq_f32(v167, v15));
                  v182 = vsubq_f32(vmulq_f32(v166, v18), vmulq_f32(v170, v17));
                  v183 = vaddq_f32(v156, vaddq_f32(vmulq_f32(v168, v14), vmulq_f32(v164, v15)));
                  v10 = v102 + v122 * 16;
                  v125 += 2;
                  v184 = vsubq_f32(vmulq_f32(v165, v18), vmulq_f32(v169, v17));
                  v185 = vsubq_f32(v174, v181);
                  LODWORD(v172) = v124 + 1;
                  v122 += 2;
                  v123 -= 2;
                  *(float32x4_t *)v10 = vsubq_f32(v183, v182);
                  v109[v124] = vaddq_f32(v182, v183);
                  v124 -= 2;
                  v121 += 8;
                  *(float32x4_t *)(v10 + 16) = vaddq_f32(v184, v185);
                  v109[(int)v172] = vsubq_f32(v184, v185);
                }
                while ( v125 <= (int)v204 );
              }
              ++v119;
              v102 += v112;
              v103 += v112;
              v105 += v201;
              v107 += v201;
              v104 += v112;
              v115 = (float32x4_t *)((char *)v115 + v111);
              v116 = (float32x4_t *)((char *)v116 + v111);
              a5 = (float32x4_t *)((char *)a5 + v111);
              v117 = (float32x4_t *)((char *)v117 + v111);
              v114 = (float32x4_t *)((char *)v114 + v111);
              v19 = v120;
            }
            while ( v119 != v202 );
          }
          break;
        default:
          v10 = v25;
          a5 = v24;
          break;
      }
      a1 = v195;
      v20 = v16 == a4;
      v12 = v200 + 1;
      if ( v16 == a4 )
        v16 = v196;
      else
        v16 = a4;
      if ( v20 )
        v8 = a4;
      else
        v8 = v196;
      v11 = v203;
    }
    while ( v12 != v193 );
  }
  return v8;
}
// 46CB8: variable 'a5' is possibly undefined
// 46CB8: variable 'v10' is possibly undefined

//----- (00000000000473E4) ----------------------------------------------------
int32x4_t __fastcall sub_473E4(int a1, __int64 a2, float32x4_t *a3, float32x4_t *a4)
{
  int32x4_t result; // q0
  int32x4_t v5; // q2
  int32x4_t v6; // q3
  int32x4_t v7; // q4
  int32x4_t v8; // q5
  int32x4_t v9; // q6
  int32x4_t v10; // q7
  float32x4_t v11; // q18
  float32x4_t v12; // q19
  float32x4_t v13; // q20
  float32x4_t v14; // q21
  float32x4_t v15; // q22
  int32x4_t v16; // q23
  int32x4_t v17; // q5
  int32x4_t v18; // q24
  int32x4_t v19; // q3
  int32x4_t v20; // q7
  int32x4_t v21; // q6
  int32x4_t v22; // q16
  int32x4_t v23; // q2
  float v24; // s25
  float v25; // s26
  float32x4_t v26; // q27
  float32x4_t v27; // q23
  float32x4_t v28; // q24
  float32x4_t v29; // q3
  float32x4_t v30; // q5
  float32x4_t v31; // q7
  float32x4_t v32; // q16
  float32x4_t v33; // q2
  float v34; // s1
  float v35; // s25
  float32x4_t v36; // q26
  float32x4_t v37; // q17
  float32x4_t v38; // q24
  float32x4_t v39; // q20
  float32x4_t v40; // q16
  float32x4_t v41; // q19
  float32x4_t v42; // q3
  float32x4_t v43; // q22
  float32x4_t v44; // q2
  float32x4_t v45; // q6
  __int128 v46; // q18
  float32x4_t v47; // q16
  float32x4_t v48; // q3
  float32x4_t v49; // q7
  float32x4_t v50; // q20
  float32x4_t v51; // q2
  float32x4_t v52; // q22
  float32x4_t v53; // q20
  float32x4_t v54; // q24
  float32x4_t v55; // q3
  float32x4_t v56; // q6
  float32x4_t v57; // q5
  float32x4_t v58; // q16
  float32x4_t v59; // q2
  int32x4_t *v60; // x9
  float32x4_t *v61; // x10
  float32x4_t *v62; // x11
  unsigned __int64 v63; // x12
  int32x4_t v64; // q1
  int32x4_t v65; // q2
  int32x4_t v66; // q3
  int32x4_t v67; // q4
  int32x4_t v68; // q5
  int32x4_t v69; // q6
  int32x4_t v70; // q7
  float32x4_t v71; // q16
  float32x4_t v72; // q17
  float32x4_t v73; // q18
  float32x4_t v74; // q19
  float32x4_t v75; // q21
  int32x4_t v76; // q22
  int32x4_t v77; // q0
  int32x4_t v78; // q4
  int32x4_t v79; // q2
  int32x4_t v80; // q6
  int32x4_t v81; // q1
  int32x4_t v82; // q5
  int32x4_t v83; // q3
  float32x4_t v84; // q7
  float32x4_t v85; // q4
  float32x4_t v86; // q22
  float32x4_t v87; // q0
  float32x4_t v88; // q2
  float32x4_t v89; // q5
  float32x4_t v90; // q6
  float32x4_t v91; // q1
  float32x4_t v92; // q3
  float32x4_t v93; // q4
  float32x4_t v94; // q17
  float32x4_t v95; // q5
  float32x4_t v96; // q16
  float32x4_t v97; // q22
  float32x4_t v98; // q19
  float32x4_t v99; // q6
  float32x4_t v100; // q18
  float32x4_t v101; // q4
  long double v102; // t1
  float32x4_t v103; // q3
  float32x4_t v104; // q5
  float32x4_t v105; // q6
  float32x4_t v106; // q0
  float32x4_t v107; // q1
  float32x4_t v108; // q16
  float32x4_t v109; // q5
  float32x4_t v110; // q7
  float32x4_t v111; // q0
  float32x4_t v112; // q4
  float32x4_t v113; // q2
  float32x4_t v114; // q6
  float32x4_t v115; // q1

  v5 = *(int32x4_t *)(a2 + 96);
  result = *(int32x4_t *)(a2 + 112);
  v6 = *(int32x4_t *)(a2 + 16);
  v7 = *(int32x4_t *)(a2 + 32);
  v8 = *(int32x4_t *)(a2 + 48);
  v9 = *(int32x4_t *)(a2 + 64);
  v10 = *(int32x4_t *)(a2 + 80);
  v11 = a4[1];
  v12 = a4[2];
  v13 = a4[3];
  v14 = a4[4];
  v15 = a4[5];
  v16 = vzip1q_s32((int32x4_t)0, v8);
  v17 = vzip2q_s32((int32x4_t)0, v8);
  v18 = vzip1q_s32(v6, v10);
  v19 = vzip2q_s32(v6, v10);
  v20 = vzip1q_s32((int32x4_t)0, v9);
  v21 = vzip2q_s32((int32x4_t)0, v9);
  v22 = vzip1q_s32(v7, v5);
  v23 = vzip2q_s32(v7, v5);
  v7.n128_f32[0] = COERCE_FLOAT(*(_QWORD *)(a2 + 8));
  LODWORD(v24) = HIDWORD(*(_QWORD *)a2);
  LODWORD(v25) = HIDWORD(*(_OWORD *)a2);
  v26 = vzip1q_s32(v16, v18);
  v27 = vzip2q_s32(v16, v18);
  v28 = vzip1q_s32(v17, v19);
  v29 = vzip2q_s32(v17, v19);
  v30 = vzip1q_s32(v20, v22);
  v31 = vzip2q_s32(v20, v22);
  v32 = vzip1q_s32(v21, v23);
  v33 = vzip2q_s32(v21, v23);
  v21.n128_f32[0] = COERCE_FLOAT(*(_OWORD *)a2) + v7.n128_f32[0];
  v34 = COERCE_FLOAT(*(_OWORD *)a2) - v7.n128_f32[0];
  v7.n128_f32[0] = v24 + v25;
  v35 = v25 - v24;
  v36 = vmulq_f32(v27, v11);
  v37 = vmulq_f32(v28, v13);
  v38 = vmulq_f32(v28, v12);
  v39 = vmulq_f32(v32, v13);
  v40 = vmulq_f32(v32, v12);
  v41 = vmulq_f32(v29, v15);
  v42 = vmulq_f32(v29, v14);
  v43 = vmulq_f32(v33, v15);
  v44 = vmulq_f32(v33, v14);
  v14.n128_f32[0] = v21.n128_f32[0] + v7.n128_f32[0];
  v7.n128_f32[0] = v21.n128_f32[0] - v7.n128_f32[0];
  v45 = vsubq_f32(vmulq_f32(v27, *a4), vmulq_f32(v11, v31));
  v46 = *(_OWORD *)(a2 + 16LL * (2 * a1 - 1));
  v47 = vaddq_f32(v37, v40);
  v37.n128_u32[0] = HIDWORD(*(_QWORD *)(a2 + 16LL * (2 * a1 - 1)));
  v48 = vsubq_f32(v42, v43);
  v49 = vaddq_f32(v36, vmulq_f32(v31, *a4));
  v50 = vsubq_f32(v38, v39);
  v51 = vaddq_f32(v41, v44);
  v52 = vaddq_f32(v26, v50);
  v53 = vsubq_f32(v26, v50);
  v54 = vaddq_f32(v45, v48);
  v55 = vsubq_f32(v48, v45);
  v56 = vaddq_f32(v30, v47);
  v57 = vsubq_f32(v30, v47);
  v58 = vaddq_f32(v49, v51);
  v59 = vsubq_f32(v51, v49);
  v49.n128_f32[0] = COERCE_FLOAT(*(_QWORD *)(a2 + 16LL * (2 * a1 - 1) + 8));
  v41.n128_f32[0] = (float)(v37.n128_f32[0] - *((float *)&v46 + 3)) * 0.70711;
  v37.n128_f32[0] = (float)(v37.n128_f32[0] + *((float *)&v46 + 3)) * 0.70711;
  *a3 = vaddq_f32(v52, v54);
  a3[1] = vaddq_f32(v56, v58);
  a3[2] = vaddq_f32(v53, v59);
  a3[3] = vsubq_f32(v55, v57);
  a3[4] = vsubq_f32(v53, v59);
  a3[5] = vaddq_f32(v57, v55);
  a3[6] = vsubq_f32(v52, v54);
  a3[7] = vsubq_f32(v58, v56);
  a3->n128_u32[0] = v14.n128_u32[0];
  a3[1].n128_u32[0] = v7.n128_u32[0];
  a3[4].n128_f32[0] = v34;
  a3[5].n128_f32[0] = v35;
  a3[2].n128_f32[0] = *(float *)&v46 + v41.n128_f32[0];
  a3[3].n128_f32[0] = (float)-v49.n128_f32[0] - v37.n128_f32[0];
  a3[6].n128_f32[0] = *(float *)&v46 - v41.n128_f32[0];
  a3[7].n128_f32[0] = v49.n128_f32[0] - v37.n128_f32[0];
  if ( a1 >= 8 )
  {
    v60 = (int32x4_t *)(a2 + 240);
    v61 = a3 + 15;
    v62 = a4 + 11;
    v63 = 1;
    do
    {
      v64 = v60[-7];
      v65 = v60[-6];
      v66 = v60[-5];
      v67 = v60[-4];
      v68 = v60[-3];
      v69 = v60[-2];
      v70 = v60[-1];
      v71 = v62[-5];
      v72 = v62[-4];
      v73 = v62[-3];
      v74 = v62[-2];
      v75 = v62[-1];
      v76 = vzip1q_s32(result, v67);
      v77 = vzip2q_s32(result, v67);
      v78 = vzip1q_s32(v65, v69);
      v79 = vzip2q_s32(v65, v69);
      v80 = vzip1q_s32(v64, v68);
      v81 = vzip2q_s32(v64, v68);
      v82 = vzip1q_s32(v66, v70);
      v83 = vzip2q_s32(v66, v70);
      v84 = vzip1q_s32(v76, v78);
      v85 = vzip2q_s32(v76, v78);
      v86 = vzip1q_s32(v77, v79);
      v87 = vzip2q_s32(v77, v79);
      v88 = vzip1q_s32(v80, v82);
      v89 = vzip2q_s32(v80, v82);
      v90 = vzip1q_s32(v81, v83);
      v91 = vzip2q_s32(v81, v83);
      v92 = vmulq_f32(v85, v72);
      v93 = vmulq_f32(v85, v71);
      v94 = vmulq_f32(v72, v89);
      v95 = vmulq_f32(v89, v71);
      v96 = vmulq_f32(v86, v74);
      v97 = vmulq_f32(v86, v73);
      v98 = vmulq_f32(v90, v74);
      v99 = vmulq_f32(v90, v73);
      v100 = vmulq_f32(v87, *v62);
      v101 = vsubq_f32(v93, v94);
      v102 = *(long double *)v60;
      v60 += 8;
      v103 = vaddq_f32(v92, v95);
      v104 = vsubq_f32(v97, v98);
      v105 = vaddq_f32(v96, v99);
      v106 = vsubq_f32(vmulq_f32(v87, v75), vmulq_f32(v91, *v62));
      v107 = vaddq_f32(v100, vmulq_f32(v91, v75));
      v108 = vaddq_f32(v84, v104);
      v109 = vsubq_f32(v84, v104);
      v110 = vaddq_f32(v101, v106);
      v111 = vsubq_f32(v106, v101);
      v112 = vaddq_f32(v88, v105);
      v113 = vsubq_f32(v88, v105);
      v114 = vaddq_f32(v103, v107);
      v115 = vsubq_f32(v107, v103);
      ++v63;
      v61[-7] = vaddq_f32(v108, v110);
      v61[-6] = vaddq_f32(v112, v114);
      v61[-5] = vaddq_f32(v109, v115);
      v61[-4] = vsubq_f32(v111, v113);
      v61[-3] = vsubq_f32(v109, v115);
      v61[-2] = vaddq_f32(v113, v111);
      v61[-1] = vsubq_f32(v108, v110);
      *v61 = vsubq_f32(v114, v112);
      v61 += 8;
      v62 += 6;
      *(long double *)&result = v102;
    }
    while ( v63 < (unsigned int)a1 >> 2 );
  }
  return result;
}

//----- (0000000000047698) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall sub_47698(int a1, float32x4_t *a2, float *a3, float32x4_t *a4)
{
  float *v4; // x10
  float *v5; // x11
  float v6; // w8
  float v7; // w9
  float32x4_t v8; // q1
  float32x4_t v9; // q2
  float32x4_t v10; // q3
  float32x4_t v11; // q4
  float32x4_t v12; // q5
  float32x4_t v13; // q6
  float32x4_t v14; // q7
  float32x4_t v15; // q17 OVERLAPPED
  float32x4_t v16; // q18
  float32x4_t v17; // q19
  float32x4_t v18; // q20
  float32x4_t v19; // q21
  float32x4_t v20; // q22
  float32x4_t v21; // q0
  float32x4_t v22; // q6
  float32x4_t v23; // q2
  float32x4_t v24; // q4
  float32x4_t v25; // q1
  float32x4_t v26; // q7
  float32x4_t v27; // q3
  int8x16_t v28; // q5 OVERLAPPED
  float32x4_t v29; // q6
  float32x4_t v30; // q22
  float32x4_t v31; // q0
  float32x4_t v32; // q7
  float32x4_t v33; // q23
  float32x4_t v34; // q2
  int8x16_t v35; // q4 OVERLAPPED
  int32x4_t v36; // q24
  int32x4_t v37; // q25
  int8x16_t v38; // q1
  int32x4_t v39; // q6
  int8x16_t v40; // q26
  int8x16_t v41; // q3
  int32x4_t v42; // q0
  int8x16_t v43; // q27
  int8x16_t v44; // q2
  int8x16_t v45; // q7
  unsigned __int64 v46; // d16
  float *v47; // x10
  int8x16_t v48; // q16 OVERLAPPED
  int8x16_t v49; // q1 OVERLAPPED
  float *v50; // x10
  int8x16_t v51; // q17
  int8x16_t v52; // q2
  float *v53; // x11
  float *v54; // x10
  float32x4_t *v55; // x9
  float *v56; // x10
  float32x4_t *v57; // x11
  unsigned __int64 v58; // x12
  float32x4_t v59; // q0
  float32x4_t v60; // q1
  float32x4_t v61; // q2
  float32x4_t v62; // q3
  float32x4_t v63; // q4
  float32x4_t v64; // q5
  float32x4_t v65; // q6
  float32x4_t v66; // q16
  float32x4_t v67; // q17
  float32x4_t v68; // q18
  float32x4_t v69; // q19
  float32x4_t v70; // q21
  float32x4_t v71; // q22
  float32x4_t v72; // q0
  float32x4_t v73; // q6
  float32x4_t v74; // q2
  float32x4_t v75; // q4
  float32x4_t v76; // q1
  float32x4_t v77; // q7
  float32x4_t v78; // q3
  int32x4_t v79; // q5
  float32x4_t v80; // q6
  float32x4_t v81; // q22 OVERLAPPED
  float32x4_t v82; // q7 OVERLAPPED
  int32x4_t v83; // q0
  float32x4_t v84; // q1
  float32x4_t v85; // q3
  float32x4_t v86; // q2
  float32x4_t v87; // q4
  float32x4_t v88; // q17
  int32x4_t v89; // q3 OVERLAPPED
  int32x4_t v90; // q4
  int32x4_t v91; // q17
  int32x4_t v92; // q1
  int32x4_t v93; // q6
  int32x4_t v94; // q2
  int8x16_t v95; // q18 OVERLAPPED
  float *v96; // x13
  int8x16_t v97; // q20 OVERLAPPED
  int8x16_t v98; // q19
  float *v99; // x14
  int8x16_t v100; // q21
  unsigned __int64 v101; // d23
  float *v102; // x13
  int8x16_t v103; // q4 OVERLAPPED
  int8x16_t v104; // q0 OVERLAPPED
  float *v105; // x13
  float *v106; // x14
  int8x16_t v107; // q5
  int8x16_t v108; // q1
  float *v109; // x13
  float *v110; // x14
  float v111; // s1
  float v112; // s0
  float *v113; // x8
  float v114; // s1
  float v115; // s3
  float result; // s0
  float v117; // [xsp+0h] [xbp-20h]
  float v118; // [xsp+4h] [xbp-1Ch]
  float v119; // [xsp+8h] [xbp-18h]
  float v120; // [xsp+Ch] [xbp-14h]
  float v121; // [xsp+10h] [xbp-10h]
  float v122; // [xsp+14h] [xbp-Ch]
  float v123; // [xsp+18h] [xbp-8h]
  float32x2x2_t v124; // 0:d28.8,8:d29.8

  v4 = a3 + 4;
  v5 = a3 + 12;
  v121 = a2->n128_f32[0];
  v117 = a2[1].n128_f32[0];
  v122 = a2[2].n128_f32[0];
  v118 = a2[3].n128_f32[0];
  v123 = a2[4].n128_f32[0];
  v119 = a2[5].n128_f32[0];
  v6 = a2[6].n128_f32[0];
  v7 = a2[7].n128_f32[0];
  v120 = v7;
  v8 = a2[1];
  v9 = a2[2];
  v10 = a2[3];
  v11 = a2[4];
  v12 = a2[5];
  v13 = a2[6];
  v14 = a2[7];
  v15 = a4[1];
  v16 = a4[2];
  v17 = a4[3];
  v18 = a4[4];
  v19 = a4[5];
  v20 = vaddq_f32(*a2, v13);
  v21 = vsubq_f32(*a2, v13);
  v22 = vaddq_f32(v9, v11);
  v23 = vsubq_f32(v9, v11);
  v24 = vaddq_f32(v8, v14);
  v25 = vsubq_f32(v8, v14);
  v26 = vaddq_f32(v10, v12);
  v27 = vsubq_f32(v10, v12);
  v28 = vaddq_f32(v22, v20);
  v29 = vsubq_f32(v20, v22);
  v30 = vsubq_f32(v21, v26);
  v31 = vaddq_f32(v26, v21);
  v32 = vaddq_f32(v27, v25);
  v33 = vsubq_f32(v24, v23);
  v34 = vaddq_f32(v23, v24);
  v35 = vaddq_f32(vmulq_f32(v30, *a4), vmulq_f32(v15, v33));
  v36 = vaddq_f32(vmulq_f32(v32, v17), vmulq_f32(v29, v16));
  v37 = vaddq_f32(vmulq_f32(v34, v19), vmulq_f32(v31, v18));
  v38 = vsubq_f32(v25, v27);
  v39 = vsubq_f32(vmulq_f32(v32, v16), vmulq_f32(v29, v17));
  v40 = vextq_s8(v28, vtrn2q_s32(v28, v36), 8u);
  v41 = vsubq_f32(vmulq_f32(v33, *a4), vmulq_f32(v30, v15));
  v42 = vsubq_f32(vmulq_f32(v34, v18), vmulq_f32(v31, v19));
  v43 = vextq_s8(v35, vtrn2q_s32(v35, v37), 8u);
  v124.val[0].n64_u64[0] = vextq_s8(v40, v40, 8u).n128_u64[0];
  v44 = vextq_s8(v38, vtrn2q_s32(v38, v39), 8u);
  v124.val[1].n64_u64[0] = vextq_s8(v43, v43, 8u).n128_u64[0];
  v45 = vextq_s8(v41, vtrn2q_s32(v41, v42), 8u);
  v46 = vextq_s8(v44, v44, 8u).n128_u64[0];
  vst2_f32(v4, v124);
  v47 = a3 + 8;
  v15.n128_u64[0] = vextq_s8(v45, v45, 8u).n128_u64[0];
  vst2_f32(v47, *(float32x2x2_t *)((char *)&v15 - 8));
  v48 = vzip2q_s32(v28, v36);
  v49 = vzip2q_s32(v38, v39);
  v50 = a3 + 16;
  v51 = vzip2q_s32(v35, v37);
  v52 = vzip2q_s32(v41, v42);
  v41.n128_u64[0] = vextq_s8(v48, v48, 8u).n128_u64[0];
  v28.n128_u64[0] = vextq_s8(v49, v49, 8u).n128_u64[0];
  vst2_f32(v5, (float32x2x2_t)v48);
  v53 = a3 + 20;
  vst2_f32(v50, (float32x2x2_t)v49);
  v54 = a3 + 24;
  v35.n128_u64[0] = vextq_s8(v51, v51, 8u).n128_u64[0];
  v39.n128_u64[0] = vextq_s8(v52, v52, 8u).n128_u64[0];
  vst2_f32(v53, *(float32x2x2_t *)((char *)&v35 - 8));
  vst2_f32(v54, (float32x2x2_t)v28);
  if ( a1 < 8 )
  {
    v111 = v6;
    v112 = v7;
  }
  else
  {
    v55 = a2 + 15;
    v56 = a3 + 56;
    v57 = a4 + 11;
    v58 = 1;
    do
    {
      v59 = v55[-7];
      v60 = v55[-6];
      v61 = v55[-5];
      v62 = v55[-4];
      v63 = v55[-3];
      v64 = v55[-2];
      v65 = v55[-1];
      v66 = v57[-5];
      v67 = v57[-4];
      v68 = v57[-3];
      v69 = v57[-2];
      v70 = v57[-1];
      v71 = vaddq_f32(v59, v65);
      v72 = vsubq_f32(v59, v65);
      v73 = vaddq_f32(v61, v63);
      v74 = vsubq_f32(v61, v63);
      v75 = vaddq_f32(v60, *v55);
      v76 = vsubq_f32(v60, *v55);
      v77 = vaddq_f32(v62, v64);
      v78 = vsubq_f32(v62, v64);
      v79 = vaddq_f32(v73, v71);
      v80 = vsubq_f32(v71, v73);
      v81 = vsubq_f32(v72, v77);
      v82 = vaddq_f32(v77, v72);
      v83 = vsubq_f32(v76, v78);
      v84 = vaddq_f32(v78, v76);
      v85 = vsubq_f32(v75, v74);
      v86 = vaddq_f32(v74, v75);
      v87 = vmulq_f32(v81, v67);
      v88 = vmulq_f32(v67, v85);
      v89 = vsubq_f32(vmulq_f32(v85, v66), v87);
      v90 = vaddq_f32(vmulq_f32(v84, v69), vmulq_f32(v80, v68));
      v91 = vaddq_f32(vmulq_f32(v81, v66), v88);
      v92 = vsubq_f32(vmulq_f32(v84, v68), vmulq_f32(v80, v69));
      v93 = vaddq_f32(vmulq_f32(v86, *v57), vmulq_f32(v82, v70));
      v94 = vsubq_f32(vmulq_f32(v86, v70), vmulq_f32(v82, *v57));
      v95 = vzip1q_s32(v79, v90);
      v96 = v56 - 28;
      v97 = vzip1q_s32(v83, v92);
      v98 = vzip1q_s32(v91, v93);
      v81.n128_u64[0] = vextq_s8(v95, v95, 8u).n128_u64[0];
      v99 = v56 - 24;
      v100 = vzip1q_s32(v89, v94);
      vst2_f32(v96, (float32x2x2_t)v95);
      v101 = vextq_s8(v98, v98, 8u).n128_u64[0];
      v95.n128_u64[0] = vextq_s8(v97, v97, 8u).n128_u64[0];
      v102 = v56 - 20;
      v103 = vzip2q_s32(v79, v90);
      v104 = vzip2q_s32(v83, v92);
      vst2_f32(v99, (float32x2x2_t)v97);
      v98.n128_u64[0] = vextq_s8(v100, v100, 8u).n128_u64[0];
      vst2_f32(v102, (float32x2x2_t)v81);
      v105 = v56 - 16;
      v106 = v56 - 12;
      v107 = vzip2q_s32(v91, v93);
      v108 = vzip2q_s32(v89, v94);
      v94.n128_u64[0] = vextq_s8(v103, v103, 8u).n128_u64[0];
      v93.n128_u64[0] = vextq_s8(v104, v104, 8u).n128_u64[0];
      vst2_f32(v105, (float32x2x2_t)v95);
      v109 = v56 - 8;
      vst2_f32(v106, (float32x2x2_t)v103);
      v110 = v56 - 4;
      ++v58;
      v89.n128_u64[0] = vextq_s8(v107, v107, 8u).n128_u64[0];
      v82.n128_u64[0] = vextq_s8(v108, v108, 8u).n128_u64[0];
      v55 += 8;
      vst2_f32(v109, (float32x2x2_t)v104);
      vst2_f32(v110, *(float32x2x2_t *)((char *)&v89 - 8));
      vst2_f32(v56, *(float32x2x2_t *)((char *)&v82 - 8));
      v56 += 32;
      v57 += 6;
    }
    while ( v58 < (unsigned int)a1 >> 2 );
    v111 = v6;
    v112 = v120;
  }
  v113 = &a3[8 * a1];
  *a3 = (float)(v121 + v117) + (float)(v123 + v123);
  a3[1] = (float)(v121 - v117) - (float)(v119 + v119);
  a3[2] = (float)(v121 + v117) - (float)(v123 + v123);
  a3[3] = (float)(v121 - v117) + (float)(v119 + v119);
  *(v113 - 4) = (float)(v122 + v111) + (float)(v122 + v111);
  v114 = v122 - v111;
  v115 = (float)(v118 + v112) * 1.4142;
  result = (float)(v112 - v118) + (float)(v112 - v118);
  *(v113 - 3) = (float)(v114 * 1.4142) - v115;
  *(v113 - 2) = result;
  *(v113 - 1) = (float)(v114 * -1.4142) - v115;
  return result;
}
// 476F9: failed to expand linear variable q17.16
// 477C9: failed to expand linear variable q16.16
// 477CD: failed to expand linear variable q1.16
// 47759: failed to expand linear variable q4.16
// 47725: failed to expand linear variable q5.16
// 478C1: failed to expand linear variable q18.16
// 478C9: failed to expand linear variable q20.16
// 47861: failed to expand linear variable q22.16
// 478ED: failed to expand linear variable q4.16
// 478F1: failed to expand linear variable q0.16
// 478A9: failed to expand linear variable q3.16
// 47865: failed to expand linear variable q7.16

//----- (0000000000047A0C) ----------------------------------------------------
float32x4_t *__fastcall sub_47A0C(int a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x8
  float32x4_t *v8; // x2
  int32x4_t v9; // q0
  float32x4_t v10; // q26
  float32x4_t v11; // q27
  float32x4_t v12; // q28
  __int64 v13; // x11
  float32x4_t v14; // q25
  float32x4_t v15; // q29
  float32x4_t *v16; // x8
  float32x4_t v17; // q30
  int v18; // w1
  bool v19; // zf
  float32x4_t *v20; // x9
  int v21; // w8
  int v22; // w25
  __int64 v23; // kr08_8
  int v24; // w10
  float32x4_t *v25; // x5
  __int64 v26; // x0
  __int64 v27; // x9
  __int64 v28; // x10
  __int64 v29; // x3
  __int64 v30; // x14
  __int64 v31; // x11
  float32x4_t *v32; // x1
  float32x4_t v33; // q1
  float32x4_t v34; // q0
  float32x4_t v35; // q2
  float32x4_t v36; // q0
  float32x4_t v37; // q1
  __int64 v38; // x12
  float32x4_t *v39; // x17
  float32x4_t *v40; // x13
  __int64 v41; // x14
  __int64 v42; // x1
  __int64 v43; // x3
  __int64 v44; // x5
  __int64 v45; // x6
  float *v46; // x7
  float *v47; // x19
  __int64 v48; // x20
  __int64 v49; // x21
  float32x4_t v50; // q0
  float32x4_t v51; // q1
  float32x4_t v52; // q2
  float32x4_t *v53; // x23
  float32x4_t v54; // q3
  float32x4_t v55; // q4
  float32x4_t v56; // q0
  float32x4_t v57; // q1
  float32x4_t v58; // q3
  float32x4_t v59; // q5
  float32x4_t v60; // q1
  float32x4_t v61; // q0
  float32x4_t v62; // q2
  float32x4_t v63; // q3
  float32x4_t v64; // q4
  float v65; // s6
  float32x4_t v66; // q3
  float32x4_t v67; // q2
  float32x4_t v68; // q1
  float32x4_t v69; // q3
  float32x4_t v70; // q7
  float32x4_t *v71; // x22
  float32x4_t v72; // q0
  float32x4_t *v73; // x24
  float32x4_t v74; // q4
  float32x4_t v75; // q2
  unsigned int v76; // w11
  int v77; // w14
  int v78; // w8
  __int64 v79; // x13
  int v80; // w12
  __int64 v81; // x15
  __int64 v82; // x9
  __int64 v83; // x17
  __int64 v84; // x0
  __int64 v85; // x3
  __int64 v86; // x5
  __int64 v87; // x6
  __int64 v88; // x21
  float32x4_t v89; // q2
  float32x4_t v90; // q3
  float32x4_t v91; // q0
  float32x4_t v92; // q1
  float32x4_t v93; // q4
  float32x4_t v94; // q5
  float32x4_t v95; // q2
  float32x4_t v96; // q3
  float32x4_t v97; // q6
  float32x4_t v98; // q0
  float32x4_t v99; // q1
  float32x4_t v100; // q2
  __int64 v101; // x14
  int v102; // w28
  __int64 v103; // x6
  float32x4_t *v104; // x20
  int v105; // w19
  __int64 v106; // x3
  __int64 v107; // x5
  __int64 v108; // x24
  float32x4_t *v109; // x23
  float32x4_t *v110; // x8
  int v111; // w11
  __int64 v112; // x12
  __int64 v113; // x17
  __int64 v114; // x0
  __int64 v115; // x1
  __int64 v116; // x2
  float32x4_t *v117; // x5
  __int64 v118; // x6
  __int64 v119; // x7
  float32x4_t *v120; // x30
  __int64 v121; // x20
  __int64 v122; // x23
  unsigned __int64 v123; // x21
  int v124; // w15
  int v125; // w14
  __int64 v126; // x24
  float32x4_t v127; // q1
  float32x4_t v128; // q16
  float32x4_t v129; // q3
  float32x4_t v130; // q6
  float32x4_t v131; // q7
  float32x4_t v132; // q17
  float32x4_t v133; // q2
  float32x4_t v134; // q18
  float32x4_t v135; // q19
  float32x4_t v136; // q5
  float32x4_t v137; // q0
  float32x4_t *v138; // x10
  float32x4_t v139; // q4
  float32x4_t v140; // q20
  float32x4_t v141; // q21
  const float *v142; // x26
  float32x4_t v143; // q22
  float32x4_t v144; // q0
  float32x4_t v145; // q1
  float32x4_t v146; // q3
  float32x4_t v147; // q6
  const float *v148; // x10
  float v149; // s23
  float32x4_t v150; // q5
  float32x4_t v151; // q18
  float32x4_t v152; // q24
  float32x4_t v153; // q17
  float32x4_t v154; // q19
  float32x4_t v155; // q1
  float32x4_t v156; // q3
  float32x4_t v157; // q7
  float32x4_t v158; // q6
  float32x4_t v159; // q4
  float32x4_t v160; // q20
  const float *v161; // x26
  float32x4_t v162; // q21
  float32x4_t v163; // q22
  float32x4_t v164; // q20
  float32x4_t v165; // q21
  float32x4_t v166; // q0
  float32x4_t v167; // q2
  const float *v168; // x10
  float32x4_t v169; // q5
  float32x4_t v170; // q18
  float32x4_t v171; // q6
  float32x4_t v172; // q23
  float32x4_t v173; // q24
  float32x4_t v174; // q6
  float32x4_t v175; // q5
  float32x4_t v176; // q16
  float32x4_t v177; // q22
  float32x4_t v178; // q16
  float32x4_t *v179; // x26
  float32x4_t *v180; // x10
  float32x4_t v181; // q0
  float32x4_t v182; // q1
  float32x4_t *v183; // x26
  float32x4_t v184; // q2
  float32x4_t v185; // q3
  float32x4_t *v186; // x10
  __int64 v188; // [xsp+8h] [xbp-118h]
  float32x4_t v189; // [xsp+10h] [xbp-110h]
  float32x4_t v190; // [xsp+20h] [xbp-100h]
  float32x4_t v191; // [xsp+30h] [xbp-F0h]
  float32x4_t v192; // [xsp+40h] [xbp-E0h]
  float32x4_t v193; // [xsp+50h] [xbp-D0h]
  float32x4_t v194; // [xsp+60h] [xbp-C0h]
  __int64 v195; // [xsp+70h] [xbp-B0h]
  float32x4_t *v196; // [xsp+78h] [xbp-A8h]
  __int64 v200; // [xsp+98h] [xbp-88h]
  int v201; // [xsp+A0h] [xbp-80h]
  int v202; // [xsp+A4h] [xbp-7Ch]
  __int64 v203; // [xsp+A8h] [xbp-78h]
  __int64 v204; // [xsp+B0h] [xbp-70h]
  float32x4_t *v205; // [xsp+B8h] [xbp-68h]
  int v206; // [xsp+C0h] [xbp-60h]

  v6 = *(unsigned int *)(a6 + 4);
  v8 = a2;
  if ( (int)v6 >= 1 )
  {
    v195 = v6 + 1;
    v188 = a5 + 4;
    v9 = vdupq_n_s32(0x3FDDB3D7u);
    v10 = vdupq_n_s32(0x3F5DB3D7u);
    v11 = vdupq_n_s32(0x3E9E377Au);
    v12 = vdupq_n_s32(0xBF4F1BBD);
    v13 = 1;
    v14.n128_u64[0] = 0xBF000000BF000000LL;
    v14.n128_u64[1] = 0xBF000000BF000000LL;
    v15 = vdupq_n_s32(0x3F737871u);
    if ( a2 == a4 )
      v16 = a3;
    else
      v16 = a4;
    v17 = vdupq_n_s32(0x3F167918u);
    v18 = 1;
    v206 = 0;
    v200 = a5;
    v189 = v9;
    v205 = v16;
    v193 = v11;
    v194 = v10;
    v191 = v15;
    v192 = v12;
    v190 = v17;
    v196 = a3;
    do
    {
      v203 = v13 + 1;
      v21 = *(_DWORD *)(a6 + 4 * (v13 + 1));
      v201 = v21;
      v22 = a1 / (v21 * v18);
      v202 = v21 * v18;
      v23 = a5;
      v24 = 2 * v18;
      a5 = v200 + 4LL * v206;
      switch ( v21 )
      {
        case 2:
          sub_48D14((unsigned int)v22, v18, (__int64)v8, v205, a5);
          goto LABEL_7;
        case 3:
          if ( v18 < 1 )
            goto LABEL_8;
          v25 = v205;
          v26 = v24;
          v27 = (unsigned int)v18;
          v28 = 16LL * v22;
          v29 = v18;
          v30 = v18 * (__int64)v22;
          v31 = 48LL * v22;
          v32 = v8;
          a5 = v27;
          do
          {
            v33 = *v32;
            --a5;
            v34 = vaddq_f32(v32[v22 + (__int64)(v22 - 1)], v32[v22 + (__int64)(v22 - 1)]);
            *v25 = vaddq_f32(*v32, v34);
            v35 = v32[2 * v22];
            v36 = vaddq_f32(v33, vmulq_f32(v34, v14));
            v32 = (float32x4_t *)((char *)v32 + v31);
            v37 = vmulq_f32(v35, v189);
            v25[v30] = vsubq_f32(v36, v37);
            *(float32x4_t *)((char *)v25 + v28 * v26) = vaddq_f32(v36, v37);
            v25 = (float32x4_t *)((char *)v25 + v28);
          }
          while ( a5 );
          if ( v22 == 1 )
            goto LABEL_8;
          v38 = 0;
          v39 = v205 + 1;
          v40 = &v8[2 * v22];
          v41 = ((__int64)v22 << 33) - 0x300000000LL;
          v42 = (__int64)&v205[v22 * v26 + 1];
          v43 = (__int64)&v205[v29 * v22 + 1];
          a5 = (__int64)v8;
          if ( v22 < 3 )
            goto LABEL_21;
LABEL_23:
          v44 = 0;
          v45 = 0xFFFFFFFFFFFFFFELL;
          v46 = (float *)(v188 + 4LL * v206);
          v47 = (float *)(v188 + 4LL * (v22 + v206));
          v48 = v41;
          v49 = 2;
          do
          {
            v50 = v40[v44 + 1];
            v51 = *(float32x4_t *)((char *)v8 + (v48 >> 28));
            v52 = *(float32x4_t *)(a5 + v44 * 16 + 16);
            v53 = &v39[v44];
            v49 += 2;
            v54 = vaddq_f32(v50, v51);
            *v53 = vaddq_f32(v52, v54);
            v55 = v40[v44 + 2];
            v56 = vsubq_f32(v50, v51);
            v57 = vmulq_f32(v54, v14);
            v58 = v40[v45];
            v59 = *(float32x4_t *)(a5 + v44 * 16 + 32);
            v60 = vaddq_f32(v52, v57);
            v61 = vmulq_f32(v56, v10);
            v62 = vsubq_f32(v55, v58);
            v63 = vaddq_f32(v55, v58);
            v53[1] = vaddq_f32(v59, v62);
            v64 = vaddq_f32(v59, vmulq_f32(v62, v14));
            v65 = *(v46 - 1);
            v66 = vmulq_f32(v63, v10);
            v67 = vsubq_f32(v60, v66);
            v68 = vaddq_f32(v60, v66);
            v69 = vaddq_f32(v61, v64);
            v70 = vmulq_n_f32(v67, *v46);
            v71 = (float32x4_t *)(v43 + v44 * 16);
            *v71 = vsubq_f32(vmulq_n_f32(v67, v65), vmulq_n_f32(v69, *v46));
            v71[1] = vaddq_f32(v70, vmulq_n_f32(v69, v65));
            v69.n128_f32[0] = *(v47 - 1);
            v72 = vsubq_f32(v64, v61);
            v73 = (float32x4_t *)(v42 + v44 * 16);
            v48 -= 0x200000000LL;
            v74 = vmulq_n_f32(v68, *v47);
            v75 = vmulq_n_f32(v72, *v47);
            v44 += 2;
            v45 -= 2;
            v47 += 2;
            v46 += 2;
            *v73 = vsubq_f32(vmulq_n_f32(v68, v69.n128_f32[0]), v75);
            v73[1] = vaddq_f32(v74, vmulq_n_f32(v72, v69.n128_f32[0]));
          }
          while ( v49 < v22 );
LABEL_21:
          while ( 1 )
          {
            ++v38;
            v40 = (float32x4_t *)((char *)v40 + v31);
            v41 += (unsigned __int64)(unsigned int)(3 * v22) << 32;
            a5 += v31;
            v42 += v28;
            v43 += v28;
            v39 = (float32x4_t *)((char *)v39 + v28);
            if ( v38 == v27 )
              goto LABEL_8;
            if ( v22 >= 3 )
              goto LABEL_23;
          }
        case 4:
          sub_4893C((unsigned int)v22, v18, v8, v205, a5, v200 + 4LL * (v22 + v206), v200 + 4LL * (v22 + v206 + v22));
LABEL_7:
          v17 = v190;
          v15 = v191;
          v12 = v192;
          v11 = v193;
          v10 = v194;
          v14.n128_u64[0] = 0xBF000000BF000000LL;
          v14.n128_u64[1] = 0xBF000000BF000000LL;
          goto LABEL_8;
        case 5:
          v76 = v18 + 1;
          v77 = (6 * v22) | 1;
          v78 = -v77;
          v79 = ~(v22 * (v18 + 1));
          v80 = 4 * v18;
          if ( v18 >= 1 )
          {
            v81 = v76 - 1LL;
            v82 = 16LL * v22;
            v83 = (__int64)&v8[v78 + 1];
            v84 = (__int64)&v205[(v80 | 1LL) * v22 + 1];
            v85 = (__int64)&v205[(v24 | 1LL) * v22 + 1];
            a5 = (__int64)&v205[(v18 + 1LL) * v22 + 1];
            v86 = (__int64)&v205[(5 * v18 + 1LL) * v22 + 1];
            v87 = (__int64)&v205[(3 * v18 + 1LL) * v22 + 1];
            do
            {
              v88 = 16 * v79;
              --v81;
              v89 = vaddq_f32(
                      *(float32x4_t *)(v83 + ((__int64)v22 << 7) - 16),
                      *(float32x4_t *)(v83 + ((__int64)v22 << 7) - 16));
              v90 = vaddq_f32(*(float32x4_t *)(v83 + 160LL * v22 - 16), *(float32x4_t *)(v83 + 160LL * v22 - 16));
              v91 = vaddq_f32(*(float32x4_t *)(v83 + ((__int64)v22 << 7)), *(float32x4_t *)(v83 + ((__int64)v22 << 7)));
              v92 = vaddq_f32(*(float32x4_t *)(v83 + 160LL * v22), *(float32x4_t *)(v83 + 160LL * v22));
              v93 = vaddq_f32(v89, v90);
              v94 = vaddq_f32(vmulq_f32(v89, v11), vmulq_f32(v90, v12));
              v95 = vaddq_f32(vmulq_f32(v89, v12), vmulq_f32(v90, v11));
              v96 = vaddq_f32(vmulq_f32(v91, v15), vmulq_f32(v92, v17));
              v97 = *(float32x4_t *)(v83 + 96LL * v22);
              v98 = vsubq_f32(vmulq_f32(v91, v17), vmulq_f32(v92, v15));
              v99 = vaddq_f32(v97, v94);
              v100 = vaddq_f32(v97, v95);
              *(float32x4_t *)(a5 + v88) = vaddq_f32(v97, v93);
              a5 += v82;
              *(float32x4_t *)(v85 + v88) = vsubq_f32(v99, v96);
              *(float32x4_t *)(v87 + v88) = vsubq_f32(v100, v98);
              *(float32x4_t *)(v84 + v88) = vaddq_f32(v98, v100);
              *(float32x4_t *)(v86 + v88) = vaddq_f32(v96, v99);
              v86 += v82;
              v84 += v82;
              v87 += v82;
              v85 += v82;
              v83 += 80LL * v22;
            }
            while ( v81 );
          }
          if ( v22 == 1 || v18 < 1 )
            goto LABEL_8;
          v204 = v76;
          v101 = v77 - 1;
          v102 = 8 * v22 - 1;
          v103 = v79 + (5 * v18 + 1LL) * v22;
          v104 = v8 + 2;
          v105 = 10 * v22 - 1;
          v106 = v79 + (v80 | 1LL) * v22;
          v107 = v79 + (v18 + 1LL) * v22;
          v108 = v79 + (3 * v18 + 1LL) * v22;
          v109 = &v8[6LL * v22 - v101];
          v110 = &v8[v78];
          v111 = 5 * v22;
          v112 = 16LL * v22;
          v113 = 80LL * v22;
          v114 = (__int64)&v205[v106 + 2];
          v115 = (__int64)&v205[v79 + 2 + (v24 | 1LL) * v22];
          v116 = (__int64)&v205[v107 + 2];
          a5 = (__int64)&v104[10LL * v22 - v101];
          v117 = &v104[8LL * v22 - v101];
          v118 = (__int64)&v205[v103 + 2];
          v119 = (__int64)&v205[v108 + 2];
          v120 = v109 + 1;
          v121 = 1;
          if ( v22 < 3 )
            goto LABEL_33;
          break;
        default:
          a5 = v23;
          goto LABEL_8;
      }
LABEL_35:
      v122 = v200;
      v123 = 0;
      v124 = v102;
      v125 = v105;
      v126 = 3;
      do
      {
        v127 = v117[v123 / 0x10 - 1];
        v128 = v117[v123 / 0x10];
        v129 = v110[v124 - 1];
        v130 = *(float32x4_t *)(a5 + v123 - 16);
        v131 = *(float32x4_t *)(a5 + v123);
        v132 = v110[v125 - 1];
        v133 = v120[v123 / 0x10];
        v134 = vaddq_f32(v127, v129);
        v135 = vaddq_f32(v130, v132);
        v136 = v110[v124];
        v137 = v110[v125];
        v138 = (float32x4_t *)(v116 + v123);
        *v138 = vaddq_f32(v133, vaddq_f32(v134, v135));
        v139 = v120[v123 / 0x10 + 1];
        v140 = vsubq_f32(v128, v136);
        v141 = vsubq_f32(v131, v137);
        v142 = (const float *)(v122 + 4LL * v206);
        v138[1] = vaddq_f32(vaddq_f32(v140, v141), v139);
        v143 = vld1q_dup_f32(v142++);
        v144 = vaddq_f32(v131, v137);
        v145 = vsubq_f32(v127, v129);
        v146 = vsubq_f32(v130, v132);
        v147 = vaddq_f32(vmulq_f32(v134, v11), vmulq_f32(v135, v12));
        v148 = (const float *)(v122 + 4LL * (v22 + v206));
        v149 = *v142;
        v150 = vaddq_f32(v128, v136);
        v151 = vaddq_f32(vmulq_f32(v134, v12), vmulq_f32(v135, v11));
        v152 = vld1q_dup_f32(v148++);
        v153 = vaddq_f32(vmulq_f32(v145, v15), vmulq_f32(v146, v17));
        v154 = vaddq_f32(vmulq_f32(v150, v15), vmulq_f32(v144, v17));
        v155 = vsubq_f32(vmulq_f32(v145, v17), vmulq_f32(v146, v15));
        v156 = vaddq_f32(v133, v147);
        v157 = vaddq_f32(vaddq_f32(vmulq_f32(v140, v11), vmulq_f32(v141, v12)), v139);
        v158 = vsubq_f32(v156, v154);
        v159 = vaddq_f32(vaddq_f32(vmulq_f32(v140, v12), vmulq_f32(v141, v11)), v139);
        v160 = vaddq_f32(v153, v157);
        v161 = (const float *)(v122 + 4LL * (v22 + v206 + v22));
        v162 = vmulq_f32(v158, v143);
        v163 = vmulq_f32(v160, v143);
        v128.n128_f32[0] = *v148;
        v164 = vsubq_f32(v162, vmulq_n_f32(v160, v149));
        v165 = vld1q_dup_f32(v161++);
        v166 = vsubq_f32(vmulq_f32(v150, v17), vmulq_f32(v144, v15));
        v167 = vaddq_f32(v133, v151);
        v168 = (const float *)(v122 + 4LL * (v22 + v206 + v22 + v22));
        v169 = vsubq_f32(v167, v166);
        v170 = vaddq_f32(v155, v159);
        v171 = vmulq_n_f32(v158, v149);
        v172 = vmulq_f32(v169, v152);
        v173 = vmulq_f32(v170, v152);
        v174 = vaddq_f32(v171, v163);
        v175 = vmulq_n_f32(v169, v128.n128_f32[0]);
        v176 = vmulq_n_f32(v170, v128.n128_f32[0]);
        v170.n128_f32[0] = *v161;
        v177 = vld1q_dup_f32(v168++);
        v178 = vsubq_f32(v172, v176);
        v179 = (float32x4_t *)(v115 + v123);
        v172.n128_f32[0] = *v168;
        v180 = (float32x4_t *)(v119 + v123);
        v181 = vaddq_f32(v166, v167);
        v182 = vsubq_f32(v159, v155);
        *v179 = v164;
        v179[1] = v174;
        *v180 = v178;
        v180[1] = vaddq_f32(v175, v173);
        v183 = (float32x4_t *)(v114 + v123);
        v184 = vaddq_f32(v154, v156);
        v185 = vsubq_f32(v157, v153);
        v126 += 2;
        *v183 = vsubq_f32(vmulq_f32(v181, v165), vmulq_n_f32(v182, v170.n128_f32[0]));
        v183[1] = vaddq_f32(vmulq_n_f32(v181, v170.n128_f32[0]), vmulq_f32(v182, v165));
        v186 = (float32x4_t *)(v118 + v123);
        v125 -= 2;
        v123 += 32LL;
        v124 -= 2;
        v122 += 8;
        *v186 = vsubq_f32(vmulq_f32(v184, v177), vmulq_n_f32(v185, v172.n128_f32[0]));
        v186[1] = vaddq_f32(vmulq_n_f32(v184, v172.n128_f32[0]), vmulq_f32(v185, v177));
      }
      while ( v126 <= v22 );
LABEL_33:
      while ( 1 )
      {
        ++v121;
        v105 += v111;
        v118 += v112;
        v114 += v112;
        v102 += v111;
        v119 += v112;
        v115 += v112;
        v116 += v112;
        v120 = (float32x4_t *)((char *)v120 + v113);
        a5 += v113;
        v117 = (float32x4_t *)((char *)v117 + v113);
        if ( v121 == v204 )
          break;
        if ( v22 >= 3 )
          goto LABEL_35;
      }
LABEL_8:
      v13 = v203;
      v18 = v202;
      v19 = v205 == a4;
      if ( v205 == a4 )
        v20 = v196;
      else
        v20 = a4;
      v205 = v20;
      if ( v19 )
        v8 = a4;
      else
        v8 = v196;
      v206 += (v201 - 1) * v22;
    }
    while ( v203 != v195 );
  }
  return v8;
}
// 47B64: variable 'a5' is possibly undefined

//----- (000000000004828C) ----------------------------------------------------
float __fastcall pffft_zconvolve_accumulate(__int64 a1, float *a2, float *a3, float *a4, double a5)
{
  __int64 v5; // x8
  float v6; // s5
  float v7; // s1
  float v8; // s6
  float v9; // s3
  float v10; // s2
  float v11; // s4
  __int64 v12; // x9
  float32x4_t v13; // q7
  float32x4_t *v14; // x10
  float32x4_t *v15; // x11
  float32x4_t *v16; // x12
  float32x4_t v17; // q16
  float32x4_t v18; // q18
  float32x4_t v19; // q17
  float32x4_t v20; // q19
  float32x4_t v21; // q20
  float32x4_t v22; // q16
  float32x4_t v23; // q17
  float32x4_t v24; // q16
  float32x4_t v25; // q18
  float32x4_t v26; // q17
  float32x4_t v27; // q19
  float32x4_t v28; // q20
  float32x4_t v29; // q16
  float32x4_t v30; // q17
  float v31; // s1
  float v32; // s3

  v5 = *(int *)(a1 + 4);
  v6 = *a2;
  v7 = a2[4];
  v8 = *a3;
  v9 = a3[4];
  v10 = *a4;
  v11 = a4[4];
  if ( (int)v5 >= 1 )
  {
    v12 = 0;
    v13 = vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    v14 = (float32x4_t *)(a3 + 8);
    v15 = (float32x4_t *)(a2 + 8);
    v16 = (float32x4_t *)(a4 + 8);
    do
    {
      v18 = v14[-2];
      v17 = v14[-1];
      v19 = v15[-2];
      v20 = v15[-1];
      v12 += 2;
      v21 = vmulq_f32(v19, v17);
      v22 = vaddq_f32(v16[-2], vmulq_f32(v13, vsubq_f32(vmulq_f32(v19, v18), vmulq_f32(v20, v17))));
      v23 = vaddq_f32(vmulq_f32(v13, vaddq_f32(vmulq_f32(v20, v18), v21)), v16[-1]);
      v16[-2] = v22;
      v16[-1] = v23;
      v25 = *v14;
      v24 = v14[1];
      v14 += 4;
      v26 = *v15;
      v27 = v15[1];
      v15 += 4;
      v28 = vmulq_f32(v26, v24);
      v29 = vaddq_f32(*v16, vmulq_f32(v13, vsubq_f32(vmulq_f32(v26, v25), vmulq_f32(v27, v24))));
      v30 = vaddq_f32(vmulq_f32(v13, vaddq_f32(vmulq_f32(v27, v25), v28)), v16[1]);
      *v16 = v29;
      v16[1] = v30;
      v16 += 4;
    }
    while ( v12 < v5 );
  }
  if ( !*(_DWORD *)(a1 + 68) )
  {
    v31 = v7 * v9;
    v32 = (float)(v6 * v8) * *(float *)&a5;
    *(float *)&a5 = v11 + (float)(v31 * *(float *)&a5);
    *a4 = v10 + v32;
    a4[4] = *(float *)&a5;
  }
  return *(float *)&a5;
}

//----- (0000000000048370) ----------------------------------------------------
int8x16_t __fastcall pffft_transform(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        long double a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10)
{
  return pffft_transform_internal(a1, a2, a3, a4, a5, 0, a6, a7, a8, a9, a10);
}

//----- (0000000000048378) ----------------------------------------------------
int8x16_t __fastcall pffft_transform_ordered(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        long double a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10)
{
  return pffft_transform_internal(a1, a2, a3, a4, a5, 1, a6, a7, a8, a9, a10);
}

//----- (0000000000048380) ----------------------------------------------------
float32x4_t *__fastcall sub_48380(
        float32x4_t *result,
        int a2,
        float32x4_t *a3,
        float32x4_t *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  __int64 v7; // x8
  int v8; // w19
  int v9; // w9
  int v10; // w10
  float32x4_t *v11; // x1
  float32x4_t *v12; // x7
  float32x4_t v13; // q0
  float32x4_t v14; // q1
  float32x4_t v15; // q2
  float32x4_t v16; // q3
  float32x4_t v17; // q4
  float32x4_t v18; // q5
  int v19; // w7
  __int64 v20; // x17
  int v21; // w19
  int v22; // w12
  __int64 v23; // x13
  int v24; // w20
  __int64 v25; // x21
  __int64 v26; // x23
  float32x4_t *v27; // x24
  __int64 v28; // x25
  __int64 v29; // x26
  float32x4_t *v30; // x27
  float *v31; // x4
  float *v32; // x30
  __int64 v33; // x14
  __int64 v34; // x28
  __int64 v35; // x29
  float *v36; // x1
  __int64 v37; // x9
  float32x4_t v38; // q0
  float32x4_t v39; // q1
  float v40; // s2
  float32x4_t v41; // q6
  float32x4_t v42; // q7
  float v43; // s16
  float v44; // s4
  float32x4_t v45; // q18
  float32x4_t v46; // q0
  float32x4_t v47; // q3
  float32x4_t v48; // q1
  float32x4_t v49; // q2
  float32x4_t v50; // q6
  float32x4_t v51; // q17
  float32x4_t v52; // q7
  float32x4_t v53; // q16
  float32x4_t v54; // q19
  float32x4_t v55; // q0
  float32x4_t v56; // q1
  float32x4_t v57; // q3
  float32x4_t v58; // q16
  float32x4_t v59; // q5
  float32x4_t v60; // q4
  float32x4_t v61; // q18
  float32x4_t v62; // q19
  float32x4_t v63; // q6
  float32x4_t v64; // q5
  float32x4_t v65; // q2
  float32x4_t v66; // q7
  float32x4_t v67; // q16
  float32x4_t v68; // q3
  float32x4_t *v69; // x5
  float32x4_t v70; // q0
  float32x4_t v71; // q4
  float32x4_t v72; // q1
  float32x4_t v73; // q2
  float32x4_t v74; // q5
  float32x4_t v75; // q3
  float32x4_t *v76; // x6
  int v77; // w7
  __int64 v78; // x11
  __int64 v79; // x13
  __int64 v80; // x16
  int v81; // w4
  __int64 v82; // x11
  __int64 v83; // x0
  __int64 v84; // x9
  __int64 v85; // x12
  float32x4_t v86; // q0
  float32x4_t *v87; // x15
  float32x4_t *v88; // x16
  float32x4_t *v89; // x17
  __int64 v90; // x11
  float32x4_t v91; // q1
  float32x4_t v92; // q2
  float32x4_t v93; // q3
  float32x4_t v94; // q4
  float32x4_t v95; // q5
  float32x4_t v96; // q1
  __int64 v97; // x11
  float *v98; // [xsp+38h] [xbp-88h]
  float *v99; // [xsp+40h] [xbp-80h]
  float *v100; // [xsp+48h] [xbp-78h]
  __int64 v101; // [xsp+58h] [xbp-68h]

  v7 = a2 * (__int64)(int)result;
  v8 = 2 * v7;
  v9 = 2 * (_DWORD)result;
  v10 = 4 * (_DWORD)result;
  if ( (int)v7 >= 1 )
  {
    v11 = a4;
    v12 = a3;
    do
    {
      v13 = *v12;
      v14 = v12[v7];
      v15 = v12[3 * (int)v7];
      v16 = v12[v8];
      v12 += (int)result;
      v17 = vaddq_f32(v14, v15);
      v18 = vaddq_f32(v13, v16);
      v11[v9 - 1] = vsubq_f32(v13, v16);
      v11[v9] = vsubq_f32(v15, v14);
      *v11 = vaddq_f32(v18, v17);
      v11[v10 - 1] = vsubq_f32(v18, v17);
      v11 += v10;
    }
    while ( v12 < &a3[v7] );
  }
  v19 = (_DWORD)result - 1;
  if ( (int)result > 1 )
  {
    if ( (_DWORD)result == 2 )
    {
      if ( (int)v7 < 1 )
        return result;
      goto LABEL_14;
    }
    if ( (int)v7 >= 1 )
    {
      v20 = 16LL * (int)result;
      v100 = (float *)(a5 + 4);
      v99 = (float *)(a6 + 4);
      v98 = (float *)(a7 + 4);
      v101 = v9;
      v21 = (v9 - 4) | 1;
      v22 = 0;
      v23 = 0;
      v24 = (v10 - 4) | 1;
      v25 = (__int64)&a3[v7 + 1];
      v26 = (__int64)&a3[3 * (int)v7 + 1];
      v27 = &a3[(int)((2 * v7) | 1)];
      v28 = (__int64)&a3[3 * (int)v7 + 2];
      v29 = (__int64)&a3[(int)v7 + 2];
      v30 = a3;
      do
      {
        v32 = v98;
        v31 = v99;
        v33 = v22;
        v34 = 0;
        v35 = 0;
        v36 = v100;
        v37 = 2;
        do
        {
          v38 = *(float32x4_t *)(v25 + v34 * 16);
          v39 = *(float32x4_t *)(v29 + v34 * 16);
          v40 = *(v36 - 1);
          v41 = *(float32x4_t *)(v26 + v34 * 16);
          v42 = *(float32x4_t *)(v28 + v34 * 16);
          v43 = *(v32 - 1);
          v44 = *(v31 - 1);
          v45 = vmulq_n_f32(v38, *v36);
          v46 = vmulq_n_f32(v38, v40);
          v47 = vmulq_n_f32(v39, *v36);
          v48 = vmulq_n_f32(v39, v40);
          v49 = vmulq_n_f32(v41, *v32);
          v50 = vmulq_n_f32(v41, v43);
          v51 = vmulq_n_f32(v42, *v32);
          v52 = vmulq_n_f32(v42, v43);
          v53 = v27[v34];
          v54 = v27[v34 + 1];
          v55 = vaddq_f32(v46, v47);
          v56 = vsubq_f32(v48, v45);
          v57 = vmulq_n_f32(v53, *v31);
          v58 = vmulq_n_f32(v53, v44);
          v59 = vmulq_n_f32(v54, *v31);
          v60 = vmulq_n_f32(v54, v44);
          v61 = v30[v34 + 1];
          v62 = v30[v34 + 2];
          v63 = vaddq_f32(v50, v51);
          v64 = vaddq_f32(v58, v59);
          v65 = vsubq_f32(v52, v49);
          v66 = vaddq_f32(v55, v63);
          v67 = vaddq_f32(v64, v61);
          v68 = vsubq_f32(v60, v57);
          v69 = &a4[v33 + v34];
          v37 += 2;
          v70 = vsubq_f32(v63, v55);
          v71 = vaddq_f32(v56, v65);
          v72 = vsubq_f32(v56, v65);
          v73 = vsubq_f32(v61, v64);
          v74 = vaddq_f32(v68, v62);
          v75 = vsubq_f32(v62, v68);
          v69[1] = vaddq_f32(v67, v66);
          a4[v24 + (int)v35] = vsubq_f32(v67, v66);
          v76 = &a4[v101 + 2 + v22 + v34];
          v77 = v21 + v35;
          v78 = v35;
          v35 -= 2;
          v34 += 2;
          v36 += 2;
          v31 += 2;
          v32 += 2;
          v76[-1] = vaddq_f32(v73, v72);
          a4[v77] = vsubq_f32(v73, v72);
          v69[2] = vaddq_f32(v71, v74);
          a4[(int)result - 2 + (__int64)(3 * (int)result) + v22 + v78] = vsubq_f32(v71, v74);
          *v76 = vaddq_f32(v70, v75);
          a4[2 * (int)result - 2 + v33 + v78] = vsubq_f32(v70, v75);
        }
        while ( v37 < (int)result );
        v23 += (int)result;
        v22 += v10;
        v21 += v10;
        v24 += v10;
        v30 = (float32x4_t *)((char *)v30 + v20);
        v28 += v20;
        v26 += v20;
        v27 = (float32x4_t *)((char *)v27 + v20);
        v25 += v20;
        v29 += v20;
      }
      while ( v23 < v7 );
      v8 = 2 * v7;
      v19 = (_DWORD)result - 1;
      if ( (_DWORD)result - ((unsigned int)result & 0xFFFFFFFE) != 1 )
      {
LABEL_14:
        v79 = (int)result;
        v80 = (int)result - 1LL;
        v81 = 3 * (_DWORD)result;
        v82 = v80 + v8 + (int)v7;
        v83 = v7 + v80;
        v84 = 0;
        v85 = 0;
        v86 = vdupq_n_s32(0xBF3504F3);
        v87 = &a3[v80];
        v88 = &a3[v80 + v8];
        v89 = &a3[v82];
        result = &a3[v83];
        do
        {
          v90 = v85;
          v91 = result[v85];
          v92 = v89[v85];
          v93 = v87[v85];
          v85 += v79;
          v94 = vmulq_f32(vsubq_f32(v92, v91), v86);
          a4[v19 + (int)v84] = vaddq_f32(v93, v94);
          v95 = v88[v90];
          v96 = vmulq_f32(vaddq_f32(v91, v92), v86);
          a4[v81 - 1 + (int)v84] = vsubq_f32(v93, v94);
          v97 = v84;
          v84 += v10;
          a4[v79 + v97] = vsubq_f32(v96, v95);
          a4[v81 + v97] = vaddq_f32(v96, v95);
        }
        while ( v85 < v7 );
      }
    }
  }
  return result;
}
// 4869C: conditional instruction was optimized away because w8.4>=1
// 48684: conditional instruction was optimized away because w0.4>=3

//----- (0000000000048770) ----------------------------------------------------
float32x4_t __fastcall sub_48770(int a1, int a2, float32x4_t *a3, __int64 a4, __int64 a5)
{
  int v5; // w9
  int v6; // w8
  __int64 v7; // x10
  __int64 v8; // x11
  float32x4_t v9; // q0
  float32x4_t v10; // q1
  int v11; // w17
  float32x4_t v12; // q2
  float32x4_t result; // q0
  int v14; // w10
  __int64 v15; // x11
  float32x4_t *v16; // x16
  float *v17; // x4
  int v18; // w6
  __int64 v19; // x7
  float32x4_t *v20; // x19
  float *v21; // x20
  float32x4_t *v22; // x21
  __int64 v23; // x22
  float v24; // s3
  float32x4_t v25; // q4
  float32x4_t v26; // q5
  float32x4_t v27; // q0
  float32x4_t v28; // q1
  float32x4_t v29; // q2
  float32x4_t v30; // q3
  float32x4_t v31; // q4
  float32x4_t v32; // q1
  float32x4_t v33; // q3
  __int64 v34; // x12
  float32x4_t *v35; // x14
  __int64 v36; // x11
  float32x4_t *v37; // x12
  __int64 v38; // x8
  float32x4_t v39; // q0
  float32x4_t v40; // q1

  v5 = a2 * a1;
  v6 = 2 * a1;
  if ( a2 * a1 >= 1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = a3[v8];
      v10 = a3[v5 + v8];
      v8 += a1;
      v11 = ((v6 - 2) | 1) + v7;
      v12 = vaddq_f32(v9, v10);
      result = vsubq_f32(v9, v10);
      *(float32x4_t *)(a4 + 16 * v7) = v12;
      v7 += v6;
      *(float32x4_t *)(a4 + 16LL * v11) = result;
    }
    while ( v8 < v5 );
  }
  if ( a1 > 1 )
  {
    if ( a1 == 2 )
    {
      if ( v5 < 1 )
        return result;
      goto LABEL_14;
    }
    if ( v5 >= 1 )
    {
      v14 = 0;
      v15 = 0;
      v16 = a3 + 2;
      v17 = (float *)(a5 + 4);
      v18 = 2 * a1;
      do
      {
        v19 = a4 - 48 + 16LL * v18;
        v20 = (float32x4_t *)(a4 + 32 + 16LL * v14);
        v15 += a1;
        v21 = v17;
        v22 = v16;
        v23 = 2;
        do
        {
          v24 = *(v21 - 1);
          v25 = v22[v5 - 1];
          v26 = v22[v5];
          v27 = v22[-1];
          v28 = *v22;
          v23 += 2;
          v22 += 2;
          v29 = vaddq_f32(vmulq_n_f32(v26, *v21), vmulq_n_f32(v25, v24));
          v30 = vsubq_f32(vmulq_n_f32(v26, v24), vmulq_n_f32(v25, *v21));
          v31 = vaddq_f32(v28, v30);
          v32 = vsubq_f32(v30, v28);
          v33 = vaddq_f32(v27, v29);
          result = vsubq_f32(v27, v29);
          *v20 = v31;
          *(float32x4_t *)(v19 + 16) = v32;
          v20[-1] = v33;
          *(float32x4_t *)v19 = result;
          v19 -= 32;
          v20 += 2;
          v21 += 2;
        }
        while ( v23 < a1 );
        v18 += v6;
        v14 += v6;
        v16 += a1;
      }
      while ( v15 < v5 );
      if ( a1 - (a1 & 0xFFFFFFFE) != 1 )
      {
LABEL_14:
        v34 = a1;
        v35 = &a3[v34];
        v36 = 0;
        v37 = (float32x4_t *)(a4 + v34 * 16);
        v38 = 16LL * v6;
        do
        {
          v39 = v35[v36 - 1];
          v40 = a3[a1 * (a2 + 1) - 1 + (int)v36];
          v36 += a1;
          v37[-1] = v39;
          result = vnegq_f32(v40);
          *v37 = result;
          v37 = (float32x4_t *)((char *)v37 + v38);
        }
        while ( v36 < v5 );
      }
    }
  }
  return result;
}
// 488BC: conditional instruction was optimized away because w0.4>=3
// 488D4: conditional instruction was optimized away because w9.4>=1

//----- (000000000004893C) ----------------------------------------------------
__int64 __fastcall sub_4893C(
        __int64 result,
        int a2,
        float32x4_t *a3,
        float32x4_t *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  __int64 v7; // x8
  float32x4_t *v8; // x17
  float32x4_t *v9; // x7
  float32x4_t v10; // q0
  float32x4_t v11; // q1
  float32x4_t v12; // q2
  float32x4_t v13; // q3
  float32x4_t v14; // q1
  float32x4_t v15; // q4
  float32x4_t v16; // q0
  float32x4_t v17; // q2
  int v18; // w7
  int v19; // w11
  __int64 v20; // x12
  float32x4_t *v21; // x9
  __int64 v22; // x25
  float32x4_t *v23; // x17
  unsigned __int32 *v24; // x27
  float *v25; // x28
  float *v26; // x29
  __int64 v27; // x26
  float32x4_t *v28; // x30
  float32x4_t *v29; // x14
  __int64 v30; // x22
  __int64 v31; // x21
  float32x4_t *v32; // x23
  __int64 v33; // x19
  __int64 v34; // x4
  __int64 v35; // x10
  float32x4_t v36; // q2
  float32x4_t v37; // q3
  float32x4_t v38; // q4
  float32x4_t v39; // q5
  float32x4_t v40; // q0
  float32x4_t v41; // q1
  float32x4_t v42; // q16
  float32x4_t v43; // q17
  float v44; // s6
  float v45; // s7
  float32x4_t v46; // q18
  float32x4_t v47; // q0
  float32x4_t v48; // q4
  float32x4_t v49; // q1
  float32x4_t v50; // q2
  float32x4_t v51; // q0
  float32x4_t v52; // q1
  float32x4_t v53; // q3
  float32x4_t v54; // q16
  float32x4_t v55; // q5
  float32x4_t v56; // q17
  float32x4_t v57; // q3
  float32x4_t v58; // q18
  float32x4_t v59; // q1
  float32x4_t v60; // q5
  float32x4_t v61; // q2
  float32x4_t *v62; // x6
  float32x4_t v63; // q6
  float32x4_t v64; // q2
  float v65; // s7
  float32x4_t v66; // q4
  float32x4_t *v67; // x5
  float32x4_t *v68; // x6
  float32x4_t v69; // q0
  __int64 v70; // x12
  __int64 v71; // x10
  __int64 v72; // x9
  int v73; // w13
  int v74; // w14
  int v75; // w15
  float32x4_t v76; // q1
  float32x4_t v77; // q3
  float32x4_t v78; // q4
  float32x4_t v79; // q2
  float32x4_t v80; // q5
  float32x4_t v81; // q1
  float32x4_t v82; // q3
  int v83; // w17
  float32x4_t v84; // q2
  unsigned __int32 *v85; // [xsp+18h] [xbp-98h]
  float *v86; // [xsp+20h] [xbp-90h]
  float *v87; // [xsp+28h] [xbp-88h]
  int v88; // [xsp+48h] [xbp-68h]

  v7 = a2 * (__int64)(int)result;
  v88 = 4 * result;
  if ( (int)v7 >= 1 )
  {
    v8 = a4;
    v9 = a3;
    do
    {
      v10 = *v9;
      v11 = v9[2 * (int)result - 1];
      v12 = v9[v88 - 1];
      v13 = v9[2 * (int)result];
      v9 += v88;
      v14 = vaddq_f32(v11, v11);
      v15 = vaddq_f32(v10, v12);
      v16 = vsubq_f32(v10, v12);
      v17 = vaddq_f32(v13, v13);
      *v8 = vaddq_f32(v15, v14);
      v8[2 * (int)v7] = vsubq_f32(v15, v14);
      v8[v7] = vsubq_f32(v16, v17);
      v8[3 * (int)v7] = vaddq_f32(v16, v17);
      v8 += (int)result;
    }
    while ( v8 < &a4[v7] );
  }
  v18 = result - 1;
  if ( (int)result > 1 )
  {
    if ( (_DWORD)result == 2 )
    {
      if ( (int)v7 < 1 )
        return result;
      goto LABEL_14;
    }
    if ( (int)v7 >= 1 )
    {
      v87 = (float *)(a5 + 4);
      v86 = (float *)(a6 + 4);
      v19 = 0;
      v20 = 0;
      v21 = a4 + 1;
      v85 = (unsigned __int32 *)(a7 + 4);
      v22 = v7;
      do
      {
        v23 = a3 + 2;
        v24 = v85;
        v25 = v86;
        v26 = v87;
        v27 = v19;
        v28 = &a3[2 * (int)result];
        v29 = v21;
        v30 = (__int64)&a3[v88 - 3];
        v31 = ((__int64)(int)result << 34) - 0x200000000LL;
        v32 = v28 - 3;
        v33 = ((__int64)(int)result << 33) - 0x200000000LL;
        v34 = (__int64)&a3[4 * (int)v20 - 1];
        v35 = 2;
        do
        {
          v36 = v28[v27 + 1];
          v37 = v28[v27 + 2];
          v38 = v23[v27 - 1];
          v39 = v23[v19];
          v40 = *(float32x4_t *)(v30 + 16LL * v19);
          v41 = v32[v19];
          v42 = *(float32x4_t *)(v34 + ((v33 >> 28) | 0x10));
          v43 = *(float32x4_t *)(v34 + ((v31 >> 28) | 0x10));
          v45 = *(v26 - 1);
          v44 = *v26;
          v46 = vsubq_f32(v38, v40);
          v47 = vaddq_f32(v38, v40);
          v48 = vsubq_f32(v36, v41);
          v49 = vaddq_f32(v36, v41);
          v50 = vaddq_f32(v47, v49);
          v51 = vsubq_f32(v47, v49);
          v52 = vsubq_f32(v37, v42);
          v53 = vaddq_f32(v37, v42);
          v54 = vaddq_f32(v39, v43);
          v55 = vsubq_f32(v39, v43);
          v56 = vsubq_f32(v46, v53);
          v57 = vaddq_f32(v46, v53);
          v58 = vaddq_f32(v52, v55);
          v59 = vsubq_f32(v55, v52);
          v60 = vaddq_f32(v48, v54);
          *v29 = v50;
          v29[1] = v58;
          v61 = vmulq_n_f32(v56, v44);
          v62 = &v29[v22];
          v63 = vsubq_f32(vmulq_n_f32(v56, v45), vmulq_n_f32(v60, v44));
          v64 = vaddq_f32(v61, vmulq_n_f32(v60, v45));
          v56.n128_f32[0] = *(v25 - 1);
          v65 = *v25;
          v60.n128_u32[0] = *v24;
          *v62 = v63;
          v62[1] = v64;
          v64.n128_u32[0] = *(v24 - 1);
          v66 = vsubq_f32(v54, v48);
          v35 += 2;
          v67 = &v29[v22 + v22];
          v33 -= 0x200000000LL;
          v32 -= 2;
          v31 -= 0x200000000LL;
          v30 -= 32;
          v23 += 2;
          v28 += 2;
          v26 += 2;
          v25 += 2;
          v68 = &v67[v22];
          v29 = (float32x4_t *)((char *)v29 + 48 * v7 - 48LL * (_DWORD)v7 + 32);
          v24 += 2;
          *v67 = vsubq_f32(vmulq_n_f32(v51, v56.n128_f32[0]), vmulq_n_f32(v59, v65));
          v67[1] = vaddq_f32(vmulq_n_f32(v51, v65), vmulq_n_f32(v59, v56.n128_f32[0]));
          *v68 = vsubq_f32(vmulq_n_f32(v57, v64.n128_f32[0]), vmulq_n_f32(v66, v60.n128_f32[0]));
          v68[1] = vaddq_f32(vmulq_n_f32(v57, v60.n128_f32[0]), vmulq_n_f32(v66, v64.n128_f32[0]));
        }
        while ( v35 < (int)result );
        v20 += (int)result;
        v19 += v88;
        v21 += (int)result;
      }
      while ( v20 < v7 );
      v18 = result - 1;
      if ( (_DWORD)result - (result & 0xFFFFFFFE) != 1 )
      {
LABEL_14:
        v69 = vdupq_n_s32(0xBFB504F3);
        v70 = 3LL * (_DWORD)result;
        v71 = 0;
        v72 = (int)result;
        v73 = result * (a2 + 1) - 1;
        v74 = result * (3 * a2 + 1) - 1;
        v75 = result * ((2 * a2) | 1) - 1;
        do
        {
          v76 = a3[v18];
          v77 = a3[v70 - 1];
          v78 = a3[v70];
          v79 = a3[v72];
          v80 = vaddq_f32(v76, v77);
          v81 = vsubq_f32(v76, v77);
          v82 = vaddq_f32(v79, v78);
          a4[v18 + (int)v71] = vaddq_f32(v80, v80);
          result = (unsigned int)(v75 + v71);
          a4[v73 + (int)v71] = vmulq_f32(vsubq_f32(v82, v81), v69);
          v83 = v74 + v71;
          v71 += v72;
          v84 = vsubq_f32(v78, v79);
          a3 += v88;
          a4[(int)result] = vaddq_f32(v84, v84);
          a4[v83] = vmulq_f32(vaddq_f32(v81, v82), v69);
        }
        while ( v71 < v7 );
      }
    }
  }
  return result;
}
// 48C34: conditional instruction was optimized away because w8.4>=1
// 48C1C: conditional instruction was optimized away because w0.4>=3

//----- (0000000000048D14) ----------------------------------------------------
__int64 __fastcall sub_48D14(__int64 result, int a2, __int64 a3, float32x4_t *a4, __int64 a5)
{
  int v5; // w9
  int v6; // w8
  __int64 v7; // x10
  __int64 v8; // x15
  float32x4_t v9; // q0
  float32x4_t v10; // q1
  __int64 v11; // x17
  int v12; // w10
  __int64 v13; // x11
  float32x4_t *v14; // x15
  float *v15; // x4
  int v16; // w5
  float32x4_t *v17; // x6
  float32x4_t *v18; // x7
  float *v19; // x19
  float32x4_t *v20; // x20
  __int64 v21; // x21
  float32x4_t v22; // q0
  float32x4_t v23; // q1
  float32x4_t v24; // q2
  float32x4_t v25; // q3
  float32x4_t *v26; // x22
  float32x4_t v27; // q4
  float32x4_t v28; // q0
  float32x4_t v29; // q1
  float32x4_t v30; // q3
  float32x4_t v31; // q0
  __int64 v32; // x12
  float32x4_t *v33; // x14
  __int64 v34; // x11
  __int64 v35; // x8
  float32x4_t *v36; // x12
  float32x4_t v37; // q0
  __int64 v38; // x15
  float32x4_t v39; // q1
  float32x4_t v40; // q2

  v5 = a2 * result;
  v6 = 2 * result;
  if ( a2 * (int)result >= 1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *(float32x4_t *)(a3 + 16 * v7);
      v10 = *(float32x4_t *)(a3 + 16LL * (((v6 - 2) | 1) + (int)v7));
      v11 = v8;
      v8 += (int)result;
      v7 += v6;
      a4[v11] = vaddq_f32(v9, v10);
      a4[v5 + v11] = vsubq_f32(v9, v10);
    }
    while ( v8 < v5 );
  }
  if ( (int)result > 1 )
  {
    if ( (_DWORD)result == 2 )
    {
      if ( v5 < 1 )
        return result;
      goto LABEL_14;
    }
    if ( v5 >= 1 )
    {
      v12 = 0;
      v13 = 0;
      v14 = a4 + 2;
      v15 = (float *)(a5 + 4);
      v16 = 2 * result;
      do
      {
        v17 = (float32x4_t *)(a3 - 48 + 16LL * v16);
        v18 = (float32x4_t *)(a3 + 32 + 16LL * v12);
        v13 += (int)result;
        v19 = v15;
        v20 = v14;
        v21 = 2;
        do
        {
          v22 = v18[-1];
          v23 = *v18;
          v24 = *v17;
          v25 = v17[1];
          v17 -= 2;
          v21 += 2;
          v26 = &v20[v5];
          v18 += 2;
          v27 = vaddq_f32(v22, v24);
          v28 = vsubq_f32(v22, v24);
          v20[-1] = v27;
          *v20 = vsubq_f32(v23, v25);
          v27.n128_f32[0] = *(v19 - 1);
          v29 = vaddq_f32(v23, v25);
          v20 += 2;
          v30 = vmulq_n_f32(v28, *v19);
          v31 = vsubq_f32(vmulq_n_f32(v28, v27.n128_f32[0]), vmulq_n_f32(v29, *v19));
          v19 += 2;
          v26[-1] = v31;
          *v26 = vaddq_f32(v30, vmulq_n_f32(v29, v27.n128_f32[0]));
        }
        while ( v21 < (int)result );
        v16 += v6;
        v14 += (int)result;
        v12 += v6;
      }
      while ( v13 < v5 );
      if ( (_DWORD)result - (result & 0xFFFFFFFE) != 1 )
      {
LABEL_14:
        v32 = (int)result;
        v33 = &a4[v32];
        v34 = 0;
        v35 = 16LL * v6;
        v36 = (float32x4_t *)(a3 + v32 * 16);
        v37.n128_u64[0] = 0xC0000000C0000000LL;
        v37.n128_u64[1] = 0xC0000000C0000000LL;
        do
        {
          v38 = v34;
          v34 += (int)result;
          v39 = vaddq_f32(v36[-1], v36[-1]);
          v40 = vmulq_f32(*v36, v37);
          v36 = (float32x4_t *)((char *)v36 + v35);
          v33[v38 - 1] = v39;
          a4[(int)result - 1 + (__int64)v5 + v38] = v40;
        }
        while ( v34 < v5 );
      }
    }
  }
  return result;
}
// 48E54: conditional instruction was optimized away because w0.4>=3
// 48E6C: conditional instruction was optimized away because w9.4>=1

//----- (0000000000048ED4) ----------------------------------------------------
_QWORD *__fastcall dataTracker_init(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (0000000000048EDC) ----------------------------------------------------
_QWORD *__fastcall dataTracker_initAll(_QWORD *result, unsigned int a2)
{
  __int64 v2; // x8

  if ( a2 )
  {
    v2 = a2;
    do
    {
      *result = 0;
      result[1] = 0;
      result += 2;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (0000000000048EF4) ----------------------------------------------------
__int64 __fastcall dataTracker_start(__int64 result, __int64 a2)
{
  *(_QWORD *)result = a2;
  *(_BYTE *)(result + 8) = 1;
  return result;
}

//----- (0000000000048F04) ----------------------------------------------------
__int64 __fastcall dataTracker_getLength(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000048F0C) ----------------------------------------------------
__int64 __fastcall dataTracker_consume(__int64 result, unsigned __int64 a2)
{
  if ( a2 && *(_BYTE *)(result + 8) )
  {
    if ( *(_QWORD *)result < a2 )
      longjmp(&_excBuf, 9);
    *(_QWORD *)result -= a2;
  }
  return result;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000048F48) ----------------------------------------------------
__int64 __fastcall dataTracker_consumeAll(__int64 result, unsigned int a2, unsigned __int64 a3)
{
  __int64 v3; // x8

  if ( a2 && a3 )
  {
    v3 = a2;
    do
    {
      if ( *(_BYTE *)(result + 8) )
      {
        if ( *(_QWORD *)result < a3 )
          longjmp(&_excBuf, 9);
        *(_QWORD *)result -= a3;
      }
      --v3;
      result += 16;
    }
    while ( v3 );
  }
  return result;
}
// 48F74: conditional instruction was optimized away because x2.8!=0
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000048FA4) ----------------------------------------------------
_QWORD *__fastcall dataTracker_stop(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (0000000000048FAC) ----------------------------------------------------
__int64 __fastcall convertErrorCode(unsigned int a1)
{
  if ( a1 > 0xF )
    return 0xFFFFFFFFLL;
  else
    return dword_2247C[a1];
}
// 2247C: using guessed type unsigned int dword_2247C[16];

//----- (0000000000048FCC) ----------------------------------------------------
__int64 __fastcall readUInt32(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x10
  unsigned __int64 v3; // x11
  unsigned __int64 v4; // x11
  bool v5; // cf
  unsigned __int64 v6; // x11

  v1 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(v1 + 4) > *(_QWORD *)(a1 + 16) )
    longjmp(&_excBuf, 3);
  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 40) )
  {
    v3 = *(_QWORD *)(a1 + 32);
    if ( v3 <= 3 )
      goto LABEL_10;
    *(_QWORD *)(a1 + 32) = v3 - 4;
  }
  if ( *(_BYTE *)(a1 + 56) )
  {
    v4 = *(_QWORD *)(a1 + 48);
    v5 = v4 >= 4;
    v6 = v4 - 4;
    if ( !v5 )
LABEL_10:
      longjmp(&_excBuf, 9);
    *(_QWORD *)(a1 + 48) = v6;
  }
  *(_QWORD *)(a1 + 24) = v1 + 4;
  return *(unsigned int *)(v2 + v1);
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000049050) ----------------------------------------------------
__int64 __fastcall readUInt16(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x10
  unsigned __int64 v3; // x11
  unsigned __int64 v4; // x11
  bool v5; // cf
  unsigned __int64 v6; // x11

  v1 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(v1 + 2) > *(_QWORD *)(a1 + 16) )
    longjmp(&_excBuf, 3);
  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 40) )
  {
    v3 = *(_QWORD *)(a1 + 32);
    if ( v3 <= 1 )
      goto LABEL_10;
    *(_QWORD *)(a1 + 32) = v3 - 2;
  }
  if ( *(_BYTE *)(a1 + 56) )
  {
    v4 = *(_QWORD *)(a1 + 48);
    v5 = v4 >= 2;
    v6 = v4 - 2;
    if ( !v5 )
LABEL_10:
      longjmp(&_excBuf, 9);
    *(_QWORD *)(a1 + 48) = v6;
  }
  *(_QWORD *)(a1 + 24) = v1 + 2;
  return *(unsigned __int16 *)(v2 + v1);
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (00000000000490D4) ----------------------------------------------------
__int64 __fastcall readUInt8(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x10
  __int64 v3; // x11
  __int64 v4; // x11

  v1 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(v1 + 1) > *(_QWORD *)(a1 + 16) )
    longjmp(&_excBuf, 3);
  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 40) )
  {
    v3 = *(_QWORD *)(a1 + 32);
    if ( !v3 )
      goto LABEL_9;
    *(_QWORD *)(a1 + 32) = v3 - 1;
  }
  if ( *(_BYTE *)(a1 + 56) )
  {
    v4 = *(_QWORD *)(a1 + 48);
    if ( v4 )
    {
      *(_QWORD *)(a1 + 48) = v4 - 1;
      goto LABEL_8;
    }
LABEL_9:
    longjmp(&_excBuf, 9);
  }
LABEL_8:
  *(_QWORD *)(a1 + 24) = v1 + 1;
  return *(unsigned __int8 *)(v2 + v1);
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000049150) ----------------------------------------------------
float __fastcall readFloat(__int64 a1)
{
  __int64 v1; // x8
  __int64 v2; // x10
  unsigned __int64 v3; // x11
  unsigned __int64 v4; // x11
  bool v5; // cf
  unsigned __int64 v6; // x11

  v1 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(v1 + 4) > *(_QWORD *)(a1 + 16) )
    longjmp(&_excBuf, 3);
  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 40) )
  {
    v3 = *(_QWORD *)(a1 + 32);
    if ( v3 <= 3 )
      goto LABEL_10;
    *(_QWORD *)(a1 + 32) = v3 - 4;
  }
  if ( *(_BYTE *)(a1 + 56) )
  {
    v4 = *(_QWORD *)(a1 + 48);
    v5 = v4 >= 4;
    v6 = v4 - 4;
    if ( !v5 )
LABEL_10:
      longjmp(&_excBuf, 9);
    *(_QWORD *)(a1 + 48) = v6;
  }
  *(_QWORD *)(a1 + 24) = v1 + 4;
  return *(float *)(v2 + v1);
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (00000000000491D4) ----------------------------------------------------
__int64 __fastcall readFlexibleAsUInt64(__int64 a1)
{
  __int64 v1; // x10
  char v2; // w11
  unsigned __int64 v3; // x9
  __int64 v4; // x8
  char v5; // w14
  int v6; // w14
  unsigned __int64 v7; // x11
  bool v8; // cf
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x11
  unsigned __int64 v11; // x11

  v1 = *(_QWORD *)(a1 + 24);
  v2 = 0;
  v3 = 0;
  v4 = 0;
  do
  {
    if ( v1 + v3 + 1 > *(_QWORD *)(a1 + 16) )
      longjmp(&_excBuf, 3);
    v5 = *(_BYTE *)(*(_QWORD *)(a1 + 8) + v1 + v3++);
    v4 += (unsigned __int64)(v5 & 0x7F) << v2;
    v6 = v5 & 0x80;
    if ( v3 > 4 )
      break;
    v2 += 7;
  }
  while ( v6 );
  if ( (_DWORD)v3 == 5 && v6 )
    longjmp(&_excBuf, 1);
  if ( *(_BYTE *)(a1 + 40) )
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = v7 >= v3;
    v9 = v7 - v3;
    if ( !v8 )
      goto LABEL_17;
    *(_QWORD *)(a1 + 32) = v9;
  }
  if ( *(_BYTE *)(a1 + 56) )
  {
    v10 = *(_QWORD *)(a1 + 48);
    v8 = v10 >= v3;
    v11 = v10 - v3;
    if ( !v8 )
LABEL_17:
      longjmp(&_excBuf, 9);
    *(_QWORD *)(a1 + 48) = v11;
  }
  *(_QWORD *)(a1 + 24) = v1 + v3;
  return v4;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (00000000000492AC) ----------------------------------------------------
unsigned __int64 __fastcall readFlexibleAsUInt32(__int64 a1)
{
  unsigned __int64 result; // x0

  result = _readFlexibleAsUInt64(a1);
  if ( HIDWORD(result) )
    longjmp(&_excBuf, 2);
  return result;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (00000000000492D8) ----------------------------------------------------
unsigned __int64 __fastcall readFlexibleAsUInt16(__int64 a1)
{
  unsigned __int64 result; // x0

  result = _readFlexibleAsUInt64(a1);
  if ( result >= 0x10000 )
    longjmp(&_excBuf, 2);
  return result;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000049304) ----------------------------------------------------
unsigned __int64 __fastcall readFlexibleAsUInt8(__int64 a1)
{
  unsigned __int64 result; // x0

  result = _readFlexibleAsUInt64(a1);
  if ( result >= 0x100 )
    longjmp(&_excBuf, 2);
  return result;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (0000000000049330) ----------------------------------------------------
__int64 __fastcall skip(__int64 result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x9
  bool v4; // cf
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x9

  if ( a2 )
  {
    v2 = *(_QWORD *)(result + 24) + a2;
    if ( v2 > *(_QWORD *)(result + 16) )
      longjmp(&_excBuf, 3);
    if ( *(_BYTE *)(result + 40) )
    {
      v3 = *(_QWORD *)(result + 32);
      v4 = v3 >= a2;
      v5 = v3 - a2;
      if ( !v4 )
        goto LABEL_13;
      *(_QWORD *)(result + 32) = v5;
    }
    if ( *(_BYTE *)(result + 56) )
    {
      v6 = *(_QWORD *)(result + 48);
      v4 = v6 >= a2;
      v7 = v6 - a2;
      if ( !v4 )
LABEL_13:
        longjmp(&_excBuf, 9);
      *(_QWORD *)(result + 48) = v7;
    }
    *(_QWORD *)(result + 24) = v2;
  }
  return result;
}
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (00000000000493A8) ----------------------------------------------------
__int64 __fastcall lm1_decode(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int v3; // w20
  _QWORD *v6; // x19
  int v7; // w0
  int v8; // w20
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  unsigned __int64 *v11; // x24
  unsigned __int64 v12; // x10
  _QWORD *v13; // x21
  unsigned __int64 FlexibleAsUInt64; // x0
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x0
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x8
  bool v19; // cf
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x0
  unsigned __int64 v22; // x0
  unsigned __int64 v23; // x0
  unsigned __int64 v24; // x0
  char v25; // w21
  unsigned __int64 v26; // x0
  _QWORD *v27; // x19
  __int64 v28; // x0
  unsigned __int64 v29; // x0
  _QWORD *v30; // x21
  size_t v31; // x0
  void *v32; // x0
  __int64 v33; // x8
  unsigned __int64 v34; // x24
  __int64 v35; // x25
  __int64 v36; // x0
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x11
  __int64 v39; // x8
  int v40; // w12
  __int64 v41; // x9
  int v42; // w14
  unsigned __int64 v43; // x10
  unsigned int v44; // w8
  __int64 v45; // x0
  float v46; // s0
  __int64 v47; // x28
  __int64 *v48; // x28
  unsigned __int64 v49; // x8
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x8
  unsigned __int64 v53; // x8
  unsigned __int64 v54; // x8
  unsigned __int64 v55; // x8
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x8
  unsigned __int64 v58; // x8
  size_t v59; // x0
  __int64 v60; // x21
  _BYTE *v61; // x21
  __int64 v62; // x27
  unsigned __int64 v63; // x22
  __int64 v64; // x19
  unsigned __int64 v65; // x0
  unsigned __int64 v66; // x0
  __int64 v67; // x8
  unsigned __int64 v68; // x9
  unsigned __int64 v69; // x0
  unsigned __int64 v70; // x0
  unsigned __int64 v71; // x9
  unsigned int v72; // w9
  unsigned __int64 v73; // x9
  unsigned __int64 v74; // x9
  unsigned __int64 v75; // x9
  unsigned __int64 v76; // x9
  unsigned __int64 v77; // x9
  int v78; // w9
  unsigned __int64 v79; // x9
  int v80; // w9
  unsigned __int64 v81; // x9
  unsigned __int64 v82; // x9
  unsigned __int64 v83; // x10
  __int64 v84; // x13
  int v85; // w11
  __int64 v86; // x8
  int v87; // w12
  int v88; // w14
  float v89; // s0
  unsigned __int64 v90; // x14
  float v91; // s0
  unsigned __int64 v92; // x9
  unsigned __int8 *v93; // x8
  __int64 v94; // x21
  size_t v95; // x0
  _WORD *v96; // x21
  unsigned __int64 v97; // x22
  __int64 *v98; // x25
  __int64 v99; // x19
  unsigned __int64 v100; // x0
  unsigned __int64 v101; // x8
  _QWORD *v102; // x21
  int v103; // w24
  size_t v104; // x0
  void *v105; // x0
  __int64 v106; // x8
  unsigned __int64 v107; // x28
  unsigned int v108; // w25
  __int64 v109; // x27
  __int64 v110; // x0
  unsigned __int64 v111; // x0
  unsigned __int64 v112; // x0
  unsigned __int64 v113; // x8
  _QWORD *v115; // [xsp+8h] [xbp-C8h]
  unsigned __int64 *v116; // [xsp+18h] [xbp-B8h]
  _QWORD *v117; // [xsp+20h] [xbp-B0h]
  _QWORD *v118; // [xsp+28h] [xbp-A8h] BYREF
  __int64 v119; // [xsp+30h] [xbp-A0h]
  unsigned __int64 v120; // [xsp+38h] [xbp-98h]
  unsigned __int64 v121; // [xsp+40h] [xbp-90h]
  unsigned __int64 v122; // [xsp+48h] [xbp-88h] BYREF
  __int64 v123; // [xsp+50h] [xbp-80h]
  unsigned __int64 v124; // [xsp+58h] [xbp-78h]
  __int64 v125; // [xsp+60h] [xbp-70h]
  __int64 v126; // [xsp+68h] [xbp-68h]

  v3 = 1;
  v126 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 && a2 )
  {
    if ( a3 )
    {
      v6 = a1;
      v118 = calloc(1u, 0x78u);
      v119 = a2;
      v120 = a3;
      v121 = 0;
      v122 = 0;
      v123 = 0;
      v124 = 0;
      v125 = 0;
      v7 = setjmp(&_excBuf);
      if ( v7 )
      {
        v8 = v7;
        lm1_free((__int64)&v118);
        if ( (unsigned int)(v8 - 1) > 0xE )
          return (unsigned int)-1;
        else
          return dword_224BC[v8 - 1];
      }
      else
      {
        v9 = v120;
        v10 = v121;
        if ( v121 < v120 )
        {
          v11 = &v122;
          v3 = 0;
          v12 = v121;
          while ( 1 )
          {
            v10 = v12 + 4;
            if ( v12 + 4 > v9 )
              goto LABEL_345;
            if ( (_BYTE)v123 )
            {
              if ( v122 <= 3 )
                goto LABEL_344;
              v122 -= 4LL;
            }
            if ( (_BYTE)v125 )
            {
              if ( v124 < 4 )
                goto LABEL_344;
              v124 -= 4LL;
            }
            v121 = v12 + 4;
            switch ( *(_DWORD *)(v119 + v12) )
            {
              case 0xFFFFFFFE:
                v13 = v118;
                FlexibleAsUInt64 = _readFlexibleAsUInt64((__int64)&v118);
                if ( HIDWORD(FlexibleAsUInt64) )
                  goto LABEL_343;
                *(_DWORD *)v13 = FlexibleAsUInt64;
                v122 = (unsigned int)FlexibleAsUInt64;
                LOBYTE(v123) = 1;
                v13[1] = _readFlexibleAsUInt64((__int64)&v118);
                v15 = _readFlexibleAsUInt64((__int64)&v118);
                if ( HIDWORD(v15) )
                  goto LABEL_343;
                *((_DWORD *)v13 + 4) = v15;
                v16 = _readFlexibleAsUInt64((__int64)&v118);
                if ( HIDWORD(v16) )
                  goto LABEL_343;
                *((_DWORD *)v13 + 5) = v16;
                v17 = v122;
                if ( !v122 )
                  goto LABEL_335;
                v18 = v121 + v122;
                if ( v121 + v122 > v120 )
                  goto LABEL_345;
                if ( (_BYTE)v123 )
                  v122 = 0;
                if ( !(_BYTE)v125 )
                  goto LABEL_334;
                v19 = v124 >= v17;
                v20 = v124 - v17;
                if ( !v19 )
                  goto LABEL_344;
                goto LABEL_333;
              case 0xFFFFFFFF:
                goto LABEL_340;
              case 0:
                longjmp(&_excBuf, 4);
              case 1:
                v22 = _readFlexibleAsUInt64((__int64)&v118);
                if ( v22 >= 0x100 )
                  goto LABEL_343;
                if ( (unsigned __int8)v22 != 2 )
                {
                  if ( (unsigned __int8)v22 == 1 )
                    longjmp(&_excBuf, 5);
                  longjmp(&_excBuf, 6);
                }
                v23 = _readFlexibleAsUInt64((__int64)&v118);
                if ( v23 >= 0x100 )
                  goto LABEL_343;
                if ( (_BYTE)v23 )
                  longjmp(&_excBuf, 7);
                v24 = _readFlexibleAsUInt64((__int64)&v118);
                if ( v24 >= 0x100 )
                  goto LABEL_343;
                v25 = v24;
                v26 = _readFlexibleAsUInt64((__int64)&v118);
                v122 = v26;
                LOBYTE(v123) = 1;
                switch ( v25 )
                {
                  case 34:
                    v102 = v118;
                    v116 = v11;
                    v117 = v6;
                    if ( !v118[9] )
                      longjmp(&_excBuf, 8);
                    v103 = *(_DWORD *)(v118[10] + 112LL);
                    *((_WORD *)v118 + 44) = 2;
                    v102[12] = v26;
                    *((_BYTE *)v102 + 90) = 34;
                    v104 = _readFlexibleAsUInt64((__int64)&v118);
                    v102[13] = v104;
                    if ( v104 )
                    {
                      v105 = calloc(v104, 0x18u);
                      v106 = v102[13];
                      v102[14] = v105;
                      if ( v106 )
                      {
                        v107 = 0;
                        v108 = 1;
                        do
                        {
                          v109 = v102[14];
                          v110 = _readFlexibleAsUInt64((__int64)&v118);
                          *(_QWORD *)(v109 + 24 * v107) = v110;
                          v124 = v110;
                          LOBYTE(v125) = 1;
                          if ( (v103 & 4) != 0 )
                            *(_QWORD *)(v109 + 24 * v107 + 8) = _readFlexibleAsUInt64((__int64)&v118);
                          if ( (v103 & 1) != 0 )
                          {
                            v111 = _readFlexibleAsUInt64((__int64)&v118);
                            if ( v111 >= 0x10000 )
                              goto LABEL_343;
                            *(float *)(v109 + 24 * v107 + 16) = (float)(unsigned __int16)v111 * -0.0013733;
                          }
                          if ( (v103 & 2) != 0 )
                          {
                            v112 = _readFlexibleAsUInt64((__int64)&v118);
                            if ( v112 >= 0x10000 )
                              goto LABEL_343;
                            *(float *)(v109 + 24 * v107 + 20) = (float)(unsigned __int16)v112 * -0.0013733;
                          }
                          if ( v124 )
                          {
                            v113 = v121 + v124;
                            if ( v121 + v124 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 < v124 )
                                goto LABEL_344;
                              v122 -= v124;
                            }
                            if ( (_BYTE)v125 )
                              v124 = 0;
                            v121 = v113;
                          }
                          v107 = v108++;
                          v124 = 0;
                          v125 = 0;
                        }
                        while ( v102[13] > v107 );
                      }
                    }
LABEL_325:
                    v26 = v122;
                    v11 = v116;
                    v6 = v117;
                    if ( !v122 )
                      goto LABEL_335;
                    goto LABEL_328;
                  case 33:
                    v30 = v118;
                    v116 = v11;
                    v117 = v6;
                    *((_WORD *)v118 + 28) = 2;
                    v30[8] = v26;
                    *((_BYTE *)v30 + 58) = 33;
                    v31 = _readFlexibleAsUInt64((__int64)&v118);
                    v30[9] = v31;
                    if ( v31 )
                    {
                      v32 = calloc(v31, 0xB8u);
                      v33 = v30[9];
                      v30[10] = v32;
                      if ( v33 )
                      {
                        v34 = 0;
                        v115 = v30;
                        while ( 1 )
                        {
                          v35 = v30[10];
                          v36 = _readFlexibleAsUInt64((__int64)&v118);
                          *(_QWORD *)(v35 + 184 * v34) = v36;
                          v38 = v120;
                          v37 = v121;
                          v124 = v36;
                          LOBYTE(v125) = 1;
                          v39 = v121 + 1;
                          if ( v121 + 1 > v120 )
                            goto LABEL_345;
                          v40 = (unsigned __int8)v123;
                          v41 = v119;
                          if ( (_BYTE)v123 )
                          {
                            if ( !v122 )
                              goto LABEL_344;
                            --v122;
                          }
                          if ( !v36 )
                            goto LABEL_344;
                          v124 = v36 - 1;
                          ++v121;
                          v42 = *(unsigned __int8 *)(v119 + v37);
                          *(_BYTE *)(v35 + 184 * v34 + 8) = v42;
                          if ( (unsigned int)(v42 - 1) >= 2 )
                            longjmp(&_excBuf, 10);
                          v43 = v37 + 2;
                          if ( v43 > v38 )
                            goto LABEL_345;
                          if ( v40 )
                          {
                            if ( !v122 )
                              goto LABEL_344;
                            --v122;
                          }
                          if ( v36 == 1 )
                            goto LABEL_344;
                          v124 = v36 - 2;
                          v121 = v43;
                          v44 = *(unsigned __int8 *)(v41 + v39);
                          *(_BYTE *)(v35 + 184 * v34 + 9) = v44;
                          if ( v44 >= 7 )
                            longjmp(&_excBuf, 11);
                          v45 = _readFlexibleAsUInt64((__int64)&v118);
                          v47 = v35 + 184 * v34;
                          *(_QWORD *)(v47 + 16) = v45;
                          v48 = (__int64 *)(v47 + 16);
                          if ( (v45 & 1) != 0 )
                          {
                            v49 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v49);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 24) = v46;
                          }
                          if ( (v45 & 2) != 0 )
                          {
                            v50 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v50);
                            v46 = (float)LODWORD(v46) * 0.00012207;
                            *(float *)(v35 + 184 * v34 + 28) = v46;
                          }
                          if ( (v45 & 4) != 0 )
                          {
                            v51 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v51);
                            v46 = (float)LODWORD(v46) * 0.0013733;
                            *(float *)(v35 + 184 * v34 + 32) = v46;
                          }
                          if ( (v45 & 8) != 0 )
                          {
                            v52 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v52);
                            v46 = (float)LODWORD(v46) * 0.0013733;
                            *(float *)(v35 + 184 * v34 + 36) = v46;
                          }
                          if ( (v45 & 0x10) != 0 )
                          {
                            v53 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v53);
                            v46 = (float)LODWORD(v46) * 0.0013733;
                            *(float *)(v35 + 184 * v34 + 40) = v46;
                          }
                          if ( (v45 & 0x20) != 0 )
                          {
                            v54 = v121;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            LOBYTE(v46) = *(_BYTE *)(v119 + v54);
                            v46 = (float)((float)LODWORD(v46) * 0.25) + -32.0;
                            *(float *)(v35 + 184 * v34 + 44) = v46;
                          }
                          if ( (v45 & 0x40) != 0 )
                          {
                            v55 = v121;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            LOBYTE(v46) = *(_BYTE *)(v119 + v55);
                            v46 = (float)((float)LODWORD(v46) * 0.25) + -32.0;
                            *(float *)(v35 + 184 * v34 + 48) = v46;
                          }
                          if ( (v45 & 0x80) != 0 )
                          {
                            v56 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v56);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 52) = v46;
                          }
                          if ( (v45 & 0x100) != 0 )
                          {
                            v57 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v57);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 56) = v46;
                          }
                          if ( (v45 & 0x200) != 0 )
                          {
                            v58 = v121;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            v59 = *(unsigned __int8 *)(v119 + v58);
                            v60 = v35 + 184 * v34;
                            *(_BYTE *)(v60 + 64) = v59;
                            v61 = (_BYTE *)(v60 + 64);
                            if ( v59 )
                            {
                              *(_QWORD *)(v35 + 184 * v34 + 72) = calloc(v59, 8u);
                              if ( *v61 )
                                break;
                            }
                          }
LABEL_160:
                          v67 = *v48;
                          if ( (*v48 & 0x400) != 0 )
                          {
                            v68 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v68);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 80) = v46;
                          }
                          if ( (v67 & 0x800) != 0 )
                          {
                            v69 = _readFlexibleAsUInt64((__int64)&v118);
                            if ( v69 >= 0x10000 )
                              goto LABEL_343;
                            v46 = (float)(unsigned __int16)v69 * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 84) = v46;
                            v67 = *v48;
                          }
                          if ( (v67 & 0x1000) != 0 )
                          {
                            v70 = _readFlexibleAsUInt64((__int64)&v118);
                            if ( v70 >= 0x10000 )
                              goto LABEL_343;
                            v46 = (float)(unsigned __int16)v70 * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 88) = v46;
                            v67 = *v48;
                          }
                          if ( (v67 & 0x2000) != 0 )
                          {
                            *(_QWORD *)(v35 + 184 * v34 + 96) = _readFlexibleAsUInt64((__int64)&v118);
                            v67 = *v48;
                          }
                          if ( (v67 & 0x4000) != 0 )
                          {
                            v71 = v121;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            v72 = *(unsigned __int8 *)(v119 + v71);
                            *(_BYTE *)(v35 + 184 * v34 + 104) = v72;
                            if ( v72 >= 2 )
                              longjmp(&_excBuf, 15);
                          }
                          if ( (v67 & 0x8000) != 0 )
                          {
                            *(_QWORD *)(v35 + 184 * v34 + 112) = _readFlexibleAsUInt64((__int64)&v118);
                            v67 = *v48;
                          }
                          if ( (v67 & 0x10000) != 0 )
                          {
                            v73 = v121;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            LOBYTE(v46) = *(_BYTE *)(v119 + v73);
                            v46 = (float)((float)LODWORD(v46) * 0.25) + -32.0;
                            *(float *)(v35 + 184 * v34 + 120) = v46;
                          }
                          if ( (v67 & 0x20000) != 0 )
                          {
                            v74 = v121;
                            if ( v121 + 4 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 3 )
                                goto LABEL_344;
                              v122 -= 4LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 4 )
                                goto LABEL_344;
                              v124 -= 4LL;
                            }
                            v121 += 4LL;
                            v46 = (float)*(unsigned int *)(v119 + v74) * 0.0000000018626;
                            *(float *)(v35 + 184 * v34 + 124) = v46;
                          }
                          if ( (v67 & 0x40000) != 0 )
                          {
                            v75 = v121;
                            if ( v121 + 4 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 3 )
                                goto LABEL_344;
                              v122 -= 4LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 4 )
                                goto LABEL_344;
                              v124 -= 4LL;
                            }
                            v121 += 4LL;
                            v46 = (float)*(unsigned int *)(v119 + v75) * 0.0000000018626;
                            *(float *)(v35 + 184 * v34 + 128) = v46;
                          }
                          if ( (v67 & 0x80000) != 0 )
                          {
                            v76 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v76);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 132) = v46;
                          }
                          if ( (v67 & 0x100000) != 0 )
                          {
                            v77 = v121;
                            if ( v121 + 4 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 3 )
                                goto LABEL_344;
                              v122 -= 4LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 4 )
                                goto LABEL_344;
                              v124 -= 4LL;
                            }
                            v121 += 4LL;
                            v78 = *(_DWORD *)(v119 + v77);
                            HIWORD(v46) = 32640;
                            *(_DWORD *)(v35 + 184 * v34 + 136) = v78;
                            if ( COERCE_FLOAT(v78 & 0x7FFFFFFF) >= INFINITY
                              && COERCE_FLOAT(v78 & 0x7FFFFFFF) <= INFINITY )
                            {
                              longjmp(&_excBuf, 12);
                            }
                          }
                          if ( (v67 & 0x200000) != 0 )
                          {
                            v79 = v121;
                            if ( v121 + 4 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 3 )
                                goto LABEL_344;
                              v122 -= 4LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 4 )
                                goto LABEL_344;
                              v124 -= 4LL;
                            }
                            v121 += 4LL;
                            v80 = *(_DWORD *)(v119 + v79);
                            HIWORD(v46) = 32640;
                            *(_DWORD *)(v35 + 184 * v34 + 140) = v80;
                            if ( COERCE_FLOAT(v80 & 0x7FFFFFFF) >= INFINITY
                              && COERCE_FLOAT(v80 & 0x7FFFFFFF) <= INFINITY )
                            {
                              longjmp(&_excBuf, 13);
                            }
                          }
                          if ( (v67 & 0x400000) != 0 )
                          {
                            v81 = v121;
                            if ( v121 + 2 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( (_BYTE)v125 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 += 2LL;
                            LOWORD(v46) = *(_WORD *)(v119 + v81);
                            v46 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 144) = v46;
                          }
                          if ( (v67 & 0x800000) != 0 )
                          {
                            v83 = v120;
                            v82 = v121;
                            v84 = v121 + 1;
                            if ( v121 + 1 > v120 )
                              goto LABEL_345;
                            v85 = (unsigned __int8)v123;
                            v86 = v119;
                            if ( (_BYTE)v123 )
                            {
                              if ( !v122 )
                                goto LABEL_344;
                              --v122;
                            }
                            v87 = (unsigned __int8)v125;
                            if ( (_BYTE)v125 )
                            {
                              if ( !v124 )
                                goto LABEL_344;
                              --v124;
                            }
                            ++v121;
                            v88 = *(unsigned __int8 *)(v119 + v82);
                            *(_BYTE *)(v35 + 184 * v34 + 152) = v88;
                            if ( (unsigned int)(v88 - 1) >= 2 )
                              longjmp(&_excBuf, 14);
                            if ( v82 + 3 > v83 )
                              goto LABEL_345;
                            if ( v85 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( v87 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 = v82 + 3;
                            LOWORD(v46) = *(_WORD *)(v86 + v84);
                            v89 = (float)LODWORD(v46) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 156) = v89;
                            if ( v82 + 5 > v83 )
                              goto LABEL_345;
                            if ( v85 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( v87 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 = v82 + 5;
                            LOWORD(v89) = *(_WORD *)(v86 + v82 + 3);
                            v90 = v82 + 7;
                            v91 = (float)LODWORD(v89) * -0.0013733;
                            *(float *)(v35 + 184 * v34 + 160) = v91;
                            if ( v82 + 7 > v83 )
                              goto LABEL_345;
                            if ( v85 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( v87 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v121 = v82 + 7;
                            LOWORD(v91) = *(_WORD *)(v86 + v82 + 5);
                            v92 = v82 + 9;
                            *(float *)(v35 + 184 * v34 + 164) = (float)LODWORD(v91) * 0.0013733;
                            if ( v92 > v83 )
                              goto LABEL_345;
                            if ( v85 )
                            {
                              if ( v122 <= 1 )
                                goto LABEL_344;
                              v122 -= 2LL;
                            }
                            if ( v87 )
                            {
                              if ( v124 < 2 )
                                goto LABEL_344;
                              v124 -= 2LL;
                            }
                            v93 = (unsigned __int8 *)(v86 + v90);
                            v121 = v92;
                            v94 = v35 + 184 * v34;
                            v95 = *v93 | ((unsigned __int64)v93[1] << 8);
                            *(_WORD *)(v94 + 168) = *v93 | (v93[1] << 8);
                            v96 = (_WORD *)(v94 + 168);
                            if ( (_DWORD)v95 )
                            {
                              *(_QWORD *)(v35 + 184 * v34 + 176) = calloc(v95, 4u);
                              if ( *v96 )
                              {
                                v97 = 0;
                                v98 = (__int64 *)(v35 + 184 * v34 + 176);
                                do
                                {
                                  v99 = *v98;
                                  v100 = _readFlexibleAsUInt64((__int64)&v118);
                                  if ( v100 >= 0x10000 )
                                    goto LABEL_343;
                                  *(float *)(v99 + 4 * v97++) = (float)(unsigned __int16)v100 * 0.000015259;
                                }
                                while ( v97 < (unsigned __int16)*v96 );
                              }
                            }
                          }
                          v30 = v115;
                          if ( v124 )
                          {
                            v101 = v121 + v124;
                            if ( v121 + v124 > v120 )
                              goto LABEL_345;
                            if ( (_BYTE)v123 )
                            {
                              if ( v122 < v124 )
                                goto LABEL_344;
                              v122 -= v124;
                            }
                            if ( (_BYTE)v125 )
                              v124 = 0;
                            v121 = v101;
                          }
                          v34 = (unsigned int)(v34 + 1);
                          v124 = 0;
                          v125 = 0;
                          if ( v115[9] <= v34 )
                            goto LABEL_325;
                        }
                        v62 = 0;
                        v63 = 0;
                        while ( 1 )
                        {
                          v64 = *(_QWORD *)(v35 + 184 * v34 + 72);
                          v65 = _readFlexibleAsUInt64((__int64)&v118);
                          if ( HIDWORD(v65) )
                            break;
                          *(_DWORD *)(v64 + v62) = v65;
                          v66 = _readFlexibleAsUInt64((__int64)&v118);
                          if ( v66 >= 0x10000 )
                            break;
                          v46 = (float)(unsigned __int16)v66 * 0.000015259;
                          *(float *)(v64 + v62 + 4) = v46;
                          ++v63;
                          v62 += 8;
                          if ( v63 >= (unsigned __int8)*v61 )
                            goto LABEL_160;
                        }
LABEL_343:
                        longjmp(&_excBuf, 2);
                      }
                    }
                    goto LABEL_325;
                  case 0:
                    v116 = v11;
                    v117 = v6;
                    v27 = v118;
                    v118[4] = v26;
                    *((_WORD *)v27 + 12) = 2;
                    *((_BYTE *)v27 + 26) = 0;
                    v28 = _readFlexibleAsUInt64((__int64)&v118);
                    v27[5] = v28;
                    if ( (v28 & 1) != 0 )
                    {
                      v29 = _readFlexibleAsUInt64((__int64)&v118);
                      if ( HIDWORD(v29) )
                        goto LABEL_343;
                      *((float *)v27 + 12) = (float)(unsigned int)v29;
                    }
                    goto LABEL_325;
                }
                v3 = 4;
                if ( !v26 )
                  goto LABEL_335;
LABEL_328:
                v18 = v121 + v26;
                if ( v121 + v26 > v120 )
                  goto LABEL_345;
                if ( (_BYTE)v123 )
                  v122 = 0;
                if ( (_BYTE)v125 )
                {
                  v20 = v124 - v26;
                  if ( v124 < v26 )
LABEL_344:
                    longjmp(&_excBuf, 9);
LABEL_333:
                  v124 = v20;
                }
LABEL_334:
                v121 = v18;
LABEL_335:
                *v11 = 0;
                v11[1] = 0;
LABEL_336:
                v9 = v120;
                v12 = v121;
                v10 = v121;
                if ( v121 >= v120 )
                  goto LABEL_340;
                break;
              default:
                v21 = _readFlexibleAsUInt64((__int64)&v118);
                if ( !v21 )
                  goto LABEL_336;
                if ( v121 + v21 > v120 )
                  goto LABEL_345;
                if ( !(_BYTE)v123 )
                  goto LABEL_33;
                if ( v122 < v21 )
                  goto LABEL_344;
                v122 -= v21;
LABEL_33:
                if ( !(_BYTE)v125 )
                  goto LABEL_36;
                if ( v124 < v21 )
                  goto LABEL_344;
                v124 -= v21;
LABEL_36:
                v121 += v21;
                goto LABEL_336;
            }
          }
        }
        v3 = 0;
LABEL_340:
        if ( v10 != v9 )
LABEL_345:
          longjmp(&_excBuf, 3);
        *v6 = v118;
      }
    }
    else
    {
      return 2;
    }
  }
  return v3;
}
// 49834: variable 'v46' is possibly undefined
// 224BC: using guessed type unsigned int dword_224BC[15];
// 78950: using guessed type struct __jmp_buf_tag _excBuf;

//----- (000000000004A6C4) ----------------------------------------------------
__int64 __fastcall lm1_free(__int64 a1)
{
  _QWORD *v1; // x21
  char *v3; // x20
  unsigned __int64 v4; // x24
  unsigned int v5; // w22
  char *v6; // x25
  void *v7; // x0
  _QWORD *v8; // x25
  void *v9; // t1
  char *v10; // x20
  void *v11; // x0
  _QWORD *v12; // x20
  void *v13; // t1
  __int64 result; // x0
  _QWORD *v15; // x20
  void *v16; // x0

  if ( !a1 )
    return 1;
  v1 = *(_QWORD **)a1;
  if ( !*(_QWORD *)a1 )
    return 1;
  v3 = (char *)v1[10];
  if ( v1[9] )
  {
    v4 = 0;
    v5 = 1;
    do
    {
      v6 = &v3[184 * v4];
      v9 = (void *)*((_QWORD *)v6 + 22);
      v8 = v6 + 176;
      v7 = v9;
      if ( v9 )
      {
        free(v7);
        *v8 = 0;
      }
      v10 = &v3[184 * v4];
      v13 = (void *)*((_QWORD *)v10 + 9);
      v12 = v10 + 72;
      v11 = v13;
      if ( v13 )
      {
        free(v11);
        *v12 = 0;
      }
      v3 = (char *)v1[10];
      v4 = v5++;
    }
    while ( v1[9] > v4 );
  }
  if ( v3 )
  {
    free(v3);
    v1[10] = 0;
  }
  v15 = *(_QWORD **)a1;
  v16 = *(void **)(*(_QWORD *)a1 + 112LL);
  if ( v16 )
  {
    free(v16);
    v15[14] = 0;
    v15 = *(_QWORD **)a1;
  }
  if ( !v15 )
    return 0;
  free(v15);
  result = 0;
  *(_QWORD *)a1 = 0;
  return result;
}

//----- (000000000004A7AC) ----------------------------------------------------
void __fastcall std::mutex::~mutex(pthread_mutex_t *this)
{
  pthread_mutex_destroy(this);
}

//----- (000000000004A7CC) ----------------------------------------------------
void __fastcall __noreturn sub_4A7CC(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (000000000004A7E0) ----------------------------------------------------
unsigned __int64 std::get_unexpected(void)
{
  return atomic_load((unsigned __int64 *)&_cxa_unexpected_handler);
}
// 78900: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000004A7F4) ----------------------------------------------------
void __noreturn std::terminate(void)
{
  __int64 *globals_fast; // x0
  __int64 v1; // x19
  void (*v2)(void); // x0

  globals_fast = __cxa_get_globals_fast();
  if ( globals_fast )
  {
    v1 = *globals_fast;
    if ( *globals_fast )
    {
      if ( sub_63698((_QWORD *)(v1 + 96)) )
        sub_4A880(*(void (**)(void))(v1 + 40));
    }
  }
  v2 = (void (*)(void))atomic_load((unsigned __int64 *)&_cxa_terminate_handler);
  sub_4A880(v2);
}
// 4A7CC: using guessed type void __fastcall __noreturn sub_4A7CC(_QWORD);
// 788F8: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (000000000004A834) ----------------------------------------------------
void __fastcall __noreturn sub_4A834(void (*a1)(void))
{
  a1();
  sub_4AC40("unexpected_handler unexpectedly returned");
}

//----- (000000000004A850) ----------------------------------------------------
void __noreturn std::unexpected(void)
{
  void (*v0)(void); // x0

  v0 = (void (*)(void))atomic_load((unsigned __int64 *)&_cxa_unexpected_handler);
  sub_4A834(v0);
}
// 78900: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000004A86C) ----------------------------------------------------
unsigned __int64 std::get_terminate(void)
{
  return atomic_load((unsigned __int64 *)&_cxa_terminate_handler);
}
// 788F8: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (000000000004A880) ----------------------------------------------------
void __fastcall __noreturn sub_4A880(void (*a1)(void))
{
  a1();
  sub_4AC40("terminate_handler unexpectedly returned");
}
// 4A7CC: using guessed type void __noreturn sub_4A7CC(void);

//----- (000000000004A8B0) ----------------------------------------------------
unsigned __int64 std::get_new_handler(void)
{
  return atomic_load((unsigned __int64 *)&_cxa_new_handler);
}
// 78AD0: using guessed type __int64 _cxa_new_handler;

//----- (000000000004A8C4) ----------------------------------------------------
void __noreturn sub_4A8C4()
{
  _QWORD *globals_fast; // x0
  _QWORD *v1; // x20
  __int64 v2; // x8
  _QWORD *v3; // x20
  const char *v4; // x19
  char *v5; // x0
  const char *v6; // x20
  const char *v7; // x0
  __int64 v8; // [xsp+18h] [xbp+18h] BYREF

  globals_fast = __cxa_get_globals_fast();
  if ( !globals_fast || (v1 = (_QWORD *)*globals_fast) == 0 )
    sub_4AC40("terminating");
  if ( sub_63698(v1 + 12) )
  {
    if ( sub_6368C((__int64)(v1 + 12)) == 0x434C4E47432B2B01LL )
      v2 = v1[1];
    else
      v2 = (__int64)(v1 + 16);
    v3 = (_QWORD *)v1[2];
    v8 = v2;
    v4 = (const char *)v3[1];
    v5 = __cxa_demangle(v4, 0, 0, 0);
    if ( v5 )
      v4 = v5;
    if ( (sub_4AF68((__int64)&`typeinfo for'std::exception, v3, &v8) & 1) != 0 )
    {
      v6 = off_78908;
      v7 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 16LL))(v8);
      sub_4AC40("terminating due to %s exception of type %s: %s", v6, v4, v7);
    }
    sub_4AC40("terminating due to %s exception of type %s", off_78908, v4);
  }
  sub_4AC40("terminating due to %s foreign exception", off_78908);
}
// 6EDF0: using guessed type __int64 *`typeinfo for'std::exception;
// 78908: using guessed type char *off_78908;

//----- (000000000004AA14) ----------------------------------------------------
void __noreturn sub_4AA14()
{
  off_78908 = "unexpected";
  std::terminate();
}
// 78908: using guessed type char *off_78908;

//----- (000000000004AA34) ----------------------------------------------------
unsigned __int64 __fastcall std::set_unexpected(void (__noreturn *a1)())
{
  if ( !a1 )
    a1 = sub_4AA14;
  return sub_65610((unsigned __int64)a1, (atomic_ullong *)&_cxa_unexpected_handler);
}
// 78900: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000004AA68) ----------------------------------------------------
unsigned __int64 __fastcall std::set_terminate(void (__noreturn *a1)())
{
  if ( !a1 )
    a1 = sub_4A8C4;
  return sub_65610((unsigned __int64)a1, (atomic_ullong *)&_cxa_terminate_handler);
}
// 788F8: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (000000000004AA9C) ----------------------------------------------------
unsigned __int64 __fastcall std::set_new_handler(void (*a1)(void))
{
  return sub_65610((unsigned __int64)a1, (atomic_ullong *)&_cxa_new_handler);
}
// 78AD0: using guessed type __int64 _cxa_new_handler;

//----- (000000000004AAC0) ----------------------------------------------------
void __fastcall sub_4AAC0(void *ptr)
{
  free(ptr);
}

//----- (000000000004AAC8) ----------------------------------------------------
void sub_4AAC8()
{
  ;
}

//----- (000000000004AAD0) ----------------------------------------------------
_QWORD *_cxa_get_globals()
{
  return __emutls_get_address(qword_78910);
}
// 78910: using guessed type size_t qword_78910[4];

//----- (000000000004AAF4) ----------------------------------------------------
_QWORD *_cxa_get_globals_fast()
{
  return __emutls_get_address(qword_78910);
}
// 78910: using guessed type size_t qword_78910[4];

//----- (000000000004AB18) ----------------------------------------------------
void __fastcall std::exception::~exception(std::exception *this)
{
  ;
}

//----- (000000000004AB20) ----------------------------------------------------
void __fastcall std::exception::~exception(std::exception *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (000000000004AB4C) ----------------------------------------------------
const char *__fastcall std::exception::what(std::exception *this)
{
  return "std::exception";
}

//----- (000000000004AB5C) ----------------------------------------------------
void __fastcall std::bad_exception::~bad_exception(std::bad_exception *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (000000000004AB88) ----------------------------------------------------
const char *__fastcall std::bad_exception::what(std::bad_exception *this)
{
  return "std::bad_exception";
}

//----- (000000000004AB98) ----------------------------------------------------
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this)
{
  *this = off_6ED88;
  return this;
}
// 6ED88: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (000000000004ABB0) ----------------------------------------------------
void __fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (000000000004ABDC) ----------------------------------------------------
const char *__fastcall std::bad_alloc::what(std::bad_alloc *this)
{
  return "std::bad_alloc";
}

//----- (000000000004ABEC) ----------------------------------------------------
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *this)
{
  *this = off_6EDB0;
  return this;
}
// 6EDB0: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (000000000004AC04) ----------------------------------------------------
void __fastcall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (000000000004AC30) ----------------------------------------------------
const char *__fastcall std::bad_array_new_length::what(std::bad_array_new_length *this)
{
  return "bad_array_new_length";
}

//----- (000000000004AC40) ----------------------------------------------------
void __noreturn sub_4AC40(const char *a1, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list arg; // [xsp+E0h] [xbp-40h] BYREF
  gcc_va_list va; // [xsp+100h] [xbp-20h] BYREF
  char *ptr; // [xsp+138h] [xbp+18h] BYREF

  va_start(va, a1);
  fwrite("libc++abi: ", 0xBu, 1u, (FILE *)((char *)&_sF + 304));
  va_copy(arg, va);
  vfprintf((FILE *)((char *)&_sF + 304), a1, arg);
  fputc(10, (FILE *)((char *)&_sF + 304));
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  vasprintf(&ptr, a1, va1);
  android_set_abort_message(ptr);
  openlog("libc++abi", 0, 0);
  syslog(2, "%s", ptr);
  closelog();
  abort();
}
// 6AAB0: using guessed type __int64 __fastcall android_set_abort_message(_QWORD);

//----- (000000000004AD48) ----------------------------------------------------
void __fastcall sub_4AD48(std::type_info *a1)
{
  std::type_info::~type_info(a1);
}

//----- (000000000004AD50) ----------------------------------------------------
__int64 sub_4AD50()
{
  __break(1u);
  return sub_4AD58();
}
// 4AD58: using guessed type __int64 sub_4AD58(void);

//----- (000000000004AD58) ----------------------------------------------------
void sub_4AD58()
{
  ;
}

//----- (000000000004AD60) ----------------------------------------------------
void sub_4AD60()
{
  ;
}

//----- (000000000004AD68) ----------------------------------------------------
void __fastcall sub_4AD68(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AD94) ----------------------------------------------------
void __fastcall sub_4AD94(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004ADC0) ----------------------------------------------------
void __fastcall sub_4ADC0(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004ADEC) ----------------------------------------------------
void __fastcall sub_4ADEC(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AE18) ----------------------------------------------------
void __fastcall sub_4AE18(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AE44) ----------------------------------------------------
void __fastcall sub_4AE44(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AE70) ----------------------------------------------------
void __fastcall sub_4AE70(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AE9C) ----------------------------------------------------
void __fastcall sub_4AE9C(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AEC8) ----------------------------------------------------
void __fastcall sub_4AEC8(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AEF4) ----------------------------------------------------
void __fastcall sub_4AEF4(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (000000000004AF20) ----------------------------------------------------
bool __fastcall sub_4AF20(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

//----- (000000000004AF38) ----------------------------------------------------
__int64 sub_4AF38()
{
  return 0;
}

//----- (000000000004AF44) ----------------------------------------------------
__int64 sub_4AF44()
{
  return 0;
}

//----- (000000000004AF50) ----------------------------------------------------
bool __fastcall sub_4AF50(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

//----- (000000000004AF68) ----------------------------------------------------
__int64 __fastcall sub_4AF68(__int64 a1, _QWORD *lpsrc, __int64 *a3)
{
  __int64 result; // x0
  __int64 v6; // x2
  _QWORD v7[4]; // [xsp+0h] [xbp-50h] BYREF
  __int128 v8; // [xsp+20h] [xbp-30h]
  _DWORD v9[8]; // [xsp+30h] [xbp-20h] BYREF

  if ( *(_QWORD *)(a1 + 8) == lpsrc[1] )
    return 1;
  result = (__int64)__dynamic_cast(
                      lpsrc,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                      0);
  if ( result )
  {
    v7[0] = result;
    v7[1] = 0;
    v6 = *a3;
    v7[2] = a1;
    v7[3] = -1;
    v8 = 0u;
    memset(v9, 0, 31);
    v9[6] = 1;
    (*(void (__fastcall **)(__int64, _QWORD *, __int64, __int64))(*(_QWORD *)result + 56LL))(result, v7, v6, 1);
    result = v9[0] == 1;
    if ( v9[0] == 1 )
      *a3 = v8;
  }
  return result;
}
// 6EE70: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 6EE88: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;

//----- (000000000004B034) ----------------------------------------------------
void *_dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  __int64 v5; // x9
  _QWORD *v6; // x0
  __int64 v7; // x11
  char *v8; // x19
  __int64 v9; // x10
  void *result; // x0
  _QWORD v13[4]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v14; // [xsp+20h] [xbp-40h]
  _OWORD v15[2]; // [xsp+30h] [xbp-30h] BYREF

  v5 = *((_QWORD *)lpdtype + 1);
  v7 = *(_QWORD *)(*(_QWORD *)lpsrc - 16LL);
  v6 = *(_QWORD **)(*(_QWORD *)lpsrc - 8LL);
  v13[1] = lpsrc;
  v13[2] = lpstype;
  v13[3] = s2d;
  v14 = 0u;
  memset(v15, 0, 31);
  v8 = (char *)lpsrc + v7;
  v9 = v6[1];
  v13[0] = lpdtype;
  if ( v9 == v5 )
  {
    DWORD2(v15[1]) = 1;
    (*(void (__fastcall **)(_QWORD *, _QWORD *, char *, char *, __int64, _QWORD))(*v6 + 40LL))(
      v6,
      v13,
      (char *)lpsrc + v7,
      (char *)lpsrc + v7,
      1,
      0);
    if ( LODWORD(v15[0]) == 1 )
      return v8;
    else
      return 0;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD *, _QWORD *, char *, __int64, _QWORD))(*v6 + 48LL))(
      v6,
      v13,
      (char *)lpsrc + v7,
      1,
      0);
    if ( HIDWORD(v15[0]) == 1 )
    {
      if ( LODWORD(v15[0]) == 1 )
        return (void *)v14;
      result = 0;
      if ( !LODWORD(v15[1]) && *(_QWORD *)((char *)v15 + 4) == 0x100000001LL )
        return (void *)v14;
    }
    else if ( HIDWORD(v15[0]) )
    {
      return 0;
    }
    else if ( DWORD2(v15[0]) == 1 && DWORD1(v15[0]) == 1 && LODWORD(v15[1]) == 1 )
    {
      return (void *)*((_QWORD *)&v14 + 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (000000000004B16C) ----------------------------------------------------
__int64 __fastcall sub_4B16C(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( *(_QWORD *)(result + 8) == *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL) )
  {
    v4 = *(_QWORD *)(a2 + 32);
    if ( v4 )
    {
      if ( v4 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 60) + 1;
        *(_DWORD *)(a2 + 48) = 2;
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v5;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  return result;
}

//----- (000000000004B1E0) ----------------------------------------------------
__int64 __fastcall sub_4B1E0(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( *(_QWORD *)(result + 8) != *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL) )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(result + 16) + 56LL))(*(_QWORD *)(result + 16));
  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    if ( v4 == a3 )
    {
      if ( *(_DWORD *)(a2 + 48) == 2 )
        *(_DWORD *)(a2 + 48) = a4;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 60) + 1;
      *(_DWORD *)(a2 + 48) = 2;
      *(_BYTE *)(a2 + 78) = 1;
      *(_DWORD *)(a2 + 60) = v5;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a4;
    *(_DWORD *)(a2 + 60) = 1;
  }
  return result;
}

//----- (000000000004B260) ----------------------------------------------------
__int64 __fastcall sub_4B260(__int64 result, __int64 a2, char *a3, __int64 a4)
{
  unsigned int v4; // w20
  __int64 v7; // x22
  unsigned __int64 v8; // x23
  __int64 v9; // x8
  __int64 v10; // x9
  char *v11; // x8
  int v12; // w8
  __int64 v13; // x0
  char *v14; // x2
  unsigned __int64 v15; // x22
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x3
  bool v19; // cf
  unsigned __int64 v20; // x21
  __int64 v21; // x3

  v4 = a4;
  if ( *(_QWORD *)(result + 8) == *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL) )
  {
    v11 = *(char **)(a2 + 32);
    if ( v11 )
    {
      if ( v11 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v12 = *(_DWORD *)(a2 + 60) + 1;
        *(_DWORD *)(a2 + 48) = 2;
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v12;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  else
  {
    v7 = result;
    v8 = result + 16LL * *(unsigned int *)(result + 20) + 24;
    v9 = *(_QWORD *)(result + 32);
    if ( a3 )
    {
      v10 = v9 >> 8;
      if ( (v9 & 1) != 0 )
        v10 = *(_QWORD *)(*(_QWORD *)a3 + v10);
    }
    else
    {
      v10 = 0;
    }
    v13 = *(_QWORD *)(result + 24);
    v14 = &a3[v10];
    if ( (v9 & 2) != 0 )
      a4 = (unsigned int)a4;
    else
      a4 = 2;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v13 + 56LL))(v13, a2, v14, a4);
    if ( v7 + 40 < v8 )
    {
      if ( a3 )
      {
        v15 = v7 + 56;
        do
        {
          v16 = *(_QWORD *)(v15 - 8);
          v17 = v16 >> 8;
          if ( (v16 & 1) != 0 )
            v17 = *(_QWORD *)(*(_QWORD *)a3 + v17);
          if ( (v16 & 2) != 0 )
            v18 = v4;
          else
            v18 = 2;
          result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64))(**(_QWORD **)(v15 - 16) + 56LL))(
                     *(_QWORD *)(v15 - 16),
                     a2,
                     &a3[v17],
                     v18);
          if ( *(_BYTE *)(a2 + 78) )
            break;
          v19 = v15 >= v8;
          v15 += 16LL;
        }
        while ( !v19 );
      }
      else
      {
        v20 = v7 + 56;
        do
        {
          if ( (*(_QWORD *)(v20 - 8) & 2LL) != 0 )
            v21 = v4;
          else
            v21 = 2;
          result = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, __int64))(**(_QWORD **)(v20 - 16) + 56LL))(
                     *(_QWORD *)(v20 - 16),
                     a2,
                     0,
                     v21);
          if ( *(_BYTE *)(a2 + 78) )
            break;
          v19 = v20 >= v8;
          v20 += 16LL;
        }
        while ( !v19 );
      }
    }
  }
  return result;
}

//----- (000000000004B42C) ----------------------------------------------------
_BYTE *__fastcall sub_4B42C(__int64 a1, const char **lpsrc)
{
  _BYTE *result; // x0

  if ( (*(_BYTE *)(a1 + 16) & 0x18) != 0 )
    goto LABEL_2;
  if ( !lpsrc )
    return 0;
  result = __dynamic_cast(
             lpsrc,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
             0);
  if ( result )
  {
    if ( (result[16] & 0x18) == 0 )
      return (_BYTE *)(*(_QWORD *)(a1 + 8) == (_QWORD)lpsrc[1]);
LABEL_2:
    if ( (const char **)a1 == lpsrc )
      return (_BYTE *)(&dword_0 + 1);
    return (_BYTE *)(strcmp(*(const char **)(a1 + 8), lpsrc[1]) == 0);
  }
  return result;
}
// 0: using guessed type int dword_0;
// 6EE70: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 6EEA0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;

//----- (000000000004B4E4) ----------------------------------------------------
__int64 __fastcall sub_4B4E4(__int64 a1, _QWORD *lpsrc, _QWORD **a3)
{
  char *v4; // x22
  int v5; // w23
  _QWORD *v8; // x8
  __int64 result; // x0
  _BYTE *v10; // x0
  _QWORD *v11; // x8
  _QWORD *v12; // x20
  int v13; // w8
  _QWORD *v14; // x22
  _QWORD *v15; // x21
  char *v16; // x8
  void *v17; // x0
  const void *v18; // x1
  __int64 v19; // x19
  __int64 v20; // x29
  __int64 v21; // x22
  _QWORD *v22; // x19
  void *v23; // x22
  int v24; // w8
  _QWORD *v25; // x23
  __int64 v26; // x19
  _QWORD v27[4]; // [xsp+0h] [xbp-50h] BYREF
  __int128 v28; // [xsp+20h] [xbp-30h]
  _DWORD v29[8]; // [xsp+30h] [xbp-20h] BYREF
  __int64 v30; // [xsp+50h] [xbp+0h]
  __int64 v31; // [xsp+58h] [xbp+8h]
  __int64 vars0; // [xsp+70h] [xbp+20h]
  __int64 vars8; // [xsp+78h] [xbp+28h]
  __int64 vars10; // [xsp+80h] [xbp+30h]
  __int64 vars18; // [xsp+88h] [xbp+38h]

  v4 = (char *)lpsrc[1];
  if ( v4 == "Dn" )
  {
    result = 1;
    *a3 = 0;
    return result;
  }
  v5 = *(_DWORD *)(a1 + 16);
  if ( (v5 & 0x18) != 0 )
    goto LABEL_57;
  v10 = __dynamic_cast(
          lpsrc,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
          0);
  if ( !v10 )
    goto LABEL_12;
  if ( (v10[16] & 0x18) != 0 )
  {
LABEL_57:
    if ( (_QWORD *)a1 == lpsrc || !strcmp(*(const char **)(a1 + 8), v4) )
    {
LABEL_5:
      if ( *a3 )
      {
        v8 = (_QWORD *)**a3;
        result = 1;
LABEL_7:
        *a3 = v8;
        return result;
      }
      return 1;
    }
  }
  else if ( *(char **)(a1 + 8) == v4 )
  {
    goto LABEL_5;
  }
LABEL_12:
  result = (__int64)__dynamic_cast(
                      lpsrc,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
                      0);
  if ( !result )
    return result;
  v11 = *a3;
  if ( !*a3 )
  {
    v12 = 0;
    v13 = *(_DWORD *)(result + 16);
    if ( ((unsigned __int8)v13 & (unsigned __int8)~(_BYTE)v5 & 7) == 0 )
      goto LABEL_17;
    return 0;
  }
  v12 = (_QWORD *)*v11;
  *a3 = (_QWORD *)*v11;
  v13 = *(_DWORD *)(result + 16);
  if ( ((unsigned __int8)v13 & (unsigned __int8)~(_BYTE)v5 & 7) != 0 )
    return 0;
LABEL_17:
  if ( ((unsigned __int8)v5 & (unsigned __int8)~(_BYTE)v13 & 0x60) != 0 )
    return 0;
  v14 = *(_QWORD **)(a1 + 24);
  v15 = *(_QWORD **)(result + 24);
  v16 = (char *)v14[1];
  if ( v16 == (char *)v15[1] )
    return 1;
  if ( v16 == "v" )
    return __dynamic_cast(
             *(const void **)(result + 24),
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
             0) == 0;
  v17 = __dynamic_cast(
          v14,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
          0);
  if ( v17 )
  {
    if ( (v5 & 1) == 0 )
      return 0;
    v22 = v15;
    v23 = v17;
    do
    {
      if ( !v22 )
        return 0;
      result = (__int64)__dynamic_cast(
                          v22,
                          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
                          0);
      if ( !result )
        return result;
      v24 = *((_DWORD *)v23 + 4);
      if ( (*(_DWORD *)(result + 16) & ~v24) != 0 )
        return 0;
      v25 = (_QWORD *)*((_QWORD *)v23 + 3);
      v22 = *(_QWORD **)(result + 24);
      if ( v25[1] == v22[1] )
        return 1;
      if ( (v24 & 1) == 0 )
        return 0;
      v23 = __dynamic_cast(
              *((const void **)v23 + 3),
              (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
              (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
              0);
    }
    while ( v23 );
    result = (__int64)__dynamic_cast(
                        v25,
                        (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                        (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                        0);
    if ( !result )
      return result;
    v18 = v22;
    v19 = vars18;
    v20 = v30;
LABEL_47:
    vars0 = v20;
    vars8 = v31;
    vars10 = v19;
    if ( v18 )
    {
      v26 = result;
      result = (__int64)__dynamic_cast(
                          v18,
                          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                          0);
      if ( !result )
        return result;
      if ( (*(_DWORD *)(result + 16) & ~*(_DWORD *)(v26 + 16)) != 0 )
        return 0;
      if ( *(_QWORD *)(*(_QWORD *)(v26 + 24) + 8LL) == *(_QWORD *)(*(_QWORD *)(result + 24) + 8LL) )
        return *(_QWORD *)(*(_QWORD *)(v26 + 32) + 8LL) == *(_QWORD *)(*(_QWORD *)(result + 32) + 8LL);
    }
    return 0;
  }
  result = (__int64)__dynamic_cast(
                      v14,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                      0);
  if ( result )
  {
    if ( (v5 & 1) == 0 )
      return 0;
    v18 = v15;
    v19 = vars18;
    v20 = v30;
    goto LABEL_47;
  }
  result = (__int64)__dynamic_cast(
                      v14,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                      (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                      0);
  if ( result )
  {
    v21 = result;
    result = (__int64)__dynamic_cast(
                        v15,
                        (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                        (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                        0);
    if ( result )
    {
      v27[0] = result;
      v27[1] = 0;
      v27[2] = v21;
      v27[3] = -1;
      v28 = 0u;
      memset(v29, 0, 31);
      v29[6] = 1;
      (*(void (__fastcall **)(__int64, _QWORD *, _QWORD *, __int64))(*(_QWORD *)result + 56LL))(result, v27, v12, 1);
      result = v29[0] == 1;
      if ( v29[0] == 1 )
      {
        if ( *a3 )
        {
          v8 = (_QWORD *)v28;
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}
// 6EE70: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 6EE88: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;
// 6EEA0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 6EEB8: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_type_info;
// 6EED0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 6EEE8: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (000000000004B970) ----------------------------------------------------
_DWORD *__fastcall sub_4B970(__int64 a1, _QWORD *lpsrc, _QWORD *a3)
{
  const char *v4; // x21
  int v5; // w22
  _DWORD *result; // x0
  const void *v9; // x0
  void *v10; // x8
  _BYTE *v11; // x0
  int v12; // w8

  v4 = (const char *)lpsrc[1];
  if ( v4 != "Dn" )
  {
    v5 = *(_DWORD *)(a1 + 16);
    if ( (v5 & 0x18) != 0 )
      goto LABEL_3;
    v11 = __dynamic_cast(
            lpsrc,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
            0);
    if ( v11 )
    {
      if ( (v11[16] & 0x18) != 0 )
      {
LABEL_3:
        if ( (_QWORD *)a1 != lpsrc )
        {
          if ( !strcmp(*(const char **)(a1 + 8), v4) )
            return &dword_0 + 1;
          goto LABEL_12;
        }
        return &dword_0 + 1;
      }
      if ( *(const char **)(a1 + 8) == v4 )
        return &dword_0 + 1;
    }
LABEL_12:
    result = __dynamic_cast(
               lpsrc,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
               0);
    if ( result )
    {
      v12 = result[4];
      if ( ((unsigned __int8)v12 & (unsigned __int8)~(_BYTE)v5 & 7) != 0
        || ((unsigned __int8)v5 & (unsigned __int8)~(_BYTE)v12 & 0x60) != 0
        || *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) != *(_QWORD *)(*((_QWORD *)result + 3) + 8LL) )
      {
        return 0;
      }
      else
      {
        return (_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL) == *(_QWORD *)(*((_QWORD *)result + 4) + 8LL));
      }
    }
    return result;
  }
  v9 = *(const void **)(a1 + 24);
  if ( v9
    && __dynamic_cast(
         v9,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
         0) )
  {
    v10 = &unk_22620;
  }
  else
  {
    v10 = &unk_22630;
  }
  result = &dword_0 + 1;
  *a3 = v10;
  return result;
}
// 0: using guessed type int dword_0;
// 6EE70: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 6EEA0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 6EED0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 6EEE8: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (000000000004BB20) ----------------------------------------------------
__int64 __fastcall sub_4BB20(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5)
{
  __int64 v9; // x23
  __int64 v10; // x8
  const char *v11; // x24
  int v12; // w8
  __int64 v13; // x8
  _QWORD *v14; // x25
  char v15; // w22
  char v16; // w24
  unsigned __int64 v17; // x26
  __int64 v18; // x9
  __int64 v19; // x8
  unsigned __int64 v20; // x24
  __int64 v21; // x9
  __int64 v22; // x3
  __int64 *v23; // x25
  int v24; // w8
  __int64 v25; // x0
  __int64 v26; // t1
  __int64 v27; // x3
  __int64 v28; // x8
  __int64 v29; // x9
  __int64 v30; // x8
  __int64 v31; // x9
  __int64 v32; // x4
  __int64 v33; // x0
  __int64 v34; // t1
  __int64 v35; // x3
  __int64 v36; // x8
  __int64 v37; // x9
  __int64 v38; // x0
  __int64 v39; // t1
  __int64 v40; // x3
  __int64 v41; // x8
  __int64 v42; // x9
  int v43; // w8
  int v44; // w8
  int v45; // w9

  v9 = result;
  v10 = *(_QWORD *)(a2 + 16);
  if ( (a5 & 1) != 0 )
  {
    if ( v10 != result )
    {
      v11 = *(const char **)(result + 8);
      result = strcmp(v11, *(const char **)(v10 + 8));
      if ( (_DWORD)result )
      {
        if ( *(_QWORD *)a2 == v9 )
          goto LABEL_6;
        result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
        if ( !(_DWORD)result )
          goto LABEL_6;
LABEL_13:
        v19 = *(_QWORD *)(v9 + 32);
        v20 = v9 + 16LL * *(unsigned int *)(v9 + 20) + 24;
        v21 = v19 >> 8;
        if ( (v19 & 1) != 0 )
          v21 = *(_QWORD *)(*(_QWORD *)a3 + v21);
        if ( (v19 & 2) != 0 )
          v22 = a4;
        else
          v22 = 2;
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v9 + 24) + 48LL))(
                   *(_QWORD *)(v9 + 24),
                   a2,
                   &a3[v21],
                   v22,
                   a5 & 1);
        v23 = (__int64 *)(v9 + 40);
        if ( v9 + 40 < v20 )
        {
          v24 = *(_DWORD *)(v9 + 16);
          if ( (v24 & 2) != 0 || *(_DWORD *)(a2 + 60) == 1 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) )
                break;
              v28 = v23[1];
              v29 = v28 >> 8;
              if ( (v28 & 1) != 0 )
                v29 = *(_QWORD *)(*(_QWORD *)a3 + v29);
              v26 = *v23;
              v23 += 2;
              v25 = v26;
              v27 = (v28 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v25 + 48LL))(
                         v25,
                         a2,
                         &a3[v29],
                         v27,
                         a5 & 1);
            }
            while ( (unsigned __int64)v23 < v20 );
          }
          else if ( (v24 & 1) != 0 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 && *(_DWORD *)(a2 + 48) == 1 )
                break;
              v36 = v23[1];
              v37 = v36 >> 8;
              if ( (v36 & 1) != 0 )
                v37 = *(_QWORD *)(*(_QWORD *)a3 + v37);
              v34 = *v23;
              v23 += 2;
              v33 = v34;
              v35 = (v36 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v33 + 48LL))(
                         v33,
                         a2,
                         &a3[v37],
                         v35,
                         a5 & 1);
            }
            while ( (unsigned __int64)v23 < v20 );
          }
          else
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 )
                break;
              v41 = v23[1];
              v42 = v41 >> 8;
              if ( (v41 & 1) != 0 )
                v42 = *(_QWORD *)(*(_QWORD *)a3 + v42);
              v39 = *v23;
              v23 += 2;
              v38 = v39;
              v40 = (v41 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v38 + 48LL))(
                         v38,
                         a2,
                         &a3[v42],
                         v40,
                         a5 & 1);
            }
            while ( (unsigned __int64)v23 < v20 );
          }
        }
        return result;
      }
    }
LABEL_29:
    if ( *(char **)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  v18 = *(_QWORD *)(result + 8);
  if ( v18 == *(_QWORD *)(v10 + 8) )
    goto LABEL_29;
  if ( v18 != *(_QWORD *)(*(_QWORD *)a2 + 8LL) )
    goto LABEL_13;
LABEL_6:
  if ( *(char **)(a2 + 32) == a3 || *(char **)(a2 + 40) == a3 )
  {
    if ( a4 == 1 )
      *(_DWORD *)(a2 + 56) = 1;
    return result;
  }
  v12 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = a4;
  if ( v12 == 4 )
    goto LABEL_74;
  v13 = *(unsigned int *)(v9 + 20);
  if ( !(_DWORD)v13 )
  {
    *(_DWORD *)(a2 + 68) = 4;
    goto LABEL_74;
  }
  v14 = (_QWORD *)(v9 + 24);
  v15 = 0;
  v16 = 0;
  v17 = v9 + 24 + 16 * v13;
  while ( 1 )
  {
    *(_WORD *)(a2 + 76) = 0;
    v30 = v14[1];
    v31 = v30 >> 8;
    if ( (v30 & 1) != 0 )
      v31 = *(_QWORD *)(*(_QWORD *)a3 + v31);
    if ( (v30 & 2) != 0 )
      v32 = 1;
    else
      v32 = 2;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, char *, __int64, _QWORD))(*(_QWORD *)*v14 + 40LL))(
               *v14,
               a2,
               a3,
               &a3[v31],
               v32,
               a5 & 1);
    if ( *(_BYTE *)(a2 + 78) )
    {
LABEL_67:
      if ( (v16 & 1) == 0 )
      {
        v43 = 4;
        goto LABEL_73;
      }
LABEL_68:
      v16 = v15;
      goto LABEL_72;
    }
    if ( *(_BYTE *)(a2 + 77) )
      break;
LABEL_32:
    v14 += 2;
    if ( (unsigned __int64)v14 >= v17 )
      goto LABEL_67;
  }
  if ( !*(_BYTE *)(a2 + 76) )
  {
    if ( (*(_BYTE *)(v9 + 16) & 1) == 0 )
      goto LABEL_68;
    v16 = 1;
    goto LABEL_32;
  }
  if ( *(_DWORD *)(a2 + 48) != 1 )
  {
    v16 = 1;
    v15 = 1;
    if ( (*(_BYTE *)(v9 + 16) & 2) == 0 )
      goto LABEL_72;
    goto LABEL_32;
  }
  v16 = 1;
LABEL_72:
  v43 = 3;
  v15 = v16;
LABEL_73:
  *(_DWORD *)(a2 + 68) = v43;
  if ( (v15 & 1) == 0 )
  {
LABEL_74:
    v45 = *(_DWORD *)(a2 + 60);
    v44 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v44 + 1;
    if ( v45 == 1 && *(_DWORD *)(a2 + 48) == 2 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (000000000004BEC8) ----------------------------------------------------
__int64 __fastcall sub_4BEC8(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v9; // x23
  __int64 v10; // x8
  const char *v11; // x24
  int v12; // w8
  int v13; // w8
  __int64 v14; // x9
  int v15; // w8
  int v16; // w9

  v9 = result;
  v10 = *(_QWORD *)(a2 + 16);
  if ( (a5 & 1) == 0 )
  {
    v14 = *(_QWORD *)(result + 8);
    if ( v14 != *(_QWORD *)(v10 + 8) )
    {
      if ( v14 == *(_QWORD *)(*(_QWORD *)a2 + 8LL) )
        goto LABEL_6;
      return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v9 + 16) + 48LL))(
               *(_QWORD *)(v9 + 16),
               a2,
               a3,
               a4,
               a5 & 1);
    }
LABEL_15:
    if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  if ( v10 == result )
    goto LABEL_15;
  v11 = *(const char **)(result + 8);
  result = strcmp(v11, *(const char **)(v10 + 8));
  if ( !(_DWORD)result )
    goto LABEL_15;
  if ( *(_QWORD *)a2 != v9 )
  {
    result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
    if ( (_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v9 + 16) + 48LL))(
               *(_QWORD *)(v9 + 16),
               a2,
               a3,
               a4,
               a5 & 1);
  }
LABEL_6:
  if ( *(_QWORD *)(a2 + 32) == a3 || *(_QWORD *)(a2 + 40) == a3 )
  {
    if ( a4 == 1 )
      *(_DWORD *)(a2 + 56) = 1;
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 68);
    *(_DWORD *)(a2 + 56) = a4;
    if ( v12 != 4 )
    {
      *(_WORD *)(a2 + 76) = 0;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, __int64, _QWORD))(**(_QWORD **)(v9 + 16)
                                                                                             + 40LL))(
                 *(_QWORD *)(v9 + 16),
                 a2,
                 a3,
                 a3,
                 1,
                 a5 & 1);
      if ( *(_BYTE *)(a2 + 77) )
      {
        v13 = *(unsigned __int8 *)(a2 + 76);
        *(_DWORD *)(a2 + 68) = 3;
        if ( v13 )
          return result;
      }
      else
      {
        *(_DWORD *)(a2 + 68) = 4;
      }
    }
    v16 = *(_DWORD *)(a2 + 60);
    v15 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v15 + 1;
    if ( v16 == 1 && *(_DWORD *)(a2 + 48) == 2 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (000000000004C0B4) ----------------------------------------------------
__int64 __fastcall sub_4C0B4(__int64 result, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 v8; // x22
  __int64 v9; // x8
  const char *v10; // x23
  __int64 v11; // x9
  int v12; // w8
  int v13; // w9

  v8 = result;
  v9 = *(_QWORD *)(a2 + 16);
  if ( (a5 & 1) != 0 )
  {
    if ( v9 != result )
    {
      v10 = *(const char **)(result + 8);
      result = strcmp(v10, *(const char **)(v9 + 8));
      if ( (_DWORD)result )
      {
        if ( *(_QWORD *)a2 != v8 )
        {
          result = strcmp(v10, *(const char **)(*(_QWORD *)a2 + 8LL));
          if ( (_DWORD)result )
            return result;
        }
        goto LABEL_9;
      }
    }
  }
  else
  {
    v11 = *(_QWORD *)(result + 8);
    if ( v11 != *(_QWORD *)(v9 + 8) )
    {
      if ( v11 != *(_QWORD *)(*(_QWORD *)a2 + 8LL) )
        return result;
LABEL_9:
      if ( *(_QWORD *)(a2 + 32) == a3 || *(_QWORD *)(a2 + 40) == a3 )
      {
        if ( a4 == 1 )
          *(_DWORD *)(a2 + 56) = 1;
      }
      else
      {
        v13 = *(_DWORD *)(a2 + 60);
        v12 = *(_DWORD *)(a2 + 64);
        *(_DWORD *)(a2 + 56) = a4;
        *(_QWORD *)(a2 + 40) = a3;
        *(_DWORD *)(a2 + 64) = v12 + 1;
        if ( v13 == 1 && *(_DWORD *)(a2 + 48) == 2 )
          *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 68) = 4;
      }
      return result;
    }
  }
  if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
    *(_DWORD *)(a2 + 52) = a4;
  return result;
}

//----- (000000000004C218) ----------------------------------------------------
__int64 __fastcall sub_4C218(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6)
{
  __int64 v11; // x24
  __int64 v12; // x8
  char *v13; // x9
  __int64 v14; // x9
  int v15; // w26
  int v16; // w28
  __int64 v17; // x9
  __int64 v18; // x8
  unsigned __int64 v19; // x25
  __int64 v20; // x9
  __int64 v21; // x4
  int v22; // w8
  int v23; // w9
  int v24; // w27
  int v25; // w26
  __int64 *v26; // x28
  __int64 v27; // x0
  __int64 v28; // t1
  __int64 v29; // x4
  __int64 v30; // x8
  __int64 v31; // x9
  unsigned int v32; // w8

  v11 = result;
  v12 = *(_QWORD *)(a2 + 16);
  if ( (a6 & 1) != 0 )
  {
    if ( v12 == result )
      goto LABEL_4;
    result = strcmp(*(const char **)(result + 8), *(const char **)(v12 + 8));
    if ( !(_DWORD)result )
      goto LABEL_4;
LABEL_9:
    v15 = *(unsigned __int8 *)(a2 + 76);
    v16 = *(unsigned __int8 *)(a2 + 77);
    v17 = *(unsigned int *)(v11 + 20);
    *(_WORD *)(a2 + 76) = 0;
    v18 = *(_QWORD *)(v11 + 32);
    v19 = v11 + 16 * v17 + 24;
    v20 = v18 >> 8;
    if ( (v18 & 1) != 0 )
      v20 = *(_QWORD *)(*(_QWORD *)a4 + v20);
    if ( (v18 & 2) != 0 )
      v21 = a5;
    else
      v21 = 2;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v11 + 24)
                                                                                          + 40LL))(
               *(_QWORD *)(v11 + 24),
               a2,
               a3,
               &a4[v20],
               v21,
               a6 & 1);
    v22 = *(unsigned __int8 *)(a2 + 76);
    v23 = *(unsigned __int8 *)(a2 + 77);
    v24 = v22 | v15;
    v25 = v23 | v16;
    v26 = (__int64 *)(v11 + 40);
    while ( (unsigned __int64)v26 < v19 )
    {
      v25 &= 1u;
      v24 &= 1u;
      if ( *(_BYTE *)(a2 + 78) )
        break;
      if ( v22 )
      {
        if ( *(_DWORD *)(a2 + 48) == 1 || (*(_BYTE *)(v11 + 16) & 2) == 0 )
          break;
      }
      else if ( v23 && (*(_BYTE *)(v11 + 16) & 1) == 0 )
      {
        break;
      }
      *(_WORD *)(a2 + 76) = 0;
      v30 = v26[1];
      v31 = v30 >> 8;
      if ( (v30 & 1) != 0 )
        v31 = *(_QWORD *)(*(_QWORD *)a4 + v31);
      v28 = *v26;
      v26 += 2;
      v27 = v28;
      if ( (v30 & 2) != 0 )
        v29 = a5;
      else
        v29 = 2;
      result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v27 + 40LL))(
                 v27,
                 a2,
                 a3,
                 &a4[v31],
                 v29,
                 a6 & 1);
      v22 = *(unsigned __int8 *)(a2 + 76);
      v23 = *(unsigned __int8 *)(a2 + 77);
      v24 |= v22;
      v25 |= v23;
    }
    *(_BYTE *)(a2 + 76) = v24 != 0;
    *(_BYTE *)(a2 + 77) = v25 != 0;
    return result;
  }
  if ( *(_QWORD *)(result + 8) != *(_QWORD *)(v12 + 8) )
    goto LABEL_9;
LABEL_4:
  v13 = *(char **)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v13 != a4 )
    return result;
  v14 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v14 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    v32 = *(_DWORD *)(a2 + 72);
    goto LABEL_35;
  }
  if ( v14 != a3 )
  {
    ++*(_DWORD *)(a2 + 60);
LABEL_36:
    *(_BYTE *)(a2 + 78) = 1;
    return result;
  }
  v32 = *(_DWORD *)(a2 + 48);
  if ( v32 == 2 )
  {
    v32 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( *(_DWORD *)(a2 + 72) == 1 )
  {
LABEL_35:
    if ( v32 != 1 )
      return result;
    goto LABEL_36;
  }
  return result;
}

//----- (000000000004C448) ----------------------------------------------------
__int64 __fastcall sub_4C448(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  __int64 v11; // x24
  __int64 v12; // x8
  __int64 v13; // x9
  __int64 v14; // x9
  unsigned int v15; // w8

  v11 = result;
  v12 = *(_QWORD *)(a2 + 16);
  if ( (a6 & 1) == 0 )
  {
    if ( *(_QWORD *)(result + 8) == *(_QWORD *)(v12 + 8) )
      goto LABEL_4;
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v11 + 16) + 40LL))(
             *(_QWORD *)(v11 + 16),
             a2,
             a3,
             a4,
             a5,
             a6 & 1);
  }
  if ( v12 != result )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v12 + 8));
    if ( (_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v11 + 16)
                                                                                          + 40LL))(
               *(_QWORD *)(v11 + 16),
               a2,
               a3,
               a4,
               a5,
               a6 & 1);
  }
LABEL_4:
  v13 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v13 != a4 )
    return result;
  v14 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v14 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    v15 = *(_DWORD *)(a2 + 72);
    goto LABEL_16;
  }
  if ( v14 != a3 )
  {
    ++*(_DWORD *)(a2 + 60);
LABEL_17:
    *(_BYTE *)(a2 + 78) = 1;
    return result;
  }
  v15 = *(_DWORD *)(a2 + 48);
  if ( v15 == 2 )
  {
    v15 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( *(_DWORD *)(a2 + 72) == 1 )
  {
LABEL_16:
    if ( v15 == 1 )
      goto LABEL_17;
  }
  return result;
}

//----- (000000000004C594) ----------------------------------------------------
__int64 __fastcall sub_4C594(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v10; // x8
  __int64 v11; // x9
  __int64 v12; // x9
  int v13; // w8

  v10 = *(_QWORD *)(a2 + 16);
  if ( (a6 & 1) != 0 )
  {
    if ( v10 != result )
    {
      result = strcmp(*(const char **)(result + 8), *(const char **)(v10 + 8));
      if ( (_DWORD)result )
        return result;
    }
  }
  else if ( *(_QWORD *)(result + 8) != *(_QWORD *)(v10 + 8) )
  {
    return result;
  }
  v11 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v11 != a4 )
    return result;
  v12 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v12 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    v13 = *(_DWORD *)(a2 + 72);
    goto LABEL_15;
  }
  if ( v12 != a3 )
  {
    ++*(_DWORD *)(a2 + 60);
    goto LABEL_16;
  }
  v13 = *(_DWORD *)(a2 + 48);
  if ( v13 == 2 )
  {
    v13 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( *(_DWORD *)(a2 + 72) == 1 )
  {
LABEL_15:
    if ( v13 != 1 )
      return result;
LABEL_16:
    *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (000000000004C694) ----------------------------------------------------
void __fastcall std::type_info::~type_info(std::type_info *this)
{
  ;
}

//----- (000000000004C69C) ----------------------------------------------------
void __fastcall std::type_info::~type_info(std::type_info *this)
{
  std::type_info::~type_info(this);
  operator delete(this);
}

//----- (000000000004C6C8) ----------------------------------------------------
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *this)
{
  *this = off_6FA08;
  return this;
}
// 6FA08: using guessed type void (__fastcall *[2])(std::bad_cast *__hidden this);

//----- (000000000004C6E0) ----------------------------------------------------
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  std::exception::~exception(this);
}

//----- (000000000004C6E8) ----------------------------------------------------
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  std::bad_cast::~bad_cast(this);
  operator delete(this);
}

//----- (000000000004C714) ----------------------------------------------------
const char *__fastcall std::bad_cast::what(std::bad_cast *this)
{
  return "std::bad_cast";
}

//----- (000000000004C724) ----------------------------------------------------
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *this)
{
  *this = off_6FA30;
  return this;
}
// 6FA30: using guessed type void (__fastcall *[2])(std::bad_typeid *__hidden this);

//----- (000000000004C73C) ----------------------------------------------------
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  std::exception::~exception(this);
}

//----- (000000000004C744) ----------------------------------------------------
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  std::bad_typeid::~bad_typeid(this);
  operator delete(this);
}

//----- (000000000004C770) ----------------------------------------------------
const char *__fastcall std::bad_typeid::what(std::bad_typeid *this)
{
  return "std::bad_typeid";
}

//----- (000000000004C780) ----------------------------------------------------
void __noreturn _cxa_pure_virtual(void)
{
  sub_4AC40("Pure virtual function called!");
}

//----- (000000000004C798) ----------------------------------------------------
void __noreturn _cxa_deleted_virtual(void)
{
  sub_4AC40("Deleted virtual function called!");
}

//----- (000000000004C7B0) ----------------------------------------------------
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  char *v8; // x20
  size_t v9; // x0
  size_t v10; // x1
  unsigned __int64 v11; // x23
  __int64 v12; // x26
  __int64 v13; // x26
  unsigned __int8 *v14; // x0
  int v15; // w8
  _OWORD *i; // x0
  _OWORD *v17; // x8
  unsigned __int8 *v19; // x22
  unsigned __int8 *v20; // x12
  const char *v21; // x23
  _QWORD *v22; // x26
  __int64 v23; // x8
  _QWORD *v24; // x0
  __int64 v25; // x8
  unsigned __int8 **v26; // x9
  const char *v27; // x22
  unsigned __int8 *v28; // x23
  unsigned __int8 *v29; // x8
  int v30; // w9
  unsigned __int8 *v31; // x11
  unsigned __int8 *v32; // x10
  size_t v33; // x8
  size_t v34; // x8
  size_t v35; // x9
  size_t v36; // x1
  _BYTE *v37; // x0
  unsigned __int8 *v38; // [xsp+0h] [xbp-1390h]
  void *v39; // [xsp+18h] [xbp-1378h] BYREF
  size_t v40; // [xsp+20h] [xbp-1370h]
  unsigned __int64 v41; // [xsp+28h] [xbp-1368h]
  __int64 v42; // [xsp+30h] [xbp-1360h]
  int v43; // [xsp+38h] [xbp-1358h]
  const char *v44; // [xsp+40h] [xbp-1350h] BYREF
  unsigned __int8 *v45; // [xsp+48h] [xbp-1348h]
  void *v46; // [xsp+50h] [xbp-1340h]
  _OWORD *v47; // [xsp+58h] [xbp-1338h]
  void **v48; // [xsp+60h] [xbp-1330h]
  _OWORD v49[16]; // [xsp+68h] [xbp-1328h] BYREF
  void *v50[3]; // [xsp+168h] [xbp-1228h] BYREF
  _BYTE v51[256]; // [xsp+180h] [xbp-1210h] BYREF
  void *v52[3]; // [xsp+280h] [xbp-1110h] BYREF
  _BYTE v53[64]; // [xsp+298h] [xbp-10F8h] BYREF
  void *v54[3]; // [xsp+2D8h] [xbp-10B8h] BYREF
  _BYTE v55[32]; // [xsp+2F0h] [xbp-10A0h] BYREF
  void *ptr; // [xsp+310h] [xbp-1080h] BYREF
  _BYTE *v57; // [xsp+318h] [xbp-1078h]
  __int16 *v58; // [xsp+320h] [xbp-1070h]
  _BYTE v59[32]; // [xsp+328h] [xbp-1068h] BYREF
  __int16 v60; // [xsp+348h] [xbp-1048h] BYREF
  __int64 v61; // [xsp+350h] [xbp-1040h]
  __int64 v62; // [xsp+358h] [xbp-1038h]
  int v63; // [xsp+360h] [xbp-1030h]
  _OWORD v64[256]; // [xsp+370h] [xbp-1020h] BYREF
  _OWORD *v65; // [xsp+1370h] [xbp-20h]

  if ( !lpmangled || lpout && !lpoutlen )
  {
    v8 = 0;
    if ( lpstatus )
      *lpstatus = -3;
    return v8;
  }
  v9 = strlen(lpmangled);
  v44 = lpmangled;
  v45 = (unsigned __int8 *)&lpmangled[v9];
  v48 = v50;
  v52[2] = v54;
  v46 = v49;
  v47 = v49;
  v50[0] = v51;
  v50[1] = v51;
  v58 = &v60;
  v50[2] = v52;
  memset(v53, 0, sizeof(v53));
  memset(v49, 0, sizeof(v49));
  v54[2] = &ptr;
  memset(v59, 0, sizeof(v59));
  memset(v51, 0, sizeof(v51));
  v52[0] = v53;
  v52[1] = v53;
  v54[0] = v55;
  v54[1] = v55;
  memset(v55, 0, sizeof(v55));
  ptr = v59;
  v57 = v59;
  v60 = 1;
  v61 = -1;
  v63 = 0;
  v62 = 0;
  v64[0] = 0u;
  v65 = v64;
  if ( v9 < 2 )
    goto LABEL_14;
  v11 = v9;
  v12 = 2;
  if ( strncmp("_Z", lpmangled, 2u) )
  {
    if ( v11 < 3 )
      goto LABEL_14;
    v12 = 3;
    if ( strncmp("__Z", lpmangled, 3u) )
    {
      if ( v11 >= 4 )
      {
        v13 = 4;
        if ( !strncmp("___Z", lpmangled, 4u) || v11 >= 5 && (v13 = 5, !strncmp("____Z", lpmangled, 5u)) )
        {
          v44 = &lpmangled[v13];
          v39 = sub_4CEF0((unsigned __int8 **)&v44, v10);
          if ( !v39 )
            goto LABEL_15;
          v27 = v44;
          v28 = v45;
          if ( (unsigned __int64)(v45 - (unsigned __int8 *)v44) < 0xD || strncmp("_block_invoke", v44, 0xDu) )
            goto LABEL_15;
          v29 = (unsigned __int8 *)(v27 + 13);
          v44 = v27 + 13;
          if ( v27 + 13 != (const char *)v28 )
          {
            v30 = *v29;
            if ( v30 == 95 )
            {
              v29 = (unsigned __int8 *)(v27 + 14);
              v44 = v27 + 14;
            }
            if ( v28 == v29 )
            {
              v29 = 0;
              v31 = 0;
              v32 = v28;
            }
            else if ( (unsigned int)*v29 - 58 >= 0xFFFFFFF6 )
            {
              v32 = v29;
              while ( (unsigned int)*v32 - 58 >= 0xFFFFFFF6 )
              {
                v44 = (const char *)++v32;
                if ( v32 == v28 )
                {
                  v32 = v28;
                  v31 = v28;
                  goto LABEL_56;
                }
              }
              v31 = v32;
            }
            else
            {
              v31 = 0;
              v32 = v29;
              v29 = 0;
            }
LABEL_56:
            if ( v30 == 95 && v29 == v31 )
              goto LABEL_15;
            if ( v28 != v32 )
            {
              if ( *v32 != 46 )
                goto LABEL_15;
              v44 = (const char *)v28;
            }
          }
          v14 = (unsigned __int8 *)sub_4DA08((__int64)&v44, "invocation function for block in ", (__int64 *)&v39);
          goto LABEL_62;
        }
      }
LABEL_14:
      v14 = (unsigned __int8 *)sub_4DAC4((__int64)&v44, v10);
      if ( v45 != (unsigned __int8 *)v44 )
        goto LABEL_15;
LABEL_62:
      v19 = v14;
      if ( v14 )
        goto LABEL_63;
      goto LABEL_15;
    }
  }
  v44 = &lpmangled[v12];
  v19 = sub_4CEF0((unsigned __int8 **)&v44, v10);
  if ( v19 )
  {
    v21 = v44;
    v20 = v45;
    if ( v45 == (unsigned __int8 *)v44 )
      goto LABEL_63;
    if ( *v44 == 46 )
    {
      v22 = v65;
      v23 = *((_QWORD *)v65 + 1);
      if ( (unsigned __int64)(v23 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v38 = v45;
        v24 = malloc(0x1000u);
        if ( !v24 )
          goto LABEL_81;
        v23 = 0;
        *v24 = v22;
        v24[1] = 0;
        v22 = v24;
        v20 = v38;
        v65 = v24;
      }
      v25 = v23 + 48;
      v26 = (unsigned __int8 **)((char *)v22 + v25);
      v22[1] = v25;
      LOWORD(v25) = *(_WORD *)((char *)v22 + v25 - 23);
      *(v26 - 2) = v19;
      *(v26 - 1) = (unsigned __int8 *)v21;
      *((_BYTE *)v26 - 24) = 1;
      *v26 = v20;
      *(_WORD *)((char *)v26 - 23) = v25 & 0xF000 | 0x540;
      *(v26 - 4) = (unsigned __int8 *)off_719C8;
      v19 = (unsigned __int8 *)(v26 - 4);
      v44 = (const char *)v45;
LABEL_63:
      if ( lpout )
        v33 = *lpoutlen;
      else
        v33 = 0;
      v39 = lpout;
      v40 = 0;
      v41 = v33;
      v42 = -1;
      v43 = 1;
      if ( ptr == v57 )
      {
        (*(void (__fastcall **)(unsigned __int8 *, void **))(*(_QWORD *)v19 + 32LL))(v19, &v39);
        if ( (*(_WORD *)(v19 + 9) & 0xC0) != 0x40 )
          (*(void (__fastcall **)(unsigned __int8 *, void **))(*(_QWORD *)v19 + 40LL))(v19, &v39);
        v34 = v40;
        v35 = v40 + 1;
        if ( v40 + 1 <= v41 )
        {
          v37 = v39;
LABEL_76:
          v40 = v35;
          v37[v34] = 0;
          if ( lpoutlen )
            *lpoutlen = v40;
          v15 = 0;
          v8 = (char *)v39;
          if ( !lpstatus )
            goto LABEL_17;
          goto LABEL_16;
        }
        if ( 2 * v41 <= v40 + 993 )
          v36 = v40 + 993;
        else
          v36 = 2 * v41;
        v41 = v36;
        v37 = realloc(v39, v36);
        v39 = v37;
        if ( v37 )
        {
          v34 = v40;
          v35 = v40 + 1;
          goto LABEL_76;
        }
      }
      else
      {
        __assert2(
          "out/llvm-project/libcxxabi/src/cxa_demangle.cpp",
          395,
          "char *__cxxabiv1::__cxa_demangle(const char *, char *, size_t *, int *)",
          "Parser.ForwardTemplateRefs.empty()");
      }
LABEL_81:
      std::terminate();
    }
  }
LABEL_15:
  v8 = 0;
  v15 = -2;
  if ( lpstatus )
LABEL_16:
    *lpstatus = v15;
LABEL_17:
  for ( i = v65; v65; i = v65 )
  {
    while ( 1 )
    {
      v17 = *(_OWORD **)i;
      v65 = *(_OWORD **)i;
      if ( i != v64 )
        break;
      i = v17;
      if ( !v17 )
        goto LABEL_22;
    }
    free(i);
  }
LABEL_22:
  v64[0] = 0u;
  v65 = v64;
  if ( ptr != v59 )
    free(ptr);
  if ( v54[0] != v55 )
    free(v54[0]);
  if ( v52[0] != v53 )
    free(v52[0]);
  if ( v50[0] != v51 )
    free(v50[0]);
  if ( v46 != v49 )
    free(v46);
  return v8;
}
// 4C9C4: variable 'v10' is possibly undefined
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 719C8: using guessed type __int64 (__fastcall *off_719C8[10])();

//----- (000000000004CD90) ----------------------------------------------------
void __fastcall sub_4CD90(_QWORD *a1)
{
  _QWORD *v2; // x0
  _QWORD *v3; // x20
  _QWORD *v4; // x8
  _QWORD *v5; // x0
  _QWORD *v6; // x0
  _QWORD *v7; // x0
  _QWORD *v8; // x0
  _QWORD *v9; // x0

  v2 = (_QWORD *)a1[614];
  v3 = a1 + 102;
  if ( v2 )
  {
    do
    {
      while ( 1 )
      {
        v4 = (_QWORD *)*v2;
        a1[614] = *v2;
        if ( v2 == v3 )
          break;
        free(v2);
        v2 = (_QWORD *)a1[614];
        if ( !v2 )
          goto LABEL_6;
      }
      v2 = v4;
    }
    while ( v4 );
  }
LABEL_6:
  v5 = (_QWORD *)a1[90];
  *v3 = 0;
  a1[103] = 0;
  a1[614] = v3;
  if ( v5 != a1 + 93 )
    free(v5);
  v6 = (_QWORD *)a1[83];
  if ( v6 != a1 + 86 )
    free(v6);
  v7 = (_QWORD *)a1[72];
  if ( v7 != a1 + 75 )
    free(v7);
  v8 = (_QWORD *)a1[37];
  if ( v8 != a1 + 40 )
    free(v8);
  v9 = (_QWORD *)a1[2];
  if ( v9 != a1 + 5 )
    free(v9);
}

//----- (000000000004CE60) ----------------------------------------------------
__int64 __fastcall sub_4CE60(__int64 a1, char *s1, __int64 a3)
{
  const char *v3; // x21
  size_t v4; // x20
  __int64 result; // x0

  v3 = *(const char **)a1;
  v4 = a3 - (_QWORD)s1;
  if ( (unsigned __int64)(a3 - (_QWORD)s1) > *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 )
    return 0;
  if ( strncmp(s1, v3, v4) )
    return 0;
  result = 1;
  *(_QWORD *)a1 = &v3[v4];
  return result;
}

//----- (000000000004CEF0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_4CEF0(unsigned __int8 **a1, size_t a2)
{
  unsigned __int8 **v2; // x21
  unsigned __int8 *v4; // x8
  __int128 v5; // q0
  unsigned __int8 *v6; // x0
  unsigned __int8 **v7; // x22
  unsigned __int8 *v8; // x8
  unsigned __int8 *v9; // x9
  __int128 v10; // q0
  unsigned __int8 *v11; // x8
  unsigned __int8 *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int8 *v14; // x8
  signed __int64 v15; // x23
  unsigned __int8 **v16; // x23
  size_t v17; // x21
  _BYTE *v18; // x8
  unsigned __int8 *v19; // x21
  unsigned __int8 *v20; // x0
  __int128 v21; // q0
  int v22; // w11
  unsigned __int8 *v27; // x0
  unsigned __int8 *v28; // x8
  unsigned __int8 *v29; // x9
  size_t v30; // x1
  unsigned __int8 *v31; // x20
  unsigned __int8 *v32; // x9
  unsigned __int64 v33; // x10
  unsigned __int64 v34; // x8
  unsigned __int8 *v35; // x11
  __int64 *v36; // x15
  unsigned __int8 *v37; // x12
  __int64 v38; // x14
  __int64 v39; // x13
  unsigned __int64 v40; // x16
  unsigned __int64 v41; // x17
  unsigned __int64 v42; // x15
  __int64 *v43; // x16
  __int64 v44; // x17
  __int64 v45; // x0
  int v46; // w9
  _QWORD *v47; // x21
  unsigned __int8 *v48; // x20
  __int64 v49; // x8
  unsigned __int8 *v50; // x0
  __int64 v51; // x8
  unsigned __int8 *v52; // x9
  __int16 v53; // w8
  const char *v54; // x11
  char *v55; // x10
  const char *v56; // x21
  unsigned __int8 *v57; // x22
  unsigned __int64 v58; // x8
  unsigned int v59; // w9
  unsigned __int8 *v60; // x8
  unsigned __int8 *v61; // x8
  _BOOL4 v62; // w20
  unsigned __int8 *v63; // x8
  unsigned __int8 *v64; // x9
  unsigned int v65; // w10
  int v66; // w10
  unsigned int v67; // w10
  unsigned __int8 *v68; // x20
  __int64 v69; // x8
  unsigned __int8 *v70; // x0
  __int64 v71; // x8
  unsigned __int64 v72; // x22
  unsigned __int8 **v73; // x24
  unsigned __int8 *v74; // x8
  unsigned __int8 **v75; // x0
  signed __int64 v76; // x25
  unsigned __int8 *v77; // x26
  unsigned __int8 *v78; // x0
  unsigned int v79; // w8
  __int64 v80; // x1
  unsigned __int8 *v81; // x0
  size_t v82; // x1
  unsigned __int8 *v83; // x8
  unsigned __int8 *v84; // x9
  unsigned __int8 *v85; // x10
  unsigned __int8 *v86; // x8
  unsigned __int64 v87; // x20
  unsigned __int8 *v88; // x24
  unsigned __int8 *v89; // x8
  char *v90; // x22
  unsigned __int8 **v91; // x0
  signed __int64 v92; // x23
  unsigned __int8 *v93; // x0
  __int64 v95; // x1
  unsigned __int8 **v96; // [xsp+0h] [xbp-E0h] BYREF
  __int128 v97; // [xsp+8h] [xbp-D8h] BYREF
  _OWORD *v98; // [xsp+18h] [xbp-C8h] BYREF
  unsigned __int8 *v99; // [xsp+20h] [xbp-C0h] BYREF
  _QWORD *v100; // [xsp+28h] [xbp-B8h] BYREF
  char v101[8]; // [xsp+30h] [xbp-B0h] BYREF
  unsigned __int64 v102; // [xsp+38h] [xbp-A8h]
  unsigned __int8 **v103; // [xsp+40h] [xbp-A0h] BYREF
  unsigned __int8 **v104; // [xsp+48h] [xbp-98h]
  __int128 v105; // [xsp+50h] [xbp-90h]
  _OWORD v106[2]; // [xsp+60h] [xbp-80h] BYREF
  void *ptr; // [xsp+80h] [xbp-60h] BYREF
  __int128 v108; // [xsp+88h] [xbp-58h]
  _BYTE v109[64]; // [xsp+98h] [xbp-48h] BYREF
  __int64 v110; // [xsp+D8h] [xbp-8h] BYREF

  v2 = (unsigned __int8 **)a1[83];
  *(_QWORD *)&v105 = v106;
  *((_QWORD *)&v105 + 1) = &ptr;
  v4 = (unsigned __int8 *)(a1 + 86);
  v103 = a1;
  v104 = (unsigned __int8 **)v106;
  memset(v106, 0, sizeof(v106));
  ptr = v109;
  *(_QWORD *)&v108 = v109;
  *((_QWORD *)&v108 + 1) = &v110;
  memset(v109, 0, sizeof(v109));
  if ( v2 == a1 + 86 )
  {
    v14 = a1[84];
    v15 = v14 - (unsigned __int8 *)v2;
    memmove(v106, v2, v14 - (unsigned __int8 *)v2);
    v6 = (unsigned __int8 *)ptr;
    a1[84] = (unsigned __int8 *)v2;
    *(_QWORD *)&v105 = (char *)v106 + v15;
    v7 = (unsigned __int8 **)a1[72];
    v8 = (unsigned __int8 *)(a1 + 75);
    if ( v7 != a1 + 75 )
    {
LABEL_3:
      ptr = v7;
      if ( v6 == v109 )
      {
        a1[72] = v8;
        v21 = *(_OWORD *)(a1 + 73);
        a1[73] = v8;
        a1[74] = (unsigned __int8 *)(a1 + 83);
        v108 = v21;
        a1[84] = (unsigned __int8 *)v2;
        a1[73] = v8;
        v11 = *a1;
        v12 = a1[1];
        v13 = v12 - *a1;
        if ( v12 == *a1 )
          goto LABEL_18;
      }
      else
      {
        v9 = (unsigned __int8 *)*((_QWORD *)&v108 + 1);
        a1[72] = v6;
        v10 = *(_OWORD *)(a1 + 73);
        a1[74] = v9;
        a1[73] = v6;
        v108 = v10;
        a1[84] = (unsigned __int8 *)v2;
        a1[73] = v6;
        v11 = *a1;
        v12 = a1[1];
        v13 = v12 - *a1;
        if ( v12 == *a1 )
          goto LABEL_18;
      }
      goto LABEL_12;
    }
  }
  else
  {
    v104 = v2;
    v5 = *((_OWORD *)a1 + 42);
    v2 = a1 + 86;
    v6 = v109;
    a1[83] = v4;
    a1[84] = v4;
    v105 = v5;
    a1[85] = (unsigned __int8 *)(a1 + 90);
    v7 = (unsigned __int8 **)a1[72];
    v8 = (unsigned __int8 *)(a1 + 75);
    if ( v7 != a1 + 75 )
      goto LABEL_3;
  }
  v16 = a1;
  if ( v6 != v109 )
  {
    free(v6);
    v7 = (unsigned __int8 **)a1[72];
    ptr = v109;
    *(_QWORD *)&v108 = v109;
    v16 = v103;
    *((_QWORD *)&v108 + 1) = &v110;
  }
  v17 = a1[73] - (unsigned __int8 *)v7;
  memmove(v109, v7, v17);
  a1[73] = (unsigned __int8 *)v7;
  v18 = &v109[v17];
  v19 = v16[83];
  v20 = v16[72];
  *(_QWORD *)&v108 = v18;
  v16[84] = v19;
  v16[73] = v20;
  v11 = *a1;
  v12 = a1[1];
  v13 = v12 - *a1;
  if ( v12 == *a1 )
    goto LABEL_18;
LABEL_12:
  v22 = *v11;
  if ( v22 == 71 )
  {
    if ( v13 < 2 )
      goto LABEL_132;
    v46 = v11[1];
    if ( v46 == 73 )
    {
      v100 = 0;
      *a1 = v11 + 2;
      v31 = 0;
      if ( (sub_504DC((__int64)a1, (__int64 *)&v100) & 1) != 0 )
        goto LABEL_133;
      v47 = v100;
      if ( !v100 )
        goto LABEL_133;
      v68 = a1[614];
      v69 = *((_QWORD *)v68 + 1);
      if ( (unsigned __int64)(v69 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v70 = (unsigned __int8 *)malloc(0x1000u);
        if ( !v70 )
          goto LABEL_137;
        v69 = 0;
        *(_QWORD *)v70 = v68;
        *((_QWORD *)v70 + 1) = 0;
        v68 = v70;
        a1[614] = v70;
      }
      v71 = v69 + 48;
      v52 = &v68[v71];
      *((_QWORD *)v68 + 1) = v71;
      LOWORD(v71) = *(_WORD *)&v68[v71 - 23];
      *(v52 - 24) = 20;
      v53 = v71 & 0xF000 | 0x540;
      v54 = "initializer for module ";
      v55 = "";
      goto LABEL_79;
    }
    if ( v46 != 82 )
    {
      if ( v46 != 86 )
        goto LABEL_132;
      *a1 = v11 + 2;
      v47 = sub_4ECA0((__int64)a1, 0);
      if ( !v47 )
        goto LABEL_132;
      v48 = a1[614];
      v49 = *((_QWORD *)v48 + 1);
      if ( (unsigned __int64)(v49 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v50 = (unsigned __int8 *)malloc(0x1000u);
        if ( !v50 )
          goto LABEL_137;
        v49 = 0;
        *(_QWORD *)v50 = v48;
        *((_QWORD *)v50 + 1) = 0;
        v48 = v50;
        a1[614] = v50;
      }
      v51 = v49 + 48;
      v52 = &v48[v51];
      *((_QWORD *)v48 + 1) = v51;
      LOWORD(v51) = *(_WORD *)&v48[v51 - 23];
      *(v52 - 24) = 20;
      v53 = v51 & 0xF000 | 0x540;
      v54 = "guard variable for ";
      v55 = "";
LABEL_79:
      *(_WORD *)(v52 - 23) = v53;
      *((_QWORD *)v52 - 2) = v54;
      *((_QWORD *)v52 - 1) = v55;
      *(_QWORD *)v52 = v47;
      *((_QWORD *)v52 - 4) = off_6FAB8;
      v31 = v52 - 32;
      goto LABEL_133;
    }
    *a1 = v11 + 2;
    v100 = sub_4ECA0((__int64)a1, 0);
    if ( !v100 )
      goto LABEL_132;
    v63 = *a1;
    v64 = a1[1];
    if ( v64 == *a1 || (v65 = *v63, v65 < 0x30) || v65 >= 0x3A && v65 - 65 > 0x19 )
    {
      v66 = 1;
      if ( v63 == v64 )
        goto LABEL_71;
    }
    else
    {
      while ( 1 )
      {
        v67 = *v63;
        if ( v67 < 0x30 || v67 >= 0x3A && v67 - 65 > 0x19 )
          break;
        *a1 = ++v63;
        if ( v63 == v64 )
          goto LABEL_132;
      }
      v66 = 0;
      if ( v63 == v64 )
        goto LABEL_71;
    }
    if ( *v63 == 95 )
    {
      *a1 = v63 + 1;
LABEL_72:
      v27 = (unsigned __int8 *)sub_50428((__int64)a1, (__int64 *)&v100);
      goto LABEL_116;
    }
LABEL_71:
    if ( !v66 )
      goto LABEL_132;
    goto LABEL_72;
  }
  if ( v22 == 84 )
  {
    if ( v13 >= 2 )
    {
      switch ( v11[1] )
      {
        case 'A':
          __asm { BTI             j; jumptable 000000000004D0F0 case 65 }
          *a1 = v11 + 2;
          v100 = sub_4F358(a1);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4FB50((__int64)a1, (__int64 *)&v100);
          break;
        case 'C':
          __asm { BTI             j; jumptable 000000000004D0F0 case 67 }
          *a1 = v11 + 2;
          v100 = sub_4DAC4((__int64)a1, a2);
          if ( !v100 )
            goto LABEL_132;
          v81 = sub_4D97C(a1, 1);
          if ( v81 == (unsigned __int8 *)v82 )
            goto LABEL_132;
          v83 = *a1;
          if ( *a1 == a1[1] )
            goto LABEL_132;
          if ( *v83 != 95 )
            goto LABEL_132;
          *a1 = v83 + 1;
          *(_QWORD *)&v97 = sub_4DAC4((__int64)a1, v82);
          if ( !(_QWORD)v97 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_50160((__int64)a1, (__int64 *)&v97, (__int64 *)&v100);
          break;
        case 'H':
          __asm { BTI             j; jumptable 000000000004D0F0 case 72 }
          *a1 = v11 + 2;
          v100 = sub_4ECA0((__int64)a1, 0);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_5020C((__int64)a1, (__int64 *)&v100);
          break;
        case 'I':
          __asm { BTI             j; jumptable 000000000004D0F0 case 73 }
          *a1 = v11 + 2;
          v100 = sub_4DAC4((__int64)a1, a2);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4FD6C((__int64)a1, (__int64 *)&v100);
          break;
        case 'S':
          __asm { BTI             j; jumptable 000000000004D0F0 case 83 }
          *a1 = v11 + 2;
          v100 = sub_4DAC4((__int64)a1, a2);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4FE20((__int64)a1, (__int64 *)&v100);
          break;
        case 'T':
          __asm { BTI             j; jumptable 000000000004D0F0 case 84 }
          *a1 = v11 + 2;
          v100 = sub_4DAC4((__int64)a1, a2);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4FCB8((__int64)a1, (__int64 *)&v100);
          break;
        case 'V':
          __asm { BTI             j; jumptable 000000000004D0F0 case 86 }
          *a1 = v11 + 2;
          v100 = sub_4DAC4((__int64)a1, a2);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4FC04((__int64)a1, (__int64 *)&v100);
          break;
        case 'W':
          __asm { BTI             j; jumptable 000000000004D0F0 case 87 }
          *a1 = v11 + 2;
          v100 = sub_4ECA0((__int64)a1, 0);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_4DA08((__int64)a1, "thread-local wrapper routine for ", (__int64 *)&v100);
          break;
        case 'c':
          __asm { BTI             j; jumptable 000000000004D0F0 case 99 }
          *a1 = v11 + 2;
          if ( (sub_4FED4((__int64)a1) & 1) != 0 )
            goto LABEL_132;
          if ( (sub_4FED4((__int64)a1) & 1) != 0 )
            goto LABEL_132;
          v100 = (_QWORD *)sub_4CEF0(a1);
          if ( !v100 )
            goto LABEL_132;
          v27 = (unsigned __int8 *)sub_500AC((__int64)a1, (__int64 *)&v100);
          break;
        default:
          goto LABEL_51;
      }
      goto LABEL_116;
    }
LABEL_51:
    __asm { BTI             j; jumptable 000000000004D0F0 default case, cases 66,68-71,74-82,85,88-98 }
    v61 = v11 + 1;
    *a1 = v61;
    if ( v12 == v61 )
    {
      v62 = 0;
      if ( (sub_4FED4((__int64)a1) & 1) != 0 )
        goto LABEL_132;
    }
    else
    {
      v62 = *v61 == 118;
      if ( (sub_4FED4((__int64)a1) & 1) != 0 )
        goto LABEL_132;
    }
    v100 = (_QWORD *)sub_4CEF0(a1);
    if ( v100 )
    {
      if ( v62 )
        v27 = (unsigned __int8 *)sub_502C0((__int64)a1, (__int64 *)&v100);
      else
        v27 = (unsigned __int8 *)sub_50374((__int64)a1, (__int64 *)&v100);
      goto LABEL_116;
    }
    goto LABEL_132;
  }
LABEL_18:
  v28 = a1[90];
  v29 = a1[91];
  LOWORD(v100) = 0;
  HIDWORD(v100) = 0;
  v101[0] = 0;
  v102 = (v29 - v28) >> 3;
  v31 = (unsigned __int8 *)sub_4ECA0((__int64)a1, (size_t)&v100);
  v99 = v31;
  if ( !v31 )
    goto LABEL_133;
  v32 = a1[90];
  v33 = v102;
  v34 = (a1[91] - v32) >> 3;
  if ( v34 <= v102 )
  {
    if ( v34 >= v102 )
    {
      a1[91] = &v32[8 * v102];
      goto LABEL_40;
    }
LABEL_136:
    __assert2(
      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
      129,
      "void (anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_demangle::ForwardTempl"
      "ateReference *, 4>::dropBack(size_t) [T = (anonymous namespace)::itanium_demangle::ForwardTemplateReference *, N = 4]",
      "Index <= size() && \"dropBack() can't expand!\"");
LABEL_137:
    std::terminate();
  }
  v35 = a1[83];
  if ( v35 == a1[84]
    || (v36 = *(__int64 **)v35) == 0
    || (v37 = &v32[8 * v102],
        v38 = *v36,
        v39 = *(_QWORD *)v37,
        v40 = *(_QWORD *)(*(_QWORD *)v37 + 16LL),
        v40 >= (v36[1] - *v36) >> 3) )
  {
LABEL_132:
    v31 = 0;
    goto LABEL_133;
  }
  v41 = v102 + 1;
  do
  {
    v42 = v41;
    *(_QWORD *)(v39 + 24) = *(_QWORD *)(v38 + 8 * v40);
    if ( v34 == v41 )
    {
      if ( v34 >= v33 )
      {
        a1[91] = v37;
        if ( v41 < v34 )
          goto LABEL_132;
        goto LABEL_40;
      }
      goto LABEL_136;
    }
    v43 = *(__int64 **)v35;
    if ( !*(_QWORD *)v35 )
      break;
    v39 = *(_QWORD *)&v32[8 * v41];
    v38 = *v43;
    v44 = v43[1];
    v40 = *(_QWORD *)(v39 + 16);
    v45 = v44 - v38;
    v41 = v42 + 1;
  }
  while ( v40 < v45 >> 3 );
  if ( v42 < v34 )
    goto LABEL_132;
LABEL_40:
  v56 = (const char *)*a1;
  v57 = a1[1];
  v58 = v57 - *a1;
  if ( v57 == *a1 )
    goto LABEL_133;
  v59 = *(unsigned __int8 *)v56 - 46;
  if ( v59 <= 0x31 && ((1LL << v59) & 0x2000000800001LL) != 0 )
    goto LABEL_133;
  v98 = 0;
  if ( v58 >= 0xD && !strncmp("Ua9enable_ifI", v56, 0xDu) )
  {
    v84 = a1[2];
    v85 = a1[3];
    v86 = (unsigned __int8 *)(v56 + 13);
    *a1 = (unsigned __int8 *)(v56 + 13);
    v87 = (v85 - v84) >> 3;
    while ( v86 == v57 || *v86 != 69 )
    {
      v90 = sub_4F358(a1);
      if ( !v90 )
        goto LABEL_132;
      v89 = a1[3];
      if ( v89 == a1[4] )
      {
        v91 = (unsigned __int8 **)a1[2];
        v92 = v89 - (unsigned __int8 *)v91;
        if ( v91 == a1 + 5 )
        {
          v93 = (unsigned __int8 *)malloc(2 * (v89 - (unsigned __int8 *)v91));
          if ( !v93 )
            goto LABEL_137;
          v88 = v93;
          memcpy(v93, a1 + 5, v92);
          a1[2] = v88;
        }
        else
        {
          v88 = (unsigned __int8 *)realloc(v91, 2 * (v89 - (unsigned __int8 *)v91));
          a1[2] = v88;
          if ( !v88 )
            goto LABEL_137;
        }
        v89 = &v88[v92];
        a1[3] = &v88[v92];
        a1[4] = &v88[8 * (v92 >> 2)];
      }
      a1[3] = v89 + 8;
      *(_QWORD *)v89 = v90;
      v86 = *a1;
      v57 = a1[1];
    }
    *a1 = v86 + 1;
    *(_QWORD *)&v97 = sub_4F750(a1, v87);
    *((_QWORD *)&v97 + 1) = v95;
    v98 = sub_4F6AC((__int64)a1, &v97);
    v96 = 0;
    if ( (_BYTE)v100 )
      goto LABEL_48;
LABEL_46:
    if ( !BYTE1(v100) )
      goto LABEL_48;
    v96 = sub_4DAC4((__int64)a1, v30);
    if ( v96 )
      goto LABEL_48;
    goto LABEL_132;
  }
  v96 = 0;
  if ( !(_BYTE)v100 )
    goto LABEL_46;
LABEL_48:
  v60 = *a1;
  if ( *a1 == a1[1] || *v60 != 118 )
  {
    v72 = (a1[3] - a1[2]) >> 3;
    while ( 1 )
    {
      v73 = sub_4DAC4((__int64)a1, v30);
      if ( !v73 )
        goto LABEL_132;
      v74 = a1[3];
      if ( v74 == a1[4] )
      {
        v75 = (unsigned __int8 **)a1[2];
        v76 = v74 - (unsigned __int8 *)v75;
        if ( v75 == a1 + 5 )
        {
          v78 = (unsigned __int8 *)malloc(2 * (v74 - (unsigned __int8 *)v75));
          if ( !v78 )
            goto LABEL_137;
          v77 = v78;
          memcpy(v78, a1 + 5, v76);
          a1[2] = v77;
        }
        else
        {
          v77 = (unsigned __int8 *)realloc(v75, 2 * (v74 - (unsigned __int8 *)v75));
          a1[2] = v77;
          if ( !v77 )
            goto LABEL_137;
        }
        v74 = &v77[v76];
        a1[3] = &v77[v76];
        a1[4] = &v77[8 * (v76 >> 2)];
      }
      a1[3] = v74 + 8;
      *(_QWORD *)v74 = v73;
      if ( a1[1] != *a1 )
      {
        v79 = **a1 - 46;
        if ( v79 > 0x31 || ((1LL << v79) & 0x2000000800001LL) == 0 )
          continue;
      }
      *(_QWORD *)&v97 = sub_4F750(a1, v72);
      *((_QWORD *)&v97 + 1) = v80;
      goto LABEL_94;
    }
  }
  v97 = 0u;
  *a1 = v60 + 1;
LABEL_94:
  v27 = (unsigned __int8 *)sub_4F884(
                             (__int64)a1,
                             (__int64 *)&v96,
                             (__int64 *)&v99,
                             &v97,
                             (__int64 *)&v98,
                             (int *)&v100 + 1,
                             v101);
LABEL_116:
  v31 = v27;
LABEL_133:
  sub_4F96C(&v103);
  return v31;
}
// 4D318: variable 'v30' is possibly undefined
// 4D5F8: variable 'v80' is possibly undefined
// 4D678: variable 'a2' is possibly undefined
// 4D6C0: variable 'v82' is possibly undefined
// 4D908: variable 'v95' is possibly undefined
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004D97C) ----------------------------------------------------
unsigned __int8 *__fastcall sub_4D97C(unsigned __int8 **a1, char a2)
{
  unsigned __int8 *result; // x0
  unsigned __int8 *v5; // x10
  unsigned __int8 *v6; // x1

  result = *a1;
  v5 = a1[1];
  v6 = result;
  if ( (a2 & 1) != 0 )
  {
    v6 = result;
    if ( result != v5 )
    {
      v6 = result;
      if ( *result == 110 )
      {
        v6 = result + 1;
        *a1 = result + 1;
      }
    }
  }
  if ( v5 == v6 || (unsigned int)*v6 - 58 < 0xFFFFFFF6 )
    return 0;
  do
  {
    if ( (unsigned int)*v6 - 58 < 0xFFFFFFF6 )
      break;
    *a1 = ++v6;
  }
  while ( v6 != v5 );
  return result;
}

//----- (000000000004DA08) ----------------------------------------------------
_QWORD *__fastcall sub_4DA08(__int64 a1, char *s, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x21
  size_t v11; // x0
  __int16 v12; // w9
  char *v13; // x11
  __int64 v14; // x10
  _QWORD *result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 48;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  v11 = strlen(s);
  v12 = *(_WORD *)((char *)v10 - 23);
  *((_BYTE *)v10 - 24) = 20;
  v13 = &s[v11];
  *(v10 - 4) = off_6FAB8;
  v14 = *a3;
  *(_WORD *)((char *)v10 - 23) = v12 & 0xF000 | 0x540;
  result = v10 - 4;
  *(v10 - 2) = s;
  *(v10 - 1) = v13;
  *v10 = v14;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004DAC4) ----------------------------------------------------
unsigned __int8 **__fastcall sub_4DAC4(__int64 a1, size_t a2)
{
  const char *v2; // x8
  const char *v3; // x9
  unsigned __int64 v5; // x10
  char v6; // w11
  int v7; // w12
  _BYTE *v12; // x10
  const char *v13; // x8
  unsigned __int8 **v14; // x20
  int v15; // w10
  unsigned __int8 *v16; // x8
  char v17; // w20
  __int64 v18; // x0
  unsigned __int8 **v19; // x0
  unsigned int v20; // w8
  char *v21; // x8
  _BYTE *v22; // x23
  signed __int64 v23; // x21
  char *v24; // x22
  char *v25; // x0
  _QWORD *v26; // x20
  __int64 v27; // x8
  _QWORD *v28; // x0
  __int64 v29; // x8
  const char **v30; // x9
  __int16 v31; // w8
  const char *v32; // x11
  _QWORD *v33; // x20
  __int64 v34; // x8
  _QWORD *v35; // x0
  __int64 v36; // x8
  _QWORD *v37; // x20
  __int64 v38; // x8
  _QWORD *v39; // x0
  __int64 v40; // x8
  _QWORD *v41; // x20
  __int64 v42; // x8
  _QWORD *v43; // x0
  __int64 v44; // x8
  char *v45; // x10
  _QWORD *v46; // x20
  __int64 v47; // x8
  _QWORD *v48; // x0
  __int64 v49; // x8
  _QWORD *v50; // x20
  __int64 v51; // x8
  _QWORD *v52; // x0
  __int64 v53; // x8
  _QWORD *v54; // x20
  __int64 v55; // x8
  _QWORD *v56; // x0
  __int64 v57; // x8
  _QWORD *v58; // x20
  __int64 v59; // x8
  _QWORD *v60; // x0
  __int64 v61; // x8
  _QWORD *v62; // x20
  __int64 v63; // x8
  _QWORD *v64; // x0
  __int64 v65; // x8
  _QWORD *v66; // x20
  __int64 v67; // x8
  _QWORD *v68; // x0
  __int64 v69; // x8
  _QWORD *v70; // x20
  __int64 v71; // x8
  _QWORD *v72; // x0
  __int64 v73; // x8
  _QWORD *v74; // x20
  __int64 v75; // x8
  _QWORD *v76; // x0
  __int64 v77; // x8
  _QWORD *v78; // x20
  __int64 v79; // x8
  _QWORD *v80; // x0
  __int64 v81; // x8
  _QWORD *v82; // x20
  __int64 v83; // x8
  _QWORD *v84; // x0
  __int64 v85; // x8
  unsigned int v86; // w9
  unsigned __int64 v87; // x11
  int v88; // w11
  unsigned __int64 v89; // x9
  unsigned int v90; // w8
  _QWORD *v91; // x20
  __int64 v92; // x8
  _QWORD *v93; // x0
  __int64 v94; // x8
  _QWORD *v95; // x20
  __int64 v96; // x8
  _QWORD *v97; // x0
  __int64 v98; // x8
  unsigned __int64 v99; // x10
  unsigned __int8 *v100; // x11
  const char *v101; // x8
  int v102; // t1
  unsigned __int8 *v103; // x11
  _QWORD *v104; // x20
  __int64 v105; // x8
  _QWORD *v106; // x0
  __int64 v107; // x8
  _QWORD *v108; // x20
  __int64 v109; // x8
  _QWORD *v110; // x0
  __int64 v111; // x8
  _QWORD *v112; // x20
  __int64 v113; // x8
  _QWORD *v114; // x0
  __int64 v115; // x8
  _QWORD *v116; // x20
  __int64 v117; // x8
  _QWORD *v118; // x0
  __int64 v119; // x8
  _QWORD *v120; // x20
  __int64 v121; // x8
  _QWORD *v122; // x0
  __int64 v123; // x8
  char *v125; // x0
  const char *v126; // x8
  __int64 v127; // x1
  char *v128; // x0
  const char *v129; // x8
  const char *v130; // x9
  __int64 v131; // x1
  _OWORD *v132; // x0
  const char *v133; // x8
  const char *v134; // x9
  const char *v135; // x8
  const char *v136; // x8
  char *v137; // x1
  const char *v138; // x8
  const char *v139; // x8
  __int64 v140; // x1
  const char *v141; // x8
  unsigned __int8 **v142; // [xsp+8h] [xbp-18h] BYREF
  __int128 v143; // [xsp+10h] [xbp-10h] BYREF
  char *v144; // [xsp+38h] [xbp+18h] BYREF

  v2 = *(const char **)a1;
  v3 = *(const char **)(a1 + 8);
  v142 = 0;
  v5 = v3 - v2;
  if ( v3 == v2 )
  {
LABEL_39:
    __asm { BTI             j; jumptable 000000000004DB1C default case, cases 66,69,72-74,76,78,81,87-96,107,112,113 }
    v18 = (__int64)sub_608B8((const char **)a1);
LABEL_40:
    v14 = (unsigned __int8 **)v18;
    if ( v18 )
    {
LABEL_41:
      v21 = *(char **)(a1 + 304);
      if ( v21 == *(char **)(a1 + 312) )
      {
        v22 = *(_BYTE **)(a1 + 296);
        v23 = v21 - v22;
        if ( v22 == (_BYTE *)(a1 + 320) )
        {
          v25 = (char *)malloc(2 * v23);
          if ( !v25 )
            goto LABEL_216;
          v24 = v25;
          memmove(v25, v22, v23);
          *(_QWORD *)(a1 + 296) = v24;
        }
        else
        {
          v24 = (char *)realloc(*(void **)(a1 + 296), 2 * (v21 - v22));
          *(_QWORD *)(a1 + 296) = v24;
          if ( !v24 )
LABEL_216:
            std::terminate();
        }
        v21 = &v24[v23];
        *(_QWORD *)(a1 + 312) = &v24[8 * (v23 >> 2)];
      }
      *(_QWORD *)(a1 + 304) = v21 + 8;
      *(_QWORD *)v21 = v14;
    }
  }
  else
  {
    v6 = *v2;
    v7 = 0;
    switch ( *v2 )
    {
      case 'A':
        __asm { BTI             j; jumptable 000000000004DB1C case 65 }
        v12 = v2 + 1;
        v144 = 0;
        *(_QWORD *)a1 = v2 + 1;
        if ( v3 == v2 + 1 )
          goto LABEL_169;
        if ( (unsigned int)(unsigned __int8)*v12 - 58 >= 0xFFFFFFF6 )
        {
          *(_QWORD *)&v143 = sub_4D97C((unsigned __int8 **)a1, 0);
          *((_QWORD *)&v143 + 1) = v127;
          v128 = (char *)sub_5C364(a1, &v143);
          v129 = *(const char **)a1;
          v130 = *(const char **)(a1 + 8);
          v144 = v128;
          if ( v129 == v130 || *v129 != 95 )
            goto LABEL_179;
          v13 = v129 + 1;
        }
        else if ( *v12 == 95 )
        {
          v13 = v2 + 2;
        }
        else
        {
LABEL_169:
          v125 = sub_52694(a1);
          if ( !v125 )
            goto LABEL_179;
          v126 = *(const char **)a1;
          if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v126 != 95 )
            goto LABEL_179;
          v13 = v126 + 1;
          v144 = v125;
        }
        *(_QWORD *)a1 = v13;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( (_QWORD)v143 )
        {
          v18 = (__int64)sub_621EC(a1, (__int64 *)&v143, (__int64 *)&v144);
          goto LABEL_40;
        }
LABEL_179:
        v14 = 0;
        break;
      case 'C':
        __asm { BTI             j; jumptable 000000000004DB1C case 67 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_215;
        v14 = (unsigned __int8 **)sub_60BA0(a1, (__int64 *)&v143);
        goto LABEL_41;
      case 'D':
        __asm { BTI             j; jumptable 000000000004DB1C case 68 }
        if ( v5 < 2 )
          goto LABEL_215;
        v15 = *((unsigned __int8 *)v2 + 1);
        v14 = 0;
        switch ( v2[1] )
        {
          case 'B':
          case 'U':
            __asm { BTI             j; jumptable 000000000004DBC0 cases 66,85 }
            v16 = (unsigned __int8 *)(v2 + 2);
            v17 = v15 == 66;
            *(_QWORD *)a1 = v16;
            if ( v3 == (const char *)v16 || (unsigned int)*v16 - 58 < 0xFFFFFFF6 )
            {
              *(_QWORD *)&v143 = sub_52694(a1);
              if ( !(_QWORD)v143 )
                goto LABEL_215;
            }
            else
            {
              *(_QWORD *)&v143 = sub_4D97C((unsigned __int8 **)a1, 0);
              *((_QWORD *)&v143 + 1) = v140;
              *(_QWORD *)&v143 = sub_5C364(a1, &v143);
            }
            v141 = *(const char **)a1;
            if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v141 != 95 )
              goto LABEL_215;
            *(_QWORD *)a1 = v141 + 1;
            v14 = (unsigned __int8 **)sub_604F4(a1, &v143, v17);
            break;
          case 'F':
            __asm { BTI             j; jumptable 000000000004DBC0 case 70 }
            *(_QWORD *)a1 = v2 + 2;
            *(_QWORD *)&v143 = sub_4D97C((unsigned __int8 **)a1, 0);
            *((_QWORD *)&v143 + 1) = v131;
            v132 = sub_5C364(a1, &v143);
            v133 = *(const char **)a1;
            v134 = *(const char **)(a1 + 8);
            *(_QWORD *)&v143 = v132;
            if ( v133 == v134 || *v133 != 95 )
              goto LABEL_215;
            *(_QWORD *)a1 = v133 + 1;
            v14 = (unsigned __int8 **)sub_60450(a1, (__int64 *)&v143);
            goto LABEL_163;
          case 'O':
          case 'o':
          case 'w':
          case 'x':
            goto LABEL_123;
          case 'T':
          case 't':
            __asm { BTI             j; jumptable 000000000004DBC0 cases 84,116 }
            v18 = sub_51900(a1);
            goto LABEL_40;
          case 'a':
            __asm { BTI             j; jumptable 000000000004DBC0 case 97 }
            v135 = v2 + 2;
            goto LABEL_201;
          case 'c':
            __asm { BTI             j; jumptable 000000000004DBC0 case 99 }
            v136 = v2 + 2;
            v137 = "decltype(auto)";
            goto LABEL_204;
          case 'd':
            __asm { BTI             j; jumptable 000000000004DBC0 case 100 }
            v138 = v2 + 2;
            goto LABEL_199;
          case 'e':
            __asm { BTI             j; jumptable 000000000004DBC0 case 101 }
            *(_QWORD *)a1 = v2 + 2;
            JUMPOUT(0x603A0);
          case 'f':
            __asm { BTI             j; jumptable 000000000004DBC0 case 102 }
            v138 = v2 + 2;
LABEL_199:
            *(_QWORD *)a1 = v138;
            JUMPOUT(0x60240);
          case 'h':
            __asm { BTI             j; jumptable 000000000004DBC0 case 104 }
            v135 = v2 + 2;
LABEL_201:
            *(_QWORD *)a1 = v135;
            JUMPOUT(0x522F0);
          case 'i':
            __asm { BTI             j; jumptable 000000000004DBC0 case 105 }
            v139 = v2 + 2;
            goto LABEL_208;
          case 'n':
            __asm { BTI             j; jumptable 000000000004DBC0 case 110 }
            v136 = v2 + 2;
            v137 = "std::nullptr_t";
LABEL_204:
            *(_QWORD *)a1 = v136;
            return (unsigned __int8 **)sub_5E6C8(a1, v137);
          case 'p':
            __asm { BTI             j; jumptable 000000000004DBC0 case 112 }
            *(_QWORD *)a1 = v2 + 2;
            *(_QWORD *)&v143 = sub_4DAC4(a1);
            if ( !(_QWORD)v143 )
              goto LABEL_215;
            v14 = (unsigned __int8 **)sub_55B54(a1, (__int64 *)&v143);
            goto LABEL_41;
          case 's':
            __asm { BTI             j; jumptable 000000000004DBC0 case 115 }
            v139 = v2 + 2;
LABEL_208:
            *(_QWORD *)a1 = v139;
            JUMPOUT(0x602F0);
          case 'u':
            __asm { BTI             j; jumptable 000000000004DBC0 case 117 }
            *(_QWORD *)a1 = v2 + 2;
            JUMPOUT(0x583B8);
          case 'v':
            __asm { BTI             j; jumptable 000000000004DBC0 case 118 }
            v18 = (__int64)sub_605A8((const char **)a1);
            goto LABEL_40;
          default:
            goto LABEL_163;
        }
        break;
      case 'F':
        goto LABEL_123;
      case 'G':
        __asm { BTI             j; jumptable 000000000004DB1C case 71 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_215;
        v14 = (unsigned __int8 **)sub_60C54(a1, (__int64 *)&v143);
        goto LABEL_41;
      case 'K':
      case 'V':
        goto LABEL_109;
      case 'M':
        __asm { BTI             j; jumptable 000000000004DB1C case 77 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_179;
        v144 = (char *)sub_4DAC4(a1);
        if ( !v144 )
          goto LABEL_179;
        v18 = (__int64)sub_62478(a1, (__int64 *)&v143, (__int64 *)&v144);
        goto LABEL_40;
      case 'O':
        __asm { BTI             j; jumptable 000000000004DB1C case 79 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_215;
        LODWORD(v144) = 1;
        goto LABEL_26;
      case 'P':
        __asm { BTI             j; jumptable 000000000004DB1C case 80 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_215;
        v14 = (unsigned __int8 **)sub_60A30(a1, (__int64 *)&v143);
        goto LABEL_41;
      case 'R':
        __asm { BTI             j; jumptable 000000000004DB1C case 82 }
        *(_QWORD *)a1 = v2 + 1;
        *(_QWORD *)&v143 = sub_4DAC4(a1);
        if ( !(_QWORD)v143 )
          goto LABEL_215;
        LODWORD(v144) = 0;
LABEL_26:
        v14 = (unsigned __int8 **)sub_60AE0(a1, (__int64 *)&v143, (int *)&v144);
        goto LABEL_41;
      case 'S':
        __asm { BTI             j; jumptable 000000000004DB1C case 83 }
        if ( v5 >= 2 && v2[1] == 116 )
          goto LABEL_39;
        LOBYTE(v144) = 0;
        v19 = sub_50D98((const char **)a1, 0, &v144);
        v142 = v19;
        if ( !v19 )
          goto LABEL_215;
        v14 = v19;
        if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73 || (_BYTE)v144 && !*(_BYTE *)(a1 + 776) )
        {
          if ( (_BYTE)v144 )
            break;
          goto LABEL_41;
        }
        if ( !(_BYTE)v144 )
          sub_4F5F4((_QWORD *)(a1 + 296), (__int64 *)&v142);
LABEL_188:
        *(_QWORD *)&v143 = sub_50F00((_QWORD *)a1, 0);
        if ( (_QWORD)v143 )
        {
          v14 = (unsigned __int8 **)sub_514E0(a1, (__int64 *)&v142, (__int64 *)&v143);
          goto LABEL_41;
        }
        goto LABEL_215;
      case 'T':
        __asm { BTI             j; jumptable 000000000004DB1C case 84 }
        if ( v5 >= 2 )
        {
          v20 = *((unsigned __int8 *)v2 + 1) - 101;
          if ( v20 <= 0x10 && ((1 << v20) & 0x14001) != 0 )
            goto LABEL_39;
        }
        v14 = (unsigned __int8 **)sub_5158C(a1, a2);
        v142 = v14;
        if ( !v14 )
          break;
        if ( *(_BYTE *)(a1 + 776) && *(_QWORD *)(a1 + 8) != *(_QWORD *)a1 && **(_BYTE **)a1 == 73 )
          goto LABEL_188;
        goto LABEL_41;
      case 'U':
        goto LABEL_124;
      case 'a':
        __asm { BTI             j; jumptable 000000000004DB1C case 97 }
        v26 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v27 = v26[1];
        if ( (unsigned __int64)(v27 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_52;
        v28 = malloc(0x1000u);
        if ( !v28 )
          goto LABEL_216;
        v27 = 0;
        *v28 = v26;
        v28[1] = 0;
        v26 = v28;
        *(_QWORD *)(a1 + 4912) = v28;
LABEL_52:
        v29 = v27 + 32;
        v30 = (const char **)((char *)v26 + v29);
        v26[1] = v29;
        v31 = *(_WORD *)((_BYTE *)v26 + v29 - 7) & 0xF000 | 0x540;
        v32 = "signed char";
        goto LABEL_69;
      case 'b':
        __asm { BTI             j; jumptable 000000000004DB1C case 98 }
        v33 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v34 = v33[1];
        if ( (unsigned __int64)(v34 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_56;
        v35 = malloc(0x1000u);
        if ( !v35 )
          goto LABEL_216;
        v34 = 0;
        *v35 = v33;
        v35[1] = 0;
        v33 = v35;
        *(_QWORD *)(a1 + 4912) = v35;
LABEL_56:
        v36 = v34 + 32;
        v30 = (const char **)((char *)v33 + v36);
        v33[1] = v36;
        v31 = *(_WORD *)((_BYTE *)v33 + v36 - 7) & 0xF000 | 0x540;
        v32 = "bool";
        goto LABEL_144;
      case 'c':
        __asm { BTI             j; jumptable 000000000004DB1C case 99 }
        v37 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v38 = v37[1];
        if ( (unsigned __int64)(v38 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_60;
        v39 = malloc(0x1000u);
        if ( !v39 )
          goto LABEL_216;
        v38 = 0;
        *v39 = v37;
        v39[1] = 0;
        v37 = v39;
        *(_QWORD *)(a1 + 4912) = v39;
LABEL_60:
        v40 = v38 + 32;
        v30 = (const char **)((char *)v37 + v40);
        v37[1] = v40;
        v31 = *(_WORD *)((_BYTE *)v37 + v40 - 7) & 0xF000 | 0x540;
        v32 = "char";
        goto LABEL_144;
      case 'd':
        __asm { BTI             j; jumptable 000000000004DB1C case 100 }
        v41 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v42 = v41[1];
        if ( (unsigned __int64)(v42 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_64;
        v43 = malloc(0x1000u);
        if ( !v43 )
          goto LABEL_216;
        v42 = 0;
        *v43 = v41;
        v43[1] = 0;
        v41 = v43;
        *(_QWORD *)(a1 + 4912) = v43;
LABEL_64:
        v44 = v42 + 32;
        v30 = (const char **)((char *)v41 + v44);
        v41[1] = v44;
        LOWORD(v44) = *(_WORD *)((char *)v41 + v44 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v44 & 0xF000 | 0x540;
        v32 = "double";
        v45 = "";
        goto LABEL_162;
      case 'e':
        __asm { BTI             j; jumptable 000000000004DB1C case 101 }
        v46 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v47 = v46[1];
        if ( (unsigned __int64)(v47 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_68;
        v48 = malloc(0x1000u);
        if ( !v48 )
          goto LABEL_216;
        v47 = 0;
        *v48 = v46;
        v48[1] = 0;
        v46 = v48;
        *(_QWORD *)(a1 + 4912) = v48;
LABEL_68:
        v49 = v47 + 32;
        v30 = (const char **)((char *)v46 + v49);
        v46[1] = v49;
        v31 = *(_WORD *)((_BYTE *)v46 + v49 - 7) & 0xF000 | 0x540;
        v32 = "long double";
LABEL_69:
        *((_BYTE *)v30 - 8) = 7;
        v45 = (char *)(v32 + 11);
        goto LABEL_162;
      case 'f':
        __asm { BTI             j; jumptable 000000000004DB1C case 102 }
        v50 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v51 = v50[1];
        if ( (unsigned __int64)(v51 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_73;
        v52 = malloc(0x1000u);
        if ( !v52 )
          goto LABEL_216;
        v51 = 0;
        *v52 = v50;
        v52[1] = 0;
        v50 = v52;
        *(_QWORD *)(a1 + 4912) = v52;
LABEL_73:
        v53 = v51 + 32;
        v30 = (const char **)((char *)v50 + v53);
        v50[1] = v53;
        v31 = *(_WORD *)((_BYTE *)v50 + v53 - 7) & 0xF000 | 0x540;
        v32 = "float";
        goto LABEL_129;
      case 'g':
        __asm { BTI             j; jumptable 000000000004DB1C case 103 }
        v54 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v55 = v54[1];
        if ( (unsigned __int64)(v55 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_77;
        v56 = malloc(0x1000u);
        if ( !v56 )
          goto LABEL_216;
        v55 = 0;
        *v56 = v54;
        v56[1] = 0;
        v54 = v56;
        *(_QWORD *)(a1 + 4912) = v56;
LABEL_77:
        v57 = v55 + 32;
        v30 = (const char **)((char *)v54 + v57);
        v54[1] = v57;
        LOWORD(v57) = *(_WORD *)((char *)v54 + v57 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v57 & 0xF000 | 0x540;
        v32 = "__float128";
        v45 = "";
        goto LABEL_162;
      case 'h':
        __asm { BTI             j; jumptable 000000000004DB1C case 104 }
        v58 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v59 = v58[1];
        if ( (unsigned __int64)(v59 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_81;
        v60 = malloc(0x1000u);
        if ( !v60 )
          goto LABEL_216;
        v59 = 0;
        *v60 = v58;
        v60[1] = 0;
        v58 = v60;
        *(_QWORD *)(a1 + 4912) = v60;
LABEL_81:
        v61 = v59 + 32;
        v30 = (const char **)((char *)v58 + v61);
        v58[1] = v61;
        v31 = *(_WORD *)((_BYTE *)v58 + v61 - 7) & 0xF000 | 0x540;
        v32 = "unsigned char";
        goto LABEL_98;
      case 'i':
        __asm { BTI             j; jumptable 000000000004DB1C case 105 }
        v62 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v63 = v62[1];
        if ( (unsigned __int64)(v63 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_85;
        v64 = malloc(0x1000u);
        if ( !v64 )
          goto LABEL_216;
        v63 = 0;
        *v64 = v62;
        v64[1] = 0;
        v62 = v64;
        *(_QWORD *)(a1 + 4912) = v64;
LABEL_85:
        v65 = v63 + 32;
        v30 = (const char **)((char *)v62 + v65);
        v62[1] = v65;
        v31 = *(_WORD *)((_BYTE *)v62 + v65 - 7) & 0xF000 | 0x540;
        v32 = "int";
        goto LABEL_161;
      case 'j':
        __asm { BTI             j; jumptable 000000000004DB1C case 106 }
        v66 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v67 = v66[1];
        if ( (unsigned __int64)(v67 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_89;
        v68 = malloc(0x1000u);
        if ( !v68 )
          goto LABEL_216;
        v67 = 0;
        *v68 = v66;
        v68[1] = 0;
        v66 = v68;
        *(_QWORD *)(a1 + 4912) = v68;
LABEL_89:
        v69 = v67 + 32;
        v30 = (const char **)((char *)v66 + v69);
        v66[1] = v69;
        LOWORD(v69) = *(_WORD *)((char *)v66 + v69 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v69 & 0xF000 | 0x540;
        v32 = "unsigned int";
        v45 = "";
        goto LABEL_162;
      case 'l':
        __asm { BTI             j; jumptable 000000000004DB1C case 108 }
        v70 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v71 = v70[1];
        if ( (unsigned __int64)(v71 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_93;
        v72 = malloc(0x1000u);
        if ( !v72 )
          goto LABEL_216;
        v71 = 0;
        *v72 = v70;
        v72[1] = 0;
        v70 = v72;
        *(_QWORD *)(a1 + 4912) = v72;
LABEL_93:
        v73 = v71 + 32;
        v30 = (const char **)((char *)v70 + v73);
        v70[1] = v73;
        v31 = *(_WORD *)((_BYTE *)v70 + v73 - 7) & 0xF000 | 0x540;
        v32 = "long";
        goto LABEL_144;
      case 'm':
        __asm { BTI             j; jumptable 000000000004DB1C case 109 }
        v74 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v75 = v74[1];
        if ( (unsigned __int64)(v75 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_97;
        v76 = malloc(0x1000u);
        if ( !v76 )
          goto LABEL_216;
        v75 = 0;
        *v76 = v74;
        v76[1] = 0;
        v74 = v76;
        *(_QWORD *)(a1 + 4912) = v76;
LABEL_97:
        v77 = v75 + 32;
        v30 = (const char **)((char *)v74 + v77);
        v74[1] = v77;
        v31 = *(_WORD *)((_BYTE *)v74 + v77 - 7) & 0xF000 | 0x540;
        v32 = "unsigned long";
LABEL_98:
        *((_BYTE *)v30 - 8) = 7;
        v45 = (char *)(v32 + 13);
        goto LABEL_162;
      case 'n':
        __asm { BTI             j; jumptable 000000000004DB1C case 110 }
        v78 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v79 = v78[1];
        if ( (unsigned __int64)(v79 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_102;
        v80 = malloc(0x1000u);
        if ( !v80 )
          goto LABEL_216;
        v79 = 0;
        *v80 = v78;
        v80[1] = 0;
        v78 = v80;
        *(_QWORD *)(a1 + 4912) = v80;
LABEL_102:
        v81 = v79 + 32;
        v30 = (const char **)((char *)v78 + v81);
        v78[1] = v81;
        LOWORD(v81) = *(_WORD *)((char *)v78 + v81 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v81 & 0xF000 | 0x540;
        v32 = "__int128";
        v45 = "";
        goto LABEL_162;
      case 'o':
        __asm { BTI             j; jumptable 000000000004DB1C case 111 }
        v82 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v83 = v82[1];
        if ( (unsigned __int64)(v83 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_106;
        v84 = malloc(0x1000u);
        if ( !v84 )
          goto LABEL_216;
        v83 = 0;
        *v84 = v82;
        v84[1] = 0;
        v82 = v84;
        *(_QWORD *)(a1 + 4912) = v84;
LABEL_106:
        v85 = v83 + 32;
        v30 = (const char **)((char *)v82 + v85);
        v82[1] = v85;
        LOWORD(v85) = *(_WORD *)((char *)v82 + v85 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v85 & 0xF000 | 0x540;
        v32 = "unsigned __int128";
        v45 = "";
        goto LABEL_162;
      case 'r':
        __asm { BTI             j; jumptable 000000000004DB1C case 114 }
        if ( v5 < 2 )
        {
          v86 = 1;
          v87 = 1;
        }
        else
        {
          v6 = v2[1];
          v7 = 1;
LABEL_109:
          __asm { BTI             j; jumptable 000000000004DB1C cases 75,86 }
          if ( v6 == 86 )
            v86 = v7 + 1;
          else
            v86 = v7;
          v87 = v86;
          if ( v5 > v86 )
          {
            if ( v2[v86] == 75 )
              v87 = v86 + 1;
            else
              v87 = v86;
            v86 = v87;
          }
        }
        if ( v5 > v87
          && ((v88 = (unsigned __int8)v2[v87], v88 == 70)
           || v88 == 68
           && (v89 = v86 + 1LL, v5 > v89)
           && (v90 = (unsigned __int8)v2[v89] - 79, v90 <= 0x29)
           && ((1LL << v90) & 0x30100000001LL) != 0) )
        {
LABEL_123:
          __asm { BTI             j; jumptable 000000000004DB1C case 70 }
          v18 = (__int64)sub_5F818((const char **)a1);
        }
        else
        {
LABEL_124:
          __asm { BTI             j; jumptable 000000000004DB1C case 85 }
          v18 = (__int64)sub_5FE28((const char **)a1);
        }
        goto LABEL_40;
      case 's':
        __asm { BTI             j; jumptable 000000000004DB1C case 115 }
        v91 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v92 = v91[1];
        if ( (unsigned __int64)(v92 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_128;
        v93 = malloc(0x1000u);
        if ( !v93 )
          goto LABEL_216;
        v92 = 0;
        *v93 = v91;
        v93[1] = 0;
        v91 = v93;
        *(_QWORD *)(a1 + 4912) = v93;
LABEL_128:
        v94 = v92 + 32;
        v30 = (const char **)((char *)v91 + v94);
        v91[1] = v94;
        v31 = *(_WORD *)((_BYTE *)v91 + v94 - 7) & 0xF000 | 0x540;
        v32 = "short";
LABEL_129:
        *((_BYTE *)v30 - 8) = 7;
        v45 = (char *)(v32 + 5);
        goto LABEL_162;
      case 't':
        __asm { BTI             j; jumptable 000000000004DB1C case 116 }
        v95 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v96 = v95[1];
        if ( (unsigned __int64)(v96 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_133;
        v97 = malloc(0x1000u);
        if ( !v97 )
          goto LABEL_216;
        v96 = 0;
        *v97 = v95;
        v97[1] = 0;
        v95 = v97;
        *(_QWORD *)(a1 + 4912) = v97;
LABEL_133:
        v98 = v96 + 32;
        v30 = (const char **)((char *)v95 + v98);
        v95[1] = v98;
        LOWORD(v98) = *(_WORD *)((char *)v95 + v98 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v98 & 0xF000 | 0x540;
        v32 = "unsigned short";
        v45 = "";
        goto LABEL_162;
      case 'u':
        __asm { BTI             j; jumptable 000000000004DB1C case 117 }
        *(_QWORD *)a1 = v2 + 1;
        if ( v3 == v2 + 1 || (unsigned int)*((unsigned __int8 *)v2 + 1) - 58 < 0xFFFFFFF6 )
          goto LABEL_182;
        v99 = 0;
        v100 = (unsigned __int8 *)(v2 + 2);
        v101 = v2 + 1;
        while ( 1 )
        {
          *(_QWORD *)a1 = v100;
          v99 = *(v100 - 1) + 10 * v99 - 48;
          if ( v100 == (unsigned __int8 *)v3 )
            break;
          v102 = *v100++;
          ++v101;
          if ( (unsigned int)(v102 - 48) >= 0xA )
          {
            v103 = v100 - 1;
            goto LABEL_181;
          }
        }
        v101 = v3;
        v103 = (unsigned __int8 *)v3;
LABEL_181:
        if ( v3 - v101 >= v99 )
        {
          *(_QWORD *)a1 = &v103[v99];
          *(_QWORD *)&v143 = v101;
          *((_QWORD *)&v143 + 1) = &v103[v99];
          if ( &v103[v99] != (unsigned __int8 *)v101 )
          {
            v14 = (unsigned __int8 **)sub_50B10(a1, &v143);
            goto LABEL_41;
          }
        }
        else
        {
LABEL_182:
          v143 = 0u;
        }
LABEL_215:
        v14 = 0;
        break;
      case 'v':
        __asm { BTI             j; jumptable 000000000004DB1C case 118 }
        v104 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v105 = v104[1];
        if ( (unsigned __int64)(v105 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_143;
        v106 = malloc(0x1000u);
        if ( !v106 )
          goto LABEL_216;
        v105 = 0;
        *v106 = v104;
        v106[1] = 0;
        v104 = v106;
        *(_QWORD *)(a1 + 4912) = v106;
LABEL_143:
        v107 = v105 + 32;
        v30 = (const char **)((char *)v104 + v107);
        v104[1] = v107;
        v31 = *(_WORD *)((_BYTE *)v104 + v107 - 7) & 0xF000 | 0x540;
        v32 = "void";
LABEL_144:
        *((_BYTE *)v30 - 8) = 7;
        v45 = (char *)(v32 + 4);
        goto LABEL_162;
      case 'w':
        __asm { BTI             j; jumptable 000000000004DB1C case 119 }
        v108 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v109 = v108[1];
        if ( (unsigned __int64)(v109 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_148;
        v110 = malloc(0x1000u);
        if ( !v110 )
          goto LABEL_216;
        v109 = 0;
        *v110 = v108;
        v110[1] = 0;
        v108 = v110;
        *(_QWORD *)(a1 + 4912) = v110;
LABEL_148:
        v111 = v109 + 32;
        v30 = (const char **)((char *)v108 + v111);
        v108[1] = v111;
        LOWORD(v111) = *(_WORD *)((char *)v108 + v111 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v111 & 0xF000 | 0x540;
        v32 = "wchar_t";
        v45 = "";
        goto LABEL_162;
      case 'x':
        __asm { BTI             j; jumptable 000000000004DB1C case 120 }
        v112 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v113 = v112[1];
        if ( (unsigned __int64)(v113 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_152;
        v114 = malloc(0x1000u);
        if ( !v114 )
          goto LABEL_216;
        v113 = 0;
        *v114 = v112;
        v114[1] = 0;
        v112 = v114;
        *(_QWORD *)(a1 + 4912) = v114;
LABEL_152:
        v115 = v113 + 32;
        v30 = (const char **)((char *)v112 + v115);
        v112[1] = v115;
        LOWORD(v115) = *(_WORD *)((char *)v112 + v115 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v115 & 0xF000 | 0x540;
        v32 = "long long";
        v45 = "";
        goto LABEL_162;
      case 'y':
        __asm { BTI             j; jumptable 000000000004DB1C case 121 }
        v116 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v117 = v116[1];
        if ( (unsigned __int64)(v117 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_156;
        v118 = malloc(0x1000u);
        if ( !v118 )
          goto LABEL_216;
        v117 = 0;
        *v118 = v116;
        v118[1] = 0;
        v116 = v118;
        *(_QWORD *)(a1 + 4912) = v118;
LABEL_156:
        v119 = v117 + 32;
        v30 = (const char **)((char *)v116 + v119);
        v116[1] = v119;
        LOWORD(v119) = *(_WORD *)((char *)v116 + v119 - 7);
        *((_BYTE *)v30 - 8) = 7;
        v31 = v119 & 0xF000 | 0x540;
        v32 = "unsigned long long";
        v45 = "";
        goto LABEL_162;
      case 'z':
        __asm { BTI             j; jumptable 000000000004DB1C case 122 }
        v120 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v2 + 1;
        v121 = v120[1];
        if ( (unsigned __int64)(v121 - 4048) > 0xFFFFFFFFFFFFF00FLL )
          goto LABEL_160;
        v122 = malloc(0x1000u);
        if ( !v122 )
          goto LABEL_216;
        v121 = 0;
        *v122 = v120;
        v122[1] = 0;
        v120 = v122;
        *(_QWORD *)(a1 + 4912) = v122;
LABEL_160:
        v123 = v121 + 32;
        v30 = (const char **)((char *)v120 + v123);
        v120[1] = v123;
        v31 = *(_WORD *)((_BYTE *)v120 + v123 - 7) & 0xF000 | 0x540;
        v32 = "...";
LABEL_161:
        *((_BYTE *)v30 - 8) = 7;
        v45 = (char *)(v32 + 3);
LABEL_162:
        *(_WORD *)((char *)v30 - 7) = v31;
        *v30 = v32;
        v30[1] = v45;
        *(v30 - 2) = (const char *)off_6FBA8;
        v14 = (unsigned __int8 **)(v30 - 2);
        break;
      default:
        goto LABEL_39;
    }
  }
LABEL_163:
  __asm { BTI             j; jumptable 000000000004DBC0 default case, cases 67-69,71-78,80-83,86-96,98,103,106-109,113,114 }
  return v14;
}
// 4EAE0: control flows out of bounds to 603A0
// 4EB14: control flows out of bounds to 60240
// 4EB48: control flows out of bounds to 522F0
// 4EBF4: control flows out of bounds to 602F0
// 4EC28: control flows out of bounds to 583B8
// 4E8FC: conditional instruction was optimized away because x10.8<2u
// 4E910: variable 'v127' is possibly undefined
// 4EA2C: variable 'v131' is possibly undefined
// 4EC48: variable 'v140' is possibly undefined
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (000000000004ECA0) ----------------------------------------------------
_QWORD *__fastcall sub_4ECA0(__int64 a1, size_t a2)
{
  unsigned __int8 *v2; // x9
  unsigned __int8 *v3; // x10
  int v6; // w8
  unsigned __int8 *v7; // x8
  int v8; // w10
  __int64 v9; // x21
  __int64 *v10; // x8
  _BYTE *v11; // x0
  signed __int64 v12; // x22
  char *v13; // x23
  unsigned __int8 *v14; // x1
  unsigned __int8 *v15; // x8
  _BYTE *v16; // x9
  char v17; // w10
  _BYTE *v18; // x22
  unsigned __int8 **v19; // x3
  unsigned __int64 v20; // x9
  __int64 v25; // x0
  char *v26; // x0
  char *v27; // x23
  _QWORD *v28; // x24
  __int64 v29; // x8
  _QWORD *v30; // x0
  __int64 v31; // x8
  __int64 *v32; // x9
  _QWORD *v33; // x23
  __int64 v34; // x8
  _QWORD *v35; // x0
  __int64 v36; // x8
  _QWORD *v37; // x9
  __int64 *v38; // x8
  _BYTE *v39; // x0
  signed __int64 v40; // x23
  char *v41; // x24
  char *v42; // x0
  __int64 v43; // x8
  unsigned __int8 *v44; // x8
  char *v45; // x0
  char *v46; // x0
  char *v47; // x22
  _QWORD *v48; // x20
  __int64 v49; // x8
  _QWORD *v50; // x0
  __int64 v51; // x8
  __int64 *v52; // x9
  _QWORD *v54; // [xsp+0h] [xbp-10h] BYREF
  __int64 v55; // [xsp+8h] [xbp-8h] BYREF

  v3 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  if ( v2 == *(unsigned __int8 **)a1 )
  {
LABEL_13:
    LOBYTE(v55) = 0;
    v9 = sub_50D98(a1, a2, &v55);
    if ( !v9 )
      return (_QWORD *)v9;
    if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73 )
    {
      if ( !(_BYTE)v55 )
        return (_QWORD *)v9;
      return 0;
    }
    if ( !(_BYTE)v55 )
    {
      v10 = *(__int64 **)(a1 + 304);
      if ( v10 == *(__int64 **)(a1 + 312) )
      {
        v11 = *(_BYTE **)(a1 + 296);
        v12 = (char *)v10 - v11;
        if ( v11 == (_BYTE *)(a1 + 320) )
        {
          v45 = (char *)malloc(2 * ((char *)v10 - v11));
          if ( !v45 )
            goto LABEL_116;
          v13 = v45;
          memcpy(v45, (const void *)(a1 + 320), v12);
          *(_QWORD *)(a1 + 296) = v13;
        }
        else
        {
          v13 = (char *)realloc(v11, 2 * ((char *)v10 - v11));
          *(_QWORD *)(a1 + 296) = v13;
          if ( !v13 )
LABEL_116:
            std::terminate();
        }
        v10 = (__int64 *)&v13[v12];
        *(_QWORD *)(a1 + 312) = &v13[8 * (v12 >> 2)];
      }
      *(_QWORD *)(a1 + 304) = v10 + 1;
      *v10 = v9;
    }
    v46 = sub_50F00((_QWORD *)a1, a2 != 0);
    if ( !v46 )
      return 0;
    v47 = v46;
    if ( a2 )
      *(_BYTE *)(a2 + 1) = 1;
    v48 = *(_QWORD **)(a1 + 4912);
    v49 = v48[1];
    if ( (unsigned __int64)(v49 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v50 = malloc(0x1000u);
      if ( !v50 )
        goto LABEL_116;
      v49 = 0;
      *v50 = v48;
      v50[1] = 0;
      v48 = v50;
      *(_QWORD *)(a1 + 4912) = v50;
    }
    v51 = v49 + 32;
    v52 = (_QWORD *)((char *)v48 + v51);
    v48[1] = v51;
    LOWORD(v51) = *(_WORD *)((char *)v48 + v51 - 7);
    *((_BYTE *)v52 - 8) = 41;
    *v52 = v9;
    v52[1] = (__int64)v47;
    *(v52 - 2) = (__int64)off_71808;
    v9 = (__int64)(v52 - 2);
    *(_WORD *)((char *)v52 - 7) = v51 & 0xF000 | 0x540;
    return (_QWORD *)v9;
  }
  v6 = *v3;
  if ( v6 == 90 )
  {
    *(_QWORD *)a1 = v3 + 1;
    v55 = sub_4CEF0(a1);
    if ( !v55 )
      return 0;
    v15 = *(unsigned __int8 **)a1;
    v14 = *(unsigned __int8 **)(a1 + 8);
    if ( *(unsigned __int8 **)a1 == v14 || *v15 != 69 )
      return 0;
    v16 = v15 + 1;
    *(_QWORD *)a1 = v15 + 1;
    if ( v15 + 1 == v14 )
      goto LABEL_100;
    if ( *v16 == 115 )
    {
      *(_QWORD *)a1 = v15 + 2;
      *(_QWORD *)a1 = sub_5E618(v15 + 2, v14);
      v54 = sub_5E6C8(a1, "string literal");
      return sub_5E778(a1, &v55, (__int64 *)&v54);
    }
    if ( *v16 != 100 )
    {
LABEL_100:
      v54 = (_QWORD *)sub_4ECA0(a1, a2);
      if ( !v54 )
        return 0;
      *(_QWORD *)a1 = sub_5E618(*(unsigned __int8 **)a1, *(unsigned __int8 **)(a1 + 8));
    }
    else
    {
      *(_QWORD *)a1 = v15 + 2;
      sub_4D97C((unsigned __int8 **)a1, 1);
      v44 = *(unsigned __int8 **)a1;
      if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) )
        return 0;
      if ( *v44 != 95 )
        return 0;
      *(_QWORD *)a1 = v44 + 1;
      v54 = (_QWORD *)sub_4ECA0(a1, a2);
      if ( !v54 )
        return 0;
    }
    return sub_5E778(a1, &v55, (__int64 *)&v54);
  }
  if ( v6 != 78 )
    goto LABEL_13;
  v7 = v3 + 1;
  *(_QWORD *)a1 = v3 + 1;
  if ( v3 + 1 == v2 )
  {
    v8 = 0;
    v7 = v2;
    if ( !a2 )
      goto LABEL_35;
    goto LABEL_34;
  }
  if ( *v7 != 114 )
  {
    v8 = 0;
    if ( v7 != v2 )
      goto LABEL_7;
LABEL_32:
    v7 = v2;
    goto LABEL_33;
  }
  v7 = v3 + 2;
  v8 = 4;
  *(_QWORD *)a1 = v7;
  if ( v7 == v2 )
    goto LABEL_32;
LABEL_7:
  if ( *v7 == 86 )
  {
    ++v7;
    v8 |= 2u;
    *(_QWORD *)a1 = v7;
  }
  if ( v7 == v2 )
  {
    v7 = v2;
    if ( !a2 )
      goto LABEL_35;
    goto LABEL_34;
  }
  if ( *v7 == 75 )
  {
    ++v7;
    v8 |= 1u;
    *(_QWORD *)a1 = v7;
    if ( !a2 )
      goto LABEL_35;
    goto LABEL_34;
  }
LABEL_33:
  if ( a2 )
LABEL_34:
    *(_DWORD *)(a2 + 4) = v8;
LABEL_35:
  if ( v7 == v2 )
    goto LABEL_42;
  if ( *v7 == 79 )
  {
    *(_QWORD *)a1 = ++v7;
    if ( a2 )
    {
      v17 = 2;
LABEL_44:
      *(_BYTE *)(a2 + 8) = v17;
      goto LABEL_45;
    }
    goto LABEL_45;
  }
  if ( *v7 != 82 )
  {
LABEL_42:
    if ( a2 )
    {
      v17 = 0;
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  *(_QWORD *)a1 = ++v7;
  if ( a2 )
  {
    v17 = 1;
    goto LABEL_44;
  }
LABEL_45:
  v9 = 0;
  v18 = (_BYTE *)(a1 + 320);
  while ( v7 == v2 || *v7 != 69 )
  {
    if ( a2 )
      *(_BYTE *)(a2 + 1) = 0;
    v19 = 0;
    v20 = v2 - v7;
    if ( v20 )
    {
      switch ( *v7 )
      {
        case 'D':
          __asm { BTI             j; jumptable 000000000004EF30 case 68 }
          if ( v20 < 2 || (v7[1] | 0x20) != 0x74 )
          {
            v19 = 0;
            goto LABEL_78;
          }
          if ( v9 )
            return 0;
          v25 = sub_51900(a1);
          goto LABEL_79;
        case 'I':
          __asm { BTI             j; jumptable 000000000004EF30 case 73 }
          if ( !v9 )
            return (_QWORD *)v9;
          v26 = sub_50F00((_QWORD *)a1, a2 != 0);
          if ( !v26 || *(_BYTE *)(v9 + 8) == 41 )
            return 0;
          v27 = v26;
          if ( a2 )
            *(_BYTE *)(a2 + 1) = 1;
          v28 = *(_QWORD **)(a1 + 4912);
          v29 = v28[1];
          if ( (unsigned __int64)(v29 - 4048) > 0xFFFFFFFFFFFFF00FLL )
            goto LABEL_64;
          v30 = malloc(0x1000u);
          if ( !v30 )
            goto LABEL_116;
          v29 = 0;
          *v30 = v28;
          v30[1] = 0;
          v28 = v30;
          *(_QWORD *)(a1 + 4912) = v30;
LABEL_64:
          v31 = v29 + 32;
          v32 = (_QWORD *)((char *)v28 + v31);
          v28[1] = v31;
          LOWORD(v31) = *(_WORD *)((char *)v28 + v31 - 7);
          *v32 = v9;
          v32[1] = (__int64)v27;
          *(v32 - 2) = (__int64)off_71808;
          v9 = (__int64)(v32 - 2);
          *((_BYTE *)v32 - 8) = 41;
          *(_WORD *)((char *)v32 - 7) = v31 & 0xF000 | 0x540;
          goto LABEL_80;
        case 'S':
          __asm { BTI             j; jumptable 000000000004EF30 case 83 }
          if ( v20 >= 2 && v7[1] == 116 )
          {
            v33 = *(_QWORD **)(a1 + 4912);
            *(_QWORD *)a1 = v7 + 2;
            v34 = v33[1];
            if ( (unsigned __int64)(v34 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
            {
              v35 = malloc(0x1000u);
              if ( !v35 )
                goto LABEL_116;
              v34 = 0;
              *v35 = v33;
              v35[1] = 0;
              v33 = v35;
              *(_QWORD *)(a1 + 4912) = v35;
            }
            v36 = v34 + 32;
            v37 = (_QWORD *)((char *)v33 + v36);
            v33[1] = v36;
            LOWORD(v36) = *(_WORD *)((char *)v33 + v36 - 7);
            *((_BYTE *)v37 - 8) = 7;
            *v37 = "std";
            v37[1] = "";
            *(_WORD *)((char *)v37 - 7) = v36 & 0xF000 | 0x540;
            *(v37 - 2) = off_6FBA8;
            v19 = (unsigned __int8 **)(v37 - 2);
          }
          else
          {
            v19 = sub_51A40(a1);
            if ( !v19 )
              return 0;
          }
          if ( *((_BYTE *)v19 + 8) == 25 )
            goto LABEL_78;
          if ( v9 )
            return 0;
          v7 = *(unsigned __int8 **)a1;
          v2 = *(unsigned __int8 **)(a1 + 8);
          v9 = (__int64)v19;
          break;
        case 'T':
          __asm { BTI             j; jumptable 000000000004EF30 case 84 }
          if ( v9 )
            return 0;
          v25 = (__int64)sub_5158C(a1, a2);
          goto LABEL_79;
        default:
          goto LABEL_78;
      }
    }
    else
    {
LABEL_78:
      __asm { BTI             j; jumptable 000000000004EF30 default case, cases 69-72,74-82 }
      v25 = sub_51CFC(a1, a2, v9, v19);
LABEL_79:
      v9 = v25;
      if ( !v25 )
        return (_QWORD *)v9;
LABEL_80:
      v38 = *(__int64 **)(a1 + 304);
      if ( v38 == *(__int64 **)(a1 + 312) )
      {
        v39 = *(_BYTE **)(a1 + 296);
        v40 = (char *)v38 - v39;
        if ( v39 == v18 )
        {
          v42 = (char *)malloc(2 * ((char *)v38 - v39));
          if ( !v42 )
            goto LABEL_116;
          v41 = v42;
          memcpy(v42, (const void *)(a1 + 320), v40);
          *(_QWORD *)(a1 + 296) = v41;
        }
        else
        {
          v41 = (char *)realloc(v39, 2 * ((char *)v38 - v39));
          *(_QWORD *)(a1 + 296) = v41;
          if ( !v41 )
            goto LABEL_116;
        }
        v38 = (__int64 *)&v41[v40];
        *(_QWORD *)(a1 + 312) = &v41[8 * (v40 >> 2)];
      }
      *(_QWORD *)(a1 + 304) = v38 + 1;
      *v38 = v9;
      v7 = *(unsigned __int8 **)a1;
      v2 = *(unsigned __int8 **)a1;
      if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
      {
        v2 = *(unsigned __int8 **)(a1 + 8);
        if ( *v7 == 77 )
        {
          ++v7;
          v2 = *(unsigned __int8 **)(a1 + 8);
          *(_QWORD *)a1 = v7;
        }
      }
    }
  }
  *(_QWORD *)a1 = v7 + 1;
  if ( v9 )
  {
    v43 = *(_QWORD *)(a1 + 304);
    if ( *(_QWORD *)(a1 + 296) != v43 )
    {
      *(_QWORD *)(a1 + 304) = v43 - 8;
      return (_QWORD *)v9;
    }
    return 0;
  }
  return (_QWORD *)v9;
}
// 4F0A0: variable 'a2' is possibly undefined
// 4CEF0: using guessed type __int64 __fastcall sub_4CEF0(_QWORD);
// 50D98: using guessed type __int64 __fastcall sub_50D98(_QWORD, _QWORD, _QWORD);
// 51CFC: using guessed type __int64 __fastcall sub_51CFC(_QWORD, _QWORD, _QWORD, _QWORD);
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 71808: using guessed type __int64 (__fastcall *off_71808[10])();

//----- (000000000004F358) ----------------------------------------------------
char *__fastcall sub_4F358(_QWORD *a1)
{
  unsigned __int8 *v1; // x8
  unsigned __int8 *v2; // x9
  int v4; // w11
  char *result; // x0
  unsigned __int8 *v6; // x8
  __int64 v7; // x10
  __int64 v8; // x11
  unsigned __int8 *v9; // x8
  _QWORD *v10; // x21
  unsigned __int64 v11; // x20
  char *v12; // x24
  char *v13; // x8
  char *v14; // x22
  _BYTE *v15; // x0
  signed __int64 v16; // x23
  char *v17; // x0
  char *v18; // x0
  _QWORD *v19; // x22
  char *v20; // x20
  char *v21; // x1
  char *v22; // x21
  __int64 v23; // x8
  _QWORD *v24; // x0
  __int64 v25; // x8
  char **v26; // x9

  v1 = (unsigned __int8 *)*a1;
  v2 = (unsigned __int8 *)a1[1];
  if ( v2 == (unsigned __int8 *)*a1 )
    return (char *)sub_4DAC4(a1);
  v4 = *v1;
  if ( v4 == 74 )
  {
    v7 = a1[2];
    v8 = a1[3];
    v9 = v1 + 1;
    v10 = a1 + 5;
    *a1 = v9;
    v11 = (v8 - v7) >> 3;
    while ( v9 == v2 || *v9 != 69 )
    {
      result = (char *)sub_4F358(a1);
      if ( !result )
        return result;
      v13 = (char *)a1[3];
      v14 = result;
      if ( v13 == (char *)a1[4] )
      {
        v15 = (_BYTE *)a1[2];
        v16 = v13 - v15;
        if ( v15 == (_BYTE *)v10 )
        {
          v17 = (char *)malloc(2 * (v13 - v15));
          if ( !v17 )
            goto LABEL_34;
          v12 = v17;
          memcpy(v17, a1 + 5, v16);
          a1[2] = v12;
        }
        else
        {
          v12 = (char *)realloc(v15, 2 * (v13 - v15));
          a1[2] = v12;
          if ( !v12 )
            goto LABEL_34;
        }
        v13 = &v12[v16];
        a1[4] = &v12[8 * (v16 >> 2)];
      }
      a1[3] = v13 + 8;
      *(_QWORD *)v13 = v14;
      v9 = (unsigned __int8 *)*a1;
      v2 = (unsigned __int8 *)a1[1];
    }
    *a1 = v9 + 1;
    v18 = sub_4F750(a1, v11);
    v19 = (_QWORD *)a1[614];
    v20 = v18;
    v22 = v21;
    v23 = v19[1];
    if ( (unsigned __int64)(v23 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v24 = malloc(0x1000u);
      if ( !v24 )
LABEL_34:
        std::terminate();
      v23 = 0;
      *v24 = v19;
      v24[1] = 0;
      v19 = v24;
      a1[614] = v24;
    }
    v25 = v23 + 32;
    v26 = (char **)((char *)v19 + v25);
    v19[1] = v25;
    LOWORD(v25) = *(_WORD *)((char *)v19 + v25 - 7);
    *((_BYTE *)v26 - 8) = 37;
    *v26 = v20;
    v26[1] = v22;
    *(_WORD *)((char *)v26 - 7) = v25 & 0xF000 | 0x540;
    *(v26 - 2) = (char *)off_71878;
    return (char *)(v26 - 2);
  }
  if ( v4 != 76 )
  {
    if ( v4 == 88 )
    {
      *a1 = v1 + 1;
      result = sub_52694((__int64)a1);
      if ( result )
      {
        v6 = (unsigned __int8 *)*a1;
        if ( *a1 != a1[1] )
        {
          if ( *v6 != 69 )
            return 0;
          goto LABEL_26;
        }
        return 0;
      }
      return result;
    }
    return (char *)sub_4DAC4(a1);
  }
  if ( (unsigned __int64)&v2[-*a1] < 2 || v1[1] != 90 )
    JUMPOUT(0x53E00);
  *a1 = v1 + 2;
  result = (char *)sub_4CEF0(a1);
  if ( result )
  {
    v6 = (unsigned __int8 *)*a1;
    if ( *a1 != a1[1] && *v6 == 69 )
    {
LABEL_26:
      *a1 = v6 + 1;
      return result;
    }
    return 0;
  }
  return result;
}
// 4F530: control flows out of bounds to 53E00
// 4F550: variable 'v21' is possibly undefined
// 4CEF0: using guessed type __int64 __fastcall sub_4CEF0(_QWORD);
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 71878: using guessed type __int64 (__fastcall *off_71878[10])();

//----- (000000000004F5F4) ----------------------------------------------------
_QWORD *__fastcall sub_4F5F4(_QWORD *result, __int64 *size)
{
  char *v2; // x8
  _QWORD *v3; // x19
  const void *v5; // x23
  signed __int64 v6; // x21
  char *v7; // x22
  char *v8; // x0
  __int64 v9; // x10

  v2 = (char *)result[1];
  v3 = result;
  if ( v2 == (char *)result[2] )
  {
    v5 = (const void *)*result;
    v6 = (signed __int64)&v2[-*result];
    if ( (_QWORD *)*result == result + 3 )
    {
      v8 = (char *)malloc(2 * v6);
      if ( !v8 )
        goto LABEL_9;
      v7 = v8;
      result = memmove(v8, v5, v6);
      *v3 = v7;
    }
    else
    {
      result = realloc((void *)*result, 2 * v6);
      v7 = (char *)result;
      *v3 = result;
      if ( !result )
LABEL_9:
        std::terminate();
    }
    v2 = &v7[v6];
    v3[1] = &v7[v6];
    v3[2] = &v7[8 * (v6 >> 2)];
  }
  v9 = *size;
  v3[1] = v2 + 8;
  *(_QWORD *)v2 = v9;
  return result;
}

//----- (000000000004F6AC) ----------------------------------------------------
_OWORD *__fastcall sub_4F6AC(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _OWORD *v8; // x9
  __int128 v9; // q0
  _OWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_OWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  v9 = *a2;
  *((_BYTE *)v8 - 8) = 9;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *((_QWORD *)v8 - 2) = off_718E8;
  result = v8 - 1;
  *v8 = v9;
  return result;
}
// 718E8: using guessed type __int64 (__fastcall *off_718E8[10])();

//----- (000000000004F750) ----------------------------------------------------
char *__fastcall sub_4F750(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x9
  _QWORD *v4; // x24
  const void *v5; // x22
  size_t v6; // x21
  __int64 v9; // x8
  unsigned __int64 v10; // x23
  _QWORD *v11; // x0
  char *v12; // x23
  _QWORD *v13; // x0
  __int64 v14; // x9
  __int64 v15; // x8
  char *result; // x0

  v2 = a1[2];
  v3 = a1[3];
  if ( a2 > (v3 - v2) >> 3 )
  {
    __assert2(
      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
      2470,
      "NodeArray (anonymous namespace)::itanium_demangle::AbstractManglingParser<(anonymous namespace)::itanium_demangle:"
      ":ManglingParser<(anonymous namespace)::DefaultAllocator>, (anonymous namespace)::DefaultAllocator>::popTrailingNod"
      "eArray(size_t) [Derived = (anonymous namespace)::itanium_demangle::ManglingParser<(anonymous namespace)::DefaultAl"
      "locator>, Alloc = (anonymous namespace)::DefaultAllocator]",
      "FromPosition <= Names.size()");
    goto LABEL_12;
  }
  v4 = (_QWORD *)a1[614];
  v5 = (const void *)(v2 + 8 * a2);
  v6 = v3 - (_QWORD)v5;
  v9 = v4[1];
  v10 = ((_DWORD)v3 - (_DWORD)v5 + 15) & 0xFFFFFFF0;
  if ( v9 + v10 < 0xFF0 )
    goto LABEL_8;
  if ( v10 < 0xFF1 )
  {
    v13 = malloc(0x1000u);
    if ( !v13 )
      goto LABEL_13;
    v9 = 0;
    *v13 = v4;
    v13[1] = 0;
    v4 = v13;
    a1[614] = v13;
LABEL_8:
    v14 = v9 + v10;
    v12 = (char *)v4 + v9 + 16;
    v4[1] = v14;
    goto LABEL_9;
  }
  v11 = malloc(v10 + 16);
  if ( !v11 )
    goto LABEL_13;
  v12 = (char *)(v11 + 2);
  *v11 = *v4;
  v11[1] = 0;
  *v4 = v11;
LABEL_9:
  memmove(v12, v5, v6);
  v15 = a1[2];
  if ( a2 > (a1[3] - v15) >> 3 )
  {
LABEL_12:
    __assert2(
      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
      129,
      "void (anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_demangle::Node *, 32>:"
      ":dropBack(size_t) [T = (anonymous namespace)::itanium_demangle::Node *, N = 32]",
      "Index <= size() && \"dropBack() can't expand!\"");
LABEL_13:
    std::terminate();
  }
  result = v12;
  a1[3] = v15 + 8 * a2;
  return result;
}
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004F884) ----------------------------------------------------
char *__fastcall sub_4F884(__int64 a1, __int64 *a2, __int64 *a3, __int128 *a4, __int64 *a5, int *a6, char *a7)
{
  _QWORD *v7; // x26
  __int64 v13; // x8
  _QWORD *v16; // x0
  __int64 v17; // x8
  __int64 v18; // x10
  char *v19; // x9
  __int64 v20; // x8
  __int128 v21; // q0
  int v22; // w13
  __int16 v23; // w11
  char v24; // w14
  __int64 v25; // x12
  char *result; // x0

  v7 = *(_QWORD **)(a1 + 4912);
  v13 = v7[1];
  if ( (unsigned __int64)(v13 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v16 = malloc(0x1000u);
    if ( !v16 )
      std::terminate();
    v13 = 0;
    *v16 = v7;
    v16[1] = 0;
    v7 = v16;
    *(_QWORD *)(a1 + 4912) = v16;
  }
  v17 = v13 + 64;
  v18 = *a2;
  v19 = (char *)v7 + v17;
  v7[1] = v17;
  v20 = *a3;
  v21 = *a4;
  v22 = *a6;
  v23 = *(_WORD *)(v19 - 39) & 0xF000;
  v24 = *a7;
  *(v19 - 40) = 18;
  v25 = *a5;
  *((_QWORD *)v19 - 4) = v18;
  *((_QWORD *)v19 - 3) = v20;
  *(_WORD *)(v19 - 39) = v23 | 0x100;
  *((_OWORD *)v19 - 1) = v21;
  *((_QWORD *)v19 - 6) = off_71958;
  result = v19 - 48;
  *(_QWORD *)v19 = v25;
  *((_DWORD *)v19 + 2) = v22;
  v19[12] = v24;
  return result;
}
// 71958: using guessed type __int64 (__fastcall *off_71958[10])();

//----- (000000000004F96C) ----------------------------------------------------
void __fastcall sub_4F96C(_QWORD *a1)
{
  _QWORD *v1; // x1
  _QWORD *v2; // x23
  _QWORD *v4; // x22
  char *v5; // x20
  char *v6; // x21
  __int64 v7; // x8
  __int64 v8; // x9
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x8
  _QWORD *v12; // x24
  _QWORD *v13; // x23
  _QWORD *v14; // x1
  char *v15; // x20
  char *v16; // x21
  __int64 v17; // x8
  __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x9
  _QWORD *v21; // x0
  _QWORD *v22; // x0

  v2 = (_QWORD *)*a1;
  v1 = (_QWORD *)a1[1];
  v4 = a1 + 4;
  v5 = *(char **)(*a1 + 664LL);
  v6 = (char *)(*a1 + 688LL);
  if ( v1 == a1 + 4 )
  {
    if ( v5 != v6 )
    {
      free(*(void **)(*a1 + 664LL));
      v2[83] = v6;
      v1 = (_QWORD *)a1[1];
      v5 = v6;
      v2[84] = v6;
      v2[85] = v2 + 90;
    }
    memmove(v6, v1, a1[2] - (_QWORD)v1);
    v11 = a1[1];
    v2[84] = &v5[a1[2] - v11];
    goto LABEL_7;
  }
  v2[83] = v1;
  if ( v5 != v6 )
  {
    v7 = a1[2];
    a1[1] = v5;
    v8 = v2[84];
    v2[84] = v7;
    v9 = a1[3];
    a1[2] = v8;
    v10 = v2[85];
    v2[85] = v9;
    v11 = a1[1];
    a1[3] = v10;
LABEL_7:
    a1[2] = v11;
    goto LABEL_9;
  }
  *((_OWORD *)v2 + 42) = *((_OWORD *)a1 + 1);
  a1[1] = v4;
  a1[2] = v4;
  a1[3] = a1 + 8;
LABEL_9:
  v12 = (_QWORD *)*a1;
  v13 = a1 + 11;
  v14 = (_QWORD *)a1[8];
  v15 = *(char **)(*a1 + 576LL);
  v16 = (char *)(*a1 + 600LL);
  if ( v14 == a1 + 11 )
  {
    if ( v15 != v16 )
    {
      free(*(void **)(*a1 + 576LL));
      v12[72] = v16;
      v14 = (_QWORD *)a1[8];
      v15 = v16;
      v12[73] = v16;
      v12[74] = v12 + 83;
    }
    memmove(v16, v14, a1[9] - (_QWORD)v14);
    v21 = (_QWORD *)a1[8];
    v12[73] = &v15[a1[9] - (_QWORD)v21];
    a1[9] = v21;
    if ( v21 == v13 )
    {
LABEL_17:
      v22 = (_QWORD *)a1[1];
      if ( v22 == v4 )
        return;
      goto LABEL_18;
    }
LABEL_16:
    free(v21);
    goto LABEL_17;
  }
  v12[72] = v14;
  if ( v15 != v16 )
  {
    v17 = a1[9];
    a1[8] = v15;
    v18 = v12[73];
    v12[73] = v17;
    v19 = a1[10];
    a1[9] = v18;
    v20 = v12[74];
    v12[74] = v19;
    v21 = (_QWORD *)a1[8];
    a1[9] = v21;
    a1[10] = v20;
    if ( v21 == v13 )
      goto LABEL_17;
    goto LABEL_16;
  }
  *(_OWORD *)(v12 + 73) = *(_OWORD *)(a1 + 9);
  a1[8] = v13;
  a1[9] = v13;
  a1[10] = a1 + 19;
  v22 = (_QWORD *)a1[1];
  if ( v22 != v4 )
LABEL_18:
    free(v22);
}

//----- (000000000004FB50) ----------------------------------------------------
_QWORD *__fastcall sub_4FB50(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "template parameter object for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004FC04) ----------------------------------------------------
_QWORD *__fastcall sub_4FC04(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "vtable for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004FCB8) ----------------------------------------------------
_QWORD *__fastcall sub_4FCB8(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "VTT for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004FD6C) ----------------------------------------------------
_QWORD *__fastcall sub_4FD6C(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "typeinfo for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004FE20) ----------------------------------------------------
_QWORD *__fastcall sub_4FE20(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "typeinfo name for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (000000000004FED4) ----------------------------------------------------
__int64 __fastcall sub_4FED4(__int64 a1)
{
  _BYTE *v1; // x8
  _BYTE *v2; // x9
  _BYTE *v3; // x11
  _BYTE *v4; // x10
  unsigned int v5; // w8
  _BYTE *v6; // x10
  _BYTE *v7; // x11
  _BYTE *v9; // x12

  v1 = *(_BYTE **)a1;
  v2 = *(_BYTE **)(a1 + 8);
  if ( *(_BYTE **)a1 == v2 )
    return 1;
  if ( *v1 != 104 )
  {
    if ( *v1 == 118 )
    {
      v6 = v1 + 1;
      *(_QWORD *)a1 = v1 + 1;
      if ( v1 + 1 != v2 )
      {
        v7 = v1 + 1;
        if ( *v6 == 110 )
        {
          v7 = v1 + 2;
          *(_QWORD *)a1 = v1 + 2;
        }
        if ( v2 != v7 && (unsigned int)(unsigned __int8)*v7 - 58 >= 0xFFFFFFF6 )
        {
          while ( (unsigned int)(unsigned __int8)*v7 - 58 >= 0xFFFFFFF6 )
          {
            *(_QWORD *)a1 = ++v7;
            if ( v7 == v2 )
            {
              v7 = v2;
              break;
            }
          }
          v5 = 1;
          if ( v6 == v7 || v7 == v2 )
            return v5;
          if ( *v7 == 95 )
          {
            v9 = v7 + 1;
            *(_QWORD *)a1 = v7 + 1;
            if ( v7 + 1 != v2 )
            {
              v4 = v7 + 1;
              if ( *v9 == 110 )
              {
                v4 = v7 + 2;
                *(_QWORD *)a1 = v7 + 2;
              }
              if ( v2 != v4 && (unsigned int)(unsigned __int8)*v4 - 58 >= 0xFFFFFFF6 )
              {
                while ( (unsigned int)(unsigned __int8)*v4 - 58 >= 0xFFFFFFF6 )
                {
                  *(_QWORD *)a1 = ++v4;
                  if ( v4 == v2 )
                  {
                    v4 = v2;
                    break;
                  }
                }
                v5 = 1;
                if ( v9 == v4 || v4 == v2 )
                  return v5;
                if ( *v4 == 95 )
                  goto LABEL_14;
              }
            }
          }
        }
      }
    }
    return 1;
  }
  v3 = v1 + 1;
  *(_QWORD *)a1 = v1 + 1;
  if ( v1 + 1 == v2 )
    return 1;
  v4 = v1 + 1;
  if ( *v3 == 110 )
  {
    v4 = v1 + 2;
    *(_QWORD *)a1 = v1 + 2;
  }
  if ( v2 == v4 || (unsigned int)(unsigned __int8)*v4 - 58 < 0xFFFFFFF6 )
    return 1;
  while ( (unsigned int)(unsigned __int8)*v4 - 58 >= 0xFFFFFFF6 )
  {
    *(_QWORD *)a1 = ++v4;
    if ( v4 == v2 )
    {
      v4 = v2;
      break;
    }
  }
  v5 = 1;
  if ( v3 == v4 || v4 == v2 )
    return v5;
  if ( *v4 != 95 )
    return 1;
LABEL_14:
  v5 = 0;
  *(_QWORD *)a1 = v4 + 1;
  return v5;
}

//----- (00000000000500AC) ----------------------------------------------------
_QWORD *__fastcall sub_500AC(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "covariant return thunk to ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (0000000000050160) ----------------------------------------------------
_QWORD *__fastcall sub_50160(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x11
  _QWORD *result; // x0
  __int64 v13; // x10

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *((_BYTE *)v10 - 8) = 21;
  v11 = *a3;
  *(v10 - 2) = off_6FB38;
  result = v10 - 2;
  v13 = *a2;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x540;
  *v10 = v13;
  v10[1] = v11;
  return result;
}
// 6FB38: using guessed type __int64 (__fastcall *off_6FB38[10])();

//----- (000000000005020C) ----------------------------------------------------
_QWORD *__fastcall sub_5020C(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "thread-local initialization routine for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (00000000000502C0) ----------------------------------------------------
_QWORD *__fastcall sub_502C0(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "virtual thunk to ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (0000000000050374) ----------------------------------------------------
_QWORD *__fastcall sub_50374(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "non-virtual thunk to ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (0000000000050428) ----------------------------------------------------
_QWORD *__fastcall sub_50428(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x11

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 20;
  *(v8 - 4) = off_6FAB8;
  result = v8 - 4;
  v10 = *a2;
  *(v8 - 2) = "reference temporary for ";
  *(v8 - 1) = "";
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 6FAB8: using guessed type __int64 (__fastcall *off_6FAB8[10])();

//----- (00000000000504DC) ----------------------------------------------------
__int64 __fastcall sub_504DC(__int64 a1, __int64 *a2)
{
  const char *v2; // x8
  const char *v3; // x9
  _BYTE *v6; // x21
  __int64 v7; // x8
  _QWORD *v8; // x27
  __int64 v9; // x8
  __int64 v10; // x10
  char *v11; // x9
  char *v12; // x27
  char *v13; // x8
  char v14; // w23
  __int64 v15; // x0
  __int64 v16; // x22
  _QWORD *v17; // x0
  _BYTE *v18; // x0
  signed __int64 v19; // x22
  char *v20; // x23
  char *v21; // x0

  v2 = *(const char **)a1;
  v3 = *(const char **)(a1 + 8);
  if ( *(const char **)a1 != v3 )
  {
    v6 = (_BYTE *)(a1 + 320);
    while ( *v2 == 87 )
    {
      *(_QWORD *)a1 = v2 + 1;
      if ( v2 + 1 == v3 || v2[1] != 80 )
      {
        v14 = 0;
        v15 = sub_50964((const char **)a1);
        if ( !v15 )
          return 1;
      }
      else
      {
        v14 = 1;
        *(_QWORD *)a1 = v2 + 2;
        v15 = sub_50964((const char **)a1);
        if ( !v15 )
          return 1;
      }
      v8 = *(_QWORD **)(a1 + 4912);
      v16 = v15;
      v7 = v8[1];
      if ( (unsigned __int64)(v7 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v17 = malloc(0x1000u);
        if ( !v17 )
          goto LABEL_23;
        v7 = 0;
        *v17 = v8;
        v17[1] = 0;
        v8 = v17;
        *(_QWORD *)(a1 + 4912) = v17;
      }
      v9 = v7 + 48;
      v10 = *a2;
      v11 = (char *)v8 + v9;
      v8[1] = v9;
      LOWORD(v9) = *(_WORD *)((char *)v8 + v9 - 23);
      *((_QWORD *)v11 - 2) = v10;
      *((_QWORD *)v11 - 1) = v16;
      *(v11 - 24) = 25;
      *((_QWORD *)v11 - 4) = off_6FC18;
      v12 = v11 - 32;
      *v11 = v14;
      *(_WORD *)(v11 - 23) = v9 & 0xF000 | 0x540;
      *a2 = (__int64)(v11 - 32);
      v13 = *(char **)(a1 + 304);
      if ( v13 == *(char **)(a1 + 312) )
      {
        v18 = *(_BYTE **)(a1 + 296);
        v19 = v13 - v18;
        if ( v18 == v6 )
        {
          v21 = (char *)malloc(2 * (v13 - v18));
          if ( !v21 )
LABEL_23:
            std::terminate();
          v20 = v21;
          memcpy(v21, v6, v19);
          *(_QWORD *)(a1 + 296) = v20;
        }
        else
        {
          v20 = (char *)realloc(v18, 2 * (v13 - v18));
          *(_QWORD *)(a1 + 296) = v20;
          if ( !v20 )
            goto LABEL_23;
        }
        *(_QWORD *)(a1 + 304) = &v20[v19 + 8];
        *(_QWORD *)(a1 + 312) = &v20[8 * (v19 >> 2)];
        *(_QWORD *)&v20[v19] = v12;
        v2 = *(const char **)a1;
        v3 = *(const char **)(a1 + 8);
        if ( *(const char **)a1 == v3 )
          return 0;
      }
      else
      {
        *(_QWORD *)(a1 + 304) = v13 + 8;
        *(_QWORD *)v13 = v12;
        v2 = *(const char **)a1;
        v3 = *(const char **)(a1 + 8);
        if ( *(const char **)a1 == v3 )
          return 0;
      }
    }
  }
  return 0;
}
// 6FC18: using guessed type __int64 (__fastcall *off_6FC18[10])();

//----- (00000000000506AC) ----------------------------------------------------
__int64 sub_506AC()
{
  return 0;
}

//----- (00000000000506B8) ----------------------------------------------------
__int64 sub_506B8()
{
  return 0;
}

//----- (00000000000506C4) ----------------------------------------------------
__int64 sub_506C4()
{
  return 0;
}

//----- (00000000000506D0) ----------------------------------------------------
void sub_506D0()
{
  ;
}

//----- (00000000000506D8) ----------------------------------------------------
__int64 __fastcall sub_506D8(_QWORD *a1, void **a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x22
  size_t v6; // x21
  char *v7; // x8
  size_t v8; // x9
  char *v9; // x10
  unsigned __int64 v10; // x9
  void *v11; // x0
  size_t v12; // x1
  char *v13; // x0
  __int64 v14; // x20
  __int64 result; // x0

  v3 = (_BYTE *)a1[2];
  v2 = (_BYTE *)a1[3];
  v6 = v2 - v3;
  if ( v2 != v3 )
  {
    v7 = (char *)a2[1];
    v8 = (size_t)a2[2];
    v9 = &v7[v6];
    if ( (unsigned __int64)&v7[v6] <= v8 )
    {
      v13 = (char *)*a2;
    }
    else
    {
      v10 = 2 * v8;
      v11 = *a2;
      if ( v10 <= (unsigned __int64)(v9 + 992) )
        v12 = (size_t)(v9 + 992);
      else
        v12 = v10;
      a2[2] = (void *)v12;
      v13 = (char *)realloc(v11, v12);
      *a2 = v13;
      if ( !v13 )
        std::terminate();
      v7 = (char *)a2[1];
    }
    memcpy(&v7[(_QWORD)v13], v3, v6);
    a2[1] = (char *)a2[1] + v6;
  }
  v14 = a1[4];
  result = (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)v14 + 32LL))(v14, a2);
  if ( (*(_WORD *)(v14 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)v14 + 40LL))(v14, a2);
  return result;
}

//----- (00000000000507C0) ----------------------------------------------------
void sub_507C0()
{
  ;
}

//----- (00000000000507C8) ----------------------------------------------------
__int64 sub_507C8()
{
  return 0;
}

//----- (00000000000507D8) ----------------------------------------------------
void __fastcall sub_507D8(void *a1)
{
  operator delete(a1);
}

//----- (00000000000507E0) ----------------------------------------------------
__int64 __fastcall sub_507E0(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 *v11; // x21
  __int64 v12; // x9
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  void *v17; // x0
  size_t v18; // x1
  char *v19; // x0
  __int64 *v20; // x20
  __int64 v21; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 24) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1016);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_19;
    v2 = (char *)a2[1];
  }
  qmemcpy(&v2[(_QWORD)v10], "construction vtable for ", 24);
  v11 = *(__int64 **)(a1 + 16);
  v12 = *v11;
  a2[1] = (char *)a2[1] + 24;
  (*(void (__fastcall **)(__int64 *, void **))(v12 + 32))(v11, a2);
  if ( (*(_WORD *)((_BYTE *)v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, void **))(*v11 + 40))(v11, a2);
  v13 = (char *)a2[1];
  v14 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v13 + 4) > v14 )
  {
    v15 = (size_t)(v13 + 996);
    v16 = 2 * v14;
    v17 = *a2;
    if ( v16 <= v15 )
      v18 = v15;
    else
      v18 = v16;
    a2[2] = (void *)v18;
    v19 = (char *)realloc(v17, v18);
    *a2 = v19;
    if ( v19 )
    {
      v13 = (char *)a2[1];
      goto LABEL_17;
    }
LABEL_19:
    std::terminate();
  }
  v19 = (char *)*a2;
LABEL_17:
  *(_DWORD *)&v13[(_QWORD)v19] = 762210605;
  v20 = *(__int64 **)(a1 + 24);
  v21 = *v20;
  a2[1] = (char *)a2[1] + 4;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v21 + 32))(v20, a2);
  if ( (*(_WORD *)((_BYTE *)v20 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v20 + 40))(v20, a2);
  return result;
}

//----- (000000000005095C) ----------------------------------------------------
void __fastcall sub_5095C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000050964) ----------------------------------------------------
__int64 __fastcall sub_50964(const char **a1)
{
  const char *v1; // x8
  const char *v2; // x11
  signed __int64 v3; // x10
  __int64 v5; // x16
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x15
  const char *v8; // x20
  __int64 v9; // x12
  __int64 v10; // x14
  char *v11; // x21
  unsigned __int8 *v12; // x22
  __int64 v13; // x8
  unsigned __int8 *v14; // x0
  __int64 v15; // x8
  const char **v16; // x0
  __int16 v17; // w9
  __int64 v19; // x8
  unsigned __int8 *v20; // x0

  v1 = *a1;
  v2 = a1[1];
  v3 = v2 - *a1;
  if ( v2 != *a1 && (unsigned int)*(unsigned __int8 *)v1 - 58 >= 0xFFFFFFF6 )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = v6;
      v8 = &v1[v5 + 1];
      v9 = v5;
      *a1 = v8;
      v10 = (unsigned __int8)v1[v5];
      v6 = v10 + 10 * v6 - 48;
      if ( v8 == v2 )
        break;
      ++v5;
    }
    while ( (unsigned int)*(unsigned __int8 *)v8 - 48 <= 9 );
    if ( v6 - 1 < ~v9 + v3 )
    {
      v11 = (char *)&v1[10 * v7 - 47 + v9 + v10];
      *a1 = v11;
      if ( v6 < 0xA || strncmp("_GLOBAL__N", v8, 0xAu) )
      {
        v12 = (unsigned __int8 *)a1[614];
        v13 = *((_QWORD *)v12 + 1);
        if ( (unsigned __int64)(v13 - 4048) > 0xFFFFFFFFFFFFF00FLL )
        {
LABEL_12:
          v15 = v13 + 32;
LABEL_13:
          *((_QWORD *)v12 + 1) = v15;
          v16 = (const char **)&v12[v15];
          v17 = *(_WORD *)&v12[v15 - 7];
          *v16 = v8;
          v16[1] = v11;
          *((_BYTE *)v16 - 8) = 7;
          *(_WORD *)((char *)v16 - 7) = v17 & 0xF000 | 0x540;
          *(v16 - 2) = (const char *)off_6FBA8;
          return (__int64)&v12[v15 - 16];
        }
        v14 = (unsigned __int8 *)malloc(0x1000u);
        if ( v14 )
        {
          v13 = 0;
          *(_QWORD *)v14 = v12;
          *((_QWORD *)v14 + 1) = 0;
          v12 = v14;
          a1[614] = (const char *)v14;
          goto LABEL_12;
        }
LABEL_19:
        std::terminate();
      }
      v12 = (unsigned __int8 *)a1[614];
      v19 = *((_QWORD *)v12 + 1);
      if ( (unsigned __int64)(v19 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v20 = (unsigned __int8 *)malloc(0x1000u);
        if ( !v20 )
          goto LABEL_19;
        v19 = 0;
        *(_QWORD *)v20 = v12;
        *((_QWORD *)v20 + 1) = 0;
        v12 = v20;
        a1[614] = (const char *)v20;
      }
      v8 = "(anonymous namespace)";
      v15 = v19 + 32;
      v11 = "";
      goto LABEL_13;
    }
  }
  return 0;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (0000000000050B10) ----------------------------------------------------
_OWORD *__fastcall sub_50B10(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _OWORD *v8; // x9
  __int128 v9; // q0
  _OWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_OWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  v9 = *a2;
  *((_BYTE *)v8 - 8) = 7;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *((_QWORD *)v8 - 2) = off_6FBA8;
  result = v8 - 1;
  *v8 = v9;
  return result;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (0000000000050BB4) ----------------------------------------------------
_QWORD *__fastcall sub_50BB4(_QWORD *result, void **a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x21
  size_t v4; // x20
  char *v5; // x8
  size_t v6; // x9
  char *v8; // x10
  unsigned __int64 v9; // x9
  void *v10; // x0
  size_t v11; // x1
  char *v12; // x0

  v3 = (_BYTE *)result[2];
  v2 = (_BYTE *)result[3];
  v4 = v2 - v3;
  if ( v2 != v3 )
  {
    v5 = (char *)a2[1];
    v6 = (size_t)a2[2];
    v8 = &v5[v4];
    if ( (unsigned __int64)&v5[v4] <= v6 )
    {
      v12 = (char *)*a2;
    }
    else
    {
      v9 = 2 * v6;
      v10 = *a2;
      if ( v9 <= (unsigned __int64)(v8 + 992) )
        v11 = (size_t)(v8 + 992);
      else
        v11 = v9;
      a2[2] = (void *)v11;
      v12 = (char *)realloc(v10, v11);
      *a2 = v12;
      if ( !v12 )
        std::terminate();
      v5 = (char *)a2[1];
    }
    result = memcpy(&v5[(_QWORD)v12], v3, v4);
    a2[1] = (char *)a2[1] + v4;
  }
  return result;
}

//----- (0000000000050C4C) ----------------------------------------------------
__int64 __fastcall sub_50C4C(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (0000000000050C5C) ----------------------------------------------------
void __fastcall sub_50C5C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000050C64) ----------------------------------------------------
__int64 __fastcall sub_50C64(__int64 a1, _QWORD *a2)
{
  __int64 v3; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x10
  char v7; // w21
  __int64 v8; // x9
  unsigned __int64 v9; // x8
  _BYTE *v10; // x0
  size_t v11; // x1
  _BYTE *v12; // x0
  __int64 v13; // x20
  __int64 result; // x0

  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v3 + 32LL))(*(_QWORD *)(a1 + 16), a2);
    if ( (*(_WORD *)(v3 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v3 + 40LL))(v3, a2);
  }
  if ( *(_QWORD *)(a1 + 16) || *(_BYTE *)(a1 + 32) )
  {
    v5 = a2[1];
    v6 = a2[2];
    if ( *(_BYTE *)(a1 + 32) )
      v7 = 58;
    else
      v7 = 46;
    v8 = v5 + 1;
    if ( v5 + 1 <= v6 )
    {
      v12 = (_BYTE *)*a2;
    }
    else
    {
      v9 = v5 + 993;
      v10 = (_BYTE *)*a2;
      if ( 2 * v6 <= v9 )
        v11 = v9;
      else
        v11 = 2 * v6;
      a2[2] = v11;
      v12 = realloc(v10, v11);
      *a2 = v12;
      if ( !v12 )
        std::terminate();
      v5 = a2[1];
      v8 = v5 + 1;
    }
    a2[1] = v8;
    v12[v5] = v7;
  }
  v13 = *(_QWORD *)(a1 + 24);
  result = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v13 + 32LL))(v13, a2);
  if ( (*(_WORD *)(v13 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v13 + 40LL))(v13, a2);
  return result;
}

//----- (0000000000050D90) ----------------------------------------------------
void __fastcall sub_50D90(void *a1)
{
  operator delete(a1);
}

//----- (0000000000050D98) ----------------------------------------------------
unsigned __int8 **__fastcall sub_50D98(const char **a1, _BYTE *a2, _BYTE *a3)
{
  const char *v3; // x23
  const char *v4; // x24
  __int64 v8; // x22
  unsigned __int8 **result; // x0
  __int64 v10; // x3
  const char *v11; // x22
  __int64 v12; // x8
  char *v13; // x0
  __int64 v14; // x8
  char *v15; // x9
  const char *v16; // x24

  v3 = *a1;
  v4 = a1[1];
  if ( (unsigned __int64)(v4 - *a1) >= 2 && !strncmp("St", v3, 2u) )
  {
    v11 = a1[614];
    v12 = *((_QWORD *)v11 + 1);
    *a1 = v3 + 2;
    if ( (unsigned __int64)(v12 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v13 = (char *)malloc(0x1000u);
      if ( !v13 )
        std::terminate();
      v12 = 0;
      *(_QWORD *)v13 = v11;
      *((_QWORD *)v13 + 1) = 0;
      v11 = v13;
      a1[614] = v13;
    }
    v14 = v12 + 32;
    v15 = (char *)&v11[v14];
    *((_QWORD *)v11 + 1) = v14;
    LOWORD(v14) = *(_WORD *)&v11[v14 - 7];
    *(_QWORD *)v15 = "std";
    *((_QWORD *)v15 + 1) = "";
    *(_WORD *)(v15 - 7) = v14 & 0xF000 | 0x540;
    v3 = *a1;
    v16 = a1[1];
    *(v15 - 8) = 7;
    *((_QWORD *)v15 - 2) = off_6FBA8;
    v8 = (__int64)(v15 - 16);
    if ( v16 == v3 )
      goto LABEL_15;
  }
  else
  {
    v8 = 0;
    if ( v4 == v3 )
    {
LABEL_15:
      v10 = 0;
      return sub_51CFC((__int64)a1, a2, v8, v10);
    }
  }
  if ( *v3 != 83 )
    goto LABEL_15;
  result = sub_51A40((__int64)a1);
  if ( !result )
    return result;
  v10 = (__int64)result;
  if ( *((_BYTE *)result + 8) == 25 )
    return sub_51CFC((__int64)a1, a2, v8, v10);
  result = 0;
  if ( a3 )
  {
    if ( !v8 )
    {
      result = (unsigned __int8 **)v10;
      *a3 = 1;
    }
  }
  return result;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (0000000000050F00) ----------------------------------------------------
char *__fastcall sub_50F00(_QWORD *a1, char a2)
{
  _BYTE *v2; // x8
  _QWORD *v5; // x0
  _QWORD *v6; // x8
  _BYTE *v7; // x26
  _BYTE *v8; // x22
  _BYTE *v9; // x8
  _BYTE *v10; // x8
  __int128 v11; // q0
  size_t v12; // x23
  char *v13; // x23
  _BYTE *v14; // x0
  _BYTE *v15; // x24
  char *v16; // x8
  _BYTE *v17; // x0
  signed __int64 v18; // x24
  char *v19; // x25
  char *v20; // x0
  char *v21; // x20
  _QWORD *v22; // x20
  __int64 v23; // x24
  __int64 v24; // x25
  __int64 v25; // x8
  _QWORD *v26; // x0
  __int64 v27; // x8
  __int64 v28; // x9
  _QWORD *v29; // x20
  __int16 v30; // w10
  __int16 v31; // w8
  __int64 v32; // x11
  __int64 v33; // x12
  __int64 v34; // x10
  __int64 v35; // x11
  __int64 v36; // x8
  __int64 v37; // x28
  char **v38; // x8
  _BYTE *v39; // x27
  const void *v40; // x26
  signed __int64 v41; // x24
  char *v42; // x25
  char *v43; // x0
  char *result; // x0
  char *v45; // x23
  char *v46; // x8
  char *v47; // x21
  _BYTE *v48; // x0
  signed __int64 v49; // x22
  char *v50; // x0
  char *v51; // x0
  _QWORD *v52; // x22
  char *v53; // x20
  char *v54; // x1
  char *v55; // x21
  __int64 v56; // x8
  _QWORD *v57; // x0
  __int64 v58; // x8
  char **v59; // x9
  __int64 v60; // x1
  __int64 v61; // x2
  __int64 v62; // x3
  __int64 v63; // x4
  __int64 v64; // x5
  __int64 v65; // x6
  __int64 v66; // x7
  __int64 v67; // x8
  _QWORD *v68; // x19
  double v69; // d0
  double v70; // d1
  double v71; // d2
  double v72; // d3
  double v73; // d4
  double v74; // d5
  double v75; // d6
  double v76; // d7
  __int64 v77; // [xsp+8h] [xbp-58h]
  __int64 v78; // [xsp+10h] [xbp-50h]
  _QWORD *v79; // [xsp+20h] [xbp-40h]
  _BYTE *ptr; // [xsp+28h] [xbp-38h]
  __int128 v81; // [xsp+30h] [xbp-30h]
  _BYTE v82[32]; // [xsp+40h] [xbp-20h] BYREF
  __int64 vars0; // [xsp+60h] [xbp+0h] BYREF

  v2 = (_BYTE *)*a1;
  if ( *a1 == a1[1] || *v2 != 73 )
    return 0;
  *a1 = v2 + 1;
  if ( (a2 & 1) != 0 )
  {
    v5 = (_QWORD *)a1[83];
    v6 = (_QWORD *)a1[85];
    a1[84] = v5;
    if ( v5 == v6 )
    {
      if ( v5 == a1 + 86 )
      {
        v5 = malloc(0);
        if ( !v5 )
          goto LABEL_81;
        a1[83] = v5;
      }
      else
      {
        v5 = realloc(v5, 0);
        a1[83] = v5;
        if ( !v5 )
LABEL_81:
          std::terminate();
      }
      a1[84] = v5;
      a1[85] = v5;
    }
    a1[84] = v5 + 1;
    *v5 = a1 + 72;
    a1[73] = a1[72];
  }
  v7 = a1 + 5;
  v77 = a1[3];
  v78 = a1[2];
  if ( (a2 & 1) != 0 )
  {
    v8 = a1 + 86;
    v79 = a1 + 90;
    while ( 1 )
    {
      v9 = (_BYTE *)*a1;
      if ( *a1 != a1[1] && *v9 == 69 )
        goto LABEL_77;
      v10 = (_BYTE *)a1[83];
      ptr = v82;
      *((_QWORD *)&v81 + 1) = &vars0;
      memset(v82, 0, sizeof(v82));
      if ( v10 == v8 )
      {
        v12 = a1[84] - (_QWORD)v8;
        memcpy(v82, a1 + 86, v12);
        a1[84] = v8;
        *(_QWORD *)&v81 = &v82[v12];
      }
      else
      {
        ptr = v10;
        v11 = *((_OWORD *)a1 + 42);
        a1[83] = v8;
        a1[84] = v8;
        v81 = v11;
        a1[85] = v79;
      }
      v13 = sub_4F358(a1);
      v14 = (_BYTE *)a1[83];
      if ( ptr == v82 )
      {
        v15 = v82;
        if ( v14 != v8 )
        {
          free(v14);
          v15 = ptr;
          a1[83] = v8;
          a1[84] = v8;
          a1[85] = v79;
        }
        memmove(a1 + 86, v15, v81 - (_QWORD)v15);
        v14 = v15;
        a1[84] = &v8[v81 - (_QWORD)v15];
        if ( v13 )
        {
LABEL_29:
          v16 = (char *)a1[3];
          if ( v16 == (char *)a1[4] )
          {
            v17 = (_BYTE *)a1[2];
            v18 = v16 - v17;
            if ( v17 == v7 )
            {
              v20 = (char *)malloc(2 * (v16 - v17));
              if ( !v20 )
                goto LABEL_81;
              v19 = v20;
              memcpy(v20, v7, v18);
              a1[2] = v19;
            }
            else
            {
              v19 = (char *)realloc(v17, 2 * (v16 - v17));
              a1[2] = v19;
              if ( !v19 )
                goto LABEL_81;
            }
            v16 = &v19[v18];
            a1[3] = &v19[v18];
            a1[4] = &v19[8 * (v18 >> 2)];
          }
          v21 = v13;
          a1[3] = v16 + 8;
          *(_QWORD *)v16 = v13;
          if ( v13[8] == 37 )
          {
            v22 = (_QWORD *)a1[614];
            v23 = *((_QWORD *)v13 + 2);
            v24 = *((_QWORD *)v13 + 3);
            v25 = v22[1];
            if ( (unsigned __int64)(v25 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
            {
              v26 = malloc(0x1000u);
              if ( !v26 )
                goto LABEL_81;
              v25 = 0;
              *v26 = v22;
              v26[1] = 0;
              v22 = v26;
              a1[614] = v26;
            }
            v27 = v25 + 32;
            v28 = 8 * v24;
            v22[1] = v27;
            v29 = (_QWORD *)((char *)v22 + v27);
            LOWORD(v27) = *(_WORD *)((char *)v29 - 7);
            *v29 = v23;
            v29[1] = v24;
            v30 = v27 & 0xF000;
            *((_BYTE *)v29 - 8) = 36;
            v31 = v27 & 0xF000 | 0xA80;
            *(_WORD *)((char *)v29 - 7) = v30 | 0xA80;
            *(v29 - 2) = off_71728;
            v21 = (char *)(v29 - 2);
            if ( v24 )
            {
              v32 = 8 * v24;
              v33 = v23;
              while ( (*(_WORD *)(*(_QWORD *)v33 + 9LL) & 0x300) == 0x100 )
              {
                v33 += 8;
                v32 -= 8;
                if ( !v32 )
                  goto LABEL_44;
              }
            }
            else
            {
LABEL_44:
              v31 = v30 | 0x980;
              *(_WORD *)(v21 + 9) = v30 | 0x980;
            }
            if ( v24 )
            {
              v34 = 8 * v24;
              v35 = v23;
              while ( (*(_WORD *)(*(_QWORD *)v35 + 9LL) & 0xC00) == 0x400 )
              {
                v35 += 8;
                v34 -= 8;
                if ( !v34 )
                  goto LABEL_49;
              }
            }
            else
            {
LABEL_49:
              v31 = v31 & 0xF3FF | 0x400;
              *(_WORD *)(v21 + 9) = v31;
            }
            if ( v24 )
            {
              while ( (*(_WORD *)(*(_QWORD *)v23 + 9LL) & 0xC0) == 0x40 )
              {
                v23 += 8;
                v28 -= 8;
                if ( !v28 )
                  goto LABEL_53;
              }
            }
            else
            {
LABEL_53:
              *(_WORD *)(v21 + 9) = v31 & 0xFF3F | 0x40;
            }
          }
          v36 = a1[84];
          if ( v36 == a1[83] )
          {
            v68 = (_QWORD *)__assert2(
                              "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
                              139,
                              "T &(anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_"
                              "demangle::PODSmallVector<(anonymous namespace)::itanium_demangle::Node *, 8> *, 4>::back()"
                              " [T = (anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itani"
                              "um_demangle::Node *, 8> *, N = 4]",
                              "Last != First && \"Calling back() on empty vector!\"");
            if ( ptr != v82 )
              free(ptr);
            sub_65E10(v68, v60, v61, v62, v63, v64, v65, v66, v67, v69, v70, v71, v72, v73, v74, v75, v76);
          }
          v37 = *(_QWORD *)(v36 - 8);
          v38 = *(char ***)(v37 + 8);
          if ( v38 == *(char ***)(v37 + 16) )
          {
            v39 = v7;
            v40 = *(const void **)v37;
            v41 = (signed __int64)v38 - *(_QWORD *)v37;
            if ( *(_QWORD *)v37 == v37 + 24 )
            {
              v43 = (char *)malloc(2 * v41);
              if ( !v43 )
                goto LABEL_81;
              v42 = v43;
              memmove(v43, v40, v41);
              *(_QWORD *)v37 = v42;
            }
            else
            {
              v42 = (char *)realloc(*(void **)v37, 2 * v41);
              *(_QWORD *)v37 = v42;
              if ( !v42 )
                goto LABEL_81;
            }
            v38 = (char **)&v42[v41];
            v7 = v39;
            *(_QWORD *)(v37 + 8) = &v42[v41];
            *(_QWORD *)(v37 + 16) = &v42[8 * (v41 >> 2)];
          }
          *(_QWORD *)(v37 + 8) = v38 + 1;
          *v38 = v21;
          v14 = ptr;
        }
      }
      else
      {
        a1[83] = ptr;
        if ( v14 == v8 )
        {
          ptr = v82;
          v14 = v82;
          *((_OWORD *)a1 + 42) = v81;
          if ( v13 )
            goto LABEL_29;
        }
        else
        {
          ptr = v14;
          *((_OWORD *)a1 + 42) = v81;
          if ( v13 )
            goto LABEL_29;
        }
      }
      if ( v14 != v82 )
        free(v14);
      if ( !v13 )
        return 0;
    }
  }
  while ( 1 )
  {
    v9 = (_BYTE *)*a1;
    if ( *a1 != a1[1] && *v9 == 69 )
      break;
    result = sub_4F358(a1);
    if ( !result )
      return result;
    v46 = (char *)a1[3];
    v47 = result;
    if ( v46 == (char *)a1[4] )
    {
      v48 = (_BYTE *)a1[2];
      v49 = v46 - v48;
      if ( v48 == v7 )
      {
        v50 = (char *)malloc(2 * (v46 - v48));
        if ( !v50 )
          goto LABEL_81;
        v45 = v50;
        memcpy(v50, a1 + 5, v49);
        a1[2] = v45;
      }
      else
      {
        v45 = (char *)realloc(v48, 2 * (v46 - v48));
        a1[2] = v45;
        if ( !v45 )
          goto LABEL_81;
      }
      v46 = &v45[v49];
      a1[3] = &v45[v49];
      a1[4] = &v45[8 * (v49 >> 2)];
    }
    a1[3] = v46 + 8;
    *(_QWORD *)v46 = v47;
  }
LABEL_77:
  *a1 = v9 + 1;
  v51 = sub_4F750(a1, (v77 - v78) >> 3);
  v52 = (_QWORD *)a1[614];
  v53 = v51;
  v55 = v54;
  v56 = v52[1];
  if ( (unsigned __int64)(v56 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v57 = malloc(0x1000u);
    if ( !v57 )
      goto LABEL_81;
    v56 = 0;
    *v57 = v52;
    v57[1] = 0;
    v52 = v57;
    a1[614] = v57;
  }
  v58 = v56 + 32;
  v59 = (char **)((char *)v52 + v58);
  v52[1] = v58;
  LOWORD(v58) = *(_WORD *)((char *)v52 + v58 - 7);
  *((_BYTE *)v59 - 8) = 39;
  *v59 = v53;
  v59[1] = v55;
  *(_WORD *)((char *)v59 - 7) = v58 & 0xF000 | 0x540;
  *(v59 - 2) = (char *)off_71798;
  return (char *)(v59 - 2);
}
// 5142C: variable 'v54' is possibly undefined
// 514DC: variable 'v60' is possibly undefined
// 514DC: variable 'v61' is possibly undefined
// 514DC: variable 'v62' is possibly undefined
// 514DC: variable 'v63' is possibly undefined
// 514DC: variable 'v64' is possibly undefined
// 514DC: variable 'v65' is possibly undefined
// 514DC: variable 'v66' is possibly undefined
// 514DC: variable 'v67' is possibly undefined
// 514DC: variable 'v69' is possibly undefined
// 514DC: variable 'v70' is possibly undefined
// 514DC: variable 'v71' is possibly undefined
// 514DC: variable 'v72' is possibly undefined
// 514DC: variable 'v73' is possibly undefined
// 514DC: variable 'v74' is possibly undefined
// 514DC: variable 'v75' is possibly undefined
// 514DC: variable 'v76' is possibly undefined
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 71728: using guessed type __int64 (__fastcall *off_71728[10])();
// 71798: using guessed type __int64 (__fastcall *off_71798[10])();

//----- (00000000000514E0) ----------------------------------------------------
_QWORD *__fastcall sub_514E0(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x11
  _QWORD *result; // x0
  __int64 v13; // x10

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *((_BYTE *)v10 - 8) = 41;
  v11 = *a3;
  *(v10 - 2) = off_71808;
  result = v10 - 2;
  v13 = *a2;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x540;
  *v10 = v13;
  v10[1] = v11;
  return result;
}
// 71808: using guessed type __int64 (__fastcall *off_71808[10])();

//----- (000000000005158C) ----------------------------------------------------
_QWORD *__fastcall sub_5158C(__int64 a1, size_t size)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x11
  _BYTE *v5; // x10
  __int64 v6; // x9
  _BYTE *v7; // x13
  _BYTE *v8; // x12
  unsigned int v9; // w14
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x20
  _BYTE *v12; // x8
  int v13; // w10
  _QWORD *v14; // x21
  __int64 v15; // x8
  _QWORD *v16; // x0
  __int64 v17; // x8
  _BYTE *v18; // x9
  _BYTE *v19; // x20
  char *v20; // x8
  _BYTE *v21; // x23
  signed __int64 v22; // x21
  char *v23; // x22
  __int64 v24; // x11
  _BYTE *v25; // x13
  _BYTE *v26; // x10
  _BYTE *v27; // x8
  int v28; // w10
  __int64 v29; // x10
  unsigned __int64 v30; // x8
  _QWORD *v31; // x11
  _QWORD *v33; // x20
  __int64 v34; // x8
  _QWORD *v35; // x0
  __int64 v36; // x8
  _QWORD *v37; // x9
  char *v38; // x0
  __int64 v39; // [xsp+18h] [xbp+18h] BYREF

  v3 = *(_BYTE **)a1;
  v2 = *(_BYTE **)(a1 + 8);
  if ( *(_BYTE **)a1 == v2 )
    return 0;
  if ( *v3 != 84 )
    return 0;
  v5 = v3 + 1;
  *(_QWORD *)a1 = v3 + 1;
  if ( v3 + 1 == v2 )
    return 0;
  if ( *v5 == 76 )
  {
    *(_QWORD *)a1 = v3 + 2;
    if ( v2 == v3 + 2 || (unsigned int)(unsigned __int8)v3[2] - 58 < 0xFFFFFFF6 )
      return 0;
    v6 = 0;
    v7 = v3 + 4;
    do
    {
      v8 = v7 - 1;
      v5 = v7;
      *(_QWORD *)a1 = v7 - 1;
      v6 = (unsigned __int8)*(v7 - 2) + 10 * v6 - 48;
      if ( v7 - 1 == v2 )
        break;
      v9 = (unsigned __int8)*(v7++ - 1) - 48;
    }
    while ( v9 <= 9 );
    if ( v8 == v2 )
      return 0;
    if ( *(v5 - 1) != 95 )
      return 0;
    v10 = v6 + 1;
    *(_QWORD *)a1 = v5;
    if ( v5 == v2 )
      return 0;
  }
  else
  {
    v10 = 0;
    if ( v5 == v2 )
      return 0;
  }
  if ( *v5 == 95 )
  {
    v11 = 0;
    v12 = v5 + 1;
    v13 = *(unsigned __int8 *)(a1 + 777);
    *(_QWORD *)a1 = v12;
    if ( !v13 )
      goto LABEL_32;
    goto LABEL_17;
  }
  if ( (unsigned int)(unsigned __int8)*v5 - 58 < 0xFFFFFFF6 )
    return 0;
  v24 = 0;
  v25 = v5 + 1;
  do
  {
    *(_QWORD *)a1 = v25;
    v26 = v25;
    v24 = (unsigned __int8)*(v25 - 1) + 10 * v24 - 48;
    if ( v25 == v2 )
      break;
    ++v25;
  }
  while ( (unsigned int)(unsigned __int8)*v26 - 48 <= 9 );
  if ( v26 == v2 || *v26 != 95 )
    return 0;
  v11 = v24 + 1;
  v27 = v26 + 1;
  v28 = *(unsigned __int8 *)(a1 + 777);
  *(_QWORD *)a1 = v27;
  if ( !v28 )
    goto LABEL_32;
LABEL_17:
  if ( !v10 )
  {
    v14 = *(_QWORD **)(a1 + 4912);
    v15 = v14[1];
    if ( (unsigned __int64)(v15 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v16 = malloc(0x1000u);
      if ( !v16 )
        goto LABEL_50;
      v15 = 0;
      *v16 = v14;
      v16[1] = 0;
      v14 = v16;
      *(_QWORD *)(a1 + 4912) = v16;
    }
    v17 = v15 + 48;
    v18 = (char *)v14 + v17;
    v14[1] = v17;
    LOWORD(v17) = *(_WORD *)((char *)v14 + v17 - 23);
    *((_QWORD *)v18 - 2) = v11;
    *((_QWORD *)v18 - 1) = 0;
    *v18 = 0;
    *((_QWORD *)v18 - 4) = off_6FC88;
    v19 = v18 - 32;
    *(_WORD *)(v18 - 23) = v17 & 0xF000 | 0xA80;
    *(v18 - 24) = 40;
    v20 = *(char **)(a1 + 728);
    if ( v20 == *(char **)(a1 + 736) )
    {
      v21 = *(_BYTE **)(a1 + 720);
      v22 = v20 - v21;
      if ( v21 == (_BYTE *)(a1 + 744) )
      {
        v38 = (char *)malloc(2 * v22);
        if ( !v38 )
          goto LABEL_50;
        v23 = v38;
        memmove(v38, v21, v22);
        *(_QWORD *)(a1 + 720) = v23;
      }
      else
      {
        v23 = (char *)realloc(*(void **)(a1 + 720), 2 * (v20 - v21));
        *(_QWORD *)(a1 + 720) = v23;
        if ( !v23 )
LABEL_50:
          std::terminate();
      }
      v20 = &v23[v22];
      *(_QWORD *)(a1 + 736) = &v23[8 * (v22 >> 2)];
    }
    *(_QWORD *)(a1 + 728) = v20 + 8;
    *(_QWORD *)v20 = v19;
    return v19;
  }
LABEL_32:
  v29 = *(_QWORD *)(a1 + 664);
  v30 = (*(_QWORD *)(a1 + 672) - v29) >> 3;
  if ( v10 < v30 )
  {
    v31 = *(_QWORD **)(v29 + 8 * v10);
    if ( v31 )
    {
      if ( v11 < (__int64)(v31[1] - *v31) >> 3 )
        return *(_QWORD **)(*v31 + 8 * v11);
    }
  }
  v19 = 0;
  if ( *(_QWORD *)(a1 + 784) == v10 && v10 <= v30 )
  {
    if ( v10 == v30 )
    {
      v39 = 0;
      sub_52238((_QWORD *)(a1 + 664), &v39);
    }
    v33 = *(_QWORD **)(a1 + 4912);
    v34 = v33[1];
    if ( (unsigned __int64)(v34 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v35 = malloc(0x1000u);
      if ( !v35 )
        goto LABEL_50;
      v34 = 0;
      *v35 = v33;
      v35[1] = 0;
      v33 = v35;
      *(_QWORD *)(a1 + 4912) = v35;
    }
    v36 = v34 + 32;
    v37 = (_QWORD *)((char *)v33 + v36);
    v33[1] = v36;
    LOWORD(v36) = *(_WORD *)((char *)v33 + v36 - 7);
    *((_BYTE *)v37 - 8) = 7;
    *(_WORD *)((char *)v37 - 7) = v36 & 0xF000 | 0x540;
    *v37 = "auto";
    v37[1] = "";
    *(v37 - 2) = off_6FBA8;
    return v37 - 2;
  }
  return v19;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 6FC88: using guessed type __int64 (__fastcall *off_6FC88[10])();

//----- (0000000000051900) ----------------------------------------------------
__int64 __fastcall sub_51900(__int64 a1)
{
  _BYTE *v1; // x8
  _BYTE *v2; // x9
  _BYTE *v4; // x10
  __int64 result; // x0
  _BYTE *v6; // x9
  _QWORD *v7; // x21
  __int64 v8; // x20
  __int64 v9; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  _QWORD *v12; // x9

  v1 = *(_BYTE **)a1;
  v2 = *(_BYTE **)(a1 + 8);
  if ( *(_BYTE **)a1 == v2 )
    return 0;
  if ( *v1 != 68 )
    return 0;
  v4 = v1 + 1;
  *(_QWORD *)a1 = v1 + 1;
  if ( v1 + 1 == v2 || *v4 != 116 && *v4 != 84 )
    return 0;
  *(_QWORD *)a1 = v1 + 2;
  result = sub_52694(a1);
  if ( !result )
    return result;
  v6 = *(_BYTE **)a1;
  if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v6 != 69 )
    return 0;
  v7 = *(_QWORD **)(a1 + 4912);
  v8 = result;
  v9 = v7[1];
  *(_QWORD *)a1 = v6 + 1;
  if ( (unsigned __int64)(v9 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v9 = 0;
    *v10 = v7;
    v10[1] = 0;
    v7 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v9 + 64;
  v12 = (_QWORD *)((char *)v7 + v11);
  v7[1] = v11;
  LOWORD(v11) = *(_WORD *)((char *)v7 + v11 - 39);
  *((_BYTE *)v12 - 40) = 56;
  *(v12 - 1) = 0;
  *v12 = 0;
  *(v12 - 4) = "decltype";
  *(v12 - 3) = "";
  *(v12 - 2) = v8;
  *(_WORD *)((char *)v12 - 39) = v11 & 0xF000 | 0x540;
  *(v12 - 6) = off_705A8;
  return (__int64)(v12 - 6);
}
// 52694: using guessed type __int64 __fastcall sub_52694(_QWORD);
// 705A8: using guessed type __int64 (__fastcall *off_705A8[10])();

//----- (0000000000051A40) ----------------------------------------------------
unsigned __int8 **__fastcall sub_51A40(__int64 a1)
{
  _BYTE *v1; // x9
  _BYTE *v2; // x10
  _BYTE *v4; // x8
  unsigned int v5; // w11
  unsigned __int8 **v6; // x20
  int v7; // w22
  unsigned __int8 ***v12; // x8
  unsigned __int8 ***v13; // x9
  __int64 v15; // x10
  __int64 v16; // x13
  __int64 v17; // x12
  __int64 v18; // x9
  __int64 v19; // x11
  _QWORD *v20; // x20
  __int64 v21; // x8
  _QWORD *v22; // x0
  __int64 v23; // x8
  unsigned __int8 **v24; // x21
  unsigned __int8 **v25; // x0
  char *v26; // x8
  _BYTE *v27; // x23
  signed __int64 v28; // x21
  char *v29; // x22
  char *v30; // x0

  v2 = *(_BYTE **)a1;
  v1 = *(_BYTE **)(a1 + 8);
  if ( *(_BYTE **)a1 == v1 )
    goto LABEL_14;
  if ( *v2 != 83 )
    goto LABEL_14;
  v4 = v2 + 1;
  *(_QWORD *)a1 = v2 + 1;
  if ( v1 == v2 + 1 )
    goto LABEL_14;
  v5 = (unsigned __int8)*v4;
  if ( v5 < 0x61 )
  {
    if ( v5 == 95 )
    {
      v12 = *(unsigned __int8 ****)(a1 + 296);
      v13 = *(unsigned __int8 ****)(a1 + 304);
      *(_QWORD *)a1 = v2 + 2;
      if ( v12 != v13 )
      {
        v6 = *v12;
        goto LABEL_15;
      }
    }
    else if ( v5 >= 0x30 )
    {
LABEL_12:
      if ( v5 < 0x3A || v5 - 65 <= 0x19 )
      {
        v15 = 0;
        while ( 1 )
        {
          v17 = (unsigned __int8)*v4;
          if ( (unsigned int)v17 < 0x30 )
            break;
          if ( (unsigned int)v17 < 0x3A )
          {
            v16 = -48;
          }
          else
          {
            if ( (unsigned int)(v17 - 65) > 0x19 )
              break;
            v16 = -55;
          }
          v6 = 0;
          ++v4;
          v15 = v17 + 36 * v15 + v16;
          *(_QWORD *)a1 = v4;
          if ( v4 == v1 )
            goto LABEL_15;
        }
        if ( v4 != v1 && *v4 == 95 )
        {
          v18 = *(_QWORD *)(a1 + 296);
          v19 = *(_QWORD *)(a1 + 304);
          *(_QWORD *)a1 = v4 + 1;
          if ( v15 + 1 < (unsigned __int64)((v19 - v18) >> 3) )
          {
            v6 = *(unsigned __int8 ***)(v18 + 8 * (v15 + 1));
            goto LABEL_15;
          }
        }
      }
    }
LABEL_14:
    v6 = 0;
    goto LABEL_15;
  }
  if ( v5 > 0x7A )
    goto LABEL_12;
  v6 = 0;
  v7 = 0;
  switch ( *v4 )
  {
    case 'a':
      goto LABEL_31;
    case 'b':
      __asm { BTI             j; jumptable 0000000000051ABC case 98 }
      v7 = 1;
      goto LABEL_31;
    case 'd':
      __asm { BTI             j; jumptable 0000000000051ABC case 100 }
      v7 = 5;
      goto LABEL_31;
    case 'i':
      __asm { BTI             j; jumptable 0000000000051ABC case 105 }
      v7 = 3;
      goto LABEL_31;
    case 'o':
      __asm { BTI             j; jumptable 0000000000051ABC case 111 }
      v7 = 4;
      goto LABEL_31;
    case 's':
      __asm { BTI             j; jumptable 0000000000051ABC case 115 }
      v7 = 2;
LABEL_31:
      __asm { BTI             j; jumptable 0000000000051ABC case 97 }
      v20 = *(_QWORD **)(a1 + 4912);
      v21 = v20[1];
      *(_QWORD *)a1 = v2 + 2;
      if ( (unsigned __int64)(v21 - 4064) > 0xFFFFFFFFFFFFF00FLL )
        goto LABEL_34;
      v22 = malloc(0x1000u);
      if ( !v22 )
        goto LABEL_44;
      v21 = 0;
      *v22 = v20;
      v22[1] = 0;
      v20 = v22;
      *(_QWORD *)(a1 + 4912) = v22;
LABEL_34:
      v23 = v21 + 16;
      v24 = (unsigned __int8 **)((char *)v20 + v23);
      v20[1] = v23;
      LOWORD(v23) = *(_WORD *)((char *)v20 + v23 + 9);
      *((_BYTE *)v24 + 8) = 44;
      *((_DWORD *)v24 + 3) = v7;
      *v24 = (unsigned __int8 *)off_713A8;
      *(_WORD *)((char *)v24 + 9) = v23 & 0xF000 | 0x540;
      v25 = sub_5D76C(a1, v24);
      if ( v25 == v24 )
      {
        v6 = v24;
      }
      else
      {
        v26 = *(char **)(a1 + 304);
        v6 = v25;
        if ( v26 == *(char **)(a1 + 312) )
        {
          v27 = *(_BYTE **)(a1 + 296);
          v28 = v26 - v27;
          if ( v27 == (_BYTE *)(a1 + 320) )
          {
            v30 = (char *)malloc(2 * v28);
            if ( !v30 )
              goto LABEL_44;
            v29 = v30;
            memmove(v30, v27, v28);
            *(_QWORD *)(a1 + 296) = v29;
          }
          else
          {
            v29 = (char *)realloc(*(void **)(a1 + 296), 2 * (v26 - v27));
            *(_QWORD *)(a1 + 296) = v29;
            if ( !v29 )
LABEL_44:
              std::terminate();
          }
          v26 = &v29[v28];
          *(_QWORD *)(a1 + 312) = &v29[8 * (v28 >> 2)];
        }
        *(_QWORD *)(a1 + 304) = v26 + 8;
        *(_QWORD *)v26 = v6;
      }
      break;
    default:
      break;
  }
LABEL_15:
  __asm { BTI             j; jumptable 0000000000051ABC default case, cases 99,101-104,106-110,112-114 }
  return v6;
}
// 713A8: using guessed type __int64 (__fastcall *off_713A8[10])();

//----- (0000000000051CFC) ----------------------------------------------------
unsigned __int8 **__fastcall sub_51CFC(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // x19
  unsigned __int8 **v7; // x23
  const char *v9; // x22
  const char *v10; // x24
  unsigned int v11; // w9
  unsigned __int8 **v12; // x21
  _QWORD *v13; // x22
  __int64 v14; // x8
  _QWORD *v15; // x0
  __int64 v16; // x8
  __int64 v17; // x9
  int v18; // w10
  int v19; // w8
  const char *v20; // x8
  int v21; // w9
  __int64 v22; // x22
  _QWORD *v23; // x23
  __int64 v24; // x8
  _QWORD *v25; // x0
  __int64 v26; // x8
  __int64 *v27; // x9
  const char *v28; // x8
  __int64 v29; // x21
  __int64 v30; // x22
  __int64 v31; // x0
  __int64 v32; // x24
  unsigned __int64 v33; // x21
  __int64 *v34; // x8
  _BYTE *v35; // x0
  signed __int64 v36; // x23
  char *v37; // x25
  char *v38; // x0
  const char *v39; // x8
  char *v40; // x0
  _QWORD *v41; // x21
  char *v42; // x22
  __int64 v43; // x1
  __int64 v44; // x23
  __int64 v45; // x8
  _QWORD *v46; // x0
  __int64 v47; // x8
  __int16 *v48; // x9
  unsigned int v49; // w8
  int v50; // w22
  unsigned __int8 **v51; // x0
  _QWORD *v52; // x21
  __int64 v53; // x8
  _QWORD *v54; // x0
  __int64 v55; // x8
  __int64 *v56; // x9
  __int64 v57; // [xsp+8h] [xbp-8h] BYREF
  __int64 v58; // [xsp+28h] [xbp+18h] BYREF

  v5 = a3;
  v58 = a3;
  v57 = a4;
  if ( (sub_504DC(a1, &v57) & 1) != 0 )
    return 0;
  v9 = *(const char **)a1;
  v10 = *(const char **)(a1 + 8);
  if ( *(const char **)a1 != v10 && *v9 == 76 )
    *(_QWORD *)a1 = ++v9;
  if ( v10 == v9 )
    goto LABEL_15;
  v11 = *(unsigned __int8 *)v9;
  if ( v11 < 0x31 )
    goto LABEL_15;
  if ( v11 > 0x39 )
  {
    if ( v11 == 85 )
    {
      v12 = (unsigned __int8 **)sub_58468(a1, (__int64)a2);
      if ( v12 )
        goto LABEL_32;
      goto LABEL_71;
    }
LABEL_15:
    if ( (unsigned __int64)(v10 - v9) >= 2 && !strncmp("DC", v9, 2u) )
    {
      v28 = v9 + 2;
      v29 = *(_QWORD *)(a1 + 16);
      v30 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)a1 = v28;
      v31 = sub_50964((const char **)a1);
      if ( !v31 )
        return 0;
      v32 = v31;
      v33 = (v30 - v29) >> 3;
      while ( 1 )
      {
        v34 = *(__int64 **)(a1 + 24);
        if ( v34 == *(__int64 **)(a1 + 32) )
        {
          v35 = *(_BYTE **)(a1 + 16);
          v36 = (char *)v34 - v35;
          if ( v35 == (_BYTE *)(a1 + 40) )
          {
            v38 = (char *)malloc(2 * ((char *)v34 - v35));
            if ( !v38 )
              goto LABEL_78;
            v37 = v38;
            memcpy(v38, (const void *)(a1 + 40), v36);
            *(_QWORD *)(a1 + 16) = v37;
          }
          else
          {
            v37 = (char *)realloc(v35, 2 * ((char *)v34 - v35));
            *(_QWORD *)(a1 + 16) = v37;
            if ( !v37 )
              goto LABEL_78;
          }
          v34 = (__int64 *)&v37[v36];
          *(_QWORD *)(a1 + 32) = &v37[8 * (v36 >> 2)];
        }
        *(_QWORD *)(a1 + 24) = v34 + 1;
        *v34 = v32;
        v39 = *(const char **)a1;
        if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v39 == 69 )
          break;
        v32 = sub_50964((const char **)a1);
        v7 = 0;
        if ( !v32 )
          return v7;
      }
      *(_QWORD *)a1 = v39 + 1;
      v40 = sub_4F750((_QWORD *)a1, v33);
      v41 = *(_QWORD **)(a1 + 4912);
      v42 = v40;
      v44 = v43;
      v45 = v41[1];
      if ( (unsigned __int64)(v45 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v46 = malloc(0x1000u);
        if ( !v46 )
          goto LABEL_78;
        v45 = 0;
        *v46 = v41;
        v46[1] = 0;
        v41 = v46;
        *(_QWORD *)(a1 + 4912) = v46;
      }
      v47 = v45 + 32;
      v48 = (__int16 *)((char *)v41 + v47);
      v41[1] = v47;
      LOWORD(v47) = *(_WORD *)((char *)v41 + v47 - 7);
      *((_BYTE *)v48 - 8) = 49;
      *(_QWORD *)v48 = v42;
      *((_QWORD *)v48 + 1) = v44;
      *(__int16 *)((char *)v48 - 7) = v47 & 0xF000 | 0x540;
      *((_QWORD *)v48 - 2) = off_714F8;
      v12 = (unsigned __int8 **)(v48 - 8);
      if ( v48 == &word_10 )
        goto LABEL_71;
      goto LABEL_32;
    }
    if ( v10 == v9 || (unsigned int)*(unsigned __int8 *)v9 - 67 > 1 )
    {
      v12 = (unsigned __int8 **)sub_5D04C(a1, a2);
      if ( !v12 )
        goto LABEL_71;
      goto LABEL_32;
    }
    v7 = 0;
    if ( !v5 || v57 )
      return v7;
    if ( *(_BYTE *)(v5 + 8) == 44 )
    {
      v13 = *(_QWORD **)(a1 + 4912);
      v14 = v13[1];
      if ( (unsigned __int64)(v14 - 4064) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v15 = malloc(0x1000u);
        if ( !v15 )
          goto LABEL_78;
        v14 = 0;
        *v15 = v13;
        v15[1] = 0;
        v13 = v15;
        *(_QWORD *)(a1 + 4912) = v15;
      }
      v16 = v14 + 16;
      v17 = (__int64)v13 + v16;
      v13[1] = v16;
      LOWORD(v16) = *(_WORD *)((char *)v13 + v16 + 9);
      *(_BYTE *)(v17 + 8) = 43;
      v18 = *(_DWORD *)(v5 + 12);
      v5 = v17;
      v58 = v17;
      *(_DWORD *)(v17 + 12) = v18;
      *(_WORD *)(v17 + 9) = v16 & 0xF000 | 0x540;
      v9 = *(const char **)a1;
      v10 = *(const char **)(a1 + 8);
      *(_QWORD *)v17 = off_71430;
    }
    if ( v9 == v10 )
      return 0;
    v19 = *(unsigned __int8 *)v9;
    if ( v19 == 67 )
    {
      v20 = v9 + 1;
      *(_QWORD *)a1 = v9 + 1;
      if ( v9 + 1 == v10 )
      {
        v21 = 0;
        v20 = v10;
      }
      else if ( *v20 == 73 )
      {
        v20 = v9 + 2;
        v21 = 1;
        *(_QWORD *)a1 = v9 + 2;
      }
      else
      {
        v21 = 0;
      }
      if ( v10 == v20 )
        return 0;
      v50 = *(unsigned __int8 *)v20;
      if ( (unsigned int)(v50 - 49) > 4 )
        return 0;
      *(_QWORD *)a1 = v20 + 1;
      if ( a2 )
        *a2 = 1;
      if ( v21 && !sub_4ECA0(a1, (size_t)a2) )
        return 0;
      v12 = (unsigned __int8 **)sub_5E1F8(a1, &v58, 0, v50 - 48);
      if ( v12 )
        goto LABEL_32;
    }
    else
    {
      v7 = 0;
      if ( v19 != 68 )
        return v7;
      if ( (unsigned __int64)(v10 - v9) < 2 )
        return v7;
      v49 = *((unsigned __int8 *)v9 + 1);
      v7 = 0;
      if ( v49 > 0x35 || ((1LL << v49) & 0x37000000000000LL) == 0 )
        return v7;
      *(_QWORD *)a1 = v9 + 2;
      if ( a2 )
        *a2 = 1;
      v12 = (unsigned __int8 **)sub_5E1F8(a1, &v58, 1, v49 - 48);
      if ( v12 )
        goto LABEL_32;
    }
LABEL_71:
    if ( v12 )
      goto LABEL_72;
    return 0;
  }
  v12 = (unsigned __int8 **)sub_50964((const char **)a1);
  if ( !v12 )
    goto LABEL_71;
LABEL_32:
  v22 = v57;
  if ( !v57 )
    goto LABEL_71;
  v23 = *(_QWORD **)(a1 + 4912);
  v24 = v23[1];
  if ( (unsigned __int64)(v24 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v25 = malloc(0x1000u);
    if ( !v25 )
      goto LABEL_78;
    v24 = 0;
    *v25 = v23;
    v25[1] = 0;
    v23 = v25;
    *(_QWORD *)(a1 + 4912) = v25;
  }
  v26 = v24 + 32;
  v27 = (_QWORD *)((char *)v23 + v26);
  v23[1] = v26;
  LOWORD(v26) = *(_WORD *)((char *)v23 + v26 - 7);
  *v27 = v22;
  v27[1] = (__int64)v12;
  *(v27 - 2) = (__int64)off_715D8;
  v12 = (unsigned __int8 **)(v27 - 2);
  *((_BYTE *)v27 - 8) = 26;
  *(_WORD *)((char *)v27 - 7) = v26 & 0xF000 | 0x540;
LABEL_72:
  v51 = sub_5D76C(a1, v12);
  v7 = v51;
  if ( v5 && v51 )
  {
    v52 = *(_QWORD **)(a1 + 4912);
    v53 = v52[1];
    if ( (unsigned __int64)(v53 - 4048) > 0xFFFFFFFFFFFFF00FLL )
    {
LABEL_77:
      v55 = v53 + 32;
      v56 = (_QWORD *)((char *)v52 + v55);
      v52[1] = v55;
      LOWORD(v55) = *(_WORD *)((char *)v52 + v55 - 7);
      *v56 = v5;
      v56[1] = (__int64)v7;
      *(v56 - 2) = (__int64)off_71648;
      v7 = (unsigned __int8 **)(v56 - 2);
      *((_BYTE *)v56 - 8) = 23;
      *(_WORD *)((char *)v56 - 7) = v55 & 0xF000 | 0x540;
      return v7;
    }
    v54 = malloc(0x1000u);
    if ( v54 )
    {
      v53 = 0;
      *v54 = v52;
      v54[1] = 0;
      v52 = v54;
      *(_QWORD *)(a1 + 4912) = v54;
      goto LABEL_77;
    }
LABEL_78:
    std::terminate();
  }
  return v7;
}
// 52054: variable 'v43' is possibly undefined
// 10: using guessed type __int16;
// 71430: using guessed type __int64 (__fastcall *off_71430[9])();
// 714F8: using guessed type __int64 (__fastcall *off_714F8[10])();
// 715D8: using guessed type __int64 (__fastcall *off_715D8[10])();
// 71648: using guessed type __int64 (__fastcall *off_71648[10])();

//----- (0000000000052238) ----------------------------------------------------
_QWORD *__fastcall sub_52238(_QWORD *result, __int64 *size)
{
  char *v2; // x8
  _QWORD *v3; // x19
  const void *v5; // x23
  signed __int64 v6; // x21
  char *v7; // x22
  char *v8; // x0
  __int64 v9; // x10

  v2 = (char *)result[1];
  v3 = result;
  if ( v2 == (char *)result[2] )
  {
    v5 = (const void *)*result;
    v6 = (signed __int64)&v2[-*result];
    if ( (_QWORD *)*result == result + 3 )
    {
      v8 = (char *)malloc(2 * v6);
      if ( !v8 )
        goto LABEL_9;
      v7 = v8;
      result = memmove(v8, v5, v6);
      *v3 = v7;
    }
    else
    {
      result = realloc((void *)*result, 2 * v6);
      v7 = (char *)result;
      *v3 = result;
      if ( !result )
LABEL_9:
        std::terminate();
    }
    v2 = &v7[v6];
    v3[1] = &v7[v6];
    v3[2] = &v7[8 * (v6 >> 2)];
  }
  v9 = *size;
  v3[1] = v2 + 8;
  *(_QWORD *)v2 = v9;
  return result;
}

//----- (00000000000523A0) ----------------------------------------------------
bool __fastcall sub_523A0(__int64 a1)
{
  __int64 v3; // x0
  unsigned int v4; // w8
  char v5; // w0

  if ( *(_BYTE *)(a1 + 32) )
    return 0;
  v3 = *(_QWORD *)(a1 + 24);
  *(_BYTE *)(a1 + 32) = 1;
  v4 = *(unsigned __int8 *)(v3 + 9);
  if ( (v4 & 0xC0) == 0x80 )
  {
    v5 = (**(__int64 (__fastcall ***)(__int64))v3)(v3);
    *(_BYTE *)(a1 + 32) = 0;
    return v5 & 1;
  }
  else
  {
    *(_BYTE *)(a1 + 32) = 0;
    return v4 < 0x40;
  }
}

//----- (0000000000052438) ----------------------------------------------------
bool __fastcall sub_52438(__int64 a1)
{
  _BYTE *v3; // x0
  int v4; // w8
  char v5; // w0

  if ( *(_BYTE *)(a1 + 32) )
    return 0;
  v3 = *(_BYTE **)(a1 + 24);
  *(_BYTE *)(a1 + 32) = 1;
  v4 = v3[10] & 3;
  if ( v4 == 2 )
  {
    v5 = (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v3 + 8LL))(v3);
    *(_BYTE *)(a1 + 32) = 0;
    return v5 & 1;
  }
  else
  {
    *(_BYTE *)(a1 + 32) = 0;
    return v4 == 0;
  }
}

//----- (00000000000524D0) ----------------------------------------------------
bool __fastcall sub_524D0(__int64 a1)
{
  __int64 v3; // x0
  int v4; // w8
  char v5; // w0

  if ( *(_BYTE *)(a1 + 32) )
    return 0;
  v3 = *(_QWORD *)(a1 + 24);
  *(_BYTE *)(a1 + 32) = 1;
  v4 = (*(unsigned __int16 *)(v3 + 9) >> 10) & 3;
  if ( v4 == 2 )
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
    *(_BYTE *)(a1 + 32) = 0;
    return v5 & 1;
  }
  else
  {
    *(_BYTE *)(a1 + 32) = 0;
    return v4 == 0;
  }
}

//----- (0000000000052568) ----------------------------------------------------
__int64 __fastcall sub_52568(__int64 result)
{
  __int64 v1; // x19
  __int64 *v2; // x0
  __int64 v3; // x9

  v1 = result;
  if ( !*(_BYTE *)(result + 32) )
  {
    v2 = *(__int64 **)(result + 24);
    v3 = *v2;
    *(_BYTE *)(v1 + 32) = 1;
    result = (*(__int64 (__fastcall **)(__int64 *))(v3 + 24))(v2);
    *(_BYTE *)(v1 + 32) = 0;
  }
  return result;
}

//----- (00000000000525CC) ----------------------------------------------------
__int64 __fastcall sub_525CC(__int64 result)
{
  __int64 v1; // x19
  __int64 *v2; // x0
  __int64 v3; // x9

  if ( !*(_BYTE *)(result + 32) )
  {
    v1 = result;
    v2 = *(__int64 **)(result + 24);
    v3 = *v2;
    *(_BYTE *)(v1 + 32) = 1;
    result = (*(__int64 (__fastcall **)(__int64 *))(v3 + 32))(v2);
    *(_BYTE *)(v1 + 32) = 0;
  }
  return result;
}

//----- (000000000005262C) ----------------------------------------------------
__int64 __fastcall sub_5262C(__int64 result)
{
  __int64 v1; // x19
  __int64 *v2; // x0
  __int64 v3; // x9

  if ( !*(_BYTE *)(result + 32) )
  {
    v1 = result;
    v2 = *(__int64 **)(result + 24);
    v3 = *v2;
    *(_BYTE *)(v1 + 32) = 1;
    result = (*(__int64 (__fastcall **)(__int64 *))(v3 + 40))(v2);
    *(_BYTE *)(v1 + 32) = 0;
  }
  return result;
}

//----- (000000000005268C) ----------------------------------------------------
void __fastcall sub_5268C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000052694) ----------------------------------------------------
char *__fastcall sub_52694(__int64 a1)
{
  unsigned __int8 *v1; // x21
  unsigned __int8 *v2; // x24
  unsigned __int64 v3; // x23
  char *result; // x0
  size_t v10; // x1
  char v11; // w20
  __int64 v12; // x9
  unsigned int v13; // w8
  __int64 v14; // x11
  __int64 v15; // x12
  unsigned __int8 *v16; // x13
  unsigned int v17; // w14
  unsigned __int8 *v18; // x26
  const char *v19; // x22
  unsigned __int8 *v20; // x27
  int v21; // w28
  size_t v22; // x23
  __int64 v23; // x0
  const char *v24; // x25
  int v25; // w8
  const char *v26; // x22
  __int64 v27; // kr00_8
  const char *v28; // kr08_8
  unsigned int v29; // w21
  _QWORD *v30; // x23
  char *v31; // x20
  __int64 v32; // x8
  _QWORD *v33; // x0
  __int64 v34; // x8
  char **v35; // x9
  __int64 v36; // x9
  __int64 v37; // x10
  unsigned __int8 *v38; // x8
  unsigned __int64 v39; // x20
  char *v40; // x24
  char *v41; // x8
  char *v42; // x22
  _BYTE *v43; // x0
  signed __int64 v44; // x23
  char *v45; // x0
  __int64 v46; // x1
  int v47; // w9
  int v48; // w8
  _BYTE *v49; // x21
  unsigned __int64 v50; // x22
  char *v51; // x25
  char *v52; // x8
  char *v53; // x23
  _BYTE *v54; // x0
  signed __int64 v55; // x24
  char *v56; // x0
  _QWORD *v57; // x23
  char *v58; // x21
  unsigned int v59; // w22
  __int64 v60; // x8
  _QWORD *v61; // x0
  __int64 v62; // x8
  char *v63; // x9
  unsigned __int64 v64; // x20
  char *v65; // x24
  char *v66; // x8
  unsigned __int8 *v67; // x8
  char *v68; // x22
  _BYTE *v69; // x0
  signed __int64 v70; // x23
  char *v71; // x0
  char v72; // w20
  unsigned __int8 *v73; // x8
  unsigned __int8 *v74; // x9
  unsigned __int64 v75; // x20
  int v76; // w25
  char *v77; // x24
  char *v78; // x8
  char *v79; // x22
  _BYTE *v80; // x0
  signed __int64 v81; // x23
  char *v82; // x0
  size_t v83; // x1
  __int64 v84; // x1
  char v85; // w0
  __int64 v86; // x25
  __int64 v87; // x27
  unsigned __int8 *v88; // x8
  char *v89; // x0
  int v90; // w8
  __int64 v91; // x1
  char *v92; // x24
  char *v93; // x8
  char *v94; // x22
  _BYTE *v95; // x0
  signed __int64 v96; // x23
  char *v97; // x0
  unsigned __int64 v98; // x20
  unsigned __int8 *v99; // x8
  char *v100; // x0
  int v101; // w8
  __int64 v102; // x1
  __int128 *v103; // x1
  int v104; // w8
  __int64 v105; // x1
  char *v106; // x8
  char *v107; // x21
  _BYTE *v108; // x0
  signed __int64 v109; // x22
  char *v110; // x23
  unsigned __int64 v111; // x20
  unsigned __int8 *v112; // x8
  __int64 v113; // x1
  char *v114; // x0
  __int64 v115; // x1
  unsigned __int8 *v116; // x8
  const char *v117; // x0
  __int64 v118; // x1
  __int64 v119; // x21
  unsigned __int8 *v120; // x8
  __int64 v121; // x1
  char *v122; // x0
  __int64 v123; // x1
  unsigned __int8 *v124; // x8
  int v125; // w9
  _QWORD *v126; // x0
  __int64 v127; // x1
  __int64 v128; // x2
  __int64 v129; // x3
  __int64 v130; // x4
  __int64 v131; // x5
  __int64 v132; // x6
  __int64 v133; // x7
  __int64 v134; // x8
  double v135; // d0
  double v136; // d1
  double v137; // d2
  double v138; // d3
  double v139; // d4
  double v140; // d5
  double v141; // d6
  double v142; // d7
  __int128 v143; // [xsp+0h] [xbp-40h] BYREF
  __int128 v144; // [xsp+10h] [xbp-30h] BYREF
  char *v145; // [xsp+20h] [xbp-20h] BYREF
  int v146; // [xsp+2Ch] [xbp-14h] BYREF
  __int128 v147; // [xsp+30h] [xbp-10h] BYREF

  v1 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = (unsigned __int64)&v2[-*(_QWORD *)a1];
  if ( v3 < 2 )
    goto LABEL_2;
  if ( !strncmp("gs", (const char *)v1, 2u) )
  {
    v1 += 2;
    v3 = v2 - v1;
    *(_QWORD *)a1 = v1;
    if ( (unsigned __int64)(v2 - v1) < 2 )
      goto LABEL_2;
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  v12 = 0;
  v13 = *v1;
  v14 = 61;
  do
  {
    v15 = (unsigned __int64)(v12 + v14) >> 1;
    v16 = (unsigned __int8 *)&unk_6FCE8 + 16 * v15;
    v17 = *v16;
    if ( v13 > v17 || v13 == v17 && v1[1] > (unsigned int)v16[1] )
    {
      v12 = v15 + 1;
      v15 = v14;
    }
    v14 = v15;
  }
  while ( v15 != v12 );
  v18 = (unsigned __int8 *)&unk_6FCE8 + 16 * v12;
  if ( v13 == *v18 && v1[1] == v18[1] )
  {
    v19 = (const char *)*((_QWORD *)v18 + 1);
    v20 = v1 + 2;
    v21 = v18[2];
    *(_QWORD *)a1 = v1 + 2;
    v22 = strlen(v19);
    if ( v22 < 8 || (v23 = strncmp("operator", v19, 8u), (_DWORD)v23) )
    {
      v126 = (_QWORD *)__assert2(
                         "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
                         2631,
                         "StringView (anonymous namespace)::itanium_demangle::AbstractManglingParser<(anonymous namespace"
                         ")::itanium_demangle::ManglingParser<(anonymous namespace)::DefaultAllocator>, (anonymous namesp"
                         "ace)::DefaultAllocator>::OperatorInfo::getSymbol() const [Derived = (anonymous namespace)::itan"
                         "ium_demangle::ManglingParser<(anonymous namespace)::DefaultAllocator>, Alloc = (anonymous names"
                         "pace)::DefaultAllocator]",
                         "Res.startsWith(\"operator\") && \"operator name does not start with 'operator'\"");
      *(_BYTE *)(a1 + 776) = v11;
      sub_65E10(v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142);
    }
    v24 = v19 + 8;
    if ( v22 >= 9 && *v24 == 32 )
      v24 = v19 + 9;
    while ( 2 )
    {
      v27 = v23;
      v28 = v19;
      v26 = &v19[v22];
      result = 0;
      *(_QWORD *)&v144 = v24;
      *((_QWORD *)&v144 + 1) = v26;
      switch ( v21 )
      {
        case 0:
          __asm { BTI             j; jumptable 0000000000052960 case 0 }
          v29 = v18[3];
          result = (char *)sub_52694(a1);
          if ( !result )
            goto LABEL_3;
          v30 = *(_QWORD **)(a1 + 4912);
          v31 = result;
          v32 = v30[1];
          if ( (unsigned __int64)(v32 - 4032) > 0xFFFFFFFFFFFFF00FLL )
            goto LABEL_41;
          v33 = malloc(0x1000u);
          if ( !v33 )
            goto LABEL_204;
          v32 = 0;
          *v33 = v30;
          v33[1] = 0;
          v30 = v33;
          *(_QWORD *)(a1 + 4912) = v33;
LABEL_41:
          v34 = v32 + 48;
          v35 = (char **)((char *)v30 + v34);
          v30[1] = v34;
          LOWORD(v34) = *(_WORD *)((char *)v30 + v34 - 23);
          *(v35 - 2) = (char *)v24;
          *(v35 - 1) = (char *)v26;
          *((_BYTE *)v35 - 24) = 62;
          *v35 = v31;
          *(_WORD *)((char *)v35 - 23) = v34 & 0xF000 | (v29 >> 1) | 0x540;
          *(v35 - 4) = (char *)off_70148;
          result = (char *)(v35 - 4);
          goto LABEL_3;
        case 1:
          __asm { BTI             j; jumptable 0000000000052960 case 1 }
          if ( v20 == v2 || *v20 != 95 )
          {
            result = (char *)sub_52694(a1);
            *(_QWORD *)&v147 = result;
            if ( result )
            {
              LODWORD(v143) = (char)v18[3] >> 1;
              result = (char *)sub_537A8(a1, (__int64 *)&v147, &v144, &v143);
            }
          }
          else
          {
            v47 = (char)v18[3];
            *(_QWORD *)&v147 = v24;
            *((_QWORD *)&v147 + 1) = v26;
            *(_QWORD *)a1 = v1 + 3;
            LODWORD(v145) = v47 >> 1;
            result = (char *)sub_52694(a1);
            *(_QWORD *)&v143 = result;
            if ( result )
              result = (char *)sub_56B08(a1, &v147, (__int64 *)&v143, &v145);
          }
          goto LABEL_3;
        case 2:
          __asm { BTI             j; jumptable 0000000000052960 case 2 }
          v48 = (char)v18[3];
          *(_QWORD *)&v147 = v24;
          *((_QWORD *)&v147 + 1) = v26;
          v146 = v48 >> 1;
          result = (char *)sub_52694(a1);
          *(_QWORD *)&v143 = result;
          if ( result )
          {
            result = (char *)sub_52694(a1);
            v145 = result;
            if ( result )
              result = (char *)sub_565E0(a1, (__int64 *)&v143, &v147, (__int64 *)&v145, &v146);
          }
          goto LABEL_3;
        case 3:
          __asm { BTI             j; jumptable 0000000000052960 case 3 }
          result = (char *)sub_52694(a1);
          *(_QWORD *)&v147 = result;
          if ( result )
          {
            result = (char *)sub_52694(a1);
            *(_QWORD *)&v143 = result;
            if ( result )
            {
              LODWORD(v145) = (char)v18[3] >> 1;
              result = (char *)sub_53868(a1, (__int64 *)&v147, (__int64 *)&v143, &v145);
            }
          }
          goto LABEL_3;
        case 4:
          __asm { BTI             j; jumptable 0000000000052960 case 4 }
          result = (char *)sub_52694(a1);
          *(_QWORD *)&v147 = result;
          if ( result )
          {
            result = (char *)sub_52694(a1);
            *(_QWORD *)&v143 = result;
            if ( result )
            {
              LODWORD(v145) = (char)v18[3] >> 1;
              result = (char *)sub_53928(a1, (__int64 *)&v147, &v144, (__int64 *)&v143, &v145);
            }
          }
          goto LABEL_3;
        case 5:
          __asm { BTI             j; jumptable 0000000000052960 case 5 }
          v49 = (_BYTE *)(a1 + 40);
          v50 = (__int64)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          while ( 2 )
          {
            if ( v20 == v2 || *v20 != 95 )
            {
              result = (char *)sub_52694(a1);
              if ( !result )
                goto LABEL_3;
              v52 = *(char **)(a1 + 24);
              v53 = result;
              if ( v52 != *(char **)(a1 + 32) )
              {
LABEL_80:
                *(_QWORD *)(a1 + 24) = v52 + 8;
                *(_QWORD *)v52 = v53;
                v20 = *(unsigned __int8 **)a1;
                v2 = *(unsigned __int8 **)(a1 + 8);
                continue;
              }
              v54 = *(_BYTE **)(a1 + 16);
              v55 = v52 - v54;
              if ( v54 == v49 )
              {
                v56 = (char *)malloc(2 * (v52 - v54));
                if ( v56 )
                {
                  v51 = v56;
                  memcpy(v56, (const void *)(a1 + 40), v55);
                  *(_QWORD *)(a1 + 16) = v51;
                  goto LABEL_79;
                }
              }
              else
              {
                v51 = (char *)realloc(v54, 2 * (v52 - v54));
                *(_QWORD *)(a1 + 16) = v51;
                if ( v51 )
                {
LABEL_79:
                  v52 = &v51[v55];
                  *(_QWORD *)(a1 + 24) = &v51[v55];
                  *(_QWORD *)(a1 + 32) = &v51[8 * (v55 >> 2)];
                  goto LABEL_80;
                }
              }
LABEL_204:
              std::terminate();
            }
            break;
          }
          *(_QWORD *)a1 = v20 + 1;
          *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v50);
          *((_QWORD *)&v147 + 1) = v84;
          result = (char *)sub_4DAC4(a1);
          v145 = result;
          if ( !result )
            goto LABEL_3;
          v85 = sub_4CE60(a1, "pi", (__int64)"");
          v86 = *(_QWORD *)(a1 + 16);
          v87 = *(_QWORD *)(a1 + 24);
          if ( (v85 & 1) != 0 )
          {
            while ( 1 )
            {
              v88 = *(unsigned __int8 **)a1;
              if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v88 == 69 )
                goto LABEL_134;
              result = (char *)sub_52694(a1);
              if ( !result )
                goto LABEL_3;
              v93 = *(char **)(a1 + 24);
              v94 = result;
              if ( v93 == *(char **)(a1 + 32) )
              {
                v95 = *(_BYTE **)(a1 + 16);
                v96 = v93 - v95;
                if ( v95 == v49 )
                {
                  v97 = (char *)malloc(2 * (v93 - v95));
                  if ( !v97 )
                    goto LABEL_204;
                  v92 = v97;
                  memcpy(v97, (const void *)(a1 + 40), v96);
                  *(_QWORD *)(a1 + 16) = v92;
                }
                else
                {
                  v92 = (char *)realloc(v95, 2 * (v93 - v95));
                  *(_QWORD *)(a1 + 16) = v92;
                  if ( !v92 )
                    goto LABEL_204;
                }
                v93 = &v92[v96];
                *(_QWORD *)(a1 + 24) = &v92[v96];
                *(_QWORD *)(a1 + 32) = &v92[8 * (v96 >> 2)];
              }
              *(_QWORD *)(a1 + 24) = v93 + 8;
              *(_QWORD *)v93 = v94;
            }
          }
          v88 = *(unsigned __int8 **)a1;
          if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v88 == 69 )
          {
LABEL_134:
            *(_QWORD *)a1 = v88 + 1;
            v89 = sub_4F750((_QWORD *)a1, (v87 - v86) >> 3);
            v90 = (char)v18[3];
            *(_QWORD *)&v143 = v89;
            *((_QWORD *)&v143 + 1) = v91;
            v146 = v90 >> 1;
            result = (char *)sub_539F4(a1, &v147, (__int64 *)&v145, &v143, v11, v90 & 1, (__int16 *)&v146);
            goto LABEL_3;
          }
          goto LABEL_2;
        case 6:
          __asm { BTI             j; jumptable 0000000000052960 case 6 }
          result = (char *)sub_52694(a1);
          if ( !result )
            goto LABEL_3;
          v57 = *(_QWORD **)(a1 + 4912);
          v58 = result;
          v59 = v18[3];
          v60 = v57[1];
          if ( (unsigned __int64)(v60 - 4048) > 0xFFFFFFFFFFFFF00FLL )
            goto LABEL_92;
          v61 = malloc(0x1000u);
          if ( !v61 )
            goto LABEL_204;
          v60 = 0;
          *v61 = v57;
          v61[1] = 0;
          v57 = v61;
          *(_QWORD *)(a1 + 4912) = v61;
LABEL_92:
          v62 = v60 + 32;
          v63 = (char *)v57 + v62;
          v57[1] = v62;
          LOWORD(v62) = *(_WORD *)((char *)v57 + v62 - 7);
          *(_QWORD *)v63 = v58;
          *(v63 - 8) = 61;
          v63[8] = v11;
          *(_WORD *)(v63 - 7) = v62 & 0xF000 | (v59 >> 1) | 0x540;
          v63[9] = v59 & 1;
          *((_QWORD *)v63 - 2) = off_70378;
          result = v63 - 16;
          goto LABEL_3;
        case 7:
          __asm { BTI             j; jumptable 0000000000052960 case 7 }
          result = (char *)sub_52694(a1);
          *(_QWORD *)&v143 = result;
          if ( !result )
            goto LABEL_3;
          v64 = (__int64)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          while ( 2 )
          {
            v67 = *(unsigned __int8 **)a1;
            if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v67 != 69 )
            {
              result = (char *)sub_52694(a1);
              if ( !result )
                goto LABEL_3;
              v66 = *(char **)(a1 + 24);
              v68 = result;
              if ( v66 == *(char **)(a1 + 32) )
              {
                v69 = *(_BYTE **)(a1 + 16);
                v70 = v66 - v69;
                if ( v69 == (_BYTE *)(a1 + 40) )
                {
                  v71 = (char *)malloc(2 * (v66 - v69));
                  if ( !v71 )
                    goto LABEL_204;
                  v65 = v71;
                  memcpy(v71, (const void *)(a1 + 40), v70);
                  *(_QWORD *)(a1 + 16) = v65;
                }
                else
                {
                  v65 = (char *)realloc(v69, 2 * (v66 - v69));
                  *(_QWORD *)(a1 + 16) = v65;
                  if ( !v65 )
                    goto LABEL_204;
                }
                v66 = &v65[v70];
                *(_QWORD *)(a1 + 24) = &v65[v70];
                *(_QWORD *)(a1 + 32) = &v65[8 * (v70 >> 2)];
              }
              *(_QWORD *)(a1 + 24) = v66 + 8;
              *(_QWORD *)v66 = v68;
              continue;
            }
            break;
          }
          *(_QWORD *)a1 = v67 + 1;
          v100 = sub_4F750((_QWORD *)a1, v64);
          v101 = (char)v18[3];
          *(_QWORD *)&v147 = v100;
          *((_QWORD *)&v147 + 1) = v102;
          v103 = &v143;
          v104 = v101 >> 1;
          goto LABEL_152;
        case 8:
          __asm { BTI             j; jumptable 0000000000052960 case 8 }
          v72 = *(_BYTE *)(a1 + 776);
          *(_BYTE *)(a1 + 776) = 0;
          result = (char *)sub_4DAC4(a1);
          *(_QWORD *)&v143 = result;
          *(_BYTE *)(a1 + 776) = v72;
          if ( !result )
            goto LABEL_3;
          v73 = *(unsigned __int8 **)a1;
          v74 = *(unsigned __int8 **)(a1 + 8);
          v75 = (__int64)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          if ( *(unsigned __int8 **)a1 == v74 )
            goto LABEL_159;
          v76 = *v73;
          if ( v76 == 95 )
          {
            *(_QWORD *)a1 = ++v73;
            while ( v73 == v74 || *v73 != 69 )
            {
              result = (char *)sub_52694(a1);
              if ( !result )
                goto LABEL_3;
              v78 = *(char **)(a1 + 24);
              v79 = result;
              if ( v78 == *(char **)(a1 + 32) )
              {
                v80 = *(_BYTE **)(a1 + 16);
                v81 = v78 - v80;
                if ( v80 == (_BYTE *)(a1 + 40) )
                {
                  v82 = (char *)malloc(2 * (v78 - v80));
                  if ( !v82 )
                    goto LABEL_204;
                  v77 = v82;
                  memcpy(v82, (const void *)(a1 + 40), v81);
                  *(_QWORD *)(a1 + 16) = v77;
                }
                else
                {
                  v77 = (char *)realloc(v80, 2 * (v78 - v80));
                  *(_QWORD *)(a1 + 16) = v77;
                  if ( !v77 )
                    goto LABEL_204;
                }
                v78 = &v77[v81];
                *(_QWORD *)(a1 + 24) = &v77[v81];
                *(_QWORD *)(a1 + 32) = &v77[8 * (v81 >> 2)];
              }
              *(_QWORD *)(a1 + 24) = v78 + 8;
              *(_QWORD *)v78 = v79;
              v73 = *(unsigned __int8 **)a1;
              v74 = *(unsigned __int8 **)(a1 + 8);
            }
          }
          else if ( v76 != 69 )
          {
LABEL_159:
            result = (char *)sub_52694(a1);
            if ( !result )
              goto LABEL_3;
            v106 = *(char **)(a1 + 24);
            v107 = result;
            if ( v106 == *(char **)(a1 + 32) )
            {
              v108 = *(_BYTE **)(a1 + 16);
              v109 = v106 - v108;
              if ( v108 == (_BYTE *)(a1 + 40) )
              {
                v114 = (char *)malloc(2 * (v106 - v108));
                if ( !v114 )
                  goto LABEL_204;
                v110 = v114;
                memcpy(v114, (const void *)(a1 + 40), v109);
                *(_QWORD *)(a1 + 16) = v110;
              }
              else
              {
                v110 = (char *)realloc(v108, 2 * (v106 - v108));
                *(_QWORD *)(a1 + 16) = v110;
                if ( !v110 )
                  goto LABEL_204;
              }
              v106 = &v110[v109];
              *(_QWORD *)(a1 + 24) = &v110[v109];
              *(_QWORD *)(a1 + 32) = &v110[8 * (v109 >> 2)];
            }
            *(_QWORD *)(a1 + 24) = v106 + 8;
            *(_QWORD *)v106 = v107;
            *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v75);
            *((_QWORD *)&v147 + 1) = v115;
            if ( v115 == 1 )
            {
LABEL_182:
              LODWORD(v145) = (char)v18[3] >> 1;
              result = (char *)sub_53BA8(a1, (__int64 *)&v143, &v147, &v145);
              goto LABEL_3;
            }
LABEL_2:
            result = 0;
            goto LABEL_3;
          }
          *(_QWORD *)a1 = v73 + 1;
          *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v75);
          *((_QWORD *)&v147 + 1) = v105;
          if ( v76 == 95 || v105 == 1 )
            goto LABEL_182;
          goto LABEL_2;
        case 9:
          __asm { BTI             j; jumptable 0000000000052960 case 9 }
          result = (char *)sub_52694(a1);
          *(_QWORD *)&v147 = result;
          if ( result )
          {
            result = (char *)sub_52694(a1);
            *(_QWORD *)&v143 = result;
            if ( result )
            {
              result = (char *)sub_52694(a1);
              v145 = result;
              if ( result )
              {
                v146 = (char)v18[3] >> 1;
                result = (char *)sub_53C68(a1, (__int64 *)&v147, (__int64 *)&v143, (__int64 *)&v145, &v146);
              }
            }
          }
          goto LABEL_3;
        case 10:
          goto LABEL_3;
        default:
          v19 = v28;
          v23 = v27;
          v24 = v28;
          continue;
      }
    }
  }
  switch ( v13 )
  {
    case 'f':
      v25 = v1[1];
      if ( v25 != 112 && (v25 != 76 || v3 < 3 || (unsigned int)v1[2] - 58 < 0xFFFFFFF6) )
        JUMPOUT(0x55008);
      return sub_54C24((const char **)a1);
    case 'T':
      return (char *)sub_5158C(a1, v10);
    case 'L':
      JUMPOUT(0x53E00);
    default:
      if ( !strncmp("il", (const char *)v1, 2u) )
      {
        v36 = *(_QWORD *)(a1 + 16);
        v37 = *(_QWORD *)(a1 + 24);
        v38 = v1 + 2;
        *(_QWORD *)a1 = v1 + 2;
        v39 = (v37 - v36) >> 3;
        while ( v38 == v2 || *v38 != 69 )
        {
          result = (char *)sub_552C4(a1);
          if ( !result )
            goto LABEL_3;
          v41 = *(char **)(a1 + 24);
          v42 = result;
          if ( v41 == *(char **)(a1 + 32) )
          {
            v43 = *(_BYTE **)(a1 + 16);
            v44 = v41 - v43;
            if ( v43 == (_BYTE *)(a1 + 40) )
            {
              v45 = (char *)malloc(2 * (v41 - v43));
              if ( !v45 )
                goto LABEL_204;
              v40 = v45;
              memcpy(v45, (const void *)(a1 + 40), v44);
              *(_QWORD *)(a1 + 16) = v40;
            }
            else
            {
              v40 = (char *)realloc(v43, 2 * (v41 - v43));
              *(_QWORD *)(a1 + 16) = v40;
              if ( !v40 )
                goto LABEL_204;
            }
            v41 = &v40[v44];
            *(_QWORD *)(a1 + 24) = &v40[v44];
            *(_QWORD *)(a1 + 32) = &v40[8 * (v44 >> 2)];
          }
          *(_QWORD *)(a1 + 24) = v41 + 8;
          *(_QWORD *)v41 = v42;
          v38 = *(unsigned __int8 **)a1;
          v2 = *(unsigned __int8 **)(a1 + 8);
        }
        *(_QWORD *)a1 = v38 + 1;
        *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v39);
        *((_QWORD *)&v147 + 1) = v46;
        result = (char *)sub_55520(a1, &v147);
        goto LABEL_3;
      }
      if ( (unsigned __int64)(v2 - v1) >= 2 && !strncmp("mc", (const char *)v1, 2u) )
      {
        *(_QWORD *)a1 = v1 + 2;
        JUMPOUT(0x555C4);
      }
      if ( (sub_4CE60(a1, "nx", (__int64)"") & 1) != 0 )
      {
        result = (char *)sub_52694(a1);
        *(_QWORD *)&v147 = result;
        if ( result )
        {
          LODWORD(v144) = 2;
          result = (char *)sub_5573C(a1, (__int64 *)&v147, &v144);
        }
        goto LABEL_3;
      }
      if ( (sub_4CE60(a1, "so", (__int64)"") & 1) != 0 )
        JUMPOUT(0x55800);
      if ( (sub_4CE60(a1, "sp", (__int64)"") & 1) != 0 )
      {
        result = (char *)sub_52694(a1);
        *(_QWORD *)&v147 = result;
        if ( result )
          result = (char *)sub_55B54(a1, (__int64 *)&v147);
        goto LABEL_3;
      }
      if ( (sub_4CE60(a1, "sZ", (__int64)"") & 1) != 0 )
      {
        if ( *(_QWORD *)(a1 + 8) != *(_QWORD *)a1 && **(_BYTE **)a1 == 84 )
        {
          result = (char *)sub_5158C(a1, v83);
          *(_QWORD *)&v147 = result;
          if ( result )
            result = (char *)sub_55BF8(a1, (__int64 *)&v147);
          goto LABEL_3;
        }
        result = sub_54C24((const char **)a1);
        *(_QWORD *)&v147 = result;
        if ( !result )
        {
LABEL_3:
          __asm { BTI             j; jumptable 0000000000052960 case 10 }
          return result;
        }
LABEL_174:
        result = (char *)sub_55C9C(a1, (__int64 *)&v147);
        goto LABEL_3;
      }
      if ( (sub_4CE60(a1, "sP", (__int64)"") & 1) != 0 )
      {
        v98 = (__int64)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
        v99 = *(unsigned __int8 **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) )
          goto LABEL_148;
LABEL_147:
        if ( *v99 != 69 )
        {
LABEL_148:
          while ( 1 )
          {
            result = (char *)sub_4F358(a1);
            *(_QWORD *)&v147 = result;
            if ( !result )
              goto LABEL_3;
            sub_4F5F4((_QWORD *)(a1 + 16), (__int64 *)&v147);
            v99 = *(unsigned __int8 **)a1;
            if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
              goto LABEL_147;
          }
        }
        *(_QWORD *)a1 = v99 + 1;
        *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v98);
        *((_QWORD *)&v147 + 1) = v113;
        *(_QWORD *)&v147 = sub_55D54(a1, &v147);
        goto LABEL_174;
      }
      if ( (sub_4CE60(a1, "tl", (__int64)"") & 1) != 0 )
      {
        result = (char *)sub_4DAC4(a1);
        *(_QWORD *)&v144 = result;
        if ( result )
        {
          v111 = (__int64)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          v112 = *(unsigned __int8 **)a1;
          if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) )
            goto LABEL_168;
LABEL_167:
          if ( *v112 == 69 )
          {
            *(_QWORD *)a1 = v112 + 1;
            *(_QWORD *)&v147 = sub_4F750((_QWORD *)a1, v111);
            *((_QWORD *)&v147 + 1) = v121;
            result = (char *)sub_55DF4(a1, (__int64 *)&v144, &v147);
          }
          else
          {
LABEL_168:
            while ( 1 )
            {
              result = (char *)sub_552C4(a1);
              *(_QWORD *)&v147 = result;
              if ( !result )
                break;
              sub_4F5F4((_QWORD *)(a1 + 16), (__int64 *)&v147);
              v112 = *(unsigned __int8 **)a1;
              if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
                goto LABEL_167;
            }
          }
        }
        goto LABEL_3;
      }
      if ( (sub_4CE60(a1, "tr", (__int64)"") & 1) != 0 )
        JUMPOUT(0x55EA0);
      if ( (sub_4CE60(a1, "tw", (__int64)"") & 1) != 0 )
      {
        result = (char *)sub_52694(a1);
        *(_QWORD *)&v147 = result;
        if ( result )
          result = (char *)sub_55F50(a1, (__int64 *)&v147);
        goto LABEL_3;
      }
      v116 = *(unsigned __int8 **)a1;
      if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v116 != 117 )
        JUMPOUT(0x55FF4);
      *(_QWORD *)a1 = v116 + 1;
      result = (char *)sub_50964((const char **)a1);
      *(_QWORD *)&v144 = result;
      if ( !result )
        goto LABEL_3;
      v117 = (const char *)(*(__int64 (__fastcall **)(char *))(*(_QWORD *)result + 48LL))(result);
      if ( v118 - (_QWORD)v117 == 8 && !strncmp(v117, "__uuidof", 8u) )
      {
        v124 = *(unsigned __int8 **)a1;
        if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
        {
          v125 = *v124;
          if ( v125 == 122 )
          {
            *(_QWORD *)a1 = v124 + 1;
            result = (char *)sub_52694(a1);
            goto LABEL_202;
          }
          if ( v125 == 116 )
          {
            *(_QWORD *)a1 = v124 + 1;
            result = (char *)sub_4DAC4(a1);
LABEL_202:
            *(_QWORD *)&v143 = result;
            if ( !result )
              goto LABEL_3;
            v119 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
            sub_4F5F4((_QWORD *)(a1 + 16), (__int64 *)&v143);
            goto LABEL_196;
          }
        }
      }
      v119 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
      v120 = *(unsigned __int8 **)a1;
      if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) )
        goto LABEL_190;
LABEL_189:
      if ( *v120 != 69 )
      {
LABEL_190:
        while ( 1 )
        {
          result = (char *)sub_4F358(a1);
          *(_QWORD *)&v147 = result;
          if ( !result )
            goto LABEL_3;
          sub_4F5F4((_QWORD *)(a1 + 16), (__int64 *)&v147);
          v120 = *(unsigned __int8 **)a1;
          if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
            goto LABEL_189;
        }
      }
      *(_QWORD *)a1 = v120 + 1;
LABEL_196:
      v122 = sub_4F750((_QWORD *)a1, v119 >> 3);
      v104 = 1;
      *(_QWORD *)&v147 = v122;
      *((_QWORD *)&v147 + 1) = v123;
      v103 = &v144;
LABEL_152:
      LODWORD(v145) = v104;
      result = (char *)sub_53AE8(a1, (__int64 *)v103, &v147, &v145);
      goto LABEL_3;
  }
}
// 5285C: control flows out of bounds to 53E00
// 52A3C: control flows out of bounds to 55008
// 52B30: control flows out of bounds to 55800
// 52BC0: control flows out of bounds to 555C4
// 53500: control flows out of bounds to 55EA0
// 536F0: control flows out of bounds to 55FF4
// 527FC: conditional instruction was optimized away because x23.8>=8u
// 528B8: variable 'v10' is possibly undefined
// 52B48: variable 'v46' is possibly undefined
// 53120: variable 'v83' is possibly undefined
// 531DC: variable 'v84' is possibly undefined
// 53240: variable 'v91' is possibly undefined
// 5338C: variable 'v102' is possibly undefined
// 533E4: variable 'v105' is possibly undefined
// 53518: variable 'v113' is possibly undefined
// 535C0: variable 'v115' is possibly undefined
// 53628: variable 'v118' is possibly undefined
// 536AC: variable 'v121' is possibly undefined
// 5370C: variable 'v123' is possibly undefined
// 537A4: variable 'v127' is possibly undefined
// 537A4: variable 'v128' is possibly undefined
// 537A4: variable 'v129' is possibly undefined
// 537A4: variable 'v130' is possibly undefined
// 537A4: variable 'v131' is possibly undefined
// 537A4: variable 'v132' is possibly undefined
// 537A4: variable 'v133' is possibly undefined
// 537A4: variable 'v134' is possibly undefined
// 537A4: variable 'v135' is possibly undefined
// 537A4: variable 'v136' is possibly undefined
// 537A4: variable 'v137' is possibly undefined
// 537A4: variable 'v138' is possibly undefined
// 537A4: variable 'v139' is possibly undefined
// 537A4: variable 'v140' is possibly undefined
// 537A4: variable 'v141' is possibly undefined
// 537A4: variable 'v142' is possibly undefined
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 4F358: using guessed type __int64 __fastcall sub_4F358(_QWORD);
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 70148: using guessed type __int64 (__fastcall *off_70148[10])();
// 70378: using guessed type __int64 (__fastcall *off_70378[10])();

//----- (00000000000537A8) ----------------------------------------------------
__int64 __fastcall sub_537A8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x10
  __int128 v13; // q0
  char v14; // w9
  __int64 result; // x0

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 48;
  v12 = *a2;
  v4[1] = v11;
  v13 = *a3;
  v14 = *a4;
  *(_QWORD *)((char *)v4 + v11 - 32) = off_701B8;
  result = (__int64)v4 + v11 - 32;
  LOWORD(v11) = *(_WORD *)((char *)v4 + v11 - 23);
  *(_BYTE *)(result + 8) = 52;
  *(_QWORD *)(result + 16) = v12;
  *(_WORD *)(result + 9) = v11 & 0xF000 | v14 & 0x3F | 0x540;
  *(_OWORD *)(result + 24) = v13;
  return result;
}
// 701B8: using guessed type __int64 (__fastcall *off_701B8[10])();

//----- (0000000000053868) ----------------------------------------------------
_QWORD *__fastcall sub_53868(__int64 a1, __int64 *a2, __int64 *a3, _WORD *a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  _QWORD *v12; // x9
  __int64 v13; // x10
  _QWORD *result; // x0
  __int64 v15; // x11

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 32;
  v12 = (_QWORD *)((char *)v4 + v11);
  v4[1] = v11;
  LOWORD(v11) = *(_WORD *)((_BYTE *)v4 + v11 - 7) & 0xF000 | *a4 & 0x3F | 0x540;
  *((_BYTE *)v12 - 8) = 51;
  v13 = *a2;
  *(v12 - 2) = off_70228;
  result = v12 - 2;
  v15 = *a3;
  *(_WORD *)((char *)v12 - 7) = v11;
  *v12 = v13;
  v12[1] = v15;
  return result;
}
// 70228: using guessed type __int64 (__fastcall *off_70228[10])();

//----- (0000000000053928) ----------------------------------------------------
__int64 __fastcall sub_53928(__int64 a1, __int64 *a2, __int128 *a3, __int64 *a4, _WORD *a5)
{
  _QWORD *v5; // x24
  __int64 v10; // x8
  _QWORD *v12; // x0
  __int64 v13; // x8
  __int64 v14; // x10
  __int64 v15; // x12
  __int128 v16; // q0
  char v17; // w9
  __int64 result; // x0

  v5 = *(_QWORD **)(a1 + 4912);
  v10 = v5[1];
  if ( (unsigned __int64)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v12 = malloc(0x1000u);
    if ( !v12 )
      std::terminate();
    v10 = 0;
    *v12 = v5;
    v12[1] = 0;
    v5 = v12;
    *(_QWORD *)(a1 + 4912) = v12;
  }
  v13 = v10 + 48;
  v14 = *a2;
  v15 = *a4;
  v5[1] = v13;
  v16 = *a3;
  v17 = *a5;
  *(_QWORD *)((char *)v5 + v13 - 32) = off_70298;
  result = (__int64)v5 + v13 - 32;
  LOWORD(v13) = *(_WORD *)((char *)v5 + v13 - 23);
  *(_BYTE *)(result + 8) = 54;
  *(_QWORD *)(result + 16) = v14;
  *(_OWORD *)(result + 24) = v16;
  *(_WORD *)(result + 9) = v13 & 0xF000 | v17 & 0x3F | 0x540;
  *(_QWORD *)(result + 40) = v15;
  return result;
}
// 70298: using guessed type __int64 (__fastcall *off_70298[10])();

//----- (00000000000539F4) ----------------------------------------------------
__int64 __fastcall sub_539F4(__int64 a1, __int128 *a2, __int64 *a3, __int128 *a4, char a5, char a6, __int16 *a7)
{
  _QWORD *v7; // x26
  __int64 v13; // x8
  _QWORD *v16; // x0
  __int64 v17; // x8
  __int64 v18; // x9
  __int128 v19; // q0
  __int128 v20; // q1
  __int16 v21; // w10
  __int64 result; // x0

  v7 = *(_QWORD **)(a1 + 4912);
  v13 = v7[1];
  if ( (unsigned __int64)(v13 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v16 = malloc(0x1000u);
    if ( !v16 )
      std::terminate();
    v13 = 0;
    *v16 = v7;
    v16[1] = 0;
    v7 = v16;
    *(_QWORD *)(a1 + 4912) = v16;
  }
  v17 = v13 + 64;
  v18 = *a3;
  v7[1] = v17;
  v19 = *a2;
  v20 = *a4;
  v21 = *a7;
  *(_QWORD *)((char *)v7 + v17 - 48) = off_70308;
  result = (__int64)v7 + v17 - 48;
  LOWORD(v17) = *(_WORD *)((char *)v7 + v17 - 39);
  *(_QWORD *)(result + 32) = v18;
  *(_BYTE *)(result + 8) = 60;
  *(_OWORD *)(result + 16) = v19;
  *(_OWORD *)(result + 40) = v20;
  *(_BYTE *)(result + 56) = a5 != 0;
  *(_WORD *)(result + 9) = v17 & 0xF000 | v21 & 0x3F | 0x540;
  *(_BYTE *)(result + 57) = a6 != 0;
  return result;
}
// 70308: using guessed type __int64 (__fastcall *off_70308[10])();

//----- (0000000000053AE8) ----------------------------------------------------
__int64 __fastcall sub_53AE8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x10
  __int128 v13; // q0
  char v14; // w9
  __int64 result; // x0

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 48;
  v12 = *a2;
  v4[1] = v11;
  v13 = *a3;
  v14 = *a4;
  *(_QWORD *)((char *)v4 + v11 - 32) = off_703E8;
  result = (__int64)v4 + v11 - 32;
  LOWORD(v11) = *(_WORD *)((char *)v4 + v11 - 23);
  *(_BYTE *)(result + 8) = 59;
  *(_QWORD *)(result + 16) = v12;
  *(_WORD *)(result + 9) = v11 & 0xF000 | v14 & 0x3F | 0x540;
  *(_OWORD *)(result + 24) = v13;
  return result;
}
// 703E8: using guessed type __int64 (__fastcall *off_703E8[10])();

//----- (0000000000053BA8) ----------------------------------------------------
__int64 __fastcall sub_53BA8(__int64 a1, __int64 *a2, __int128 *a3, _WORD *a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x10
  __int128 v13; // q0
  char v14; // w9
  __int64 result; // x0

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 48;
  v12 = *a2;
  v4[1] = v11;
  v13 = *a3;
  v14 = *a4;
  *(_QWORD *)((char *)v4 + v11 - 32) = off_70458;
  result = (__int64)v4 + v11 - 32;
  LOWORD(v11) = *(_WORD *)((char *)v4 + v11 - 23);
  *(_BYTE *)(result + 8) = 64;
  *(_QWORD *)(result + 16) = v12;
  *(_WORD *)(result + 9) = v11 & 0xF000 | v14 & 0x3F | 0x540;
  *(_OWORD *)(result + 24) = v13;
  return result;
}
// 70458: using guessed type __int64 (__fastcall *off_70458[10])();

//----- (0000000000053C68) ----------------------------------------------------
_QWORD *__fastcall sub_53C68(__int64 a1, __int64 *a2, __int64 *a3, __int64 *a4, _WORD *a5)
{
  _QWORD *v5; // x24
  __int64 v10; // x8
  _QWORD *v12; // x0
  __int64 v13; // x8
  _QWORD *v14; // x9
  __int64 v15; // x12
  char v16; // w10
  _QWORD *result; // x0
  __int64 v18; // x11
  __int64 v19; // x10

  v5 = *(_QWORD **)(a1 + 4912);
  v10 = v5[1];
  if ( (unsigned __int64)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v12 = malloc(0x1000u);
    if ( !v12 )
      std::terminate();
    v10 = 0;
    *v12 = v5;
    v12[1] = 0;
    v5 = v12;
    *(_QWORD *)(a1 + 4912) = v12;
  }
  v13 = v10 + 48;
  v14 = (_QWORD *)((char *)v5 + v13);
  v15 = *a3;
  v5[1] = v13;
  LOWORD(v13) = *(_WORD *)((char *)v5 + v13 - 23);
  v16 = *a5;
  *(v14 - 4) = off_704C8;
  result = v14 - 4;
  LOWORD(v13) = v13 & 0xF000 | v16 & 0x3F | 0x540;
  v18 = *a2;
  *((_BYTE *)v14 - 24) = 53;
  v19 = *a4;
  *(_WORD *)((char *)v14 - 23) = v13;
  *(v14 - 2) = v18;
  *(v14 - 1) = v15;
  *v14 = v19;
  return result;
}
// 704C8: using guessed type __int64 (__fastcall *off_704C8[10])();

//----- (0000000000054C24) ----------------------------------------------------
char *__fastcall sub_54C24(const char **a1)
{
  const char *v1; // x20
  const char *v2; // x21
  unsigned __int64 v4; // x8
  char *result; // x0
  const char *v6; // x8
  const char *v7; // x9
  char *v8; // x8
  char *v9; // x10
  unsigned __int8 *v10; // x9
  char *v11; // x8
  char *v12; // x22
  unsigned __int8 *v13; // x20
  const char *v14; // x8
  const char *v15; // x20
  __int64 v16; // x8
  char *v17; // x0
  __int64 v18; // x8
  char *v19; // x0
  __int64 (__fastcall **v20)(); // x8
  const char *v21; // x21
  __int64 v22; // x8
  char *v23; // x0
  __int64 v24; // x8
  __int128 v25; // [xsp+50h] [xbp-10h] BYREF

  v1 = *a1;
  v2 = a1[1];
  v4 = v2 - *a1;
  if ( v4 >= 3 )
  {
    if ( !strncmp("fpT", v1, 3u) )
    {
      v14 = v1 + 3;
      v15 = a1[614];
      *a1 = v14;
      v16 = *((_QWORD *)v15 + 1);
      if ( (unsigned __int64)(v16 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v17 = (char *)malloc(0x1000u);
        if ( !v17 )
          goto LABEL_66;
        v16 = 0;
        *(_QWORD *)v17 = v15;
        *((_QWORD *)v17 + 1) = 0;
        v15 = v17;
        a1[614] = v17;
      }
      v18 = v16 + 32;
      v19 = (char *)&v15[v18];
      *((_QWORD *)v15 + 1) = v18;
      LOWORD(v18) = *(_WORD *)&v15[v18 - 7];
      *(v19 - 8) = 7;
      *(_WORD *)(v19 - 7) = v18 & 0xF000 | 0x540;
      v20 = off_6FBA8;
      *(_QWORD *)v19 = "this";
      *((_QWORD *)v19 + 1) = "";
LABEL_45:
      *((_QWORD *)v19 - 2) = v20;
      return v19 - 16;
    }
  }
  else if ( v4 != 2 )
  {
    return 0;
  }
  if ( !strncmp("fp", v1, 2u) )
  {
    v11 = (char *)(v1 + 2);
    *a1 = v1 + 2;
    if ( v1 + 2 == v2 )
      return 0;
    if ( *v11 == 114 )
    {
      v11 = (char *)(v1 + 3);
      *a1 = v1 + 3;
    }
    if ( v11 == v2 )
      return 0;
    if ( *v11 == 86 )
      *a1 = ++v11;
    if ( v11 == v2 )
      return 0;
    if ( *v11 == 75 )
      *a1 = ++v11;
    if ( v2 == v11 )
      return 0;
    if ( (unsigned int)(unsigned __int8)*v11 - 58 >= 0xFFFFFFF6 )
    {
      v13 = (unsigned __int8 *)v11;
      while ( (unsigned int)*v13 - 58 >= 0xFFFFFFF6 )
      {
        *a1 = (const char *)++v13;
        if ( v13 == (unsigned __int8 *)v2 )
        {
          v13 = (unsigned __int8 *)v2;
          break;
        }
      }
      v12 = v11;
      v11 = (char *)v13;
    }
    else
    {
      v12 = 0;
      v13 = 0;
    }
    if ( v11 == v2 || *v11 != 95 )
      return 0;
    v21 = a1[614];
    *a1 = v11 + 1;
    v22 = *((_QWORD *)v21 + 1);
    if ( (unsigned __int64)(v22 - 4048) > 0xFFFFFFFFFFFFF00FLL )
      goto LABEL_56;
    v23 = (char *)malloc(0x1000u);
    if ( v23 )
    {
      v22 = 0;
      *(_QWORD *)v23 = v21;
      *((_QWORD *)v23 + 1) = 0;
      v21 = v23;
      a1[614] = v23;
LABEL_56:
      v24 = v22 + 32;
      v19 = (char *)&v21[v24];
      *((_QWORD *)v21 + 1) = v24;
      LOWORD(v24) = *(_WORD *)&v21[v24 - 7];
      *(v19 - 8) = 63;
      *(_QWORD *)v19 = v12;
      *((_QWORD *)v19 + 1) = v13;
      *(_WORD *)(v19 - 7) = v24 & 0xF000 | 0x540;
      v20 = off_70CA8;
      goto LABEL_45;
    }
LABEL_66:
    std::terminate();
  }
  if ( strncmp("fL", v1, 2u) )
    return 0;
  v6 = v1 + 2;
  *a1 = v1 + 2;
  if ( v2 == v1 + 2 || (unsigned int)*(unsigned __int8 *)v6 - 58 < 0xFFFFFFF6 )
    return 0;
  v7 = v1 + 2;
  while ( (unsigned int)*(unsigned __int8 *)v7 - 58 >= 0xFFFFFFF6 )
  {
    *a1 = ++v7;
    if ( v7 == v2 )
    {
      v7 = v2;
      break;
    }
  }
  result = 0;
  if ( v6 != v7 && v7 != v2 )
  {
    if ( *v7 == 112 )
    {
      v8 = (char *)(v7 + 1);
      *a1 = v7 + 1;
      if ( v7 + 1 != v2 )
      {
        if ( *v8 == 114 )
        {
          v8 = (char *)(v7 + 2);
          *a1 = v7 + 2;
        }
        if ( v8 != v2 )
        {
          if ( *v8 == 86 )
            *a1 = ++v8;
          if ( v8 != v2 )
          {
            if ( *v8 == 75 )
              *a1 = ++v8;
            if ( v2 != v8 )
            {
              if ( (unsigned int)(unsigned __int8)*v8 - 58 >= 0xFFFFFFF6 )
              {
                v10 = (unsigned __int8 *)v8;
                while ( (unsigned int)*v10 - 58 >= 0xFFFFFFF6 )
                {
                  *a1 = (const char *)++v10;
                  if ( v10 == (unsigned __int8 *)v2 )
                  {
                    v10 = (unsigned __int8 *)v2;
                    break;
                  }
                }
                v9 = v8;
                v8 = (char *)v10;
              }
              else
              {
                v9 = 0;
                v10 = 0;
              }
              *(_QWORD *)&v25 = v9;
              *((_QWORD *)&v25 + 1) = v10;
              if ( v8 != v2 && *v8 == 95 )
              {
                *a1 = v8 + 1;
                return (char *)sub_5B188((__int64)a1, &v25);
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 70CA8: using guessed type __int64 (__fastcall *off_70CA8[10])();

//----- (00000000000552C4) ----------------------------------------------------
__int64 __fastcall sub_552C4(__int64 a1)
{
  const char *v1; // x8
  unsigned __int64 v3; // x9
  __int64 result; // x0
  int v6; // w9
  __int64 v7; // x20
  _QWORD *v8; // x22
  __int64 v9; // x21
  __int64 v10; // x8
  _QWORD *v11; // x0
  __int64 v12; // x8
  __int64 *v13; // x9
  __int64 *v14; // x0
  __int16 v15; // w8
  __int64 v16; // x20
  __int64 v17; // x21
  _QWORD *v18; // x23
  __int64 v19; // x22
  __int64 v20; // x8
  _QWORD *v21; // x0
  __int64 v22; // x8
  __int64 (__fastcall **v23)(); // x8
  __int64 v24; // x20
  _QWORD *v25; // x22
  __int64 v26; // x21
  __int64 v27; // x8
  _QWORD *v28; // x0
  __int64 v29; // x8

  v1 = *(const char **)a1;
  v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if ( !v3 )
    return sub_52694(a1);
  if ( *v1 != 100 || v3 < 2 )
    return sub_52694(a1);
  v6 = *((unsigned __int8 *)v1 + 1);
  switch ( v6 )
  {
    case 'X':
      *(_QWORD *)a1 = v1 + 2;
      result = sub_52694(a1);
      if ( result )
      {
        v16 = result;
        result = sub_52694(a1);
        if ( result )
        {
          v17 = result;
          result = sub_552C4(a1);
          if ( result )
          {
            v18 = *(_QWORD **)(a1 + 4912);
            v19 = result;
            v20 = v18[1];
            if ( (unsigned __int64)(v20 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
            {
              v21 = malloc(0x1000u);
              if ( !v21 )
                goto LABEL_32;
              v20 = 0;
              *v21 = v18;
              v21[1] = 0;
              v18 = v21;
              *(_QWORD *)(a1 + 4912) = v21;
            }
            v22 = v20 + 48;
            v14 = (_QWORD *)((char *)v18 + v22);
            v18[1] = v22;
            LOWORD(v22) = *(_WORD *)((char *)v18 + v22 - 23);
            *((_BYTE *)v14 - 24) = 78;
            *(v14 - 2) = v16;
            *(v14 - 1) = v17;
            *v14 = v19;
            *(_WORD *)((char *)v14 - 23) = v22 & 0xF000 | 0x540;
            v23 = off_70E68;
LABEL_30:
            *(v14 - 4) = (__int64)v23;
            return (__int64)(v14 - 4);
          }
        }
      }
      break;
    case 'x':
      *(_QWORD *)a1 = v1 + 2;
      result = sub_52694(a1);
      if ( result )
      {
        v24 = result;
        result = sub_552C4(a1);
        if ( result )
        {
          v25 = *(_QWORD **)(a1 + 4912);
          v26 = result;
          v27 = v25[1];
          if ( (unsigned __int64)(v27 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
          {
            v28 = malloc(0x1000u);
            if ( !v28 )
              goto LABEL_32;
            v27 = 0;
            *v28 = v25;
            v28[1] = 0;
            v25 = v28;
            *(_QWORD *)(a1 + 4912) = v28;
          }
          v29 = v27 + 48;
          v13 = (_QWORD *)((char *)v25 + v29);
          v14 = v13;
          v25[1] = v29;
          LOWORD(v29) = *(_WORD *)((char *)v25 + v29 - 23);
          *((_BYTE *)v13 - 24) = 77;
          *(v13 - 2) = v24;
          *(v13 - 1) = v26;
          v15 = v29 & 0xF000 | 0x540;
          *(_BYTE *)v13 = 1;
          goto LABEL_29;
        }
      }
      break;
    case 'i':
      *(_QWORD *)a1 = v1 + 2;
      result = sub_50964((const char **)a1);
      if ( result )
      {
        v7 = result;
        result = sub_552C4(a1);
        if ( result )
        {
          v8 = *(_QWORD **)(a1 + 4912);
          v9 = result;
          v10 = v8[1];
          if ( (unsigned __int64)(v10 - 4032) > 0xFFFFFFFFFFFFF00FLL )
          {
LABEL_15:
            v12 = v10 + 48;
            v13 = (_QWORD *)((char *)v8 + v12);
            v14 = v13;
            v8[1] = v12;
            LOWORD(v12) = *(_WORD *)((char *)v8 + v12 - 23);
            *((_BYTE *)v13 - 24) = 77;
            *(v13 - 2) = v7;
            *(v13 - 1) = v9;
            *(_BYTE *)v13 = 0;
            v15 = v12 & 0xF000 | 0x540;
LABEL_29:
            *(_WORD *)((char *)v13 - 23) = v15;
            v23 = off_70DF8;
            goto LABEL_30;
          }
          v11 = malloc(0x1000u);
          if ( v11 )
          {
            v10 = 0;
            *v11 = v8;
            v11[1] = 0;
            v8 = v11;
            *(_QWORD *)(a1 + 4912) = v11;
            goto LABEL_15;
          }
LABEL_32:
          std::terminate();
        }
      }
      break;
    default:
      return sub_52694(a1);
  }
  return result;
}
// 52694: using guessed type __int64 __fastcall sub_52694(_QWORD);
// 70DF8: using guessed type __int64 (__fastcall *off_70DF8[10])();
// 70E68: using guessed type __int64 (__fastcall *off_70E68[10])();

//----- (0000000000055520) ----------------------------------------------------
__int64 __fastcall sub_55520(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  __int128 v8; // q0
  __int64 result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v2[1] = v7;
  v8 = *a2;
  *(_QWORD *)((char *)v2 + v7 - 32) = off_70ED8;
  result = (__int64)v2 + v7 - 32;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *(_BYTE *)(result + 8) = 66;
  *(_QWORD *)(result + 16) = 0;
  *(_WORD *)(result + 9) = v7 & 0xF000 | 0x540;
  *(_OWORD *)(result + 24) = v8;
  return result;
}
// 70ED8: using guessed type __int64 (__fastcall *off_70ED8[10])();

//----- (000000000005573C) ----------------------------------------------------
_QWORD *__fastcall sub_5573C(__int64 a1, __int64 *a2, _WORD *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  char v11; // w10
  __int64 v12; // x10
  _QWORD *result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 64;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 39);
  v11 = *a3;
  *((_BYTE *)v10 - 40) = 56;
  LOWORD(v9) = v9 & 0xF000 | v11 & 0x3F;
  v12 = *a2;
  *(v10 - 1) = 0;
  *v10 = 0;
  *(v10 - 6) = off_705A8;
  result = v10 - 6;
  *(_WORD *)((char *)v10 - 39) = v9 | 0x540;
  *(v10 - 4) = "noexcept ";
  *(v10 - 3) = "";
  *(v10 - 2) = v12;
  return result;
}
// 705A8: using guessed type __int64 (__fastcall *off_705A8[10])();

//----- (0000000000055B54) ----------------------------------------------------
_QWORD *__fastcall sub_55B54(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 38;
  *(v8 - 2) = off_70D88;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 70D88: using guessed type __int64 (__fastcall *off_70D88[10])();

//----- (0000000000055BF8) ----------------------------------------------------
_QWORD *__fastcall sub_55BF8(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 58;
  *(v8 - 2) = off_71028;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 71028: using guessed type __int64 (__fastcall *off_71028[10])();

//----- (0000000000055C9C) ----------------------------------------------------
_QWORD *__fastcall sub_55C9C(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  __int64 v9; // x12
  _QWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 64;
  v8 = (_QWORD *)((char *)v2 + v7);
  v9 = *a2;
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 39);
  *((_BYTE *)v8 - 40) = 56;
  *(v8 - 1) = 0;
  *v8 = 0;
  *(v8 - 6) = off_705A8;
  result = v8 - 6;
  *(_WORD *)((char *)v8 - 39) = v7 & 0xF000 | 0x540;
  *(v8 - 4) = "sizeof... ";
  *(v8 - 3) = "";
  *(v8 - 2) = v9;
  return result;
}
// 705A8: using guessed type __int64 (__fastcall *off_705A8[10])();

//----- (0000000000055D54) ----------------------------------------------------
_OWORD *__fastcall sub_55D54(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _OWORD *v8; // x9
  __int128 v9; // q0
  _OWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_OWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  v9 = *a2;
  *((_BYTE *)v8 - 8) = 0;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *((_QWORD *)v8 - 2) = off_71098;
  result = v8 - 1;
  *v8 = v9;
  return result;
}
// 71098: using guessed type __int64 (__fastcall *off_71098[10])();

//----- (0000000000055DF4) ----------------------------------------------------
__int64 __fastcall sub_55DF4(__int64 a1, __int64 *a2, __int128 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  __int64 v10; // x9
  __int128 v11; // q0
  __int64 result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 48;
  v10 = *a2;
  v3[1] = v9;
  v11 = *a3;
  *(_QWORD *)((char *)v3 + v9 - 32) = off_70ED8;
  result = (__int64)v3 + v9 - 32;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 23);
  *(_BYTE *)(result + 8) = 66;
  *(_QWORD *)(result + 16) = v10;
  *(_WORD *)(result + 9) = v9 & 0xF000 | 0x540;
  *(_OWORD *)(result + 24) = v11;
  return result;
}
// 70ED8: using guessed type __int64 (__fastcall *off_70ED8[10])();

//----- (0000000000055F50) ----------------------------------------------------
_QWORD *__fastcall sub_55F50(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 68;
  *(v8 - 2) = off_71108;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 71108: using guessed type __int64 (__fastcall *off_71108[10])();

//----- (00000000000565E0) ----------------------------------------------------
__int64 __fastcall sub_565E0(__int64 a1, __int64 *a2, __int128 *a3, __int64 *a4, _WORD *a5)
{
  _QWORD *v5; // x24
  __int64 v10; // x8
  _QWORD *v12; // x0
  __int64 v13; // x8
  __int64 v14; // x10
  __int64 v15; // x12
  __int128 v16; // q0
  char v17; // w9
  __int64 result; // x0

  v5 = *(_QWORD **)(a1 + 4912);
  v10 = v5[1];
  if ( (unsigned __int64)(v10 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v12 = malloc(0x1000u);
    if ( !v12 )
      std::terminate();
    v10 = 0;
    *v12 = v5;
    v12[1] = 0;
    v5 = v12;
    *(_QWORD *)(a1 + 4912) = v12;
  }
  v13 = v10 + 48;
  v14 = *a2;
  v15 = *a4;
  v5[1] = v13;
  v16 = *a3;
  v17 = *a5;
  *(_QWORD *)((char *)v5 + v13 - 32) = off_700D8;
  result = (__int64)v5 + v13 - 32;
  LOWORD(v13) = *(_WORD *)((char *)v5 + v13 - 23);
  *(_BYTE *)(result + 8) = 50;
  *(_QWORD *)(result + 16) = v14;
  *(_OWORD *)(result + 24) = v16;
  *(_WORD *)(result + 9) = v13 & 0xF000 | v17 & 0x3F | 0x540;
  *(_QWORD *)(result + 40) = v15;
  return result;
}
// 700D8: using guessed type __int64 (__fastcall *off_700D8[10])();

//----- (00000000000566AC) ----------------------------------------------------
char *__fastcall sub_566AC(__int64 a1, __int64 a2)
{
  int v4; // w23
  int v5; // w8
  __int16 v6; // w24
  int v7; // w8
  int v8; // w2
  _BYTE *v9; // x9
  _BYTE *v10; // x21
  size_t v11; // x22
  __int64 v12; // x8
  size_t v13; // x9
  size_t v14; // x10
  unsigned __int64 v15; // x9
  char *v16; // x0
  size_t v17; // x1
  char *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x9
  size_t v21; // x8
  unsigned __int64 v22; // x9
  char *v23; // x0
  size_t v24; // x1
  char *v25; // x0
  const char *v26; // x0
  __int64 v27; // x2
  _BYTE *v28; // x9
  unsigned __int64 v29; // x9
  size_t v30; // x8
  unsigned __int64 v31; // x9
  char *v32; // x0
  size_t v33; // x1
  char *v34; // x0
  __int64 *v35; // x0
  char *result; // x0
  __int64 v37; // x8
  unsigned __int64 v38; // x10
  __int64 v39; // x9
  unsigned __int64 v40; // x8
  char *v41; // x0
  size_t v42; // x1
  __int64 v43; // x8
  unsigned __int64 v44; // x10
  __int64 v45; // x9
  unsigned __int64 v46; // x8
  char *v47; // x0
  size_t v48; // x1
  char *v49; // x0

  if ( *(_DWORD *)(a2 + 32) )
    goto LABEL_2;
  v26 = *(const char **)(a1 + 24);
  v27 = *(_QWORD *)(a1 + 32) - (_QWORD)v26;
  if ( v27 != 2 )
  {
    if ( v27 == 1 && *v26 == 62 )
      goto LABEL_47;
LABEL_2:
    v4 = 0;
    goto LABEL_3;
  }
  if ( strncmp(v26, ">>", 2u) )
    goto LABEL_2;
LABEL_47:
  v43 = *(_QWORD *)(a2 + 8);
  v44 = *(_QWORD *)(a2 + 16);
  v45 = v43 + 1;
  *(_DWORD *)(a2 + 32) = 1;
  if ( v43 + 1 <= v44 )
  {
    v49 = *(char **)a2;
  }
  else
  {
    v46 = v43 + 993;
    v47 = *(char **)a2;
    if ( 2 * v44 <= v46 )
      v48 = v46;
    else
      v48 = 2 * v44;
    *(_QWORD *)(a2 + 16) = v48;
    v49 = (char *)realloc(v47, v48);
    *(_QWORD *)a2 = v49;
    if ( !v49 )
      goto LABEL_55;
    v43 = *(_QWORD *)(a2 + 8);
    v45 = v43 + 1;
  }
  v4 = 1;
  *(_QWORD *)(a2 + 8) = v45;
  v49[v43] = 40;
LABEL_3:
  v5 = *(unsigned __int16 *)(a1 + 9);
  v6 = (_WORD)v5 << 10;
  v7 = v5 << 26 >> 26;
  if ( (v6 & 0xFC00) == 0x4400 )
    v8 = 15;
  else
    v8 = v7;
  sub_56990(*(__int64 **)(a1 + 16), a2, v8, (v6 & 0xFC00) != 17408);
  v10 = *(_BYTE **)(a1 + 24);
  v9 = *(_BYTE **)(a1 + 32);
  if ( v9 - v10 == 1 && *v10 == 44 )
  {
    v11 = 1;
    v12 = *(_QWORD *)(a2 + 8);
    if ( v9 != v10 )
      goto LABEL_9;
  }
  else
  {
    v19 = *(_QWORD *)(a2 + 8);
    v20 = *(_QWORD *)(a2 + 16);
    if ( v19 + 1 <= v20 )
    {
      v25 = *(char **)a2;
    }
    else
    {
      v21 = v19 + 993;
      v22 = 2 * v20;
      v23 = *(char **)a2;
      if ( v22 <= v21 )
        v24 = v21;
      else
        v24 = v22;
      *(_QWORD *)(a2 + 16) = v24;
      v25 = (char *)realloc(v23, v24);
      *(_QWORD *)a2 = v25;
      if ( !v25 )
        goto LABEL_55;
      v19 = *(_QWORD *)(a2 + 8);
    }
    v25[v19] = 32;
    v12 = *(_QWORD *)(a2 + 8) + 1LL;
    *(_QWORD *)(a2 + 8) = v12;
    v10 = *(_BYTE **)(a1 + 24);
    v28 = *(_BYTE **)(a1 + 32);
    v11 = v28 - v10;
    if ( v28 != v10 )
    {
LABEL_9:
      v13 = *(_QWORD *)(a2 + 16);
      v14 = v12 + v11;
      if ( v12 + v11 <= v13 )
      {
        v18 = *(char **)a2;
      }
      else
      {
        v15 = 2 * v13;
        v16 = *(char **)a2;
        if ( v15 <= v14 + 992 )
          v17 = v14 + 992;
        else
          v17 = v15;
        *(_QWORD *)(a2 + 16) = v17;
        v18 = (char *)realloc(v16, v17);
        *(_QWORD *)a2 = v18;
        if ( !v18 )
          goto LABEL_55;
        v12 = *(_QWORD *)(a2 + 8);
      }
      memcpy(&v18[v12], v10, v11);
      v29 = *(_QWORD *)(a2 + 16);
      v12 = *(_QWORD *)(a2 + 8) + v11;
      *(_QWORD *)(a2 + 8) = v12;
      if ( v12 + 1 <= v29 )
        goto LABEL_35;
      goto LABEL_28;
    }
  }
  v29 = *(_QWORD *)(a2 + 16);
  if ( v12 + 1 <= v29 )
  {
LABEL_35:
    v34 = *(char **)a2;
    goto LABEL_36;
  }
LABEL_28:
  v30 = v12 + 993;
  v31 = 2 * v29;
  v32 = *(char **)a2;
  if ( v31 <= v30 )
    v33 = v30;
  else
    v33 = v31;
  *(_QWORD *)(a2 + 16) = v33;
  v34 = (char *)realloc(v32, v33);
  *(_QWORD *)a2 = v34;
  if ( !v34 )
    goto LABEL_55;
  v12 = *(_QWORD *)(a2 + 8);
LABEL_36:
  v34[v12] = 32;
  v35 = *(__int64 **)(a1 + 40);
  ++*(_QWORD *)(a2 + 8);
  result = sub_56990(v35, a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, v6 == 17408);
  if ( !v4 )
    return result;
  v37 = *(_QWORD *)(a2 + 8);
  v38 = *(_QWORD *)(a2 + 16);
  v39 = v37 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v37 + 1 <= v38 )
  {
    result = *(char **)a2;
    goto LABEL_44;
  }
  v40 = v37 + 993;
  v41 = *(char **)a2;
  if ( 2 * v38 <= v40 )
    v42 = v40;
  else
    v42 = 2 * v38;
  *(_QWORD *)(a2 + 16) = v42;
  result = (char *)realloc(v41, v42);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_55:
    std::terminate();
  v37 = *(_QWORD *)(a2 + 8);
  v39 = v37 + 1;
LABEL_44:
  *(_QWORD *)(a2 + 8) = v39;
  result[v37] = 41;
  return result;
}

//----- (0000000000056988) ----------------------------------------------------
void __fastcall sub_56988(void *a1)
{
  operator delete(a1);
}

//----- (0000000000056990) ----------------------------------------------------
_BYTE *__fastcall sub_56990(__int64 *a1, __int64 a2, int a3, char a4)
{
  _BYTE *result; // x0
  __int64 v7; // x8
  unsigned __int64 v8; // x10
  __int64 v9; // x9
  unsigned __int64 v10; // x8
  _BYTE *v11; // x0
  size_t v12; // x1
  _BYTE *v13; // x0
  __int64 v14; // x11
  __int64 v15; // x8
  unsigned __int64 v16; // x10
  __int64 v17; // x9
  unsigned __int64 v18; // x8
  _BYTE *v19; // x0
  size_t v20; // x1

  if ( (a4 & 1u) + a3 <= *(unsigned __int16 *)((char *)a1 + 9) << 26 >> 26 )
  {
    v7 = *(_QWORD *)(a2 + 8);
    v8 = *(_QWORD *)(a2 + 16);
    v9 = v7 + 1;
    ++*(_DWORD *)(a2 + 32);
    if ( v7 + 1 <= v8 )
    {
      v13 = *(_BYTE **)a2;
    }
    else
    {
      v10 = v7 + 993;
      v11 = *(_BYTE **)a2;
      if ( 2 * v8 <= v10 )
        v12 = v10;
      else
        v12 = 2 * v8;
      *(_QWORD *)(a2 + 16) = v12;
      v13 = realloc(v11, v12);
      *(_QWORD *)a2 = v13;
      if ( !v13 )
        goto LABEL_22;
      v7 = *(_QWORD *)(a2 + 8);
      v9 = v7 + 1;
    }
    v14 = *a1;
    *(_QWORD *)(a2 + 8) = v9;
    v13[v7] = 40;
    (*(void (__fastcall **)(__int64 *, __int64))(v14 + 32))(a1, a2);
    if ( (*(_WORD *)((_BYTE *)a1 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 40))(a1, a2);
    v15 = *(_QWORD *)(a2 + 8);
    v16 = *(_QWORD *)(a2 + 16);
    v17 = v15 + 1;
    --*(_DWORD *)(a2 + 32);
    if ( v15 + 1 <= v16 )
    {
      result = *(_BYTE **)a2;
      goto LABEL_20;
    }
    v18 = v15 + 993;
    v19 = *(_BYTE **)a2;
    if ( 2 * v16 <= v18 )
      v20 = v18;
    else
      v20 = 2 * v16;
    *(_QWORD *)(a2 + 16) = v20;
    result = realloc(v19, v20);
    *(_QWORD *)a2 = result;
    if ( result )
    {
      v15 = *(_QWORD *)(a2 + 8);
      v17 = v15 + 1;
LABEL_20:
      *(_QWORD *)(a2 + 8) = v17;
      result[v15] = 41;
      return result;
    }
LABEL_22:
    std::terminate();
  }
  result = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 32))(a1, a2);
  if ( (*(_WORD *)((_BYTE *)a1 + 9) & 0xC0) != 0x40 )
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 40))(a1, a2);
  return result;
}

//----- (0000000000056B08) ----------------------------------------------------
_QWORD *__fastcall sub_56B08(__int64 a1, __int128 *a2, __int64 *a3, _WORD *a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  _QWORD *v12; // x9
  char v13; // w10
  __int128 v14; // q0
  _QWORD *result; // x0
  __int64 v16; // x10

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 48;
  v12 = (_QWORD *)((char *)v4 + v11);
  v4[1] = v11;
  LOWORD(v11) = *(_WORD *)((char *)v4 + v11 - 23);
  v13 = *a4;
  v14 = *a2;
  *((_BYTE *)v12 - 24) = 62;
  LOWORD(v11) = v11 & 0xF000 | v13 & 0x3F | 0x540;
  *(v12 - 4) = off_70148;
  result = v12 - 4;
  v16 = *a3;
  *(_WORD *)((char *)v12 - 23) = v11;
  *((_OWORD *)v12 - 1) = v14;
  *v12 = v16;
  return result;
}
// 70148: using guessed type __int64 (__fastcall *off_70148[10])();

//----- (0000000000056BCC) ----------------------------------------------------
_BYTE *__fastcall sub_56BCC(__int64 a1, void **a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x22
  size_t v6; // x21
  char *v7; // x8
  size_t v8; // x9
  char *v9; // x10
  unsigned __int64 v10; // x9
  void *v11; // x0
  size_t v12; // x1
  char *v13; // x0

  v3 = *(_BYTE **)(a1 + 16);
  v2 = *(_BYTE **)(a1 + 24);
  v6 = v2 - v3;
  if ( v2 != v3 )
  {
    v7 = (char *)a2[1];
    v8 = (size_t)a2[2];
    v9 = &v7[v6];
    if ( (unsigned __int64)&v7[v6] <= v8 )
    {
      v13 = (char *)*a2;
    }
    else
    {
      v10 = 2 * v8;
      v11 = *a2;
      if ( v10 <= (unsigned __int64)(v9 + 992) )
        v12 = (size_t)(v9 + 992);
      else
        v12 = v10;
      a2[2] = (void *)v12;
      v13 = (char *)realloc(v11, v12);
      *a2 = v13;
      if ( !v13 )
        std::terminate();
      v7 = (char *)a2[1];
    }
    memcpy(&v7[(_QWORD)v13], v3, v6);
    a2[1] = (char *)a2[1] + v6;
  }
  return sub_56990(*(__int64 **)(a1 + 32), (__int64)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
}

//----- (0000000000056C7C) ----------------------------------------------------
void __fastcall sub_56C7C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000056C84) ----------------------------------------------------
void *__fastcall sub_56C84(__int64 a1, void **a2)
{
  void *result; // x0
  _BYTE *v5; // x8
  _BYTE *v6; // x21
  size_t v7; // x20
  char *v8; // x8
  size_t v9; // x9
  char *v10; // x10
  unsigned __int64 v11; // x9
  void *v12; // x0
  size_t v13; // x1
  char *v14; // x0

  result = sub_56990(*(__int64 **)(a1 + 16), (__int64)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 1);
  v6 = *(_BYTE **)(a1 + 24);
  v5 = *(_BYTE **)(a1 + 32);
  v7 = v5 - v6;
  if ( v5 != v6 )
  {
    v8 = (char *)a2[1];
    v9 = (size_t)a2[2];
    v10 = &v8[v7];
    if ( (unsigned __int64)&v8[v7] <= v9 )
    {
      v14 = (char *)*a2;
    }
    else
    {
      v11 = 2 * v9;
      v12 = *a2;
      if ( v11 <= (unsigned __int64)(v10 + 992) )
        v13 = (size_t)(v10 + 992);
      else
        v13 = v11;
      a2[2] = (void *)v13;
      v14 = (char *)realloc(v12, v13);
      *a2 = v14;
      if ( !v14 )
        std::terminate();
      v8 = (char *)a2[1];
    }
    result = memcpy(&v8[(_QWORD)v14], v6, v7);
    a2[1] = (char *)a2[1] + v7;
  }
  return result;
}

//----- (0000000000056D34) ----------------------------------------------------
void __fastcall sub_56D34(void *a1)
{
  operator delete(a1);
}

//----- (0000000000056D3C) ----------------------------------------------------
_BYTE *__fastcall sub_56D3C(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x10
  __int64 v6; // x9
  unsigned __int64 v7; // x8
  _BYTE *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 v11; // x8
  unsigned __int64 v12; // x10
  __int64 v13; // x9
  unsigned __int64 v14; // x8
  _BYTE *v15; // x0
  size_t v16; // x1
  _BYTE *result; // x0

  sub_56990(*(__int64 **)(a1 + 16), a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 1;
  ++*(_DWORD *)(a2 + 32);
  if ( v4 + 1 <= v5 )
  {
    v10 = *(_BYTE **)a2;
  }
  else
  {
    v7 = v4 + 993;
    v8 = *(_BYTE **)a2;
    if ( 2 * v5 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v5;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_16;
    v4 = *(_QWORD *)(a2 + 8);
    v6 = v4 + 1;
  }
  *(_QWORD *)(a2 + 8) = v6;
  v10[v4] = 91;
  sub_56990(*(__int64 **)(a1 + 24), a2, 19, 0);
  v11 = *(_QWORD *)(a2 + 8);
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v11 + 1 <= v12 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_15;
  }
  v14 = v11 + 993;
  v15 = *(_BYTE **)a2;
  if ( 2 * v12 <= v14 )
    v16 = v14;
  else
    v16 = 2 * v12;
  *(_QWORD *)(a2 + 16) = v16;
  result = realloc(v15, v16);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_16:
    std::terminate();
  v11 = *(_QWORD *)(a2 + 8);
  v13 = v11 + 1;
LABEL_15:
  *(_QWORD *)(a2 + 8) = v13;
  result[v11] = 93;
  return result;
}

//----- (0000000000056E48) ----------------------------------------------------
void __fastcall sub_56E48(void *a1)
{
  operator delete(a1);
}

//----- (0000000000056E50) ----------------------------------------------------
_BYTE *__fastcall sub_56E50(__int64 a1, void **a2)
{
  _BYTE *v4; // x8
  _BYTE *v5; // x22
  size_t v6; // x21
  char *v7; // x8
  size_t v8; // x9
  char *v9; // x10
  unsigned __int64 v10; // x9
  void *v11; // x0
  size_t v12; // x1
  char *v13; // x0

  sub_56990(*(__int64 **)(a1 + 16), (__int64)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 1);
  v5 = *(_BYTE **)(a1 + 24);
  v4 = *(_BYTE **)(a1 + 32);
  v6 = v4 - v5;
  if ( v4 != v5 )
  {
    v7 = (char *)a2[1];
    v8 = (size_t)a2[2];
    v9 = &v7[v6];
    if ( (unsigned __int64)&v7[v6] <= v8 )
    {
      v13 = (char *)*a2;
    }
    else
    {
      v10 = 2 * v8;
      v11 = *a2;
      if ( v10 <= (unsigned __int64)(v9 + 992) )
        v12 = (size_t)(v9 + 992);
      else
        v12 = v10;
      a2[2] = (void *)v12;
      v13 = (char *)realloc(v11, v12);
      *a2 = v13;
      if ( !v13 )
        std::terminate();
      v7 = (char *)a2[1];
    }
    memcpy(&v7[(_QWORD)v13], v5, v6);
    a2[1] = (char *)a2[1] + v6;
  }
  return sub_56990(*(__int64 **)(a1 + 40), (__int64)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
}

//----- (0000000000056F14) ----------------------------------------------------
void __fastcall sub_56F14(void *a1)
{
  operator delete(a1);
}

//----- (0000000000056F1C) ----------------------------------------------------
char *__fastcall sub_56F1C(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  unsigned __int64 v11; // x9
  __int64 *v12; // x22
  size_t v13; // x8
  unsigned __int64 v14; // x9
  char *v15; // x0
  size_t v16; // x1
  char *v17; // x0
  char *v18; // x8
  __int64 v19; // x9
  int v20; // w10
  __int64 v21; // x8
  unsigned __int64 v22; // x10
  char *v23; // x0
  size_t v24; // x1
  char *v25; // x0
  unsigned __int64 v26; // x10
  unsigned __int64 v27; // x8
  char *v28; // x0
  size_t v29; // x1
  _BYTE *v30; // x0
  __int64 v31; // x8
  __int64 v32; // x21
  char *v33; // x0
  __int64 v34; // x23
  char v35; // w24
  __int64 v36; // x26
  unsigned __int64 v37; // x8
  unsigned __int64 v38; // x8
  char *v39; // x0
  size_t v40; // x1
  char *v41; // x0
  __int64 v42; // x8
  unsigned __int64 v43; // x9
  __int64 v44; // x8
  unsigned __int64 v45; // x9
  char *v46; // x0
  size_t v47; // x1
  char *v48; // x0
  unsigned __int64 v49; // x9
  size_t v50; // x8
  unsigned __int64 v51; // x9
  char *v52; // x0
  size_t v53; // x1
  char *v54; // x0
  __int64 *v55; // x21
  __int64 v56; // x9
  char *result; // x0
  __int64 v58; // x8
  unsigned __int64 v59; // x10
  unsigned __int64 v60; // x8
  char *v61; // x0
  size_t v62; // x1
  _BYTE *v63; // x0
  __int64 v64; // x8
  __int64 v65; // x21
  char *v66; // x0
  __int64 v67; // x23
  char v68; // w24
  __int64 v69; // x26
  unsigned __int64 v70; // x8
  unsigned __int64 v71; // x8
  char *v72; // x0
  size_t v73; // x1
  char *v74; // x0
  __int64 v75; // x8
  unsigned __int64 v76; // x9
  __int64 v77; // x8
  unsigned __int64 v78; // x9
  char *v79; // x0
  size_t v80; // x1

  v4 = *(_QWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 56) )
  {
    v5 = *(_QWORD *)(a2 + 16);
    if ( v4 + 2 <= v5 )
    {
      v10 = *(char **)a2;
    }
    else
    {
      v6 = v4 + 994;
      v7 = 2 * v5;
      v8 = *(char **)a2;
      if ( v7 <= v6 )
        v9 = v6;
      else
        v9 = v7;
      *(_QWORD *)(a2 + 16) = v9;
      v10 = (char *)realloc(v8, v9);
      *(_QWORD *)a2 = v10;
      if ( !v10 )
        goto LABEL_96;
      v4 = *(_QWORD *)(a2 + 8);
    }
    *(_WORD *)&v10[v4] = 14906;
    v4 = *(_QWORD *)(a2 + 8) + 2LL;
    *(_QWORD *)(a2 + 8) = v4;
  }
  v11 = *(_QWORD *)(a2 + 16);
  v12 = (__int64 *)(a2 + 8);
  if ( v4 + 3 <= v11 )
  {
    v17 = *(char **)a2;
  }
  else
  {
    v13 = v4 + 995;
    v14 = 2 * v11;
    v15 = *(char **)a2;
    if ( v14 <= v13 )
      v16 = v13;
    else
      v16 = v14;
    *(_QWORD *)(a2 + 16) = v16;
    v17 = (char *)realloc(v15, v16);
    *(_QWORD *)a2 = v17;
    if ( !v17 )
      goto LABEL_96;
    v4 = *v12;
  }
  v18 = &v17[v4];
  v18[2] = 119;
  *(_WORD *)v18 = 25966;
  v19 = *v12;
  v20 = *(unsigned __int8 *)(a1 + 57);
  v21 = *v12 + 3;
  *v12 = v21;
  if ( v20 )
  {
    v22 = *(_QWORD *)(a2 + 16);
    if ( v19 + 5 <= v22 )
    {
      v25 = *(char **)a2;
    }
    else
    {
      v23 = *(char **)a2;
      if ( 2 * v22 <= v19 + 997 )
        v24 = v19 + 997;
      else
        v24 = 2 * v22;
      *(_QWORD *)(a2 + 16) = v24;
      v25 = (char *)realloc(v23, v24);
      *(_QWORD *)a2 = v25;
      if ( !v25 )
        goto LABEL_96;
      v21 = *v12;
    }
    *(_WORD *)&v25[v21] = 23899;
    v21 = *v12 + 2;
    *v12 = v21;
  }
  if ( *(_QWORD *)(a1 + 24) )
  {
    v26 = *(_QWORD *)(a2 + 16);
    ++*(_DWORD *)(a2 + 32);
    if ( v21 + 1 <= v26 )
    {
      v33 = *(char **)a2;
      *v12 = v21 + 1;
      v33[v21] = 40;
      v32 = *v12;
      if ( !*(_QWORD *)(a1 + 24) )
      {
LABEL_48:
        v43 = *(_QWORD *)(a2 + 16);
        v44 = v32 + 1;
        --*(_DWORD *)(a2 + 32);
        if ( v32 + 1 <= v43 )
        {
          v48 = *(char **)a2;
        }
        else
        {
          v45 = 2 * v43;
          v46 = *(char **)a2;
          if ( v45 <= v32 + 993 )
            v47 = v32 + 993;
          else
            v47 = v45;
          *(_QWORD *)(a2 + 16) = v47;
          v48 = (char *)realloc(v46, v47);
          *(_QWORD *)a2 = v48;
          if ( !v48 )
            goto LABEL_96;
          v32 = *v12;
          v44 = *v12 + 1;
        }
        *v12 = v44;
        v48[v32] = 41;
        v21 = *v12;
        goto LABEL_56;
      }
    }
    else
    {
      v27 = v21 + 993;
      v28 = *(char **)a2;
      if ( 2 * v26 <= v27 )
        v29 = v27;
      else
        v29 = 2 * v26;
      *(_QWORD *)(a2 + 16) = v29;
      v30 = realloc(v28, v29);
      *(_QWORD *)a2 = v30;
      if ( !v30 )
        goto LABEL_96;
      v31 = (*v12)++;
      v30[v31] = 40;
      v32 = *v12;
      if ( !*(_QWORD *)(a1 + 24) )
        goto LABEL_48;
    }
    v34 = 0;
    v35 = 1;
    while ( 1 )
    {
      v36 = v32;
      if ( (v35 & 1) == 0 )
      {
        v37 = *(_QWORD *)(a2 + 16);
        if ( v32 + 2 <= v37 )
        {
          v41 = *(char **)a2;
          v42 = v32;
        }
        else
        {
          v38 = 2 * v37;
          v39 = *(char **)a2;
          if ( v38 <= v32 + 994 )
            v40 = v32 + 994;
          else
            v40 = v38;
          *(_QWORD *)(a2 + 16) = v40;
          v41 = (char *)realloc(v39, v40);
          *(_QWORD *)a2 = v41;
          if ( !v41 )
            goto LABEL_96;
          v42 = *v12;
        }
        *(_WORD *)&v41[v42] = 8236;
        v36 = *v12 + 2;
        *v12 = v36;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 16) + 8 * v34), a2, 18, 0);
      if ( v36 == *(_QWORD *)(a2 + 8) )
      {
        *v12 = v32;
        if ( ++v34 == *(_QWORD *)(a1 + 24) )
          goto LABEL_48;
      }
      else
      {
        v35 = 0;
        v32 = *(_QWORD *)(a2 + 8);
        if ( ++v34 == *(_QWORD *)(a1 + 24) )
          goto LABEL_48;
      }
    }
  }
LABEL_56:
  v49 = *(_QWORD *)(a2 + 16);
  if ( v21 + 1 <= v49 )
  {
    v54 = *(char **)a2;
  }
  else
  {
    v50 = v21 + 993;
    v51 = 2 * v49;
    v52 = *(char **)a2;
    if ( v51 <= v50 )
      v53 = v50;
    else
      v53 = v51;
    *(_QWORD *)(a2 + 16) = v53;
    v54 = (char *)realloc(v52, v53);
    *(_QWORD *)a2 = v54;
    if ( !v54 )
      goto LABEL_96;
    v21 = *v12;
  }
  v54[v21] = 32;
  v55 = *(__int64 **)(a1 + 32);
  v56 = *v55;
  ++*(_QWORD *)(a2 + 8);
  result = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64))(v56 + 32))(v55, a2);
  if ( (*(_WORD *)((_BYTE *)v55 + 9) & 0xC0) != 0x40 )
    result = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64))(*v55 + 40))(v55, a2);
  if ( *(_QWORD *)(a1 + 48) )
  {
    v58 = *(_QWORD *)(a2 + 8);
    v59 = *(_QWORD *)(a2 + 16);
    ++*(_DWORD *)(a2 + 32);
    if ( v58 + 1 <= v59 )
    {
      v66 = *(char **)a2;
      *v12 = v58 + 1;
      v66[v58] = 40;
      v65 = *v12;
      if ( !*(_QWORD *)(a1 + 48) )
      {
LABEL_87:
        v76 = *(_QWORD *)(a2 + 16);
        v77 = v65 + 1;
        --*(_DWORD *)(a2 + 32);
        if ( v65 + 1 <= v76 )
        {
          result = *(char **)a2;
          goto LABEL_94;
        }
        v78 = 2 * v76;
        v79 = *(char **)a2;
        if ( v78 <= v65 + 993 )
          v80 = v65 + 993;
        else
          v80 = v78;
        *(_QWORD *)(a2 + 16) = v80;
        result = (char *)realloc(v79, v80);
        *(_QWORD *)a2 = result;
        if ( result )
        {
          v65 = *v12;
          v77 = *v12 + 1;
LABEL_94:
          *v12 = v77;
          result[v65] = 41;
          return result;
        }
LABEL_96:
        std::terminate();
      }
    }
    else
    {
      v60 = v58 + 993;
      v61 = *(char **)a2;
      if ( 2 * v59 <= v60 )
        v62 = v60;
      else
        v62 = 2 * v59;
      *(_QWORD *)(a2 + 16) = v62;
      v63 = realloc(v61, v62);
      *(_QWORD *)a2 = v63;
      if ( !v63 )
        goto LABEL_96;
      v64 = (*v12)++;
      v63[v64] = 40;
      v65 = *v12;
      if ( !*(_QWORD *)(a1 + 48) )
        goto LABEL_87;
    }
    v67 = 0;
    v68 = 1;
    while ( 1 )
    {
      v69 = v65;
      if ( (v68 & 1) == 0 )
      {
        v70 = *(_QWORD *)(a2 + 16);
        if ( v65 + 2 <= v70 )
        {
          v74 = *(char **)a2;
          v75 = v65;
        }
        else
        {
          v71 = 2 * v70;
          v72 = *(char **)a2;
          if ( v71 <= v65 + 994 )
            v73 = v65 + 994;
          else
            v73 = v71;
          *(_QWORD *)(a2 + 16) = v73;
          v74 = (char *)realloc(v72, v73);
          *(_QWORD *)a2 = v74;
          if ( !v74 )
            goto LABEL_96;
          v75 = *v12;
        }
        *(_WORD *)&v74[v75] = 8236;
        v69 = *v12 + 2;
        *v12 = v69;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 40) + 8 * v67), a2, 18, 0);
      if ( v69 == *(_QWORD *)(a2 + 8) )
      {
        *v12 = v65;
        if ( ++v67 == *(_QWORD *)(a1 + 48) )
          goto LABEL_87;
      }
      else
      {
        v68 = 0;
        v65 = *(_QWORD *)(a2 + 8);
        if ( ++v67 == *(_QWORD *)(a1 + 48) )
          goto LABEL_87;
      }
    }
  }
  return result;
}

//----- (0000000000057454) ----------------------------------------------------
void __fastcall sub_57454(void *a1)
{
  operator delete(a1);
}

//----- (000000000005745C) ----------------------------------------------------
__int64 __fastcall sub_5745C(__int64 a1, char **a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  unsigned __int64 v11; // x9
  size_t v12; // x8
  unsigned __int64 v13; // x9
  char *v14; // x0
  size_t v15; // x1
  char *v16; // x0
  char *v17; // x8
  char *v18; // x9
  int v19; // w10
  __int64 v20; // x8
  unsigned __int64 v21; // x10
  char *v22; // x0
  size_t v23; // x1
  char *v24; // x0
  unsigned __int64 v25; // x10
  __int64 v26; // x9
  unsigned __int64 v27; // x8
  char *v28; // x0
  size_t v29; // x1
  char *v30; // x0
  __int64 v31; // x20
  __int64 result; // x0

  v4 = (__int64)a2[1];
  if ( *(_BYTE *)(a1 + 24) )
  {
    v5 = (unsigned __int64)a2[2];
    if ( v4 + 2 <= v5 )
    {
      v10 = *a2;
    }
    else
    {
      v6 = v4 + 994;
      v7 = 2 * v5;
      v8 = *a2;
      if ( v7 <= v6 )
        v9 = v6;
      else
        v9 = v7;
      a2[2] = (char *)v9;
      v10 = (char *)realloc(v8, v9);
      *a2 = v10;
      if ( !v10 )
        goto LABEL_35;
      v4 = (__int64)a2[1];
    }
    *(_WORD *)&v10[v4] = 14906;
    v4 = (__int64)(a2[1] + 2);
    a2[1] = (char *)v4;
  }
  v11 = (unsigned __int64)a2[2];
  if ( v4 + 6 <= v11 )
  {
    v16 = *a2;
  }
  else
  {
    v12 = v4 + 998;
    v13 = 2 * v11;
    v14 = *a2;
    if ( v13 <= v12 )
      v15 = v12;
    else
      v15 = v13;
    a2[2] = (char *)v15;
    v16 = (char *)realloc(v14, v15);
    *a2 = v16;
    if ( !v16 )
      goto LABEL_35;
    v4 = (__int64)a2[1];
  }
  v17 = &v16[v4];
  *((_WORD *)v17 + 2) = 25972;
  *(_DWORD *)v17 = 1701602660;
  v18 = a2[1];
  v19 = *(unsigned __int8 *)(a1 + 25);
  v20 = (__int64)(v18 + 6);
  a2[1] = v18 + 6;
  if ( v19 )
  {
    v21 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v18 + 8) <= v21 )
    {
      v24 = *a2;
    }
    else
    {
      v22 = *a2;
      if ( 2 * v21 <= (unsigned __int64)(v18 + 1000) )
        v23 = (size_t)(v18 + 1000);
      else
        v23 = 2 * v21;
      a2[2] = (char *)v23;
      v24 = (char *)realloc(v22, v23);
      *a2 = v24;
      if ( !v24 )
        goto LABEL_35;
      v20 = (__int64)a2[1];
    }
    *(_WORD *)&v24[v20] = 23899;
    v20 = (__int64)(a2[1] + 2);
    a2[1] = (char *)v20;
  }
  v25 = (unsigned __int64)a2[2];
  v26 = v20 + 1;
  if ( v20 + 1 > v25 )
  {
    v27 = v20 + 993;
    v28 = *a2;
    if ( 2 * v25 <= v27 )
      v29 = v27;
    else
      v29 = 2 * v25;
    a2[2] = (char *)v29;
    v30 = (char *)realloc(v28, v29);
    *a2 = v30;
    if ( v30 )
    {
      v20 = (__int64)a2[1];
      v26 = v20 + 1;
      goto LABEL_33;
    }
LABEL_35:
    std::terminate();
  }
  v30 = *a2;
LABEL_33:
  a2[1] = (char *)v26;
  v30[v20] = 32;
  v31 = *(_QWORD *)(a1 + 16);
  result = (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v31 + 32LL))(v31, a2);
  if ( (*(_WORD *)(v31 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v31 + 40LL))(v31, a2);
  return result;
}

//----- (0000000000057640) ----------------------------------------------------
void __fastcall sub_57640(void *a1)
{
  operator delete(a1);
}

//----- (0000000000057648) ----------------------------------------------------
char *__fastcall sub_57648(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x10
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x21
  char *v13; // x0
  __int64 v14; // x22
  char v15; // w23
  __int64 v16; // x25
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  char *v26; // x0
  size_t v27; // x1
  char *result; // x0

  v2 = a1[2];
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 32);
  if ( v5 + 1 > v6 )
  {
    v7 = v5 + 993;
    v8 = *(char **)a2;
    if ( 2 * v6 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v6;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_32;
    v11 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v11 + 1;
    v10[v11] = 40;
    v12 = *(_QWORD *)(a2 + 8);
    if ( !a1[4] )
      goto LABEL_24;
LABEL_11:
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = *(_QWORD *)(a2 + 16);
        if ( v12 + 2 <= v17 )
        {
          v21 = *(char **)a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *(char **)a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          *(_QWORD *)(a2 + 16) = v20;
          v21 = (char *)realloc(v19, v20);
          *(_QWORD *)a2 = v21;
          if ( !v21 )
            goto LABEL_32;
          v22 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v16;
      }
      sub_56990(*(__int64 **)(a1[3] + 8 * v14), a2, 18, 0);
      if ( v16 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v12;
        if ( ++v14 == a1[4] )
          goto LABEL_24;
      }
      else
      {
        v15 = 0;
        v12 = *(_QWORD *)(a2 + 8);
        if ( ++v14 == a1[4] )
          goto LABEL_24;
      }
    }
  }
  v13 = *(char **)a2;
  *(_QWORD *)(a2 + 8) = v5 + 1;
  v13[v5] = 40;
  v12 = *(_QWORD *)(a2 + 8);
  if ( a1[4] )
    goto LABEL_11;
LABEL_24:
  v23 = *(_QWORD *)(a2 + 16);
  v24 = v12 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v12 + 1 <= v23 )
  {
    result = *(char **)a2;
    goto LABEL_31;
  }
  v25 = 2 * v23;
  v26 = *(char **)a2;
  if ( v25 <= v12 + 993 )
    v27 = v12 + 993;
  else
    v27 = v25;
  *(_QWORD *)(a2 + 16) = v27;
  result = (char *)realloc(v26, v27);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_32:
    std::terminate();
  v12 = *(_QWORD *)(a2 + 8);
  v24 = v12 + 1;
LABEL_31:
  *(_QWORD *)(a2 + 8) = v24;
  result[v12] = 41;
  return result;
}

//----- (000000000005785C) ----------------------------------------------------
void __fastcall sub_5785C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000057864) ----------------------------------------------------
_BYTE *__fastcall sub_57864(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x10
  __int64 v6; // x9
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x8
  unsigned __int64 v13; // x10
  __int64 v14; // x9
  unsigned __int64 v15; // x8
  char *v16; // x0
  size_t v17; // x1
  char *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int64 v21; // x8
  char *v22; // x0
  size_t v23; // x1
  _BYTE *v24; // x0
  __int64 v25; // x8
  __int64 v26; // x21
  char *v27; // x0
  __int64 v28; // x22
  char v29; // w23
  __int64 v30; // x25
  unsigned __int64 v31; // x8
  unsigned __int64 v32; // x8
  char *v33; // x0
  size_t v34; // x1
  char *v35; // x0
  __int64 v36; // x8
  unsigned __int64 v37; // x9
  __int64 v38; // x8
  unsigned __int64 v39; // x9
  char *v40; // x0
  size_t v41; // x1
  _BYTE *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v6 = v2 + 1;
  ++*(_DWORD *)(a2 + 32);
  if ( v2 + 1 <= v3 )
  {
    v10 = *(char **)a2;
  }
  else
  {
    v7 = v2 + 993;
    v8 = *(char **)a2;
    if ( 2 * v3 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v3;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = (char *)realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_46;
    v2 = *(_QWORD *)(a2 + 8);
    v6 = v2 + 1;
  }
  *(_QWORD *)(a2 + 8) = v6;
  v10[v2] = 40;
  v11 = a1[2];
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 32LL))(v11, a2);
  if ( (*(_WORD *)(v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 40LL))(v11, a2);
  v12 = *(_QWORD *)(a2 + 8);
  v13 = *(_QWORD *)(a2 + 16);
  v14 = v12 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v12 + 1 <= v13 )
  {
    v18 = *(char **)a2;
  }
  else
  {
    v15 = v12 + 993;
    v16 = *(char **)a2;
    if ( 2 * v13 <= v15 )
      v17 = v15;
    else
      v17 = 2 * v13;
    *(_QWORD *)(a2 + 16) = v17;
    v18 = (char *)realloc(v16, v17);
    *(_QWORD *)a2 = v18;
    if ( !v18 )
      goto LABEL_46;
    v12 = *(_QWORD *)(a2 + 8);
    v14 = v12 + 1;
  }
  *(_QWORD *)(a2 + 8) = v14;
  v18[v12] = 41;
  v19 = *(_QWORD *)(a2 + 8);
  v20 = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 32);
  if ( v19 + 1 <= v20 )
  {
    v27 = *(char **)a2;
    *(_QWORD *)(a2 + 8) = v19 + 1;
    v27[v19] = 40;
    v26 = *(_QWORD *)(a2 + 8);
    if ( !a1[4] )
      goto LABEL_38;
LABEL_25:
    v28 = 0;
    v29 = 1;
    while ( 1 )
    {
      v30 = v26;
      if ( (v29 & 1) == 0 )
      {
        v31 = *(_QWORD *)(a2 + 16);
        if ( v26 + 2 <= v31 )
        {
          v35 = *(char **)a2;
          v36 = v26;
        }
        else
        {
          v32 = 2 * v31;
          v33 = *(char **)a2;
          if ( v32 <= v26 + 994 )
            v34 = v26 + 994;
          else
            v34 = v32;
          *(_QWORD *)(a2 + 16) = v34;
          v35 = (char *)realloc(v33, v34);
          *(_QWORD *)a2 = v35;
          if ( !v35 )
            goto LABEL_46;
          v36 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v35[v36] = 8236;
        v30 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v30;
      }
      sub_56990(*(__int64 **)(a1[3] + 8 * v28), a2, 18, 0);
      if ( v30 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v26;
        if ( ++v28 == a1[4] )
          goto LABEL_38;
      }
      else
      {
        v29 = 0;
        v26 = *(_QWORD *)(a2 + 8);
        if ( ++v28 == a1[4] )
          goto LABEL_38;
      }
    }
  }
  v21 = v19 + 993;
  v22 = *(char **)a2;
  if ( 2 * v20 <= v21 )
    v23 = v21;
  else
    v23 = 2 * v20;
  *(_QWORD *)(a2 + 16) = v23;
  v24 = realloc(v22, v23);
  *(_QWORD *)a2 = v24;
  if ( !v24 )
    goto LABEL_46;
  v25 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v25 + 1;
  v24[v25] = 40;
  v26 = *(_QWORD *)(a2 + 8);
  if ( a1[4] )
    goto LABEL_25;
LABEL_38:
  v37 = *(_QWORD *)(a2 + 16);
  v38 = v26 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v26 + 1 <= v37 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_45;
  }
  v39 = 2 * v37;
  v40 = *(char **)a2;
  if ( v39 <= v26 + 993 )
    v41 = v26 + 993;
  else
    v41 = v39;
  *(_QWORD *)(a2 + 16) = v41;
  result = realloc(v40, v41);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_46:
    std::terminate();
  v26 = *(_QWORD *)(a2 + 8);
  v38 = v26 + 1;
LABEL_45:
  *(_QWORD *)(a2 + 8) = v38;
  result[v26] = 41;
  return result;
}

//----- (0000000000057B34) ----------------------------------------------------
void __fastcall sub_57B34(void *a1)
{
  operator delete(a1);
}

//----- (0000000000057B3C) ----------------------------------------------------
_BYTE *__fastcall sub_57B3C(__int64 a1, void **a2)
{
  char *v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 *v12; // x0
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  void *v17; // x0
  size_t v18; // x1
  char *v19; // x0
  char *v20; // x8
  __int64 *v21; // x0

  sub_56990(*(__int64 **)(a1 + 16), (__int64)a2, *(unsigned __int16 *)(a1 + 9) << 26 >> 26, 0);
  v4 = (char *)a2[1];
  v5 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v4 + 3) <= v5 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v4 + 995);
    v7 = 2 * v5;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_16;
    v4 = (char *)a2[1];
  }
  v11 = &v4[(_QWORD)v10];
  v11[2] = 32;
  *(_WORD *)v11 = 16160;
  v12 = *(__int64 **)(a1 + 24);
  a2[1] = (char *)a2[1] + 3;
  sub_56990(v12, (__int64)a2, 19, 0);
  v13 = (char *)a2[1];
  v14 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v13 + 3) <= v14 )
  {
    v19 = (char *)*a2;
    goto LABEL_15;
  }
  v15 = (size_t)(v13 + 995);
  v16 = 2 * v14;
  v17 = *a2;
  if ( v16 <= v15 )
    v18 = v15;
  else
    v18 = v16;
  a2[2] = (void *)v18;
  v19 = (char *)realloc(v17, v18);
  *a2 = v19;
  if ( !v19 )
LABEL_16:
    std::terminate();
  v13 = (char *)a2[1];
LABEL_15:
  v20 = &v13[(_QWORD)v19];
  v20[2] = 32;
  *(_WORD *)v20 = 14880;
  v21 = *(__int64 **)(a1 + 32);
  a2[1] = (char *)a2[1] + 3;
  return sub_56990(v21, (__int64)a2, 17, 1);
}

//----- (0000000000057C60) ----------------------------------------------------
void __fastcall sub_57C60(void *a1)
{
  operator delete(a1);
}

//----- (0000000000057C68) ----------------------------------------------------
char *__fastcall sub_57C68(__int64 a1, __int64 a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x22
  bool v6; // zf
  size_t v7; // x21
  size_t v8; // x8
  size_t v9; // x9
  size_t v10; // x10
  unsigned __int64 v11; // x9
  char *v12; // x0
  size_t v13; // x1
  char *v14; // x0
  unsigned __int64 v15; // x9
  int v16; // w21
  size_t v17; // x8
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 *v22; // x0
  __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  size_t v26; // x8
  unsigned __int64 v27; // x9
  char *v28; // x0
  size_t v29; // x1
  char *v30; // x0
  __int64 v31; // x10
  unsigned __int64 v32; // x11
  __int64 v33; // x8
  __int64 v34; // x9
  char *v35; // x0
  size_t v36; // x1
  char *v37; // x0
  __int64 v38; // x8
  unsigned __int64 v39; // x10
  __int64 v40; // x9
  unsigned __int64 v41; // x8
  char *v42; // x0
  size_t v43; // x1
  char *result; // x0

  v3 = *(_BYTE **)(a1 + 16);
  v2 = *(_BYTE **)(a1 + 24);
  v7 = v2 - v3;
  v6 = v2 == v3;
  v8 = *(_QWORD *)(a2 + 8);
  if ( !v6 )
  {
    v9 = *(_QWORD *)(a2 + 16);
    v10 = v8 + v7;
    if ( v8 + v7 <= v9 )
    {
      v14 = *(char **)a2;
    }
    else
    {
      v11 = 2 * v9;
      v12 = *(char **)a2;
      if ( v11 <= v10 + 992 )
        v13 = v10 + 992;
      else
        v13 = v11;
      *(_QWORD *)(a2 + 16) = v13;
      v14 = (char *)realloc(v12, v13);
      *(_QWORD *)a2 = v14;
      if ( !v14 )
        goto LABEL_39;
      v8 = *(_QWORD *)(a2 + 8);
    }
    memcpy(&v14[v8], v3, v7);
    v8 = *(_QWORD *)(a2 + 8) + v7;
    *(_QWORD *)(a2 + 8) = v8;
  }
  v15 = *(_QWORD *)(a2 + 16);
  v16 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  if ( v8 + 1 <= v15 )
  {
    v21 = *(char **)a2;
  }
  else
  {
    v17 = v8 + 993;
    v18 = 2 * v15;
    v19 = *(char **)a2;
    if ( v18 <= v17 )
      v20 = v17;
    else
      v20 = v18;
    *(_QWORD *)(a2 + 16) = v20;
    v21 = (char *)realloc(v19, v20);
    *(_QWORD *)a2 = v21;
    if ( !v21 )
      goto LABEL_39;
    v8 = *(_QWORD *)(a2 + 8);
  }
  v21[v8] = 60;
  v22 = *(__int64 **)(a1 + 32);
  v23 = *v22;
  ++*(_QWORD *)(a2 + 8);
  (*(void (__fastcall **)(__int64 *, __int64))(v23 + 32))(v22, a2);
  v24 = *(_QWORD *)(a2 + 8);
  v25 = *(_QWORD *)(a2 + 16);
  if ( v24 + 1 <= v25 )
  {
    v30 = *(char **)a2;
  }
  else
  {
    v26 = v24 + 993;
    v27 = 2 * v25;
    v28 = *(char **)a2;
    if ( v27 <= v26 )
      v29 = v26;
    else
      v29 = v27;
    *(_QWORD *)(a2 + 16) = v29;
    v30 = (char *)realloc(v28, v29);
    *(_QWORD *)a2 = v30;
    if ( !v30 )
      goto LABEL_39;
    v24 = *(_QWORD *)(a2 + 8);
  }
  v30[v24] = 62;
  v31 = *(_QWORD *)(a2 + 8);
  v32 = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 32) = v16 + 1;
  v33 = v31 + 1;
  v34 = v31 + 2;
  *(_QWORD *)(a2 + 8) = v31 + 1;
  if ( v31 + 2 <= v32 )
  {
    v37 = *(char **)a2;
  }
  else
  {
    v35 = *(char **)a2;
    if ( 2 * v32 <= v31 + 994 )
      v36 = v31 + 994;
    else
      v36 = 2 * v32;
    *(_QWORD *)(a2 + 16) = v36;
    v37 = (char *)realloc(v35, v36);
    *(_QWORD *)a2 = v37;
    if ( !v37 )
      goto LABEL_39;
    v33 = *(_QWORD *)(a2 + 8);
    v34 = v33 + 1;
  }
  *(_QWORD *)(a2 + 8) = v34;
  v37[v33] = 40;
  sub_56990(*(__int64 **)(a1 + 40), a2, 19, 0);
  v38 = *(_QWORD *)(a2 + 8);
  v39 = *(_QWORD *)(a2 + 16);
  v40 = v38 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v38 + 1 <= v39 )
  {
    result = *(char **)a2;
    goto LABEL_38;
  }
  v41 = v38 + 993;
  v42 = *(char **)a2;
  if ( 2 * v39 <= v41 )
    v43 = v41;
  else
    v43 = 2 * v39;
  *(_QWORD *)(a2 + 16) = v43;
  result = (char *)realloc(v42, v43);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_39:
    std::terminate();
  v38 = *(_QWORD *)(a2 + 8);
  v40 = v38 + 1;
LABEL_38:
  *(_QWORD *)(a2 + 8) = v40;
  result[v38] = 41;
  return result;
}

//----- (0000000000057E98) ----------------------------------------------------
void __fastcall sub_57E98(void *a1)
{
  operator delete(a1);
}

//----- (0000000000057EA0) ----------------------------------------------------
char *__fastcall sub_57EA0(_QWORD *a1, char **a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x22
  bool v6; // zf
  size_t v7; // x21
  size_t v8; // x8
  size_t v9; // x9
  size_t v10; // x10
  unsigned __int64 v11; // x9
  char *v12; // x0
  size_t v13; // x1
  char *v14; // x0
  unsigned __int64 v15; // x10
  size_t v16; // x9
  unsigned __int64 v17; // x8
  char *v18; // x0
  size_t v19; // x1
  char *v20; // x0
  __int64 v21; // x21
  char *v22; // x8
  unsigned __int64 v23; // x10
  unsigned __int64 v24; // x8
  char *v25; // x0
  size_t v26; // x1
  char *result; // x0
  char *v28; // x8
  _BYTE *v29; // x8
  _BYTE *v30; // x21
  size_t v31; // x20
  _BYTE *v32; // x8
  char *v33; // x8
  size_t v34; // x9
  char *v35; // x10
  unsigned __int64 v36; // x9
  char *v37; // x0
  size_t v38; // x1
  char *v39; // x0

  v3 = (_BYTE *)a1[2];
  v2 = (_BYTE *)a1[3];
  v7 = v2 - v3;
  v6 = v2 == v3;
  v8 = (size_t)a2[1];
  if ( !v6 )
  {
    v9 = (size_t)a2[2];
    v10 = v8 + v7;
    if ( v8 + v7 <= v9 )
    {
      v14 = *a2;
    }
    else
    {
      v11 = 2 * v9;
      v12 = *a2;
      if ( v11 <= v10 + 992 )
        v13 = v10 + 992;
      else
        v13 = v11;
      a2[2] = (char *)v13;
      v14 = (char *)realloc(v12, v13);
      *a2 = v14;
      if ( !v14 )
        goto LABEL_35;
      v8 = (size_t)a2[1];
    }
    memcpy(&v14[v8], v3, v7);
    v8 = (size_t)&a2[1][v7];
    a2[1] = (char *)v8;
  }
  v15 = (unsigned __int64)a2[2];
  v16 = v8 + 1;
  ++*((_DWORD *)a2 + 8);
  if ( v8 + 1 <= v15 )
  {
    v20 = *a2;
  }
  else
  {
    v17 = v8 + 993;
    v18 = *a2;
    if ( 2 * v15 <= v17 )
      v19 = v17;
    else
      v19 = 2 * v15;
    a2[2] = (char *)v19;
    v20 = (char *)realloc(v18, v19);
    *a2 = v20;
    if ( !v20 )
      goto LABEL_35;
    v8 = (size_t)a2[1];
    v16 = v8 + 1;
  }
  a2[1] = (char *)v16;
  v20[v8] = 40;
  v21 = a1[4];
  (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v21 + 32LL))(v21, a2);
  if ( (*(_WORD *)(v21 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v21 + 40LL))(v21, a2);
  v22 = a2[1];
  v23 = (unsigned __int64)a2[2];
  --*((_DWORD *)a2 + 8);
  if ( (unsigned __int64)(v22 + 1) > v23 )
  {
    v24 = (unsigned __int64)(v22 + 993);
    v25 = *a2;
    if ( 2 * v23 <= v24 )
      v26 = v24;
    else
      v26 = 2 * v23;
    a2[2] = (char *)v26;
    result = (char *)realloc(v25, v26);
    *a2 = result;
    if ( !result )
      goto LABEL_35;
    v28 = a2[1];
    a2[1] = v28 + 1;
    v28[(_QWORD)result] = 41;
    v30 = (_BYTE *)a1[5];
    v29 = (_BYTE *)a1[6];
    v31 = v29 - v30;
    if ( v29 == v30 )
      return result;
    goto LABEL_27;
  }
  result = *a2;
  a2[1] = v22 + 1;
  v22[(_QWORD)result] = 41;
  v30 = (_BYTE *)a1[5];
  v32 = (_BYTE *)a1[6];
  v31 = v32 - v30;
  if ( v32 != v30 )
  {
LABEL_27:
    v33 = a2[1];
    v34 = (size_t)a2[2];
    v35 = &v33[v31];
    if ( (unsigned __int64)&v33[v31] <= v34 )
    {
      v39 = *a2;
      goto LABEL_34;
    }
    v36 = 2 * v34;
    v37 = *a2;
    if ( v36 <= (unsigned __int64)(v35 + 992) )
      v38 = (size_t)(v35 + 992);
    else
      v38 = v36;
    a2[2] = (char *)v38;
    v39 = (char *)realloc(v37, v38);
    *a2 = v39;
    if ( v39 )
    {
      v33 = a2[1];
LABEL_34:
      result = (char *)memcpy(&v33[(_QWORD)v39], v30, v31);
      a2[1] += v31;
      return result;
    }
LABEL_35:
    std::terminate();
  }
  return result;
}

//----- (00000000000580C4) ----------------------------------------------------
void __fastcall sub_580C4(void *a1)
{
  operator delete(a1);
}

//----- (00000000000580CC) ----------------------------------------------------
_QWORD *__fastcall sub_580CC(__int64 a1, __int64 a2, __int64 a3)
{
  _BYTE *v3; // x9
  _BYTE *v4; // x22
  _BYTE *v8; // x8
  _QWORD *result; // x0
  _BYTE *v10; // x23
  _QWORD *v11; // x24
  __int64 v12; // x9
  _QWORD *v13; // x0
  __int64 v14; // x8
  _QWORD *v15; // x9

  v4 = *(_BYTE **)a1;
  v3 = *(_BYTE **)(a1 + 8);
  v8 = *(_BYTE **)a1;
  if ( *(_BYTE **)a1 != v3 )
  {
    v8 = *(_BYTE **)a1;
    if ( *v4 == 110 )
    {
      v8 = v4 + 1;
      *(_QWORD *)a1 = v4 + 1;
    }
  }
  if ( v3 == v8 )
    return 0;
  if ( (unsigned int)(unsigned __int8)*v8 - 58 < 0xFFFFFFF6 )
    return 0;
  while ( (unsigned int)(unsigned __int8)*v8 - 58 >= 0xFFFFFFF6 )
  {
    *(_QWORD *)a1 = ++v8;
    if ( v8 == v3 )
    {
      v8 = v3;
      break;
    }
  }
  v10 = v8;
  result = 0;
  if ( v8 != v4 && v8 != v3 )
  {
    if ( *v8 == 69 )
    {
      v11 = *(_QWORD **)(a1 + 4912);
      v12 = v11[1];
      *(_QWORD *)a1 = v8 + 1;
      if ( (unsigned __int64)(v12 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v13 = malloc(0x1000u);
        if ( !v13 )
          std::terminate();
        v12 = 0;
        *v13 = v11;
        v13[1] = 0;
        v11 = v13;
        *(_QWORD *)(a1 + 4912) = v13;
      }
      v14 = v12 + 48;
      v15 = (_QWORD *)((char *)v11 + v12 + 48);
      v11[1] = v14;
      LOWORD(v14) = *(_WORD *)((char *)v15 - 23);
      *((_BYTE *)v15 - 24) = 73;
      *(v15 - 2) = a2;
      *(v15 - 1) = a3;
      *v15 = v4;
      v15[1] = v10;
      *(_WORD *)((char *)v15 - 23) = v14 & 0xF000 | 0x540;
      *(v15 - 4) = off_70618;
      return v15 - 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 70618: using guessed type __int64 (__fastcall *off_70618[10])();

//----- (0000000000058270) ----------------------------------------------------
char *__fastcall sub_58270(__int64 a1, int a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  char *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4064) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 16;
  result = (char *)v2 + v7;
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 + 9);
  result[8] = 69;
  *(_QWORD *)result = off_70688;
  *(_WORD *)(result + 9) = v7 & 0xF000 | 0x540;
  result[11] = a2 != 0;
  return result;
}
// 70688: using guessed type __int64 (__fastcall *off_70688[10])();

//----- (0000000000058314) ----------------------------------------------------
_QWORD *__fastcall sub_58314(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 70;
  *(v8 - 2) = off_70848;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 70848: using guessed type __int64 (__fastcall *off_70848[10])();

//----- (0000000000058468) ----------------------------------------------------
const char **__fastcall sub_58468(__int64 a1, __int64 a2)
{
  const char *v3; // x20
  const char *v4; // x21
  const char **v5; // x20
  const char *v7; // x8
  _QWORD *v8; // x20
  __int64 v9; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  const char **v12; // x20
  __int64 (__fastcall **v13)(); // x8
  unsigned __int8 *v14; // x8
  const char *v15; // x23
  unsigned __int8 *v16; // x22
  _BYTE *v17; // x21
  char *v18; // x8
  __int64 v19; // x27
  signed __int64 v20; // x20
  char *v21; // x9
  __int64 v22; // x24
  char *v23; // x22
  _QWORD *v24; // x20
  __int64 v25; // x8
  _QWORD *v26; // x0
  __int64 v27; // x8
  char *v28; // x0
  const char *v29; // x8
  __int64 v30; // x25
  __int64 v31; // x26
  unsigned __int64 i; // x9
  char *v33; // x24
  char *v34; // x8
  int v35; // w1
  _BYTE *v36; // x0
  __int64 *v37; // x22
  _BYTE *v38; // x0
  signed __int64 v39; // x23
  char *v40; // x0
  unsigned __int64 v41; // x22
  char *v42; // x21
  const char *v43; // x1
  const char *v44; // x20
  const char *v45; // x23
  __int64 v46; // x8
  __int64 v47; // x0
  __int64 v48; // x24
  __int64 *v49; // x8
  const char *v50; // x8
  _BYTE *v51; // x0
  signed __int64 v52; // x25
  char *v53; // x26
  char *v54; // x0
  const char *v55; // x8
  char *v56; // x0
  const char *v57; // x8
  const char *v58; // x9
  char *v59; // x22
  const char *v60; // x1
  const char *v61; // x23
  const char *v62; // x25
  const char *v63; // x24
  _QWORD *v64; // x26
  __int64 v65; // x8
  _QWORD *v66; // x0
  __int64 v67; // x8
  const char **v68; // x9
  __int64 v69; // x10
  _QWORD *v70; // x20
  __int64 v71; // x1
  __int64 v72; // x2
  __int64 v73; // x3
  __int64 v74; // x4
  __int64 v75; // x5
  __int64 v76; // x6
  __int64 v77; // x7
  __int64 v78; // x8
  double v79; // d0
  double v80; // d1
  double v81; // d2
  double v82; // d3
  double v83; // d4
  double v84; // d5
  double v85; // d6
  double v86; // d7
  __int64 v87; // [xsp+8h] [xbp-68h] BYREF
  unsigned __int64 v88; // [xsp+10h] [xbp-60h]
  void *ptr[3]; // [xsp+18h] [xbp-58h] BYREF
  _OWORD v90[4]; // [xsp+30h] [xbp-40h] BYREF
  __int64 vars0; // [xsp+70h] [xbp+0h] BYREF

  if ( a2 )
    *(_QWORD *)(a1 + 672) = *(_QWORD *)(a1 + 664);
  v3 = *(const char **)a1;
  v4 = *(const char **)(a1 + 8);
  if ( (unsigned __int64)&v4[-*(_QWORD *)a1] < 2 )
    return 0;
  if ( !strncmp("Ut", *(const char **)a1, 2u) )
  {
    v14 = (unsigned __int8 *)(v3 + 2);
    *(_QWORD *)a1 = v3 + 2;
    if ( v4 == v3 + 2 )
      return 0;
    if ( (unsigned int)*v14 - 58 >= 0xFFFFFFF6 )
    {
      v16 = (unsigned __int8 *)(v3 + 2);
      do
      {
        if ( (unsigned int)*v16 - 58 < 0xFFFFFFF6 )
          goto LABEL_32;
        *(_QWORD *)a1 = ++v16;
      }
      while ( v16 != (unsigned __int8 *)v4 );
      v16 = (unsigned __int8 *)v4;
LABEL_32:
      v15 = v3 + 2;
      v14 = v16;
      if ( v16 == (unsigned __int8 *)v4 )
        return 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      if ( v14 == (unsigned __int8 *)v4 )
        return 0;
    }
    if ( *v14 == 95 )
    {
      v24 = *(_QWORD **)(a1 + 4912);
      *(_QWORD *)a1 = v14 + 1;
      v25 = v24[1];
      if ( (unsigned __int64)(v25 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v26 = malloc(0x1000u);
        if ( !v26 )
          goto LABEL_98;
        v25 = 0;
        *v26 = v24;
        v26[1] = 0;
        v24 = v26;
        *(_QWORD *)(a1 + 4912) = v26;
      }
      v27 = v25 + 32;
      v24[1] = v27;
      v12 = (const char **)((char *)v24 + v27);
      LOWORD(v27) = *(_WORD *)((char *)v12 - 7);
      *((_BYTE *)v12 - 8) = 47;
      *v12 = v15;
      v12[1] = (const char *)v16;
      *(_WORD *)((char *)v12 - 7) = v27 & 0xF000 | 0x540;
      v13 = off_708B8;
      goto LABEL_38;
    }
    return 0;
  }
  if ( strncmp("Ul", v3, 2u) )
  {
    if ( strncmp("Ub", v3, 2u) )
      return 0;
    v7 = v3 + 2;
    *(_QWORD *)a1 = v3 + 2;
    if ( v4 == v3 + 2 )
      return 0;
    if ( (unsigned int)*(unsigned __int8 *)v7 - 58 >= 0xFFFFFFF6 )
    {
      while ( (unsigned int)*(unsigned __int8 *)v7 - 58 >= 0xFFFFFFF6 )
      {
        ++v7;
        v5 = 0;
        *(_QWORD *)a1 = v7;
        if ( v7 == v4 )
          return v5;
      }
    }
    if ( v7 == v4 || *v7 != 95 )
      return 0;
    v8 = *(_QWORD **)(a1 + 4912);
    *(_QWORD *)a1 = v7 + 1;
    v9 = v8[1];
    if ( (unsigned __int64)(v9 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v10 = malloc(0x1000u);
      if ( !v10 )
        goto LABEL_98;
      v9 = 0;
      *v10 = v8;
      v10[1] = 0;
      v8 = v10;
      *(_QWORD *)(a1 + 4912) = v10;
    }
    v11 = v9 + 32;
    v8[1] = v11;
    v12 = (const char **)((char *)v8 + v11);
    LOWORD(v11) = *(_WORD *)((char *)v12 - 7);
    *((_BYTE *)v12 - 8) = 7;
    *(_WORD *)((char *)v12 - 7) = v11 & 0xF000 | 0x540;
    v13 = off_6FBA8;
    *v12 = "'block-literal'";
    v12[1] = "";
LABEL_38:
    *(v12 - 2) = (const char *)v13;
    return v12 - 2;
  }
  v17 = *(_BYTE **)(a1 + 664);
  v18 = *(char **)(a1 + 672);
  *(_QWORD *)a1 = v3 + 2;
  v19 = *(_QWORD *)(a1 + 784);
  v20 = v18 - v17;
  ptr[0] = v90;
  ptr[1] = v90;
  ptr[2] = &vars0;
  v21 = *(char **)(a1 + 680);
  v22 = (v18 - v17) >> 3;
  memset(v90, 0, sizeof(v90));
  *(_QWORD *)(a1 + 784) = v22;
  v87 = a1;
  v88 = v22;
  if ( v18 == v21 )
  {
    if ( v17 == (_BYTE *)(a1 + 688) )
    {
      v28 = (char *)malloc(2 * v20);
      if ( !v28 )
        goto LABEL_98;
      v23 = v28;
      memmove(v28, v17, v20);
      *(_QWORD *)(a1 + 664) = v23;
    }
    else
    {
      v23 = (char *)realloc(v17, 2 * v20);
      *(_QWORD *)(a1 + 664) = v23;
      if ( !v23 )
        goto LABEL_98;
    }
    v18 = &v23[8 * v22];
    *(_QWORD *)(a1 + 680) = &v23[8 * (v20 >> 2)];
  }
  *(_QWORD *)(a1 + 672) = v18 + 8;
  *(_QWORD *)v18 = ptr;
  v29 = *(const char **)a1;
  v30 = *(_QWORD *)(a1 + 16);
  v31 = *(_QWORD *)(a1 + 24);
  for ( i = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1; i; i = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 )
  {
    if ( *v29 != 84 )
      break;
    v35 = i < 2 ? 0 : *((unsigned __int8 *)v29 + 1);
    v36 = memchr("yptn", v35, 4u);
    if ( !v36 || v36 - "yptn" == -1 )
      break;
    v37 = sub_599EC((const char **)a1);
    if ( !v37 )
      goto LABEL_93;
    v34 = *(char **)(a1 + 24);
    if ( v34 == *(char **)(a1 + 32) )
    {
      v38 = *(_BYTE **)(a1 + 16);
      v39 = v34 - v38;
      if ( v38 == (_BYTE *)(a1 + 40) )
      {
        v40 = (char *)malloc(2 * (v34 - v38));
        if ( !v40 )
          goto LABEL_98;
        v33 = v40;
        memcpy(v40, (const void *)(a1 + 40), v39);
        *(_QWORD *)(a1 + 16) = v33;
      }
      else
      {
        v33 = (char *)realloc(v38, 2 * (v34 - v38));
        *(_QWORD *)(a1 + 16) = v33;
        if ( !v33 )
          goto LABEL_98;
      }
      v34 = &v33[v39];
      *(_QWORD *)(a1 + 24) = &v33[v39];
      *(_QWORD *)(a1 + 32) = &v33[8 * (v39 >> 2)];
    }
    *(_QWORD *)(a1 + 24) = v34 + 8;
    *(_QWORD *)v34 = v37;
    v29 = *(const char **)a1;
  }
  v41 = (v31 - v30) >> 3;
  v42 = sub_4F750((_QWORD *)a1, v41);
  v44 = v43;
  if ( v43 )
  {
    v45 = *(const char **)a1;
    if ( *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2u )
      goto LABEL_66;
  }
  else
  {
    v46 = *(_QWORD *)(a1 + 672);
    if ( v46 == *(_QWORD *)(a1 + 664) )
      goto LABEL_100;
    *(_QWORD *)(a1 + 672) = v46 - 8;
    v45 = *(const char **)a1;
    if ( *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2u )
      goto LABEL_66;
  }
  if ( !strncmp("vE", v45, 2u) )
  {
    v55 = v45 + 2;
    goto LABEL_79;
  }
  do
  {
    do
    {
      while ( 1 )
      {
LABEL_66:
        v47 = sub_4DAC4(a1);
        v48 = v47;
        if ( !v47 )
          goto LABEL_93;
        v49 = *(__int64 **)(a1 + 24);
        if ( v49 == *(__int64 **)(a1 + 32) )
          break;
        *(_QWORD *)(a1 + 24) = v49 + 1;
        *v49 = v47;
        v50 = *(const char **)a1;
        if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
          goto LABEL_65;
      }
      v51 = *(_BYTE **)(a1 + 16);
      v52 = (char *)v49 - v51;
      if ( v51 == (_BYTE *)(a1 + 40) )
      {
        v54 = (char *)malloc(2 * ((char *)v49 - v51));
        if ( !v54 )
          goto LABEL_98;
        v53 = v54;
        memcpy(v54, (const void *)(a1 + 40), v52);
        *(_QWORD *)(a1 + 16) = v53;
      }
      else
      {
        v53 = (char *)realloc(v51, 2 * ((char *)v49 - v51));
        *(_QWORD *)(a1 + 16) = v53;
        if ( !v53 )
          goto LABEL_98;
      }
      *(_QWORD *)(a1 + 24) = &v53[v52];
      *(_QWORD *)(a1 + 32) = &v53[8 * (v52 >> 2)];
      *(_QWORD *)(a1 + 24) = &v53[v52 + 8];
      *(_QWORD *)&v53[v52] = v48;
      v50 = *(const char **)a1;
    }
    while ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) );
LABEL_65:
    ;
  }
  while ( *v50 != 69 );
  v55 = v50 + 1;
LABEL_79:
  *(_QWORD *)a1 = v55;
  v56 = sub_4F750((_QWORD *)a1, v41);
  v57 = *(const char **)a1;
  v58 = *(const char **)(a1 + 8);
  v59 = v56;
  v61 = v60;
  if ( v58 == *(const char **)a1 || (unsigned int)*(unsigned __int8 *)v57 - 58 < 0xFFFFFFF6 )
  {
    v62 = 0;
    v63 = 0;
    if ( v57 == v58 )
      goto LABEL_93;
LABEL_88:
    if ( *v57 != 95 )
      goto LABEL_93;
    v64 = *(_QWORD **)(a1 + 4912);
    *(_QWORD *)a1 = v57 + 1;
    v65 = v64[1];
    if ( (unsigned __int64)(v65 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v66 = malloc(0x1000u);
      if ( v66 )
      {
        v65 = 0;
        *v66 = v64;
        v66[1] = 0;
        v64 = v66;
        *(_QWORD *)(a1 + 4912) = v66;
        goto LABEL_92;
      }
LABEL_98:
      std::terminate();
    }
LABEL_92:
    v67 = v65 + 64;
    v68 = (const char **)((char *)v64 + v67);
    v64[1] = v67;
    LOWORD(v67) = *(_WORD *)((char *)v64 + v67 - 39);
    *(v68 - 4) = v42;
    *(v68 - 3) = v44;
    *((_BYTE *)v68 - 40) = 48;
    *(v68 - 2) = v59;
    *(v68 - 1) = v61;
    *v68 = v62;
    v68[1] = v63;
    *(_WORD *)((char *)v68 - 39) = v67 & 0xF000 | 0x540;
    *(v68 - 6) = (const char *)off_70B58;
    v5 = v68 - 6;
  }
  else
  {
    v63 = *(const char **)a1;
    while ( (unsigned int)*(unsigned __int8 *)v63 - 58 >= 0xFFFFFFF6 )
    {
      *(_QWORD *)a1 = ++v63;
      if ( v63 == v58 )
      {
        v63 = v58;
        break;
      }
    }
    v62 = v57;
    v57 = v63;
    if ( v63 != v58 )
      goto LABEL_88;
LABEL_93:
    v5 = 0;
  }
  v69 = *(_QWORD *)(v87 + 664);
  if ( v88 > (*(_QWORD *)(v87 + 672) - v69) >> 3 )
  {
    __assert2(
      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
      2409,
      "(anonymous namespace)::itanium_demangle::AbstractManglingParser<(anonymous namespace)::itanium_demangle::ManglingP"
      "arser<(anonymous namespace)::DefaultAllocator>, (anonymous namespace)::DefaultAllocator>::ScopedTemplateParamList:"
      ":~ScopedTemplateParamList() [Derived = (anonymous namespace)::itanium_demangle::ManglingParser<(anonymous namespac"
      "e)::DefaultAllocator>, Alloc = (anonymous namespace)::DefaultAllocator]",
      "Parser->TemplateParams.size() >= OldNumTemplateParamLists");
LABEL_100:
    v70 = (_QWORD *)__assert2(
                      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
                      124,
                      "void (anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_demang"
                      "le::PODSmallVector<(anonymous namespace)::itanium_demangle::Node *, 8> *, 4>::pop_back() [T = (ano"
                      "nymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_demangle::Node *, 8> *, N = 4]",
                      "Last != First && \"Popping empty vector!\"");
    sub_59ED0(&v87);
    *(_QWORD *)(a1 + 784) = v19;
    sub_65E10(v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86);
  }
  *(_QWORD *)(v87 + 672) = v69 + 8 * v88;
  if ( ptr[0] != v90 )
    free(ptr[0]);
  *(_QWORD *)(a1 + 784) = v19;
  return v5;
}
// 588A4: variable 'v43' is possibly undefined
// 589E4: variable 'v60' is possibly undefined
// 58B7C: variable 'v71' is possibly undefined
// 58B7C: variable 'v72' is possibly undefined
// 58B7C: variable 'v73' is possibly undefined
// 58B7C: variable 'v74' is possibly undefined
// 58B7C: variable 'v75' is possibly undefined
// 58B7C: variable 'v76' is possibly undefined
// 58B7C: variable 'v77' is possibly undefined
// 58B7C: variable 'v78' is possibly undefined
// 58B7C: variable 'v79' is possibly undefined
// 58B7C: variable 'v80' is possibly undefined
// 58B7C: variable 'v81' is possibly undefined
// 58B7C: variable 'v82' is possibly undefined
// 58B7C: variable 'v83' is possibly undefined
// 58B7C: variable 'v84' is possibly undefined
// 58B7C: variable 'v85' is possibly undefined
// 58B7C: variable 'v86' is possibly undefined
// 4A7CC: using guessed type void __fastcall __noreturn sub_4A7CC(_QWORD);
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 708B8: using guessed type __int64 (__fastcall *off_708B8[10])();
// 70B58: using guessed type __int64 (__fastcall *off_70B58[10])();

//----- (0000000000058B80) ----------------------------------------------------
_QWORD *__fastcall sub_58B80(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 71;
  *(v8 - 2) = off_70BC8;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 70BC8: using guessed type __int64 (__fastcall *off_70BC8[10])();

//----- (0000000000058C24) ----------------------------------------------------
__int64 __fastcall sub_58C24(__int64 a1, __int64 *a2, __int128 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  __int64 v10; // x9
  __int128 v11; // q0
  __int64 result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 48;
  v10 = *a2;
  v3[1] = v9;
  v11 = *a3;
  *(_QWORD *)((char *)v3 + v9 - 32) = off_70C38;
  result = (__int64)v3 + v9 - 32;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 23);
  *(_BYTE *)(result + 8) = 72;
  *(_QWORD *)(result + 16) = v10;
  *(_WORD *)(result + 9) = v9 & 0xF000 | 0x540;
  *(_OWORD *)(result + 24) = v11;
  return result;
}
// 70C38: using guessed type __int64 (__fastcall *off_70C38[10])();

//----- (0000000000058CD0) ----------------------------------------------------
_QWORD *__fastcall sub_58CD0(_QWORD *result, char **a2)
{
  _QWORD *v3; // x20
  char *v4; // x8
  unsigned __int64 v5; // x10
  char *v6; // x9
  unsigned __int64 v7; // x8
  _BYTE *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  _BYTE *v11; // x8
  _BYTE *v12; // x22
  bool v13; // zf
  size_t v14; // x21
  size_t v15; // x8
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  _BYTE *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  unsigned __int64 v22; // x10
  size_t v23; // x9
  unsigned __int64 v24; // x8
  _BYTE *v25; // x0
  size_t v26; // x1
  _BYTE *v27; // x22
  __int64 v28; // x8
  unsigned __int64 v29; // x10
  __int64 *v30; // x23
  __int64 v31; // x9
  unsigned __int64 v32; // x8
  _BYTE *v33; // x0
  size_t v34; // x1
  _BYTE *v35; // x8
  size_t v36; // x21
  __int64 v37; // x8
  size_t v38; // x9
  size_t v39; // x10
  char *v40; // x0
  _BYTE *v41; // x8
  _BYTE *v42; // x9
  unsigned __int64 v43; // x9
  _BYTE *v44; // x0
  size_t v45; // x1
  _BYTE *v46; // x8
  _BYTE *v47; // x21
  size_t v48; // x20
  char *v49; // x8
  size_t v50; // x9
  char *v51; // x10
  unsigned __int64 v52; // x9
  _BYTE *v53; // x0
  size_t v54; // x1
  char *v55; // x0

  v3 = result;
  if ( result[3] - result[2] >= 4u )
  {
    v4 = a2[1];
    v5 = (unsigned __int64)a2[2];
    v6 = v4 + 1;
    ++*((_DWORD *)a2 + 8);
    if ( (unsigned __int64)(v4 + 1) <= v5 )
    {
      v10 = *a2;
    }
    else
    {
      v7 = (unsigned __int64)(v4 + 993);
      v8 = *a2;
      if ( 2 * v5 <= v7 )
        v9 = v7;
      else
        v9 = 2 * v5;
      a2[2] = (char *)v9;
      v10 = (char *)realloc(v8, v9);
      *a2 = v10;
      if ( !v10 )
        goto LABEL_59;
      v4 = a2[1];
      v6 = v4 + 1;
    }
    a2[1] = v6;
    v4[(_QWORD)v10] = 40;
    v12 = (_BYTE *)v3[2];
    v11 = (_BYTE *)v3[3];
    v14 = v11 - v12;
    v13 = v11 == v12;
    v15 = (size_t)a2[1];
    if ( !v13 )
    {
      v16 = (size_t)a2[2];
      v17 = v15 + v14;
      if ( v15 + v14 <= v16 )
      {
        v21 = *a2;
      }
      else
      {
        v18 = 2 * v16;
        v19 = *a2;
        if ( v18 <= v17 + 992 )
          v20 = v17 + 992;
        else
          v20 = v18;
        a2[2] = (char *)v20;
        v21 = (char *)realloc(v19, v20);
        *a2 = v21;
        if ( !v21 )
          goto LABEL_59;
        v15 = (size_t)a2[1];
      }
      memcpy(&v21[v15], v12, v14);
      v15 = (size_t)&a2[1][v14];
      a2[1] = (char *)v15;
    }
    v22 = (unsigned __int64)a2[2];
    v23 = v15 + 1;
    --*((_DWORD *)a2 + 8);
    if ( v15 + 1 <= v22 )
    {
      result = *a2;
    }
    else
    {
      v24 = v15 + 993;
      v25 = *a2;
      if ( 2 * v22 <= v24 )
        v26 = v24;
      else
        v26 = 2 * v22;
      a2[2] = (char *)v26;
      result = realloc(v25, v26);
      *a2 = (char *)result;
      if ( !result )
        goto LABEL_59;
      v15 = (size_t)a2[1];
      v23 = v15 + 1;
    }
    a2[1] = (char *)v23;
    *((_BYTE *)result + v15) = 41;
  }
  v27 = (_BYTE *)v3[4];
  if ( *v27 == 110 )
  {
    v28 = (__int64)a2[1];
    v29 = (unsigned __int64)a2[2];
    v30 = (__int64 *)(a2 + 1);
    v31 = v28 + 1;
    if ( v28 + 1 <= v29 )
    {
      result = *a2;
    }
    else
    {
      v32 = v28 + 993;
      v33 = *a2;
      if ( 2 * v29 <= v32 )
        v34 = v32;
      else
        v34 = 2 * v29;
      a2[2] = (char *)v34;
      result = realloc(v33, v34);
      *a2 = (char *)result;
      if ( !result )
        goto LABEL_59;
      v28 = *v30;
      v31 = *v30 + 1;
    }
    *v30 = v31;
    *((_BYTE *)result + v28) = 45;
    v41 = (_BYTE *)v3[4];
    v42 = (_BYTE *)v3[5];
    if ( v42 == v41 )
      v27 = (_BYTE *)v3[4];
    else
      v27 = v41 + 1;
    v36 = v42 - v27;
    if ( v42 != v27 )
    {
      v37 = (__int64)a2[1];
      v38 = (size_t)a2[2];
      v39 = v37 + v36;
      if ( v37 + v36 > v38 )
        goto LABEL_42;
      goto LABEL_35;
    }
  }
  else
  {
    v35 = (_BYTE *)v3[5];
    v36 = v35 - v27;
    if ( v35 != v27 )
    {
      v37 = (__int64)a2[1];
      v38 = (size_t)a2[2];
      v30 = (__int64 *)(a2 + 1);
      v39 = v37 + v36;
      if ( v37 + v36 > v38 )
      {
LABEL_42:
        v43 = 2 * v38;
        v44 = *a2;
        if ( v43 <= v39 + 992 )
          v45 = v39 + 992;
        else
          v45 = v43;
        a2[2] = (char *)v45;
        v40 = (char *)realloc(v44, v45);
        *a2 = v40;
        if ( !v40 )
          goto LABEL_59;
        v37 = *v30;
        goto LABEL_47;
      }
LABEL_35:
      v40 = *a2;
LABEL_47:
      result = memcpy(&v40[v37], v27, v36);
      *v30 += v36;
    }
  }
  v47 = (_BYTE *)v3[2];
  v46 = (_BYTE *)v3[3];
  v48 = v46 - v47;
  if ( (unsigned __int64)(v46 - v47) <= 3 && v46 != v47 )
  {
    v49 = a2[1];
    v50 = (size_t)a2[2];
    v51 = &v49[v48];
    if ( (unsigned __int64)&v49[v48] <= v50 )
    {
      v55 = *a2;
      goto LABEL_57;
    }
    v52 = 2 * v50;
    v53 = *a2;
    if ( v52 <= (unsigned __int64)(v51 + 992) )
      v54 = (size_t)(v51 + 992);
    else
      v54 = v52;
    a2[2] = (char *)v54;
    v55 = (char *)realloc(v53, v54);
    *a2 = v55;
    if ( v55 )
    {
      v49 = a2[1];
LABEL_57:
      result = memcpy(&v49[(_QWORD)v55], v47, v48);
      a2[1] += v48;
      return result;
    }
LABEL_59:
    std::terminate();
  }
  return result;
}

//----- (0000000000058FA8) ----------------------------------------------------
void __fastcall sub_58FA8(void *a1)
{
  operator delete(a1);
}

//----- (0000000000058FB0) ----------------------------------------------------
_BYTE *__fastcall sub_58FB0(_BYTE *result, void **a2)
{
  char *v2; // x9
  const char *v3; // x21
  size_t v4; // x20
  char *v5; // x8
  size_t v6; // x9
  char *v8; // x10
  unsigned __int64 v9; // x9
  void *v10; // x0
  size_t v11; // x1
  char *v12; // x0

  if ( result[11] )
    v2 = "";
  else
    v2 = "";
  if ( result[11] )
    v3 = "true";
  else
    v3 = "false";
  v4 = v2 - v3;
  if ( v2 != v3 )
  {
    v5 = (char *)a2[1];
    v6 = (size_t)a2[2];
    v8 = &v5[v4];
    if ( (unsigned __int64)&v5[v4] <= v6 )
    {
      v12 = (char *)*a2;
    }
    else
    {
      v9 = 2 * v6;
      v10 = *a2;
      if ( v9 <= (unsigned __int64)(v8 + 992) )
        v11 = (size_t)(v8 + 992);
      else
        v11 = v9;
      a2[2] = (void *)v11;
      v12 = (char *)realloc(v10, v11);
      *a2 = v12;
      if ( !v12 )
        std::terminate();
      v5 = (char *)a2[1];
    }
    result = memcpy(&v5[(_QWORD)v12], v3, v4);
    a2[1] = (char *)a2[1] + v4;
  }
  return result;
}

//----- (000000000005906C) ----------------------------------------------------
void __fastcall sub_5906C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000059074) ----------------------------------------------------
void *__fastcall sub_59074(void *result, void **a2)
{
  unsigned __int8 *v2; // x8
  int v3; // w9
  int v4; // w11
  int v5; // w14
  int v6; // w15
  char v7; // w16
  char v8; // w9
  char v9; // w16
  char v10; // w9
  int v11; // w17
  char v12; // w16
  char v13; // w11
  char v14; // w11
  int v15; // w15
  char v16; // w9
  int v17; // w14
  int v18; // w8
  char v19; // w9
  char v20; // w11
  char v21; // w11
  char v22; // w16
  char v23; // w15
  char v24; // w10
  char v25; // w10
  char v26; // w12
  char v27; // w12
  char *v29; // x8
  char *v30; // x9
  char v31; // w11
  char *v33; // x8
  unsigned __int64 v34; // x9
  size_t v35; // x20
  unsigned __int64 v36; // x10
  unsigned __int64 v37; // x9
  void *v38; // x0
  size_t v39; // x1
  char *v40; // x0
  _QWORD v41[3]; // [xsp+0h] [xbp-20h] BYREF
  float v42; // [xsp+18h] [xbp-8h] BYREF

  v2 = (unsigned __int8 *)*((_QWORD *)result + 2);
  if ( (unsigned __int64)(*((_QWORD *)result + 3) - (_QWORD)v2 + 1LL) >= 9 )
  {
    v3 = *v2;
    v4 = v2[1];
    v5 = v2[2];
    v6 = v2[3];
    v7 = (unsigned int)(v3 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v8 = v7 + v3;
    v9 = (unsigned int)(v4 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v10 = v9 + v4 + 16 * v8;
    v11 = v2[4];
    v12 = (unsigned int)(v5 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v13 = (unsigned int)(v6 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    LOBYTE(v42) = v10;
    v14 = v13 + v6;
    v15 = v2[5];
    v16 = v12 + v5;
    v17 = v2[6];
    v18 = v2[7];
    v19 = v14 + 16 * v16;
    v20 = (unsigned int)(v11 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v21 = v20 + v11;
    v22 = (unsigned int)(v15 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v23 = v22 + v15;
    v24 = (unsigned int)(v17 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v25 = v24 + v17;
    v26 = (unsigned int)(v18 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v27 = v26 + v18;
    v29 = (char *)&v42 + 1;
    BYTE1(v42) = v19;
    v30 = (char *)&v42 + 3;
    BYTE2(v42) = v23 + 16 * v21;
    HIBYTE(v42) = v27 + 16 * v25;
    do
    {
      v31 = *(v29 - 1);
      *(v29 - 1) = *v30;
      *v30-- = v31;
    }
    while ( v29++ < v30 );
    memset(v41, 0, sizeof(v41));
    result = (void *)snprintf((char *)v41, 0x18u, "%af", v42);
    if ( (_DWORD)result )
    {
      v33 = (char *)a2[1];
      v34 = (unsigned __int64)a2[2];
      v35 = (int)result;
      v36 = (unsigned __int64)&v33[(int)result];
      if ( v36 <= v34 )
      {
        v40 = (char *)*a2;
      }
      else
      {
        v37 = 2 * v34;
        v38 = *a2;
        if ( v37 <= v36 + 992 )
          v39 = v36 + 992;
        else
          v39 = v37;
        a2[2] = (void *)v39;
        v40 = (char *)realloc(v38, v39);
        *a2 = v40;
        if ( !v40 )
          std::terminate();
        v33 = (char *)a2[1];
      }
      result = memcpy(&v33[(_QWORD)v40], v41, v35);
      a2[1] = (char *)a2[1] + v35;
    }
  }
  return result;
}

//----- (0000000000059238) ----------------------------------------------------
void __fastcall sub_59238(void *a1)
{
  operator delete(a1);
}

//----- (0000000000059240) ----------------------------------------------------
void *__fastcall sub_59240(void *result, void **a2)
{
  unsigned __int8 *v2; // x8
  int v3; // w12
  int v4; // w13
  int v5; // w14
  int v6; // w15
  char v7; // w16
  char v8; // w12
  char v9; // w16
  char v10; // w12
  int v11; // w17
  char v12; // w16
  char v13; // w13
  char v14; // w13
  int v15; // w15
  char v16; // w12
  int v17; // w14
  char v18; // w12
  char v19; // w13
  int v20; // w16
  char v21; // w13
  char v22; // w17
  char v23; // w15
  char v24; // w17
  char v25; // w14
  char v26; // w17
  int v27; // w0
  char v28; // w13
  char v29; // w12
  int v30; // w15
  int v31; // w14
  char v32; // w12
  int v33; // w16
  char v34; // w13
  char v35; // w12
  char v36; // w13
  int v37; // w15
  char v38; // w13
  char v39; // w14
  char v40; // w14
  int v41; // w16
  char v42; // w13
  int v43; // w14
  char v44; // w17
  char v45; // w15
  int v46; // w0
  char v47; // w8
  char v48; // w16
  char v49; // w8
  char v50; // w9
  char v51; // w10
  char *v53; // x8
  char v54; // w10
  char *v55; // x9
  char v56; // w11
  char *v58; // x8
  unsigned __int64 v59; // x9
  size_t v60; // x20
  unsigned __int64 v61; // x10
  unsigned __int64 v62; // x9
  void *v63; // x0
  size_t v64; // x1
  char *v65; // x0
  _OWORD v66[2]; // [xsp+0h] [xbp-30h] BYREF
  double v67; // [xsp+28h] [xbp-8h] BYREF

  v2 = (unsigned __int8 *)*((_QWORD *)result + 2);
  if ( (unsigned __int64)(*((_QWORD *)result + 3) - (_QWORD)v2 + 1LL) >= 0x11 )
  {
    v3 = *v2;
    v4 = v2[1];
    v5 = v2[2];
    v6 = v2[3];
    v7 = (unsigned int)(v3 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v8 = v7 + v3;
    v9 = (unsigned int)(v4 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v10 = v9 + v4 + 16 * v8;
    v11 = v2[4];
    v12 = (unsigned int)(v5 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v13 = (unsigned int)(v6 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    LOBYTE(v67) = v10;
    v14 = v13 + v6;
    v15 = v2[5];
    v16 = v12 + v5;
    v17 = v2[6];
    v18 = v14 + 16 * v16;
    v19 = (unsigned int)(v11 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v20 = v2[7];
    v21 = v19 + v11;
    v22 = (unsigned int)(v15 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v23 = v22 + v15;
    v24 = (unsigned int)(v17 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v25 = v24 + v17;
    v26 = (unsigned int)(v20 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v27 = v2[8];
    v28 = v23 + 16 * v21;
    BYTE1(v67) = v18;
    v29 = v26 + v20 + 16 * v25;
    v30 = v2[9];
    BYTE2(v67) = v28;
    v31 = v2[10];
    BYTE3(v67) = v29;
    v32 = (unsigned int)(v27 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v33 = v2[11];
    v34 = (unsigned int)(v30 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v35 = v34 + v30 + 16 * (v32 + v27);
    v36 = (unsigned int)(v31 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v37 = v2[12];
    v38 = v36 + v31;
    v39 = (unsigned int)(v33 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v40 = v39 + v33;
    v41 = v2[13];
    v42 = v40 + 16 * v38;
    v43 = v2[14];
    v44 = (unsigned int)(v37 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v45 = v44 + v37;
    v46 = v2[15];
    v47 = (unsigned int)(v41 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v48 = v47 + v41;
    v49 = (unsigned int)(v43 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v50 = v49 + v43;
    v51 = (unsigned int)(v46 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v53 = (char *)&v67 + 1;
    v54 = v51 + v46 + 16 * v50;
    v55 = (char *)&v67 + 7;
    BYTE4(v67) = v35;
    BYTE5(v67) = v42;
    BYTE6(v67) = v48 + 16 * v45;
    HIBYTE(v67) = v54;
    do
    {
      v56 = *(v53 - 1);
      *(v53 - 1) = *v55;
      *v55-- = v56;
    }
    while ( v53++ < v55 );
    memset(v66, 0, sizeof(v66));
    result = (void *)snprintf((char *)v66, 0x20u, "%a", v67);
    if ( (_DWORD)result )
    {
      v58 = (char *)a2[1];
      v59 = (unsigned __int64)a2[2];
      v60 = (int)result;
      v61 = (unsigned __int64)&v58[(int)result];
      if ( v61 <= v59 )
      {
        v65 = (char *)*a2;
      }
      else
      {
        v62 = 2 * v59;
        v63 = *a2;
        if ( v62 <= v61 + 992 )
          v64 = v61 + 992;
        else
          v64 = v62;
        a2[2] = (void *)v64;
        v65 = (char *)realloc(v63, v64);
        *a2 = v65;
        if ( !v65 )
          std::terminate();
        v58 = (char *)a2[1];
      }
      result = memcpy(&v58[(_QWORD)v65], v66, v60);
      a2[1] = (char *)a2[1] + v60;
    }
  }
  return result;
}

//----- (00000000000594C0) ----------------------------------------------------
void __fastcall sub_594C0(void *a1)
{
  operator delete(a1);
}

//----- (00000000000594C8) ----------------------------------------------------
void *__fastcall sub_594C8(void *result, void **a2)
{
  unsigned __int8 *v2; // x8
  int v3; // w12
  int v4; // w13
  int v5; // w14
  int v6; // w15
  char v7; // w16
  char v8; // w12
  char v9; // w16
  char v10; // w12
  int v11; // w17
  char v12; // w16
  char v13; // w13
  char v14; // w13
  int v15; // w15
  char v16; // w12
  int v17; // w14
  char v18; // w12
  char v19; // w13
  int v20; // w16
  char v21; // w13
  char v22; // w17
  char v23; // w15
  char v24; // w17
  char v25; // w14
  char v26; // w17
  int v27; // w0
  char v28; // w13
  char v29; // w12
  int v30; // w15
  int v31; // w14
  char v32; // w12
  int v33; // w16
  char v34; // w12
  char v35; // w13
  char v36; // w12
  char v37; // w13
  int v38; // w15
  char v39; // w12
  char v40; // w12
  int v41; // w16
  char v42; // w12
  char v43; // w13
  int v44; // w14
  char v45; // w13
  int v46; // w15
  char v47; // w17
  char v48; // w16
  char v49; // w17
  char v50; // w14
  char v51; // w17
  int v52; // w0
  char v53; // w12
  int v54; // w15
  int v55; // w14
  char v56; // w12
  int v57; // w16
  char v58; // w12
  char v59; // w13
  char v60; // w12
  char v61; // w13
  int v62; // w15
  char v63; // w12
  char v64; // w12
  int v65; // w16
  char v66; // w12
  char v67; // w13
  int v68; // w14
  char v69; // w13
  int v70; // w15
  char v71; // w17
  char v72; // w16
  char v73; // w17
  char v74; // w14
  char v75; // w17
  int v76; // w0
  char v77; // w12
  int v78; // w15
  int v79; // w14
  char v80; // w12
  int v81; // w16
  char v82; // w13
  char v83; // w12
  char v84; // w13
  int v85; // w15
  char v86; // w13
  char v87; // w14
  char v88; // w14
  int v89; // w16
  char v90; // w13
  int v91; // w14
  char v92; // w17
  char v93; // w15
  int v94; // w0
  char v95; // w8
  char v96; // w16
  char v97; // w8
  char v98; // w9
  char v99; // w10
  char *v101; // x8
  char v102; // w10
  char *v103; // x9
  char v104; // w11
  char *v106; // x8
  unsigned __int64 v107; // x9
  size_t v108; // x20
  unsigned __int64 v109; // x10
  unsigned __int64 v110; // x9
  void *v111; // x0
  size_t v112; // x1
  char *v113; // x0
  _OWORD v114[3]; // [xsp+0h] [xbp-40h] BYREF
  long double v115; // [xsp+30h] [xbp-10h] BYREF

  v2 = (unsigned __int8 *)*((_QWORD *)result + 2);
  if ( (unsigned __int64)(*((_QWORD *)result + 3) - (_QWORD)v2 + 1LL) >= 0x21 )
  {
    v3 = *v2;
    v4 = v2[1];
    v5 = v2[2];
    v6 = v2[3];
    v7 = (unsigned int)(v3 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v8 = v7 + v3;
    v9 = (unsigned int)(v4 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v10 = v9 + v4 + 16 * v8;
    v11 = v2[4];
    v12 = (unsigned int)(v5 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v13 = (unsigned int)(v6 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    LOBYTE(v115) = v10;
    v14 = v13 + v6;
    v15 = v2[5];
    v16 = v12 + v5;
    v17 = v2[6];
    v18 = v14 + 16 * v16;
    v19 = (unsigned int)(v11 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v20 = v2[7];
    v21 = v19 + v11;
    v22 = (unsigned int)(v15 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v23 = v22 + v15;
    v24 = (unsigned int)(v17 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v25 = v24 + v17;
    v26 = (unsigned int)(v20 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v27 = v2[8];
    v28 = v23 + 16 * v21;
    BYTE1(v115) = v18;
    v29 = v26 + v20 + 16 * v25;
    v30 = v2[9];
    BYTE2(v115) = v28;
    v31 = v2[10];
    BYTE3(v115) = v29;
    v32 = (unsigned int)(v27 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v33 = v2[11];
    v34 = v32 + v27;
    v35 = (unsigned int)(v30 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v36 = v35 + v30 + 16 * v34;
    v37 = (unsigned int)(v31 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v38 = v2[12];
    BYTE4(v115) = v36;
    v39 = (unsigned int)(v33 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v40 = v39 + v33;
    v41 = v2[13];
    v42 = v40 + 16 * (v37 + v31);
    v43 = (unsigned int)(v38 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v44 = v2[14];
    v45 = v43 + v38;
    v46 = v2[15];
    v47 = (unsigned int)(v41 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v48 = v47 + v41;
    v49 = (unsigned int)(v44 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v50 = v49 + v44;
    v51 = (unsigned int)(v46 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v52 = v2[16];
    BYTE5(v115) = v42;
    v53 = v51 + v46 + 16 * v50;
    v54 = v2[17];
    BYTE6(v115) = v48 + 16 * v45;
    v55 = v2[18];
    BYTE7(v115) = v53;
    v56 = (unsigned int)(v52 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v57 = v2[19];
    v58 = v56 + v52;
    v59 = (unsigned int)(v54 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v60 = v59 + v54 + 16 * v58;
    v61 = (unsigned int)(v55 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v62 = v2[20];
    BYTE8(v115) = v60;
    v63 = (unsigned int)(v57 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v64 = v63 + v57;
    v65 = v2[21];
    v66 = v64 + 16 * (v61 + v55);
    v67 = (unsigned int)(v62 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v68 = v2[22];
    v69 = v67 + v62;
    v70 = v2[23];
    v71 = (unsigned int)(v65 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v72 = v71 + v65;
    v73 = (unsigned int)(v68 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v74 = v73 + v68;
    v75 = (unsigned int)(v70 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v76 = v2[24];
    BYTE9(v115) = v66;
    v77 = v75 + v70 + 16 * v74;
    v78 = v2[25];
    BYTE10(v115) = v72 + 16 * v69;
    v79 = v2[26];
    BYTE11(v115) = v77;
    v80 = (unsigned int)(v76 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v81 = v2[27];
    v82 = (unsigned int)(v78 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v83 = v82 + v78 + 16 * (v80 + v76);
    v84 = (unsigned int)(v79 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v85 = v2[28];
    v86 = v84 + v79;
    v87 = (unsigned int)(v81 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v88 = v87 + v81;
    v89 = v2[29];
    v90 = v88 + 16 * v86;
    v91 = v2[30];
    v92 = (unsigned int)(v85 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v93 = v92 + v85;
    v94 = v2[31];
    v95 = (unsigned int)(v89 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v96 = v95 + v89;
    v97 = (unsigned int)(v91 - 58) >= 0xFFFFFFF6 ? 0 : 9;
    v98 = v97 + v91;
    v99 = (unsigned int)(v94 - 58) >= 0xFFFFFFF6 ? -48 : -87;
    v101 = (char *)&v115 + 1;
    v102 = v99 + v94 + 16 * v98;
    v103 = (char *)((unsigned __int64)&v115 | 0xF);
    BYTE12(v115) = v83;
    BYTE13(v115) = v90;
    BYTE14(v115) = v96 + 16 * v93;
    HIBYTE(v115) = v102;
    do
    {
      v104 = *(v101 - 1);
      *(v101 - 1) = *v103;
      *v103-- = v104;
    }
    while ( v101++ < v103 );
    memset(v114, 0, 42);
    result = (void *)snprintf((char *)v114, 0x2Au, "%LaL", v115);
    if ( (_DWORD)result )
    {
      v106 = (char *)a2[1];
      v107 = (unsigned __int64)a2[2];
      v108 = (int)result;
      v109 = (unsigned __int64)&v106[(int)result];
      if ( v109 <= v107 )
      {
        v113 = (char *)*a2;
      }
      else
      {
        v110 = 2 * v107;
        v111 = *a2;
        if ( v110 <= v109 + 992 )
          v112 = v109 + 992;
        else
          v112 = v110;
        a2[2] = (void *)v112;
        v113 = (char *)realloc(v111, v112);
        *a2 = v113;
        if ( !v113 )
          std::terminate();
        v106 = (char *)a2[1];
      }
      result = memcpy(&v106[(_QWORD)v113], v114, v108);
      a2[1] = (char *)a2[1] + v108;
    }
  }
  return result;
}

//----- (00000000000598CC) ----------------------------------------------------
void __fastcall sub_598CC(void *a1)
{
  operator delete(a1);
}

//----- (00000000000598D4) ----------------------------------------------------
char *__fastcall sub_598D4(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 *v11; // x20
  __int64 v12; // x9
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  void *v17; // x0
  size_t v18; // x1
  char *result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 2) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 994);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_18;
    v2 = (char *)a2[1];
  }
  *(_WORD *)&v2[(_QWORD)v10] = 15394;
  v11 = *(__int64 **)(a1 + 16);
  v12 = *v11;
  a2[1] = (char *)a2[1] + 2;
  (*(void (__fastcall **)(__int64 *, void **))(v12 + 32))(v11, a2);
  if ( (*(_WORD *)((_BYTE *)v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, void **))(*v11 + 40))(v11, a2);
  v13 = (char *)a2[1];
  v14 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v13 + 2) <= v14 )
  {
    result = (char *)*a2;
    goto LABEL_17;
  }
  v15 = (size_t)(v13 + 994);
  v16 = 2 * v14;
  v17 = *a2;
  if ( v16 <= v15 )
    v18 = v15;
  else
    v18 = v16;
  a2[2] = (void *)v18;
  result = (char *)realloc(v17, v18);
  *a2 = result;
  if ( !result )
LABEL_18:
    std::terminate();
  v13 = (char *)a2[1];
LABEL_17:
  *(_WORD *)&v13[(_QWORD)result] = 8766;
  a2[1] = (char *)a2[1] + 2;
  return result;
}

//----- (00000000000599E4) ----------------------------------------------------
void __fastcall sub_599E4(void *a1)
{
  operator delete(a1);
}

//----- (00000000000599EC) ----------------------------------------------------
__int64 *__fastcall sub_599EC(const char **a1)
{
  const char *v1; // x20
  char *v2; // x19
  __int64 v4; // x0
  const char *v5; // x21
  __int64 v6; // x20
  __int64 v7; // x8
  char *v8; // x0
  __int64 v9; // x8
  __int64 *v10; // x19
  __int64 (__fastcall **v11)(); // x8
  __int64 v12; // x0
  const char *v13; // x21
  __int64 v14; // x20
  __int64 v15; // x8
  char *v16; // x0
  __int64 v17; // x8
  __int64 v18; // x0
  __int64 v19; // x20
  __int64 v20; // x0
  const char *v21; // x22
  __int64 v22; // x21
  __int64 v23; // x8
  char *v24; // x0
  __int64 v25; // x8
  __int64 v27; // x0
  const char **v28; // x22
  char *v29; // x8
  const char *v30; // x25
  const char *v31; // x27
  __int64 v32; // x20
  signed __int64 v33; // x21
  char *v34; // x9
  __int64 v35; // x28
  const char *v36; // x23
  char *v37; // x0
  unsigned __int64 v38; // x21
  const char *v39; // x25
  __int64 *v40; // x8
  const char *v41; // x8
  __int64 v42; // x23
  const char **v43; // x0
  signed __int64 v44; // x24
  char *v45; // x0
  char *v46; // x0
  const char *v47; // x23
  char *v48; // x21
  __int64 v49; // x1
  __int64 v50; // x22
  __int64 v51; // x8
  char *v52; // x0
  __int64 v53; // x8
  char *v54; // x9
  const char *v55; // x10
  _QWORD *v56; // x19
  __int64 v57; // x1
  __int64 v58; // x2
  __int64 v59; // x3
  __int64 v60; // x4
  __int64 v61; // x5
  __int64 v62; // x6
  __int64 v63; // x7
  __int64 v64; // x8
  double v65; // d0
  double v66; // d1
  double v67; // d2
  double v68; // d3
  double v69; // d4
  double v70; // d5
  double v71; // d6
  double v72; // d7
  const char **v73; // [xsp+8h] [xbp-68h] BYREF
  unsigned __int64 v74; // [xsp+10h] [xbp-60h]
  void *ptr[3]; // [xsp+18h] [xbp-58h] BYREF
  _OWORD v76[4]; // [xsp+30h] [xbp-40h] BYREF
  __int64 vars0; // [xsp+70h] [xbp+0h] BYREF

  v1 = *a1;
  if ( (unsigned __int64)(a1[1] - *a1) < 2 )
    return 0;
  if ( !strncmp("Ty", v1, 2u) )
  {
    *a1 = v1 + 2;
    v12 = sub_5A0A4(a1, 0);
    if ( v12 )
    {
      v13 = a1[614];
      v14 = v12;
      v15 = *((_QWORD *)v13 + 1);
      if ( (unsigned __int64)(v15 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v16 = (char *)malloc(0x1000u);
        if ( !v16 )
          goto LABEL_52;
        v15 = 0;
        *(_QWORD *)v16 = v13;
        *((_QWORD *)v16 + 1) = 0;
        v13 = v16;
        a1[614] = v16;
      }
      v17 = v15 + 32;
      v10 = (__int64 *)&v13[v17];
      *((_QWORD *)v13 + 1) = v17;
      LOWORD(v17) = *(_WORD *)&v13[v17 - 7];
      *((_BYTE *)v10 - 8) = 32;
      *v10 = v14;
      *(_WORD *)((char *)v10 - 7) = v17 & 0xF000 | 0x500;
      v11 = off_70998;
      goto LABEL_23;
    }
    return 0;
  }
  if ( !strncmp("Tn", v1, 2u) )
  {
    *a1 = v1 + 2;
    v18 = sub_5A0A4(a1, 1u);
    if ( v18 )
    {
      v19 = v18;
      v20 = sub_4DAC4(a1);
      if ( v20 )
      {
        v21 = a1[614];
        v22 = v20;
        v23 = *((_QWORD *)v21 + 1);
        if ( (unsigned __int64)(v23 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
        {
          v24 = (char *)malloc(0x1000u);
          if ( !v24 )
            goto LABEL_52;
          v23 = 0;
          *(_QWORD *)v24 = v21;
          *((_QWORD *)v24 + 1) = 0;
          v21 = v24;
          a1[614] = v24;
        }
        v25 = v23 + 32;
        v10 = (__int64 *)&v21[v25];
        *((_QWORD *)v21 + 1) = v25;
        LOWORD(v25) = *(_WORD *)&v21[v25 - 7];
        *((_BYTE *)v10 - 8) = 33;
        *v10 = v19;
        v10[1] = v22;
        *(_WORD *)((char *)v10 - 7) = v25 & 0xF000 | 0x500;
        v11 = off_70A08;
        goto LABEL_23;
      }
    }
    return 0;
  }
  if ( strncmp("Tt", v1, 2u) )
  {
    if ( !strncmp("Tp", v1, 2u) )
    {
      *a1 = v1 + 2;
      v4 = sub_599EC(a1);
      if ( v4 )
      {
        v5 = a1[614];
        v6 = v4;
        v7 = *((_QWORD *)v5 + 1);
        if ( (unsigned __int64)(v7 - 4048) > 0xFFFFFFFFFFFFF00FLL )
        {
LABEL_11:
          v9 = v7 + 32;
          v10 = (__int64 *)&v5[v9];
          *((_QWORD *)v5 + 1) = v9;
          LOWORD(v9) = *(_WORD *)&v5[v9 - 7];
          *((_BYTE *)v10 - 8) = 35;
          *v10 = v6;
          *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x500;
          v11 = off_70AE8;
LABEL_23:
          *(v10 - 2) = (__int64)v11;
          return v10 - 2;
        }
        v8 = (char *)malloc(0x1000u);
        if ( v8 )
        {
          v7 = 0;
          *(_QWORD *)v8 = v5;
          *((_QWORD *)v8 + 1) = 0;
          v5 = v8;
          a1[614] = v8;
          goto LABEL_11;
        }
LABEL_52:
        std::terminate();
      }
    }
    return 0;
  }
  *a1 = v1 + 2;
  v27 = sub_5A0A4(a1, 2u);
  if ( !v27 )
    return 0;
  v28 = (const char **)a1[83];
  v29 = (char *)a1[84];
  v30 = a1[2];
  v31 = a1[3];
  v32 = v27;
  v33 = v29 - (char *)v28;
  ptr[2] = &vars0;
  v34 = (char *)a1[85];
  v35 = (v29 - (char *)v28) >> 3;
  memset(v76, 0, sizeof(v76));
  ptr[0] = v76;
  ptr[1] = v76;
  v73 = a1;
  v74 = v35;
  if ( v29 == v34 )
  {
    if ( v28 == a1 + 86 )
    {
      v37 = (char *)malloc(2 * v33);
      if ( !v37 )
        goto LABEL_52;
      v36 = v37;
      memmove(v37, v28, v33);
      a1[83] = v36;
    }
    else
    {
      v36 = (const char *)realloc(v28, 2 * v33);
      a1[83] = v36;
      if ( !v36 )
        goto LABEL_52;
    }
    v29 = (char *)&v36[8 * v35];
    a1[85] = &v36[8 * (v33 >> 2)];
  }
  v38 = (v31 - v30) >> 3;
  a1[84] = v29 + 8;
  *(_QWORD *)v29 = ptr;
  while ( 1 )
  {
    v41 = *a1;
    if ( a1[1] != *a1 && *v41 == 69 )
      break;
    v42 = sub_599EC(a1);
    if ( !v42 )
    {
      v2 = 0;
      goto LABEL_49;
    }
    v40 = (__int64 *)a1[3];
    if ( v40 == (__int64 *)a1[4] )
    {
      v43 = (const char **)a1[2];
      v44 = (char *)v40 - (char *)v43;
      if ( v43 == a1 + 5 )
      {
        v45 = (char *)malloc(2 * ((char *)v40 - (char *)v43));
        if ( !v45 )
          goto LABEL_52;
        v39 = v45;
        memcpy(v45, a1 + 5, v44);
        a1[2] = v39;
      }
      else
      {
        v39 = (const char *)realloc(v43, 2 * ((char *)v40 - (char *)v43));
        a1[2] = v39;
        if ( !v39 )
          goto LABEL_52;
      }
      v40 = (__int64 *)&v39[v44];
      a1[3] = &v39[v44];
      a1[4] = &v39[8 * (v44 >> 2)];
    }
    a1[3] = (const char *)(v40 + 1);
    *v40 = v42;
  }
  *a1 = v41 + 1;
  v46 = sub_4F750(a1, v38);
  v47 = a1[614];
  v48 = v46;
  v50 = v49;
  v51 = *((_QWORD *)v47 + 1);
  if ( (unsigned __int64)(v51 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v52 = (char *)malloc(0x1000u);
    if ( !v52 )
      goto LABEL_52;
    v51 = 0;
    *(_QWORD *)v52 = v47;
    *((_QWORD *)v52 + 1) = 0;
    v47 = v52;
    a1[614] = v52;
  }
  v53 = v51 + 48;
  v54 = (char *)&v47[v53];
  *((_QWORD *)v47 + 1) = v53;
  LOWORD(v53) = *(_WORD *)&v47[v53 - 23];
  *(v54 - 24) = 34;
  *((_QWORD *)v54 - 2) = v32;
  *((_QWORD *)v54 - 1) = v48;
  *(_QWORD *)v54 = v50;
  *(_WORD *)(v54 - 23) = v53 & 0xF000 | 0x500;
  *((_QWORD *)v54 - 4) = off_70A78;
  v2 = v54 - 32;
LABEL_49:
  v55 = v73[83];
  if ( v74 > (v73[84] - v55) >> 3 )
  {
    v56 = (_QWORD *)__assert2(
                      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
                      2409,
                      "(anonymous namespace)::itanium_demangle::AbstractManglingParser<(anonymous namespace)::itanium_dem"
                      "angle::ManglingParser<(anonymous namespace)::DefaultAllocator>, (anonymous namespace)::DefaultAllo"
                      "cator>::ScopedTemplateParamList::~ScopedTemplateParamList() [Derived = (anonymous namespace)::itan"
                      "ium_demangle::ManglingParser<(anonymous namespace)::DefaultAllocator>, Alloc = (anonymous namespac"
                      "e)::DefaultAllocator]",
                      "Parser->TemplateParams.size() >= OldNumTemplateParamLists");
    sub_59ED0(&v73);
    sub_65E10(v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72);
  }
  v73[84] = &v55[8 * v74];
  if ( ptr[0] != v76 )
    free(ptr[0]);
  return (__int64 *)v2;
}
// 59DEC: variable 'v49' is possibly undefined
// 59ECC: variable 'v57' is possibly undefined
// 59ECC: variable 'v58' is possibly undefined
// 59ECC: variable 'v59' is possibly undefined
// 59ECC: variable 'v60' is possibly undefined
// 59ECC: variable 'v61' is possibly undefined
// 59ECC: variable 'v62' is possibly undefined
// 59ECC: variable 'v63' is possibly undefined
// 59ECC: variable 'v64' is possibly undefined
// 59ECC: variable 'v65' is possibly undefined
// 59ECC: variable 'v66' is possibly undefined
// 59ECC: variable 'v67' is possibly undefined
// 59ECC: variable 'v68' is possibly undefined
// 59ECC: variable 'v69' is possibly undefined
// 59ECC: variable 'v70' is possibly undefined
// 59ECC: variable 'v71' is possibly undefined
// 59ECC: variable 'v72' is possibly undefined
// 4A7CC: using guessed type void __fastcall __noreturn sub_4A7CC(_QWORD);
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 70998: using guessed type __int64 (__fastcall *off_70998[10])();
// 70A08: using guessed type __int64 (__fastcall *off_70A08[10])();
// 70A78: using guessed type __int64 (__fastcall *off_70A78[10])();
// 70AE8: using guessed type __int64 (__fastcall *off_70AE8[10])();

//----- (0000000000059ED0) ----------------------------------------------------
void __fastcall sub_59ED0(_QWORD *a1)
{
  unsigned __int64 v1; // x10
  __int64 v2; // x11
  _QWORD *v3; // x8
  __int64 v4; // x0

  v1 = a1[1];
  v2 = *(_QWORD *)(*a1 + 664LL);
  if ( v1 > (*(_QWORD *)(*a1 + 672LL) - v2) >> 3 )
  {
    v4 = __assert2(
           "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
           2409,
           "(anonymous namespace)::itanium_demangle::AbstractManglingParser<(anonymous namespace)::itanium_demangle::Mang"
           "lingParser<(anonymous namespace)::DefaultAllocator>, (anonymous namespace)::DefaultAllocator>::ScopedTemplate"
           "ParamList::~ScopedTemplateParamList() [Derived = (anonymous namespace)::itanium_demangle::ManglingParser<(ano"
           "nymous namespace)::DefaultAllocator>, Alloc = (anonymous namespace)::DefaultAllocator]",
           "Parser->TemplateParams.size() >= OldNumTemplateParamLists");
    sub_4A7CC(v4);
  }
  v3 = (_QWORD *)a1[2];
  *(_QWORD *)(*a1 + 672LL) = v2 + 8 * v1;
  if ( v3 != a1 + 5 )
    free(v3);
}
// 4A7CC: using guessed type void __fastcall __noreturn sub_4A7CC(_QWORD);
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000059F4C) ----------------------------------------------------
char *__fastcall sub_59F4C(__int64 a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x8
  _BYTE *v12; // x9
  _BYTE *v13; // x21
  size_t v14; // x20
  size_t v15; // x9
  size_t v16; // x10
  unsigned __int64 v17; // x9
  char *v18; // x0
  size_t v19; // x1
  char *v20; // x0
  unsigned __int64 v21; // x9
  size_t v22; // x8
  unsigned __int64 v23; // x9
  char *v24; // x0
  size_t v25; // x1
  char *result; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 8) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1000);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_25;
    v2 = a2[1];
  }
  *(_QWORD *)&v2[(_QWORD)v10] = 0x64656D616E6E7527LL;
  v11 = (__int64)(a2[1] + 8);
  a2[1] = (char *)v11;
  v13 = *(_BYTE **)(a1 + 16);
  v12 = *(_BYTE **)(a1 + 24);
  v14 = v12 - v13;
  if ( v12 != v13 )
  {
    v15 = (size_t)a2[2];
    v16 = v11 + v14;
    if ( v11 + v14 <= v15 )
    {
      v20 = *a2;
    }
    else
    {
      v17 = 2 * v15;
      v18 = *a2;
      if ( v17 <= v16 + 992 )
        v19 = v16 + 992;
      else
        v19 = v17;
      a2[2] = (char *)v19;
      v20 = (char *)realloc(v18, v19);
      *a2 = v20;
      if ( !v20 )
        goto LABEL_25;
      v11 = (__int64)a2[1];
    }
    memcpy(&v20[v11], v13, v14);
    v11 = (__int64)&a2[1][v14];
    a2[1] = (char *)v11;
  }
  v21 = (unsigned __int64)a2[2];
  if ( v11 + 1 <= v21 )
  {
    result = *a2;
    goto LABEL_24;
  }
  v22 = v11 + 993;
  v23 = 2 * v21;
  v24 = *a2;
  if ( v23 <= v22 )
    v25 = v22;
  else
    v25 = v23;
  a2[2] = (char *)v25;
  result = (char *)realloc(v24, v25);
  *a2 = result;
  if ( !result )
LABEL_25:
    std::terminate();
  v11 = (__int64)a2[1];
LABEL_24:
  result[v11] = 39;
  ++a2[1];
  return result;
}

//----- (000000000005A09C) ----------------------------------------------------
void __fastcall sub_5A09C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A0A4) ----------------------------------------------------
__int64 __fastcall sub_5A0A4(_QWORD *a1, size_t size)
{
  char *v2; // x9
  _QWORD *v3; // x22
  int v4; // w19
  int v6; // w21
  __int64 v7; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _DWORD *v10; // x9
  __int64 v11; // x11
  __int64 v12; // x8
  __int64 v13; // x19
  __int64 v14; // x23
  __int64 *v15; // x8
  const void *v16; // x22
  signed __int64 v17; // x20
  char *v18; // x21
  char *v19; // x0
  __int64 result; // x0

  v2 = (char *)a1 + 4 * (int)size;
  v3 = (_QWORD *)a1[614];
  v4 = size;
  v6 = *((_DWORD *)v2 + 198);
  v7 = v3[1];
  *((_DWORD *)v2 + 198) = v6 + 1;
  if ( (unsigned __int64)(v7 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      goto LABEL_14;
    v7 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    a1[614] = v8;
  }
  v9 = v7 + 32;
  v10 = (_DWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *(v10 - 1) = v4;
  *v10 = v6;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x540;
  v11 = a1[83];
  *((_BYTE *)v10 - 8) = 31;
  v12 = a1[84];
  *((_QWORD *)v10 - 2) = off_70928;
  v13 = (__int64)(v10 - 4);
  if ( v12 == v11 )
  {
    __assert2(
      "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
      139,
      "T &(anonymous namespace)::itanium_demangle::PODSmallVector<(anonymous namespace)::itanium_demangle::PODSmallVector"
      "<(anonymous namespace)::itanium_demangle::Node *, 8> *, 4>::back() [T = (anonymous namespace)::itanium_demangle::P"
      "ODSmallVector<(anonymous namespace)::itanium_demangle::Node *, 8> *, N = 4]",
      "Last != First && \"Calling back() on empty vector!\"");
    goto LABEL_14;
  }
  v14 = *(_QWORD *)(v12 - 8);
  v15 = *(__int64 **)(v14 + 8);
  if ( v15 == *(__int64 **)(v14 + 16) )
  {
    v16 = *(const void **)v14;
    v17 = (signed __int64)v15 - *(_QWORD *)v14;
    if ( *(_QWORD *)v14 == v14 + 24 )
    {
      v19 = (char *)malloc(2 * v17);
      if ( !v19 )
        goto LABEL_14;
      v18 = v19;
      memmove(v19, v16, v17);
      *(_QWORD *)v14 = v18;
    }
    else
    {
      v18 = (char *)realloc(*(void **)v14, 2 * v17);
      *(_QWORD *)v14 = v18;
      if ( !v18 )
LABEL_14:
        std::terminate();
    }
    v15 = (__int64 *)&v18[v17];
    *(_QWORD *)(v14 + 16) = &v18[8 * (v17 >> 2)];
  }
  result = v13;
  *(_QWORD *)(v14 + 8) = v15 + 1;
  *v15 = v13;
  return result;
}
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);
// 70928: using guessed type __int64 (__fastcall *off_70928[10])();

//----- (000000000005A20C) ----------------------------------------------------
char *__fastcall sub_5A20C(char *result, _QWORD *a2)
{
  int v2; // w8
  char *v3; // x20
  __int64 v5; // x8
  unsigned __int64 v6; // x9
  __int64 *v7; // x21
  size_t v8; // x8
  unsigned __int64 v9; // x9
  char *v10; // x0
  size_t v11; // x1
  __int64 v12; // x8
  unsigned __int64 v13; // x9
  size_t v14; // x8
  unsigned __int64 v15; // x9
  char *v16; // x0
  size_t v17; // x1
  unsigned __int64 v18; // x9
  size_t v19; // x8
  unsigned __int64 v20; // x9
  char *v21; // x0
  size_t v22; // x1
  __int16 v23; // w10
  char *v24; // x8
  __int64 v25; // x9
  int v26; // w8
  __int64 v27; // x20
  unsigned __int64 v28; // x8
  _BYTE *v29; // x14
  bool v30; // cf
  bool v31; // zf
  int v32; // w13
  __int64 v33; // x8
  unsigned __int64 v34; // x9
  __int64 v35; // x10
  unsigned __int64 v36; // x9
  char *v37; // x0
  size_t v38; // x1
  char *v39; // x0
  _BYTE v40[24]; // [xsp+8h] [xbp-18h] BYREF

  v2 = *((_DWORD *)result + 3);
  v3 = result;
  switch ( v2 )
  {
    case 2:
      v12 = a2[1];
      v13 = a2[2];
      v7 = a2 + 1;
      if ( v12 + 3 <= v13 )
      {
        result = (char *)*a2;
      }
      else
      {
        v14 = v12 + 995;
        v15 = 2 * v13;
        v16 = (char *)*a2;
        if ( v15 <= v14 )
          v17 = v14;
        else
          v17 = v15;
        a2[2] = v17;
        result = (char *)realloc(v16, v17);
        *a2 = result;
        if ( !result )
          goto LABEL_43;
        v12 = *v7;
      }
      v24 = &result[v12];
      v25 = 3;
      v24[2] = 84;
      *(_WORD *)v24 = 21540;
      goto LABEL_29;
    case 1:
      v5 = a2[1];
      v18 = a2[2];
      v7 = a2 + 1;
      if ( v5 + 2 <= v18 )
      {
        result = (char *)*a2;
      }
      else
      {
        v19 = v5 + 994;
        v20 = 2 * v18;
        v21 = (char *)*a2;
        if ( v20 <= v19 )
          v22 = v19;
        else
          v22 = v20;
        a2[2] = v22;
        result = (char *)realloc(v21, v22);
        *a2 = result;
        if ( !result )
          goto LABEL_43;
        v5 = *v7;
      }
      v23 = 20004;
      goto LABEL_28;
    case 0:
      v5 = a2[1];
      v6 = a2[2];
      v7 = a2 + 1;
      if ( v5 + 2 <= v6 )
      {
        result = (char *)*a2;
      }
      else
      {
        v8 = v5 + 994;
        v9 = 2 * v6;
        v10 = (char *)*a2;
        if ( v9 <= v8 )
          v11 = v8;
        else
          v11 = v9;
        a2[2] = v11;
        result = (char *)realloc(v10, v11);
        *a2 = result;
        if ( !result )
          goto LABEL_43;
        v5 = *v7;
      }
      v23 = 21540;
LABEL_28:
      v25 = 2;
      *(_WORD *)&result[v5] = v23;
LABEL_29:
      *v7 += v25;
      break;
  }
  v26 = *((_DWORD *)v3 + 4);
  if ( v26 )
  {
    v27 = 0;
    v28 = (unsigned int)(v26 - 1);
    do
    {
      v29 = &v40[v27--];
      v30 = v28 >= 9;
      v31 = v28 == 9;
      v32 = v28 % 0xA;
      v28 /= 0xAu;
      v29[20] = v32 | 0x30;
    }
    while ( !v31 && v30 );
    if ( v27 )
    {
      v33 = a2[1];
      v34 = a2[2];
      v35 = v33 - v27;
      if ( v33 - v27 <= v34 )
      {
        v39 = (char *)*a2;
        goto LABEL_41;
      }
      v36 = 2 * v34;
      v37 = (char *)*a2;
      if ( v36 <= v35 + 992 )
        v38 = v35 + 992;
      else
        v38 = v36;
      a2[2] = v38;
      v39 = (char *)realloc(v37, v38);
      *a2 = v39;
      if ( v39 )
      {
        v33 = a2[1];
LABEL_41:
        result = (char *)memcpy(&v39[v33], &v40[v27 + 21], -v27);
        a2[1] -= v27;
        return result;
      }
LABEL_43:
      std::terminate();
    }
  }
  return result;
}

//----- (000000000005A418) ----------------------------------------------------
void __fastcall sub_5A418(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A420) ----------------------------------------------------
char *__fastcall sub_5A420(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v5; // x8
  unsigned __int64 v6; // x9
  void *v7; // x0
  size_t v8; // x1
  char *result; // x0
  char *v10; // x8

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 9) <= v3 )
  {
    result = (char *)*a2;
  }
  else
  {
    v5 = (size_t)(v2 + 1001);
    v6 = 2 * v3;
    v7 = *a2;
    if ( v6 <= v5 )
      v8 = v5;
    else
      v8 = v6;
    a2[2] = (void *)v8;
    result = (char *)realloc(v7, v8);
    *a2 = result;
    if ( !result )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v10 = &v2[(_QWORD)result];
  v10[8] = 32;
  *(_QWORD *)v10 = *(_QWORD *)"typename ";
  a2[1] = (char *)a2[1] + 9;
  return result;
}

//----- (000000000005A4B0) ----------------------------------------------------
__int64 __fastcall sub_5A4B0(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 40LL))(v2, a2);
  return result;
}

//----- (000000000005A518) ----------------------------------------------------
void __fastcall sub_5A518(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A520) ----------------------------------------------------
__int64 __fastcall sub_5A520(__int64 a1, __int64 *a2)
{
  __int64 result; // x0
  unsigned int v5; // w8
  __int64 v6; // x8
  unsigned __int64 v7; // x9
  size_t v8; // x8
  unsigned __int64 v9; // x9
  void *v10; // x0
  size_t v11; // x1

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 32LL))(*(_QWORD *)(a1 + 24));
  result = *(_QWORD *)(a1 + 24);
  v5 = *(unsigned __int8 *)(result + 9);
  if ( (v5 & 0xC0) == 0x80 )
  {
    result = (**(__int64 (__fastcall ***)(__int64, __int64 *))result)(result, a2);
    if ( (result & 1) != 0 )
      return result;
  }
  else if ( v5 < 0x40 )
  {
    return result;
  }
  v6 = a2[1];
  v7 = a2[2];
  if ( v6 + 1 <= v7 )
  {
    result = *a2;
  }
  else
  {
    v8 = v6 + 993;
    v9 = 2 * v7;
    v10 = (void *)*a2;
    if ( v9 <= v8 )
      v11 = v8;
    else
      v11 = v9;
    a2[2] = v11;
    result = (__int64)realloc(v10, v11);
    *a2 = result;
    if ( !result )
      std::terminate();
    v6 = a2[1];
  }
  *(_BYTE *)(result + v6) = 32;
  ++a2[1];
  return result;
}

//----- (000000000005A5F0) ----------------------------------------------------
__int64 __fastcall sub_5A5F0(__int64 a1, __int64 a2)
{
  __int64 v2; // x21

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 40LL))(v2, a2);
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 24) + 40LL))(*(_QWORD *)(a1 + 24), a2);
}

//----- (000000000005A668) ----------------------------------------------------
void __fastcall sub_5A668(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A670) ----------------------------------------------------
char *__fastcall sub_5A670(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  int v6; // w21
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  char *v12; // x8
  __int64 v13; // x22
  __int64 v14; // x8
  __int64 v15; // x23
  char v16; // w24
  __int64 v17; // x26
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x8
  char *v20; // x0
  size_t v21; // x1
  char *v22; // x0
  __int64 v23; // x8
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x8
  char *v26; // x0
  size_t v27; // x1
  char *result; // x0
  char *v29; // x9

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v6 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  if ( v2 + 9 <= v3 )
  {
    v11 = *(char **)a2;
  }
  else
  {
    v7 = v2 + 1001;
    v8 = 2 * v3;
    v9 = *(char **)a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    *(_QWORD *)(a2 + 16) = v10;
    v11 = (char *)realloc(v9, v10);
    *(_QWORD *)a2 = v11;
    if ( !v11 )
      goto LABEL_30;
    v2 = *(_QWORD *)(a2 + 8);
  }
  v12 = &v11[v2];
  v12[8] = 60;
  *(_QWORD *)v12 = *(_QWORD *)"template<";
  v13 = *(_QWORD *)(a2 + 8) + 9LL;
  v14 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a2 + 8) = v13;
  if ( v14 )
  {
    v15 = 0;
    v16 = 1;
    while ( 1 )
    {
      v17 = v13;
      if ( (v16 & 1) == 0 )
      {
        v18 = *(_QWORD *)(a2 + 16);
        if ( v13 + 2 <= v18 )
        {
          v22 = *(char **)a2;
          v23 = v13;
        }
        else
        {
          v19 = 2 * v18;
          v20 = *(char **)a2;
          if ( v19 <= v13 + 994 )
            v21 = v13 + 994;
          else
            v21 = v19;
          *(_QWORD *)(a2 + 16) = v21;
          v22 = (char *)realloc(v20, v21);
          *(_QWORD *)a2 = v22;
          if ( !v22 )
            goto LABEL_30;
          v23 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v22[v23] = 8236;
        v17 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v17;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 24) + 8 * v15), a2, 18, 0);
      if ( v17 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v13;
        if ( ++v15 == *(_QWORD *)(a1 + 32) )
          break;
      }
      else
      {
        v16 = 0;
        v13 = *(_QWORD *)(a2 + 8);
        if ( ++v15 == *(_QWORD *)(a1 + 32) )
          break;
      }
    }
  }
  v24 = *(_QWORD *)(a2 + 16);
  if ( v13 + 11 <= v24 )
  {
    result = *(char **)a2;
    goto LABEL_29;
  }
  v25 = 2 * v24;
  v26 = *(char **)a2;
  if ( v25 <= v13 + 1003 )
    v27 = v13 + 1003;
  else
    v27 = v25;
  *(_QWORD *)(a2 + 16) = v27;
  result = (char *)realloc(v26, v27);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_30:
    std::terminate();
  v13 = *(_QWORD *)(a2 + 8);
LABEL_29:
  v29 = &result[v13];
  *(_QWORD *)v29 = *(_QWORD *)"> typename ";
  *(_DWORD *)(v29 + 7) = 543518049;
  *(_QWORD *)(a2 + 8) += 11LL;
  *(_DWORD *)(a2 + 32) = v6;
  return result;
}

//----- (000000000005A860) ----------------------------------------------------
__int64 __fastcall sub_5A860(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 40LL))(v2, a2);
  return result;
}

//----- (000000000005A8C8) ----------------------------------------------------
void __fastcall sub_5A8C8(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A8D0) ----------------------------------------------------
char *__fastcall sub_5A8D0(__int64 a1, void **a2)
{
  char *v3; // x8
  unsigned __int64 v4; // x9
  size_t v5; // x8
  unsigned __int64 v6; // x9
  void *v7; // x0
  size_t v8; // x1
  char *result; // x0
  char *v10; // x8

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
  v3 = (char *)a2[1];
  v4 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v3 + 3) <= v4 )
  {
    result = (char *)*a2;
  }
  else
  {
    v5 = (size_t)(v3 + 995);
    v6 = 2 * v4;
    v7 = *a2;
    if ( v6 <= v5 )
      v8 = v5;
    else
      v8 = v6;
    a2[2] = (void *)v8;
    result = (char *)realloc(v7, v8);
    *a2 = result;
    if ( !result )
      std::terminate();
    v3 = (char *)a2[1];
  }
  v10 = &v3[(_QWORD)result];
  v10[2] = 46;
  *(_WORD *)v10 = 11822;
  a2[1] = (char *)a2[1] + 3;
  return result;
}

//----- (000000000005A968) ----------------------------------------------------
__int64 __fastcall sub_5A968(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 40LL))(*(_QWORD *)(a1 + 16));
}

//----- (000000000005A97C) ----------------------------------------------------
void __fastcall sub_5A97C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005A984) ----------------------------------------------------
_BYTE *__fastcall sub_5A984(_QWORD *a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x8
  _BYTE *v13; // x9
  _BYTE *v14; // x22
  size_t v15; // x21
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  unsigned __int64 v22; // x9
  size_t v23; // x8
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  char *v27; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 7) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v6 = (size_t)(v2 + 999);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_25;
    v2 = a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  *(_DWORD *)(v11 + 3) = 1633968749;
  *(_DWORD *)v11 = 1835101223;
  v12 = (__int64)(a2[1] + 7);
  a2[1] = (char *)v12;
  v14 = (_BYTE *)a1[6];
  v13 = (_BYTE *)a1[7];
  v15 = v13 - v14;
  if ( v13 != v14 )
  {
    v16 = (size_t)a2[2];
    v17 = v12 + v15;
    if ( v12 + v15 <= v16 )
    {
      v21 = *a2;
    }
    else
    {
      v18 = 2 * v16;
      v19 = *a2;
      if ( v18 <= v17 + 992 )
        v20 = v17 + 992;
      else
        v20 = v18;
      a2[2] = (char *)v20;
      v21 = (char *)realloc(v19, v20);
      *a2 = v21;
      if ( !v21 )
        goto LABEL_25;
      v12 = (__int64)a2[1];
    }
    memcpy(&v21[v12], v14, v15);
    v12 = (__int64)&a2[1][v15];
    a2[1] = (char *)v12;
  }
  v22 = (unsigned __int64)a2[2];
  if ( v12 + 1 <= v22 )
  {
    v27 = *a2;
    goto LABEL_24;
  }
  v23 = v12 + 993;
  v24 = 2 * v22;
  v25 = *a2;
  if ( v24 <= v23 )
    v26 = v23;
  else
    v26 = v24;
  a2[2] = (char *)v26;
  v27 = (char *)realloc(v25, v26);
  *a2 = v27;
  if ( !v27 )
LABEL_25:
    std::terminate();
  v12 = (__int64)a2[1];
LABEL_24:
  v27[v12] = 39;
  ++a2[1];
  return sub_5AAEC(a1, (__int64)a2);
}

//----- (000000000005AAE4) ----------------------------------------------------
void __fastcall sub_5AAE4(void *a1)
{
  operator delete(a1);
}

//----- (000000000005AAEC) ----------------------------------------------------
_BYTE *__fastcall sub_5AAEC(_QWORD *a1, __int64 a2)
{
  int v4; // w21
  __int64 v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 v12; // x8
  unsigned __int64 v13; // x10
  __int64 v14; // x9
  char *v15; // x0
  __int64 v16; // x21
  __int64 v17; // x22
  __int64 v18; // x8
  __int64 v19; // x23
  char v20; // w24
  __int64 v21; // x26
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x8
  char *v24; // x0
  size_t v25; // x1
  char *v26; // x0
  __int64 v27; // x8
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x8
  char *v30; // x0
  size_t v31; // x1
  char *v32; // x0
  __int64 v33; // x8
  unsigned __int64 v34; // x8
  char *v35; // x0
  size_t v36; // x1
  _BYTE *v37; // x0
  __int64 v38; // x8
  __int64 v39; // x22
  char v40; // w23
  __int64 v41; // x25
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x8
  char *v44; // x0
  size_t v45; // x1
  char *v46; // x0
  __int64 v47; // x8
  unsigned __int64 v48; // x9
  __int64 v49; // x8
  unsigned __int64 v50; // x9
  char *v51; // x0
  size_t v52; // x1
  _BYTE *result; // x0

  v4 = *(_DWORD *)(a2 + 32);
  if ( a1[3] )
  {
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 32) = 0;
    if ( v5 + 1 <= v6 )
    {
      v11 = *(char **)a2;
    }
    else
    {
      v7 = v5 + 993;
      v8 = 2 * v6;
      v9 = *(char **)a2;
      if ( v8 <= v7 )
        v10 = v7;
      else
        v10 = v8;
      *(_QWORD *)(a2 + 16) = v10;
      v11 = (char *)realloc(v9, v10);
      *(_QWORD *)a2 = v11;
      if ( !v11 )
        goto LABEL_60;
      v5 = *(_QWORD *)(a2 + 8);
    }
    v11[v5] = 60;
    v17 = *(_QWORD *)(a2 + 8) + 1LL;
    v18 = a1[3];
    *(_QWORD *)(a2 + 8) = v17;
    if ( v18 )
    {
      v19 = 0;
      v20 = 1;
      while ( 1 )
      {
        v21 = v17;
        if ( (v20 & 1) == 0 )
        {
          v22 = *(_QWORD *)(a2 + 16);
          if ( v17 + 2 <= v22 )
          {
            v26 = *(char **)a2;
            v27 = v17;
          }
          else
          {
            v23 = 2 * v22;
            v24 = *(char **)a2;
            if ( v23 <= v17 + 994 )
              v25 = v17 + 994;
            else
              v25 = v23;
            *(_QWORD *)(a2 + 16) = v25;
            v26 = (char *)realloc(v24, v25);
            *(_QWORD *)a2 = v26;
            if ( !v26 )
              goto LABEL_60;
            v27 = *(_QWORD *)(a2 + 8);
          }
          *(_WORD *)&v26[v27] = 8236;
          v21 = *(_QWORD *)(a2 + 8) + 2LL;
          *(_QWORD *)(a2 + 8) = v21;
        }
        sub_56990(*(__int64 **)(a1[2] + 8 * v19), a2, 18, 0);
        if ( v21 == *(_QWORD *)(a2 + 8) )
        {
          *(_QWORD *)(a2 + 8) = v17;
          if ( ++v19 == a1[3] )
            break;
        }
        else
        {
          v20 = 0;
          v17 = *(_QWORD *)(a2 + 8);
          if ( ++v19 == a1[3] )
            break;
        }
      }
    }
    v28 = *(_QWORD *)(a2 + 16);
    if ( v17 + 1 <= v28 )
    {
      v32 = *(char **)a2;
    }
    else
    {
      v29 = 2 * v28;
      v30 = *(char **)a2;
      if ( v29 <= v17 + 993 )
        v31 = v17 + 993;
      else
        v31 = v29;
      *(_QWORD *)(a2 + 16) = v31;
      v32 = (char *)realloc(v30, v31);
      *(_QWORD *)a2 = v32;
      if ( !v32 )
        goto LABEL_60;
      v17 = *(_QWORD *)(a2 + 8);
    }
    v32[v17] = 62;
    v33 = *(_QWORD *)(a2 + 8);
    v13 = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 32) = v4;
    v12 = v33 + 1;
    *(_QWORD *)(a2 + 8) = v12;
    v14 = v12 + 1;
    *(_DWORD *)(a2 + 32) = v4 + 1;
    if ( v12 + 1 > v13 )
      goto LABEL_34;
LABEL_9:
    v15 = *(char **)a2;
    *(_QWORD *)(a2 + 8) = v14;
    v15[v12] = 40;
    v16 = *(_QWORD *)(a2 + 8);
    if ( a1[5] )
    {
LABEL_39:
      v39 = 0;
      v40 = 1;
      while ( 1 )
      {
        v41 = v16;
        if ( (v40 & 1) == 0 )
        {
          v42 = *(_QWORD *)(a2 + 16);
          if ( v16 + 2 <= v42 )
          {
            v46 = *(char **)a2;
            v47 = v16;
          }
          else
          {
            v43 = 2 * v42;
            v44 = *(char **)a2;
            if ( v43 <= v16 + 994 )
              v45 = v16 + 994;
            else
              v45 = v43;
            *(_QWORD *)(a2 + 16) = v45;
            v46 = (char *)realloc(v44, v45);
            *(_QWORD *)a2 = v46;
            if ( !v46 )
              goto LABEL_60;
            v47 = *(_QWORD *)(a2 + 8);
          }
          *(_WORD *)&v46[v47] = 8236;
          v41 = *(_QWORD *)(a2 + 8) + 2LL;
          *(_QWORD *)(a2 + 8) = v41;
        }
        sub_56990(*(__int64 **)(a1[4] + 8 * v39), a2, 18, 0);
        if ( v41 == *(_QWORD *)(a2 + 8) )
        {
          *(_QWORD *)(a2 + 8) = v16;
          if ( ++v39 == a1[5] )
            goto LABEL_52;
        }
        else
        {
          v40 = 0;
          v16 = *(_QWORD *)(a2 + 8);
          if ( ++v39 == a1[5] )
            goto LABEL_52;
        }
      }
    }
    goto LABEL_52;
  }
  v12 = *(_QWORD *)(a2 + 8);
  v13 = *(_QWORD *)(a2 + 16);
  v14 = v12 + 1;
  *(_DWORD *)(a2 + 32) = v4 + 1;
  if ( v12 + 1 <= v13 )
    goto LABEL_9;
LABEL_34:
  v34 = v12 + 993;
  v35 = *(char **)a2;
  if ( 2 * v13 <= v34 )
    v36 = v34;
  else
    v36 = 2 * v13;
  *(_QWORD *)(a2 + 16) = v36;
  v37 = realloc(v35, v36);
  *(_QWORD *)a2 = v37;
  if ( !v37 )
    goto LABEL_60;
  v38 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v38 + 1;
  v37[v38] = 40;
  v16 = *(_QWORD *)(a2 + 8);
  if ( a1[5] )
    goto LABEL_39;
LABEL_52:
  v48 = *(_QWORD *)(a2 + 16);
  v49 = v16 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v16 + 1 <= v48 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_59;
  }
  v50 = 2 * v48;
  v51 = *(char **)a2;
  if ( v50 <= v16 + 993 )
    v52 = v16 + 993;
  else
    v52 = v50;
  *(_QWORD *)(a2 + 16) = v52;
  result = realloc(v51, v52);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_60:
    std::terminate();
  v16 = *(_QWORD *)(a2 + 8);
  v49 = v16 + 1;
LABEL_59:
  *(_QWORD *)(a2 + 8) = v49;
  result[v16] = 41;
  return result;
}

//----- (000000000005AE60) ----------------------------------------------------
char *__fastcall sub_5AE60(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x0
  int v12; // w9
  __int64 v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  void *v17; // x0
  size_t v18; // x1
  char *result; // x0
  char *v20; // x8

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 2) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 994);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_18;
    v2 = (char *)a2[1];
  }
  *(_WORD *)&v2[(_QWORD)v10] = 23899;
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(unsigned __int8 *)(v11 + 8);
  v13 = (__int64)a2[1] + 2;
  a2[1] = (void *)v13;
  if ( v12 == 48 )
  {
    sub_5AAEC((_QWORD *)v11, (__int64)a2);
    v13 = (__int64)a2[1];
  }
  v14 = (unsigned __int64)a2[2];
  if ( v13 + 5 <= v14 )
  {
    result = (char *)*a2;
    goto LABEL_17;
  }
  v15 = v13 + 997;
  v16 = 2 * v14;
  v17 = *a2;
  if ( v16 <= v15 )
    v18 = v15;
  else
    v18 = v16;
  a2[2] = (void *)v18;
  result = (char *)realloc(v17, v18);
  *a2 = result;
  if ( !result )
LABEL_18:
    std::terminate();
  v13 = (__int64)a2[1];
LABEL_17:
  v20 = &result[v13];
  v20[4] = 125;
  *(_DWORD *)v20 = 774778491;
  a2[1] = (char *)a2[1] + 5;
  return result;
}

//----- (000000000005AF60) ----------------------------------------------------
void __fastcall sub_5AF60(void *a1)
{
  operator delete(a1);
}

//----- (000000000005AF68) ----------------------------------------------------
char *__fastcall sub_5AF68(_QWORD *a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x10
  char *v6; // x9
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x21
  char *v12; // x8
  unsigned __int64 v13; // x10
  char *v14; // x9
  unsigned __int64 v15; // x8
  char *v16; // x0
  size_t v17; // x1
  char *result; // x0
  _BYTE *v19; // x21
  char *v20; // x8
  unsigned __int64 v21; // x9
  size_t v22; // x8
  unsigned __int64 v23; // x9
  char *v24; // x0
  size_t v25; // x1
  _BYTE *v26; // x8
  size_t v27; // x20
  __int64 v28; // x8
  size_t v29; // x9
  size_t v30; // x10
  char *v31; // x0
  _BYTE *v32; // x9
  _BYTE *v33; // x10
  unsigned __int64 v34; // x9
  char *v35; // x0
  size_t v36; // x1

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  v6 = v2 + 1;
  ++*((_DWORD *)a2 + 8);
  if ( (unsigned __int64)(v2 + 1) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v7 = (unsigned __int64)(v2 + 993);
    v8 = *a2;
    if ( 2 * v3 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v3;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_40;
    v2 = a2[1];
    v6 = v2 + 1;
  }
  a2[1] = v6;
  v2[(_QWORD)v10] = 40;
  v11 = a1[2];
  (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v11 + 32LL))(v11, a2);
  if ( (*(_WORD *)(v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v11 + 40LL))(v11, a2);
  v12 = a2[1];
  v13 = (unsigned __int64)a2[2];
  v14 = v12 + 1;
  --*((_DWORD *)a2 + 8);
  if ( (unsigned __int64)(v12 + 1) <= v13 )
  {
    result = *a2;
  }
  else
  {
    v15 = (unsigned __int64)(v12 + 993);
    v16 = *a2;
    if ( 2 * v13 <= v15 )
      v17 = v15;
    else
      v17 = 2 * v13;
    a2[2] = (char *)v17;
    result = (char *)realloc(v16, v17);
    *a2 = result;
    if ( !result )
      goto LABEL_40;
    v12 = a2[1];
    v14 = v12 + 1;
  }
  a2[1] = v14;
  v12[(_QWORD)result] = 41;
  v19 = (_BYTE *)a1[3];
  if ( *v19 != 110 )
  {
    v26 = (_BYTE *)a1[4];
    v27 = v26 - v19;
    if ( v26 == v19 )
      return result;
    v28 = (__int64)a2[1];
    v29 = (size_t)a2[2];
    v30 = v28 + v27;
    if ( v28 + v27 > v29 )
    {
LABEL_33:
      v34 = 2 * v29;
      v35 = *a2;
      if ( v34 <= v30 + 992 )
        v36 = v30 + 992;
      else
        v36 = v34;
      a2[2] = (char *)v36;
      v31 = (char *)realloc(v35, v36);
      *a2 = v31;
      if ( v31 )
      {
        v28 = (__int64)a2[1];
        goto LABEL_38;
      }
LABEL_40:
      std::terminate();
    }
LABEL_26:
    v31 = *a2;
LABEL_38:
    result = (char *)memcpy(&v31[v28], v19, v27);
    a2[1] += v27;
    return result;
  }
  v20 = a2[1];
  v21 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v20 + 1) <= v21 )
  {
    result = *a2;
  }
  else
  {
    v22 = (size_t)(v20 + 993);
    v23 = 2 * v21;
    v24 = *a2;
    if ( v23 <= v22 )
      v25 = v22;
    else
      v25 = v23;
    a2[2] = (char *)v25;
    result = (char *)realloc(v24, v25);
    *a2 = result;
    if ( !result )
      goto LABEL_40;
    v20 = a2[1];
  }
  v20[(_QWORD)result] = 45;
  v32 = (_BYTE *)a1[3];
  v33 = (_BYTE *)a1[4];
  v28 = (__int64)(a2[1] + 1);
  if ( v33 == v32 )
    v19 = (_BYTE *)a1[3];
  else
    v19 = v32 + 1;
  v27 = v33 - v19;
  a2[1] = (char *)v28;
  if ( v33 != v19 )
  {
    v29 = (size_t)a2[2];
    v30 = v28 + v27;
    if ( v28 + v27 > v29 )
      goto LABEL_33;
    goto LABEL_26;
  }
  return result;
}

//----- (000000000005B180) ----------------------------------------------------
void __fastcall sub_5B180(void *a1)
{
  operator delete(a1);
}

//----- (000000000005B188) ----------------------------------------------------
_OWORD *__fastcall sub_5B188(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _OWORD *v8; // x9
  __int128 v9; // q0
  _OWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_OWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  v9 = *a2;
  *((_BYTE *)v8 - 8) = 63;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *((_QWORD *)v8 - 2) = off_70CA8;
  result = v8 - 1;
  *v8 = v9;
  return result;
}
// 70CA8: using guessed type __int64 (__fastcall *off_70CA8[10])();

//----- (000000000005B22C) ----------------------------------------------------
char *__fastcall sub_5B22C(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *result; // x0
  __int64 v11; // x8
  _BYTE *v12; // x9
  _BYTE *v13; // x21
  size_t v14; // x20
  size_t v15; // x9
  size_t v16; // x10
  unsigned __int64 v17; // x9
  void *v18; // x0
  size_t v19; // x1
  char *v20; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 2) <= v3 )
  {
    result = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 994);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    result = (char *)realloc(v8, v9);
    *a2 = result;
    if ( !result )
      goto LABEL_18;
    v2 = (char *)a2[1];
  }
  *(_WORD *)&v2[(_QWORD)result] = 28774;
  v11 = (__int64)a2[1] + 2;
  a2[1] = (void *)v11;
  v13 = *(_BYTE **)(a1 + 16);
  v12 = *(_BYTE **)(a1 + 24);
  v14 = v12 - v13;
  if ( v12 == v13 )
    return result;
  v15 = (size_t)a2[2];
  v16 = v11 + v14;
  if ( v11 + v14 <= v15 )
  {
    v20 = (char *)*a2;
    goto LABEL_16;
  }
  v17 = 2 * v15;
  v18 = *a2;
  if ( v17 <= v16 + 992 )
    v19 = v16 + 992;
  else
    v19 = v17;
  a2[2] = (void *)v19;
  v20 = (char *)realloc(v18, v19);
  *a2 = v20;
  if ( !v20 )
LABEL_18:
    std::terminate();
  v11 = (__int64)a2[1];
LABEL_16:
  result = (char *)memcpy(&v20[v11], v13, v14);
  a2[1] = (char *)a2[1] + v14;
  return result;
}

//----- (000000000005B31C) ----------------------------------------------------
void sub_5B31C()
{
  ;
}

//----- (000000000005B324) ----------------------------------------------------
void __fastcall sub_5B324(void *a1)
{
  operator delete(a1);
}

//----- (000000000005B32C) ----------------------------------------------------
_BYTE *__fastcall sub_5B32C(__int64 a1, __int64 a2)
{
  int v2; // w9
  unsigned __int64 v3; // x10
  __int64 v6; // x8
  __int64 *v7; // x23
  unsigned __int64 v8; // x8
  char *v9; // x0
  size_t v10; // x1
  _BYTE *v11; // x0
  __int64 v12; // x8
  int v13; // w8
  __int64 *v14; // x0
  char *v15; // x0
  __int64 v16; // x8
  unsigned __int64 v17; // x9
  size_t v18; // x8
  unsigned __int64 v19; // x9
  char *v20; // x0
  size_t v21; // x1
  char *v22; // x0
  __int64 v23; // x8
  unsigned __int64 v24; // x9
  size_t v25; // x8
  unsigned __int64 v26; // x9
  char *v27; // x0
  size_t v28; // x1
  char *v29; // x0
  __int64 v30; // x8
  _BYTE *v31; // x9
  _BYTE *v32; // x22
  size_t v33; // x21
  size_t v34; // x9
  size_t v35; // x10
  unsigned __int64 v36; // x9
  char *v37; // x0
  size_t v38; // x1
  char *v39; // x0
  unsigned __int64 v40; // x9
  size_t v41; // x8
  unsigned __int64 v42; // x9
  char *v43; // x0
  size_t v44; // x1
  _BYTE *v45; // x0
  char *v46; // x8
  __int64 v47; // x9
  __int64 v48; // x8
  unsigned __int64 v49; // x10
  char *v50; // x0
  size_t v51; // x1
  _BYTE *v52; // x0
  __int64 v53; // x8
  _BYTE *v54; // x9
  _BYTE *v55; // x22
  size_t v56; // x21
  size_t v57; // x9
  size_t v58; // x10
  unsigned __int64 v59; // x9
  char *v60; // x0
  size_t v61; // x1
  char *v62; // x0
  unsigned __int64 v63; // x9
  size_t v64; // x8
  unsigned __int64 v65; // x9
  char *v66; // x0
  size_t v67; // x1
  _BYTE *v68; // x0
  __int64 v69; // x8
  unsigned __int64 v70; // x10
  __int64 v71; // x9
  unsigned __int64 v72; // x8
  char *v73; // x0
  size_t v74; // x1
  _BYTE *result; // x0
  char **v76[2]; // [xsp+0h] [xbp-10h] BYREF

  v2 = *(_DWORD *)(a2 + 32);
  v3 = *(_QWORD *)(a2 + 16);
  v76[0] = (char **)a2;
  v76[1] = (char **)a1;
  v7 = (__int64 *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 32) = v2 + 1;
  if ( v6 + 1 <= v3 )
  {
    v15 = *(char **)a2;
    *v7 = v6 + 1;
    v15[v6] = 40;
    v13 = *(unsigned __int8 *)(a1 + 48);
    v14 = *(__int64 **)(a1 + 24);
    if ( !*(_BYTE *)(a1 + 48) )
      goto LABEL_16;
  }
  else
  {
    v8 = v6 + 993;
    v9 = *(char **)a2;
    if ( 2 * v3 <= v8 )
      v10 = v8;
    else
      v10 = 2 * v3;
    *(_QWORD *)(a2 + 16) = v10;
    v11 = realloc(v9, v10);
    *(_QWORD *)a2 = v11;
    if ( !v11 )
      goto LABEL_79;
    v12 = (*v7)++;
    v11[v12] = 40;
    v13 = *(unsigned __int8 *)(a1 + 48);
    v14 = *(__int64 **)(a1 + 24);
    if ( !*(_BYTE *)(a1 + 48) )
    {
LABEL_16:
      if ( v13 )
      {
        sub_56990(v14, a2, 3, 1);
        v23 = *(_QWORD *)(a2 + 8);
        v24 = *(_QWORD *)(a2 + 16);
        if ( v23 + 1 > v24 )
        {
LABEL_18:
          v25 = v23 + 993;
          v26 = 2 * v24;
          v27 = *(char **)a2;
          if ( v26 <= v25 )
            v28 = v25;
          else
            v28 = v26;
          *(_QWORD *)(a2 + 16) = v28;
          v29 = (char *)realloc(v27, v28);
          *(_QWORD *)a2 = v29;
          if ( !v29 )
            goto LABEL_79;
          v23 = *v7;
LABEL_25:
          v29[v23] = 32;
          v30 = *v7 + 1;
          *v7 = v30;
          v32 = *(_BYTE **)(a1 + 32);
          v31 = *(_BYTE **)(a1 + 40);
          v33 = v31 - v32;
          if ( v31 != v32 )
          {
            v34 = *(_QWORD *)(a2 + 16);
            v35 = v30 + v33;
            if ( v30 + v33 <= v34 )
            {
              v39 = *(char **)a2;
            }
            else
            {
              v36 = 2 * v34;
              v37 = *(char **)a2;
              if ( v36 <= v35 + 992 )
                v38 = v35 + 992;
              else
                v38 = v36;
              *(_QWORD *)(a2 + 16) = v38;
              v39 = (char *)realloc(v37, v38);
              *(_QWORD *)a2 = v39;
              if ( !v39 )
                goto LABEL_79;
              v30 = *v7;
            }
            memcpy(&v39[v30], v32, v33);
            v30 = *v7 + v33;
            *v7 = v30;
          }
          v40 = *(_QWORD *)(a2 + 16);
          if ( v30 + 1 <= v40 )
          {
            v45 = *(_BYTE **)a2;
          }
          else
          {
            v41 = v30 + 993;
            v42 = 2 * v40;
            v43 = *(char **)a2;
            if ( v42 <= v41 )
              v44 = v41;
            else
              v44 = v42;
            *(_QWORD *)(a2 + 16) = v44;
            v45 = realloc(v43, v44);
            *(_QWORD *)a2 = v45;
            if ( !v45 )
              goto LABEL_79;
            v30 = *v7;
          }
          v45[v30] = 32;
          v16 = *v7 + 1;
          *v7 = v16;
          v17 = *(_QWORD *)(a2 + 16);
          if ( v16 + 3 <= v17 )
            goto LABEL_42;
          goto LABEL_11;
        }
      }
      else
      {
        sub_5B75C(v76);
        v23 = *(_QWORD *)(a2 + 8);
        v24 = *(_QWORD *)(a2 + 16);
        if ( v23 + 1 > v24 )
          goto LABEL_18;
      }
      v29 = *(char **)a2;
      goto LABEL_25;
    }
  }
  if ( v14 )
    goto LABEL_16;
  v16 = *v7;
  v17 = *(_QWORD *)(a2 + 16);
  if ( *v7 + 3 <= v17 )
  {
LABEL_42:
    v22 = *(char **)a2;
    goto LABEL_43;
  }
LABEL_11:
  v18 = v16 + 995;
  v19 = 2 * v17;
  v20 = *(char **)a2;
  if ( v19 <= v18 )
    v21 = v18;
  else
    v21 = v19;
  *(_QWORD *)(a2 + 16) = v21;
  v22 = (char *)realloc(v20, v21);
  *(_QWORD *)a2 = v22;
  if ( !v22 )
    goto LABEL_79;
  v16 = *v7;
LABEL_43:
  v46 = &v22[v16];
  v46[2] = 46;
  *(_WORD *)v46 = 11822;
  v47 = *v7;
  v48 = *v7 + 3;
  *v7 = v48;
  if ( *(_BYTE *)(a1 + 48) || *(_QWORD *)(a1 + 24) )
  {
    v49 = *(_QWORD *)(a2 + 16);
    if ( v47 + 4 <= v49 )
    {
      v52 = *(_BYTE **)a2;
    }
    else
    {
      v50 = *(char **)a2;
      if ( 2 * v49 <= v47 + 996 )
        v51 = v47 + 996;
      else
        v51 = 2 * v49;
      *(_QWORD *)(a2 + 16) = v51;
      v52 = realloc(v50, v51);
      *(_QWORD *)a2 = v52;
      if ( !v52 )
        goto LABEL_79;
      v48 = *v7;
    }
    v52[v48] = 32;
    v53 = *v7 + 1;
    *v7 = v53;
    v55 = *(_BYTE **)(a1 + 32);
    v54 = *(_BYTE **)(a1 + 40);
    v56 = v54 - v55;
    if ( v54 != v55 )
    {
      v57 = *(_QWORD *)(a2 + 16);
      v58 = v53 + v56;
      if ( v53 + v56 <= v57 )
      {
        v62 = *(char **)a2;
      }
      else
      {
        v59 = 2 * v57;
        v60 = *(char **)a2;
        if ( v59 <= v58 + 992 )
          v61 = v58 + 992;
        else
          v61 = v59;
        *(_QWORD *)(a2 + 16) = v61;
        v62 = (char *)realloc(v60, v61);
        *(_QWORD *)a2 = v62;
        if ( !v62 )
          goto LABEL_79;
        v53 = *v7;
      }
      memcpy(&v62[v53], v55, v56);
      v53 = *v7 + v56;
      *v7 = v53;
    }
    v63 = *(_QWORD *)(a2 + 16);
    if ( v53 + 1 <= v63 )
    {
      v68 = *(_BYTE **)a2;
    }
    else
    {
      v64 = v53 + 993;
      v65 = 2 * v63;
      v66 = *(char **)a2;
      if ( v65 <= v64 )
        v67 = v64;
      else
        v67 = v65;
      *(_QWORD *)(a2 + 16) = v67;
      v68 = realloc(v66, v67);
      *(_QWORD *)a2 = v68;
      if ( !v68 )
        goto LABEL_79;
      v53 = *v7;
    }
    v68[v53] = 32;
    ++*v7;
    if ( *(_BYTE *)(a1 + 48) )
      sub_5B75C(v76);
    else
      sub_56990(*(__int64 **)(a1 + 24), a2, 3, 1);
  }
  v69 = *(_QWORD *)(a2 + 8);
  v70 = *(_QWORD *)(a2 + 16);
  v71 = v69 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v69 + 1 <= v70 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_78;
  }
  v72 = v69 + 993;
  v73 = *(char **)a2;
  if ( 2 * v70 <= v72 )
    v74 = v72;
  else
    v74 = 2 * v70;
  *(_QWORD *)(a2 + 16) = v74;
  result = realloc(v73, v74);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_79:
    std::terminate();
  v69 = *v7;
  v71 = *v7 + 1;
LABEL_78:
  *v7 = v71;
  result[v69] = 41;
  return result;
}

//----- (000000000005B754) ----------------------------------------------------
void __fastcall sub_5B754(void *a1)
{
  operator delete(a1);
}

//----- (000000000005B75C) ----------------------------------------------------
char *__fastcall sub_5B75C(char ***a1)
{
  char **v1; // x20
  char **v2; // x21
  char *v4; // x8
  unsigned __int64 v5; // x10
  char *v6; // x9
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int16 v11; // w9
  __int16 v12; // w8
  char *v13; // x9
  char **v14; // x1
  char **v15; // x19
  char *v16; // x8
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x8
  char *v20; // x0
  size_t v21; // x1
  char *result; // x0
  __int64 (__fastcall **v23)(); // [xsp+8h] [xbp-18h] BYREF
  char v24; // [xsp+10h] [xbp-10h]
  __int16 v25; // [xsp+11h] [xbp-Fh]
  char *v26; // [xsp+18h] [xbp-8h]

  v2 = *a1;
  v1 = a1[1];
  v4 = (*a1)[1];
  v5 = (unsigned __int64)(*a1)[2];
  v6 = v4 + 1;
  ++*((_DWORD *)*a1 + 8);
  if ( (unsigned __int64)(v4 + 1) <= v5 )
  {
    v10 = *v2;
  }
  else
  {
    v7 = (unsigned __int64)(v4 + 993);
    v8 = *v2;
    if ( 2 * v5 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v5;
    v2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *v2 = v10;
    if ( !v10 )
      goto LABEL_16;
    v4 = v2[1];
    v6 = v4 + 1;
  }
  v2[1] = v6;
  v11 = v25 & 0xF000;
  v4[(_QWORD)v10] = 40;
  v12 = v11 | 0x540;
  v13 = v1[2];
  v14 = *a1;
  v23 = off_70D88;
  v24 = 38;
  v25 = v12;
  v26 = v13;
  sub_5B890((__int64)&v23, v14);
  v15 = *a1;
  v16 = v15[1];
  v17 = (unsigned __int64)v15[2];
  v18 = v16 + 1;
  --*((_DWORD *)v15 + 8);
  if ( (unsigned __int64)(v16 + 1) <= v17 )
  {
    result = *v15;
    goto LABEL_15;
  }
  v19 = (unsigned __int64)(v16 + 993);
  v20 = *v15;
  if ( 2 * v17 <= v19 )
    v21 = v19;
  else
    v21 = 2 * v17;
  v15[2] = (char *)v21;
  result = (char *)realloc(v20, v21);
  *v15 = result;
  if ( !result )
LABEL_16:
    std::terminate();
  v16 = v15[1];
  v18 = v16 + 1;
LABEL_15:
  v15[1] = v18;
  v16[(_QWORD)result] = 41;
  return result;
}
// 70D88: using guessed type __int64 (__fastcall *off_70D88[10])();

//----- (000000000005B890) ----------------------------------------------------
__int64 __fastcall sub_5B890(__int64 a1, char **a2)
{
  __int64 *v2; // x21
  int v5; // w22
  int v6; // w23
  __int64 v7; // x8
  __int64 v8; // x25
  __int64 result; // x0
  unsigned int v10; // w24
  int i; // w25
  char *v12; // x8
  unsigned __int64 v13; // x9
  size_t v14; // x8
  unsigned __int64 v15; // x9
  char *v16; // x0
  size_t v17; // x1
  char *v18; // x0
  char *v19; // x8
  __int64 *v20; // x21
  __int64 v21; // x9
  char *v22; // x8
  unsigned __int64 v23; // x9
  size_t v24; // x8
  unsigned __int64 v25; // x9
  char *v26; // x0
  size_t v27; // x1
  char *v28; // x8

  v2 = *(__int64 **)(a1 + 16);
  v5 = *((_DWORD *)a2 + 6);
  v6 = *((_DWORD *)a2 + 7);
  v7 = *v2;
  v8 = (__int64)a2[1];
  a2[3] = (char *)-1LL;
  result = (*(__int64 (__fastcall **)(__int64 *))(v7 + 32))(v2);
  if ( (*(_WORD *)((_BYTE *)v2 + 9) & 0xC0) != 0x40 )
    result = (*(__int64 (__fastcall **)(__int64 *, char **))(*v2 + 40))(v2, a2);
  v10 = *((_DWORD *)a2 + 7);
  if ( v10 == -1 )
  {
    v22 = a2[1];
    v23 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v22 + 3) <= v23 )
    {
      result = (__int64)*a2;
    }
    else
    {
      v24 = (size_t)(v22 + 995);
      v25 = 2 * v23;
      v26 = *a2;
      if ( v25 <= v24 )
        v27 = v24;
      else
        v27 = v25;
      a2[2] = (char *)v27;
      result = (__int64)realloc(v26, v27);
      *a2 = (char *)result;
      if ( !result )
LABEL_27:
        std::terminate();
      v22 = a2[1];
    }
    v28 = &v22[result];
    v28[2] = 46;
    *(_WORD *)v28 = 11822;
    v8 = (__int64)(a2[1] + 3);
    goto LABEL_25;
  }
  if ( !v10 )
  {
LABEL_25:
    a2[1] = (char *)v8;
    goto LABEL_26;
  }
  if ( v10 >= 2 )
  {
    for ( i = 1; i != v10; ++i )
    {
      v12 = a2[1];
      v13 = (unsigned __int64)a2[2];
      if ( (unsigned __int64)(v12 + 2) <= v13 )
      {
        v18 = *a2;
      }
      else
      {
        v14 = (size_t)(v12 + 994);
        v15 = 2 * v13;
        v16 = *a2;
        if ( v15 <= v14 )
          v17 = v14;
        else
          v17 = v15;
        a2[2] = (char *)v17;
        v18 = (char *)realloc(v16, v17);
        *a2 = v18;
        if ( !v18 )
          goto LABEL_27;
        v12 = a2[1];
      }
      *(_WORD *)&v12[(_QWORD)v18] = 8236;
      v19 = a2[1];
      *((_DWORD *)a2 + 6) = i;
      v20 = *(__int64 **)(a1 + 16);
      v21 = *v20;
      a2[1] = v19 + 2;
      result = (*(__int64 (__fastcall **)(__int64 *, char **))(v21 + 32))(v20, a2);
      if ( (*(_WORD *)((_BYTE *)v20 + 9) & 0xC0) != 0x40 )
        result = (*(__int64 (__fastcall **)(__int64 *, char **))(*v20 + 40))(v20, a2);
    }
  }
LABEL_26:
  *((_DWORD *)a2 + 6) = v5;
  *((_DWORD *)a2 + 7) = v6;
  return result;
}

//----- (000000000005BA50) ----------------------------------------------------
void __fastcall sub_5BA50(void *a1)
{
  operator delete(a1);
}

//----- (000000000005BA58) ----------------------------------------------------
__int64 __fastcall sub_5BA58(__int64 a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x10
  char *v6; // x9
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  unsigned __int64 v10; // x8
  char *v11; // x0
  size_t v12; // x1
  char *v13; // x0
  __int64 v14; // x21
  char *v15; // x8
  unsigned __int64 v16; // x10
  char *v17; // x9
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  char *v22; // x0
  __int64 v23; // x21
  __int64 v24; // x21
  char *v25; // x8
  unsigned __int64 v26; // x9
  size_t v27; // x8
  unsigned __int64 v28; // x9
  char *v29; // x0
  size_t v30; // x1
  char *v31; // x0
  char *v32; // x8
  __int64 result; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  v6 = v2 + 1;
  if ( *(_BYTE *)(a1 + 32) )
  {
    if ( (unsigned __int64)(v2 + 1) > v3 )
    {
      v7 = (unsigned __int64)(v2 + 993);
      v8 = *a2;
      if ( 2 * v3 <= v7 )
        v9 = v7;
      else
        v9 = 2 * v3;
      a2[2] = (char *)v9;
      v13 = (char *)realloc(v8, v9);
      *a2 = v13;
      if ( !v13 )
        goto LABEL_39;
      v2 = a2[1];
      v6 = v2 + 1;
    }
    else
    {
      v13 = *a2;
    }
    a2[1] = v6;
    v2[(_QWORD)v13] = 91;
    v14 = *(_QWORD *)(a1 + 16);
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v14 + 32LL))(v14, a2);
    if ( (*(_WORD *)(v14 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v14 + 40LL))(v14, a2);
    v15 = a2[1];
    v16 = (unsigned __int64)a2[2];
    v17 = v15 + 1;
    if ( (unsigned __int64)(v15 + 1) <= v16 )
    {
      v21 = *a2;
    }
    else
    {
      v18 = (unsigned __int64)(v15 + 993);
      v19 = *a2;
      if ( 2 * v16 <= v18 )
        v20 = v18;
      else
        v20 = 2 * v16;
      a2[2] = (char *)v20;
      v21 = (char *)realloc(v19, v20);
      *a2 = v21;
      if ( !v21 )
        goto LABEL_39;
      v15 = a2[1];
      v17 = v15 + 1;
    }
    a2[1] = v17;
    v15[(_QWORD)v21] = 93;
  }
  else
  {
    if ( (unsigned __int64)(v2 + 1) > v3 )
    {
      v10 = (unsigned __int64)(v2 + 993);
      v11 = *a2;
      if ( 2 * v3 <= v10 )
        v12 = v10;
      else
        v12 = 2 * v3;
      a2[2] = (char *)v12;
      v22 = (char *)realloc(v11, v12);
      *a2 = v22;
      if ( !v22 )
        goto LABEL_39;
      v2 = a2[1];
      v6 = v2 + 1;
    }
    else
    {
      v22 = *a2;
    }
    a2[1] = v6;
    v2[(_QWORD)v22] = 46;
    v23 = *(_QWORD *)(a1 + 16);
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v23 + 32LL))(v23, a2);
    if ( (*(_WORD *)(v23 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v23 + 40LL))(v23, a2);
  }
  v24 = *(_QWORD *)(a1 + 24);
  if ( (unsigned int)*(unsigned __int8 *)(v24 + 8) - 77 < 2 )
    goto LABEL_37;
  v25 = a2[1];
  v26 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v25 + 3) <= v26 )
  {
    v31 = *a2;
    goto LABEL_36;
  }
  v27 = (size_t)(v25 + 995);
  v28 = 2 * v26;
  v29 = *a2;
  if ( v28 <= v27 )
    v30 = v27;
  else
    v30 = v28;
  a2[2] = (char *)v30;
  v31 = (char *)realloc(v29, v30);
  *a2 = v31;
  if ( !v31 )
LABEL_39:
    std::terminate();
  v25 = a2[1];
LABEL_36:
  v32 = &v25[(_QWORD)v31];
  v32[2] = 32;
  *(_WORD *)v32 = 15648;
  v24 = *(_QWORD *)(a1 + 24);
  a2[1] += 3;
LABEL_37:
  result = (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v24 + 32LL))(v24, a2);
  if ( (*(_WORD *)(v24 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v24 + 40LL))(v24, a2);
  return result;
}

//----- (000000000005BCB4) ----------------------------------------------------
void __fastcall sub_5BCB4(void *a1)
{
  operator delete(a1);
}

//----- (000000000005BCBC) ----------------------------------------------------
__int64 __fastcall sub_5BCBC(_QWORD *a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x10
  char *v6; // x9
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x21
  char *v12; // x8
  unsigned __int64 v13; // x9
  size_t v14; // x8
  unsigned __int64 v15; // x9
  char *v16; // x0
  size_t v17; // x1
  char *v18; // x0
  char *v19; // x8
  __int64 *v20; // x21
  __int64 v21; // x9
  char *v22; // x8
  unsigned __int64 v23; // x10
  char *v24; // x9
  unsigned __int64 v25; // x8
  char *v26; // x0
  size_t v27; // x1
  char *v28; // x0
  __int64 v29; // x21
  char *v30; // x8
  unsigned __int64 v31; // x9
  size_t v32; // x8
  unsigned __int64 v33; // x9
  char *v34; // x0
  size_t v35; // x1
  char *v36; // x0
  char *v37; // x8
  __int64 result; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  v6 = v2 + 1;
  if ( (unsigned __int64)(v2 + 1) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v7 = (unsigned __int64)(v2 + 993);
    v8 = *a2;
    if ( 2 * v3 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v3;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_37;
    v2 = a2[1];
    v6 = v2 + 1;
  }
  a2[1] = v6;
  v2[(_QWORD)v10] = 91;
  v11 = a1[2];
  (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v11 + 32LL))(v11, a2);
  if ( (*(_WORD *)(v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v11 + 40LL))(v11, a2);
  v12 = a2[1];
  v13 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v12 + 5) <= v13 )
  {
    v18 = *a2;
  }
  else
  {
    v14 = (size_t)(v12 + 997);
    v15 = 2 * v13;
    v16 = *a2;
    if ( v15 <= v14 )
      v17 = v14;
    else
      v17 = v15;
    a2[2] = (char *)v17;
    v18 = (char *)realloc(v16, v17);
    *a2 = v18;
    if ( !v18 )
      goto LABEL_37;
    v12 = a2[1];
  }
  v19 = &v12[(_QWORD)v18];
  v19[4] = 32;
  *(_DWORD *)v19 = 774778400;
  v20 = (__int64 *)a1[3];
  v21 = *v20;
  a2[1] += 5;
  (*(void (__fastcall **)(__int64 *, char **))(v21 + 32))(v20, a2);
  if ( (*(_WORD *)((_BYTE *)v20 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, char **))(*v20 + 40))(v20, a2);
  v22 = a2[1];
  v23 = (unsigned __int64)a2[2];
  v24 = v22 + 1;
  if ( (unsigned __int64)(v22 + 1) <= v23 )
  {
    v28 = *a2;
  }
  else
  {
    v25 = (unsigned __int64)(v22 + 993);
    v26 = *a2;
    if ( 2 * v23 <= v25 )
      v27 = v25;
    else
      v27 = 2 * v23;
    a2[2] = (char *)v27;
    v28 = (char *)realloc(v26, v27);
    *a2 = v28;
    if ( !v28 )
      goto LABEL_37;
    v22 = a2[1];
    v24 = v22 + 1;
  }
  a2[1] = v24;
  v22[(_QWORD)v28] = 93;
  v29 = a1[4];
  if ( (unsigned int)*(unsigned __int8 *)(v29 + 8) - 77 < 2 )
    goto LABEL_35;
  v30 = a2[1];
  v31 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v30 + 3) <= v31 )
  {
    v36 = *a2;
    goto LABEL_34;
  }
  v32 = (size_t)(v30 + 995);
  v33 = 2 * v31;
  v34 = *a2;
  if ( v33 <= v32 )
    v35 = v32;
  else
    v35 = v33;
  a2[2] = (char *)v35;
  v36 = (char *)realloc(v34, v35);
  *a2 = v36;
  if ( !v36 )
LABEL_37:
    std::terminate();
  v30 = a2[1];
LABEL_34:
  v37 = &v30[(_QWORD)v36];
  v37[2] = 32;
  *(_WORD *)v37 = 15648;
  v29 = a1[4];
  a2[1] += 3;
LABEL_35:
  result = (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v29 + 32LL))(v29, a2);
  if ( (*(_WORD *)(v29 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v29 + 40LL))(v29, a2);
  return result;
}

//----- (000000000005BF2C) ----------------------------------------------------
void __fastcall sub_5BF2C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005BF34) ----------------------------------------------------
_BYTE *__fastcall sub_5BF34(_QWORD *a1, void **a2)
{
  __int64 v3; // x21
  char *v5; // x8
  unsigned __int64 v6; // x10
  unsigned __int64 v7; // x8
  void *v8; // x0
  size_t v9; // x1
  void *v10; // x0
  char *v11; // x8
  __int64 v12; // x21
  void *v13; // x0
  __int64 v14; // x22
  char v15; // w23
  __int64 v16; // x25
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  void *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  void *v24; // x8
  unsigned __int64 v25; // x9
  void *v26; // x0
  size_t v27; // x1
  _BYTE *result; // x0

  v3 = a1[2];
  if ( v3 )
  {
    (*(void (__fastcall **)(_QWORD, void **))(*(_QWORD *)v3 + 32LL))(a1[2], a2);
    if ( (*(_WORD *)(v3 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v3 + 40LL))(v3, a2);
  }
  v5 = (char *)a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 1) > v6 )
  {
    v7 = (unsigned __int64)(v5 + 993);
    v8 = *a2;
    if ( 2 * v6 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v6;
    a2[2] = (void *)v9;
    v10 = realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_33;
    v11 = (char *)a2[1];
    a2[1] = v11 + 1;
    v11[(_QWORD)v10] = 123;
    v12 = (__int64)a2[1];
    if ( !a1[4] )
      goto LABEL_25;
LABEL_12:
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = (unsigned __int64)a2[2];
        if ( v12 + 2 <= v17 )
        {
          v21 = (char *)*a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          a2[2] = (void *)v20;
          v21 = (char *)realloc(v19, v20);
          *a2 = v21;
          if ( !v21 )
            goto LABEL_33;
          v22 = (__int64)a2[1];
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = (__int64)a2[1] + 2;
        a2[1] = (void *)v16;
      }
      sub_56990(*(__int64 **)(a1[3] + 8 * v14), (__int64)a2, 18, 0);
      if ( (void *)v16 == a2[1] )
      {
        a2[1] = (void *)v12;
        if ( ++v14 == a1[4] )
          goto LABEL_25;
      }
      else
      {
        v15 = 0;
        v12 = (__int64)a2[1];
        if ( ++v14 == a1[4] )
          goto LABEL_25;
      }
    }
  }
  v13 = *a2;
  a2[1] = v5 + 1;
  v5[(_QWORD)v13] = 123;
  v12 = (__int64)a2[1];
  if ( a1[4] )
    goto LABEL_12;
LABEL_25:
  v23 = (unsigned __int64)a2[2];
  v24 = (void *)(v12 + 1);
  if ( v12 + 1 <= v23 )
  {
    result = *a2;
    goto LABEL_32;
  }
  v25 = 2 * v23;
  v26 = *a2;
  if ( v25 <= v12 + 993 )
    v27 = v12 + 993;
  else
    v27 = v25;
  a2[2] = (void *)v27;
  result = realloc(v26, v27);
  *a2 = result;
  if ( !result )
LABEL_33:
    std::terminate();
  v12 = (__int64)a2[1];
  v24 = (void *)(v12 + 1);
LABEL_32:
  a2[1] = v24;
  result[v12] = 125;
  return result;
}

//----- (000000000005C138) ----------------------------------------------------
void __fastcall sub_5C138(void *a1)
{
  operator delete(a1);
}

//----- (000000000005C140) ----------------------------------------------------
_BYTE *__fastcall sub_5C140(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x10
  __int64 v6; // x9
  unsigned __int64 v7; // x8
  _BYTE *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x8
  unsigned __int64 v13; // x10
  __int64 v14; // x9
  unsigned __int64 v15; // x8
  _BYTE *v16; // x0
  size_t v17; // x1
  _BYTE *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x10
  __int64 v21; // x9
  unsigned __int64 v22; // x8
  _BYTE *v23; // x0
  size_t v24; // x1
  _BYTE *v25; // x0
  __int64 v26; // x20
  __int64 v27; // x8
  unsigned __int64 v28; // x10
  __int64 v29; // x9
  unsigned __int64 v30; // x8
  _BYTE *v31; // x0
  size_t v32; // x1
  _BYTE *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v6 = v2 + 1;
  ++*(_DWORD *)(a2 + 32);
  if ( v2 + 1 <= v3 )
  {
    v10 = *(_BYTE **)a2;
  }
  else
  {
    v7 = v2 + 993;
    v8 = *(_BYTE **)a2;
    if ( 2 * v3 <= v7 )
      v9 = v7;
    else
      v9 = 2 * v3;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_34;
    v2 = *(_QWORD *)(a2 + 8);
    v6 = v2 + 1;
  }
  *(_QWORD *)(a2 + 8) = v6;
  v10[v2] = 40;
  v11 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 32LL))(v11, a2);
  if ( (*(_WORD *)(v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 40LL))(v11, a2);
  v12 = *(_QWORD *)(a2 + 8);
  v13 = *(_QWORD *)(a2 + 16);
  v14 = v12 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v12 + 1 <= v13 )
  {
    v18 = *(_BYTE **)a2;
  }
  else
  {
    v15 = v12 + 993;
    v16 = *(_BYTE **)a2;
    if ( 2 * v13 <= v15 )
      v17 = v15;
    else
      v17 = 2 * v13;
    *(_QWORD *)(a2 + 16) = v17;
    v18 = realloc(v16, v17);
    *(_QWORD *)a2 = v18;
    if ( !v18 )
      goto LABEL_34;
    v12 = *(_QWORD *)(a2 + 8);
    v14 = v12 + 1;
  }
  *(_QWORD *)(a2 + 8) = v14;
  v18[v12] = 41;
  v19 = *(_QWORD *)(a2 + 8);
  v20 = *(_QWORD *)(a2 + 16);
  v21 = v19 + 1;
  ++*(_DWORD *)(a2 + 32);
  if ( v19 + 1 <= v20 )
  {
    v25 = *(_BYTE **)a2;
  }
  else
  {
    v22 = v19 + 993;
    v23 = *(_BYTE **)a2;
    if ( 2 * v20 <= v22 )
      v24 = v22;
    else
      v24 = 2 * v20;
    *(_QWORD *)(a2 + 16) = v24;
    v25 = realloc(v23, v24);
    *(_QWORD *)a2 = v25;
    if ( !v25 )
      goto LABEL_34;
    v19 = *(_QWORD *)(a2 + 8);
    v21 = v19 + 1;
  }
  *(_QWORD *)(a2 + 8) = v21;
  v25[v19] = 40;
  v26 = *(_QWORD *)(a1 + 24);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v26 + 32LL))(v26, a2);
  if ( (*(_WORD *)(v26 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v26 + 40LL))(v26, a2);
  v27 = *(_QWORD *)(a2 + 8);
  v28 = *(_QWORD *)(a2 + 16);
  v29 = v27 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v27 + 1 <= v28 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_33;
  }
  v30 = v27 + 993;
  v31 = *(_BYTE **)a2;
  if ( 2 * v28 <= v30 )
    v32 = v30;
  else
    v32 = 2 * v28;
  *(_QWORD *)(a2 + 16) = v32;
  result = realloc(v31, v32);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_34:
    std::terminate();
  v27 = *(_QWORD *)(a2 + 8);
  v29 = v27 + 1;
LABEL_33:
  *(_QWORD *)(a2 + 8) = v29;
  result[v27] = 41;
  return result;
}

//----- (000000000005C35C) ----------------------------------------------------
void __fastcall sub_5C35C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005C364) ----------------------------------------------------
_OWORD *__fastcall sub_5C364(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _OWORD *v8; // x9
  __int128 v9; // q0
  _OWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_OWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  v9 = *a2;
  *((_BYTE *)v8 - 8) = 7;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *((_QWORD *)v8 - 2) = off_6FBA8;
  result = v8 - 1;
  *v8 = v9;
  return result;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (000000000005C408) ----------------------------------------------------
char *__fastcall sub_5C408(_QWORD *a1, char **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 *v12; // x21
  __int64 v13; // x9
  char *v14; // x8
  unsigned __int64 v15; // x9
  size_t v16; // x8
  unsigned __int64 v17; // x9
  char *v18; // x0
  size_t v19; // x1
  char *v20; // x0
  char *v21; // x8
  char *v22; // x9
  _BYTE *v23; // x10
  _BYTE *v24; // x21
  __int64 v25; // x8
  unsigned __int64 v26; // x10
  char *v27; // x0
  size_t v28; // x1
  char *v29; // x0
  unsigned __int64 v30; // x10
  char *v31; // x0
  size_t v32; // x1
  char *v33; // x0
  size_t v34; // x9
  size_t v35; // x20
  unsigned __int64 v36; // x10
  unsigned __int64 v37; // x9
  char *v38; // x0
  size_t v39; // x1
  char *v40; // x0
  _BYTE *v41; // x9
  _BYTE *v42; // x10
  unsigned __int64 v43; // x9
  size_t v44; // x8
  unsigned __int64 v45; // x9
  char *v46; // x0
  size_t v47; // x1
  char *result; // x0

  v2 = a1[3];
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 2) <= v6 )
  {
    v11 = *a2;
  }
  else
  {
    v7 = (size_t)(v5 + 994);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (char *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      goto LABEL_58;
    v5 = a2[1];
  }
  *(_WORD *)&v5[(_QWORD)v11] = 15406;
  v12 = (__int64 *)a1[2];
  v13 = *v12;
  a2[1] += 2;
  (*(void (__fastcall **)(__int64 *, char **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, char **))(*v12 + 40))(v12, a2);
  v14 = a2[1];
  v15 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v14 + 11) <= v15 )
  {
    v20 = *a2;
  }
  else
  {
    v16 = (size_t)(v14 + 1003);
    v17 = 2 * v15;
    v18 = *a2;
    if ( v17 <= v16 )
      v19 = v16;
    else
      v19 = v17;
    a2[2] = (char *)v19;
    v20 = (char *)realloc(v18, v19);
    *a2 = v20;
    if ( !v20 )
      goto LABEL_58;
    v14 = a2[1];
  }
  v21 = &v14[(_QWORD)v20];
  *(_QWORD *)v21 = *(_QWORD *)" at offset ";
  *(_DWORD *)(v21 + 7) = 544499059;
  v22 = a2[1];
  v24 = (_BYTE *)a1[4];
  v23 = (_BYTE *)a1[5];
  v25 = (__int64)(v22 + 11);
  a2[1] = v22 + 11;
  if ( v24 == v23 )
  {
    v30 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v22 + 12) <= v30 )
    {
      v33 = *a2;
    }
    else
    {
      v31 = *a2;
      if ( 2 * v30 <= (unsigned __int64)(v22 + 1004) )
        v32 = (size_t)(v22 + 1004);
      else
        v32 = 2 * v30;
      a2[2] = (char *)v32;
      v33 = (char *)realloc(v31, v32);
      *a2 = v33;
      if ( !v33 )
        goto LABEL_58;
      v25 = (__int64)a2[1];
    }
    v35 = 1;
    v33[v25] = 48;
    goto LABEL_49;
  }
  if ( *v24 != 110 )
  {
    v34 = (size_t)a2[2];
    v35 = v23 - v24;
    v36 = v25 + v23 - v24;
    if ( v36 <= v34 )
    {
LABEL_47:
      v40 = *a2;
LABEL_48:
      memcpy(&v40[v25], v24, v35);
LABEL_49:
      v25 = (__int64)&a2[1][v35];
      a2[1] = (char *)v25;
      goto LABEL_50;
    }
LABEL_34:
    v37 = 2 * v34;
    v38 = *a2;
    if ( v37 <= v36 + 992 )
      v39 = v36 + 992;
    else
      v39 = v37;
    a2[2] = (char *)v39;
    v40 = (char *)realloc(v38, v39);
    *a2 = v40;
    if ( !v40 )
      goto LABEL_58;
    v25 = (__int64)a2[1];
    goto LABEL_48;
  }
  v26 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v22 + 12) <= v26 )
  {
    v29 = *a2;
  }
  else
  {
    v27 = *a2;
    if ( 2 * v26 <= (unsigned __int64)(v22 + 1004) )
      v28 = (size_t)(v22 + 1004);
    else
      v28 = 2 * v26;
    a2[2] = (char *)v28;
    v29 = (char *)realloc(v27, v28);
    *a2 = v29;
    if ( !v29 )
      goto LABEL_58;
    v25 = (__int64)a2[1];
  }
  v29[v25] = 45;
  v41 = (_BYTE *)a1[4];
  v42 = (_BYTE *)a1[5];
  v25 = (__int64)(a2[1] + 1);
  if ( v42 == v41 )
    v24 = (_BYTE *)a1[4];
  else
    v24 = v41 + 1;
  v35 = v42 - v24;
  a2[1] = (char *)v25;
  if ( v42 != v24 )
  {
    v34 = (size_t)a2[2];
    v36 = v25 + v35;
    if ( v25 + v35 <= v34 )
      goto LABEL_47;
    goto LABEL_34;
  }
LABEL_50:
  v43 = (unsigned __int64)a2[2];
  if ( v25 + 1 <= v43 )
  {
    result = *a2;
    goto LABEL_57;
  }
  v44 = v25 + 993;
  v45 = 2 * v43;
  v46 = *a2;
  if ( v45 <= v44 )
    v47 = v44;
  else
    v47 = v45;
  a2[2] = (char *)v47;
  result = (char *)realloc(v46, v47);
  *a2 = result;
  if ( !result )
LABEL_58:
    std::terminate();
  v25 = (__int64)a2[1];
LABEL_57:
  result[v25] = 62;
  ++a2[1];
  return result;
}

//----- (000000000005C704) ----------------------------------------------------
void __fastcall sub_5C704(void *a1)
{
  operator delete(a1);
}

//----- (000000000005C70C) ----------------------------------------------------
_BYTE *__fastcall sub_5C70C(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x10
  unsigned __int64 v13; // x11
  __int64 v14; // x9
  __int64 v15; // x8
  char *v16; // x0
  size_t v17; // x1
  _BYTE *v18; // x0
  __int64 v19; // x8
  __int64 v20; // x8
  unsigned __int64 v21; // x10
  __int64 v22; // x9
  unsigned __int64 v23; // x8
  char *v24; // x0
  size_t v25; // x1
  _BYTE *result; // x0
  __int64 (__fastcall **v27)(); // [xsp+8h] [xbp-18h] BYREF
  char v28; // [xsp+10h] [xbp-10h]
  __int16 v29; // [xsp+11h] [xbp-Fh]
  __int64 v30; // [xsp+18h] [xbp-8h]

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  if ( v2 + 9 <= v3 )
  {
    v10 = *(char **)a2;
  }
  else
  {
    v6 = v2 + 1001;
    v7 = 2 * v3;
    v8 = *(char **)a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = (char *)realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_23;
    v2 = *(_QWORD *)(a2 + 8);
  }
  v11 = &v10[v2];
  v11[8] = 46;
  *(_QWORD *)v11 = *(_QWORD *)"sizeof...";
  v12 = *(_QWORD *)(a2 + 8);
  v13 = *(_QWORD *)(a2 + 16);
  v14 = v12 + 10;
  v15 = v12 + 9;
  ++*(_DWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 8) = v12 + 9;
  if ( v12 + 10 <= v13 )
  {
    v18 = *(_BYTE **)a2;
  }
  else
  {
    v16 = *(char **)a2;
    if ( 2 * v13 <= v12 + 1002 )
      v17 = v12 + 1002;
    else
      v17 = 2 * v13;
    *(_QWORD *)(a2 + 16) = v17;
    v18 = realloc(v16, v17);
    *(_QWORD *)a2 = v18;
    if ( !v18 )
      goto LABEL_23;
    v15 = *(_QWORD *)(a2 + 8);
    v14 = v15 + 1;
  }
  *(_QWORD *)(a2 + 8) = v14;
  v18[v15] = 40;
  v19 = *(_QWORD *)(a1 + 16);
  v29 = 1344;
  v28 = 38;
  v30 = v19;
  v27 = off_70D88;
  sub_5B890((__int64)&v27, (char **)a2);
  v20 = *(_QWORD *)(a2 + 8);
  v21 = *(_QWORD *)(a2 + 16);
  v22 = v20 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v20 + 1 <= v21 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_22;
  }
  v23 = v20 + 993;
  v24 = *(char **)a2;
  if ( 2 * v21 <= v23 )
    v25 = v23;
  else
    v25 = 2 * v21;
  *(_QWORD *)(a2 + 16) = v25;
  result = realloc(v24, v25);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_23:
    std::terminate();
  v20 = *(_QWORD *)(a2 + 8);
  v22 = v20 + 1;
LABEL_22:
  *(_QWORD *)(a2 + 8) = v22;
  result[v20] = 41;
  return result;
}
// 70D88: using guessed type __int64 (__fastcall *off_70D88[10])();

//----- (000000000005C88C) ----------------------------------------------------
void __fastcall sub_5C88C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005C894) ----------------------------------------------------
_BYTE *__fastcall sub_5C894(_BYTE *result, void **a2)
{
  _BYTE *v2; // x19
  __int64 v4; // x21
  __int64 v5; // x22
  char v6; // w23
  __int64 v7; // x25
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  void *v10; // x0
  size_t v11; // x1
  char *v12; // x0
  __int64 v13; // x8

  if ( *((_QWORD *)result + 3) )
  {
    v2 = result;
    v4 = 0;
    v5 = (__int64)a2[1];
    v6 = 1;
    do
    {
      while ( 1 )
      {
        v7 = v5;
        if ( (v6 & 1) == 0 )
        {
          v8 = (unsigned __int64)a2[2];
          if ( v5 + 2 <= v8 )
          {
            v12 = (char *)*a2;
            v13 = v5;
          }
          else
          {
            v9 = 2 * v8;
            v10 = *a2;
            if ( v9 <= v5 + 994 )
              v11 = v5 + 994;
            else
              v11 = v9;
            a2[2] = (void *)v11;
            v12 = (char *)realloc(v10, v11);
            *a2 = v12;
            if ( !v12 )
              std::terminate();
            v13 = (__int64)a2[1];
          }
          *(_WORD *)&v12[v13] = 8236;
          v7 = (__int64)a2[1] + 2;
          a2[1] = (void *)v7;
        }
        result = sub_56990(*(__int64 **)(*((_QWORD *)v2 + 2) + 8 * v4), (__int64)a2, 18, 0);
        if ( (void *)v7 != a2[1] )
          break;
        a2[1] = (void *)v5;
        if ( ++v4 == *((_QWORD *)v2 + 3) )
          return result;
      }
      v6 = 0;
      v5 = (__int64)a2[1];
      ++v4;
    }
    while ( v4 != *((_QWORD *)v2 + 3) );
  }
  return result;
}

//----- (000000000005C9A0) ----------------------------------------------------
void __fastcall sub_5C9A0(void *a1)
{
  operator delete(a1);
}

//----- (000000000005C9A8) ----------------------------------------------------
__int64 __fastcall sub_5C9A8(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 6) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 998);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  *((_WORD *)v11 + 2) = 8311;
  *(_DWORD *)v11 = 1869768820;
  v12 = *(__int64 **)(a1 + 16);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 6;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005CA80) ----------------------------------------------------
void __fastcall sub_5CA80(void *a1)
{
  operator delete(a1);
}

//----- (000000000005CA88) ----------------------------------------------------
unsigned __int8 **__fastcall sub_5CA88(unsigned __int8 **a1, size_t a2)
{
  int v3; // w8
  __int64 v4; // x20
  unsigned __int8 *v5; // x8
  unsigned __int8 **v6; // x0
  signed __int64 v7; // x21
  size_t v8; // x1
  unsigned __int8 *v9; // x0
  unsigned __int8 *v10; // x22
  unsigned __int8 **v12; // x23
  unsigned __int8 *v13; // x0

  if ( a1[1] == *a1 )
    return sub_51A40((__int64)a1);
  v3 = **a1;
  if ( v3 != 68 )
  {
    if ( v3 == 84 )
    {
      v4 = (__int64)sub_5158C((__int64)a1, a2);
      if ( v4 )
      {
        v5 = a1[38];
        if ( v5 == a1[39] )
        {
          v6 = (unsigned __int8 **)a1[37];
          v7 = v5 - (unsigned __int8 *)v6;
          v8 = 2 * (v5 - (unsigned __int8 *)v6);
          if ( v6 == a1 + 40 )
          {
            v9 = (unsigned __int8 *)malloc(2 * (v5 - (unsigned __int8 *)v6));
            if ( v9 )
            {
              v10 = v9;
              memcpy(v9, a1 + 40, v7);
LABEL_18:
              a1[37] = v10;
              goto LABEL_19;
            }
            goto LABEL_22;
          }
          goto LABEL_14;
        }
        goto LABEL_20;
      }
      return (unsigned __int8 **)v4;
    }
    return sub_51A40((__int64)a1);
  }
  v4 = sub_51900((__int64)a1);
  if ( v4 )
  {
    v5 = a1[38];
    if ( v5 == a1[39] )
    {
      v12 = (unsigned __int8 **)a1[37];
      v7 = v5 - (unsigned __int8 *)v12;
      v8 = 2 * (v5 - (unsigned __int8 *)v12);
      if ( v12 == a1 + 40 )
      {
        v13 = (unsigned __int8 *)malloc(2 * v7);
        if ( v13 )
        {
          v10 = v13;
          memmove(v13, v12, v7);
          goto LABEL_18;
        }
LABEL_22:
        std::terminate();
      }
      v6 = (unsigned __int8 **)a1[37];
LABEL_14:
      v10 = (unsigned __int8 *)realloc(v6, v8);
      a1[37] = v10;
      if ( v10 )
      {
LABEL_19:
        v5 = &v10[v7];
        a1[39] = &v10[8 * (v7 >> 2)];
        goto LABEL_20;
      }
      goto LABEL_22;
    }
LABEL_20:
    a1[38] = v5 + 8;
    *(_QWORD *)v5 = v4;
  }
  return (unsigned __int8 **)v4;
}

//----- (000000000005CBDC) ----------------------------------------------------
__int64 __fastcall sub_5CBDC(__int64 a1)
{
  __int64 v2; // x19
  __int64 v3; // x0
  _QWORD *v4; // x22
  __int64 v5; // x21
  __int64 v6; // x8
  _QWORD *v7; // x0
  __int64 v8; // x8
  __int64 *v9; // x9

  v2 = sub_50964((const char **)a1);
  if ( !v2 || *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73 )
    return v2;
  v3 = sub_50F00(a1, 0);
  if ( v3 )
  {
    v4 = *(_QWORD **)(a1 + 4912);
    v5 = v3;
    v6 = v4[1];
    if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v7 = malloc(0x1000u);
      if ( !v7 )
        std::terminate();
      v6 = 0;
      *v7 = v4;
      v7[1] = 0;
      v4 = v7;
      *(_QWORD *)(a1 + 4912) = v7;
    }
    v8 = v6 + 32;
    v9 = (_QWORD *)((char *)v4 + v8);
    v4[1] = v8;
    LOWORD(v8) = *(_WORD *)((char *)v4 + v8 - 7);
    *((_BYTE *)v9 - 8) = 41;
    *v9 = v2;
    v9[1] = v5;
    *(v9 - 2) = (__int64)off_71808;
    v2 = (__int64)(v9 - 2);
    *(_WORD *)((char *)v9 - 7) = v8 & 0xF000 | 0x540;
    return v2;
  }
  return 0;
}
// 50F00: using guessed type __int64 __fastcall sub_50F00(_QWORD, _QWORD);
// 71808: using guessed type __int64 (__fastcall *off_71808[10])();

//----- (000000000005CCD4) ----------------------------------------------------
__int64 __fastcall sub_5CCD4(__int64 a1)
{
  unsigned __int8 *v1; // x20
  unsigned __int8 *v2; // x21
  size_t v4; // x1
  __int64 v5; // x20
  __int64 v6; // x0
  _QWORD *v7; // x22
  __int64 v8; // x21
  __int64 v9; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 *v12; // x9
  __int64 v14; // x21
  _QWORD *v15; // x20
  __int64 v16; // x8
  _QWORD *v17; // x0
  __int64 v18; // x8
  __int64 *v19; // x9

  v1 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  if ( v2 != *(unsigned __int8 **)a1 && (unsigned int)*v1 - 58 >= 0xFFFFFFF6 )
    return sub_5CBDC(a1);
  if ( (unsigned __int64)&v2[-*(_QWORD *)a1] < 2 )
    goto LABEL_6;
  if ( !strncmp("dn", (const char *)v1, 2u) )
  {
    *(_QWORD *)a1 = v1 + 2;
    if ( v2 == v1 + 2 || (unsigned int)v1[2] - 58 < 0xFFFFFFF6 )
    {
      v14 = (__int64)sub_5CA88((unsigned __int8 **)a1, v4);
      if ( !v14 )
        return 0;
    }
    else
    {
      v14 = sub_5CBDC(a1);
      if ( !v14 )
        return 0;
    }
    v15 = *(_QWORD **)(a1 + 4912);
    v16 = v15[1];
    if ( (unsigned __int64)(v16 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v17 = malloc(0x1000u);
      if ( !v17 )
        goto LABEL_26;
      v16 = 0;
      *v17 = v15;
      v17[1] = 0;
      v15 = v17;
      *(_QWORD *)(a1 + 4912) = v17;
    }
    v18 = v16 + 32;
    v19 = (_QWORD *)((char *)v15 + v18);
    v15[1] = v18;
    LOWORD(v18) = *(_WORD *)((char *)v15 + v18 - 7);
    *((_BYTE *)v19 - 8) = 46;
    *v19 = v14;
    *(_WORD *)((char *)v19 - 7) = v18 & 0xF000 | 0x540;
    *(v19 - 2) = (__int64)off_711E8;
    return (__int64)(v19 - 2);
  }
  if ( !strncmp("on", (const char *)v1, 2u) )
  {
    *(_QWORD *)a1 = v1 + 2;
    v5 = sub_5D04C(a1, 0);
    if ( !v5 )
      return v5;
  }
  else
  {
LABEL_6:
    v5 = sub_5D04C(a1, 0);
    if ( !v5 )
      return v5;
  }
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73 )
    return v5;
  v6 = sub_50F00(a1, 0);
  if ( v6 )
  {
    v7 = *(_QWORD **)(a1 + 4912);
    v8 = v6;
    v9 = v7[1];
    if ( (unsigned __int64)(v9 - 4048) > 0xFFFFFFFFFFFFF00FLL )
    {
LABEL_13:
      v11 = v9 + 32;
      v12 = (_QWORD *)((char *)v7 + v11);
      v7[1] = v11;
      LOWORD(v11) = *(_WORD *)((char *)v7 + v11 - 7);
      *((_BYTE *)v12 - 8) = 41;
      *v12 = v5;
      v12[1] = v8;
      *(v12 - 2) = (__int64)off_71808;
      v5 = (__int64)(v12 - 2);
      *(_WORD *)((char *)v12 - 7) = v11 & 0xF000 | 0x540;
      return v5;
    }
    v10 = malloc(0x1000u);
    if ( v10 )
    {
      v9 = 0;
      *v10 = v7;
      v10[1] = 0;
      v7 = v10;
      *(_QWORD *)(a1 + 4912) = v10;
      goto LABEL_13;
    }
LABEL_26:
    std::terminate();
  }
  return 0;
}
// 5CE30: variable 'v4' is possibly undefined
// 50F00: using guessed type __int64 __fastcall sub_50F00(_QWORD, _QWORD);
// 711E8: using guessed type __int64 (__fastcall *off_711E8[10])();
// 71808: using guessed type __int64 (__fastcall *off_71808[10])();

//----- (000000000005CF24) ----------------------------------------------------
__int64 __fastcall sub_5CF24(__int64 a1, void **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  void *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = (char *)a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 2) <= v6 )
  {
    v11 = (char *)*a2;
  }
  else
  {
    v7 = (size_t)(v5 + 994);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (void *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      std::terminate();
    v5 = (char *)a2[1];
  }
  *(_WORD *)&v5[(_QWORD)v11] = 14906;
  v12 = *(__int64 **)(a1 + 24);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 2;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005D030) ----------------------------------------------------
__int64 __fastcall sub_5D030(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 48LL))(*(_QWORD *)(a1 + 24));
}

//----- (000000000005D044) ----------------------------------------------------
void __fastcall sub_5D044(void *a1)
{
  operator delete(a1);
}

//----- (000000000005D04C) ----------------------------------------------------
__int64 __fastcall sub_5D04C(__int64 a1, _BYTE *a2)
{
  const char *v2; // x20
  const char *v3; // x22
  __int64 v6; // x9
  unsigned int v7; // w8
  __int64 v8; // x11
  __int64 v9; // x12
  unsigned __int8 *v10; // x13
  unsigned int v11; // w14
  unsigned __int8 *v12; // x9
  unsigned int v13; // w8
  int v14; // w22
  char v15; // w23
  bool v16; // zf
  char v17; // w8
  __int64 v18; // x20
  _QWORD *v19; // x21
  __int64 v20; // x8
  _QWORD *v21; // x0
  __int64 v22; // x8
  __int64 *v23; // x9
  __int64 result; // x0
  _QWORD *v25; // x21
  __int64 v26; // x20
  __int64 v27; // x8
  _QWORD *v28; // x0
  __int64 v29; // x8
  const char **v30; // x0
  __int64 (__fastcall **v31)(); // x8
  _QWORD *v32; // x21
  __int64 v33; // x20
  __int64 v34; // x8
  _QWORD *v35; // x0
  __int64 v36; // x8
  const char *v37; // x20
  size_t v38; // x0
  _QWORD *v39; // x22
  size_t v40; // x21
  __int64 v41; // x8
  _QWORD *v42; // x0
  __int64 v43; // x8

  v2 = *(const char **)a1;
  v3 = *(const char **)(a1 + 8);
  if ( (unsigned __int64)&v3[-*(_QWORD *)a1] < 2 )
    goto LABEL_26;
  v6 = 0;
  v7 = *(unsigned __int8 *)v2;
  v8 = 61;
  do
  {
    v9 = (unsigned __int64)(v6 + v8) >> 1;
    v10 = (unsigned __int8 *)&unk_6FCE8 + 16 * v9;
    v11 = *v10;
    if ( v7 > v11 || v7 == v11 && *((unsigned __int8 *)v2 + 1) > (unsigned int)v10[1] )
    {
      v6 = v9 + 1;
      v9 = v8;
    }
    v8 = v9;
  }
  while ( v9 != v6 );
  v12 = (unsigned __int8 *)&unk_6FCE8 + 16 * v6;
  if ( v7 == *v12 && *((unsigned __int8 *)v2 + 1) == v12[1] )
  {
    v13 = v12[2];
    *(_QWORD *)a1 = v2 + 2;
    if ( v13 == 8 )
    {
      v14 = *(unsigned __int8 *)(a1 + 777);
      v15 = *(_BYTE *)(a1 + 776);
      *(_BYTE *)(a1 + 776) = 0;
      if ( a2 )
        v16 = 0;
      else
        v16 = v14 == 0;
      v17 = !v16;
      *(_BYTE *)(a1 + 777) = v17;
      v18 = sub_4DAC4(a1);
      if ( !v18 )
      {
        result = 0;
        goto LABEL_52;
      }
      if ( a2 )
        *a2 = 1;
      v19 = *(_QWORD **)(a1 + 4912);
      v20 = v19[1];
      if ( (unsigned __int64)(v20 - 4048) > 0xFFFFFFFFFFFFF00FLL )
      {
LABEL_24:
        v22 = v20 + 32;
        v23 = (_QWORD *)((char *)v19 + v22);
        v19[1] = v22;
        LOWORD(v22) = *(_WORD *)((char *)v19 + v22 - 7);
        *((_BYTE *)v23 - 8) = 4;
        *v23 = v18;
        *(_WORD *)((char *)v23 - 7) = v22 & 0xF000 | 0x540;
        *(v23 - 2) = (__int64)off_71258;
        result = (__int64)(v23 - 2);
LABEL_52:
        *(_BYTE *)(a1 + 777) = v14;
        *(_BYTE *)(a1 + 776) = v15;
        return result;
      }
      v21 = malloc(0x1000u);
      if ( v21 )
      {
        v20 = 0;
        *v21 = v19;
        v21[1] = 0;
        v19 = v21;
        *(_QWORD *)(a1 + 4912) = v21;
        goto LABEL_24;
      }
LABEL_53:
      std::terminate();
    }
    if ( v13 <= 0xA && (v13 != 4 || (v12[3] & 1) != 0) )
    {
      v37 = (const char *)*((_QWORD *)v12 + 1);
      v38 = strlen(v37);
      v39 = *(_QWORD **)(a1 + 4912);
      v40 = v38;
      v41 = v39[1];
      if ( (unsigned __int64)(v41 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v42 = malloc(0x1000u);
        if ( !v42 )
          goto LABEL_53;
        v41 = 0;
        *v42 = v39;
        v42[1] = 0;
        v39 = v42;
        *(_QWORD *)(a1 + 4912) = v42;
      }
      v43 = v41 + 32;
      v30 = (const char **)((char *)v39 + v43);
      v39[1] = v43;
      LOWORD(v43) = *(_WORD *)((char *)v39 + v43 - 7);
      *((_BYTE *)v30 - 8) = 7;
      *(_WORD *)((char *)v30 - 7) = v43 & 0xF000 | 0x540;
      v31 = off_6FBA8;
      *v30 = v37;
      v30[1] = &v37[v40];
LABEL_50:
      *(v30 - 2) = (const char *)v31;
      return (__int64)(v30 - 2);
    }
    return 0;
  }
  if ( !strncmp("li", v2, 2u) )
  {
    *(_QWORD *)a1 = v2 + 2;
    result = sub_50964((const char **)a1);
    if ( result )
    {
      v32 = *(_QWORD **)(a1 + 4912);
      v33 = result;
      v34 = v32[1];
      if ( (unsigned __int64)(v34 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v35 = malloc(0x1000u);
        if ( !v35 )
          goto LABEL_53;
        v34 = 0;
        *v35 = v32;
        v35[1] = 0;
        v32 = v35;
        *(_QWORD *)(a1 + 4912) = v35;
      }
      v36 = v34 + 32;
      v30 = (const char **)((char *)v32 + v36);
      v32[1] = v36;
      LOWORD(v36) = *(_WORD *)((char *)v32 + v36 - 7);
      *((_BYTE *)v30 - 8) = 19;
      *v30 = (const char *)v33;
      *(_WORD *)((char *)v30 - 7) = v36 & 0xF000 | 0x540;
      v31 = off_712C8;
      goto LABEL_50;
    }
  }
  else
  {
LABEL_26:
    if ( v2 == v3 )
    {
      return 0;
    }
    else
    {
      if ( *v2 != 118 )
        return 0;
      *(_QWORD *)a1 = v2 + 1;
      if ( v3 == v2 + 1 || (unsigned int)*((unsigned __int8 *)v2 + 1) - 48 > 9 )
        return 0;
      *(_QWORD *)a1 = v2 + 2;
      result = sub_50964((const char **)a1);
      if ( result )
      {
        v25 = *(_QWORD **)(a1 + 4912);
        v26 = result;
        v27 = v25[1];
        if ( (unsigned __int64)(v27 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
        {
          v28 = malloc(0x1000u);
          if ( !v28 )
            goto LABEL_53;
          v27 = 0;
          *v28 = v25;
          v28[1] = 0;
          v25 = v28;
          *(_QWORD *)(a1 + 4912) = v28;
        }
        v29 = v27 + 32;
        v30 = (const char **)((char *)v25 + v29);
        v25[1] = v29;
        LOWORD(v29) = *(_WORD *)((char *)v25 + v29 - 7);
        *((_BYTE *)v30 - 8) = 4;
        *v30 = (const char *)v26;
        *(_WORD *)((char *)v30 - 7) = v29 & 0xF000 | 0x540;
        v31 = off_71258;
        goto LABEL_50;
      }
    }
  }
  return result;
}
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 71258: using guessed type __int64 (__fastcall *off_71258[10])();
// 712C8: using guessed type __int64 (__fastcall *off_712C8[10])();

//----- (000000000005D424) ----------------------------------------------------
__int64 __fastcall sub_5D424(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  _BYTE *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 *v11; // x0
  __int64 v12; // x9

  v2 = a2[1];
  v3 = a2[2];
  if ( v2 + 1 <= v3 )
  {
    v10 = (_BYTE *)*a2;
  }
  else
  {
    v6 = v2 + 993;
    v7 = 2 * v3;
    v8 = (_BYTE *)*a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = v9;
    v10 = realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = a2[1];
  }
  v10[v2] = 126;
  v11 = *(__int64 **)(a1 + 16);
  v12 = *v11;
  ++a2[1];
  return (*(__int64 (__fastcall **)(__int64 *, _QWORD *))(v12 + 32))(v11, a2);
}

//----- (000000000005D4B4) ----------------------------------------------------
void __fastcall sub_5D4B4(void *a1)
{
  operator delete(a1);
}

//----- (000000000005D4BC) ----------------------------------------------------
__int64 __fastcall sub_5D4BC(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 9) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1001);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  v11[8] = 32;
  *(_QWORD *)v11 = *(_QWORD *)"operator ";
  v12 = *(__int64 **)(a1 + 16);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 9;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005D598) ----------------------------------------------------
void __fastcall sub_5D598(void *a1)
{
  operator delete(a1);
}

//----- (000000000005D5A0) ----------------------------------------------------
__int64 __fastcall sub_5D5A0(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 11) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1003);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  *(_QWORD *)v11 = *(_QWORD *)"operator\"\" ";
  *(_DWORD *)(v11 + 7) = 539107954;
  v12 = *(__int64 **)(a1 + 16);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 11;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005D680) ----------------------------------------------------
void __fastcall sub_5D680(void *a1)
{
  operator delete(a1);
}

//----- (000000000005D688) ----------------------------------------------------
__int64 __fastcall sub_5D688(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 *v11; // x20
  __int64 v12; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 2) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 994);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  *(_WORD *)&v2[(_QWORD)v10] = 14906;
  v11 = *(__int64 **)(a1 + 16);
  v12 = *v11;
  a2[1] = (char *)a2[1] + 2;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v12 + 32))(v11, a2);
  if ( (*(_WORD *)((_BYTE *)v11 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v11 + 40))(v11, a2);
  return result;
}

//----- (000000000005D750) ----------------------------------------------------
__int64 __fastcall sub_5D750(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 48LL))(*(_QWORD *)(a1 + 16));
}

//----- (000000000005D764) ----------------------------------------------------
void __fastcall sub_5D764(void *a1)
{
  operator delete(a1);
}

//----- (000000000005D76C) ----------------------------------------------------
unsigned __int8 **__fastcall sub_5D76C(__int64 a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // x8
  unsigned __int8 *v3; // x9
  __int64 v6; // x8
  unsigned __int8 **v7; // x10
  __int16 v8; // w9
  unsigned __int8 **result; // x0
  unsigned __int64 v10; // x10
  unsigned __int8 *v11; // x9
  int v12; // t1
  unsigned __int8 *v13; // x24
  unsigned __int8 *v14; // x25
  _QWORD *v15; // x26
  __int64 v16; // x8
  _QWORD *v17; // x0

  v3 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  if ( *(unsigned __int8 **)a1 != v2 )
  {
    while ( *v3 == 66 )
    {
      *(_QWORD *)a1 = v3 + 1;
      if ( v2 == v3 + 1 || (unsigned int)v3[1] - 58 < 0xFFFFFFF6 )
        return 0;
      v10 = 0;
      v11 = v3 + 2;
      while ( 1 )
      {
        *(_QWORD *)a1 = v11;
        v10 = *(v11 - 1) + 10 * v10 - 48;
        if ( v11 == v2 )
          break;
        v12 = *v11++;
        if ( (unsigned int)(v12 - 48) > 9 )
        {
          v13 = v11 - 1;
          if ( v2 - (v11 - 1) < v10 )
            return 0;
          goto LABEL_11;
        }
      }
      v13 = v2;
      if ( v10 )
        return 0;
LABEL_11:
      v14 = &v13[v10];
      *(_QWORD *)a1 = &v13[v10];
      if ( v13 == &v13[v10] )
        return 0;
      v15 = *(_QWORD **)(a1 + 4912);
      v16 = v15[1];
      if ( (unsigned __int64)(v16 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v17 = malloc(0x1000u);
        if ( !v17 )
          std::terminate();
        v16 = 0;
        *v17 = v15;
        v17[1] = 0;
        v15 = v17;
        *(_QWORD *)(a1 + 4912) = v17;
      }
      v6 = v16 + 48;
      v7 = (unsigned __int8 **)((char *)v15 + v6);
      v15[1] = v6;
      LOWORD(v6) = *(_WORD *)((char *)a2 + 9);
      *(v7 - 1) = v13;
      *v7 = v14;
      v8 = *(_WORD *)((char *)v7 - 23);
      *(v7 - 2) = (unsigned __int8 *)a2;
      *(v7 - 4) = (unsigned __int8 *)off_71488;
      result = v7 - 4;
      a2 = v7 - 4;
      *((_BYTE *)v7 - 24) = 8;
      *(_WORD *)((char *)v7 - 23) = v8 & 0xF000 | v6 & 0xFC0;
      v3 = *(unsigned __int8 **)a1;
      v2 = *(unsigned __int8 **)(a1 + 8);
      if ( *(unsigned __int8 **)a1 == v2 )
        return result;
    }
  }
  return a2;
}
// 71488: using guessed type __int64 (__fastcall *off_71488[10])();

//----- (000000000005D8FC) ----------------------------------------------------
void __fastcall sub_5D8FC(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x9

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 5) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 997);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  v11[4] = 58;
  *(_DWORD *)v11 = 979661939;
  v12 = *(unsigned int *)(a1 + 12);
  a2[1] = (char *)a2[1] + 5;
  __asm { BR              X11 }
}

//----- (000000000005DB00) ----------------------------------------------------
void __fastcall sub_5DB00(__int64 a1)
{
  __asm { BR              X10 }
}
// 5DB48: unbalanced stack, ignored a potential tail call

//----- (000000000005DB4C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 sub_5DB4C()
{
  __int64 v0; // x19
  __int64 result; // x0

  __asm { BTI             j }
  result = v0;
  __asm { BTI             j }
  return result;
}
// 5DB68: positive sp value 30 has been found
// 5DB4C: could not find valid save-restore pair for x20
// 5DB4C: could not find valid save-restore pair for x21
// 5DB54: variable 'v0' is possibly undefined

//----- (000000000005DB70) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char *sub_5DB70()
{
  __int64 v5; // x0

  __asm { BTI             j }
  __asm { BTI             j }
  if ( !strncmp("basic_", "basic_istream", 6u) )
    return "istream";
  v5 = ((__int64 (__fastcall *)(const char *, __int64, const char *, const char *))__assert2)(
         "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
         1582,
         "virtual StringView (anonymous namespace)::itanium_demangle::SpecialSubstitution::getBaseName() const",
         "SV.startsWith(\"basic_\")");
  return (char *)((__int64 (__fastcall *)(__int64))sub_5DC1C)(v5);
}
// 5DBD8: positive sp value 30 has been found
// 5DC1C: using guessed type __int64 __fastcall sub_5DC1C();

//----- (000000000005DC1C) ----------------------------------------------------
void __fastcall sub_5DC1C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005DC24) ----------------------------------------------------
char *__fastcall sub_5DC24(__int64 *a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x9
  char *result; // x0
  _BYTE *v14; // x1
  size_t v15; // x21
  char *v16; // x8
  size_t v17; // x9
  const void *v18; // x22
  char *v19; // x10
  unsigned __int64 v20; // x9
  void *v21; // x0
  size_t v22; // x1
  char *v23; // x0
  char *v24; // x8
  unsigned __int64 v25; // x9
  size_t v26; // x8
  unsigned __int64 v27; // x9
  void *v28; // x0
  size_t v29; // x1
  char *v30; // x0
  char *v31; // x9
  int v32; // w10
  __int64 v33; // x8
  unsigned __int64 v34; // x10
  void *v35; // x0
  size_t v36; // x1
  char *v37; // x0
  unsigned __int64 v38; // x9
  size_t v39; // x8
  unsigned __int64 v40; // x9
  void *v41; // x0
  size_t v42; // x1

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 5) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 997);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_43;
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  v11[4] = 58;
  *(_DWORD *)v11 = 979661939;
  v12 = *a1;
  a2[1] = (char *)a2[1] + 5;
  result = (char *)(*(__int64 (__fastcall **)(__int64 *))(v12 + 48))(a1);
  v15 = v14 - result;
  if ( v14 != result )
  {
    v16 = (char *)a2[1];
    v17 = (size_t)a2[2];
    v18 = result;
    v19 = &v16[v15];
    if ( (unsigned __int64)&v16[v15] <= v17 )
    {
      v23 = (char *)*a2;
    }
    else
    {
      v20 = 2 * v17;
      v21 = *a2;
      if ( v20 <= (unsigned __int64)(v19 + 992) )
        v22 = (size_t)(v19 + 992);
      else
        v22 = v20;
      a2[2] = (void *)v22;
      v23 = (char *)realloc(v21, v22);
      *a2 = v23;
      if ( !v23 )
        goto LABEL_43;
      v16 = (char *)a2[1];
    }
    result = (char *)memcpy(&v16[(_QWORD)v23], v18, v15);
    a2[1] = (char *)a2[1] + v15;
  }
  if ( *((_DWORD *)a1 + 3) < 2u )
    return result;
  v24 = (char *)a2[1];
  v25 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v24 + 29) <= v25 )
  {
    v30 = (char *)*a2;
  }
  else
  {
    v26 = (size_t)(v24 + 1021);
    v27 = 2 * v25;
    v28 = *a2;
    if ( v27 <= v26 )
      v29 = v26;
    else
      v29 = v27;
    a2[2] = (void *)v29;
    v30 = (char *)realloc(v28, v29);
    *a2 = v30;
    if ( !v30 )
      goto LABEL_43;
    v24 = (char *)a2[1];
  }
  qmemcpy(&v24[(_QWORD)v30], "<char, std::char_traits<char>", 29);
  v31 = (char *)a2[1];
  v32 = *((_DWORD *)a1 + 3);
  v33 = (__int64)(v31 + 29);
  a2[1] = v31 + 29;
  if ( v32 == 2 )
  {
    v34 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v31 + 51) <= v34 )
    {
      v37 = (char *)*a2;
    }
    else
    {
      v35 = *a2;
      if ( 2 * v34 <= (unsigned __int64)(v31 + 1043) )
        v36 = (size_t)(v31 + 1043);
      else
        v36 = 2 * v34;
      a2[2] = (void *)v36;
      v37 = (char *)realloc(v35, v36);
      *a2 = v37;
      if ( !v37 )
        goto LABEL_43;
      v33 = (__int64)a2[1];
    }
    qmemcpy(&v37[v33], ", std::allocator<char>", 22);
    v33 = (__int64)a2[1] + 22;
    a2[1] = (void *)v33;
  }
  v38 = (unsigned __int64)a2[2];
  if ( v33 + 1 <= v38 )
  {
    result = (char *)*a2;
    goto LABEL_41;
  }
  v39 = v33 + 993;
  v40 = 2 * v38;
  v41 = *a2;
  if ( v40 <= v39 )
    v42 = v39;
  else
    v42 = v40;
  a2[2] = (void *)v42;
  result = (char *)realloc(v41, v42);
  *a2 = result;
  if ( !result )
LABEL_43:
    std::terminate();
  v33 = (__int64)a2[1];
LABEL_41:
  result[v33] = 62;
  a2[1] = (char *)a2[1] + 1;
  return result;
}
// 5DCB4: variable 'v14' is possibly undefined

//----- (000000000005DE70) ----------------------------------------------------
char *__fastcall sub_5DE70(__int64 a1)
{
  return (char *)dword_23A0C + dword_23A0C[*(int *)(a1 + 12)];
}
// 23A0C: using guessed type int dword_23A0C[6];

//----- (000000000005DEA0) ----------------------------------------------------
void __fastcall sub_5DEA0(void *a1)
{
  operator delete(a1);
}

//----- (000000000005DEA8) ----------------------------------------------------
char *__fastcall sub_5DEA8(__int64 a1, char **a2)
{
  char *v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x8
  _BYTE *v13; // x9
  _BYTE *v14; // x21
  size_t v15; // x20
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  unsigned __int64 v22; // x9
  size_t v23; // x8
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  char *result; // x0

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
  v4 = a2[1];
  v5 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v4 + 5) <= v5 )
  {
    v10 = *a2;
  }
  else
  {
    v6 = (size_t)(v4 + 997);
    v7 = 2 * v5;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_25;
    v4 = a2[1];
  }
  v11 = &v4[(_QWORD)v10];
  v11[4] = 58;
  *(_DWORD *)v11 = 1768055131;
  v12 = (__int64)(a2[1] + 5);
  a2[1] = (char *)v12;
  v14 = *(_BYTE **)(a1 + 24);
  v13 = *(_BYTE **)(a1 + 32);
  v15 = v13 - v14;
  if ( v13 != v14 )
  {
    v16 = (size_t)a2[2];
    v17 = v12 + v15;
    if ( v12 + v15 <= v16 )
    {
      v21 = *a2;
    }
    else
    {
      v18 = 2 * v16;
      v19 = *a2;
      if ( v18 <= v17 + 992 )
        v20 = v17 + 992;
      else
        v20 = v18;
      a2[2] = (char *)v20;
      v21 = (char *)realloc(v19, v20);
      *a2 = v21;
      if ( !v21 )
        goto LABEL_25;
      v12 = (__int64)a2[1];
    }
    memcpy(&v21[v12], v14, v15);
    v12 = (__int64)&a2[1][v15];
    a2[1] = (char *)v12;
  }
  v22 = (unsigned __int64)a2[2];
  if ( v12 + 1 <= v22 )
  {
    result = *a2;
    goto LABEL_24;
  }
  v23 = v12 + 993;
  v24 = 2 * v22;
  v25 = *a2;
  if ( v24 <= v23 )
    v26 = v23;
  else
    v26 = v24;
  a2[2] = (char *)v26;
  result = (char *)realloc(v25, v26);
  *a2 = result;
  if ( !result )
LABEL_25:
    std::terminate();
  v12 = (__int64)a2[1];
LABEL_24:
  result[v12] = 93;
  ++a2[1];
  return result;
}

//----- (000000000005E00C) ----------------------------------------------------
void __fastcall sub_5E00C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E014) ----------------------------------------------------
char *__fastcall sub_5E014(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x10
  unsigned __int64 v6; // x8
  char *v7; // x0
  size_t v8; // x1
  _BYTE *v9; // x0
  __int64 v10; // x8
  __int64 v11; // x21
  char *v12; // x0
  __int64 v13; // x22
  char v14; // w23
  __int64 v15; // x25
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x8
  char *v18; // x0
  size_t v19; // x1
  char *v20; // x0
  __int64 v21; // x8
  unsigned __int64 v22; // x9
  __int64 v23; // x8
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  char *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 32);
  if ( v2 + 1 > v3 )
  {
    v6 = v2 + 993;
    v7 = *(char **)a2;
    if ( 2 * v3 <= v6 )
      v8 = v6;
    else
      v8 = 2 * v3;
    *(_QWORD *)(a2 + 16) = v8;
    v9 = realloc(v7, v8);
    *(_QWORD *)a2 = v9;
    if ( !v9 )
      goto LABEL_30;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v10 + 1;
    v9[v10] = 91;
    v11 = *(_QWORD *)(a2 + 8);
    if ( !*(_QWORD *)(a1 + 24) )
      goto LABEL_22;
LABEL_9:
    v13 = 0;
    v14 = 1;
    while ( 1 )
    {
      v15 = v11;
      if ( (v14 & 1) == 0 )
      {
        v16 = *(_QWORD *)(a2 + 16);
        if ( v11 + 2 <= v16 )
        {
          v20 = *(char **)a2;
          v21 = v11;
        }
        else
        {
          v17 = 2 * v16;
          v18 = *(char **)a2;
          if ( v17 <= v11 + 994 )
            v19 = v11 + 994;
          else
            v19 = v17;
          *(_QWORD *)(a2 + 16) = v19;
          v20 = (char *)realloc(v18, v19);
          *(_QWORD *)a2 = v20;
          if ( !v20 )
            goto LABEL_30;
          v21 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v20[v21] = 8236;
        v15 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v15;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 16) + 8 * v13), a2, 18, 0);
      if ( v15 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v11;
        if ( ++v13 == *(_QWORD *)(a1 + 24) )
          goto LABEL_22;
      }
      else
      {
        v14 = 0;
        v11 = *(_QWORD *)(a2 + 8);
        if ( ++v13 == *(_QWORD *)(a1 + 24) )
          goto LABEL_22;
      }
    }
  }
  v12 = *(char **)a2;
  *(_QWORD *)(a2 + 8) = v2 + 1;
  v12[v2] = 91;
  v11 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)(a1 + 24) )
    goto LABEL_9;
LABEL_22:
  v22 = *(_QWORD *)(a2 + 16);
  v23 = v11 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v11 + 1 <= v22 )
  {
    result = *(char **)a2;
    goto LABEL_29;
  }
  v24 = 2 * v22;
  v25 = *(char **)a2;
  if ( v24 <= v11 + 993 )
    v26 = v11 + 993;
  else
    v26 = v24;
  *(_QWORD *)(a2 + 16) = v26;
  result = (char *)realloc(v25, v26);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_30:
    std::terminate();
  v11 = *(_QWORD *)(a2 + 8);
  v23 = v11 + 1;
LABEL_29:
  *(_QWORD *)(a2 + 8) = v23;
  result[v11] = 93;
  return result;
}

//----- (000000000005E1F0) ----------------------------------------------------
void __fastcall sub_5E1F0(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E1F8) ----------------------------------------------------
char *__fastcall sub_5E1F8(__int64 a1, __int64 *a2, char a3, int a4)
{
  _QWORD *v4; // x23
  __int64 v8; // x8
  _QWORD *v10; // x0
  __int64 v11; // x8
  char *v12; // x9
  char *result; // x0
  __int64 v14; // x10

  v4 = *(_QWORD **)(a1 + 4912);
  v8 = v4[1];
  if ( (unsigned __int64)(v8 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v10 = malloc(0x1000u);
    if ( !v10 )
      std::terminate();
    v8 = 0;
    *v10 = v4;
    v10[1] = 0;
    v4 = v10;
    *(_QWORD *)(a1 + 4912) = v10;
  }
  v11 = v8 + 32;
  v12 = (char *)v4 + v11;
  v4[1] = v11;
  LOWORD(v11) = *(_WORD *)((char *)v4 + v11 - 7);
  *(v12 - 8) = 45;
  v12[8] = a3 != 0;
  *((_QWORD *)v12 - 2) = off_71568;
  result = v12 - 16;
  v14 = *a2;
  *(_WORD *)(v12 - 7) = v11 & 0xF000 | 0x540;
  *(_QWORD *)v12 = v14;
  *((_DWORD *)v12 + 3) = a4;
  return result;
}
// 71568: using guessed type __int64 (__fastcall *off_71568[10])();

//----- (000000000005E2BC) ----------------------------------------------------
_BYTE *__fastcall sub_5E2BC(__int64 a1, char **a2)
{
  char *v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  _BYTE *result; // x0
  _BYTE *v12; // x1
  size_t v13; // x20
  char *v14; // x8
  size_t v15; // x9
  const void *v16; // x21
  char *v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0

  if ( *(_BYTE *)(a1 + 24) )
  {
    v4 = a2[1];
    v5 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v4 + 1) <= v5 )
    {
      v10 = *a2;
    }
    else
    {
      v6 = (size_t)(v4 + 993);
      v7 = 2 * v5;
      v8 = *a2;
      if ( v7 <= v6 )
        v9 = v6;
      else
        v9 = v7;
      a2[2] = (char *)v9;
      v10 = (char *)realloc(v8, v9);
      *a2 = v10;
      if ( !v10 )
        goto LABEL_20;
      v4 = a2[1];
    }
    v4[(_QWORD)v10] = 126;
    ++a2[1];
  }
  result = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 48LL))(*(_QWORD *)(a1 + 16));
  v13 = v12 - result;
  if ( v12 == result )
    return result;
  v14 = a2[1];
  v15 = (size_t)a2[2];
  v16 = result;
  v17 = &v14[v13];
  if ( (unsigned __int64)&v14[v13] <= v15 )
  {
    v21 = *a2;
    goto LABEL_18;
  }
  v18 = 2 * v15;
  v19 = *a2;
  if ( v18 <= (unsigned __int64)(v17 + 992) )
    v20 = (size_t)(v17 + 992);
  else
    v20 = v18;
  a2[2] = (char *)v20;
  v21 = (char *)realloc(v19, v20);
  *a2 = v21;
  if ( !v21 )
LABEL_20:
    std::terminate();
  v14 = a2[1];
LABEL_18:
  result = memcpy(&v14[(_QWORD)v21], v16, v13);
  a2[1] += v13;
  return result;
}
// 5E344: variable 'v12' is possibly undefined

//----- (000000000005E3C4) ----------------------------------------------------
void __fastcall sub_5E3C4(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E3CC) ----------------------------------------------------
__int64 __fastcall sub_5E3CC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x10
  __int64 v7; // x9
  unsigned __int64 v8; // x8
  _BYTE *v9; // x0
  size_t v10; // x1
  _BYTE *v11; // x0
  __int64 v12; // x20
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 24);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = a2[2];
  v7 = v5 + 1;
  if ( v5 + 1 <= v6 )
  {
    v11 = (_BYTE *)*a2;
  }
  else
  {
    v8 = v5 + 993;
    v9 = (_BYTE *)*a2;
    if ( 2 * v6 <= v8 )
      v10 = v8;
    else
      v10 = 2 * v6;
    a2[2] = v10;
    v11 = realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      std::terminate();
    v5 = a2[1];
    v7 = v5 + 1;
  }
  a2[1] = v7;
  v11[v5] = 64;
  v12 = *(_QWORD *)(a1 + 16);
  result = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v12 + 32LL))(v12, a2);
  if ( (*(_WORD *)(v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v12 + 40LL))(v12, a2);
  return result;
}

//----- (000000000005E4D4) ----------------------------------------------------
__int64 __fastcall sub_5E4D4(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 48LL))(*(_QWORD *)(a1 + 24));
}

//----- (000000000005E4E8) ----------------------------------------------------
void __fastcall sub_5E4E8(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E4F0) ----------------------------------------------------
__int64 __fastcall sub_5E4F0(__int64 a1, void **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  void *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = (char *)a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 2) <= v6 )
  {
    v11 = (char *)*a2;
  }
  else
  {
    v7 = (size_t)(v5 + 994);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (void *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      std::terminate();
    v5 = (char *)a2[1];
  }
  *(_WORD *)&v5[(_QWORD)v11] = 14906;
  v12 = *(__int64 **)(a1 + 24);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 2;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005E5FC) ----------------------------------------------------
__int64 __fastcall sub_5E5FC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 48LL))(*(_QWORD *)(a1 + 24));
}

//----- (000000000005E610) ----------------------------------------------------
void __fastcall sub_5E610(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E618) ----------------------------------------------------
unsigned __int8 *__fastcall sub_5E618(unsigned __int8 *result, unsigned __int8 *a2)
{
  int v2; // w8
  int v3; // w8
  unsigned __int8 *v4; // x8
  int v5; // w9
  unsigned __int8 *v6; // x8
  int v7; // t1

  if ( result != a2 )
  {
    v2 = *result;
    if ( v2 == 95 )
    {
      if ( result + 1 != a2 )
      {
        v3 = result[1];
        if ( (unsigned int)(v3 - 58) >= 0xFFFFFFF6 )
        {
          result += 2;
        }
        else if ( v3 == 95 )
        {
          v4 = result + 2;
          if ( result + 2 != a2 )
          {
            while ( 1 )
            {
              v5 = *v4;
              if ( (unsigned int)(v5 - 58) < 0xFFFFFFF6 )
                break;
              if ( ++v4 == a2 )
                return result;
            }
            if ( v5 == 95 )
              return v4 + 1;
          }
        }
      }
    }
    else if ( (unsigned int)(v2 - 58) >= 0xFFFFFFF6 )
    {
      v6 = result + 1;
      while ( v6 != a2 )
      {
        v7 = *v6++;
        if ( (unsigned int)(v7 - 58) <= 0xFFFFFFF5 )
          return result;
      }
      return a2;
    }
  }
  return result;
}

//----- (000000000005E6C8) ----------------------------------------------------
_QWORD *__fastcall sub_5E6C8(__int64 a1, char *s)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x20
  size_t v9; // x0
  __int16 v10; // w9
  char *v11; // x10
  _QWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  v9 = strlen(s);
  v10 = *(_WORD *)((char *)v8 - 7);
  *((_BYTE *)v8 - 8) = 7;
  *(v8 - 2) = off_6FBA8;
  v11 = &s[v9];
  result = v8 - 2;
  *(_WORD *)((char *)v8 - 7) = v10 & 0xF000 | 0x540;
  *v8 = s;
  v8[1] = v11;
  return result;
}
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();

//----- (000000000005E778) ----------------------------------------------------
_QWORD *__fastcall sub_5E778(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x11
  _QWORD *result; // x0
  __int64 v13; // x10

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *((_BYTE *)v10 - 8) = 24;
  v11 = *a3;
  *(v10 - 2) = off_716B8;
  result = v10 - 2;
  v13 = *a2;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x540;
  *v10 = v13;
  v10[1] = v11;
  return result;
}
// 716B8: using guessed type __int64 (__fastcall *off_716B8[10])();

//----- (000000000005E824) ----------------------------------------------------
__int64 __fastcall sub_5E824(__int64 a1, void **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  void *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = (char *)a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 2) <= v6 )
  {
    v11 = (char *)*a2;
  }
  else
  {
    v7 = (size_t)(v5 + 994);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (void *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      std::terminate();
    v5 = (char *)a2[1];
  }
  *(_WORD *)&v5[(_QWORD)v11] = 14906;
  v12 = *(__int64 **)(a1 + 24);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 2;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (000000000005E930) ----------------------------------------------------
void __fastcall sub_5E930(void *a1)
{
  operator delete(a1);
}

//----- (000000000005E938) ----------------------------------------------------
__int64 __fastcall sub_5E938(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x0
  unsigned int v4; // w8
  __int64 v6; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(a1 + 24) > v2 )
      goto LABEL_3;
    return 0;
  }
  v2 = 0;
  v6 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if ( !v6 )
    return 0;
LABEL_3:
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v2);
  v4 = *(unsigned __int8 *)(v3 + 9);
  if ( (v4 & 0xC0) == 0x80 )
    return (**(__int64 (__fastcall ***)(__int64))v3)(v3);
  else
    return v4 < 0x40;
}

//----- (000000000005E9A4) ----------------------------------------------------
__int64 __fastcall sub_5E9A4(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  _BYTE *v3; // x0
  int v4; // w8
  __int64 v6; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(a1 + 24) > v2 )
      goto LABEL_3;
    return 0;
  }
  v2 = 0;
  v6 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if ( !v6 )
    return 0;
LABEL_3:
  v3 = *(_BYTE **)(*(_QWORD *)(a1 + 16) + 8 * v2);
  v4 = v3[10] & 3;
  if ( v4 == 2 )
    return (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v3 + 8LL))(v3);
  else
    return v4 == 0;
}

//----- (000000000005EA10) ----------------------------------------------------
__int64 __fastcall sub_5EA10(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x0
  int v4; // w8
  __int64 v6; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(a1 + 24) > v2 )
      goto LABEL_3;
    return 0;
  }
  v2 = 0;
  v6 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v6;
  if ( !v6 )
    return 0;
LABEL_3:
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v2);
  v4 = (*(unsigned __int16 *)(v3 + 9) >> 10) & 3;
  if ( v4 == 2 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
  else
    return v4 == 0;
}

//----- (000000000005EA7C) ----------------------------------------------------
__int64 __fastcall sub_5EA7C(__int64 result, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x0
  __int64 v4; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(result + 24) <= v2 )
      return result;
    goto LABEL_3;
  }
  v2 = 0;
  v4 = *(_QWORD *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v4;
  if ( v4 )
  {
LABEL_3:
    v3 = *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * v2);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3);
  }
  return result;
}

//----- (000000000005EAC8) ----------------------------------------------------
__int64 __fastcall sub_5EAC8(__int64 result, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x0
  __int64 v4; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(result + 24) <= v2 )
      return result;
    goto LABEL_3;
  }
  v2 = 0;
  v4 = *(_QWORD *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v4;
  if ( v4 )
  {
LABEL_3:
    v3 = *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * v2);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 32LL))(v3);
  }
  return result;
}

//----- (000000000005EB14) ----------------------------------------------------
__int64 __fastcall sub_5EB14(__int64 result, __int64 a2)
{
  unsigned __int64 v2; // x8
  __int64 v3; // x0
  __int64 v4; // x9

  if ( *(_DWORD *)(a2 + 28) != -1 )
  {
    v2 = *(unsigned int *)(a2 + 24);
    if ( *(_QWORD *)(result + 24) <= v2 )
      return result;
    goto LABEL_3;
  }
  v2 = 0;
  v4 = *(_QWORD *)(result + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = v4;
  if ( v4 )
  {
LABEL_3:
    v3 = *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * v2);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 40LL))(v3);
  }
  return result;
}

//----- (000000000005EB60) ----------------------------------------------------
void __fastcall sub_5EB60(void *a1)
{
  operator delete(a1);
}

//----- (000000000005EB68) ----------------------------------------------------
_BYTE *__fastcall sub_5EB68(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  int v6; // w21
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 v12; // x22
  __int64 v13; // x8
  __int64 v14; // x23
  char v15; // w24
  __int64 v16; // x26
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x8
  char *v25; // x0
  size_t v26; // x1
  _BYTE *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v6 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  if ( v2 + 1 <= v3 )
  {
    v11 = *(char **)a2;
  }
  else
  {
    v7 = v2 + 993;
    v8 = 2 * v3;
    v9 = *(char **)a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    *(_QWORD *)(a2 + 16) = v10;
    v11 = (char *)realloc(v9, v10);
    *(_QWORD *)a2 = v11;
    if ( !v11 )
      goto LABEL_30;
    v2 = *(_QWORD *)(a2 + 8);
  }
  v11[v2] = 60;
  v12 = *(_QWORD *)(a2 + 8) + 1LL;
  v13 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 8) = v12;
  if ( v13 )
  {
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = *(_QWORD *)(a2 + 16);
        if ( v12 + 2 <= v17 )
        {
          v21 = *(char **)a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *(char **)a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          *(_QWORD *)(a2 + 16) = v20;
          v21 = (char *)realloc(v19, v20);
          *(_QWORD *)a2 = v21;
          if ( !v21 )
            goto LABEL_30;
          v22 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v16;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 16) + 8 * v14), a2, 18, 0);
      if ( v16 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v12;
        if ( ++v14 == *(_QWORD *)(a1 + 24) )
          break;
      }
      else
      {
        v15 = 0;
        v12 = *(_QWORD *)(a2 + 8);
        if ( ++v14 == *(_QWORD *)(a1 + 24) )
          break;
      }
    }
  }
  v23 = *(_QWORD *)(a2 + 16);
  if ( v12 + 1 <= v23 )
  {
    result = *(_BYTE **)a2;
    goto LABEL_29;
  }
  v24 = 2 * v23;
  v25 = *(char **)a2;
  if ( v24 <= v12 + 993 )
    v26 = v12 + 993;
  else
    v26 = v24;
  *(_QWORD *)(a2 + 16) = v26;
  result = realloc(v25, v26);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_30:
    std::terminate();
  v12 = *(_QWORD *)(a2 + 8);
LABEL_29:
  result[v12] = 62;
  ++*(_QWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 32) = v6;
  return result;
}

//----- (000000000005ED2C) ----------------------------------------------------
void __fastcall sub_5ED2C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005ED34) ----------------------------------------------------
__int64 __fastcall sub_5ED34(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v5; // x20
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = *(_QWORD *)(a1 + 24);
  result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 32LL))(v5, a2);
  if ( (*(_WORD *)(v5 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 40LL))(v5, a2);
  return result;
}

//----- (000000000005EDE8) ----------------------------------------------------
__int64 __fastcall sub_5EDE8(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 48LL))(*(_QWORD *)(a1 + 16));
}

//----- (000000000005EDFC) ----------------------------------------------------
void __fastcall sub_5EDFC(void *a1)
{
  operator delete(a1);
}

//----- (000000000005EE04) ----------------------------------------------------
_BYTE *__fastcall sub_5EE04(_BYTE *result, void **a2)
{
  _BYTE *v2; // x19
  __int64 v4; // x21
  __int64 v5; // x22
  char v6; // w23
  __int64 v7; // x25
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  void *v10; // x0
  size_t v11; // x1
  char *v12; // x0
  __int64 v13; // x8

  if ( *((_QWORD *)result + 3) )
  {
    v2 = result;
    v4 = 0;
    v5 = (__int64)a2[1];
    v6 = 1;
    do
    {
      while ( 1 )
      {
        v7 = v5;
        if ( (v6 & 1) == 0 )
        {
          v8 = (unsigned __int64)a2[2];
          if ( v5 + 2 <= v8 )
          {
            v12 = (char *)*a2;
            v13 = v5;
          }
          else
          {
            v9 = 2 * v8;
            v10 = *a2;
            if ( v9 <= v5 + 994 )
              v11 = v5 + 994;
            else
              v11 = v9;
            a2[2] = (void *)v11;
            v12 = (char *)realloc(v10, v11);
            *a2 = v12;
            if ( !v12 )
              std::terminate();
            v13 = (__int64)a2[1];
          }
          *(_WORD *)&v12[v13] = 8236;
          v7 = (__int64)a2[1] + 2;
          a2[1] = (void *)v7;
        }
        result = sub_56990(*(__int64 **)(*((_QWORD *)v2 + 2) + 8 * v4), (__int64)a2, 18, 0);
        if ( (void *)v7 != a2[1] )
          break;
        a2[1] = (void *)v5;
        if ( ++v4 == *((_QWORD *)v2 + 3) )
          return result;
      }
      v6 = 0;
      v5 = (__int64)a2[1];
      ++v4;
    }
    while ( v4 != *((_QWORD *)v2 + 3) );
  }
  return result;
}

//----- (000000000005EF10) ----------------------------------------------------
void __fastcall sub_5EF10(void *a1)
{
  operator delete(a1);
}

//----- (000000000005EF18) ----------------------------------------------------
char *__fastcall sub_5EF18(__int64 a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x21
  __int64 v13; // x8
  __int64 v14; // x22
  char v15; // w23
  __int64 v16; // x25
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  char *v26; // x0
  size_t v27; // x1
  char *result; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 12) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1004);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_30;
    v2 = a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  *((_DWORD *)v11 + 2) = 979790175;
  *(_QWORD *)v11 = *(_QWORD *)" [enable_if:";
  v12 = (__int64)(a2[1] + 12);
  v13 = *(_QWORD *)(a1 + 24);
  a2[1] = (char *)v12;
  if ( v13 )
  {
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = (unsigned __int64)a2[2];
        if ( v12 + 2 <= v17 )
        {
          v21 = *a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          a2[2] = (char *)v20;
          v21 = (char *)realloc(v19, v20);
          *a2 = v21;
          if ( !v21 )
            goto LABEL_30;
          v22 = (__int64)a2[1];
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = (__int64)(a2[1] + 2);
        a2[1] = (char *)v16;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 16) + 8 * v14), (__int64)a2, 18, 0);
      if ( (char *)v16 == a2[1] )
      {
        a2[1] = (char *)v12;
        if ( ++v14 == *(_QWORD *)(a1 + 24) )
          break;
      }
      else
      {
        v15 = 0;
        v12 = (__int64)a2[1];
        if ( ++v14 == *(_QWORD *)(a1 + 24) )
          break;
      }
    }
  }
  v23 = (unsigned __int64)a2[2];
  v24 = v12 + 1;
  if ( v12 + 1 <= v23 )
  {
    result = *a2;
    goto LABEL_29;
  }
  v25 = 2 * v23;
  v26 = *a2;
  if ( v25 <= v12 + 993 )
    v27 = v12 + 993;
  else
    v27 = v25;
  a2[2] = (char *)v27;
  result = (char *)realloc(v26, v27);
  *a2 = result;
  if ( !result )
LABEL_30:
    std::terminate();
  v12 = (__int64)a2[1];
  v24 = v12 + 1;
LABEL_29:
  a2[1] = (char *)v24;
  result[v12] = 93;
  return result;
}

//----- (000000000005F0DC) ----------------------------------------------------
void __fastcall sub_5F0DC(void *a1)
{
  operator delete(a1);
}

//----- (000000000005F0E4) ----------------------------------------------------
__int64 sub_5F0E4()
{
  return 1;
}

//----- (000000000005F0F0) ----------------------------------------------------
__int64 sub_5F0F0()
{
  return 1;
}

//----- (000000000005F0FC) ----------------------------------------------------
__int64 __fastcall sub_5F0FC(__int64 a1, _QWORD *a2)
{
  __int64 v3; // x0
  __int64 v5; // x0
  unsigned int v6; // w8
  __int64 v7; // x8
  unsigned __int64 v8; // x9
  size_t v9; // x8
  unsigned __int64 v10; // x9
  _BYTE *v11; // x0
  size_t v12; // x1
  _BYTE *v13; // x0
  __int64 v14; // x20
  __int64 result; // x0

  v3 = *(_QWORD *)(a1 + 16);
  if ( !v3 )
    goto LABEL_14;
  (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v3 + 32LL))(v3, a2);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(unsigned __int8 *)(v5 + 9);
  if ( (v6 & 0xC0) == 0x80 )
  {
    if ( ((**(__int64 (__fastcall ***)(__int64, _QWORD *))v5)(v5, a2) & 1) != 0 )
      goto LABEL_14;
  }
  else if ( v6 < 0x40 )
  {
    goto LABEL_14;
  }
  v7 = a2[1];
  v8 = a2[2];
  if ( v7 + 1 <= v8 )
  {
    v13 = (_BYTE *)*a2;
  }
  else
  {
    v9 = v7 + 993;
    v10 = 2 * v8;
    v11 = (_BYTE *)*a2;
    if ( v10 <= v9 )
      v12 = v9;
    else
      v12 = v10;
    a2[2] = v12;
    v13 = realloc(v11, v12);
    *a2 = v13;
    if ( !v13 )
      std::terminate();
    v7 = a2[1];
  }
  v13[v7] = 32;
  ++a2[1];
LABEL_14:
  v14 = *(_QWORD *)(a1 + 24);
  result = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v14 + 32LL))(v14, a2);
  if ( (*(_WORD *)(v14 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v14 + 40LL))(v14, a2);
  return result;
}

//----- (000000000005F210) ----------------------------------------------------
char *__fastcall sub_5F210(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 *v5; // x21
  unsigned __int64 v6; // x10
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x22
  char *v13; // x0
  __int64 v14; // x23
  char v15; // w24
  __int64 v16; // x26
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  _BYTE *v27; // x0
  __int64 v28; // x22
  char *result; // x0
  char *v30; // x0
  int v31; // w8
  __int64 v32; // x8
  unsigned __int64 v33; // x9
  size_t v34; // x8
  unsigned __int64 v35; // x9
  char *v36; // x0
  size_t v37; // x1
  char *v38; // x8
  __int64 v39; // x8
  unsigned __int64 v40; // x9
  size_t v41; // x8
  unsigned __int64 v42; // x9
  char *v43; // x0
  size_t v44; // x1
  char *v45; // x8
  __int64 v46; // x8
  unsigned __int64 v47; // x9
  size_t v48; // x8
  unsigned __int64 v49; // x9
  char *v50; // x0
  size_t v51; // x1
  char *v52; // x8
  int v53; // w8
  __int64 v54; // x8
  unsigned __int64 v55; // x9
  size_t v56; // x8
  unsigned __int64 v57; // x9
  char *v58; // x0
  size_t v59; // x1
  __int64 v60; // x8
  unsigned __int64 v61; // x9
  size_t v62; // x8
  unsigned __int64 v63; // x9
  char *v64; // x0
  size_t v65; // x1
  __int64 v66; // x9
  char *v67; // x8
  __int64 v68; // x20

  v5 = (__int64 *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 32);
  if ( v4 + 1 <= v6 )
  {
    v13 = *(char **)a2;
    *v5 = v4 + 1;
    v13[v4] = 40;
    v12 = *v5;
    if ( !*(_QWORD *)(a1 + 40) )
      goto LABEL_22;
LABEL_9:
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = *(_QWORD *)(a2 + 16);
        if ( v12 + 2 <= v17 )
        {
          v21 = *(char **)a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *(char **)a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          *(_QWORD *)(a2 + 16) = v20;
          v21 = (char *)realloc(v19, v20);
          *(_QWORD *)a2 = v21;
          if ( !v21 )
            goto LABEL_81;
          v22 = *v5;
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = *v5 + 2;
        *v5 = v16;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 32) + 8 * v14), a2, 18, 0);
      if ( v16 == *(_QWORD *)(a2 + 8) )
      {
        *v5 = v12;
        if ( ++v14 == *(_QWORD *)(a1 + 40) )
          goto LABEL_22;
      }
      else
      {
        v15 = 0;
        v12 = *(_QWORD *)(a2 + 8);
        if ( ++v14 == *(_QWORD *)(a1 + 40) )
          goto LABEL_22;
      }
    }
  }
  v7 = v4 + 993;
  v8 = *(char **)a2;
  if ( 2 * v6 <= v7 )
    v9 = v7;
  else
    v9 = 2 * v6;
  *(_QWORD *)(a2 + 16) = v9;
  v10 = realloc(v8, v9);
  *(_QWORD *)a2 = v10;
  if ( !v10 )
    goto LABEL_81;
  v11 = (*v5)++;
  v10[v11] = 40;
  v12 = *v5;
  if ( *(_QWORD *)(a1 + 40) )
    goto LABEL_9;
LABEL_22:
  v23 = *(_QWORD *)(a2 + 16);
  --*(_DWORD *)(a2 + 32);
  if ( v12 + 1 <= v23 )
  {
    v30 = *(char **)a2;
    *v5 = v12 + 1;
    v30[v12] = 41;
    result = *(char **)(a1 + 16);
    if ( !result )
      goto LABEL_31;
    goto LABEL_30;
  }
  v24 = 2 * v23;
  v25 = *(char **)a2;
  if ( v24 <= v12 + 993 )
    v26 = v12 + 993;
  else
    v26 = v24;
  *(_QWORD *)(a2 + 16) = v26;
  v27 = realloc(v25, v26);
  *(_QWORD *)a2 = v27;
  if ( !v27 )
    goto LABEL_81;
  v28 = (*v5)++;
  v27[v28] = 41;
  result = *(char **)(a1 + 16);
  if ( result )
LABEL_30:
    result = (char *)(*(__int64 (__fastcall **)(char *, __int64))(*(_QWORD *)result + 40LL))(result, a2);
LABEL_31:
  v31 = *(_DWORD *)(a1 + 56);
  if ( (v31 & 1) != 0 )
  {
    v32 = *(_QWORD *)(a2 + 8);
    v33 = *(_QWORD *)(a2 + 16);
    if ( v32 + 6 <= v33 )
    {
      result = *(char **)a2;
    }
    else
    {
      v34 = v32 + 998;
      v35 = 2 * v33;
      v36 = *(char **)a2;
      if ( v35 <= v34 )
        v37 = v34;
      else
        v37 = v35;
      *(_QWORD *)(a2 + 16) = v37;
      result = (char *)realloc(v36, v37);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_81;
      v32 = *v5;
    }
    v38 = &result[v32];
    *((_WORD *)v38 + 2) = 29811;
    *(_DWORD *)v38 = 1852793632;
    v31 = *(_DWORD *)(a1 + 56);
    *v5 += 6;
  }
  if ( (v31 & 2) != 0 )
  {
    v39 = *(_QWORD *)(a2 + 8);
    v40 = *(_QWORD *)(a2 + 16);
    if ( v39 + 9 <= v40 )
    {
      result = *(char **)a2;
    }
    else
    {
      v41 = v39 + 1001;
      v42 = 2 * v40;
      v43 = *(char **)a2;
      if ( v42 <= v41 )
        v44 = v41;
      else
        v44 = v42;
      *(_QWORD *)(a2 + 16) = v44;
      result = (char *)realloc(v43, v44);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_81;
      v39 = *v5;
    }
    v45 = &result[v39];
    v45[8] = 101;
    *(_QWORD *)v45 = *(_QWORD *)" volatile";
    v31 = *(_DWORD *)(a1 + 56);
    *v5 += 9;
  }
  if ( (v31 & 4) != 0 )
  {
    v46 = *(_QWORD *)(a2 + 8);
    v47 = *(_QWORD *)(a2 + 16);
    if ( v46 + 9 <= v47 )
    {
      result = *(char **)a2;
    }
    else
    {
      v48 = v46 + 1001;
      v49 = 2 * v47;
      v50 = *(char **)a2;
      if ( v49 <= v48 )
        v51 = v48;
      else
        v51 = v49;
      *(_QWORD *)(a2 + 16) = v51;
      result = (char *)realloc(v50, v51);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_81;
      v46 = *v5;
    }
    v52 = &result[v46];
    v52[8] = 116;
    *(_QWORD *)v52 = *(_QWORD *)" restrict";
    *v5 += 9;
  }
  v53 = *(unsigned __int8 *)(a1 + 60);
  if ( v53 == 2 )
  {
    v60 = *(_QWORD *)(a2 + 8);
    v61 = *(_QWORD *)(a2 + 16);
    if ( v60 + 3 <= v61 )
    {
      result = *(char **)a2;
    }
    else
    {
      v62 = v60 + 995;
      v63 = 2 * v61;
      v64 = *(char **)a2;
      if ( v63 <= v62 )
        v65 = v62;
      else
        v65 = v63;
      *(_QWORD *)(a2 + 16) = v65;
      result = (char *)realloc(v64, v65);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_81;
      v60 = *v5;
    }
    v67 = &result[v60];
    v66 = 3;
    v67[2] = 38;
    *(_WORD *)v67 = 9760;
    goto LABEL_76;
  }
  if ( v53 != 1 )
    goto LABEL_77;
  v54 = *(_QWORD *)(a2 + 8);
  v55 = *(_QWORD *)(a2 + 16);
  if ( v54 + 2 <= v55 )
  {
    result = *(char **)a2;
    goto LABEL_73;
  }
  v56 = v54 + 994;
  v57 = 2 * v55;
  v58 = *(char **)a2;
  if ( v57 <= v56 )
    v59 = v56;
  else
    v59 = v57;
  *(_QWORD *)(a2 + 16) = v59;
  result = (char *)realloc(v58, v59);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_81:
    std::terminate();
  v54 = *v5;
LABEL_73:
  v66 = 2;
  *(_WORD *)&result[v54] = 9760;
LABEL_76:
  *v5 += v66;
LABEL_77:
  v68 = *(_QWORD *)(a1 + 48);
  if ( v68 )
  {
    result = (char *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v68 + 32LL))(v68, a2);
    if ( (*(_WORD *)(v68 + 9) & 0xC0) != 0x40 )
      return (char *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v68 + 40LL))(v68, a2);
  }
  return result;
}

//----- (000000000005F68C) ----------------------------------------------------
void __fastcall sub_5F68C(void *a1)
{
  operator delete(a1);
}

//----- (000000000005F694) ----------------------------------------------------
char *__fastcall sub_5F694(_QWORD *a1, char **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 v12; // x8
  _BYTE *v13; // x9
  _BYTE *v14; // x21
  size_t v15; // x20
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  unsigned __int64 v22; // x9
  size_t v23; // x8
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  char *result; // x0

  v2 = a1[2];
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 2) <= v6 )
  {
    v11 = *a2;
  }
  else
  {
    v7 = (size_t)(v5 + 994);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (char *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      goto LABEL_27;
    v5 = a2[1];
  }
  *(_WORD *)&v5[(_QWORD)v11] = 10272;
  v12 = (__int64)(a2[1] + 2);
  a2[1] = (char *)v12;
  v14 = (_BYTE *)a1[3];
  v13 = (_BYTE *)a1[4];
  v15 = v13 - v14;
  if ( v13 != v14 )
  {
    v16 = (size_t)a2[2];
    v17 = v12 + v15;
    if ( v12 + v15 <= v16 )
    {
      v21 = *a2;
    }
    else
    {
      v18 = 2 * v16;
      v19 = *a2;
      if ( v18 <= v17 + 992 )
        v20 = v17 + 992;
      else
        v20 = v18;
      a2[2] = (char *)v20;
      v21 = (char *)realloc(v19, v20);
      *a2 = v21;
      if ( !v21 )
        goto LABEL_27;
      v12 = (__int64)a2[1];
    }
    memcpy(&v21[v12], v14, v15);
    v12 = (__int64)&a2[1][v15];
    a2[1] = (char *)v12;
  }
  v22 = (unsigned __int64)a2[2];
  if ( v12 + 1 <= v22 )
  {
    result = *a2;
    goto LABEL_26;
  }
  v23 = v12 + 993;
  v24 = 2 * v22;
  v25 = *a2;
  if ( v24 <= v23 )
    v26 = v23;
  else
    v26 = v24;
  a2[2] = (char *)v26;
  result = (char *)realloc(v25, v26);
  *a2 = result;
  if ( !result )
LABEL_27:
    std::terminate();
  v12 = (__int64)a2[1];
LABEL_26:
  result[v12] = 41;
  ++a2[1];
  return result;
}

//----- (000000000005F810) ----------------------------------------------------
void __fastcall sub_5F810(void *a1)
{
  operator delete(a1);
}

//----- (000000000005F818) ----------------------------------------------------
char *__fastcall sub_5F818(const char **a1)
{
  const char *v1; // x20
  const char *v2; // x22
  int v4; // w28
  char **v5; // x21
  const char *v6; // x20
  const char *v7; // x22
  const char *v8; // x9
  const char *v9; // x10
  const char *v10; // x8
  unsigned __int64 v11; // x20
  const char *v12; // x24
  char *v13; // x8
  char *result; // x0
  char *v15; // x22
  const char **v16; // x0
  signed __int64 v17; // x23
  char *v18; // x0
  const char *v19; // x21
  __int64 v20; // x8
  char *v21; // x0
  __int64 v22; // x8
  char **v23; // x21
  __int64 (__fastcall **v24)(); // x8
  char *v25; // x20
  const char *v26; // x8
  const char *v27; // x25
  const char *v28; // x27
  char *v29; // x8
  char v30; // w26
  char *v31; // x25
  const char **v32; // x0
  signed __int64 v33; // x26
  char *v34; // x0
  const char *v35; // x9
  const char *v36; // x21
  char *v37; // x20
  __int64 v38; // x8
  char *v39; // x0
  __int64 v40; // x8
  __int64 v41; // x8
  char *v42; // x0
  const char *v43; // x24
  char *v44; // x23
  __int64 v45; // x1
  __int64 v46; // x22
  __int64 v47; // x8
  char *v48; // x0
  __int64 v49; // x8
  char *v50; // x9
  __int16 v51; // w10
  char *v52; // x0
  const char *v53; // x21
  char *v54; // x20
  char *v55; // x1
  char *v56; // x22
  __int64 v57; // x8
  char *v58; // x0
  __int64 v59; // x8
  unsigned __int64 v60; // [xsp+8h] [xbp-8h]

  v1 = *a1;
  v2 = a1[1];
  if ( *a1 == v2 || *v1 != 114 )
  {
    v4 = 0;
    if ( v1 == v2 )
      goto LABEL_4;
  }
  else
  {
    ++v1;
    v4 = 4;
    *a1 = v1;
    if ( v1 == v2 )
    {
LABEL_4:
      v1 = v2;
      goto LABEL_12;
    }
  }
  if ( *v1 == 86 )
  {
    ++v1;
    v4 |= 2u;
    *a1 = v1;
  }
  if ( v1 == v2 )
    goto LABEL_13;
  if ( *v1 == 75 )
  {
    ++v1;
    v4 |= 1u;
    *a1 = v1;
    if ( (unsigned __int64)(v2 - v1) < 2 )
      goto LABEL_13;
    goto LABEL_16;
  }
LABEL_12:
  if ( (unsigned __int64)(v2 - v1) < 2 )
    goto LABEL_13;
LABEL_16:
  if ( !strncmp("Do", v1, 2u) )
  {
    v19 = a1[614];
    v20 = *((_QWORD *)v19 + 1);
    *a1 = v1 + 2;
    if ( (unsigned __int64)(v20 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v21 = (char *)malloc(0x1000u);
      if ( !v21 )
        goto LABEL_81;
      v20 = 0;
      *(_QWORD *)v21 = v19;
      *((_QWORD *)v21 + 1) = 0;
      v19 = v21;
      a1[614] = v21;
    }
    v22 = v20 + 32;
    *((_QWORD *)v19 + 1) = v22;
    v23 = (char **)&v19[v22];
    LOWORD(v22) = *(_WORD *)((char *)v23 - 7);
    *((_BYTE *)v23 - 8) = 7;
    *(_WORD *)((char *)v23 - 7) = v22 & 0xF000 | 0x540;
    v24 = off_6FBA8;
    *v23 = "noexcept";
    v23[1] = "";
    goto LABEL_34;
  }
  if ( !strncmp("DO", v1, 2u) )
  {
    *a1 = v1 + 2;
    result = sub_52694((__int64)a1);
    if ( !result )
      return result;
    v35 = *a1;
    if ( *a1 == a1[1] || *v35 != 69 )
      return 0;
    v36 = a1[614];
    v37 = result;
    v38 = *((_QWORD *)v36 + 1);
    *a1 = v35 + 1;
    if ( (unsigned __int64)(v38 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v39 = (char *)malloc(0x1000u);
      if ( !v39 )
        goto LABEL_81;
      v38 = 0;
      *(_QWORD *)v39 = v36;
      *((_QWORD *)v39 + 1) = 0;
      v36 = v39;
      a1[614] = v39;
    }
    v40 = v38 + 32;
    *((_QWORD *)v36 + 1) = v40;
    v23 = (char **)&v36[v40];
    LOWORD(v40) = *(_WORD *)((char *)v23 - 7);
    *((_BYTE *)v23 - 8) = 16;
    *v23 = v37;
    *(_WORD *)((char *)v23 - 7) = v40 & 0xF000 | 0x540;
    v24 = off_71A38;
LABEL_34:
    *(v23 - 2) = (char *)v24;
    v5 = v23 - 2;
    v6 = *a1;
    v7 = a1[1];
    if ( (unsigned __int64)(v7 - *a1) < 2 )
      goto LABEL_36;
    goto LABEL_35;
  }
  if ( !strncmp("Dw", v1, 2u) )
  {
    v8 = a1[2];
    v9 = a1[3];
    v10 = v1 + 2;
    *a1 = v1 + 2;
    v11 = (v9 - v8) >> 3;
    while ( v10 == v2 || *v10 != 69 )
    {
      result = (char *)sub_4DAC4(a1);
      if ( !result )
        return result;
      v13 = (char *)a1[3];
      v15 = result;
      if ( v13 == a1[4] )
      {
        v16 = (const char **)a1[2];
        v17 = v13 - (char *)v16;
        if ( v16 == a1 + 5 )
        {
          v18 = (char *)malloc(2 * (v13 - (char *)v16));
          if ( !v18 )
            goto LABEL_81;
          v12 = v18;
          memcpy(v18, a1 + 5, v17);
          a1[2] = v12;
        }
        else
        {
          v12 = (const char *)realloc(v16, 2 * (v13 - (char *)v16));
          a1[2] = v12;
          if ( !v12 )
            goto LABEL_81;
        }
        v13 = (char *)&v12[v17];
        a1[4] = &v12[8 * (v17 >> 2)];
      }
      a1[3] = v13 + 8;
      *(_QWORD *)v13 = v15;
      v10 = *a1;
      v2 = a1[1];
    }
    *a1 = v10 + 1;
    v52 = sub_4F750(a1, v11);
    v53 = a1[614];
    v54 = v52;
    v56 = v55;
    v57 = *((_QWORD *)v53 + 1);
    if ( (unsigned __int64)(v57 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v58 = (char *)malloc(0x1000u);
      if ( !v58 )
        goto LABEL_81;
      v57 = 0;
      *(_QWORD *)v58 = v53;
      *((_QWORD *)v58 + 1) = 0;
      v53 = v58;
      a1[614] = v58;
    }
    v59 = v57 + 32;
    *((_QWORD *)v53 + 1) = v59;
    v23 = (char **)&v53[v59];
    LOWORD(v59) = *(_WORD *)((char *)v23 - 7);
    *((_BYTE *)v23 - 8) = 17;
    *v23 = v54;
    v23[1] = v56;
    *(_WORD *)((char *)v23 - 7) = v59 & 0xF000 | 0x540;
    v24 = off_71AA8;
    goto LABEL_34;
  }
LABEL_13:
  v5 = 0;
  v6 = *a1;
  v7 = a1[1];
  if ( (unsigned __int64)(v7 - *a1) < 2 )
    goto LABEL_36;
LABEL_35:
  if ( !strncmp("Dx", v6, 2u) )
  {
    v6 += 2;
    *a1 = v6;
    if ( v6 == v7 )
      return 0;
    goto LABEL_37;
  }
LABEL_36:
  if ( v6 == v7 )
    return 0;
LABEL_37:
  if ( *v6 != 70 )
    return 0;
  *a1 = v6 + 1;
  if ( v6 + 1 != v7 && v6[1] == 89 )
    *a1 = v6 + 2;
  result = (char *)sub_4DAC4(a1);
  if ( !result )
    return result;
  v25 = result;
  v60 = (a1[3] - a1[2]) >> 3;
  v27 = *a1;
  v26 = a1[1];
  if ( *a1 != v26 )
    goto LABEL_45;
LABEL_51:
  while ( (unsigned __int64)(v26 - v27) < 2 )
  {
LABEL_54:
    result = (char *)sub_4DAC4(a1);
    if ( !result )
      return result;
    v29 = (char *)a1[3];
    v31 = result;
    if ( v29 == a1[4] )
    {
      v32 = (const char **)a1[2];
      v33 = v29 - (char *)v32;
      if ( v32 == a1 + 5 )
      {
        v34 = (char *)malloc(2 * (v29 - (char *)v32));
        if ( !v34 )
          goto LABEL_81;
        v28 = v34;
        memcpy(v34, a1 + 5, v33);
        a1[2] = v28;
      }
      else
      {
        v28 = (const char *)realloc(v32, 2 * (v29 - (char *)v32));
        a1[2] = v28;
        if ( !v28 )
          goto LABEL_81;
      }
      v29 = (char *)&v28[v33];
      a1[4] = &v28[8 * (v33 >> 2)];
    }
    a1[3] = v29 + 8;
    *(_QWORD *)v29 = v31;
    v27 = *a1;
    v26 = a1[1];
    if ( *a1 != v26 )
    {
LABEL_45:
      while ( *v27 != 69 )
      {
        if ( *v27 == 118 )
        {
          *a1 = v27 + 1;
          v27 = *a1;
          v26 = a1[1];
          if ( *a1 != v26 )
            continue;
        }
        goto LABEL_51;
      }
      v30 = 0;
      v41 = 1;
      goto LABEL_73;
    }
  }
  if ( strncmp("RE", v27, 2u) )
  {
    v30 = 2;
    if ( !strncmp("OE", v27, 2u) )
      goto LABEL_72;
    goto LABEL_54;
  }
  v30 = 1;
LABEL_72:
  v41 = 2;
LABEL_73:
  *a1 = &v27[v41];
  v42 = sub_4F750(a1, v60);
  v43 = a1[614];
  v44 = v42;
  v46 = v45;
  v47 = *((_QWORD *)v43 + 1);
  if ( (unsigned __int64)(v47 - 4016) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v48 = (char *)malloc(0x1000u);
    if ( v48 )
    {
      v47 = 0;
      *(_QWORD *)v48 = v43;
      *((_QWORD *)v48 + 1) = 0;
      v43 = v48;
      a1[614] = v48;
      goto LABEL_76;
    }
LABEL_81:
    std::terminate();
  }
LABEL_76:
  v49 = v47 + 64;
  v50 = (char *)&v43[v49];
  *((_QWORD *)v43 + 1) = v49;
  v51 = *(_WORD *)&v43[v49 - 39];
  *((_QWORD *)v50 - 4) = v25;
  *((_QWORD *)v50 - 3) = v44;
  *((_QWORD *)v50 - 2) = v46;
  *(v50 - 40) = 15;
  *((_DWORD *)v50 - 2) = v4;
  *(v50 - 4) = v30;
  *(_QWORD *)v50 = v5;
  *(_WORD *)(v50 - 39) = v51 & 0xF000 | 0x100;
  *((_QWORD *)v50 - 6) = off_71B18;
  return (char *)&v43[v49 - 48];
}
// 5FD20: variable 'v45' is possibly undefined
// 5FDB8: variable 'v55' is possibly undefined
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 71A38: using guessed type __int64 (__fastcall *off_71A38[10])();
// 71AA8: using guessed type __int64 (__fastcall *off_71AA8[10])();
// 71B18: using guessed type __int64 (__fastcall *off_71B18[10])();

//----- (000000000005FE28) ----------------------------------------------------
__int64 *__fastcall sub_5FE28(const char **a1)
{
  const char *v1; // x8
  const char *v2; // x21
  unsigned __int64 v4; // x9
  const char *v5; // x10
  const char *v6; // x22
  const char *v7; // x20
  const char *v8; // x22
  const char *v9; // x23
  int v10; // w22
  __int64 v11; // x20
  const char *v12; // x21
  __int64 v13; // x8
  char *v14; // x0
  __int64 v15; // x8
  __int64 *v16; // x9
  __int16 v17; // w10
  unsigned __int64 v18; // x24
  char *v19; // x21
  __int64 v20; // x0
  const char *v21; // x24
  __int64 v22; // x22
  __int64 v23; // x8
  char *v24; // x0
  __int64 v25; // x8
  const char **v26; // x9
  __int64 v27; // x9
  unsigned __int64 v28; // x8
  unsigned __int8 *v29; // x9
  int v30; // t1
  unsigned __int8 *v31; // x24
  const char *v32; // x21
  __int64 v33; // x8
  char *v34; // x0
  __int64 v35; // x8
  unsigned __int8 **v36; // x9
  unsigned __int8 *v37; // x23

  v1 = *a1;
  v2 = a1[1];
  if ( *a1 == v2 )
    goto LABEL_14;
  if ( *v1 != 85 )
  {
    if ( *v1 == 114 )
    {
      ++v1;
      v10 = 4;
      *a1 = v1;
      if ( v1 == v2 )
        goto LABEL_20;
LABEL_15:
      if ( *v1 == 86 )
      {
        ++v1;
        v10 |= 2u;
        *a1 = v1;
      }
      if ( v1 != v2 && *v1 == 75 )
      {
        v10 |= 1u;
        *a1 = v1 + 1;
      }
LABEL_20:
      v11 = sub_4DAC4(a1);
      if ( v11 && v10 )
      {
        v12 = a1[614];
        v13 = *((_QWORD *)v12 + 1);
        if ( (unsigned __int64)(v13 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
        {
          v14 = (char *)malloc(0x1000u);
          if ( !v14 )
            goto LABEL_61;
          v13 = 0;
          *(_QWORD *)v14 = v12;
          *((_QWORD *)v14 + 1) = 0;
          v12 = v14;
          a1[614] = v14;
        }
        v15 = v13 + 32;
        v16 = (__int64 *)&v12[v15];
        *((_QWORD *)v12 + 1) = v15;
        LOWORD(v15) = *(_WORD *)&v12[v15 - 7];
        v17 = *(_WORD *)(v11 + 9);
        *v16 = v11;
        *((_BYTE *)v16 - 8) = 3;
        *((_DWORD *)v16 - 1) = v10;
        *(_WORD *)((char *)v16 - 7) = v15 & 0xF000 | v17 & 0xFC0;
        *(v16 - 2) = (__int64)off_71C68;
        return v16 - 2;
      }
      return (__int64 *)v11;
    }
LABEL_14:
    v10 = 0;
    if ( v1 == v2 )
      goto LABEL_20;
    goto LABEL_15;
  }
  *a1 = v1 + 1;
  if ( v2 == v1 + 1 || (unsigned int)*((unsigned __int8 *)v1 + 1) - 58 < 0xFFFFFFF6 )
    return 0;
  v4 = 0;
  v5 = v1 + 2;
  while ( 1 )
  {
    *a1 = v5;
    v6 = v5;
    v4 = *((unsigned __int8 *)v5 - 1) + 10 * v4 - 48;
    if ( v5 == v2 )
      break;
    ++v5;
    if ( (unsigned int)*(unsigned __int8 *)v6 - 48 > 9 )
    {
      v7 = v6;
      if ( v2 - v6 >= v4 )
        goto LABEL_9;
      return 0;
    }
  }
  v7 = v2;
  if ( v4 )
    return 0;
LABEL_9:
  v8 = &v7[v4];
  v9 = &v7[v4];
  *a1 = &v7[v4];
  if ( v7 == &v7[v4] )
    return 0;
  v18 = v4;
  if ( v4 < 9 || strncmp("objcproto", v7, 9u) )
  {
    if ( v2 == v8 || *v8 != 73 )
    {
      v19 = 0;
      v20 = sub_5FE28(a1);
      if ( !v20 )
        return 0;
    }
    else
    {
      v19 = sub_50F00(a1, 0);
      if ( !v19 )
        return 0;
      v20 = sub_5FE28(a1);
      if ( !v20 )
        return 0;
    }
    v21 = a1[614];
    v22 = v20;
    v23 = *((_QWORD *)v21 + 1);
    if ( (unsigned __int64)(v23 - 4032) > 0xFFFFFFFFFFFFF00FLL )
      goto LABEL_40;
    v24 = (char *)malloc(0x1000u);
    if ( v24 )
    {
      v23 = 0;
      *(_QWORD *)v24 = v21;
      *((_QWORD *)v24 + 1) = 0;
      v21 = v24;
      a1[614] = v24;
LABEL_40:
      v25 = v23 + 48;
      v26 = (const char **)&v21[v25];
      *((_QWORD *)v21 + 1) = v25;
      LOWORD(v25) = *(_WORD *)&v21[v25 - 23];
      *(v26 - 2) = (const char *)v22;
      *(v26 - 1) = v7;
      *((_BYTE *)v26 - 24) = 2;
      *v26 = v9;
      v26[1] = v19;
      *(_WORD *)((char *)v26 - 23) = v25 & 0xF000 | 0x540;
      *(v26 - 4) = (const char *)off_71BF8;
      return (__int64 *)(v26 - 4);
    }
LABEL_61:
    std::terminate();
  }
  if ( v18 >= 9 )
    v27 = 9;
  else
    v27 = v9 - v7;
  *a1 = &v7[v27];
  a1[1] = v9;
  if ( &v7[v27] == v9 || (unsigned int)(unsigned __int8)v7[v27] - 58 < 0xFFFFFFF6 )
    goto LABEL_52;
  v28 = 0;
  v29 = (unsigned __int8 *)&v7[v27 + 1];
  while ( 1 )
  {
    *a1 = (const char *)v29;
    v28 = *(v29 - 1) + 10 * v28 - 48;
    if ( v29 == (unsigned __int8 *)v9 )
      break;
    v30 = *v29++;
    if ( (unsigned int)(v30 - 48) > 9 )
    {
      v31 = v29 - 1;
      goto LABEL_51;
    }
  }
  v31 = (unsigned __int8 *)v9;
LABEL_51:
  if ( v9 - (const char *)v31 < v28 )
  {
LABEL_52:
    *a1 = v8;
    a1[1] = v2;
    return 0;
  }
  v37 = &v31[v28];
  *a1 = v8;
  a1[1] = v2;
  if ( v31 == &v31[v28] )
    return 0;
  v11 = sub_5FE28(a1);
  if ( v11 )
  {
    v32 = a1[614];
    v33 = *((_QWORD *)v32 + 1);
    if ( (unsigned __int64)(v33 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v34 = (char *)malloc(0x1000u);
      if ( !v34 )
        goto LABEL_61;
      v33 = 0;
      *(_QWORD *)v34 = v32;
      *((_QWORD *)v34 + 1) = 0;
      v32 = v34;
      a1[614] = v34;
    }
    v35 = v33 + 48;
    v36 = (unsigned __int8 **)&v32[v35];
    *((_QWORD *)v32 + 1) = v35;
    LOWORD(v35) = *(_WORD *)&v32[v35 - 23];
    *(v36 - 2) = (unsigned __int8 *)v11;
    *(v36 - 1) = v31;
    *((_BYTE *)v36 - 24) = 10;
    *v36 = v37;
    *(_WORD *)((char *)v36 - 23) = v35 & 0xF000 | 0x540;
    *(v36 - 4) = (unsigned __int8 *)off_71B88;
    return (__int64 *)(v36 - 4);
  }
  return (__int64 *)v11;
}
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 71B88: using guessed type __int64 (__fastcall *off_71B88[10])();
// 71BF8: using guessed type __int64 (__fastcall *off_71BF8[10])();
// 71C68: using guessed type __int64 (__fastcall *off_71C68[10])();

//----- (0000000000060450) ----------------------------------------------------
_QWORD *__fastcall sub_60450(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 29;
  *(v8 - 2) = off_71CD8;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 71CD8: using guessed type __int64 (__fastcall *off_71CD8[10])();

//----- (00000000000604F4) ----------------------------------------------------
char *__fastcall sub_604F4(__int64 a1, _QWORD *a2, char a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  char *v10; // x9
  char *result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (char *)v3 + v9;
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *(v10 - 8) = 30;
  *(_QWORD *)v10 = *a2;
  *(_WORD *)(v10 - 7) = v9 & 0xF000 | 0x540;
  *((_QWORD *)v10 - 2) = off_71D48;
  result = v10 - 16;
  v10[8] = a3 != 0;
  return result;
}
// 71D48: using guessed type __int64 (__fastcall *off_71D48[10])();

//----- (00000000000605A8) ----------------------------------------------------
char *__fastcall sub_605A8(const char **a1)
{
  const char *v1; // x20
  const char *v2; // x22
  char *result; // x0
  unsigned __int8 *v5; // x21
  unsigned int v6; // w8
  unsigned __int8 *v7; // x20
  const char *v8; // x22
  __int64 v9; // x8
  char *v10; // x0
  __int64 v11; // x8
  char *v12; // x9
  __int64 v13; // x10
  const char *v14; // x8
  const char *v15; // x9
  const char *v16; // x21
  char *v17; // x20
  __int64 v18; // x8
  char *v19; // x0
  __int64 v20; // x8
  char **v21; // x9
  char **v22; // x0
  __int16 v23; // w8
  const char *v24; // x8
  char *v25; // x20
  const char *v26; // x22
  char *v27; // x21
  __int64 v28; // x8
  char *v29; // x0
  __int64 v30; // x8
  char *v31; // [xsp+0h] [xbp-10h] BYREF
  __int64 v32; // [xsp+8h] [xbp-8h] BYREF

  v1 = *a1;
  v2 = a1[1];
  if ( (unsigned __int64)(v2 - *a1) < 2 )
    return 0;
  if ( strncmp("Dv", v1, 2u) )
    return 0;
  v5 = (unsigned __int8 *)(v1 + 2);
  *a1 = v1 + 2;
  if ( v2 == v1 + 2 )
    goto LABEL_27;
  v6 = *v5;
  if ( v6 < 0x31 )
    goto LABEL_27;
  if ( v6 > 0x39 )
  {
    if ( v6 == 95 )
    {
      *a1 = v1 + 3;
      result = (char *)sub_4DAC4(a1);
      if ( !result )
        return result;
      v16 = a1[614];
      v17 = result;
      v18 = *((_QWORD *)v16 + 1);
      if ( (unsigned __int64)(v18 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
      {
        v19 = (char *)malloc(0x1000u);
        if ( !v19 )
          goto LABEL_38;
        v18 = 0;
        *(_QWORD *)v19 = v16;
        *((_QWORD *)v19 + 1) = 0;
        v16 = v19;
        a1[614] = v19;
      }
      v20 = v18 + 32;
      v21 = (char **)&v16[v20];
      v22 = v21;
      *((_QWORD *)v16 + 1) = v20;
      v23 = *(_WORD *)&v16[v20 - 7];
      *((_BYTE *)v21 - 8) = 27;
      *v21 = v17;
      v21[1] = 0;
      goto LABEL_35;
    }
LABEL_27:
    result = sub_52694((__int64)a1);
    if ( !result )
      return result;
    v24 = *a1;
    if ( *a1 == a1[1] || *v24 != 95 )
      return 0;
    v25 = result;
    *a1 = v24 + 1;
    result = (char *)sub_4DAC4(a1);
    if ( !result )
      return result;
    v26 = a1[614];
    v27 = result;
    v28 = *((_QWORD *)v26 + 1);
    if ( (unsigned __int64)(v28 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v29 = (char *)malloc(0x1000u);
      if ( !v29 )
        goto LABEL_38;
      v28 = 0;
      *(_QWORD *)v29 = v26;
      *((_QWORD *)v29 + 1) = 0;
      v26 = v29;
      a1[614] = v29;
    }
    v30 = v28 + 32;
    v21 = (char **)&v26[v30];
    v22 = v21;
    *((_QWORD *)v26 + 1) = v30;
    v23 = *(_WORD *)&v26[v30 - 7];
    *((_BYTE *)v21 - 8) = 27;
    *v21 = v27;
    v21[1] = v25;
LABEL_35:
    *(_WORD *)((char *)v21 - 7) = v23 & 0xF000 | 0x540;
    *(v22 - 2) = (char *)off_71E28;
    return (char *)(v22 - 2);
  }
  v7 = (unsigned __int8 *)(v1 + 2);
  while ( (unsigned int)*v7 - 58 >= 0xFFFFFFF6 )
  {
    *a1 = (const char *)++v7;
    if ( v7 == (unsigned __int8 *)v2 )
    {
      v7 = (unsigned __int8 *)v2;
      break;
    }
  }
  v8 = a1[614];
  v9 = *((_QWORD *)v8 + 1);
  if ( (unsigned __int64)(v9 - 4048) > 0xFFFFFFFFFFFFF00FLL )
    goto LABEL_16;
  v10 = (char *)malloc(0x1000u);
  if ( !v10 )
LABEL_38:
    std::terminate();
  v9 = 0;
  *(_QWORD *)v10 = v8;
  *((_QWORD *)v10 + 1) = 0;
  v8 = v10;
  a1[614] = v10;
LABEL_16:
  v11 = v9 + 32;
  v12 = (char *)&v8[v11];
  *((_QWORD *)v8 + 1) = v11;
  LOWORD(v11) = *(_WORD *)&v8[v11 - 7];
  *(v12 - 8) = 7;
  *(_QWORD *)v12 = v5;
  *((_QWORD *)v12 + 1) = v7;
  *(_WORD *)(v12 - 7) = v11 & 0xF000 | 0x540;
  *((_QWORD *)v12 - 2) = off_6FBA8;
  v13 = (__int64)(v12 - 16);
  v14 = *a1;
  v15 = a1[1];
  v32 = v13;
  if ( v14 == v15 || *v14 != 95 )
    return 0;
  *a1 = v14 + 1;
  if ( v14 + 1 == v15 || v14[1] != 112 )
  {
    result = (char *)sub_4DAC4(a1);
    v31 = result;
    if ( result )
      return (char *)sub_61EAC((__int64)a1, (__int64 *)&v31, &v32);
  }
  else
  {
    *a1 = v14 + 2;
    return (char *)sub_61E08((__int64)a1, &v32);
  }
  return result;
}
// 4DAC4: using guessed type __int64 __fastcall sub_4DAC4(_QWORD);
// 6FBA8: using guessed type __int64 (__fastcall *off_6FBA8[10])();
// 71E28: using guessed type __int64 (__fastcall *off_71E28[10])();

//----- (00000000000608B8) ----------------------------------------------------
char *__fastcall sub_608B8(const char **a1)
{
  const char *v1; // x20
  const char *v4; // x21
  char *v5; // x22
  _QWORD *v6; // x20
  const char *v7; // x23
  __int64 v8; // x8
  char *v9; // x0
  __int64 v10; // x8
  char *v11; // x9

  v1 = *a1;
  if ( (unsigned __int64)(a1[1] - *a1) < 2 )
    return (char *)sub_4ECA0((__int64)a1, 0);
  if ( !strncmp("Ts", v1, 2u) )
  {
    v4 = "struct";
    v5 = "";
  }
  else if ( !strncmp("Tu", v1, 2u) )
  {
    v4 = "union";
    v5 = "";
  }
  else
  {
    if ( strncmp("Te", v1, 2u) )
      return (char *)sub_4ECA0((__int64)a1, 0);
    v4 = "enum";
    v5 = "";
  }
  *a1 = v1 + 2;
  v6 = sub_4ECA0((__int64)a1, 0);
  if ( v6 && v4 != v5 )
  {
    v7 = a1[614];
    v8 = *((_QWORD *)v7 + 1);
    if ( (unsigned __int64)(v8 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
    {
      v9 = (char *)malloc(0x1000u);
      if ( !v9 )
        std::terminate();
      v8 = 0;
      *(_QWORD *)v9 = v7;
      *((_QWORD *)v9 + 1) = 0;
      v7 = v9;
      a1[614] = v9;
    }
    v10 = v8 + 48;
    v11 = (char *)&v7[v10];
    *((_QWORD *)v7 + 1) = v10;
    LOWORD(v10) = *(_WORD *)&v7[v10 - 23];
    *(v11 - 24) = 6;
    *((_QWORD *)v11 - 1) = v5;
    *(_QWORD *)v11 = v6;
    *((_QWORD *)v11 - 2) = v4;
    *(_WORD *)(v11 - 23) = v10 & 0xF000 | 0x540;
    *((_QWORD *)v11 - 4) = off_71F78;
    return v11 - 32;
  }
  return (char *)v6;
}
// 71F78: using guessed type __int64 (__fastcall *off_71F78[10])();

//----- (0000000000060A30) ----------------------------------------------------
_QWORD *__fastcall sub_60A30(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  __int64 v8; // x9
  _QWORD *v9; // x10
  _QWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = *a2;
  v9 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)(v8 + 9) & 0xC0 | 0x500 | *(_WORD *)((_BYTE *)v2 + v7 - 7) & 0xF000;
  *((_BYTE *)v9 - 8) = 11;
  *(v9 - 2) = off_71FE8;
  result = v9 - 2;
  *(_WORD *)((char *)v9 - 7) = v7;
  *v9 = v8;
  return result;
}
// 71FE8: using guessed type __int64 (__fastcall *off_71FE8[10])();

//----- (0000000000060AE0) ----------------------------------------------------
char *__fastcall sub_60AE0(__int64 a1, __int64 *a2, int *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  __int64 v10; // x9
  char *v11; // x10
  int v12; // w12
  char *result; // x0

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = *a2;
  v11 = (char *)v3 + v9;
  v3[1] = v9;
  v12 = *a3;
  LOWORD(v9) = *(_WORD *)(v10 + 9) & 0xC0 | 0x500 | *(_WORD *)((_BYTE *)v3 + v9 - 7) & 0xF000;
  *(v11 - 8) = 12;
  *(_WORD *)(v11 - 7) = v9;
  *((_QWORD *)v11 - 2) = off_72058;
  result = v11 - 16;
  *(_QWORD *)v11 = v10;
  *((_DWORD *)v11 + 2) = v12;
  v11[12] = 0;
  return result;
}
// 72058: using guessed type __int64 (__fastcall *off_72058[10])();

//----- (0000000000060BA0) ----------------------------------------------------
_QWORD *__fastcall sub_60BA0(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  __int64 v9; // x11
  _QWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 5;
  v9 = *a2;
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *(v8 - 2) = v9;
  *(v8 - 1) = " complex";
  *(v8 - 4) = off_720C8;
  result = v8 - 4;
  *v8 = "";
  return result;
}
// 720C8: using guessed type __int64 (__fastcall *off_720C8[10])();

//----- (0000000000060C54) ----------------------------------------------------
_QWORD *__fastcall sub_60C54(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  __int64 v9; // x11
  _QWORD *result; // x0

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4032) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 48;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 23);
  *((_BYTE *)v8 - 24) = 5;
  v9 = *a2;
  *(_WORD *)((char *)v8 - 23) = v7 & 0xF000 | 0x540;
  *(v8 - 2) = v9;
  *(v8 - 1) = " imaginary";
  *(v8 - 4) = off_720C8;
  result = v8 - 4;
  *v8 = "";
  return result;
}
// 720C8: using guessed type __int64 (__fastcall *off_720C8[10])();

//----- (0000000000060D08) ----------------------------------------------------
char *__fastcall sub_60D08(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 v11; // x10
  unsigned __int64 v12; // x11
  __int64 v13; // x8
  int v14; // w12
  __int64 v15; // x9
  char *v16; // x0
  size_t v17; // x1
  char *v18; // x0
  __int64 v19; // x8
  unsigned __int64 v20; // x10
  __int64 v21; // x9
  unsigned __int64 v22; // x8
  char *v23; // x0
  size_t v24; // x1
  char *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  if ( v2 + 8 <= v3 )
  {
    v10 = *(char **)a2;
  }
  else
  {
    v6 = v2 + 1000;
    v7 = 2 * v3;
    v8 = *(char **)a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = (char *)realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_23;
    v2 = *(_QWORD *)(a2 + 8);
  }
  *(_QWORD *)&v10[v2] = 0x7470656378656F6ELL;
  v11 = *(_QWORD *)(a2 + 8);
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 + 8;
  v14 = *(_DWORD *)(a2 + 32) + 1;
  v15 = v11 + 9;
  *(_QWORD *)(a2 + 8) = v11 + 8;
  *(_DWORD *)(a2 + 32) = v14;
  if ( v11 + 9 <= v12 )
  {
    v18 = *(char **)a2;
  }
  else
  {
    v16 = *(char **)a2;
    if ( 2 * v12 <= v11 + 1001 )
      v17 = v11 + 1001;
    else
      v17 = 2 * v12;
    *(_QWORD *)(a2 + 16) = v17;
    v18 = (char *)realloc(v16, v17);
    *(_QWORD *)a2 = v18;
    if ( !v18 )
      goto LABEL_23;
    v13 = *(_QWORD *)(a2 + 8);
    v15 = v13 + 1;
  }
  *(_QWORD *)(a2 + 8) = v15;
  v18[v13] = 40;
  sub_56990(*(__int64 **)(a1 + 16), a2, 19, 0);
  v19 = *(_QWORD *)(a2 + 8);
  v20 = *(_QWORD *)(a2 + 16);
  v21 = v19 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v19 + 1 <= v20 )
  {
    result = *(char **)a2;
    goto LABEL_22;
  }
  v22 = v19 + 993;
  v23 = *(char **)a2;
  if ( 2 * v20 <= v22 )
    v24 = v22;
  else
    v24 = 2 * v20;
  *(_QWORD *)(a2 + 16) = v24;
  result = (char *)realloc(v23, v24);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_23:
    std::terminate();
  v19 = *(_QWORD *)(a2 + 8);
  v21 = v19 + 1;
LABEL_22:
  *(_QWORD *)(a2 + 8) = v21;
  result[v19] = 41;
  return result;
}

//----- (0000000000060E5C) ----------------------------------------------------
void __fastcall sub_60E5C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000060E64) ----------------------------------------------------
char *__fastcall sub_60E64(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 v12; // x10
  unsigned __int64 v13; // x11
  int v14; // w12
  char *v15; // x0
  size_t v16; // x1
  _BYTE *v17; // x0
  __int64 v18; // x8
  __int64 v19; // x21
  char *v20; // x0
  __int64 v21; // x22
  char v22; // w23
  __int64 v23; // x25
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x8
  char *v26; // x0
  size_t v27; // x1
  char *v28; // x0
  __int64 v29; // x8
  unsigned __int64 v30; // x9
  __int64 v31; // x8
  unsigned __int64 v32; // x9
  char *v33; // x0
  size_t v34; // x1
  char *result; // x0

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  if ( v2 + 5 <= v3 )
  {
    v10 = *(char **)a2;
  }
  else
  {
    v6 = v2 + 997;
    v7 = 2 * v3;
    v8 = *(char **)a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    *(_QWORD *)(a2 + 16) = v9;
    v10 = (char *)realloc(v8, v9);
    *(_QWORD *)a2 = v10;
    if ( !v10 )
      goto LABEL_37;
    v2 = *(_QWORD *)(a2 + 8);
  }
  v11 = &v10[v2];
  v11[4] = 119;
  *(_DWORD *)v11 = 1869768820;
  v12 = *(_QWORD *)(a2 + 8);
  v13 = *(_QWORD *)(a2 + 16);
  v14 = *(_DWORD *)(a2 + 32) + 1;
  *(_QWORD *)(a2 + 8) = v12 + 5;
  *(_DWORD *)(a2 + 32) = v14;
  if ( v12 + 6 <= v13 )
  {
    v20 = *(char **)a2;
    *(_QWORD *)(a2 + 8) = v12 + 6;
    v20[v12 + 5] = 40;
    v19 = *(_QWORD *)(a2 + 8);
    if ( !*(_QWORD *)(a1 + 24) )
      goto LABEL_29;
LABEL_16:
    v21 = 0;
    v22 = 1;
    while ( 1 )
    {
      v23 = v19;
      if ( (v22 & 1) == 0 )
      {
        v24 = *(_QWORD *)(a2 + 16);
        if ( v19 + 2 <= v24 )
        {
          v28 = *(char **)a2;
          v29 = v19;
        }
        else
        {
          v25 = 2 * v24;
          v26 = *(char **)a2;
          if ( v25 <= v19 + 994 )
            v27 = v19 + 994;
          else
            v27 = v25;
          *(_QWORD *)(a2 + 16) = v27;
          v28 = (char *)realloc(v26, v27);
          *(_QWORD *)a2 = v28;
          if ( !v28 )
            goto LABEL_37;
          v29 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)&v28[v29] = 8236;
        v23 = *(_QWORD *)(a2 + 8) + 2LL;
        *(_QWORD *)(a2 + 8) = v23;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 16) + 8 * v21), a2, 18, 0);
      if ( v23 == *(_QWORD *)(a2 + 8) )
      {
        *(_QWORD *)(a2 + 8) = v19;
        if ( ++v21 == *(_QWORD *)(a1 + 24) )
          goto LABEL_29;
      }
      else
      {
        v22 = 0;
        v19 = *(_QWORD *)(a2 + 8);
        if ( ++v21 == *(_QWORD *)(a1 + 24) )
          goto LABEL_29;
      }
    }
  }
  v15 = *(char **)a2;
  if ( 2 * v13 <= v12 + 998 )
    v16 = v12 + 998;
  else
    v16 = 2 * v13;
  *(_QWORD *)(a2 + 16) = v16;
  v17 = realloc(v15, v16);
  *(_QWORD *)a2 = v17;
  if ( !v17 )
    goto LABEL_37;
  v18 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v18 + 1;
  v17[v18] = 40;
  v19 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)(a1 + 24) )
    goto LABEL_16;
LABEL_29:
  v30 = *(_QWORD *)(a2 + 16);
  v31 = v19 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v19 + 1 <= v30 )
  {
    result = *(char **)a2;
    goto LABEL_36;
  }
  v32 = 2 * v30;
  v33 = *(char **)a2;
  if ( v32 <= v19 + 993 )
    v34 = v19 + 993;
  else
    v34 = v32;
  *(_QWORD *)(a2 + 16) = v34;
  result = (char *)realloc(v33, v34);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_37:
    std::terminate();
  v19 = *(_QWORD *)(a2 + 8);
  v31 = v19 + 1;
LABEL_36:
  *(_QWORD *)(a2 + 8) = v31;
  result[v19] = 41;
  return result;
}

//----- (00000000000610A0) ----------------------------------------------------
void __fastcall sub_610A0(void *a1)
{
  operator delete(a1);
}

//----- (00000000000610A8) ----------------------------------------------------
__int64 sub_610A8()
{
  return 1;
}

//----- (00000000000610B4) ----------------------------------------------------
__int64 sub_610B4()
{
  return 1;
}

//----- (00000000000610C0) ----------------------------------------------------
_BYTE *__fastcall sub_610C0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // x8
  unsigned __int64 v4; // x9
  size_t v5; // x8
  unsigned __int64 v6; // x9
  _BYTE *v7; // x0
  size_t v8; // x1
  _BYTE *result; // x0

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
  v3 = a2[1];
  v4 = a2[2];
  if ( v3 + 1 <= v4 )
  {
    result = (_BYTE *)*a2;
  }
  else
  {
    v5 = v3 + 993;
    v6 = 2 * v4;
    v7 = (_BYTE *)*a2;
    if ( v6 <= v5 )
      v8 = v5;
    else
      v8 = v6;
    a2[2] = v8;
    result = realloc(v7, v8);
    *a2 = result;
    if ( !result )
      std::terminate();
    v3 = a2[1];
  }
  result[v3] = 32;
  ++a2[1];
  return result;
}

//----- (000000000006114C) ----------------------------------------------------
char *__fastcall sub_6114C(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 *v5; // x21
  unsigned __int64 v6; // x10
  unsigned __int64 v7; // x8
  char *v8; // x0
  size_t v9; // x1
  _BYTE *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x22
  char *v13; // x0
  __int64 v14; // x23
  char v15; // w24
  __int64 v16; // x26
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x8
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  char *v26; // x0
  size_t v27; // x1
  char *v28; // x0
  char *result; // x0
  int v30; // w8
  __int64 v31; // x8
  unsigned __int64 v32; // x9
  size_t v33; // x8
  unsigned __int64 v34; // x9
  char *v35; // x0
  size_t v36; // x1
  char *v37; // x8
  __int64 v38; // x8
  unsigned __int64 v39; // x9
  size_t v40; // x8
  unsigned __int64 v41; // x9
  char *v42; // x0
  size_t v43; // x1
  char *v44; // x8
  __int64 v45; // x8
  unsigned __int64 v46; // x9
  size_t v47; // x8
  unsigned __int64 v48; // x9
  char *v49; // x0
  size_t v50; // x1
  char *v51; // x8
  int v52; // w8
  __int64 v53; // x8
  unsigned __int64 v54; // x9
  size_t v55; // x8
  unsigned __int64 v56; // x9
  char *v57; // x0
  size_t v58; // x1
  __int64 v59; // x8
  unsigned __int64 v60; // x9
  size_t v61; // x8
  unsigned __int64 v62; // x9
  char *v63; // x0
  size_t v64; // x1
  __int64 v65; // x9
  char *v66; // x8
  __int64 v67; // x8
  unsigned __int64 v68; // x10
  __int64 v69; // x9
  unsigned __int64 v70; // x8
  char *v71; // x0
  size_t v72; // x1
  char *v73; // x0
  __int64 v74; // x20

  v5 = (__int64 *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 32);
  if ( v4 + 1 <= v6 )
  {
    v13 = *(char **)a2;
    *v5 = v4 + 1;
    v13[v4] = 40;
    v12 = *v5;
    if ( !*(_QWORD *)(a1 + 32) )
      goto LABEL_22;
LABEL_9:
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v12;
      if ( (v15 & 1) == 0 )
      {
        v17 = *(_QWORD *)(a2 + 16);
        if ( v12 + 2 <= v17 )
        {
          v21 = *(char **)a2;
          v22 = v12;
        }
        else
        {
          v18 = 2 * v17;
          v19 = *(char **)a2;
          if ( v18 <= v12 + 994 )
            v20 = v12 + 994;
          else
            v20 = v18;
          *(_QWORD *)(a2 + 16) = v20;
          v21 = (char *)realloc(v19, v20);
          *(_QWORD *)a2 = v21;
          if ( !v21 )
            goto LABEL_86;
          v22 = *v5;
        }
        *(_WORD *)&v21[v22] = 8236;
        v16 = *v5 + 2;
        *v5 = v16;
      }
      sub_56990(*(__int64 **)(*(_QWORD *)(a1 + 24) + 8 * v14), a2, 18, 0);
      if ( v16 == *(_QWORD *)(a2 + 8) )
      {
        *v5 = v12;
        if ( ++v14 == *(_QWORD *)(a1 + 32) )
          goto LABEL_22;
      }
      else
      {
        v15 = 0;
        v12 = *(_QWORD *)(a2 + 8);
        if ( ++v14 == *(_QWORD *)(a1 + 32) )
          goto LABEL_22;
      }
    }
  }
  v7 = v4 + 993;
  v8 = *(char **)a2;
  if ( 2 * v6 <= v7 )
    v9 = v7;
  else
    v9 = 2 * v6;
  *(_QWORD *)(a2 + 16) = v9;
  v10 = realloc(v8, v9);
  *(_QWORD *)a2 = v10;
  if ( !v10 )
    goto LABEL_86;
  v11 = (*v5)++;
  v10[v11] = 40;
  v12 = *v5;
  if ( *(_QWORD *)(a1 + 32) )
    goto LABEL_9;
LABEL_22:
  v23 = *(_QWORD *)(a2 + 16);
  v24 = v12 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v12 + 1 <= v23 )
  {
    v28 = *(char **)a2;
  }
  else
  {
    v25 = 2 * v23;
    v26 = *(char **)a2;
    if ( v25 <= v12 + 993 )
      v27 = v12 + 993;
    else
      v27 = v25;
    *(_QWORD *)(a2 + 16) = v27;
    v28 = (char *)realloc(v26, v27);
    *(_QWORD *)a2 = v28;
    if ( !v28 )
      goto LABEL_86;
    v12 = *v5;
    v24 = *v5 + 1;
  }
  *(_QWORD *)(a2 + 8) = v24;
  v28[v12] = 41;
  result = (char *)(*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 16) + 40LL))(
                     *(_QWORD *)(a1 + 16),
                     a2);
  v30 = *(_DWORD *)(a1 + 40);
  if ( (v30 & 1) != 0 )
  {
    v31 = *(_QWORD *)(a2 + 8);
    v32 = *(_QWORD *)(a2 + 16);
    if ( v31 + 6 <= v32 )
    {
      result = *(char **)a2;
    }
    else
    {
      v33 = v31 + 998;
      v34 = 2 * v32;
      v35 = *(char **)a2;
      if ( v34 <= v33 )
        v36 = v33;
      else
        v36 = v34;
      *(_QWORD *)(a2 + 16) = v36;
      result = (char *)realloc(v35, v36);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_86;
      v31 = *v5;
    }
    v37 = &result[v31];
    *((_WORD *)v37 + 2) = 29811;
    *(_DWORD *)v37 = 1852793632;
    v30 = *(_DWORD *)(a1 + 40);
    *v5 += 6;
  }
  if ( (v30 & 2) != 0 )
  {
    v38 = *(_QWORD *)(a2 + 8);
    v39 = *(_QWORD *)(a2 + 16);
    if ( v38 + 9 <= v39 )
    {
      result = *(char **)a2;
    }
    else
    {
      v40 = v38 + 1001;
      v41 = 2 * v39;
      v42 = *(char **)a2;
      if ( v41 <= v40 )
        v43 = v40;
      else
        v43 = v41;
      *(_QWORD *)(a2 + 16) = v43;
      result = (char *)realloc(v42, v43);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_86;
      v38 = *v5;
    }
    v44 = &result[v38];
    v44[8] = 101;
    *(_QWORD *)v44 = *(_QWORD *)" volatile";
    v30 = *(_DWORD *)(a1 + 40);
    *v5 += 9;
  }
  if ( (v30 & 4) != 0 )
  {
    v45 = *(_QWORD *)(a2 + 8);
    v46 = *(_QWORD *)(a2 + 16);
    if ( v45 + 9 <= v46 )
    {
      result = *(char **)a2;
    }
    else
    {
      v47 = v45 + 1001;
      v48 = 2 * v46;
      v49 = *(char **)a2;
      if ( v48 <= v47 )
        v50 = v47;
      else
        v50 = v48;
      *(_QWORD *)(a2 + 16) = v50;
      result = (char *)realloc(v49, v50);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_86;
      v45 = *v5;
    }
    v51 = &result[v45];
    v51[8] = 116;
    *(_QWORD *)v51 = *(_QWORD *)" restrict";
    *v5 += 9;
  }
  v52 = *(unsigned __int8 *)(a1 + 44);
  if ( v52 == 2 )
  {
    v59 = *(_QWORD *)(a2 + 8);
    v60 = *(_QWORD *)(a2 + 16);
    if ( v59 + 3 <= v60 )
    {
      result = *(char **)a2;
    }
    else
    {
      v61 = v59 + 995;
      v62 = 2 * v60;
      v63 = *(char **)a2;
      if ( v62 <= v61 )
        v64 = v61;
      else
        v64 = v62;
      *(_QWORD *)(a2 + 16) = v64;
      result = (char *)realloc(v63, v64);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_86;
      v59 = *v5;
    }
    v66 = &result[v59];
    v65 = 3;
    v66[2] = 38;
    *(_WORD *)v66 = 9760;
  }
  else
  {
    if ( v52 != 1 )
      goto LABEL_75;
    v53 = *(_QWORD *)(a2 + 8);
    v54 = *(_QWORD *)(a2 + 16);
    if ( v53 + 2 <= v54 )
    {
      result = *(char **)a2;
    }
    else
    {
      v55 = v53 + 994;
      v56 = 2 * v54;
      v57 = *(char **)a2;
      if ( v56 <= v55 )
        v58 = v55;
      else
        v58 = v56;
      *(_QWORD *)(a2 + 16) = v58;
      result = (char *)realloc(v57, v58);
      *(_QWORD *)a2 = result;
      if ( !result )
        goto LABEL_86;
      v53 = *v5;
    }
    v65 = 2;
    *(_WORD *)&result[v53] = 9760;
  }
  *v5 += v65;
LABEL_75:
  if ( !*(_QWORD *)(a1 + 48) )
    return result;
  v67 = *(_QWORD *)(a2 + 8);
  v68 = *(_QWORD *)(a2 + 16);
  v69 = v67 + 1;
  if ( v67 + 1 > v68 )
  {
    v70 = v67 + 993;
    v71 = *(char **)a2;
    if ( 2 * v68 <= v70 )
      v72 = v70;
    else
      v72 = 2 * v68;
    *(_QWORD *)(a2 + 16) = v72;
    v73 = (char *)realloc(v71, v72);
    *(_QWORD *)a2 = v73;
    if ( v73 )
    {
      v67 = *v5;
      v69 = *v5 + 1;
      goto LABEL_83;
    }
LABEL_86:
    std::terminate();
  }
  v73 = *(char **)a2;
LABEL_83:
  *(_QWORD *)(a2 + 8) = v69;
  v73[v67] = 32;
  v74 = *(_QWORD *)(a1 + 48);
  result = (char *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v74 + 32LL))(v74, a2);
  if ( (*(_WORD *)(v74 + 9) & 0xC0) != 0x40 )
    return (char *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v74 + 40LL))(v74, a2);
  return result;
}

//----- (0000000000061604) ----------------------------------------------------
void __fastcall sub_61604(void *a1)
{
  operator delete(a1);
}

//----- (000000000006160C) ----------------------------------------------------
char *__fastcall sub_6160C(_QWORD *a1, char **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 v12; // x8
  _BYTE *v13; // x9
  _BYTE *v14; // x21
  size_t v15; // x20
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  unsigned __int64 v22; // x9
  size_t v23; // x8
  unsigned __int64 v24; // x9
  char *v25; // x0
  size_t v26; // x1
  char *result; // x0

  v2 = a1[2];
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 1) <= v6 )
  {
    v11 = *a2;
  }
  else
  {
    v7 = (size_t)(v5 + 993);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (char *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      goto LABEL_27;
    v5 = a2[1];
  }
  v5[(_QWORD)v11] = 60;
  v12 = (__int64)(a2[1] + 1);
  a2[1] = (char *)v12;
  v14 = (_BYTE *)a1[3];
  v13 = (_BYTE *)a1[4];
  v15 = v13 - v14;
  if ( v13 != v14 )
  {
    v16 = (size_t)a2[2];
    v17 = v12 + v15;
    if ( v12 + v15 <= v16 )
    {
      v21 = *a2;
    }
    else
    {
      v18 = 2 * v16;
      v19 = *a2;
      if ( v18 <= v17 + 992 )
        v20 = v17 + 992;
      else
        v20 = v18;
      a2[2] = (char *)v20;
      v21 = (char *)realloc(v19, v20);
      *a2 = v21;
      if ( !v21 )
        goto LABEL_27;
      v12 = (__int64)a2[1];
    }
    memcpy(&v21[v12], v14, v15);
    v12 = (__int64)&a2[1][v15];
    a2[1] = (char *)v12;
  }
  v22 = (unsigned __int64)a2[2];
  if ( v12 + 1 <= v22 )
  {
    result = *a2;
    goto LABEL_26;
  }
  v23 = v12 + 993;
  v24 = 2 * v22;
  v25 = *a2;
  if ( v24 <= v23 )
    v26 = v23;
  else
    v26 = v24;
  a2[2] = (char *)v26;
  result = (char *)realloc(v25, v26);
  *a2 = result;
  if ( !result )
LABEL_27:
    std::terminate();
  v12 = (__int64)a2[1];
LABEL_26:
  result[v12] = 62;
  ++a2[1];
  return result;
}

//----- (0000000000061788) ----------------------------------------------------
void __fastcall sub_61788(void *a1)
{
  operator delete(a1);
}

//----- (0000000000061790) ----------------------------------------------------
char *__fastcall sub_61790(_QWORD *a1, char **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *result; // x0
  __int64 v12; // x8
  _BYTE *v13; // x9
  _BYTE *v14; // x22
  size_t v15; // x21
  size_t v16; // x9
  size_t v17; // x10
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  char *v21; // x0
  __int64 v22; // x20

  v2 = a1[2];
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 1) <= v6 )
  {
    result = *a2;
  }
  else
  {
    v7 = (size_t)(v5 + 993);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (char *)v10;
    result = (char *)realloc(v9, v10);
    *a2 = result;
    if ( !result )
      goto LABEL_23;
    v5 = a2[1];
  }
  v5[(_QWORD)result] = 32;
  v12 = (__int64)(a2[1] + 1);
  a2[1] = (char *)v12;
  v14 = (_BYTE *)a1[3];
  v13 = (_BYTE *)a1[4];
  v15 = v13 - v14;
  if ( v13 == v14 )
    goto LABEL_19;
  v16 = (size_t)a2[2];
  v17 = v12 + v15;
  if ( v12 + v15 <= v16 )
  {
    v21 = *a2;
    goto LABEL_18;
  }
  v18 = 2 * v16;
  v19 = *a2;
  if ( v18 <= v17 + 992 )
    v20 = v17 + 992;
  else
    v20 = v18;
  a2[2] = (char *)v20;
  v21 = (char *)realloc(v19, v20);
  *a2 = v21;
  if ( !v21 )
LABEL_23:
    std::terminate();
  v12 = (__int64)a2[1];
LABEL_18:
  result = (char *)memcpy(&v21[v12], v14, v15);
  a2[1] += v15;
LABEL_19:
  v22 = a1[5];
  if ( v22 )
  {
    result = (char *)(*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v22 + 32LL))(v22, a2);
    if ( (*(_WORD *)(v22 + 9) & 0xC0) != 0x40 )
      return (char *)(*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v22 + 40LL))(v22, a2);
  }
  return result;
}

//----- (0000000000061908) ----------------------------------------------------
void __fastcall sub_61908(void *a1)
{
  operator delete(a1);
}

//----- (0000000000061910) ----------------------------------------------------
__int64 __fastcall sub_61910(__int64 a1)
{
  __int64 v1; // x0
  unsigned int v2; // w8

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned __int8 *)(v1 + 9);
  if ( (v2 & 0xC0) == 0x80 )
    return (**(__int64 (__fastcall ***)(__int64))v1)(v1);
  else
    return v2 < 0x40;
}

//----- (0000000000061940) ----------------------------------------------------
__int64 __fastcall sub_61940(__int64 a1)
{
  _BYTE *v1; // x0
  int v2; // w8

  v1 = *(_BYTE **)(a1 + 16);
  v2 = v1[10] & 3;
  if ( v2 == 2 )
    return (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v1 + 8LL))(v1);
  else
    return v2 == 0;
}

//----- (0000000000061970) ----------------------------------------------------
__int64 __fastcall sub_61970(__int64 a1)
{
  __int64 v1; // x0
  int v2; // w8

  v1 = *(_QWORD *)(a1 + 16);
  v2 = (*(unsigned __int16 *)(v1 + 9) >> 10) & 3;
  if ( v2 == 2 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1);
  else
    return v2 == 0;
}

//----- (00000000000619A0) ----------------------------------------------------
__int64 __fastcall sub_619A0(__int64 a1, void **a2)
{
  __int64 result; // x0
  int v5; // w8
  char *v6; // x8
  unsigned __int64 v7; // x9
  size_t v8; // x8
  unsigned __int64 v9; // x9
  void *v10; // x0
  size_t v11; // x1
  char *v12; // x8
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  void *v17; // x0
  size_t v18; // x1
  char *v19; // x8
  char *v20; // x8
  unsigned __int64 v21; // x9
  size_t v22; // x8
  unsigned __int64 v23; // x9
  void *v24; // x0
  size_t v25; // x1
  char *v26; // x8

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
  v5 = *(_DWORD *)(a1 + 12);
  if ( (v5 & 1) != 0 )
  {
    v6 = (char *)a2[1];
    v7 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v6 + 6) <= v7 )
    {
      result = (__int64)*a2;
    }
    else
    {
      v8 = (size_t)(v6 + 998);
      v9 = 2 * v7;
      v10 = *a2;
      if ( v9 <= v8 )
        v11 = v8;
      else
        v11 = v9;
      a2[2] = (void *)v11;
      result = (__int64)realloc(v10, v11);
      *a2 = (void *)result;
      if ( !result )
        goto LABEL_29;
      v6 = (char *)a2[1];
    }
    v12 = &v6[result];
    *((_WORD *)v12 + 2) = 29811;
    *(_DWORD *)v12 = 1852793632;
    v5 = *(_DWORD *)(a1 + 12);
    a2[1] = (char *)a2[1] + 6;
  }
  if ( (v5 & 2) != 0 )
  {
    v13 = (char *)a2[1];
    v14 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v13 + 9) <= v14 )
    {
      result = (__int64)*a2;
    }
    else
    {
      v15 = (size_t)(v13 + 1001);
      v16 = 2 * v14;
      v17 = *a2;
      if ( v16 <= v15 )
        v18 = v15;
      else
        v18 = v16;
      a2[2] = (void *)v18;
      result = (__int64)realloc(v17, v18);
      *a2 = (void *)result;
      if ( !result )
        goto LABEL_29;
      v13 = (char *)a2[1];
    }
    v19 = &v13[result];
    v19[8] = 101;
    *(_QWORD *)v19 = *(_QWORD *)" volatile";
    v5 = *(_DWORD *)(a1 + 12);
    a2[1] = (char *)a2[1] + 9;
  }
  if ( (v5 & 4) == 0 )
    return result;
  v20 = (char *)a2[1];
  v21 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v20 + 9) <= v21 )
  {
    result = (__int64)*a2;
    goto LABEL_27;
  }
  v22 = (size_t)(v20 + 1001);
  v23 = 2 * v21;
  v24 = *a2;
  if ( v23 <= v22 )
    v25 = v22;
  else
    v25 = v23;
  a2[2] = (void *)v25;
  result = (__int64)realloc(v24, v25);
  *a2 = (void *)result;
  if ( !result )
LABEL_29:
    std::terminate();
  v20 = (char *)a2[1];
LABEL_27:
  v26 = &v20[result];
  v26[8] = 116;
  *(_QWORD *)v26 = *(_QWORD *)" restrict";
  a2[1] = (char *)a2[1] + 9;
  return result;
}

//----- (0000000000061B28) ----------------------------------------------------
__int64 __fastcall sub_61B28(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 40LL))(*(_QWORD *)(a1 + 16));
}

//----- (0000000000061B3C) ----------------------------------------------------
void __fastcall sub_61B3C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000061B44) ----------------------------------------------------
__int64 __fastcall sub_61B44(__int64 a1, void **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  void *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  char *v11; // x8
  __int64 *v12; // x20
  __int64 v13; // x9
  __int64 result; // x0

  v2 = (char *)a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 6) <= v3 )
  {
    v10 = (char *)*a2;
  }
  else
  {
    v6 = (size_t)(v2 + 998);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (void *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      std::terminate();
    v2 = (char *)a2[1];
  }
  v11 = &v2[(_QWORD)v10];
  *((_WORD *)v11 + 2) = 29793;
  *(_DWORD *)v11 = 1869366879;
  v12 = *(__int64 **)(a1 + 16);
  v13 = *v12;
  a2[1] = (char *)a2[1] + 6;
  result = (*(__int64 (__fastcall **)(__int64 *, void **))(v13 + 32))(v12, a2);
  if ( (*(_WORD *)((_BYTE *)v12 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64 *, void **))(*v12 + 40))(v12, a2);
  return result;
}

//----- (0000000000061C1C) ----------------------------------------------------
void __fastcall sub_61C1C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000061C24) ----------------------------------------------------
char *__fastcall sub_61C24(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  unsigned __int64 v11; // x9
  size_t v12; // x8
  unsigned __int64 v13; // x9
  char *v14; // x0
  size_t v15; // x1
  char *v16; // x0
  char *v17; // x8
  char *v18; // x8
  __int64 v19; // x10
  unsigned __int64 v20; // x11
  __int64 v21; // x8
  int v22; // w12
  __int64 v23; // x9
  char *v24; // x0
  size_t v25; // x1
  char *v26; // x0
  __int64 v27; // x8
  unsigned __int64 v28; // x10
  __int64 v29; // x9
  unsigned __int64 v30; // x8
  char *v31; // x0
  size_t v32; // x1
  char *result; // x0

  v4 = *(_QWORD *)(a2 + 8);
  if ( !*(_BYTE *)(a1 + 24) )
  {
    v11 = *(_QWORD *)(a2 + 16);
    if ( v4 + 9 <= v11 )
    {
      v16 = *(char **)a2;
    }
    else
    {
      v12 = v4 + 1001;
      v13 = 2 * v11;
      v14 = *(char **)a2;
      if ( v13 <= v12 )
        v15 = v12;
      else
        v15 = v13;
      *(_QWORD *)(a2 + 16) = v15;
      v16 = (char *)realloc(v14, v15);
      *(_QWORD *)a2 = v16;
      if ( !v16 )
        goto LABEL_32;
      v4 = *(_QWORD *)(a2 + 8);
    }
    v17 = &v16[v4];
    v17[8] = 32;
    *(_QWORD *)v17 = *(_QWORD *)"unsigned ";
    v5 = *(_QWORD *)(a2 + 16);
    v4 = *(_QWORD *)(a2 + 8) + 9LL;
    *(_QWORD *)(a2 + 8) = v4;
    if ( v4 + 7 > v5 )
      goto LABEL_3;
LABEL_16:
    v10 = *(char **)a2;
    goto LABEL_17;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if ( v4 + 7 <= v5 )
    goto LABEL_16;
LABEL_3:
  v6 = v4 + 999;
  v7 = 2 * v5;
  v8 = *(char **)a2;
  if ( v7 <= v6 )
    v9 = v6;
  else
    v9 = v7;
  *(_QWORD *)(a2 + 16) = v9;
  v10 = (char *)realloc(v8, v9);
  *(_QWORD *)a2 = v10;
  if ( !v10 )
    goto LABEL_32;
  v4 = *(_QWORD *)(a2 + 8);
LABEL_17:
  v18 = &v10[v4];
  *(_DWORD *)(v18 + 3) = 1953384820;
  *(_DWORD *)v18 = 1953055327;
  v19 = *(_QWORD *)(a2 + 8);
  v20 = *(_QWORD *)(a2 + 16);
  v21 = v19 + 7;
  v22 = *(_DWORD *)(a2 + 32) + 1;
  v23 = v19 + 8;
  *(_QWORD *)(a2 + 8) = v19 + 7;
  *(_DWORD *)(a2 + 32) = v22;
  if ( v19 + 8 <= v20 )
  {
    v26 = *(char **)a2;
  }
  else
  {
    v24 = *(char **)a2;
    if ( 2 * v20 <= v19 + 1000 )
      v25 = v19 + 1000;
    else
      v25 = 2 * v20;
    *(_QWORD *)(a2 + 16) = v25;
    v26 = (char *)realloc(v24, v25);
    *(_QWORD *)a2 = v26;
    if ( !v26 )
      goto LABEL_32;
    v21 = *(_QWORD *)(a2 + 8);
    v23 = v21 + 1;
  }
  *(_QWORD *)(a2 + 8) = v23;
  v26[v21] = 40;
  sub_56990(*(__int64 **)(a1 + 16), a2, 19, 0);
  v27 = *(_QWORD *)(a2 + 8);
  v28 = *(_QWORD *)(a2 + 16);
  v29 = v27 + 1;
  --*(_DWORD *)(a2 + 32);
  if ( v27 + 1 <= v28 )
  {
    result = *(char **)a2;
    goto LABEL_31;
  }
  v30 = v27 + 993;
  v31 = *(char **)a2;
  if ( 2 * v28 <= v30 )
    v32 = v30;
  else
    v32 = 2 * v28;
  *(_QWORD *)(a2 + 16) = v32;
  result = (char *)realloc(v31, v32);
  *(_QWORD *)a2 = result;
  if ( !result )
LABEL_32:
    std::terminate();
  v27 = *(_QWORD *)(a2 + 8);
  v29 = v27 + 1;
LABEL_31:
  *(_QWORD *)(a2 + 8) = v29;
  result[v27] = 41;
  return result;
}

//----- (0000000000061E00) ----------------------------------------------------
void __fastcall sub_61E00(void *a1)
{
  operator delete(a1);
}

//----- (0000000000061E08) ----------------------------------------------------
_QWORD *__fastcall sub_61E08(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // x21
  __int64 v4; // x8
  _QWORD *v6; // x0
  __int64 v7; // x8
  _QWORD *v8; // x9
  _QWORD *result; // x0
  __int64 v10; // x10

  v2 = *(_QWORD **)(a1 + 4912);
  v4 = v2[1];
  if ( (unsigned __int64)(v4 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v6 = malloc(0x1000u);
    if ( !v6 )
      std::terminate();
    v4 = 0;
    *v6 = v2;
    v6[1] = 0;
    v2 = v6;
    *(_QWORD *)(a1 + 4912) = v6;
  }
  v7 = v4 + 32;
  v8 = (_QWORD *)((char *)v2 + v7);
  v2[1] = v7;
  LOWORD(v7) = *(_WORD *)((char *)v2 + v7 - 7);
  *((_BYTE *)v8 - 8) = 28;
  *(v8 - 2) = off_71DB8;
  result = v8 - 2;
  v10 = *a2;
  *(_WORD *)((char *)v8 - 7) = v7 & 0xF000 | 0x540;
  *v8 = v10;
  return result;
}
// 71DB8: using guessed type __int64 (__fastcall *off_71DB8[10])();

//----- (0000000000061EAC) ----------------------------------------------------
_QWORD *__fastcall sub_61EAC(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x11
  _QWORD *result; // x0
  __int64 v13; // x10

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *((_BYTE *)v10 - 8) = 27;
  v11 = *a3;
  *(v10 - 2) = off_71E28;
  result = v10 - 2;
  v13 = *a2;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x540;
  *v10 = v13;
  v10[1] = v11;
  return result;
}
// 71E28: using guessed type __int64 (__fastcall *off_71E28[10])();

//----- (0000000000061F58) ----------------------------------------------------
char *__fastcall sub_61F58(__int64 a1, char **a2)
{
  char *v2; // x8
  unsigned __int64 v3; // x9
  size_t v6; // x8
  unsigned __int64 v7; // x9
  char *v8; // x0
  size_t v9; // x1
  char *v10; // x0
  __int64 *v11; // x20
  __int64 v12; // x9
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  char *v17; // x0
  size_t v18; // x1
  char *result; // x0

  v2 = a2[1];
  v3 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v2 + 13) <= v3 )
  {
    v10 = *a2;
  }
  else
  {
    v6 = (size_t)(v2 + 1005);
    v7 = 2 * v3;
    v8 = *a2;
    if ( v7 <= v6 )
      v9 = v6;
    else
      v9 = v7;
    a2[2] = (char *)v9;
    v10 = (char *)realloc(v8, v9);
    *a2 = v10;
    if ( !v10 )
      goto LABEL_18;
    v2 = a2[1];
  }
  qmemcpy(&v2[(_QWORD)v10], "pixel vector[", 13);
  v11 = *(__int64 **)(a1 + 16);
  v12 = *v11;
  a2[1] += 13;
  (*(void (__fastcall **)(__int64 *, char **))(v12 + 32))(v11, a2);
  if ( (*(_WORD *)((_BYTE *)v11 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, char **))(*v11 + 40))(v11, a2);
  v13 = a2[1];
  v14 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v13 + 1) <= v14 )
  {
    result = *a2;
    goto LABEL_17;
  }
  v15 = (size_t)(v13 + 993);
  v16 = 2 * v14;
  v17 = *a2;
  if ( v16 <= v15 )
    v18 = v15;
  else
    v18 = v16;
  a2[2] = (char *)v18;
  result = (char *)realloc(v17, v18);
  *a2 = result;
  if ( !result )
LABEL_18:
    std::terminate();
  v13 = a2[1];
LABEL_17:
  v13[(_QWORD)result] = 93;
  ++a2[1];
  return result;
}

//----- (000000000006207C) ----------------------------------------------------
void __fastcall sub_6207C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000062084) ----------------------------------------------------
char *__fastcall sub_62084(__int64 a1, char **a2)
{
  __int64 v2; // x21
  char *v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x0
  size_t v10; // x1
  char *v11; // x0
  __int64 v12; // x20
  char *v13; // x8
  unsigned __int64 v14; // x9
  size_t v15; // x8
  unsigned __int64 v16; // x9
  char *v17; // x0
  size_t v18; // x1
  char *result; // x0

  v2 = *(_QWORD *)(a1 + 16);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
  if ( (*(_WORD *)(v2 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 40LL))(v2, a2);
  v5 = a2[1];
  v6 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v5 + 8) <= v6 )
  {
    v11 = *a2;
  }
  else
  {
    v7 = (size_t)(v5 + 1000);
    v8 = 2 * v6;
    v9 = *a2;
    if ( v8 <= v7 )
      v10 = v7;
    else
      v10 = v8;
    a2[2] = (char *)v10;
    v11 = (char *)realloc(v9, v10);
    *a2 = v11;
    if ( !v11 )
      goto LABEL_21;
    v5 = a2[1];
  }
  *(_QWORD *)&v5[(_QWORD)v11] = 0x5B726F7463657620LL;
  v12 = *(_QWORD *)(a1 + 24);
  a2[1] += 8;
  if ( v12 )
  {
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v12 + 32LL))(v12, a2);
    if ( (*(_WORD *)(v12 + 9) & 0xC0) != 0x40 )
      (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v12 + 40LL))(v12, a2);
  }
  v13 = a2[1];
  v14 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v13 + 1) <= v14 )
  {
    result = *a2;
    goto LABEL_20;
  }
  v15 = (size_t)(v13 + 993);
  v16 = 2 * v14;
  v17 = *a2;
  if ( v16 <= v15 )
    v18 = v15;
  else
    v18 = v16;
  a2[2] = (char *)v18;
  result = (char *)realloc(v17, v18);
  *a2 = result;
  if ( !result )
LABEL_21:
    std::terminate();
  v13 = a2[1];
LABEL_20:
  v13[(_QWORD)result] = 93;
  ++a2[1];
  return result;
}

//----- (00000000000621E4) ----------------------------------------------------
void __fastcall sub_621E4(void *a1)
{
  operator delete(a1);
}

//----- (00000000000621EC) ----------------------------------------------------
_QWORD *__fastcall sub_621EC(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x11
  _QWORD *result; // x0
  __int64 v13; // x10

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = (_QWORD *)((char *)v3 + v9);
  v11 = *a3;
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)((char *)v3 + v9 - 7);
  *(v10 - 2) = off_71E98;
  result = v10 - 2;
  *((_BYTE *)v10 - 8) = 14;
  v13 = *a2;
  *(_WORD *)((char *)v10 - 7) = v9 & 0xF000 | 0x400;
  *v10 = v13;
  v10[1] = v11;
  return result;
}
// 71E98: using guessed type __int64 (__fastcall *off_71E98[10])();

//----- (0000000000062294) ----------------------------------------------------
__int64 sub_62294()
{
  return 1;
}

//----- (00000000000622A0) ----------------------------------------------------
__int64 sub_622A0()
{
  return 1;
}

//----- (00000000000622AC) ----------------------------------------------------
__int64 __fastcall sub_622AC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
}

//----- (00000000000622C0) ----------------------------------------------------
__int64 __fastcall sub_622C0(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  _BYTE *v4; // x0
  unsigned __int64 v6; // x9
  size_t v7; // x8
  unsigned __int64 v8; // x9
  size_t v9; // x1
  unsigned __int64 v10; // x9
  size_t v11; // x8
  unsigned __int64 v12; // x9
  _BYTE *v13; // x0
  size_t v14; // x1
  _BYTE *v15; // x0
  __int64 v16; // x21
  __int64 v17; // x8
  unsigned __int64 v18; // x9
  size_t v19; // x8
  unsigned __int64 v20; // x9
  _BYTE *v21; // x0
  size_t v22; // x1
  _BYTE *v23; // x0
  __int64 *v24; // x0
  __int64 v25; // x9
  __int64 v27; // x0

  v2 = *(_QWORD *)(a2 + 8);
  if ( v2 )
  {
    v4 = *(_BYTE **)a2;
    if ( *(_BYTE *)(v2 + *(_QWORD *)a2 - 1) != 93 )
    {
      v6 = *(_QWORD *)(a2 + 16);
      if ( v2 + 1 > v6 )
      {
        v7 = v2 + 993;
        v8 = 2 * v6;
        if ( v8 <= v7 )
          v9 = v7;
        else
          v9 = v8;
        *(_QWORD *)(a2 + 16) = v9;
        v4 = realloc(v4, v9);
        *(_QWORD *)a2 = v4;
        if ( !v4 )
          goto LABEL_28;
        v2 = *(_QWORD *)(a2 + 8);
      }
      v4[v2] = 32;
      v2 = *(_QWORD *)(a2 + 8) + 1LL;
      *(_QWORD *)(a2 + 8) = v2;
    }
    v10 = *(_QWORD *)(a2 + 16);
    if ( v2 + 1 <= v10 )
    {
      v15 = *(_BYTE **)a2;
    }
    else
    {
      v11 = v2 + 993;
      v12 = 2 * v10;
      v13 = *(_BYTE **)a2;
      if ( v12 <= v11 )
        v14 = v11;
      else
        v14 = v12;
      *(_QWORD *)(a2 + 16) = v14;
      v15 = realloc(v13, v14);
      *(_QWORD *)a2 = v15;
      if ( !v15 )
        goto LABEL_28;
      v2 = *(_QWORD *)(a2 + 8);
    }
    v15[v2] = 91;
    v16 = *(_QWORD *)(a1 + 24);
    ++*(_QWORD *)(a2 + 8);
    if ( v16 )
    {
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v16 + 32LL))(v16, a2);
      if ( (*(_WORD *)(v16 + 9) & 0xC0) != 0x40 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v16 + 40LL))(v16, a2);
    }
    v17 = *(_QWORD *)(a2 + 8);
    v18 = *(_QWORD *)(a2 + 16);
    if ( v17 + 1 <= v18 )
    {
      v23 = *(_BYTE **)a2;
      goto LABEL_27;
    }
    v19 = v17 + 993;
    v20 = 2 * v18;
    v21 = *(_BYTE **)a2;
    if ( v20 <= v19 )
      v22 = v19;
    else
      v22 = v20;
    *(_QWORD *)(a2 + 16) = v22;
    v23 = realloc(v21, v22);
    *(_QWORD *)a2 = v23;
    if ( v23 )
    {
      v17 = *(_QWORD *)(a2 + 8);
LABEL_27:
      v23[v17] = 93;
      v24 = *(__int64 **)(a1 + 16);
      v25 = *v24;
      ++*(_QWORD *)(a2 + 8);
      return (*(__int64 (__fastcall **)(__int64 *, __int64))(v25 + 40))(v24, a2);
    }
LABEL_28:
    std::terminate();
  }
  v27 = __assert2(
          "out/llvm-project/libcxxabi/src/demangle/Utility.h",
          170,
          "char (anonymous namespace)::itanium_demangle::OutputBuffer::back() const",
          "CurrentPosition");
  return sub_62470(v27);
}
// 62470: using guessed type __int64 __fastcall sub_62470(_QWORD);
// 6AB10: using guessed type __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000062470) ----------------------------------------------------
void __fastcall sub_62470(void *a1)
{
  operator delete(a1);
}

//----- (0000000000062478) ----------------------------------------------------
_QWORD *__fastcall sub_62478(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v3; // x22
  __int64 v6; // x8
  _QWORD *v8; // x0
  __int64 v9; // x8
  __int64 v10; // x9
  _QWORD *v11; // x10
  _QWORD *result; // x0
  __int64 v13; // x11

  v3 = *(_QWORD **)(a1 + 4912);
  v6 = v3[1];
  if ( (unsigned __int64)(v6 - 4048) <= 0xFFFFFFFFFFFFF00FLL )
  {
    v8 = malloc(0x1000u);
    if ( !v8 )
      std::terminate();
    v6 = 0;
    *v8 = v3;
    v8[1] = 0;
    v3 = v8;
    *(_QWORD *)(a1 + 4912) = v8;
  }
  v9 = v6 + 32;
  v10 = *a3;
  v11 = (_QWORD *)((char *)v3 + v9);
  v3[1] = v9;
  LOWORD(v9) = *(_WORD *)(v10 + 9) & 0xC0 | 0x500 | *(_WORD *)((_BYTE *)v3 + v9 - 7) & 0xF000;
  *(v11 - 2) = off_71F08;
  result = v11 - 2;
  v13 = *a2;
  *((_BYTE *)v11 - 8) = 13;
  *(_WORD *)((char *)v11 - 7) = v9;
  *v11 = v13;
  v11[1] = v10;
  return result;
}
// 71F08: using guessed type __int64 (__fastcall *off_71F08[10])();

//----- (0000000000062530) ----------------------------------------------------
__int64 __fastcall sub_62530(__int64 a1)
{
  __int64 v1; // x0
  unsigned int v2; // w8

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(unsigned __int8 *)(v1 + 9);
  if ( (v2 & 0xC0) == 0x80 )
    return (**(__int64 (__fastcall ***)(__int64))v1)(v1);
  else
    return v2 < 0x40;
}

//----- (0000000000062560) ----------------------------------------------------
char *__fastcall sub_62560(__int64 a1, char **a2)
{
  __int64 v4; // x0
  unsigned int v5; // w8
  int v6; // w9
  int v7; // w8
  char *v8; // x8
  unsigned __int64 v9; // x9
  size_t v10; // x8
  unsigned __int64 v11; // x9
  char *v12; // x0
  size_t v13; // x1
  char *v14; // x0
  char v15; // w9
  unsigned __int64 v16; // x9
  size_t v17; // x8
  unsigned __int64 v18; // x9
  char *v19; // x0
  size_t v20; // x1
  __int64 *v21; // x20
  __int64 v22; // x9
  char *v23; // x8
  unsigned __int64 v24; // x9
  size_t v25; // x8
  unsigned __int64 v26; // x9
  char *v27; // x0
  size_t v28; // x1
  char *result; // x0
  char *v30; // x8

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 32LL))(*(_QWORD *)(a1 + 24));
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(unsigned __int16 *)(v4 + 9);
  v6 = (v5 >> 8) & 3;
  if ( v6 )
  {
    if ( v6 == 2 )
    {
      if ( ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v4 + 8LL))(v4, a2) & 1) != 0 )
        goto LABEL_8;
      v4 = *(_QWORD *)(a1 + 24);
      v5 = *(unsigned __int16 *)(v4 + 9);
    }
    v7 = (v5 >> 10) & 3;
    if ( v7 && (v7 != 2 || ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v4 + 16LL))(v4, a2) & 1) == 0) )
    {
      v8 = a2[1];
      v16 = (unsigned __int64)a2[2];
      if ( (unsigned __int64)(v8 + 1) <= v16 )
      {
        v14 = *a2;
      }
      else
      {
        v17 = (size_t)(v8 + 993);
        v18 = 2 * v16;
        v19 = *a2;
        if ( v18 <= v17 )
          v20 = v17;
        else
          v20 = v18;
        a2[2] = (char *)v20;
        v14 = (char *)realloc(v19, v20);
        *a2 = v14;
        if ( !v14 )
          goto LABEL_33;
        v8 = a2[1];
      }
      v15 = 32;
      goto LABEL_23;
    }
  }
LABEL_8:
  v8 = a2[1];
  v9 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v8 + 1) <= v9 )
  {
    v14 = *a2;
    v15 = 40;
  }
  else
  {
    v10 = (size_t)(v8 + 993);
    v11 = 2 * v9;
    v12 = *a2;
    if ( v11 <= v10 )
      v13 = v10;
    else
      v13 = v11;
    a2[2] = (char *)v13;
    v14 = (char *)realloc(v12, v13);
    *a2 = v14;
    if ( !v14 )
      goto LABEL_33;
    v8 = a2[1];
    v15 = 40;
  }
LABEL_23:
  v8[(_QWORD)v14] = v15;
  v21 = *(__int64 **)(a1 + 16);
  v22 = *v21;
  ++a2[1];
  (*(void (__fastcall **)(__int64 *, char **))(v22 + 32))(v21, a2);
  if ( (*(_WORD *)((_BYTE *)v21 + 9) & 0xC0) != 0x40 )
    (*(void (__fastcall **)(__int64 *, char **))(*v21 + 40))(v21, a2);
  v23 = a2[1];
  v24 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v23 + 3) <= v24 )
  {
    result = *a2;
    goto LABEL_32;
  }
  v25 = (size_t)(v23 + 995);
  v26 = 2 * v24;
  v27 = *a2;
  if ( v26 <= v25 )
    v28 = v25;
  else
    v28 = v26;
  a2[2] = (char *)v28;
  result = (char *)realloc(v27, v28);
  *a2 = result;
  if ( !result )
LABEL_33:
    std::terminate();
  v23 = a2[1];
LABEL_32:
  v30 = &v23[(_QWORD)result];
  v30[2] = 42;
  *(_WORD *)v30 = 14906;
  a2[1] += 3;
  return result;
}

//----- (0000000000062734) ----------------------------------------------------
__int64 __fastcall sub_62734(__int64 a1, _QWORD *a2)
{
  __int64 v3; // x0
  unsigned int v5; // w8
  int v6; // w9
  int v7; // w8
  __int64 v8; // x8
  unsigned __int64 v9; // x9
  size_t v10; // x8
  unsigned __int64 v11; // x9
  _BYTE *v12; // x0
  size_t v13; // x1
  _BYTE *v14; // x0

  v3 = *(_QWORD *)(a1 + 24);
  v5 = *(unsigned __int16 *)(v3 + 9);
  v6 = (v5 >> 8) & 3;
  if ( v6 )
  {
    if ( v6 != 2 )
    {
LABEL_5:
      v7 = (v5 >> 10) & 3;
      if ( v7 && (v7 != 2 || ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v3 + 16LL))(v3, a2) & 1) == 0) )
        return (*(__int64 (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 24) + 40LL))(*(_QWORD *)(a1 + 24), a2);
      goto LABEL_8;
    }
    if ( ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v3 + 8LL))(v3, a2) & 1) == 0 )
    {
      v3 = *(_QWORD *)(a1 + 24);
      v5 = *(unsigned __int16 *)(v3 + 9);
      goto LABEL_5;
    }
  }
LABEL_8:
  v8 = a2[1];
  v9 = a2[2];
  if ( v8 + 1 <= v9 )
  {
    v14 = (_BYTE *)*a2;
  }
  else
  {
    v10 = v8 + 993;
    v11 = 2 * v9;
    v12 = (_BYTE *)*a2;
    if ( v11 <= v10 )
      v13 = v10;
    else
      v13 = v11;
    a2[2] = v13;
    v14 = realloc(v12, v13);
    *a2 = v14;
    if ( !v14 )
      std::terminate();
    v8 = a2[1];
  }
  v14[v8] = 41;
  ++a2[1];
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 24) + 40LL))(*(_QWORD *)(a1 + 24), a2);
}

//----- (0000000000062820) ----------------------------------------------------
void __fastcall sub_62820(void *a1)
{
  operator delete(a1);
}

//----- (0000000000062828) ----------------------------------------------------
__int64 __fastcall sub_62828(_QWORD *a1, char **a2)
{
  _BYTE *v2; // x8
  _BYTE *v3; // x22
  bool v6; // zf
  size_t v7; // x21
  size_t v8; // x8
  size_t v9; // x9
  size_t v10; // x10
  unsigned __int64 v11; // x9
  char *v12; // x0
  size_t v13; // x1
  char *v14; // x0
  unsigned __int64 v15; // x10
  size_t v16; // x9
  unsigned __int64 v17; // x8
  char *v18; // x0
  size_t v19; // x1
  char *v20; // x0
  __int64 v21; // x20
  __int64 result; // x0

  v3 = (_BYTE *)a1[2];
  v2 = (_BYTE *)a1[3];
  v7 = v2 - v3;
  v6 = v2 == v3;
  v8 = (size_t)a2[1];
  if ( !v6 )
  {
    v9 = (size_t)a2[2];
    v10 = v8 + v7;
    if ( v8 + v7 <= v9 )
    {
      v14 = *a2;
    }
    else
    {
      v11 = 2 * v9;
      v12 = *a2;
      if ( v11 <= v10 + 992 )
        v13 = v10 + 992;
      else
        v13 = v11;
      a2[2] = (char *)v13;
      v14 = (char *)realloc(v12, v13);
      *a2 = v14;
      if ( !v14 )
        goto LABEL_19;
      v8 = (size_t)a2[1];
    }
    memcpy(&v14[v8], v3, v7);
    v8 = (size_t)&a2[1][v7];
    a2[1] = (char *)v8;
  }
  v15 = (unsigned __int64)a2[2];
  v16 = v8 + 1;
  if ( v8 + 1 > v15 )
  {
    v17 = v8 + 993;
    v18 = *a2;
    if ( 2 * v15 <= v17 )
      v19 = v17;
    else
      v19 = 2 * v15;
    a2[2] = (char *)v19;
    v20 = (char *)realloc(v18, v19);
    *a2 = v20;
    if ( v20 )
    {
      v8 = (size_t)a2[1];
      v16 = v8 + 1;
      goto LABEL_17;
    }
LABEL_19:
    std::terminate();
  }
  v20 = *a2;
LABEL_17:
  a2[1] = (char *)v16;
  v20[v8] = 32;
  v21 = a1[4];
  result = (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v21 + 32LL))(v21, a2);
  if ( (*(_WORD *)(v21 + 9) & 0xC0) != 0x40 )
    return (*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v21 + 40LL))(v21, a2);
  return result;
}

//----- (0000000000062964) ----------------------------------------------------
void __fastcall sub_62964(void *a1)
{
  operator delete(a1);
}

//----- (000000000006296C) ----------------------------------------------------
__int64 __fastcall sub_6296C(__int64 a1)
{
  __int64 v1; // x0
  unsigned int v2; // w8

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned __int8 *)(v1 + 9);
  if ( (v2 & 0xC0) == 0x80 )
    return (**(__int64 (__fastcall ***)(__int64))v1)(v1);
  else
    return v2 < 0x40;
}

//----- (000000000006299C) ----------------------------------------------------
char *__fastcall sub_6299C(__int64 a1, char **a2)
{
  __int64 v2; // x21
  __int64 v5; // x8
  const char *v6; // x0
  _BYTE *v7; // x0
  char *v8; // x8
  unsigned __int64 v9; // x9
  size_t v10; // x8
  unsigned __int64 v11; // x9
  char *v12; // x0
  size_t v13; // x1
  char *v14; // x0
  __int64 v15; // x0
  unsigned int v16; // w8
  int v17; // w9
  int v18; // w8
  char *v19; // x8
  unsigned __int64 v20; // x9
  size_t v21; // x8
  unsigned __int64 v22; // x9
  char *v23; // x0
  size_t v24; // x1
  char *v25; // x0
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 *v28; // x23
  size_t v29; // x8
  unsigned __int64 v30; // x9
  char *v31; // x0
  size_t v32; // x1
  char *result; // x0
  char v34; // w9
  __int64 v35; // x8
  unsigned __int64 v36; // x9
  size_t v37; // x8
  unsigned __int64 v38; // x9
  char *v39; // x0
  size_t v40; // x1
  char *v41; // x0
  char *v42; // x8
  _BYTE *v43; // x9
  _BYTE *v44; // x22
  size_t v45; // x20
  size_t v46; // x9
  size_t v47; // x10
  unsigned __int64 v48; // x9
  char *v49; // x0
  size_t v50; // x1
  char *v51; // x0
  unsigned __int64 v52; // x9
  size_t v53; // x8
  unsigned __int64 v54; // x9
  char *v55; // x0
  size_t v56; // x1

  v2 = *(_QWORD *)(a1 + 16);
  if ( *(_BYTE *)(v2 + 8) == 10 )
  {
    v5 = *(_QWORD *)(v2 + 16);
    if ( *(_BYTE *)(v5 + 8) == 7 )
    {
      v6 = *(const char **)(v5 + 16);
      if ( *(_QWORD *)(v5 + 24) - (_QWORD)v6 == 11 && !strncmp(v6, "objc_object", 0xBu) )
      {
        v35 = (__int64)a2[1];
        v36 = (unsigned __int64)a2[2];
        v28 = (__int64 *)(a2 + 1);
        if ( v35 + 3 <= v36 )
        {
          v41 = *a2;
        }
        else
        {
          v37 = v35 + 995;
          v38 = 2 * v36;
          v39 = *a2;
          if ( v38 <= v37 )
            v40 = v37;
          else
            v40 = v38;
          a2[2] = (char *)v40;
          v41 = (char *)realloc(v39, v40);
          *a2 = v41;
          if ( !v41 )
            goto LABEL_64;
          v35 = *v28;
        }
        v42 = &v41[v35];
        v42[2] = 60;
        *(_WORD *)v42 = 25705;
        v26 = *v28 + 3;
        *v28 = v26;
        v44 = *(_BYTE **)(v2 + 24);
        v43 = *(_BYTE **)(v2 + 32);
        v45 = v43 - v44;
        if ( v43 != v44 )
        {
          v46 = (size_t)a2[2];
          v47 = v26 + v45;
          if ( v26 + v45 <= v46 )
          {
            v51 = *a2;
          }
          else
          {
            v48 = 2 * v46;
            v49 = *a2;
            if ( v48 <= v47 + 992 )
              v50 = v47 + 992;
            else
              v50 = v48;
            a2[2] = (char *)v50;
            v51 = (char *)realloc(v49, v50);
            *a2 = v51;
            if ( !v51 )
              goto LABEL_64;
            v26 = *v28;
          }
          memcpy(&v51[v26], v44, v45);
          v26 = *v28 + v45;
          *v28 = v26;
        }
        v52 = (unsigned __int64)a2[2];
        if ( v26 + 1 <= v52 )
        {
          result = *a2;
        }
        else
        {
          v53 = v26 + 993;
          v54 = 2 * v52;
          v55 = *a2;
          if ( v54 <= v53 )
            v56 = v53;
          else
            v56 = v54;
          a2[2] = (char *)v56;
          result = (char *)realloc(v55, v56);
          *a2 = result;
          if ( !result )
            goto LABEL_64;
          v26 = *v28;
        }
        v34 = 62;
        goto LABEL_39;
      }
    }
  }
  (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v2 + 32LL))(v2, a2);
  v7 = *(_BYTE **)(a1 + 16);
  if ( (v7[10] & 3) == 0
    || (v7[10] & 3) == 2 && ((*(__int64 (__fastcall **)(_BYTE *, char **))(*(_QWORD *)v7 + 8LL))(v7, a2) & 1) != 0 )
  {
    v8 = a2[1];
    v9 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v8 + 1) <= v9 )
    {
      v14 = *a2;
    }
    else
    {
      v10 = (size_t)(v8 + 993);
      v11 = 2 * v9;
      v12 = *a2;
      if ( v11 <= v10 )
        v13 = v10;
      else
        v13 = v11;
      a2[2] = (char *)v13;
      v14 = (char *)realloc(v12, v13);
      *a2 = v14;
      if ( !v14 )
        goto LABEL_64;
      v8 = a2[1];
    }
    v8[(_QWORD)v14] = 32;
    ++a2[1];
  }
  v15 = *(_QWORD *)(a1 + 16);
  v16 = *(unsigned __int16 *)(v15 + 9);
  v17 = (v16 >> 8) & 3;
  if ( v17 )
  {
    if ( v17 != 2 )
    {
LABEL_20:
      v18 = (v16 >> 10) & 3;
      if ( v18
        && (v18 != 2 || ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v15 + 16LL))(v15, a2) & 1) == 0) )
      {
        goto LABEL_31;
      }
      goto LABEL_23;
    }
    if ( ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v15 + 8LL))(v15, a2) & 1) == 0 )
    {
      v15 = *(_QWORD *)(a1 + 16);
      v16 = *(unsigned __int16 *)(v15 + 9);
      goto LABEL_20;
    }
  }
LABEL_23:
  v19 = a2[1];
  v20 = (unsigned __int64)a2[2];
  if ( (unsigned __int64)(v19 + 1) <= v20 )
  {
    v25 = *a2;
  }
  else
  {
    v21 = (size_t)(v19 + 993);
    v22 = 2 * v20;
    v23 = *a2;
    if ( v22 <= v21 )
      v24 = v21;
    else
      v24 = v22;
    a2[2] = (char *)v24;
    v25 = (char *)realloc(v23, v24);
    *a2 = v25;
    if ( !v25 )
      goto LABEL_64;
    v19 = a2[1];
  }
  v19[(_QWORD)v25] = 40;
  ++a2[1];
LABEL_31:
  v26 = (__int64)a2[1];
  v27 = (unsigned __int64)a2[2];
  v28 = (__int64 *)(a2 + 1);
  if ( v26 + 1 <= v27 )
  {
    result = *a2;
    goto LABEL_38;
  }
  v29 = v26 + 993;
  v30 = 2 * v27;
  v31 = *a2;
  if ( v30 <= v29 )
    v32 = v29;
  else
    v32 = v30;
  a2[2] = (char *)v32;
  result = (char *)realloc(v31, v32);
  *a2 = result;
  if ( !result )
LABEL_64:
    std::terminate();
  v26 = *v28;
LABEL_38:
  v34 = 42;
LABEL_39:
  result[v26] = v34;
  ++*v28;
  return result;
}

//----- (0000000000062CCC) ----------------------------------------------------
__int64 __fastcall sub_62CCC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x21
  __int64 v5; // x8
  const char *v6; // x0
  __int64 result; // x0
  unsigned int v8; // w8
  int v9; // w9
  int v10; // w8
  __int64 v11; // x8
  unsigned __int64 v12; // x9
  size_t v13; // x8
  unsigned __int64 v14; // x9
  _BYTE *v15; // x0
  size_t v16; // x1
  _BYTE *v17; // x0

  v2 = *(_QWORD *)(a1 + 16);
  if ( *(_BYTE *)(v2 + 8) != 10
    || (v5 = *(_QWORD *)(v2 + 16), *(_BYTE *)(v5 + 8) != 7)
    || (v6 = *(const char **)(v5 + 16), *(_QWORD *)(v5 + 24) - (_QWORD)v6 != 11)
    || (result = strncmp(v6, "objc_object", 0xBu), (_DWORD)result) )
  {
    v8 = *(unsigned __int16 *)(v2 + 9);
    v9 = (v8 >> 8) & 3;
    if ( v9 )
    {
      if ( v9 == 2 )
      {
        if ( ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 8LL))(v2, a2) & 1) != 0 )
          goto LABEL_12;
        v2 = *(_QWORD *)(a1 + 16);
        v8 = *(unsigned __int16 *)(v2 + 9);
      }
      v10 = (v8 >> 10) & 3;
      if ( v10 && (v10 != 2 || ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 16LL))(v2, a2) & 1) == 0) )
        return (*(__int64 (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 40LL))(*(_QWORD *)(a1 + 16), a2);
    }
LABEL_12:
    v11 = a2[1];
    v12 = a2[2];
    if ( v11 + 1 <= v12 )
    {
      v17 = (_BYTE *)*a2;
    }
    else
    {
      v13 = v11 + 993;
      v14 = 2 * v12;
      v15 = (_BYTE *)*a2;
      if ( v14 <= v13 )
        v16 = v13;
      else
        v16 = v14;
      a2[2] = v16;
      v17 = realloc(v15, v16);
      *a2 = v17;
      if ( !v17 )
        std::terminate();
      v11 = a2[1];
    }
    v17[v11] = 41;
    ++a2[1];
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 40LL))(*(_QWORD *)(a1 + 16), a2);
  }
  return result;
}

//----- (0000000000062E1C) ----------------------------------------------------
void __fastcall sub_62E1C(void *a1)
{
  operator delete(a1);
}

//----- (0000000000062E24) ----------------------------------------------------
__int64 __fastcall sub_62E24(__int64 a1)
{
  __int64 v1; // x0
  unsigned int v2; // w8

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned __int8 *)(v1 + 9);
  if ( (v2 & 0xC0) == 0x80 )
    return (**(__int64 (__fastcall ***)(__int64))v1)(v1);
  else
    return v2 < 0x40;
}

//----- (0000000000062E54) ----------------------------------------------------
__int64 __fastcall sub_62E54(__int64 result, char **a2)
{
  __int64 v2; // x19
  __int64 v4; // x0
  unsigned int v5; // w1
  __int64 v6; // x1
  __int64 v7; // x22
  int v8; // w21
  char *v9; // x8
  unsigned __int64 v10; // x9
  size_t v11; // x8
  unsigned __int64 v12; // x9
  char *v13; // x0
  size_t v14; // x1
  char *v15; // x0
  unsigned int v16; // w8
  int v17; // w9
  int v18; // w8
  char *v19; // x8
  unsigned __int64 v20; // x9
  size_t v21; // x8
  unsigned __int64 v22; // x9
  char *v23; // x0
  size_t v24; // x1
  char *v25; // x0
  char *v26; // x8
  size_t v27; // x9
  bool v28; // zf
  size_t v29; // x21
  const char *v30; // x22
  char *v31; // x10
  unsigned __int64 v32; // x9
  char *v33; // x0
  size_t v34; // x1
  char *v35; // x0

  if ( !*(_BYTE *)(result + 28) )
  {
    v2 = result;
    v4 = *(_QWORD *)(result + 16);
    v5 = *(_DWORD *)(v2 + 24);
    *(_BYTE *)(v2 + 28) = 1;
    result = sub_631DC(v4, v5, (__int64)a2);
    v7 = v6;
    if ( !v6 )
    {
LABEL_43:
      *(_BYTE *)(v2 + 28) = 0;
      return result;
    }
    v8 = result;
    (*(void (__fastcall **)(__int64, char **))(*(_QWORD *)v6 + 32LL))(v6, a2);
    if ( (*(_BYTE *)(v7 + 10) & 3) == 0
      || (*(_BYTE *)(v7 + 10) & 3) == 2
      && ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v7 + 8LL))(v7, a2) & 1) != 0 )
    {
      v9 = a2[1];
      v10 = (unsigned __int64)a2[2];
      if ( (unsigned __int64)(v9 + 1) <= v10 )
      {
        v15 = *a2;
      }
      else
      {
        v11 = (size_t)(v9 + 993);
        v12 = 2 * v10;
        v13 = *a2;
        if ( v12 <= v11 )
          v14 = v11;
        else
          v14 = v12;
        a2[2] = (char *)v14;
        v15 = (char *)realloc(v13, v14);
        *a2 = v15;
        if ( !v15 )
          goto LABEL_44;
        v9 = a2[1];
      }
      v9[(_QWORD)v15] = 32;
      ++a2[1];
    }
    v16 = *(unsigned __int16 *)(v7 + 9);
    v17 = (v16 >> 8) & 3;
    if ( !v17 )
      goto LABEL_21;
    if ( v17 == 2 )
    {
      if ( ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v7 + 8LL))(v7, a2) & 1) != 0 )
        goto LABEL_21;
      v16 = *(unsigned __int16 *)(v7 + 9);
    }
    v18 = (v16 >> 10) & 3;
    if ( v18 && (v18 != 2 || ((*(__int64 (__fastcall **)(__int64, char **))(*(_QWORD *)v7 + 16LL))(v7, a2) & 1) == 0) )
    {
LABEL_29:
      v26 = a2[1];
      v27 = (size_t)a2[2];
      v28 = v8 == 0;
      if ( v8 )
        v29 = 2;
      else
        v29 = 1;
      if ( v28 )
        v30 = "&";
      else
        v30 = "&&";
      v31 = &v26[v29];
      if ( (unsigned __int64)&v26[v29] <= v27 )
      {
        v35 = *a2;
        goto LABEL_42;
      }
      v32 = 2 * v27;
      v33 = *a2;
      if ( v32 <= (unsigned __int64)(v31 + 992) )
        v34 = (size_t)(v31 + 992);
      else
        v34 = v32;
      a2[2] = (char *)v34;
      v35 = (char *)realloc(v33, v34);
      *a2 = v35;
      if ( v35 )
      {
        v26 = a2[1];
LABEL_42:
        result = (__int64)memcpy(&v26[(_QWORD)v35], v30, v29);
        a2[1] += v29;
        goto LABEL_43;
      }
LABEL_44:
      std::terminate();
    }
LABEL_21:
    v19 = a2[1];
    v20 = (unsigned __int64)a2[2];
    if ( (unsigned __int64)(v19 + 1) <= v20 )
    {
      v25 = *a2;
    }
    else
    {
      v21 = (size_t)(v19 + 993);
      v22 = 2 * v20;
      v23 = *a2;
      if ( v22 <= v21 )
        v24 = v21;
      else
        v24 = v22;
      a2[2] = (char *)v24;
      v25 = (char *)realloc(v23, v24);
      *a2 = v25;
      if ( !v25 )
        goto LABEL_44;
      v19 = a2[1];
    }
    v19[(_QWORD)v25] = 40;
    ++a2[1];
    goto LABEL_29;
  }
  return result;
}
// 62EA4: variable 'v6' is possibly undefined

//----- (0000000000063094) ----------------------------------------------------
__int64 __fastcall sub_63094(__int64 result, _QWORD *a2)
{
  __int64 v2; // x19
  __int64 v4; // x0
  unsigned int v5; // w1
  __int64 v6; // x1
  __int64 v7; // x21
  unsigned int v8; // w8
  int v9; // w9
  int v10; // w8
  __int64 v11; // x8
  unsigned __int64 v12; // x9
  size_t v13; // x8
  unsigned __int64 v14; // x9
  _BYTE *v15; // x0
  size_t v16; // x1
  _BYTE *v17; // x0

  if ( !*(_BYTE *)(result + 28) )
  {
    v2 = result;
    v4 = *(_QWORD *)(result + 16);
    v5 = *(_DWORD *)(v2 + 24);
    *(_BYTE *)(v2 + 28) = 1;
    result = sub_631DC(v4, v5, (__int64)a2);
    v7 = v6;
    if ( !v6 )
    {
LABEL_19:
      *(_BYTE *)(v2 + 28) = 0;
      return result;
    }
    v8 = *(unsigned __int16 *)(v6 + 9);
    v9 = (v8 >> 8) & 3;
    if ( !v9 )
      goto LABEL_10;
    if ( v9 == 2 )
    {
      if ( ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v6 + 8LL))(v6, a2) & 1) != 0 )
        goto LABEL_10;
      v8 = *(unsigned __int16 *)(v7 + 9);
    }
    v10 = (v8 >> 10) & 3;
    if ( v10 && (v10 != 2 || ((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v7 + 16LL))(v7, a2) & 1) == 0) )
    {
LABEL_18:
      result = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v7 + 40LL))(v7, a2);
      goto LABEL_19;
    }
LABEL_10:
    v11 = a2[1];
    v12 = a2[2];
    if ( v11 + 1 <= v12 )
    {
      v17 = (_BYTE *)*a2;
    }
    else
    {
      v13 = v11 + 993;
      v14 = 2 * v12;
      v15 = (_BYTE *)*a2;
      if ( v14 <= v13 )
        v16 = v13;
      else
        v16 = v14;
      a2[2] = v16;
      v17 = realloc(v15, v16);
      *a2 = v17;
      if ( !v17 )
        std::terminate();
      v11 = a2[1];
    }
    v17[v11] = 41;
    ++a2[1];
    goto LABEL_18;
  }
  return result;
}
// 630E4: variable 'v6' is possibly undefined

//----- (00000000000631D4) ----------------------------------------------------
void __fastcall sub_631D4(void *a1)
{
  operator delete(a1);
}

//----- (00000000000631DC) ----------------------------------------------------
__int64 __fastcall sub_631DC(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v6; // x0
  char *v7; // x8
  signed __int64 v8; // x23
  char *v9; // x24
  char *v10; // x0
  char *v11; // x0
  __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x8
  char *ptr; // [xsp+8h] [xbp-58h]
  char *v17; // [xsp+10h] [xbp-50h]
  char *v18; // [xsp+18h] [xbp-48h]
  _OWORD v19[4]; // [xsp+20h] [xbp-40h] BYREF
  __int64 vars0; // [xsp+60h] [xbp+0h] BYREF

  ptr = (char *)v19;
  v17 = (char *)v19;
  v18 = (char *)&vars0;
  memset(v19, 0, sizeof(v19));
  while ( 1 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, a3);
    if ( *(_BYTE *)(v6 + 8) != 12 )
      break;
    v7 = v17;
    a1 = *(_QWORD *)(v6 + 16);
    if ( *(_DWORD *)(v6 + 24) < (signed int)a2 )
      a2 = *(_DWORD *)(v6 + 24);
    if ( v17 == v18 )
    {
      v8 = v17 - ptr;
      if ( ptr == (char *)v19 )
      {
        v10 = (char *)malloc(2 * (v17 - ptr));
        if ( !v10 )
          goto LABEL_21;
        v9 = v10;
        memcpy(v10, v19, v8);
        ptr = v9;
      }
      else
      {
        v9 = (char *)realloc(ptr, 2 * (v17 - ptr));
        ptr = v9;
        if ( !v9 )
          goto LABEL_21;
      }
      v7 = &v9[v8];
      v18 = &v9[8 * (v8 >> 2)];
    }
    v17 = v7 + 8;
    *(_QWORD *)v7 = a1;
    v11 = ptr;
    v12 = v17 - ptr;
    if ( (unsigned __int64)(v17 - ptr) >= 9 )
    {
      v13 = v12 >> 3;
      v14 = (unsigned __int64)((v12 >> 3) - 1) >> 1;
      if ( v13 <= v14 )
      {
        __assert2(
          "out/llvm-project/libcxxabi/src/demangle/ItaniumDemangle.h",
          143,
          "T &(anonymous namespace)::itanium_demangle::PODSmallVector<const (anonymous namespace)::itanium_demangle::Node"
          " *, 8>::operator[](size_t) [T = const (anonymous namespace)::itanium_demangle::Node *, N = 8]",
          "Index < size() && \"Invalid access!\"");
LABEL_21:
        std::terminate();
      }
      if ( a1 == *(_QWORD *)&ptr[8 * v14] )
      {
        if ( ptr == (char *)v19 )
          return a2;
        goto LABEL_18;
      }
    }
  }
  v11 = ptr;
  if ( ptr == (char *)v19 )
    return a2;
LABEL_18:
  free(v11);
  return a2;
}
// 6AB10: using guessed type __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (000000000006337C) ----------------------------------------------------
void *__fastcall sub_6337C(__int64 a1, void **a2)
{
  void *result; // x0
  _BYTE *v5; // x8
  _BYTE *v6; // x21
  size_t v7; // x20
  char *v8; // x8
  size_t v9; // x9
  char *v10; // x10
  unsigned __int64 v11; // x9
  void *v12; // x0
  size_t v13; // x1
  char *v14; // x0

  result = (void *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(*(_QWORD *)(a1 + 16));
  v6 = *(_BYTE **)(a1 + 24);
  v5 = *(_BYTE **)(a1 + 32);
  v7 = v5 - v6;
  if ( v5 != v6 )
  {
    v8 = (char *)a2[1];
    v9 = (size_t)a2[2];
    v10 = &v8[v7];
    if ( (unsigned __int64)&v8[v7] <= v9 )
    {
      v14 = (char *)*a2;
    }
    else
    {
      v11 = 2 * v9;
      v12 = *a2;
      if ( v11 <= (unsigned __int64)(v10 + 992) )
        v13 = (size_t)(v10 + 992);
      else
        v13 = v11;
      a2[2] = (void *)v13;
      v14 = (char *)realloc(v12, v13);
      *a2 = v14;
      if ( !v14 )
        std::terminate();
      v8 = (char *)a2[1];
    }
    result = memcpy(&v8[(_QWORD)v14], v6, v7);
    a2[1] = (char *)a2[1] + v7;
  }
  return result;
}

//----- (0000000000063428) ----------------------------------------------------
void __fastcall sub_63428(void *a1)
{
  operator delete(a1);
}

//----- (0000000000063430) ----------------------------------------------------
void *__fastcall operator new(size_t a1)
{
  size_t v1; // x19
  void *result; // x0
  void (*new_handler)(void); // x0
  _QWORD *exception; // x19

  if ( a1 )
    v1 = a1;
  else
    v1 = 1;
  for ( result = malloc(v1); !result; result = malloc(v1) )
  {
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = __cxa_allocate_exception(8u);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return result;
}
// 6EE40: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (00000000000634A4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new(size_t a1, const std::nothrow_t *a2)
{
  return operator new(a1);
}
// 634D0: positive sp value 10 has been found

//----- (00000000000634DC) ----------------------------------------------------
void *__fastcall operator new[](size_t a1)
{
  return operator new(a1);
}

//----- (00000000000634E4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new[](size_t a1, const std::nothrow_t *a2)
{
  return operator new[](a1);
}
// 63510: positive sp value 10 has been found

//----- (000000000006351C) ----------------------------------------------------
void __fastcall operator delete(void *ptr)
{
  free(ptr);
}

//----- (0000000000063524) ----------------------------------------------------
void __fastcall operator delete(void *a1, const std::nothrow_t *a2)
{
  operator delete(a1);
}

//----- (000000000006352C) ----------------------------------------------------
void __fastcall operator delete(void *a1)
{
  operator delete(a1);
}

//----- (0000000000063534) ----------------------------------------------------
void __fastcall operator delete[](void *a1)
{
  operator delete(a1);
}

//----- (000000000006353C) ----------------------------------------------------
void __fastcall operator delete[](void *a1, const std::nothrow_t *a2)
{
  operator delete[](a1);
}

//----- (0000000000063544) ----------------------------------------------------
void __fastcall operator delete[](void *a1)
{
  operator delete[](a1);
}

//----- (000000000006354C) ----------------------------------------------------
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  size_t v2; // x19
  size_t v3; // x20
  void *result; // x0
  void (*new_handler)(void); // x0
  _QWORD *exception; // x19
  void *memptr; // [xsp+8h] [xbp-8h] BYREF

  if ( a1 )
    v2 = a1;
  else
    v2 = 1;
  if ( a2 <= 8 )
    v3 = 8;
  else
    v3 = a2;
  while ( 1 )
  {
    memptr = 0;
    posix_memalign(&memptr, v3, v2);
    result = memptr;
    if ( memptr )
      break;
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = __cxa_allocate_exception(8u);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return result;
}
// 6EE40: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (00000000000635DC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  return operator new(a1, a2);
}
// 63608: positive sp value 10 has been found

//----- (0000000000063614) ----------------------------------------------------
void *__fastcall operator new[](size_t a1, unsigned __int64 a2)
{
  return operator new(a1, a2);
}

//----- (000000000006361C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall operator new[](size_t a1, unsigned __int64 a2)
{
  return operator new[](a1, a2);
}
// 63648: positive sp value 10 has been found

//----- (0000000000063654) ----------------------------------------------------
void __fastcall operator delete(void *ptr)
{
  free(ptr);
}

//----- (000000000006365C) ----------------------------------------------------
void __fastcall operator delete(void *ptr)
{
  operator delete(ptr);
}

//----- (0000000000063664) ----------------------------------------------------
void __fastcall operator delete(void *ptr)
{
  operator delete(ptr);
}

//----- (0000000000063670) ----------------------------------------------------
void __fastcall operator delete[](void *ptr)
{
  operator delete(ptr);
}

//----- (0000000000063678) ----------------------------------------------------
void __fastcall operator delete[](void *ptr)
{
  operator delete[](ptr);
}

//----- (0000000000063680) ----------------------------------------------------
void __fastcall operator delete[](void *ptr)
{
  operator delete[](ptr);
}

//----- (000000000006368C) ----------------------------------------------------
__int64 __fastcall sub_6368C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000063698) ----------------------------------------------------
bool __fastcall sub_63698(_QWORD *a1)
{
  return *a1 >> 8 == 0x434C4E47432B2BLL;
}

//----- (00000000000636BC) ----------------------------------------------------
void *_cxa_allocate_exception(size_t thrown_size)
{
  size_t v1; // x19
  int *v2; // x0
  int *v3; // x20

  v1 = (thrown_size + 143) & 0xFFFFFFFFFFFFFFF0LL;
  v2 = sub_63EA8(v1);
  v3 = v2;
  if ( !v2 )
    std::terminate();
  memset(v2, 0, v1);
  return v3 + 32;
}

//----- (0000000000063710) ----------------------------------------------------
void *_cxa_begin_catch(void *a1)
{
  unsigned __int64 v2; // x20
  char **globals; // x0
  char *v4; // x9
  int v5; // w8
  int v6; // w10
  char *v7; // x8
  bool v8; // zf
  void *v9; // x8

  v2 = *(_QWORD *)a1;
  globals = (char **)__cxa_get_globals();
  v4 = (char *)a1 - 96;
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    v5 = *((_DWORD *)a1 - 10);
    if ( v5 >= 0 )
      v6 = *((_DWORD *)a1 - 10);
    else
      v6 = -v5;
    v7 = *globals;
    v8 = v4 == *globals;
    *((_DWORD *)a1 - 10) = v6 + 1;
    if ( !v8 )
    {
      *((_QWORD *)a1 - 6) = v7;
      *globals = v4;
    }
    v9 = (void *)*((_QWORD *)a1 - 1);
    --*((_DWORD *)globals + 2);
    return v9;
  }
  else
  {
    if ( *globals )
      std::terminate();
    *globals = v4;
    return (char *)a1 + 32;
  }
}
// 4A7CC: using guessed type void __fastcall __noreturn sub_4A7CC(_QWORD);

//----- (00000000000637BC) ----------------------------------------------------
void _cxa_free_exception(void *a1)
{
  sub_640A0((char *)a1 - 128);
}

//----- (00000000000637E0) ----------------------------------------------------
long double _cxa_allocate_dependent_exception()
{
  int *v0; // x0
  long double result; // q0

  v0 = sub_63EA8(0x80u);
  if ( !v0 )
    std::terminate();
  *(_OWORD *)&result = 0u;
  *((_OWORD *)v0 + 2) = 0u;
  *((_OWORD *)v0 + 3) = 0u;
  *((_OWORD *)v0 + 4) = 0u;
  *((_OWORD *)v0 + 5) = 0u;
  *((_OWORD *)v0 + 6) = 0u;
  *((_OWORD *)v0 + 7) = 0u;
  *(_OWORD *)v0 = 0u;
  *((_OWORD *)v0 + 1) = 0u;
  return result;
}

//----- (000000000006381C) ----------------------------------------------------
void __fastcall _cxa_free_dependent_exception(char *ptr)
{
  sub_640A0(ptr);
}

//----- (0000000000063824) ----------------------------------------------------
void __noreturn _cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  _QWORD *globals; // x22
  unsigned __int64 terminate; // x0
  int v8; // w8
  __int64 v9; // x8
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7

  globals = __cxa_get_globals();
  *((_QWORD *)a1 - 12) = std::get_unexpected();
  terminate = std::get_terminate();
  *((_QWORD *)a1 - 4) = 0x434C4E47432B2B00LL;
  a1 = (char *)a1 - 32;
  v8 = *((_DWORD *)globals + 2);
  *((_QWORD *)a1 - 7) = terminate;
  *((_QWORD *)a1 - 10) = lptinfo;
  *((_QWORD *)a1 - 9) = a3;
  *((_QWORD *)a1 - 11) = 1;
  v9 = (unsigned int)(v8 + 1);
  *((_QWORD *)a1 + 1) = &loc_638A8;
  *((_DWORD *)globals + 2) = v9;
  sub_65BE0(a1, v10, v11, v12, v13, v14, v15, v16, v9, v17, v18, v19, v20, v21, v22, v23, v24);
  sub_63910((__int64)a1 - 96);
}
// 6389C: variable 'v10' is possibly undefined
// 6389C: variable 'v11' is possibly undefined
// 6389C: variable 'v12' is possibly undefined
// 6389C: variable 'v13' is possibly undefined
// 6389C: variable 'v14' is possibly undefined
// 6389C: variable 'v15' is possibly undefined
// 6389C: variable 'v16' is possibly undefined
// 6389C: variable 'v17' is possibly undefined
// 6389C: variable 'v18' is possibly undefined
// 6389C: variable 'v19' is possibly undefined
// 6389C: variable 'v20' is possibly undefined
// 6389C: variable 'v21' is possibly undefined
// 6389C: variable 'v22' is possibly undefined
// 6389C: variable 'v23' is possibly undefined
// 6389C: variable 'v24' is possibly undefined

//----- (0000000000063910) ----------------------------------------------------
void __fastcall __noreturn sub_63910(__int64 a1)
{
  __cxa_begin_catch((void *)(a1 + 96));
  sub_4A880(*(void (**)(void))(a1 + 40));
}

//----- (0000000000063934) ----------------------------------------------------
void *_cxa_get_exception_ptr(void *a1)
{
  return (void *)*((_QWORD *)a1 - 1);
}

//----- (0000000000063940) ----------------------------------------------------
void _cxa_end_catch(void)
{
  __int64 *globals_fast; // x0
  __int64 v1; // x19
  __int64 *v2; // x20
  int v3; // w8
  int v4; // w8
  __int64 v5; // x20
  void (__fastcall *v6)(__int64); // x8

  globals_fast = __cxa_get_globals_fast();
  v1 = *globals_fast;
  if ( *globals_fast )
  {
    v2 = globals_fast;
    if ( *(_QWORD *)(v1 + 96) >> 8 == 0x434C4E47432B2BLL )
    {
      v3 = *(_DWORD *)(v1 + 56);
      if ( v3 < 0 )
      {
        *(_DWORD *)(v1 + 56) = v3 + 1;
        if ( v3 == -1 )
          *globals_fast = *(_QWORD *)(v1 + 48);
      }
      else
      {
        v4 = v3 - 1;
        *(_DWORD *)(v1 + 56) = v4;
        if ( !v4 )
        {
          *globals_fast = *(_QWORD *)(v1 + 48);
          if ( *(_BYTE *)(v1 + 96) == 1 )
          {
            v5 = *(_QWORD *)(v1 + 8) - 128LL;
            sub_640A0((char *)v1);
            v1 = v5;
          }
          if ( sub_65BB0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v1 + 8)) == 1 )
          {
            v6 = *(void (__fastcall **)(__int64))(v1 + 24);
            if ( v6 )
              v6(v1 + 128);
            sub_640A0((char *)v1);
          }
        }
      }
    }
    else
    {
      sub_65FF4(v1 + 96);
      *v2 = 0;
    }
  }
}

//----- (0000000000063A40) ----------------------------------------------------
void __fastcall _cxa_decrement_exception_refcount(__int64 a1)
{
  void (__fastcall *v2)(__int64); // x8

  if ( a1 && sub_65BB0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(a1 - 120)) == 1 )
  {
    v2 = *(void (__fastcall **)(__int64))(a1 - 104);
    if ( v2 )
      v2(a1);
    sub_640A0((char *)(a1 - 128));
  }
}

//----- (0000000000063A9C) ----------------------------------------------------
struct type_info *_cxa_current_exception_type(void)
{
  struct type_info *result; // x0
  __int64 v1; // x8

  result = (struct type_info *)__cxa_get_globals_fast();
  if ( result )
  {
    v1 = *(_QWORD *)result;
    if ( *(_QWORD *)result && *(_QWORD *)(v1 + 96) >> 8 == 0x434C4E47432B2BLL )
      return *(struct type_info **)(v1 + 16);
    else
      return 0;
  }
  return result;
}

//----- (0000000000063AF4) ----------------------------------------------------
void __noreturn _cxa_rethrow(void)
{
  _QWORD *globals; // x0
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  __int64 v16; // x20
  __int64 v17; // x8
  unsigned __int64 v18; // x22
  int v19; // w9
  __int64 v20; // x19
  _QWORD *v21; // x0
  int v22; // w8
  int v23; // w9
  __int64 v24; // x8
  bool v25; // zf

  globals = __cxa_get_globals();
  v16 = *globals;
  if ( !*globals )
    goto LABEL_2;
  v17 = *(_QWORD *)(v16 + 96);
  v18 = v17 & 0xFFFFFFFFFFFFFF00LL;
  if ( (v17 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
  {
    v17 = (unsigned int)-*(_DWORD *)(v16 + 56);
    v19 = *((_DWORD *)globals + 2) + 1;
    *(_DWORD *)(v16 + 56) = v17;
    *((_DWORD *)globals + 2) = v19;
  }
  else
  {
    *globals = 0;
  }
  sub_65BE0((_QWORD *)(v16 + 96), v1, v2, v3, v4, v5, v6, v7, v17, v8, v9, v10, v11, v12, v13, v14, v15);
  v20 = *(_QWORD *)(v16 + 96);
  v21 = __cxa_get_globals();
  if ( (v20 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
  {
    v22 = *(_DWORD *)(v16 + 56);
    if ( v22 >= 0 )
      v23 = *(_DWORD *)(v16 + 56);
    else
      v23 = -v22;
    v24 = *v21;
    v25 = v16 == *v21;
    *(_DWORD *)(v16 + 56) = v23 + 1;
    if ( !v25 )
    {
      *(_QWORD *)(v16 + 48) = v24;
      *v21 = v16;
    }
    --*((_DWORD *)v21 + 2);
    if ( v18 != 0x434C4E47432B2B00LL )
LABEL_2:
      std::terminate();
  }
  else
  {
    if ( *v21 )
      goto LABEL_2;
    *v21 = v16;
    if ( v18 != 0x434C4E47432B2B00LL )
      goto LABEL_2;
  }
  sub_4A880(*(void (**)(void))(v16 + 40));
}
// 63B60: variable 'v1' is possibly undefined
// 63B60: variable 'v2' is possibly undefined
// 63B60: variable 'v3' is possibly undefined
// 63B60: variable 'v4' is possibly undefined
// 63B60: variable 'v5' is possibly undefined
// 63B60: variable 'v6' is possibly undefined
// 63B60: variable 'v7' is possibly undefined
// 63B60: variable 'v8' is possibly undefined
// 63B60: variable 'v9' is possibly undefined
// 63B60: variable 'v10' is possibly undefined
// 63B60: variable 'v11' is possibly undefined
// 63B60: variable 'v12' is possibly undefined
// 63B60: variable 'v13' is possibly undefined
// 63B60: variable 'v14' is possibly undefined
// 63B60: variable 'v15' is possibly undefined

//----- (0000000000063BD8) ----------------------------------------------------
unsigned __int64 __fastcall _cxa_increment_exception_refcount(unsigned __int64 result)
{
  if ( result )
    return sub_65BB0(1u, (atomic_ullong *)(result - 120));
  return result;
}

//----- (0000000000063C04) ----------------------------------------------------
__int64 _cxa_current_primary_exception()
{
  __int64 *globals_fast; // x0
  __int64 v1; // x8
  __int64 v2; // x19

  globals_fast = __cxa_get_globals_fast();
  if ( !globals_fast )
    return 0;
  v1 = *globals_fast;
  if ( !*globals_fast || *(_QWORD *)(v1 + 96) >> 8 != 0x434C4E47432B2BLL )
    return 0;
  if ( (unsigned __int8)*(_QWORD *)(v1 + 96) == 1 )
    v1 = *(_QWORD *)(v1 + 8) - 128LL;
  v2 = v1 + 128;
  sub_65BB0(1u, (atomic_ullong *)(v1 + 8));
  return v2;
}

//----- (0000000000063C94) ----------------------------------------------------
_QWORD *__fastcall _cxa_rethrow_primary_exception(_QWORD *result)
{
  _QWORD *v1; // x20
  int *v2; // x0
  int *v3; // x19
  __int64 *v4; // x21
  _QWORD *globals; // x0
  __int64 v6; // x8
  __int64 v7; // x1
  __int64 v8; // x2
  __int64 v9; // x3
  __int64 v10; // x4
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  __int64 v22; // x20
  int v23; // w8
  int v24; // w9
  __int64 v25; // x8
  bool v26; // zf

  if ( !result )
    return result;
  v1 = result;
  v2 = sub_63EA8(0x80u);
  if ( !v2 )
LABEL_13:
    std::terminate();
  v3 = v2;
  *((_OWORD *)v2 + 7) = 0u;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  v4 = (__int64 *)(v2 + 24);
  *((_QWORD *)v2 + 1) = v1;
  sub_65BB0(1u, (atomic_ullong *)(v1 - 15));
  *((_QWORD *)v3 + 2) = *(v1 - 14);
  *((_QWORD *)v3 + 4) = std::get_unexpected();
  *((_QWORD *)v3 + 5) = std::get_terminate();
  *v4 = 0x434C4E47432B2B01LL;
  globals = __cxa_get_globals();
  *((_QWORD *)v3 + 13) = sub_63DC4;
  v6 = (unsigned int)(*((_DWORD *)globals + 2) + 1);
  *((_DWORD *)globals + 2) = v6;
  sub_65BE0(v4, v7, v8, v9, v10, v11, v12, v13, v6, v14, v15, v16, v17, v18, v19, v20, v21);
  v22 = *v4;
  result = __cxa_get_globals();
  if ( (v22 & 0xFFFFFFFFFFFFFF00LL) != 0x434C4E47432B2B00LL )
  {
    if ( !*result )
    {
      *result = v3;
      return result;
    }
    goto LABEL_13;
  }
  v23 = v3[14];
  if ( v23 >= 0 )
    v24 = v3[14];
  else
    v24 = -v23;
  v25 = *result;
  v26 = v3 == (int *)*result;
  v3[14] = v24 + 1;
  if ( !v26 )
  {
    *((_QWORD *)v3 + 6) = v25;
    *result = v3;
  }
  --*((_DWORD *)result + 2);
  return result;
}
// 63D3C: variable 'v7' is possibly undefined
// 63D3C: variable 'v8' is possibly undefined
// 63D3C: variable 'v9' is possibly undefined
// 63D3C: variable 'v10' is possibly undefined
// 63D3C: variable 'v11' is possibly undefined
// 63D3C: variable 'v12' is possibly undefined
// 63D3C: variable 'v13' is possibly undefined
// 63D3C: variable 'v14' is possibly undefined
// 63D3C: variable 'v15' is possibly undefined
// 63D3C: variable 'v16' is possibly undefined
// 63D3C: variable 'v17' is possibly undefined
// 63D3C: variable 'v18' is possibly undefined
// 63D3C: variable 'v19' is possibly undefined
// 63D3C: variable 'v20' is possibly undefined
// 63D3C: variable 'v21' is possibly undefined

//----- (0000000000063DC4) ----------------------------------------------------
void __fastcall sub_63DC4(int a1, __int64 a2)
{
  __int64 v3; // x20
  void (__fastcall *v4)(__int64); // x8

  if ( a1 != 1 )
    sub_4A880(*(void (**)(void))(a2 - 56));
  v3 = *(_QWORD *)(a2 - 88);
  if ( v3 && sub_65BB0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v3 - 120)) == 1 )
  {
    v4 = *(void (__fastcall **)(__int64))(v3 - 104);
    if ( v4 )
      v4(v3);
    sub_640A0((char *)(v3 - 128));
  }
  sub_640A0((char *)(a2 - 96));
}

//----- (0000000000063E38) ----------------------------------------------------
bool _cxa_uncaught_exception()
{
  _QWORD *globals_fast; // x0

  globals_fast = __cxa_get_globals_fast();
  return globals_fast && *((_DWORD *)globals_fast + 2) != 0;
}

//----- (0000000000063E80) ----------------------------------------------------
_QWORD *_cxa_uncaught_exceptions()
{
  _QWORD *result; // x0

  result = __cxa_get_globals_fast();
  if ( result )
    return (_QWORD *)*((unsigned int *)result + 2);
  return result;
}

//----- (0000000000063EA8) ----------------------------------------------------
int *__fastcall sub_63EA8(size_t a1)
{
  size_t v1; // x19
  int *result; // x0
  void *memptr; // [xsp+18h] [xbp+18h] BYREF

  if ( a1 )
    v1 = a1;
  else
    v1 = 1;
  memptr = 0;
  posix_memalign(&memptr, 0x10u, v1);
  result = (int *)memptr;
  if ( !memptr )
    return sub_63F04(v1);
  return result;
}

//----- (0000000000063F04) ----------------------------------------------------
int *__fastcall sub_63F04(__int64 a1)
{
  int *v2; // x12
  int *v3; // x10
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x11
  int *v6; // x19
  unsigned __int64 v7; // x13
  int *v8; // x8
  __int64 v9; // x12
  unsigned __int64 v10; // x12
  __int64 v11; // x13
  unsigned __int16 *v12; // x10
  __int64 v13; // x9
  _QWORD *v15; // x19
  __int64 v16; // x1
  __int64 v17; // x2
  __int64 v18; // x3
  __int64 v19; // x4
  __int64 v20; // x5
  __int64 v21; // x6
  __int64 v22; // x7
  __int64 v23; // x8
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7

  pthread_mutex_lock(&stru_78AE8);
  v2 = (int *)qword_78AE0;
  if ( qword_78AE0 )
  {
    if ( (char *)qword_78AE0 == &byte_78D10 )
      goto LABEL_12;
  }
  else
  {
    dword_78B1C = 8192128;
    v2 = &dword_78B1C;
    qword_78AE0 = (__int64)&dword_78B1C;
    if ( &dword_78B1C == (int *)&byte_78D10 )
    {
LABEL_12:
      v6 = 0;
      goto LABEL_18;
    }
  }
  v3 = 0;
  v4 = (unsigned __int64)(a1 + 3) >> 2;
  v5 = v4 + 1;
  while ( 1 )
  {
    v6 = v2 + 1;
    if ( ((unsigned __int64)(v2 + 1) & 0xF) != 0 )
    {
      v15 = (_QWORD *)__assert2(
                        "out/llvm-project/libcxxabi/src/fallback_malloc.cpp",
                        145,
                        "void *(anonymous namespace)::fallback_malloc(size_t)",
                        "reinterpret_cast<size_t>(p + 1) % RequiredAlignment == 0");
      pthread_mutex_unlock(&stru_78AE8);
      sub_65E10(v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31);
    }
    v7 = *((unsigned __int16 *)v2 + 1);
    v8 = v2;
    v9 = ((_BYTE)v7 - (_BYTE)v5) & 3;
    if ( v5 >= v7 )
      v9 = 0;
    v10 = v9 + v5;
    if ( v10 < v7 )
      break;
    if ( v4 < v7 )
      goto LABEL_15;
    v11 = 4LL * *(unsigned __int16 *)v8;
    v2 = (int *)((char *)&qword_78AE0 + v11 + 48);
    v3 = v8;
    if ( v11 == 512 )
      goto LABEL_12;
  }
  v12 = (unsigned __int16 *)&v8[(unsigned __int16)(v7 - v10)];
  v6 = (int *)(v12 + 2);
  *((_WORD *)v8 + 1) = v7 - v10;
  *v12 = 0;
  v12[1] = v10;
  if ( ((unsigned __int64)(v12 + 2) & 0xF) == 0 )
    goto LABEL_18;
  __assert2(
    "out/llvm-project/libcxxabi/src/fallback_malloc.cpp",
    166,
    "void *(anonymous namespace)::fallback_malloc(size_t)",
    "reinterpret_cast<size_t>(ptr) % RequiredAlignment == 0");
LABEL_15:
  v13 = *(unsigned __int16 *)v8;
  if ( v3 )
  {
    *(_WORD *)v3 = v13;
    *(_WORD *)v8 = 0;
  }
  else
  {
    *(_WORD *)v8 = 0;
    qword_78AE0 = (__int64)&qword_78AE0 + 4 * v13 + 48;
  }
LABEL_18:
  pthread_mutex_unlock(&stru_78AE8);
  return v6;
}
// 64018: variable 'v8' is possibly undefined
// 6401C: variable 'v3' is possibly undefined
// 64098: variable 'v16' is possibly undefined
// 64098: variable 'v17' is possibly undefined
// 64098: variable 'v18' is possibly undefined
// 64098: variable 'v19' is possibly undefined
// 64098: variable 'v20' is possibly undefined
// 64098: variable 'v21' is possibly undefined
// 64098: variable 'v22' is possibly undefined
// 64098: variable 'v23' is possibly undefined
// 64098: variable 'v24' is possibly undefined
// 64098: variable 'v25' is possibly undefined
// 64098: variable 'v26' is possibly undefined
// 64098: variable 'v27' is possibly undefined
// 64098: variable 'v28' is possibly undefined
// 64098: variable 'v29' is possibly undefined
// 64098: variable 'v30' is possibly undefined
// 64098: variable 'v31' is possibly undefined
// 6AB10: using guessed type __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...);
// 78AE0: using guessed type __int64 qword_78AE0;
// 78AE8: using guessed type pthread_mutex_t stru_78AE8;
// 78B1C: using guessed type int dword_78B1C;
// 78D10: using guessed type char byte_78D10;

//----- (00000000000640A0) ----------------------------------------------------
void __fastcall sub_640A0(char *ptr)
{
  char *v2; // x20
  int v3; // w8
  char *v4; // x10
  char *v5; // x9
  __int64 v6; // x11
  __int64 v7; // x12
  __int64 v8; // x11
  __int16 v9; // w9

  if ( ptr < byte_78B10 || ptr >= &byte_78D10 )
  {
    free(ptr);
  }
  else
  {
    v2 = ptr - 4;
    pthread_mutex_lock(&stru_78AE8);
    v3 = qword_78AE0;
    if ( !qword_78AE0 || (char *)qword_78AE0 == &byte_78D10 )
    {
LABEL_9:
      qword_78AE0 = (__int64)v2;
      *(_WORD *)v2 = (v3 - (unsigned int)&qword_78AE0 - 48) >> 2;
    }
    else
    {
      v4 = 0;
      v5 = (char *)qword_78AE0;
      while ( 1 )
      {
        v6 = *((unsigned __int16 *)v5 + 1);
        if ( &v5[4 * v6] == v2 )
        {
          *((_WORD *)v5 + 1) = *((_WORD *)ptr - 1) + v6;
          goto LABEL_15;
        }
        v7 = *((unsigned __int16 *)ptr - 1);
        if ( &v2[4 * v7] == v5 )
          break;
        v8 = 4LL * *(unsigned __int16 *)v5;
        v4 = v5;
        v5 = (char *)&qword_78AE0 + v8 + 48;
        if ( v8 == 512 )
          goto LABEL_9;
      }
      *((_WORD *)ptr - 1) = v7 + v6;
      if ( v4 )
      {
        *(_WORD *)v4 = ((unsigned int)v2 - (unsigned int)&qword_78AE0 - 48) >> 2;
      }
      else
      {
        v9 = *(_WORD *)v5;
        qword_78AE0 = (__int64)(ptr - 4);
        *(_WORD *)v2 = v9;
      }
    }
LABEL_15:
    pthread_mutex_unlock(&stru_78AE8);
  }
}
// 78AE0: using guessed type __int64 qword_78AE0;
// 78AE8: using guessed type pthread_mutex_t stru_78AE8;
// 78D10: using guessed type char byte_78D10;

//----- (00000000000641E0) ----------------------------------------------------
__int64 __fastcall _gxx_personality_v0(int a1, int a2, __int64 a3, unsigned __int16 *a4, __int64 a5)
{
  __int64 result; // x0
  char v9; // w21
  unsigned __int64 v10; // x22
  __int64 v11; // x21
  __int64 v12; // x22
  __int64 v13; // x21
  __int64 v14; // x9
  __int64 v15; // x10
  __int128 v16; // q0
  __int64 v17; // x0
  int v18; // w1
  char v19; // w2
  unsigned __int16 *v20; // x3
  __int64 v21; // x4
  __int64 v22; // [xsp+0h] [xbp-30h] BYREF
  __int128 v23; // [xsp+8h] [xbp-28h]
  __int64 v24; // [xsp+18h] [xbp-18h]
  __int64 v25; // [xsp+20h] [xbp-10h]
  unsigned int v26; // [xsp+28h] [xbp-8h]

  result = 3;
  if ( a1 != 1 || !a4 || !a5 )
    return result;
  v9 = a2;
  v10 = a3 & 0xFFFFFFFFFFFFFF00LL;
  if ( a2 == 6 )
  {
    if ( v10 == 0x434C4E47432B2B00LL )
    {
      v11 = *((int *)a4 - 9);
      v12 = *((_QWORD *)a4 - 2);
      sub_66010(a5, 0, (__int64)a4);
      sub_66010(a5, 1u, v11);
      sub_66048(a5, v12);
      if ( (v11 & 0x80000000) == 0 )
        return 7;
LABEL_18:
      result = 7;
      *((_QWORD *)a4 - 2) = 0;
      return result;
    }
    sub_6443C((__int64)&v22, 6, 0, a4, a5);
    result = v26;
    if ( v26 == 3 )
      return result;
  }
  else
  {
    sub_6443C((__int64)&v22, a2, v10 == 0x434C4E47432B2B00LL, a4, a5);
    result = v26;
    if ( v26 == 3 )
      return result;
  }
  if ( (_DWORD)result != 8 )
  {
    if ( (v9 & 1) == 0 )
    {
      if ( (v9 & 2) != 0 )
      {
        if ( (_DWORD)result == 6 )
        {
          sub_66010(a5, 0, (__int64)a4);
          v13 = v22;
          sub_66010(a5, 1u, v22);
          sub_66048(a5, v24);
          if ( (v13 & 0x8000000000000000LL) == 0 )
            return 7;
          goto LABEL_18;
        }
      }
      else
      {
        __assert2(
          "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
          980,
          "_Unwind_Reason_Code __cxxabiv1::__gxx_personality_v0(int, _Unwind_Action, uint64_t, _Unwind_Exception *, _Unwind_Context *)",
          "actions & _UA_CLEANUP_PHASE");
      }
      __assert2(
        "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
        981,
        "_Unwind_Reason_Code __cxxabiv1::__gxx_personality_v0(int, _Unwind_Action, uint64_t, _Unwind_Exception *, _Unwind_Context *)",
        "results.reason == _URC_HANDLER_FOUND");
LABEL_25:
      v17 = __assert2(
              "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
              967,
              "_Unwind_Reason_Code __cxxabiv1::__gxx_personality_v0(int, _Unwind_Action, uint64_t, _Unwind_Exception *, _"
              "Unwind_Context *)",
              "results.reason == _URC_HANDLER_FOUND");
      return sub_6443C(v17, v18, v19, v20, v21);
    }
    if ( (_DWORD)result != 6 )
      goto LABEL_25;
    if ( v10 == 0x434C4E47432B2B00LL )
    {
      v14 = v24;
      v15 = v25;
      result = 6;
      v16 = v23;
      *((_DWORD *)a4 - 9) = v22;
      *((_OWORD *)a4 - 2) = v16;
      *((_QWORD *)a4 - 2) = v14;
      *((_QWORD *)a4 - 1) = v15;
    }
    else
    {
      return 6;
    }
  }
  return result;
}
// 64439: variable 'v18' is possibly undefined
// 64439: variable 'v19' is possibly undefined
// 64439: variable 'v20' is possibly undefined
// 64439: variable 'v21' is possibly undefined
// 6AB10: using guessed type __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (000000000006443C) ----------------------------------------------------
__int64 __fastcall sub_6443C(__int64 result, int a2, char a3, unsigned __int16 *a4, __int64 a5)
{
  char v7; // w22
  __int64 v8; // x19
  int v9; // w8
  __int64 v10; // x24
  __int64 v11; // x25
  __int64 v12; // x26
  unsigned __int8 v13; // t1
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x9
  char *v16; // x21
  __int64 v17; // x9
  __int64 v18; // x8
  char v19; // t1
  unsigned __int64 v20; // x11
  __int64 v21; // x24
  __int64 v22; // x9
  unsigned int v23; // w8
  unsigned __int64 v24; // x28
  unsigned __int16 *v25; // x21
  unsigned __int8 v26; // w25
  unsigned __int8 v27; // t1
  char v28; // t1
  unsigned __int64 v29; // x11
  unsigned __int16 *v30; // x9
  unsigned __int16 *v31; // x23
  unsigned __int64 v32; // x26
  unsigned __int64 v33; // x27
  __int64 v34; // x10
  __int64 v35; // x8
  char v36; // t1
  unsigned __int64 v37; // x12
  int v38; // w27
  __int64 v39; // x28
  __int64 v40; // x21
  unsigned __int64 v41; // x9
  __int64 v42; // x8
  unsigned __int8 *v43; // x23
  unsigned int v44; // w10
  unsigned int v45; // t1
  unsigned __int64 v46; // x11
  bool v47; // cf
  __int64 v48; // x9
  int v49; // w11
  __int64 v50; // x25
  __int64 v51; // x26
  __int64 v52; // x0
  unsigned __int16 *v53; // x8
  __int64 v54; // x1
  int v55; // w8
  unsigned __int16 *v56; // x26
  __int64 v57; // x3
  unsigned __int64 v58; // x10
  __int64 v59; // x9
  unsigned __int8 *v60; // x11
  unsigned int v61; // w12
  unsigned int v62; // t1
  unsigned __int64 v63; // x13
  __int64 v64; // x10
  int v65; // w11
  __int64 v66; // x9
  unsigned __int16 *v67; // x8
  void *v68; // x0
  __int64 v69; // [xsp+8h] [xbp-38h]
  char *v70; // [xsp+8h] [xbp-38h]
  unsigned __int64 v71; // [xsp+10h] [xbp-30h]
  __int64 v72; // [xsp+18h] [xbp-28h]
  unsigned __int16 *v74; // [xsp+28h] [xbp-18h] BYREF
  unsigned __int16 *v75; // [xsp+30h] [xbp-10h] BYREF
  unsigned __int16 *v76; // [xsp+38h] [xbp-8h] BYREF

  v7 = a2;
  v8 = result;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 3;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if ( (a2 & 1) != 0 )
  {
    if ( (a2 & 0xE) != 0 )
      return result;
  }
  else
  {
    if ( (a2 & 2) == 0 )
      return result;
    if ( (~a2 & 0xC) == 0 )
    {
      v9 = 2;
      goto LABEL_64;
    }
  }
  result = sub_65F8C(a5);
  if ( !result )
    goto LABEL_63;
  v10 = result;
  *(_QWORD *)(v8 + 16) = result;
  v11 = sub_66018(a5);
  v12 = sub_65FC0(a5);
  v13 = *(_BYTE *)v10;
  v75 = (unsigned __int16 *)(v10 + 1);
  v14 = sub_64B84(&v75, v13, 0);
  v15 = v14 ? v14 : v12;
  v16 = (char *)v75 + 1;
  v71 = v15;
  v72 = *(unsigned __int8 *)v75;
  if ( v72 == 255 )
  {
    v21 = 0;
  }
  else
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = *v16++;
      v20 = (unsigned __int64)(v19 & 0x7F) << v17;
      v17 += 7;
      v18 |= v20;
    }
    while ( v19 < 0 );
    v21 = (__int64)&v16[v18];
  }
  v22 = 0;
  v23 = 0;
  v24 = v11 + ~v12;
  v27 = *v16;
  v25 = (unsigned __int16 *)(v16 + 1);
  v26 = v27;
  v75 = v25;
  do
  {
    v28 = *(_BYTE *)v25;
    v25 = (unsigned __int16 *)((char *)v25 + 1);
    v29 = (unsigned __int64)(v28 & 0x7F) << v22;
    v22 += 7;
    v23 |= v29;
  }
  while ( v28 < 0 );
  v30 = v25;
  v31 = (unsigned __int16 *)((char *)v25 + v23);
  v74 = v25;
  v75 = v25;
  v69 = v23;
  while ( 1 )
  {
    if ( v30 >= v31 )
    {
LABEL_80:
      __cxa_begin_catch(a4);
      if ( (a3 & 1) != 0 )
        sub_4A880(*((void (**)(void))a4 - 7));
      std::terminate();
    }
    v32 = sub_64B84(&v74, v26, 0);
    v33 = sub_64B84(&v74, v26, 0);
    result = sub_64B84(&v74, v26, 0);
    v34 = 0;
    v35 = 0;
    v30 = v74;
    do
    {
      v36 = *(_BYTE *)v30;
      v30 = (unsigned __int16 *)((char *)v30 + 1);
      v37 = (unsigned __int64)(v36 & 0x7F) << v34;
      v34 += 7;
      v35 |= v37;
    }
    while ( v36 < 0 );
    v74 = v30;
    if ( v32 <= v24 && v24 < v33 + v32 )
      break;
    if ( v24 < v32 )
      goto LABEL_80;
  }
  if ( !result )
  {
LABEL_63:
    v9 = 8;
    goto LABEL_64;
  }
  *(_QWORD *)(v8 + 24) = result + v71;
  if ( !v35 )
  {
    if ( (v7 & 1) != 0 )
      v9 = 8;
    else
      v9 = 6;
    goto LABEL_64;
  }
  v38 = 0;
  v39 = v72 & 0xF;
  v40 = (__int64)v25 + v69 + v35 - 1;
  v70 = (char *)(a4 + 16);
  while ( 1 )
  {
    v41 = 0;
    v42 = 0;
    v43 = (unsigned __int8 *)v40;
    do
    {
      v45 = *v43++;
      v44 = v45;
      v46 = (unsigned __int64)(v45 & 0x7F) << v41;
      v41 += 7LL;
      v42 |= v46;
    }
    while ( (v45 & 0x80) != 0 );
    v47 = v41 >= 0x40;
    v48 = -1LL << v41;
    v49 = !v47;
    if ( (v49 & (v44 >> 6)) == 0 )
      v48 = 0;
    v50 = v42 | v48;
    if ( (v42 | v48) < 1 )
    {
      v55 = (v50 == 0) | v38;
      if ( v50 && (v7 & 8) == 0 )
      {
        if ( (a3 & 1) == 0 )
          goto LABEL_73;
        v56 = a4 + 16;
        if ( sub_6368C((__int64)a4) == 0x434C4E47432B2B01LL )
          v56 = (unsigned __int16 *)*((_QWORD *)a4 - 11);
        if ( !v56 || (v57 = *((_QWORD *)a4 - 10)) == 0 )
        {
LABEL_83:
          __cxa_begin_catch(a4);
          sub_4A880(*((void (**)(void))a4 - 7));
        }
        result = sub_64D50(v50, v21, v72, v57, v56, a4, 0);
        v55 = v38;
        if ( (result & 1) != 0 )
        {
          if ( (v7 & 1) != 0 )
          {
            v9 = 6;
            *(_QWORD *)v8 = v50;
            *(_QWORD *)(v8 + 8) = v40;
            *(_QWORD *)(v8 + 32) = v56;
            goto LABEL_64;
          }
LABEL_86:
          v68 = (void *)__assert2(
                          "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
                          808,
                          "void __cxxabiv1::scan_eh_tab(scan_results &, _Unwind_Action, bool, _Unwind_Exception *, _Unwind_Context *)",
                          "actions & _UA_SEARCH_PHASE");
          _cxa_call_unexpected(v68);
        }
      }
      goto LABEL_54;
    }
    if ( !v21 || (unsigned int)v39 > 0xC || ((0x1C1Du >> (v72 & 0xF)) & 1) == 0 )
      goto LABEL_80;
    v76 = (unsigned __int16 *)(v21 + qword_23A38[v39] * v50);
    result = sub_64B84(&v76, v72, 0);
    if ( !result )
      break;
    if ( (a3 & 1) != 0 )
    {
      v51 = result;
      v52 = sub_6368C((__int64)a4);
      v53 = a4 + 16;
      if ( v52 == 0x434C4E47432B2B01LL )
        v53 = (unsigned __int16 *)*((_QWORD *)a4 - 11);
      v76 = v53;
      if ( !v53 )
        goto LABEL_83;
      v54 = *((_QWORD *)a4 - 10);
      if ( !v54 )
        goto LABEL_83;
      result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int16 **))(*(_QWORD *)v51 + 32LL))(
                 v51,
                 v54,
                 &v76);
      if ( (result & 1) != 0 )
      {
        if ( (v7 & 9) != 0 )
        {
          v67 = v76;
          *(_QWORD *)v8 = v50;
          *(_QWORD *)(v8 + 8) = v40;
          *(_QWORD *)(v8 + 32) = v67;
          *(_DWORD *)(v8 + 40) = 6;
          return result;
        }
LABEL_85:
        __assert2(
          "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
          775,
          "void __cxxabiv1::scan_eh_tab(scan_results &, _Unwind_Action, bool, _Unwind_Exception *, _Unwind_Context *)",
          "actions & (_UA_SEARCH_PHASE | _UA_FORCE_UNWIND)");
        goto LABEL_86;
      }
    }
    v55 = v38;
LABEL_54:
    v58 = 0;
    v59 = 0;
    v60 = v43;
    do
    {
      v62 = *v60++;
      v61 = v62;
      v63 = (unsigned __int64)(v62 & 0x7F) << v58;
      v58 += 7LL;
      v59 |= v63;
    }
    while ( (v62 & 0x80) != 0 );
    v47 = v58 >= 0x40;
    v64 = -1LL << v58;
    v65 = !v47;
    if ( (v65 & (v61 >> 6)) == 0 )
      v64 = 0;
    v66 = v59 | v64;
    if ( !v66 )
    {
      if ( (v55 & ((unsigned __int8)(v7 & 2) >> 1)) != 0 )
        v9 = 6;
      else
        v9 = 8;
      goto LABEL_64;
    }
    v40 = (__int64)&v43[v66];
    v38 = v55;
  }
  if ( (v7 & 0xD) == 0 )
  {
    __assert2(
      "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
      749,
      "void __cxxabiv1::scan_eh_tab(scan_results &, _Unwind_Action, bool, _Unwind_Exception *, _Unwind_Context *)",
      "actions & (_UA_SEARCH_PHASE | _UA_HANDLER_FRAME | _UA_FORCE_UNWIND)");
    goto LABEL_85;
  }
LABEL_73:
  *(_QWORD *)v8 = v50;
  *(_QWORD *)(v8 + 8) = v40;
  result = sub_6368C((__int64)a4);
  if ( result == 0x434C4E47432B2B01LL )
    v70 = (char *)*((_QWORD *)a4 - 11);
  v9 = 6;
  *(_QWORD *)(v8 + 32) = v70;
LABEL_64:
  *(_DWORD *)(v8 + 40) = v9;
  return result;
}
// 23A38: using guessed type _QWORD qword_23A38[13];
// 6AB10: using guessed type __int64 __assert2(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000064960) ----------------------------------------------------
void __noreturn _cxa_call_unexpected(void *a1)
{
  void (*unexpected)(void); // x0

  if ( !a1 )
  {
    __cxa_begin_catch(0);
    std::terminate();
  }
  __cxa_begin_catch(a1);
  if ( sub_63698(a1) )
  {
    unexpected = (void (*)(void))*((_QWORD *)a1 - 8);
  }
  else
  {
    std::get_terminate();
    unexpected = (void (*)(void))std::get_unexpected();
  }
  sub_4A834(unexpected);
}

//----- (0000000000064B84) ----------------------------------------------------
unsigned __int64 __fastcall sub_64B84(unsigned __int16 **a1, unsigned __int8 a2, __int64 a3)
{
  unsigned __int16 *v3; // x10
  unsigned __int64 v8; // x8
  unsigned __int16 *v9; // x9
  int v10; // w11
  unsigned __int64 result; // x0
  __int64 v12; // x12
  char v13; // t1
  unsigned __int64 v14; // x14
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x12
  __int64 v17; // x8
  unsigned int v18; // w13
  unsigned int v19; // t1
  unsigned __int64 v20; // x14
  _BOOL4 v21; // w14
  __int64 v22; // x12

  if ( a2 == 255 )
    return 0;
  v3 = *a1;
  switch ( a2 & 0xF )
  {
    case 0:
    case 4:
    case 0xC:
      __asm { BTI             j; jumptable 0000000000064BC0 cases 0,4,12 }
      v9 = v3 + 4;
      v8 = *(_QWORD *)v3;
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
      goto LABEL_17;
    case 1:
      __asm { BTI             j; jumptable 0000000000064BC0 case 1 }
      v12 = 0;
      v8 = 0;
      v9 = *a1;
      do
      {
        v13 = *(_BYTE *)v9;
        v9 = (unsigned __int16 *)((char *)v9 + 1);
        v14 = (unsigned __int64)(v13 & 0x7F) << v12;
        v12 += 7;
        v8 |= v14;
      }
      while ( v13 < 0 );
      goto LABEL_16;
    case 2:
      __asm { BTI             j; jumptable 0000000000064BC0 case 2 }
      v9 = v3 + 1;
      v8 = *v3;
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
      goto LABEL_17;
    case 3:
      __asm { BTI             j; jumptable 0000000000064BC0 case 3 }
      v9 = v3 + 2;
      v8 = *(unsigned int *)v3;
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
      goto LABEL_17;
    case 9:
      __asm { BTI             j; jumptable 0000000000064BC0 case 9 }
      v16 = 0;
      v17 = 0;
      v9 = *a1;
      do
      {
        v19 = *(unsigned __int8 *)v9;
        v9 = (unsigned __int16 *)((char *)v9 + 1);
        v18 = v19;
        v20 = (unsigned __int64)(v19 & 0x7F) << v16;
        v16 += 7LL;
        v17 |= v20;
      }
      while ( (v19 & 0x80) != 0 );
      v21 = v16 < 0x40;
      v22 = -1LL << v16;
      if ( (v21 & (v18 >> 6)) == 0 )
        v22 = 0;
      v8 = v17 | v22;
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
      goto LABEL_17;
    case 0xA:
      __asm { BTI             j; jumptable 0000000000064BC0 case 10 }
      v9 = v3 + 1;
      v8 = (__int16)*v3;
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
      goto LABEL_17;
    case 0xB:
      __asm { BTI             j; jumptable 0000000000064BC0 case 11 }
      v9 = v3 + 2;
      v8 = *(int *)v3;
LABEL_16:
      v10 = (a2 >> 4) & 7;
      if ( !v10 )
        goto LABEL_24;
LABEL_17:
      if ( v10 == 3 )
      {
        if ( !a3 )
        {
          __assert2(
            "out/llvm-project/libcxxabi/src/cxa_personality.cpp",
            309,
            "uintptr_t __cxxabiv1::readEncodedPointer(const uint8_t **, uint8_t, uintptr_t)",
            "(base != 0) && \"DW_EH_PE_datarel is invalid with a base of 0\"");
LABEL_36:
          __asm { BTI             j; jumptable 0000000000064BC0 default case, cases 5-8 }
          abort();
        }
        if ( !v8 )
          goto LABEL_26;
        v8 += a3;
      }
      else
      {
        if ( v10 != 1 )
          abort();
        if ( !v8 )
          goto LABEL_26;
        v8 += (unsigned __int64)v3;
      }
LABEL_24:
      if ( !v8 || (a2 & 0x80) == 0 )
      {
LABEL_26:
        *a1 = v9;
        return v8;
      }
      v15 = *(_QWORD *)v8;
      *a1 = v9;
      result = v15;
      break;
    default:
      goto LABEL_36;
  }
  return result;
}
// 6AB10: using guessed type __int64 __fastcall __assert2(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000064D50) ----------------------------------------------------
bool __fastcall sub_64D50(
        __int64 a1,
        __int64 a2,
        unsigned __int8 a3,
        __int64 a4,
        unsigned __int16 *a5,
        void *a6,
        __int64 a7)
{
  __int64 v8; // x25
  __int64 v13; // x8
  __int64 v14; // x9
  char *v15; // x26
  char v16; // t1
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x19
  unsigned __int64 v19; // x0
  char v20; // w0
  unsigned __int16 *v23; // [xsp+8h] [xbp-8h] BYREF

  if ( !a2 )
  {
    __cxa_begin_catch(a6);
    std::terminate();
  }
  v8 = a3 & 0xF;
  v13 = 0;
  v14 = 0;
  v15 = (char *)(a2 + ~a1);
  do
  {
    do
    {
      v16 = *v15++;
      v17 = (unsigned __int64)(v16 & 0x7F) << v13;
      v13 += 7;
      v18 = v17 | v14;
      v14 |= v17;
    }
    while ( v16 < 0 );
    if ( !v18 )
      break;
    if ( (unsigned int)v8 > 0xC || ((0x1C1Du >> v8) & 1) == 0 )
    {
      __cxa_begin_catch(a6);
      sub_4A880(*((void (**)(void))a6 - 7));
    }
    v23 = (unsigned __int16 *)(a2 + qword_23A38[v8] * v18);
    v19 = sub_64B84(&v23, a3, a7);
    v23 = a5;
    v20 = (*(__int64 (__fastcall **)(unsigned __int64, __int64, unsigned __int16 **))(*(_QWORD *)v19 + 32LL))(
            v19,
            a4,
            &v23);
    v13 = 0;
    v14 = 0;
  }
  while ( (v20 & 1) == 0 );
  return v18 == 0;
}
// 23A38: using guessed type _QWORD qword_23A38[13];

//----- (0000000000064E70) ----------------------------------------------------
float __fastcall sub_64E70(float a1, float a2, float a3, float a4)
{
  float v4; // s4
  int v5; // w9
  float v6; // s6
  int v7; // w8
  unsigned int v8; // w9
  int v9; // w8
  int v10; // w9
  unsigned int v11; // w12
  unsigned int v12; // w10
  unsigned int v13; // w12
  unsigned int v14; // w10
  bool v15; // vf
  signed int v16; // w12
  unsigned int v17; // w11
  unsigned int v18; // w12
  unsigned int v19; // w10
  unsigned int v20; // w12
  unsigned int v21; // w10
  int v22; // w9
  signed int v23; // w12
  unsigned int v24; // w9
  int v25; // w11
  int v26; // w8
  float v27; // s16
  unsigned int v28; // s4
  float v29; // w10
  int v30; // w11
  unsigned int v31; // w12
  char v32; // w13
  unsigned int v33; // w12
  unsigned int v34; // w10
  unsigned int v35; // w13
  unsigned int v36; // w9
  int v37; // w11
  unsigned int v38; // w12

  v4 = fmaxf(fabsf(a3), fabsf(a4));
  v5 = (unsigned __int8)(LODWORD(v4) >> 23);
  if ( v5 == 255 )
  {
    if ( SLODWORD(v4) <= -1 )
      v6 = -v4;
    else
      v6 = v4;
  }
  else if ( v4 == 0.0 )
  {
    v6 = -INFINITY;
  }
  else
  {
    if ( (unsigned __int8)(LODWORD(v4) >> 23) )
    {
      v7 = v5 - 127;
    }
    else
    {
      v8 = __clz(LODWORD(v4) & 0x7FFFFFFF);
      v7 = (unsigned __int8)(LODWORD(v4) << (v8 - 8) >> 23) - v8 - 119;
    }
    v6 = (float)v7;
  }
  v9 = 0;
  if ( fabsf(v6) == INFINITY )
    goto LABEL_41;
  v9 = (int)v6;
  v10 = -(int)v6;
  if ( a3 == 0.0 )
    goto LABEL_23;
  v11 = (unsigned __int8)(LODWORD(a3) >> 23);
  if ( v11 == 255 )
    goto LABEL_23;
  v12 = LODWORD(a3) & 0x7FFFFF;
  if ( !(unsigned __int8)(LODWORD(a3) >> 23) )
  {
    v13 = __clz(v12);
    v14 = v12 << (v13 - 8);
    v11 = 9 - v13;
    v12 = v14 & 0xFF7FFFFF;
  }
  v15 = __OFADD__(v11, v10);
  v16 = v11 - (int)v6;
  v17 = LODWORD(a3) & 0x80000000;
  if ( v15 )
    v16 = (v16 >> 31) ^ 0x80000000;
  if ( v16 >= 255 )
  {
    a3 = COERCE_FLOAT(v17 | 0x7F000000) + COERCE_FLOAT(v17 | 0x7F000000);
    if ( a4 == 0.0 )
      goto LABEL_41;
    goto LABEL_24;
  }
  if ( v16 > 0 )
  {
    LODWORD(a3) = v17 | (v16 << 23) | v12;
LABEL_23:
    if ( a4 == 0.0 )
      goto LABEL_41;
    goto LABEL_24;
  }
  if ( v16 <= -125 )
    v16 = -125;
  a3 = COERCE_FLOAT(v12 | v17 | 0x800000) * COERCE_FLOAT((v16 << 23) + 1056964608);
  if ( a4 != 0.0 )
  {
LABEL_24:
    v18 = (unsigned __int8)(LODWORD(a4) >> 23);
    if ( v18 != 255 )
    {
      v19 = LODWORD(a4) & 0x7FFFFF;
      if ( !(unsigned __int8)(LODWORD(a4) >> 23) )
      {
        v20 = __clz(v19);
        v21 = v19 << (v20 - 8);
        v18 = 9 - v20;
        v19 = v21 & 0xFF7FFFFF;
      }
      v15 = __OFADD__(v18, v10);
      v22 = v18 - (int)v6;
      v23 = (v22 >> 31) ^ 0x80000000;
      if ( !v15 )
        v23 = v22;
      v24 = LODWORD(a4) & 0x80000000;
      if ( v23 < 255 )
      {
        if ( v23 <= 0 )
        {
          if ( v23 <= -125 )
            v25 = -125;
          else
            v25 = v23;
          a4 = COERCE_FLOAT(v19 | v24 | 0x800000) * COERCE_FLOAT((v25 << 23) + 1056964608);
        }
        else
        {
          LODWORD(a4) = v24 | (v23 << 23) | v19;
        }
      }
      else
      {
        a4 = COERCE_FLOAT(v24 | 0x7F000000) + COERCE_FLOAT(v24 | 0x7F000000);
      }
    }
  }
LABEL_41:
  v26 = -v9;
  v27 = (float)(a4 * a4) + (float)(a3 * a3);
  *(float *)&v28 = (float)((float)(a4 * a2) + (float)(a1 * a3)) / v27;
  if ( *(float *)&v28 != 0.0 )
  {
    v29 = (float)((float)(a4 * a2) + (float)(a1 * a3)) / v27;
    if ( (unsigned __int8)(v28 >> 23) != 255 )
    {
      v30 = LODWORD(v29) & 0x7FFFFF;
      v31 = __clz(LODWORD(v29) & 0x7FFFFF);
      v32 = v31 - 8;
      v33 = 9 - v31;
      if ( (unsigned __int8)(v28 >> 23) )
        v33 = (unsigned __int8)(v28 >> 23);
      v34 = v28 & 0x80000000;
      v35 = (v30 << v32) & 0xFF7FFFFF;
      if ( (unsigned __int8)(v28 >> 23) )
        v36 = v30;
      else
        v36 = v35;
      v15 = __OFADD__(v33, v26);
      v37 = v33 + v26;
      v38 = ((int)(v33 + v26) >> 31) ^ 0x80000000;
      if ( v15 )
        v37 = v38;
      if ( v37 < 255 )
      {
        if ( v37 <= 0 )
        {
          if ( v37 <= -125 )
            v37 = -125;
          *(float *)&v28 = COERCE_FLOAT(v36 | v34 | 0x800000) * COERCE_FLOAT((v37 << 23) + 1056964608);
        }
        else
        {
          v28 = v34 | (v37 << 23) | v36;
        }
      }
      else
      {
        *(float *)&v28 = COERCE_FLOAT(v34 | 0x7F000000) + COERCE_FLOAT(v34 | 0x7F000000);
      }
    }
  }
  return *(float *)&v28;
}

//----- (0000000000065344) ----------------------------------------------------
_QWORD *__fastcall _emutls_get_address(size_t *a1)
{
  unsigned __int64 v2; // x22
  _QWORD *v3; // x0
  unsigned __int64 v4; // x21
  _QWORD *v5; // x20
  unsigned __int64 v6; // x24
  _QWORD *v7; // x0
  _QWORD *v8; // x0
  pthread_key_t v9; // w0
  _QWORD *v10; // x22
  _QWORD *v11; // x20
  _QWORD *v12; // x22
  _QWORD *v13; // t1
  __int64 v14; // x20
  size_t v15; // x21
  void *v16; // x0
  const void *v17; // x1

  v2 = atomic_load(a1 + 2);
  if ( !v2 )
  {
    pthread_once(dword_78D18, (void (*)(void))sub_65548);
    pthread_mutex_lock(&stru_78D28);
    v2 = a1[2];
    if ( !v2 )
    {
      v2 = ++qword_78D20;
      atomic_store(qword_78D20, a1 + 2);
    }
    pthread_mutex_unlock(&stru_78D28);
    v3 = pthread_getspecific(dword_78D14);
    if ( v3 )
      goto LABEL_3;
LABEL_9:
    v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
    v8 = malloc(8 * v6 + 16);
    if ( !v8 )
      abort();
    v5 = v8;
    memset(v8 + 2, 0, 8 * v6);
    *v5 = 1;
    goto LABEL_11;
  }
  v3 = pthread_getspecific(dword_78D14);
  if ( !v3 )
    goto LABEL_9;
LABEL_3:
  v4 = v3[1];
  v5 = v3;
  if ( v4 >= v2 )
    goto LABEL_12;
  v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
  v7 = realloc(v3, 8 * v6 + 16);
  if ( !v7 )
    abort();
  v5 = v7;
  memset(&v7[v4 + 2], 0, 8 * (v6 - v4));
LABEL_11:
  v9 = dword_78D14;
  v5[1] = v6;
  pthread_setspecific(v9, v5);
LABEL_12:
  v10 = &v5[v2 - 1];
  v13 = (_QWORD *)v10[2];
  v12 = v10 + 2;
  v11 = v13;
  if ( !v13 )
  {
    if ( a1[1] <= 8 )
      v14 = 8;
    else
      v14 = a1[1];
    if ( (v14 & (v14 - 1)) != 0 )
      abort();
    v15 = *a1;
    v16 = malloc(v14 + 7 + *a1);
    if ( !v16 )
      abort();
    v11 = (_QWORD *)(((unsigned __int64)v16 + v14 + 7) & -v14);
    *(v11 - 1) = v16;
    v17 = (const void *)a1[3];
    if ( v17 )
      memcpy(v11, v17, v15);
    else
      memset(v11, 0, v15);
    *v12 = v11;
  }
  return v11;
}
// 78D14: using guessed type int dword_78D14;
// 78D18: using guessed type pthread_once_t dword_78D18[2];
// 78D20: using guessed type __int64 qword_78D20;
// 78D28: using guessed type pthread_mutex_t stru_78D28;

//----- (0000000000065510) ----------------------------------------------------
__int64 sub_65510()
{
  __int64 result; // x0

  if ( byte_78D10 == 1 )
  {
    result = pthread_key_delete(dword_78D14);
    byte_78D10 = 0;
  }
  return result;
}
// 78D10: using guessed type char byte_78D10;
// 78D14: using guessed type int dword_78D14;

//----- (0000000000065548) ----------------------------------------------------
__int64 sub_65548()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_78D14, (void (*)(void *))sub_65584);
  if ( (_DWORD)result )
    abort();
  byte_78D10 = 1;
  return result;
}
// 78D10: using guessed type char byte_78D10;
// 78D14: using guessed type int dword_78D14;

//----- (0000000000065584) ----------------------------------------------------
void __fastcall sub_65584(_QWORD *pointer)
{
  unsigned __int64 v2; // x8
  unsigned __int64 i; // x20
  __int64 v4; // x9

  if ( *pointer )
  {
    --*pointer;
    pthread_setspecific(dword_78D14, pointer);
  }
  else
  {
    v2 = pointer[1];
    if ( v2 )
    {
      for ( i = 0; i < v2; ++i )
      {
        v4 = pointer[i + 2];
        if ( v4 )
        {
          free(*(void **)(v4 - 8));
          v2 = pointer[1];
        }
      }
    }
    free(pointer);
  }
}
// 78D14: using guessed type int dword_78D14;

//----- (0000000000065610) ----------------------------------------------------
unsigned __int64 __fastcall sub_65610(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_78D50 )
    return atomic_exchange(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(a1, (unsigned __int64 *)a2) );
  return result;
}
// 78D50: using guessed type char byte_78D50;

//----- (000000000006563C) ----------------------------------------------------
__int64 sub_6563C()
{
  __int64 result; // x0
  unsigned __int64 v1; // x19
  unsigned __int64 v2; // x19
  __int64 v3; // x8
  char s1[92]; // [xsp+4h] [xbp-6Ch] BYREF

  result = getauxval(0x10u);
  v1 = result;
  if ( (result & 0x100) != 0 )
  {
    result = __system_property_get("ro.arch", s1);
    if ( (int)result < 1 )
    {
      v3 = (v1 >> 8) & 1;
    }
    else
    {
      v2 = (v1 & 0x100) >> 8;
      result = strncmp(s1, "exynos9810", 0xAu);
      if ( (_DWORD)result )
        LODWORD(v3) = v2;
      else
        LODWORD(v3) = 0;
    }
    byte_78D50 = (_DWORD)v3 != 0;
  }
  else
  {
    byte_78D50 = 0;
  }
  return result;
}
// 6AC80: using guessed type __int64 __fastcall __system_property_get(_QWORD, _QWORD);
// 78D50: using guessed type char byte_78D50;

//----- (00000000000656D4) ----------------------------------------------------
unsigned __int64 __fastcall sub_656D4(unsigned __int64 result, __int64 a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x12
  __int64 v4; // x11
  __int64 v5; // x14
  __int64 v6; // x12
  __int64 v7; // x13
  __int64 v8; // x15
  __int64 v9; // x14
  __int64 v10; // x15
  __int64 v11; // x16
  __int64 v12; // x15
  __int64 v13; // x17
  __int64 v14; // x15
  __int64 v15; // x1
  __int64 v16; // x15
  __int64 v17; // x7
  __int64 v18; // x5
  __int64 v19; // x3
  __int64 v20; // x15
  __int64 v21; // x19
  __int64 v22; // x21
  __int64 v23; // x19
  __int64 v24; // x4
  __int64 v25; // x21
  __int64 v26; // x11
  __int64 v27; // x10
  __int64 v28; // x12
  bool v29; // zf
  __int64 v30; // x9
  __int64 v31; // x11
  int StatusReg; // w9
  __int64 v33; // x9
  __int64 v34; // x10
  unsigned __int64 v35; // x11
  __int64 v36; // x9
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x9
  unsigned __int64 v39; // x11

  if ( !qword_78D58 )
  {
    if ( (result & 0x4000000000000000LL) != 0 )
      v2 = *(_QWORD *)(a2 + 16);
    else
      v2 = 0;
    v3 = (result >> 26) & 2;
    v4 = (8 * (int)result) & 0x400LL | (((result >> 4) & 1) << 15);
    if ( (v2 & 0x80) != 0 )
      v3 = 6;
    v5 = v3 | v4;
    v6 = result & 0xC0000;
    v7 = v5 | 0x20;
    if ( (result & 0xC0000) == 0xC0000 )
      v5 |= 0x20uLL;
    v8 = (result >> 20) & 8 | (result >> 16) & 0x10 | v5;
    v9 = v8 | 0x10100;
    if ( (result & 0x200) != 0 )
      v8 |= 0x10100uLL;
    v10 = (result >> 6) & 0x40 | (result >> 7) & 0x20000 | v8;
    v11 = v10 | 0x800000;
    if ( (result & 0x4000000) != 0 )
      v10 |= 0x800000uLL;
    v12 = ((_DWORD)result << 6) & 0x800LL | (result << 11) & 0x4000 | v10;
    v13 = v12 | 0x1000;
    if ( (result & 0x40) != 0 )
      v12 |= 0x1000uLL;
    v14 = (result << 7) & 0x300000 | v12;
    v15 = v14 | 0x400000000000LL;
    if ( (result & 0x20000000) != 0 )
      v14 |= 0x400000000000uLL;
    v16 = (result << 21) & 0x2000000000000LL | v14;
    v17 = v2 << 35;
    v18 = (v2 << 35) & 0x2000000000LL;
    if ( (v2 & 0x40000) != 0 )
      v16 |= 0x180000000000uLL;
    v19 = v16 | 0x380000000000LL;
    if ( (v2 & 0x400000) != 0 )
      v16 |= 0x380000000000uLL;
    if ( (v2 & 8) != 0 )
      v18 = 0x6000000000LL;
    v20 = v17 & 0x8000000000LL | v18 | v16;
    if ( (v2 & 0x20) != 0 )
      v21 = v20 | 0x10000000000LL;
    else
      v21 = v20;
    v22 = (result >> 1) & 0x80 | v17 & 0x20000000000LL | v21 | ((v2 & 1) << 19);
    v23 = v22 | 1;
    if ( (v2 & 0x10000) != 0 )
      v22 |= 1uLL;
    v24 = ((_DWORD)v2 << 10) & 0x2000000
        | (v2 >> 1) & 0x100000000LL
        | (v2 >> 4) & 0x10000000
        | ((_DWORD)v2 << 13) & 0x4000000
        | v22;
    v25 = v24 | 0x1000000;
    if ( (v2 & 0x100) != 0 )
      v24 |= 0x1000000uLL;
    if ( result & 0x24000250 | v2 & 0x410120 || v6 == 786432 )
    {
      if ( v6 == 786432 )
        v4 = v7;
      if ( (result & 0x200) != 0 )
        v4 = v9;
      if ( (result & 0x4000000) != 0 )
        v4 = v11;
      if ( (result & 0x40) != 0 )
        v4 = v13;
      if ( (result & 0x20000000) != 0 )
        v4 = v15;
      if ( (v2 & 0x400000) != 0 )
        v4 = v19;
      if ( (v2 & 0x20) != 0 )
        v4 = v20 | 0x10000000000LL;
      if ( (v2 & 0x10000) != 0 )
        v4 = v23;
      if ( (v2 & 0x100) != 0 )
        v4 = v25;
      qword_78D58 = v4;
    }
    v26 = (v2 << 30) & 0x80000000000000LL
        | (v2 << 32) & 0x100000000000000LL
        | (v2 << 19) & 0x40000000000LL
        | (v2 << 23) & 0x40000000000000LL
        | ((_DWORD)v2 << 8) & 0x20000000
        | (v2 << 33) & 0x4000000000000LL
        | (v2 << 24) & 0xE00000000LL
        | v24;
    if ( (result & 0x800) == 0 )
    {
      if ( (result & 0x201) != 0 )
        v26 |= 0x300uLL;
      if ( v2 & 1 | result & 0x10000 )
        v26 |= 0x40000uLL;
      if ( (result & 0x4008000) != 0 )
      {
        v26 |= 0x400000uLL;
        qword_78D58 = v26;
      }
      v27 = (result >> 4) & 0x2000;
      if ( (v2 & 0x100004000LL) != 0 )
        v26 |= 0x8000000uLL;
      v28 = ((_DWORD)v2 << 19) & 0x80000000;
      v29 = (v2 & 2) == 0 || (result & 0x400000) == 0;
      v30 = v28 | v26;
      v31 = v28 | v26 | 0x1000000000LL;
      if ( !v29 )
        v30 = v31;
LABEL_98:
      v27 |= v30;
LABEL_99:
      qword_78D58 = v27 | 0x400000000000000LL;
      return result;
    }
    StatusReg = _ReadStatusReg(ID_AA64PFR1_EL1);
    if ( (StatusReg & 0xF00) != 0 )
    {
      v26 |= 0x80000000000uLL;
      qword_78D58 = v26;
    }
    v29 = (StatusReg & 0xF0) == 16;
    v33 = StatusReg & 0xF000000;
    if ( v29 )
      v34 = v26 | 0x1000000000000LL;
    else
      v34 = v26;
    v35 = _ReadStatusReg(ID_AA64PFR0_EL1);
    if ( v33 == 0x2000000 )
      v36 = v34 | 0x200000000000000LL;
    else
      v36 = v34;
    if ( (~(_DWORD)v35 & 0xF0000) != 0 )
      v36 |= 0x300uLL;
    if ( (v35 & 0xF00000000LL) != 0 )
    {
      v37 = _ReadStatusReg(ID_AA64ZFR0_EL1);
      if ( (v37 & 0xF) == 1 )
      {
        v36 |= 0x1000000000uLL;
      }
      else if ( (v37 & 0xF) == 0 )
      {
        v36 |= 0x40000000uLL;
      }
      if ( (v37 & 0xF00000) != 0 )
        v36 |= 0x80000000uLL;
    }
    if ( (_ReadStatusReg(ID_AA64ISAR0_EL1) & 0xF00000000LL) != 0 )
      v27 = v36 | 0x2000;
    else
      v27 = v36;
    v38 = _ReadStatusReg(ID_AA64ISAR1_EL1);
    if ( (v38 & 0xF) != 0 )
      v27 |= 0x40000uLL;
    if ( (v38 & 0xF00000) != 0 )
    {
      v27 |= 0x400000uLL;
      qword_78D58 = v27;
    }
    if ( (v38 & 0xF0000000000LL) == 0x20000000000LL )
      v27 |= 0x800000000000uLL;
    v39 = v38 >> 60;
    if ( (v38 & 0xF00000000000LL) != 0 )
      v27 |= 0x8000000uLL;
    if ( !v39 )
      goto LABEL_99;
    if ( v38 >> 61 )
    {
      v30 = 0x18000000000000LL;
      if ( v39 > 2 )
        v30 = 0x38000000000000LL;
      goto LABEL_98;
    }
    qword_78D58 = v27 | 0x408000000000000LL;
  }
  return result;
}
// 78D58: using guessed type __int64 qword_78D58;

//----- (0000000000065B0C) ----------------------------------------------------
void sub_65B0C()
{
  unsigned __int64 v0; // x19
  _QWORD v1[3]; // [xsp+8h] [xbp-88h] BYREF
  char s1[92]; // [xsp+24h] [xbp-6Ch] BYREF

  if ( !qword_78D58 && ((int)__system_property_get("ro.arch", s1) < 1 || strncmp(s1, "exynos9810", 0xAu)) )
  {
    v0 = getauxval(0x10u);
    v1[2] = getauxval(0x1Au);
    v1[0] = 24;
    v1[1] = v0;
    sub_656D4(v0 | 0x4000000000000000LL, (__int64)v1);
  }
}
// 6AC80: using guessed type __int64 __fastcall __system_property_get(_QWORD, _QWORD);
// 78D58: using guessed type __int64 qword_78D58;

//----- (0000000000065BB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_65BB0(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_78D50 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}
// 78D50: using guessed type char byte_78D50;

//----- (0000000000065BE0) ----------------------------------------------------
__int64 __usercall sub_65BE0@<X0>(
        _QWORD *a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        __int64 a5@<X4>,
        __int64 a6@<X5>,
        __int64 a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        double a10@<D0>,
        double a11@<D1>,
        double a12@<D2>,
        double a13@<D3>,
        double a14@<D4>,
        double a15@<D5>,
        double a16@<D6>,
        double a17@<D7>)
{
  int v18; // w0
  int v20; // w0
  __int64 v21[78]; // [xsp+0h] [xbp-4D0h] BYREF
  _OWORD v22[33]; // [xsp+270h] [xbp-260h] BYREF
  __int64 v23; // [xsp+480h] [xbp-50h] BYREF
  _BYTE v24[24]; // [xsp+488h] [xbp-48h] BYREF
  __int64 (__fastcall *v25)(__int64, __int64, _QWORD, _QWORD *, __int64 *); // [xsp+4A0h] [xbp-30h]

  sub_69A64((__int64)v22, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, v21[0]);
  a1[2] = 0;
  a1[3] = 0;
  sub_66058((__int64)v21, v22);
  v18 = sub_6626C((__int64)v21);
  if ( !v18 )
    return 5;
  while ( (v18 & 0x80000000) == 0 && !(unsigned int)sub_66294((__int64)v21, (__int64)v24) )
  {
    if ( v25 )
    {
      v20 = v25(1, 1, *a1, a1, v21);
      if ( v20 != 8 )
      {
        if ( v20 == 6 )
        {
          sub_66104((__int64)v21, 0xFFFFFFFE, &v23);
          a1[3] = v23;
          return sub_65CD8(v22, (__int64)v21, a1);
        }
        return 3;
      }
    }
    v18 = sub_6626C((__int64)v21);
    if ( !v18 )
      return 5;
  }
  return 3;
}

//----- (0000000000065CD8) ----------------------------------------------------
__int64 __fastcall sub_65CD8(_OWORD *a1, __int64 a2, _QWORD *a3)
{
  int v5; // w0
  __int64 v6; // x1
  int v7; // w0
  __int64 v9; // [xsp+0h] [xbp-50h] BYREF
  __int64 (__fastcall *v10)(__int64, __int64, _QWORD, _QWORD *, __int64); // [xsp+18h] [xbp-38h]
  __int64 v11; // [xsp+48h] [xbp-8h] BYREF

  sub_66058(a2, a1);
  v5 = sub_66280(a2);
  if ( !v5 )
    return 5;
  while ( (v5 & 0x80000000) == 0 )
  {
    sub_66104(a2, 0xFFFFFFFE, &v11);
    if ( (unsigned int)sub_66294(a2, (__int64)&v9) )
      break;
    if ( v10 )
    {
      if ( v11 == a3[3] )
        v6 = 6;
      else
        v6 = 2;
      v7 = v10(1, v6, *a3, a3, a2);
      if ( v7 != 8 )
      {
        if ( v7 == 7 )
          sub_662D4(a2);
        return 2;
      }
      if ( v11 == a3[3] )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "unwind_phase2",
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
    }
    v5 = sub_66280(a2);
    if ( !v5 )
      return 5;
  }
  return 2;
}

//----- (0000000000065E10) ----------------------------------------------------
void __usercall __noreturn sub_65E10(
        _QWORD *a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        __int64 a5@<X4>,
        __int64 a6@<X5>,
        __int64 a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        double a10@<D0>,
        double a11@<D1>,
        double a12@<D2>,
        double a13@<D3>,
        double a14@<D4>,
        double a15@<D5>,
        double a16@<D6>,
        double a17@<D7>)
{
  __int64 (__fastcall *v18)(__int64, __int64, _QWORD, _QWORD *, __int64, __int64); // x3
  __int64 v19[78]; // [xsp+0h] [xbp-480h] BYREF
  _OWORD v20[33]; // [xsp+270h] [xbp-210h] BYREF

  sub_69A64((__int64)v20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, v19[0]);
  v18 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD *, __int64, __int64))a1[2];
  if ( v18 )
    sub_65E98(v20, (__int64)v19, a1, v18, a1[3]);
  else
    sub_65CD8(v20, (__int64)v19, a1);
  fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "_Unwind_Resume", "_Unwind_Resume() can't return");
  fflush((FILE *)((char *)&_sF + 304));
  abort();
}

//----- (0000000000065E98) ----------------------------------------------------
__int64 __fastcall sub_65E98(
        _OWORD *a1,
        __int64 a2,
        _QWORD *a3,
        __int64 (__fastcall *a4)(__int64, __int64, _QWORD, _QWORD *, __int64, __int64),
        __int64 a5)
{
  __int64 result; // x0
  _BYTE v10[24]; // [xsp+8h] [xbp-48h] BYREF
  __int64 (__fastcall *v11)(__int64, __int64, _QWORD, _QWORD *, __int64); // [xsp+20h] [xbp-30h]

  sub_66058(a2, a1);
  if ( (int)sub_66280(a2) < 1 )
    return a4(1, 26, *a3, a3, a2, a5);
  while ( 1 )
  {
    result = sub_66294(a2, (__int64)v10);
    if ( (_DWORD)result )
      break;
    result = a4(1, 10, *a3, a3, a2, a5);
    if ( (_DWORD)result )
      break;
    if ( v11 )
    {
      result = v11(1, 10, *a3, a3, a2);
      if ( (_DWORD)result != 8 )
      {
        if ( (_DWORD)result != 7 )
          return result;
        sub_662D4(a2);
      }
    }
    if ( (int)sub_66280(a2) <= 0 )
      return a4(1, 26, *a3, a3, a2, a5);
  }
  return result;
}

//----- (0000000000065F8C) ----------------------------------------------------
__int64 __fastcall sub_65F8C(__int64 a1)
{
  _BYTE v2[16]; // [xsp+8h] [xbp-48h] BYREF
  __int64 v3; // [xsp+18h] [xbp-38h]

  if ( (unsigned int)sub_66294(a1, (__int64)v2) )
    return 0;
  else
    return v3;
}

//----- (0000000000065FC0) ----------------------------------------------------
__int64 __fastcall sub_65FC0(__int64 a1)
{
  _QWORD v2[9]; // [xsp+8h] [xbp-48h] BYREF

  if ( (unsigned int)sub_66294(a1, (__int64)v2) )
    return 0;
  else
    return v2[0];
}

//----- (0000000000065FF4) ----------------------------------------------------
__int64 __fastcall sub_65FF4(__int64 result)
{
  __int64 (__fastcall *v1)(__int64, __int64); // x16

  v1 = *(__int64 (__fastcall **)(__int64, __int64))(result + 8);
  if ( v1 )
    return v1(1, result);
  return result;
}

//----- (0000000000066010) ----------------------------------------------------
__int64 __fastcall sub_66010(__int64 a1, unsigned int a2, __int64 a3)
{
  return sub_66180(a1, a2, a3);
}

//----- (0000000000066018) ----------------------------------------------------
__int64 __fastcall sub_66018(__int64 a1)
{
  __int64 v2; // [xsp+8h] [xbp-8h] BYREF

  sub_66104(a1, 0xFFFFFFFF, &v2);
  return v2;
}

//----- (0000000000066048) ----------------------------------------------------
__int64 __fastcall sub_66048(__int64 a1, __int64 a2)
{
  return sub_66180(a1, 0xFFFFFFFF, a2);
}

//----- (0000000000066058) ----------------------------------------------------
__int64 __fastcall sub_66058(__int64 a1, _OWORD *a2)
{
  __int128 v4; // q0
  __int128 v5; // q2
  __int128 v6; // q3
  __int128 v7; // q0
  __int128 v8; // q2
  __int128 v9; // q3
  __int128 v10; // q0
  __int128 v11; // q2
  __int128 v12; // q3
  __int128 v13; // q1
  __int128 v14; // q2
  __int128 v15; // q3

  *(_QWORD *)a1 = off_72138;
  *(_QWORD *)(a1 + 8) = &unk_78D60;
  memcpy((void *)(a1 + 16), a2, 0x110u);
  v4 = a2[20];
  v5 = a2[17];
  v6 = a2[18];
  *(_OWORD *)(a1 + 320) = a2[19];
  *(_OWORD *)(a1 + 336) = v4;
  *(_OWORD *)(a1 + 288) = v5;
  *(_OWORD *)(a1 + 304) = v6;
  v7 = a2[24];
  v8 = a2[21];
  v9 = a2[22];
  *(_OWORD *)(a1 + 384) = a2[23];
  *(_OWORD *)(a1 + 400) = v7;
  *(_OWORD *)(a1 + 352) = v8;
  *(_OWORD *)(a1 + 368) = v9;
  v10 = a2[28];
  v11 = a2[25];
  v12 = a2[26];
  *(_OWORD *)(a1 + 448) = a2[27];
  *(_OWORD *)(a1 + 464) = v10;
  *(_OWORD *)(a1 + 416) = v11;
  *(_OWORD *)(a1 + 432) = v12;
  v13 = a2[32];
  v15 = a2[29];
  v14 = a2[30];
  *(_OWORD *)(a1 + 512) = a2[31];
  *(_OWORD *)(a1 + 528) = v13;
  *(_OWORD *)(a1 + 603) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 480) = v15;
  *(_OWORD *)(a1 + 496) = v14;
  sub_66B70(a1, 0);
  return 0;
}
// 72138: using guessed type __int64 (__fastcall *off_72138[8])();

//----- (0000000000066104) ----------------------------------------------------
__int64 __fastcall sub_66104(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v6; // x8
  __int64 result; // x0

  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) & 1) == 0 )
    return 4294960754LL;
  v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 24LL))(a1, a2);
  result = 0;
  *a3 = v6;
  return result;
}

//----- (0000000000066180) ----------------------------------------------------
__int64 __fastcall sub_66180(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v6; // x0
  _BYTE v8[32]; // [xsp+8h] [xbp-48h] BYREF
  __int64 v9; // [xsp+28h] [xbp-28h]

  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) & 1) == 0 )
    return 4294960754LL;
  (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1 + 32LL))(a1, a2, a3);
  if ( a2 == -1 )
  {
    (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 72LL))(a1, v8);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 104LL))(a1, 0);
    if ( v9 )
    {
      v6 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, 4294967294LL);
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 32LL))(a1, 4294967294LL, v9 + v6);
    }
  }
  return 0;
}

//----- (000000000006626C) ----------------------------------------------------
__int64 __fastcall sub_6626C(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 64LL))(a1, 0);
}

//----- (0000000000066280) ----------------------------------------------------
__int64 __fastcall sub_66280(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 64LL))(a1, 1);
}

//----- (0000000000066294) ----------------------------------------------------
__int64 __fastcall sub_66294(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 72LL))(a1);
  if ( *(_QWORD *)(a2 + 8) )
    return 0;
  else
    return 4294960747LL;
}

//----- (00000000000662D4) ----------------------------------------------------
__int64 __fastcall sub_662D4(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80LL))(a1);
  return 4294960756LL;
}

//----- (00000000000662FC) ----------------------------------------------------
const char *__fastcall sub_662FC(__int64 a1, unsigned int *a2, _QWORD *a3, __int64 a4, char a5)
{
  __int64 v9; // x23
  unsigned int *v10; // x24
  __int64 v11; // x8
  unsigned int *v12; // x1
  const char *result; // x0
  unsigned __int8 *v14; // x23
  unsigned __int8 v15; // w3
  __int64 v16; // x24
  __int64 v17; // x0
  int v18; // w8
  __int64 v19; // x25
  __int64 v20; // x0
  unsigned __int8 *v21; // x27
  int v22; // w8
  unsigned __int8 *v23; // x26
  unsigned __int8 v24; // w3
  unsigned __int8 *v25; // [xsp+18h] [xbp+18h] BYREF

  v10 = a2 + 1;
  v9 = *a2;
  if ( (_DWORD)v9 != -1 )
  {
    if ( *a2 )
      goto LABEL_3;
    return "FDE has zero length";
  }
  v9 = *(_QWORD *)(a2 + 1);
  v10 = a2 + 3;
  if ( !v9 )
    return "FDE has zero length";
LABEL_3:
  v11 = *v10;
  if ( !(_DWORD)v11 )
    return "FDE is really a CIE";
  v12 = (unsigned int *)((char *)v10 - v11);
  if ( (a5 & 1) != 0 )
  {
    if ( *(unsigned int **)a4 != v12 )
      return "CIE start does not match";
  }
  else
  {
    result = sub_6648C(a1, v12, a4);
    if ( result )
      return result;
  }
  v14 = (unsigned __int8 *)v10 + v9;
  v15 = *(_BYTE *)(a4 + 24);
  v25 = (unsigned __int8 *)(v10 + 1);
  v16 = sub_681E8(a1, &v25, v14, v15, 0);
  v17 = sub_681E8(a1, &v25, v14, *(_BYTE *)(a4 + 24) & 0xF, 0);
  v18 = *(unsigned __int8 *)(a4 + 49);
  v19 = v17;
  a3[5] = 0;
  if ( v18 )
  {
    v20 = sub_6850C(&v25, v14);
    v21 = v25;
    v22 = *(unsigned __int8 *)(a4 + 25);
    v23 = &v25[v20];
    if ( v22 != 255 )
    {
      if ( sub_681E8(a1, &v25, v14, v22 & 0xF, 0) )
      {
        v24 = *(_BYTE *)(a4 + 25);
        v25 = v21;
        a3[5] = sub_681E8(a1, &v25, v14, v24, 0);
      }
    }
  }
  else
  {
    v23 = v25;
  }
  result = 0;
  a3[2] = v23;
  a3[3] = v16;
  *a3 = a2;
  a3[1] = v14 - (unsigned __int8 *)a2;
  a3[4] = v19 + v16;
  return result;
}

//----- (000000000006648C) ----------------------------------------------------
const char *__fastcall sub_6648C(__int64 a1, unsigned int *a2, __int64 a3)
{
  char v4; // w20
  unsigned int *v6; // x8
  __int64 v7; // x9
  unsigned __int8 *v8; // x22
  const char *result; // x0
  __int64 v10; // x9
  int v11; // w24
  _BYTE *v12; // x23
  unsigned __int8 *v13; // x8
  int v15; // w0
  unsigned __int8 *v16; // x8
  int v17; // w11
  int v18; // w9
  unsigned __int8 *v19; // x10
  unsigned int v20; // w12
  unsigned int v21; // t1
  unsigned __int64 v22; // x13
  unsigned int v23; // w13
  __int64 v24; // x11
  char v29; // t1
  unsigned __int8 v30; // w3
  char v31; // w8
  unsigned __int8 v32; // t1
  char v33; // t1
  unsigned __int8 *v34; // x9
  char *v35; // [xsp+18h] [xbp+18h] BYREF

  *(_WORD *)(a3 + 51) = 0;
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_WORD *)(a3 + 48) = 0;
  v4 = (char)a2;
  *(_DWORD *)(a3 + 24) = 65280;
  *(_QWORD *)a3 = a2;
  v6 = a2 + 1;
  v7 = *a2;
  if ( (_DWORD)v7 != -1 )
  {
    v8 = (unsigned __int8 *)v6 + v7;
    if ( *a2 )
      goto LABEL_3;
    return 0;
  }
  v10 = *(_QWORD *)(a2 + 1);
  v6 = a2 + 3;
  v8 = (unsigned __int8 *)a2 + v10 + 12;
  if ( !v10 )
    return 0;
LABEL_3:
  if ( *v6 )
    return "CIE ID is not zero";
  v11 = *((unsigned __int8 *)v6 + 4);
  if ( (v11 & 0xFFFFFFFD) != 1 )
    return "CIE version is not 1 or 3";
  v12 = (char *)v6 + 5;
  v13 = (unsigned __int8 *)v6 + 5;
  while ( *v13++ )
    ;
  v35 = (char *)v13;
  v15 = sub_6850C((unsigned __int8 **)&v35, v8);
  v16 = (unsigned __int8 *)v35;
  v17 = 0;
  v18 = 0;
  *(_DWORD *)(a3 + 40) = v15;
  v19 = v16;
  do
  {
    if ( v19 == v8 )
    {
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    }
    v21 = *v19++;
    v20 = v21;
    ++v16;
    v22 = (unsigned __int64)(v21 & 0x7F) << v17;
    v17 += 7;
    v18 |= v22;
  }
  while ( (v21 & 0x80) != 0 );
  v23 = v17 - 7;
  v24 = -1LL << v17;
  v35 = (char *)v16;
  if ( ((v23 < 0x39) & (v20 >> 6)) == 0 )
    LODWORD(v24) = 0;
  *(_DWORD *)(a3 + 44) = v18 | v24;
  if ( v11 == 1 )
  {
    v35 = (char *)(v16 + 1);
    *(_BYTE *)(a3 + 50) = *v19;
    if ( *v12 != 122 )
      goto LABEL_31;
LABEL_20:
    sub_6850C((unsigned __int8 **)&v35, v8);
    while ( 1 )
    {
      switch ( *v12 )
      {
        case 'B':
          __asm { BTI             j; jumptable 0000000000066638 case 66 }
          *(_BYTE *)(a3 + 51) = 1;
          ++v12;
          continue;
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'M':
        case 'N':
        case 'O':
        case 'Q':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
          goto LABEL_22;
        case 'G':
          __asm { BTI             j; jumptable 0000000000066638 case 71 }
          *(_BYTE *)(a3 + 52) = 1;
          goto LABEL_22;
        case 'L':
          __asm { BTI             j; jumptable 0000000000066638 case 76 }
          ++v12;
          v29 = *v35++;
          *(_BYTE *)(a3 + 25) = v29;
          continue;
        case 'P':
          __asm { BTI             j; jumptable 0000000000066638 case 80 }
          v32 = *v35;
          v30 = *v35++;
          v31 = (char)v35;
          *(_BYTE *)(a3 + 26) = v32;
          *(_BYTE *)(a3 + 27) = v31 - v4;
          *(_QWORD *)(a3 + 32) = sub_681E8(a1, (unsigned __int8 **)&v35, v8, v30, 0);
          ++v12;
          continue;
        case 'R':
          __asm { BTI             j; jumptable 0000000000066638 case 82 }
          ++v12;
          v33 = *v35++;
          *(_BYTE *)(a3 + 24) = v33;
          continue;
        case 'S':
          __asm { BTI             j; jumptable 0000000000066638 case 83 }
          *(_BYTE *)(a3 + 48) = 1;
          ++v12;
          continue;
        case 'z':
          __asm { BTI             j; jumptable 0000000000066638 case 122 }
          *(_BYTE *)(a3 + 49) = 1;
          ++v12;
          continue;
        default:
          if ( !*v12 )
            goto LABEL_31;
LABEL_22:
          __asm { BTI             j; jumptable 0000000000066638 cases 67-70,72-75,77-79,81,84-121 }
          ++v12;
          break;
      }
    }
  }
  *(_BYTE *)(a3 + 50) = sub_6850C((unsigned __int8 **)&v35, v8);
  if ( *v12 == 122 )
    goto LABEL_20;
LABEL_31:
  result = 0;
  v34 = (unsigned __int8 *)v35;
  *(_QWORD *)(a3 + 8) = &v8[-*(_QWORD *)a3];
  *(_QWORD *)(a3 + 16) = v34;
  return result;
}

//----- (000000000006674C) ----------------------------------------------------
void sub_6674C()
{
  ;
}

//----- (0000000000066754) ----------------------------------------------------
void sub_66754()
{
  ;
}

//----- (000000000006675C) ----------------------------------------------------
bool __fastcall sub_6675C(__int64 a1, unsigned int a2)
{
  if ( a2 > 0xFFFFFFFD )
    return 1;
  if ( a2 > 0x5F )
    return 0;
  if ( a2 == 34 )
    return 1;
  return a2 - 64 < 0xFFFFFFE1;
}

//----- (000000000006679C) ----------------------------------------------------
__int64 __fastcall sub_6679C(_QWORD *a1, unsigned int a2)
{
  __int64 result; // x0

  switch ( a2 )
  {
    case 0xFFFFFFFE:
    case 0x1Fu:
      __asm { BTI             j; jumptable 00000000000667CC cases 0,33 }
      result = a1[33];
      break;
    case 0xFFFFFFFF:
    case 0x20u:
      __asm { BTI             j; jumptable 00000000000667CC cases 1,34 }
      result = a1[34];
      break;
    case 0x1Du:
      __asm { BTI             j; jumptable 00000000000667CC case 31 }
      result = a1[31];
      break;
    case 0x1Eu:
      __asm { BTI             j; jumptable 00000000000667CC case 32 }
      result = a1[32];
      break;
    case 0x22u:
      __asm { BTI             j; jumptable 00000000000667CC case 36 }
      result = a1[35];
      break;
    default:
      __asm { BTI             j; jumptable 00000000000667CC default case, cases 2-30,35 }
      if ( a2 > 0x1C )
      {
        fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getRegister", "unsupported arm64 register");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      result = a1[a2 + 2];
      break;
  }
  return result;
}

//----- (00000000000668BC) ----------------------------------------------------
_QWORD *__fastcall sub_668BC(_QWORD *result, unsigned int a2, __int64 a3)
{
  switch ( a2 )
  {
    case 0xFFFFFFFE:
    case 0x1Fu:
      __asm { BTI             j; jumptable 00000000000668EC cases 0,33 }
      result[33] = a3;
      break;
    case 0xFFFFFFFF:
    case 0x20u:
      __asm { BTI             j; jumptable 00000000000668EC cases 1,34 }
      result[34] = a3;
      break;
    case 0x1Du:
      __asm { BTI             j; jumptable 00000000000668EC case 31 }
      result[31] = a3;
      break;
    case 0x1Eu:
      __asm { BTI             j; jumptable 00000000000668EC case 32 }
      result[32] = a3;
      break;
    case 0x22u:
      __asm { BTI             j; jumptable 00000000000668EC case 36 }
      result[35] = a3;
      break;
    default:
      __asm { BTI             j; jumptable 00000000000668EC default case, cases 2-30,35 }
      if ( a2 > 0x1C )
      {
        fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "setRegister", "unsupported arm64 register");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      result[a2 + 2] = a3;
      break;
  }
  return result;
}

//----- (00000000000669DC) ----------------------------------------------------
bool __fastcall sub_669DC(__int64 a1, int a2)
{
  return (a2 & 0xFFFFFFE0) == 64;
}

//----- (00000000000669F0) ----------------------------------------------------
double __fastcall sub_669F0(__int64 a1, int a2)
{
  return *(double *)(a1 + 8LL * a2 - 224);
}

//----- (0000000000066A00) ----------------------------------------------------
__int64 __fastcall sub_66A00(__int64 result, int a2, double a3)
{
  *(double *)(result + 8LL * a2 - 224) = a3;
  return result;
}

//----- (0000000000066A10) ----------------------------------------------------
__int64 __fastcall sub_66A10(__int64 a1, char a2)
{
  unsigned int v2; // w20
  __int64 v5; // x21
  __int64 v7; // x0
  __int64 v8; // [xsp+0h] [xbp-210h] BYREF

  if ( !*(_BYTE *)(a1 + 616) )
  {
    if ( *(_BYTE *)(a1 + 618) )
    {
      memset(&v8, 0, 0x210u);
      v2 = sub_66DFC(a1);
      if ( v2 != 1 )
        return v2;
    }
    else
    {
      v5 = *(_QWORD *)(a1 + 8);
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0xFFFFFFFFLL);
      v2 = sub_66F20(v5, v7, *(unsigned int **)(a1 + 600), (__int64 *)(a1 + 16), (_BYTE *)(a1 + 617), a2 & 1);
      if ( v2 != 1 )
        return v2;
    }
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 104LL))(a1, 1);
    if ( !*(_BYTE *)(a1 + 616) )
      return v2;
  }
  return 0;
}

//----- (0000000000066AE8) ----------------------------------------------------
long double __fastcall sub_66AE8(__int64 a1, __int64 a2)
{
  long double result; // q0
  __int64 v3; // x8
  __int128 v4; // q2

  if ( *(_BYTE *)(a1 + 616) )
  {
    *(_OWORD *)&result = 0u;
    *(_QWORD *)(a2 + 64) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 544);
    result = *(long double *)(a1 + 592);
    v3 = *(_QWORD *)(a1 + 608);
    v4 = *(_OWORD *)(a1 + 560);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 576);
    *(long double *)(a2 + 48) = result;
    *(_QWORD *)(a2 + 64) = v3;
    *(_OWORD *)(a2 + 16) = v4;
  }
  return result;
}

//----- (0000000000066B2C) ----------------------------------------------------
__int64 __fastcall sub_66B2C(__int64 a1)
{
  return sub_699D4(a1 + 16);
}

//----- (0000000000066B38) ----------------------------------------------------
__int64 __fastcall sub_66B38(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 617);
}

//----- (0000000000066B44) ----------------------------------------------------
__int64 __fastcall sub_66B44(__int64 a1)
{
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0xFFFFFFFFLL);
  return 0;
}

//----- (0000000000066B70) ----------------------------------------------------
__int64 __fastcall sub_66B70(__int64 a1, char a2)
{
  __int64 v2; // x8
  __int64 result; // x0
  unsigned __int64 v6; // x20
  _QWORD *i; // x8
  unsigned int *v8; // x21
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x10
  __int128 v12; // q0
  __int64 v13; // x9
  __int64 v14; // x20
  unsigned int v15; // w0
  _QWORD v16[7]; // [xsp+0h] [xbp-6B0h] BYREF
  __int64 v17; // [xsp+38h] [xbp-678h] BYREF
  __int64 v18; // [xsp+40h] [xbp-670h]
  __int128 v19; // [xsp+50h] [xbp-660h]
  __int64 v20; // [xsp+60h] [xbp-650h]
  __int64 v21[6]; // [xsp+68h] [xbp-648h] BYREF
  __int64 *data; // [xsp+98h] [xbp-618h] BYREF
  __int64 *v23; // [xsp+A0h] [xbp-610h]
  unsigned __int64 v24; // [xsp+A8h] [xbp-608h]

  v2 = *(_QWORD *)a1;
  *(_BYTE *)(a1 + 618) = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64))(v2 + 24))(a1, 0xFFFFFFFFLL);
  if ( result )
  {
    v6 = result - (a2 & 1);
    data = *(__int64 **)(a1 + 8);
    v23 = v21;
    v24 = v6;
    if ( !dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))sub_69388, &data)
      || !v21[2]
      || (result = sub_690A0(a1, v6, v21, 0), (result & 1) == 0) )
    {
      pthread_rwlock_rdlock(&stru_78D64);
      for ( i = off_78930; ; i += 4 )
      {
        if ( i >= (_QWORD *)off_78938 )
        {
          pthread_rwlock_unlock(&stru_78D64);
          goto LABEL_15;
        }
        if ( i[1] <= v6 && i[2] > v6 )
          break;
      }
      v8 = (unsigned int *)i[3];
      pthread_rwlock_unlock(&stru_78D64);
      if ( v8 )
      {
        if ( !sub_662FC(*(_QWORD *)(a1 + 8), v8, &v17, (__int64)v16, 0) )
        {
          memset(&data, 0, 0x618u);
          result = sub_673DC(*(_QWORD *)(a1 + 8), &v17, (__int64)v16, v6, 4, &data);
          if ( (result & 1) != 0 )
          {
            v9 = v20;
            *(_QWORD *)(a1 + 584) = 0;
            v10 = v16[4];
            *(_QWORD *)(a1 + 608) = 0;
            v11 = (unsigned int)v24;
            *(_QWORD *)(a1 + 560) = v9;
            *(_QWORD *)(a1 + 568) = v10;
            v12 = v19;
            *(_QWORD *)(a1 + 576) = v11;
            *(_DWORD *)(a1 + 592) = 50331648;
            v13 = v17;
            LODWORD(v9) = v18;
            *(_OWORD *)(a1 + 544) = v12;
            *(_QWORD *)(a1 + 600) = v13;
            *(_DWORD *)(a1 + 596) = v9;
            return result;
          }
        }
      }
LABEL_15:
      v14 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0xFFFFFFFFLL);
      data = &v17;
      v23 = (_QWORD *)&byte_8;
      v16[0] = v14;
      v16[1] = 8;
      v15 = getpid();
      result = syscall(270, v15, &data, 1, v16, 1, 0);
      if ( result == 8 && v17 == 0xD4000001D2801168LL )
      {
        *(_QWORD *)(a1 + 608) = 0;
        *(_QWORD *)(a1 + 544) = v14;
        *(_QWORD *)(a1 + 552) = v14 + 4;
        *(_OWORD *)(a1 + 576) = 0u;
        *(_OWORD *)(a1 + 592) = 0u;
        *(_OWORD *)(a1 + 560) = 0u;
        *(_BYTE *)(a1 + 618) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 616) = 1;
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 616) = 1;
  }
  return result;
}
// 8: using guessed type char;
// 78930: using guessed type _UNKNOWN *off_78930;
// 78938: using guessed type _UNKNOWN *off_78938;
// 78D64: using guessed type pthread_rwlock_t stru_78D64;

//----- (0000000000066DF0) ----------------------------------------------------
const char *__fastcall sub_66DF0(__int64 a1, int a2)
{
  return sub_699A4(a2);
}

//----- (0000000000066DFC) ----------------------------------------------------
__int64 __fastcall sub_66DFC(__int64 a1)
{
  _QWORD *v1; // x9
  __int64 v3; // x9
  __int64 result; // x0

  v1 = *(_QWORD **)(a1 + 264);
  *(_QWORD *)(a1 + 16) = v1[39];
  *(_QWORD *)(a1 + 24) = v1[40];
  *(_QWORD *)(a1 + 32) = v1[41];
  *(_QWORD *)(a1 + 40) = v1[42];
  *(_QWORD *)(a1 + 48) = v1[43];
  *(_QWORD *)(a1 + 56) = v1[44];
  *(_QWORD *)(a1 + 64) = v1[45];
  *(_QWORD *)(a1 + 72) = v1[46];
  *(_QWORD *)(a1 + 80) = v1[47];
  *(_QWORD *)(a1 + 88) = v1[48];
  *(_QWORD *)(a1 + 96) = v1[49];
  *(_QWORD *)(a1 + 104) = v1[50];
  *(_QWORD *)(a1 + 112) = v1[51];
  *(_QWORD *)(a1 + 120) = v1[52];
  *(_QWORD *)(a1 + 128) = v1[53];
  *(_QWORD *)(a1 + 136) = v1[54];
  *(_QWORD *)(a1 + 144) = v1[55];
  *(_QWORD *)(a1 + 152) = v1[56];
  *(_QWORD *)(a1 + 160) = v1[57];
  *(_QWORD *)(a1 + 168) = v1[58];
  *(_QWORD *)(a1 + 176) = v1[59];
  *(_QWORD *)(a1 + 184) = v1[60];
  *(_QWORD *)(a1 + 192) = v1[61];
  *(_QWORD *)(a1 + 200) = v1[62];
  *(_QWORD *)(a1 + 208) = v1[63];
  *(_QWORD *)(a1 + 216) = v1[64];
  *(_QWORD *)(a1 + 224) = v1[65];
  *(_QWORD *)(a1 + 232) = v1[66];
  *(_QWORD *)(a1 + 240) = v1[67];
  *(_QWORD *)(a1 + 248) = v1[68];
  *(_QWORD *)(a1 + 256) = v1[69];
  *(_QWORD *)(a1 + 264) = v1[70];
  v3 = v1[71];
  result = 1;
  *(_BYTE *)(a1 + 617) = 1;
  *(_QWORD *)(a1 + 272) = v3;
  return result;
}

//----- (0000000000066F20) ----------------------------------------------------
__int64 __fastcall sub_66F20(__int64 a1, __int64 a2, unsigned int *a3, __int64 *a4, _BYTE *a5, char a6)
{
  unsigned __int64 v11; // x0
  __int64 v12; // x22
  unsigned __int64 v18; // x26
  __int64 v19; // x23
  __int64 *v20; // x24
  __int64 *v21; // x28
  __int64 v23; // d0
  __int64 *v24; // x9
  __int64 v25; // x0
  __int64 *v26; // x8
  __int64 v27[66]; // [xsp+50h] [xbp-AC0h] BYREF
  _BYTE dest[232]; // [xsp+260h] [xbp-8B0h] BYREF
  __int64 v29; // [xsp+348h] [xbp-7C8h]
  __int64 v30; // [xsp+350h] [xbp-7C0h]
  __int64 v31; // [xsp+358h] [xbp-7B8h] BYREF
  _QWORD v32[34]; // [xsp+360h] [xbp-7B0h] BYREF
  unsigned __int8 *s[3]; // [xsp+470h] [xbp-6A0h] BYREF
  __int64 v34; // [xsp+488h] [xbp-688h] BYREF
  __int128 v35; // [xsp+6A8h] [xbp-468h]
  _BYTE v36[50]; // [xsp+A88h] [xbp-88h] BYREF
  unsigned __int8 v37; // [xsp+ABAh] [xbp-56h]
  char v38; // [xsp+ABCh] [xbp-54h]
  __int64 v39[6]; // [xsp+AC0h] [xbp-50h] BYREF
  __int128 v40; // [xsp+AF0h] [xbp-20h] BYREF

  if ( sub_662FC(a1, a3, v39, (__int64)v36, 0) )
    return 4294960750LL;
  memset(s, 0, 0x618u);
  if ( (sub_673DC(a1, v39, (__int64)v36, a2, 4, s) & 1) == 0 )
    return 4294960750LL;
  v11 = sub_67EF0(a1, s, a4);
  v12 = v11;
  if ( (a6 & 1) != 0 )
  {
    if ( v38 )
    {
      for ( _X8 = a4[31] & 0xFFFFFFFFFFFFFFF0LL; _X8 < v11; _X8 += 16LL )
        __asm { STG             X8, [X8] }
    }
  }
  memcpy(dest, a4, 0x210u);
  v18 = 0;
  v19 = 0;
  v20 = &v34;
  v21 = (__int64 *)dest;
  v31 = v12;
  do
  {
    if ( *(_DWORD *)v20 )
    {
      if ( (v18 & 0x60) == 0x40 )
      {
        v23 = 0;
        switch ( *(_DWORD *)v20 )
        {
          case 1:
            break;
          case 2:
            __asm { BTI             j; jumptable 00000000000670E4 case 2 }
            v23 = *(_QWORD *)(v20[1] + v12);
            break;
          case 5:
            __asm { BTI             j; jumptable 00000000000670E4 case 5 }
            v23 = *(__int64 *)((char *)a4 + (((v20[1] << 32) - 0x4000000000LL) >> 29) + 272);
            break;
          case 6:
            __asm { BTI             j; jumptable 00000000000670E4 case 6 }
            v23 = *(_QWORD *)sub_686DC((unsigned __int8 *)v20[1], a1, a4, v12);
            break;
          default:
            __asm { BTI             j; jumptable 00000000000670E4 default case, cases 3,4 }
            fprintf(
              (FILE *)((char *)&_sF + 304),
              "libunwind: %s - %s\n",
              "getSavedFloatRegister",
              "unsupported restore location for float register");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
        }
        __asm { BTI             j; jumptable 00000000000670E4 case 1 }
        v32[(unsigned int)(v18 - 64) + 2] = v23;
      }
      else if ( v18 == v37 )
      {
        v19 = sub_67FEC(a1, a4, v12, (__int64)v20);
      }
      else if ( v18 == 34 )
      {
        v25 = sub_67FEC(a1, a4, v12, (__int64)v20);
LABEL_24:
        __asm { BTI             j; jumptable 00000000000671DC case 34 }
        v32[1] = v25;
      }
      else
      {
        if ( (unsigned int)(v18 - 64) > 0xFFFFFFE0 )
          return 4294960754LL;
        v25 = sub_67FEC(a1, a4, v12, (__int64)v20);
        v26 = &v31;
        switch ( (int)v18 )
        {
          case 29:
            __asm { BTI             j; jumptable 00000000000671DC case 29 }
            v29 = v25;
            break;
          case 30:
            __asm { BTI             j; jumptable 00000000000671DC case 30 }
            v30 = v25;
            break;
          case 31:
            goto LABEL_38;
          case 32:
            __asm { BTI             j; jumptable 00000000000671DC case 32 }
            v26 = v32;
            goto LABEL_38;
          case 34:
            goto LABEL_24;
          default:
            __asm { BTI             j; jumptable 00000000000671DC default case, case 33 }
            v26 = v21;
            if ( v18 >= 0x1D )
            {
              fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "setRegister", "unsupported arm64 register");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
LABEL_38:
            __asm { BTI             j; jumptable 00000000000671DC case 31 }
            *v26 = v25;
            break;
        }
      }
    }
    else if ( v18 == v37 )
    {
      v24 = a4 + 32;
      switch ( v37 )
      {
        case 0x1Du:
          __asm { BTI             j; jumptable 0000000000067134 case 29 }
          v24 = a4 + 29;
          break;
        case 0x1Eu:
          __asm { BTI             j; jumptable 0000000000067134 case 30 }
          v24 = a4 + 30;
          break;
        case 0x1Fu:
          __asm { BTI             j; jumptable 0000000000067134 case 31 }
          v24 = a4 + 31;
          break;
        case 0x20u:
          break;
        case 0x22u:
          __asm { BTI             j; jumptable 0000000000067134 case 34 }
          v24 = a4 + 33;
          break;
        default:
          __asm { BTI             j; jumptable 0000000000067134 default case, case 33 }
          if ( v37 > 0x1Cu )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getRegister", "unsupported arm64 register");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v24 = &a4[v37];
          break;
      }
      __asm { BTI             j; jumptable 0000000000067134 case 32 }
      v19 = *v24;
    }
    ++v18;
    v20 += 2;
    ++v21;
  }
  while ( v18 != 96 );
  *a5 = v36[48];
  memcpy(v27, a4, sizeof(v27));
  v40 = v35;
  if ( (_DWORD)v35 )
    sub_67FEC(a1, v27, v12, (__int64)&v40);
  v32[0] = v19;
  memcpy(a4, dest, 0x210u);
  return 1;
}

//----- (00000000000673DC) ----------------------------------------------------
__int64 __fastcall sub_673DC(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int a5, _BYTE *dest)
{
  __int64 v6; // x10
  __int64 v10; // x27
  __int64 v11; // x8
  __int64 v12; // x9
  __int64 v13; // x12
  __int64 v14; // x10
  __int64 v15; // x13
  unsigned __int8 **v16; // x8
  unsigned __int8 *v17; // x9
  unsigned __int8 *v18; // x24
  unsigned __int64 v19; // x23
  unsigned __int64 v21; // x25
  unsigned __int8 *v22; // x8
  int v23; // w10
  int v27; // w8
  unsigned __int8 *v28; // x9
  unsigned __int64 v29; // x26
  __int64 v30; // x0
  char *v31; // x8
  __int64 v32; // x9
  __int64 v33; // x9
  unsigned __int64 v34; // x0
  __int64 v35; // x8
  unsigned __int64 v36; // x0
  char *v37; // x9
  _BYTE *v38; // x9
  int v39; // t1
  unsigned __int64 v40; // x0
  char *v41; // x9
  _BYTE *v42; // x9
  int v43; // t1
  unsigned __int64 v44; // x26
  unsigned __int64 v45; // x0
  char *v46; // x8
  _QWORD *v47; // x26
  unsigned __int64 v48; // x26
  int v49; // w0
  unsigned __int64 v50; // x0
  unsigned __int64 v51; // x0
  char *v52; // x8
  int v53; // w9
  unsigned __int64 v54; // x0
  unsigned __int8 *v55; // x9
  int v56; // w10
  __int64 v57; // x8
  unsigned __int8 *v58; // x12
  unsigned int v59; // w11
  unsigned int v60; // t1
  unsigned __int64 v61; // x13
  char *v62; // x12
  _BOOL4 v63; // w14
  __int64 v64; // x10
  int v65; // w14
  __int64 v66; // x11
  __int64 v67; // x10
  __int64 v68; // x8
  int v69; // w9
  unsigned __int64 v70; // x0
  unsigned __int8 *v71; // x10
  int v72; // w9
  int v73; // w8
  unsigned __int8 *v74; // x12
  unsigned int v75; // w11
  unsigned int v76; // t1
  unsigned __int64 v77; // x13
  unsigned int v78; // w10
  __int64 v79; // x9
  int v80; // w10
  int v81; // w10
  int v82; // w9
  unsigned __int8 *v83; // x11
  unsigned int v84; // w12
  unsigned int v85; // t1
  unsigned __int64 v86; // x13
  unsigned int v87; // w11
  __int64 v88; // x10
  unsigned __int64 v89; // x0
  unsigned __int64 v90; // x26
  __int64 v91; // x0
  __int64 v92; // x9
  int v93; // w10
  unsigned __int64 v94; // x0
  unsigned __int8 *v95; // x9
  int v96; // w10
  __int64 v97; // x8
  unsigned __int8 *v98; // x12
  unsigned int v99; // w11
  unsigned int v100; // t1
  unsigned __int64 v101; // x13
  _BOOL4 v102; // w14
  __int64 v103; // x10
  int v104; // w14
  __int64 v105; // x11
  unsigned __int64 v106; // x0
  unsigned __int8 *v107; // x10
  __int64 v108; // x0
  __int64 v109; // x26
  int v110; // w8
  __int64 v111; // x0
  char *v112; // x8
  __int64 v113; // x9
  _BYTE *v114; // x8
  int v115; // t1
  __int64 v116; // x8
  char *v117; // x9
  unsigned __int64 v118; // x0
  unsigned __int64 v119; // x26
  __int64 v120; // x0
  __int64 v121; // x9
  const char *v123; // x0
  size_t v124; // x1
  FILE *v125; // x3
  _BYTE v126[4]; // [xsp+0h] [xbp-680h] BYREF
  int v127; // [xsp+4h] [xbp-67Ch]
  __int64 *v128; // [xsp+8h] [xbp-678h]
  _OWORD *v129; // [xsp+10h] [xbp-670h]
  __int64 v130; // [xsp+18h] [xbp-668h]
  _BYTE *v131; // [xsp+20h] [xbp-660h]
  _BYTE v132[568]; // [xsp+28h] [xbp-658h] BYREF
  __int64 v133; // [xsp+260h] [xbp-420h] BYREF
  unsigned __int8 *v134; // [xsp+640h] [xbp-40h] BYREF
  _QWORD v135[7]; // [xsp+648h] [xbp-38h] BYREF

  v6 = *(_QWORD *)(a3 + 16);
  v10 = 0;
  v11 = *(_QWORD *)(a3 + 8) + *(_QWORD *)a3;
  v12 = *a2;
  v13 = a2[1];
  v130 = a1;
  v131 = 0;
  v135[0] = v6;
  v135[1] = v11;
  v14 = a2[2];
  v15 = a2[3];
  v135[2] = -1;
  v135[3] = v14;
  v135[4] = v13 + v12;
  v135[5] = a4 - v15;
  v128 = &v133;
  v129 = dest + 568;
  while ( 1 )
  {
    v16 = (unsigned __int8 **)&v135[3 * v10];
    v18 = v16[1];
    v19 = (unsigned __int64)v16[2];
    v134 = *v16;
    v17 = v134;
    _ZF = v134 >= v18 || v19 == 0;
    if ( !_ZF )
      break;
LABEL_2:
    if ( ++v10 == 2 )
      return 1;
  }
  v21 = 0;
  while ( 2 )
  {
    v22 = v17 + 1;
    v23 = *v17;
    v134 = v17 + 1;
    switch ( v23 )
    {
      case 0:
        goto LABEL_113;
      case 1:
        __asm { BTI             j; jumptable 00000000000674B4 case 1 }
        v21 = sub_681E8(v130, &v134, v18, *(_BYTE *)(a3 + 24), 0);
        goto LABEL_113;
      case 2:
        __asm { BTI             j; jumptable 00000000000674B4 case 2 }
        v27 = v17[1];
        v28 = v17 + 2;
        goto LABEL_13;
      case 3:
        __asm { BTI             j; jumptable 00000000000674B4 case 3 }
        v27 = *(unsigned __int16 *)(v17 + 1);
        v28 = v17 + 3;
        goto LABEL_13;
      case 4:
        __asm { BTI             j; jumptable 00000000000674B4 case 4 }
        v27 = *(_DWORD *)(v17 + 1);
        v28 = v17 + 5;
LABEL_13:
        v21 += (unsigned int)(*(_DWORD *)(a3 + 40) * v27);
        v134 = v28;
        goto LABEL_113;
      case 5:
        __asm { BTI             j; jumptable 00000000000674B4 case 5 }
        v29 = sub_6850C(&v134, v18);
        v30 = sub_6850C(&v134, v18);
        if ( v29 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_offset_extended DWARF unwind, reg too big\n";
          v124 = 70;
          goto LABEL_134;
        }
        v31 = &dest[16 * v29];
        v32 = *(int *)(a3 + 44);
        if ( !v31[28] )
        {
          *(_OWORD *)&v132[16 * v29 + 24] = *(_OWORD *)&dest[16 * v29 + 24];
          v31[28] = 1;
        }
        v33 = v30 * v32;
        goto LABEL_107;
      case 6:
        __asm { BTI             j; jumptable 00000000000674B4 case 6 }
        v34 = sub_6850C(&v134, v18);
        if ( v34 < 0x60 )
        {
          if ( dest[16 * v34 + 28] )
          {
            v35 = 16 * v34;
LABEL_112:
            *(_OWORD *)&dest[v35 + 24] = *(_OWORD *)&v132[v35 + 24];
          }
          goto LABEL_113;
        }
        v123 = "libunwind: malformed DW_CFA_restore_extended DWARF unwind, reg too big\n";
        goto LABEL_124;
      case 7:
        __asm { BTI             j; jumptable 00000000000674B4 case 7 }
        v36 = sub_6850C(&v134, v18);
        if ( v36 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_undefined DWARF unwind, reg too big\n";
          goto LABEL_133;
        }
        v37 = &dest[16 * v36];
        v39 = (unsigned __int8)v37[28];
        v38 = v37 + 28;
        if ( !v39 )
        {
          *(_OWORD *)&v132[16 * v36 + 24] = *(_OWORD *)&dest[16 * v36 + 24];
          *v38 = 1;
        }
        *(_DWORD *)&dest[16 * v36 + 24] = 1;
        goto LABEL_113;
      case 8:
        __asm { BTI             j; jumptable 00000000000674B4 case 8 }
        v40 = sub_6850C(&v134, v18);
        if ( v40 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_same_value DWARF unwind, reg too big\n";
          v124 = 65;
          goto LABEL_134;
        }
        v41 = &dest[16 * v40];
        v43 = (unsigned __int8)v41[28];
        v42 = v41 + 28;
        if ( !v43 )
        {
          *(_OWORD *)&v132[16 * v40 + 24] = *(_OWORD *)&dest[16 * v40 + 24];
          *v42 = 1;
        }
        *(_DWORD *)&dest[16 * v40 + 24] = 0;
        goto LABEL_113;
      case 9:
        __asm { BTI             j; jumptable 00000000000674B4 case 9 }
        v44 = sub_6850C(&v134, v18);
        v45 = sub_6850C(&v134, v18);
        if ( v44 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg too big\n";
          v124 = 63;
          goto LABEL_134;
        }
        if ( v45 < 0x60 )
        {
          v46 = &dest[16 * v44];
          if ( !v46[28] )
          {
            *(_OWORD *)&v132[16 * v44 + 24] = *(_OWORD *)&dest[16 * v44 + 24];
            v46[28] = 1;
          }
          *((_QWORD *)v46 + 4) = v45;
          *((_DWORD *)v46 + 6) = 5;
LABEL_113:
          __asm { BTI             j; jumptable 00000000000674B4 case 0 }
          v17 = v134;
          if ( v134 >= v18 || v21 >= v19 )
            goto LABEL_2;
          continue;
        }
        v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg2 too big\n";
LABEL_133:
        v124 = 64;
LABEL_134:
        v125 = (FILE *)((char *)&_sF + 304);
LABEL_135:
        fwrite(v123, v124, 1u, v125);
        return 0;
      case 10:
        __asm { BTI             j; jumptable 00000000000674B4 case 10 }
        *(_QWORD *)&v126[-1568] = v131;
        memcpy(&v126[-1560], dest, 0x618u);
        v131 = &v126[-1568];
        goto LABEL_113;
      case 11:
        __asm { BTI             j; jumptable 00000000000674B4 case 11 }
        if ( !v131 )
          return 0;
        v47 = v131;
        memcpy(dest, v131 + 8, 0x618u);
        v131 = (_BYTE *)*v47;
        goto LABEL_113;
      case 12:
        __asm { BTI             j; jumptable 00000000000674B4 case 12 }
        v48 = sub_6850C(&v134, v18);
        v49 = sub_6850C(&v134, v18);
        if ( v48 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_def_cfa DWARF unwind, reg too big\n";
          v124 = 62;
          goto LABEL_134;
        }
        *(_DWORD *)dest = v48;
        *((_DWORD *)dest + 1) = v49;
        goto LABEL_113;
      case 13:
        __asm { BTI             j; jumptable 00000000000674B4 case 13 }
        v50 = sub_6850C(&v134, v18);
        if ( v50 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_def_cfa_register DWARF unwind, reg too big\n";
LABEL_124:
          v125 = (FILE *)((char *)&_sF + 304);
          v124 = 71;
          goto LABEL_135;
        }
        *(_DWORD *)dest = v50;
        goto LABEL_113;
      case 14:
        __asm { BTI             j; jumptable 00000000000674B4 case 14 }
        *((_DWORD *)dest + 1) = sub_6850C(&v134, v18);
        goto LABEL_113;
      case 15:
        __asm { BTI             j; jumptable 00000000000674B4 case 15 }
        *(_DWORD *)dest = 0;
        *((_QWORD *)dest + 1) = v22;
        goto LABEL_91;
      case 16:
        __asm { BTI             j; jumptable 00000000000674B4 case 16 }
        v51 = sub_6850C(&v134, v18);
        if ( v51 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_expression DWARF unwind, reg too big\n";
          v124 = 65;
          goto LABEL_134;
        }
        v52 = &dest[16 * v51];
        if ( !v52[28] )
        {
          *(_OWORD *)&v132[16 * v51 + 24] = *(_OWORD *)&dest[16 * v51 + 24];
          v52[28] = 1;
        }
        v53 = 6;
        goto LABEL_90;
      case 17:
        __asm { BTI             j; jumptable 00000000000674B4 case 17 }
        v54 = sub_6850C(&v134, v18);
        if ( v54 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big\n";
          v124 = 73;
          goto LABEL_134;
        }
        v55 = v134;
        v56 = 0;
        v57 = 0;
        v58 = v134;
        do
        {
          if ( v58 == v18 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v60 = *v58++;
          v59 = v60;
          ++v55;
          v61 = (unsigned __int64)(v60 & 0x7F) << v56;
          v56 += 7;
          v57 |= v61;
        }
        while ( (v60 & 0x80) != 0 );
        v62 = &dest[16 * v54];
        v63 = (unsigned int)(v56 - 7) < 0x39;
        v64 = -1LL << v56;
        _ZF = (v63 & (v59 >> 6)) == 0;
        v65 = (unsigned __int8)v62[28];
        if ( _ZF )
          v66 = 0;
        else
          v66 = v64;
        v67 = *(int *)(a3 + 44);
        v134 = v55;
        if ( !v65 )
        {
          *(_OWORD *)&v132[16 * v54 + 24] = *(_OWORD *)&dest[16 * v54 + 24];
          v62[28] = 1;
        }
        v68 = v57 | v66;
        v69 = 2;
        goto LABEL_85;
      case 18:
        __asm { BTI             j; jumptable 00000000000674B4 case 18 }
        v70 = sub_6850C(&v134, v18);
        v71 = v134;
        v72 = 0;
        v73 = 0;
        v74 = v134;
        do
        {
          if ( v74 == v18 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v76 = *v74++;
          v75 = v76;
          ++v71;
          v77 = (unsigned __int64)(v76 & 0x7F) << v72;
          v72 += 7;
          v73 |= v77;
        }
        while ( (v76 & 0x80) != 0 );
        v134 = v71;
        if ( v70 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big\n";
          v124 = 65;
          goto LABEL_134;
        }
        v78 = v72 - 7;
        v79 = -1LL << v72;
        _ZF = ((v78 < 0x39) & (v75 >> 6)) == 0;
        v80 = *(_DWORD *)(a3 + 44);
        if ( _ZF )
          LODWORD(v79) = 0;
        *(_DWORD *)dest = v70;
        *((_DWORD *)dest + 1) = v80 * (v73 | v79);
        goto LABEL_113;
      case 19:
        __asm { BTI             j; jumptable 00000000000674B4 case 19 }
        v81 = 0;
        v82 = 0;
        v83 = v22;
        do
        {
          if ( v83 == v18 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v85 = *v83++;
          v84 = v85;
          ++v22;
          v86 = (unsigned __int64)(v85 & 0x7F) << v81;
          v81 += 7;
          v82 |= v86;
        }
        while ( (v85 & 0x80) != 0 );
        v87 = v81 - 7;
        v88 = -1LL << v81;
        v134 = v22;
        if ( ((v87 < 0x39) & (v84 >> 6)) == 0 )
          LODWORD(v88) = 0;
        *((_DWORD *)dest + 1) = *(_DWORD *)(a3 + 44) * (v82 | v88);
        goto LABEL_113;
      case 20:
        __asm { BTI             j; jumptable 00000000000674B4 case 20 }
        v89 = sub_6850C(&v134, v18);
        v90 = v89;
        if ( v89 >= 0x60 )
        {
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: malformed DW_CFA_val_offset DWARF unwind, reg (%lu) out of range\n\n",
            v89);
          return 0;
        }
        v91 = sub_6850C(&v134, v18);
        v31 = &dest[16 * v90];
        v92 = *(int *)(a3 + 44);
        if ( !v31[28] )
        {
          *(_OWORD *)&v132[16 * v90 + 24] = *(_OWORD *)&dest[16 * v90 + 24];
          v31[28] = 1;
        }
        v33 = v91 * v92;
        v93 = 4;
LABEL_108:
        *((_DWORD *)v31 + 6) = v93;
        *((_QWORD *)v31 + 4) = v33;
        goto LABEL_113;
      case 21:
        __asm { BTI             j; jumptable 00000000000674B4 case 21 }
        v94 = sub_6850C(&v134, v18);
        if ( v94 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_val_offset_sf DWARF unwind, reg too big\n";
          v124 = 68;
          goto LABEL_134;
        }
        v95 = v134;
        v96 = 0;
        v97 = 0;
        v98 = v134;
        do
        {
          if ( v98 == v18 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v100 = *v98++;
          v99 = v100;
          ++v95;
          v101 = (unsigned __int64)(v100 & 0x7F) << v96;
          v96 += 7;
          v97 |= v101;
        }
        while ( (v100 & 0x80) != 0 );
        v62 = &dest[16 * v94];
        v102 = (unsigned int)(v96 - 7) < 0x39;
        v103 = -1LL << v96;
        _ZF = (v102 & (v99 >> 6)) == 0;
        v104 = (unsigned __int8)v62[28];
        if ( _ZF )
          v105 = 0;
        else
          v105 = v103;
        v67 = *(int *)(a3 + 44);
        v134 = v95;
        if ( !v104 )
        {
          *(_OWORD *)&v132[16 * v94 + 24] = *(_OWORD *)&dest[16 * v94 + 24];
          v62[28] = 1;
        }
        v68 = v97 | v105;
        v69 = 4;
LABEL_85:
        *((_DWORD *)v62 + 6) = v69;
        *((_QWORD *)v62 + 4) = v68 * v67;
        goto LABEL_113;
      case 22:
        __asm { BTI             j; jumptable 00000000000674B4 case 22 }
        v106 = sub_6850C(&v134, v18);
        if ( v106 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_val_expression DWARF unwind, reg too big\n";
          v124 = 69;
          goto LABEL_134;
        }
        v52 = &dest[16 * v106];
        if ( !v52[28] )
        {
          *(_OWORD *)&v132[16 * v106 + 24] = *(_OWORD *)&dest[16 * v106 + 24];
          v52[28] = 1;
        }
        v53 = 7;
LABEL_90:
        v107 = v134;
        *((_DWORD *)v52 + 6) = v53;
        *((_QWORD *)v52 + 4) = v107;
LABEL_91:
        v108 = sub_6850C(&v134, v18);
        v134 += v108;
        goto LABEL_113;
      case 45:
        __asm { BTI             j; jumptable 00000000000674B4 case 45 }
        if ( a5 == 4 )
        {
          if ( !dest[572] )
          {
            *(_OWORD *)v128 = *v129;
            dest[572] = 1;
          }
          *((_QWORD *)dest + 72) ^= 1uLL;
        }
        goto LABEL_113;
      case 46:
        __asm { BTI             j; jumptable 00000000000674B4 case 46 }
        *((_DWORD *)dest + 4) = sub_6850C(&v134, v18);
        goto LABEL_113;
      case 47:
        __asm { BTI             j; jumptable 00000000000674B4 case 47 }
        v118 = sub_6850C(&v134, v18);
        if ( v118 >= 0x60 )
        {
          v123 = "libunwind: malformed DW_CFA_GNU_negative_offset_extended DWARF unwind, reg too big\n";
          v124 = 83;
          goto LABEL_134;
        }
        v119 = v118;
        v120 = sub_6850C(&v134, v18);
        v31 = &dest[16 * v119];
        v121 = *(int *)(a3 + 44);
        if ( !v31[28] )
        {
          *(_OWORD *)&v132[16 * v119 + 24] = *(_OWORD *)&dest[16 * v119 + 24];
          v31[28] = 1;
        }
        v33 = -(v120 * v121);
LABEL_107:
        v93 = 2;
        goto LABEL_108;
      default:
        __asm { BTI             j; jumptable 00000000000674B4 default case, cases 23-44 }
        v109 = v23 & 0x3F;
        v110 = v23 & 0xC0;
        if ( v110 == 64 )
        {
          v21 += (unsigned int)(*(_DWORD *)(a3 + 40) * v109);
          goto LABEL_113;
        }
        if ( v110 != 192 )
        {
          if ( v110 != 128 )
            return 0;
          v127 = a5;
          v111 = sub_6850C(&v134, v18);
          v112 = &dest[16 * (unsigned int)v109];
          v113 = *(int *)(a3 + 44);
          v115 = (unsigned __int8)v112[28];
          v114 = v112 + 28;
          if ( !v115 )
          {
            *(_OWORD *)&v132[16 * (unsigned int)v109 + 24] = *(_OWORD *)&dest[16 * (unsigned int)v109 + 24];
            *v114 = 1;
          }
          v116 = v111 * v113;
          v117 = &dest[16 * (unsigned int)v109];
          a5 = v127;
          *((_DWORD *)v117 + 6) = 2;
          *((_QWORD *)v117 + 4) = v116;
          goto LABEL_113;
        }
        if ( !dest[16 * v109 + 28] )
          goto LABEL_113;
        v35 = 16 * v109;
        goto LABEL_112;
    }
  }
}

//----- (0000000000067EF0) ----------------------------------------------------
__int64 __fastcall sub_67EF0(__int64 a1, unsigned __int8 **a2, __int64 *a3)
{
  __int64 v3; // x8
  __int64 *v8; // x8

  v3 = *(unsigned int *)a2;
  switch ( (int)v3 )
  {
    case -2:
    case 31:
      __asm { BTI             j; jumptable 0000000000067F24 cases 0,33 }
      v8 = a3 + 31;
      return *v8 + *((int *)a2 + 1);
    case -1:
    case 32:
      __asm { BTI             j; jumptable 0000000000067F24 cases 1,34 }
      v8 = a3 + 32;
      return *v8 + *((int *)a2 + 1);
    case 0:
      __asm { BTI             j; jumptable 0000000000067F24 case 2 }
      return sub_686DC(a2[1], a1, a3, 0);
    case 29:
      __asm { BTI             j; jumptable 0000000000067F24 case 31 }
      v8 = a3 + 29;
      return *v8 + *((int *)a2 + 1);
    case 30:
      __asm { BTI             j; jumptable 0000000000067F24 case 32 }
      v8 = a3 + 30;
      return *v8 + *((int *)a2 + 1);
    case 34:
      __asm { BTI             j; jumptable 0000000000067F24 case 36 }
      v8 = a3 + 33;
      return *v8 + *((int *)a2 + 1);
    default:
      __asm { BTI             j; jumptable 0000000000067F24 default case, cases 3-30,35 }
      if ( (unsigned int)v3 > 0x1C )
      {
        fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getRegister", "unsupported arm64 register");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      v8 = &a3[v3];
      return *v8 + *((int *)a2 + 1);
  }
}

//----- (0000000000067FEC) ----------------------------------------------------
__int64 __fastcall sub_67FEC(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  __int64 v12; // x8

  result = 0;
  switch ( *(_DWORD *)a4 )
  {
    case 1:
      goto LABEL_3;
    case 2:
    case 3:
      __asm { BTI             j; jumptable 0000000000068030 cases 2,3 }
      result = *(_QWORD *)(*(_QWORD *)(a4 + 8) + a3);
LABEL_3:
      __asm { BTI             j; jumptable 0000000000068030 case 1 }
      break;
    case 5:
      __asm { BTI             j; jumptable 0000000000068030 case 5 }
      v12 = *(_QWORD *)(a4 + 8);
      switch ( (int)v12 )
      {
        case -2:
        case 31:
          __asm { BTI             j; jumptable 000000000006807C cases 0,33 }
          result = a2[31];
          break;
        case -1:
        case 32:
          __asm { BTI             j; jumptable 000000000006807C cases 1,34 }
          result = a2[32];
          break;
        case 29:
          __asm { BTI             j; jumptable 000000000006807C case 31 }
          result = a2[29];
          break;
        case 30:
          __asm { BTI             j; jumptable 000000000006807C case 32 }
          result = a2[30];
          break;
        case 34:
          __asm { BTI             j; jumptable 000000000006807C case 36 }
          result = a2[33];
          break;
        default:
          __asm { BTI             j; jumptable 000000000006807C default case, cases 2-30,35 }
          if ( (unsigned int)v12 > 0x1C )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getRegister", "unsupported arm64 register");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          result = a2[(unsigned int)*(_QWORD *)(a4 + 8)];
          break;
      }
      break;
    case 6:
      __asm { BTI             j; jumptable 0000000000068030 case 6 }
      result = *(_QWORD *)sub_686DC(*(unsigned __int8 **)(a4 + 8), a1, a2, a3);
      break;
    case 7:
      __asm { BTI             j; jumptable 0000000000068030 case 7 }
      result = sub_686DC(*(unsigned __int8 **)(a4 + 8), a1, a2, a3);
      break;
    default:
      __asm { BTI             j; jumptable 0000000000068030 default case, case 4 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getSavedRegister",
        "unsupported restore location for register");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  return result;
}

//----- (00000000000681E8) ----------------------------------------------------
__int64 __fastcall sub_681E8(__int64 a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 a4, __int64 a5)
{
  unsigned __int8 *v5; // x21
  __int64 result; // x0
  int v13; // w10
  __int64 v14; // x8
  unsigned __int8 *v15; // x9
  unsigned __int8 *v16; // x11
  unsigned int v17; // w12
  unsigned int v18; // t1
  unsigned __int64 v19; // x13
  unsigned int v20; // w11
  __int64 v21; // x10

  v5 = *a2;
  switch ( a4 & 0xF )
  {
    case 0:
    case 4:
    case 0xC:
      __asm { BTI             j; jumptable 0000000000068228 cases 0,4,12 }
      result = *(_QWORD *)v5;
      *a2 = v5 + 8;
      break;
    case 1:
      __asm { BTI             j; jumptable 0000000000068228 case 1 }
      result = sub_6850C(a2, a3);
      break;
    case 2:
      __asm { BTI             j; jumptable 0000000000068228 case 2 }
      result = *(unsigned __int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 3:
      __asm { BTI             j; jumptable 0000000000068228 case 3 }
      result = *(unsigned int *)v5;
      *a2 = v5 + 4;
      break;
    case 9:
      __asm { BTI             j; jumptable 0000000000068228 case 9 }
      v13 = 0;
      v14 = 0;
      v15 = *a2;
      v16 = *a2;
      do
      {
        if ( v16 == a3 )
        {
          fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
        }
        v18 = *v16++;
        v17 = v18;
        ++v15;
        v19 = (unsigned __int64)(v18 & 0x7F) << v13;
        v13 += 7;
        v14 |= v19;
      }
      while ( (v18 & 0x80) != 0 );
      v20 = v13 - 7;
      v21 = -1LL << v13;
      *a2 = v15;
      if ( ((v20 < 0x39) & (v17 >> 6)) == 0 )
        v21 = 0;
      result = v14 | v21;
      break;
    case 0xA:
      __asm { BTI             j; jumptable 0000000000068228 case 10 }
      result = *(__int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 0xB:
      __asm { BTI             j; jumptable 0000000000068228 case 11 }
      result = *(int *)v5;
      *a2 = v5 + 4;
      break;
    default:
      __asm { BTI             j; jumptable 0000000000068228 default case, cases 5-8 }
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  switch ( (a4 >> 4) & 7 )
  {
    case 0:
      goto LABEL_16;
    case 1:
      __asm { BTI             j; jumptable 0000000000068324 case 1 }
      result += (__int64)v5;
LABEL_16:
      __asm { BTI             j; jumptable 0000000000068324 case 0 }
      if ( (a4 & 0x80) == 0 )
        return result;
      return *(_QWORD *)result;
    case 2:
      __asm { BTI             j; jumptable 0000000000068324 case 2 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_textrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 3:
      __asm { BTI             j; jumptable 0000000000068324 case 3 }
      if ( !a5 )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "getEncodedP",
          "DW_EH_PE_datarel is invalid with a datarelBase of 0");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      result += a5;
      if ( (a4 & 0x80) != 0 )
        return *(_QWORD *)result;
      return result;
    case 4:
      __asm { BTI             j; jumptable 0000000000068324 case 4 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_funcrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 5:
      __asm { BTI             j; jumptable 0000000000068324 case 5 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_aligned pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    default:
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
}

//----- (000000000006850C) ----------------------------------------------------
__int64 __fastcall sub_6850C(unsigned __int8 **a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // x9
  unsigned __int8 *v4; // x10
  __int64 result; // x0
  int v6; // w11
  int v7; // w11
  int v8; // w11
  int v9; // w11
  int v10; // w11
  int v11; // w11
  int v12; // w11
  int v13; // w11
  __int64 v14; // x11
  unsigned __int8 *v15; // x10

  v2 = *a1;
  if ( *a1 == a2 )
    goto LABEL_25;
  v4 = v2 + 1;
  result = *v2 & 0x7F;
  if ( (*v2 & 0x80) == 0 )
  {
LABEL_3:
    *a1 = v4;
    return result;
  }
  if ( v4 == a2 )
    goto LABEL_25;
  v6 = (char)v2[1];
  result |= (unsigned __int64)(v6 & 0x7F) << 7;
  v4 = v2 + 2;
  if ( (v6 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v7 = (char)v2[2];
  result |= (unsigned __int64)(v7 & 0x7F) << 14;
  v4 = v2 + 3;
  if ( (v7 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v8 = (char)v2[3];
  result |= (unsigned __int64)(v8 & 0x7F) << 21;
  v4 = v2 + 4;
  if ( (v8 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v9 = (char)v2[4];
  result |= (unsigned __int64)(v9 & 0x7F) << 28;
  v4 = v2 + 5;
  if ( (v9 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v10 = (char)v2[5];
  result |= (unsigned __int64)(v10 & 0x7F) << 35;
  v4 = v2 + 6;
  if ( (v10 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v11 = (char)v2[6];
  result |= (unsigned __int64)(v11 & 0x7F) << 42;
  v4 = v2 + 7;
  if ( (v11 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v12 = (char)v2[7];
  result |= (unsigned __int64)(v12 & 0x7F) << 49;
  v4 = v2 + 8;
  if ( (v12 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  v13 = (char)v2[8];
  result |= (unsigned __int64)(v13 & 0x7F) << 56;
  v4 = v2 + 9;
  if ( (v13 & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
  {
LABEL_25:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "truncated uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v14 = *v4;
  if ( (v14 & 0x7E) != 0 )
  {
LABEL_26:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "malformed uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v15 = v2 + 10;
  if ( (v14 & 0x80) != 0 )
  {
    if ( v15 == a2 )
      goto LABEL_25;
    goto LABEL_26;
  }
  result |= v14 << 63;
  *a1 = v15;
  return result;
}

//----- (00000000000686DC) ----------------------------------------------------
__int64 __fastcall sub_686DC(unsigned __int8 *a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v6; // x0
  unsigned __int8 *v7; // x9
  unsigned __int8 *v8; // x20
  __int64 *v9; // x27
  __int64 *v14; // x8
  __int64 v15; // x8
  unsigned __int8 *v16; // x8
  int v17; // w10
  int v18; // w12
  __int64 v19; // x9
  unsigned int v20; // w11
  unsigned __int8 *v21; // x13
  unsigned int v22; // w14
  unsigned int v23; // t1
  unsigned __int64 v24; // x15
  unsigned int v25; // w13
  __int64 v26; // x12
  int v27; // w10
  __int64 *v28; // x8
  __int64 v29; // x9
  unsigned int v30; // w0
  unsigned __int8 *v31; // x9
  int v32; // w10
  __int64 v33; // x8
  unsigned __int8 *v34; // x11
  unsigned int v35; // w12
  unsigned int v36; // t1
  unsigned __int64 v37; // x13
  unsigned int v38; // w11
  __int64 v39; // x10
  __int64 *v40; // x9
  __int64 *v41; // x8
  __int64 v42; // x9
  __int64 *v43; // x8
  int v44; // w10
  __int64 v45; // x9
  unsigned __int8 *v46; // x11
  unsigned int v47; // w12
  unsigned int v48; // t1
  unsigned __int64 v49; // x13
  unsigned int v50; // w11
  __int64 v51; // x10
  _QWORD *v52; // x8
  __int64 v53; // x8
  unsigned __int8 *v54; // x8
  __int64 v55; // x9
  _QWORD *v56; // t1
  unsigned int v57; // w0
  __int64 v59; // [xsp+10h] [xbp-320h] BYREF
  unsigned __int8 *v60; // [xsp+328h] [xbp-8h] BYREF

  v60 = a1;
  v6 = sub_6850C(&v60, a1 + 20);
  v7 = v60;
  v59 = a4;
  v8 = &v60[v6];
  if ( v7 < &v7[v6] )
  {
    v9 = &v59;
    do
    {
      v16 = v7 + 1;
      v60 = v7 + 1;
      v17 = *v7;
      switch ( *v7 )
      {
        case 3u:
        case 0xEu:
        case 0xFu:
          __asm { BTI             j; jumptable 00000000000687A4 cases 3,14,15 }
          v16 = v7 + 9;
          v29 = *(_QWORD *)(v7 + 1);
          goto LABEL_50;
        case 6u:
          __asm { BTI             j; jumptable 00000000000687A4 case 6 }
          v43 = (__int64 *)*v9;
LABEL_36:
          __asm { BTI             j; jumptable 0000000000068D24 case 8 }
          *v9 = *v43;
          goto LABEL_6;
        case 8u:
          __asm { BTI             j; jumptable 00000000000687A4 case 8 }
          v16 = v7 + 2;
          v29 = v7[1];
          goto LABEL_50;
        case 9u:
          __asm { BTI             j; jumptable 00000000000687A4 case 9 }
          v16 = v7 + 2;
          v29 = (char)v7[1];
          goto LABEL_50;
        case 0xAu:
          __asm { BTI             j; jumptable 00000000000687A4 case 10 }
          v16 = v7 + 3;
          v29 = *(unsigned __int16 *)(v7 + 1);
          goto LABEL_50;
        case 0xBu:
          __asm { BTI             j; jumptable 00000000000687A4 case 11 }
          v16 = v7 + 3;
          v29 = *(__int16 *)(v7 + 1);
          goto LABEL_50;
        case 0xCu:
          __asm { BTI             j; jumptable 00000000000687A4 case 12 }
          v16 = v7 + 5;
          v29 = *(unsigned int *)(v7 + 1);
          goto LABEL_50;
        case 0xDu:
          __asm { BTI             j; jumptable 00000000000687A4 case 13 }
          v16 = v7 + 5;
          v29 = *(int *)(v7 + 1);
          goto LABEL_50;
        case 0x10u:
          __asm { BTI             j; jumptable 00000000000687A4 case 16 }
          v9[1] = sub_6850C(&v60, v8);
          ++v9;
          goto LABEL_6;
        case 0x11u:
          __asm { BTI             j; jumptable 00000000000687A4 case 17 }
          v44 = 0;
          v45 = 0;
          v46 = v16;
          do
          {
            if ( v46 == v8 )
            {
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "getSLEB128",
                "truncated sleb128 expression");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
            v48 = *v46++;
            v47 = v48;
            ++v16;
            v49 = (unsigned __int64)(v48 & 0x7F) << v44;
            v44 += 7;
            v45 |= v49;
          }
          while ( (v48 & 0x80) != 0 );
          v50 = v44 - 7;
          v51 = -1LL << v44;
          if ( ((v50 < 0x39) & (v47 >> 6)) == 0 )
            v51 = 0;
          v29 = v45 | v51;
LABEL_50:
          v60 = v16;
          v9[1] = v29;
          ++v9;
          goto LABEL_6;
        case 0x12u:
          __asm { BTI             j; jumptable 00000000000687A4 case 18 }
          v15 = *v9;
          break;
        case 0x13u:
          __asm { BTI             j; jumptable 00000000000687A4 case 19 }
          --v9;
          goto LABEL_6;
        case 0x14u:
          __asm { BTI             j; jumptable 00000000000687A4 case 20 }
          v15 = *(v9 - 1);
          break;
        case 0x15u:
          __asm { BTI             j; jumptable 00000000000687A4 case 21 }
          v14 = &v9[-v7[1]];
          v60 = v7 + 2;
          goto LABEL_4;
        case 0x16u:
          __asm { BTI             j; jumptable 00000000000687A4 case 22 }
          *(int8x16_t *)(v9 - 1) = vextq_s8(*(int8x16_t *)(v9 - 1), *(int8x16_t *)(v9 - 1), 8u);
          goto LABEL_6;
        case 0x17u:
          __asm { BTI             j; jumptable 00000000000687A4 case 23 }
          v52 = (_QWORD *)*v9;
          *(_OWORD *)(v9 - 1) = *((_OWORD *)v9 - 1);
          *(v9 - 2) = (__int64)v52;
          goto LABEL_6;
        case 0x18u:
          __asm { BTI             j; jumptable 00000000000687A4 case 24 }
          *(v9 - 1) = *(_QWORD *)*v9;
          --v9;
          goto LABEL_6;
        case 0x19u:
          __asm { BTI             j; jumptable 00000000000687A4 case 25 }
          v53 = *v9;
          if ( *v9 < 0 )
            goto LABEL_65;
          goto LABEL_6;
        case 0x1Au:
          __asm { BTI             j; jumptable 00000000000687A4 case 26 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) & *v9;
          goto LABEL_81;
        case 0x1Bu:
          __asm { BTI             j; jumptable 00000000000687A4 case 27 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) / *v9;
          goto LABEL_81;
        case 0x1Cu:
          __asm { BTI             j; jumptable 00000000000687A4 case 28 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) - *v9;
          goto LABEL_81;
        case 0x1Du:
          __asm { BTI             j; jumptable 00000000000687A4 case 29 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) % *v9;
          goto LABEL_81;
        case 0x1Eu:
          __asm { BTI             j; jumptable 00000000000687A4 case 30 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) * *v9;
          goto LABEL_81;
        case 0x1Fu:
          __asm { BTI             j; jumptable 00000000000687A4 case 31 }
          v53 = *v9;
LABEL_65:
          *v9 = -v53;
          goto LABEL_6;
        case 0x20u:
          __asm { BTI             j; jumptable 00000000000687A4 case 32 }
          *v9 = ~*v9;
          goto LABEL_6;
        case 0x21u:
          __asm { BTI             j; jumptable 00000000000687A4 case 33 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) | *v9;
          goto LABEL_81;
        case 0x22u:
          __asm { BTI             j; jumptable 00000000000687A4 case 34 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) + *v9;
          goto LABEL_81;
        case 0x23u:
          __asm { BTI             j; jumptable 00000000000687A4 case 35 }
          *v9 += sub_6850C(&v60, v8);
          goto LABEL_6;
        case 0x24u:
          __asm { BTI             j; jumptable 00000000000687A4 case 36 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) << *v9;
          goto LABEL_81;
        case 0x25u:
          __asm { BTI             j; jumptable 00000000000687A4 case 37 }
          v41 = v9 - 1;
          v42 = (unsigned __int64)*(v9 - 1) >> *v9;
          goto LABEL_81;
        case 0x26u:
          __asm { BTI             j; jumptable 00000000000687A4 case 38 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) >> *v9;
          goto LABEL_81;
        case 0x27u:
          __asm { BTI             j; jumptable 00000000000687A4 case 39 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) ^ *v9;
          goto LABEL_81;
        case 0x28u:
          __asm { BTI             j; jumptable 00000000000687A4 case 40 }
          v54 = v7 + 3;
          v55 = *(__int16 *)(v7 + 1);
          v56 = (_QWORD *)*v9--;
          v60 = v54;
          if ( v56 )
            v60 = &v54[v55];
          goto LABEL_6;
        case 0x29u:
          __asm { BTI             j; jumptable 00000000000687A4 case 41 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) == *v9;
          goto LABEL_81;
        case 0x2Au:
          __asm { BTI             j; jumptable 00000000000687A4 case 42 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) >= (unsigned __int64)*v9;
          goto LABEL_81;
        case 0x2Bu:
          __asm { BTI             j; jumptable 00000000000687A4 case 43 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) > (unsigned __int64)*v9;
          goto LABEL_81;
        case 0x2Cu:
          __asm { BTI             j; jumptable 00000000000687A4 case 44 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) <= (unsigned __int64)*v9;
          goto LABEL_81;
        case 0x2Du:
          __asm { BTI             j; jumptable 00000000000687A4 case 45 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) < (unsigned __int64)*v9;
          goto LABEL_81;
        case 0x2Eu:
          __asm { BTI             j; jumptable 00000000000687A4 case 46 }
          v41 = v9 - 1;
          v42 = *(v9 - 1) != *v9;
LABEL_81:
          v9 = v41;
          *v41 = v42;
          goto LABEL_6;
        case 0x2Fu:
          __asm { BTI             j; jumptable 00000000000687A4 case 47 }
          v60 = &v7[*(__int16 *)(v7 + 1) + 3];
          goto LABEL_6;
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
          __asm { BTI             j; jumptable 00000000000687A4 cases 48-79 }
          v15 = (unsigned int)(v17 - 48);
          break;
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
          __asm { BTI             j; jumptable 00000000000687A4 cases 80-111 }
          v14 = a3 + 31;
          if ( v17 != 111 )
          {
            v14 = a3 + 30;
            if ( v17 != 110 )
            {
              v14 = a3 + 29;
              if ( v17 != 109 )
                v14 = &a3[v17 - 80];
            }
          }
          goto LABEL_4;
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
          __asm { BTI             j; jumptable 00000000000687A4 cases 112-143 }
          v18 = 0;
          v19 = 0;
          v20 = v17 - 112;
          v21 = v16;
          do
          {
            if ( v21 == v8 )
            {
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "getSLEB128",
                "truncated sleb128 expression");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
            v23 = *v21++;
            v22 = v23;
            ++v16;
            v24 = (unsigned __int64)(v23 & 0x7F) << v18;
            v18 += 7;
            v19 |= v24;
          }
          while ( (v23 & 0x80) != 0 );
          v25 = v18 - 7;
          v26 = -1LL << v18;
          v27 = v17 - 110;
          v60 = v16;
          if ( ((v25 < 0x39) & (v22 >> 6)) == 0 )
            v26 = 0;
          v28 = a3 + 32;
          switch ( v27 )
          {
            case 0:
            case 33:
              __asm { BTI             j; jumptable 0000000000068830 cases 110,143 }
              v28 = a3 + 31;
              break;
            case 1:
            case 34:
              break;
            case 31:
              __asm { BTI             j; jumptable 0000000000068830 case 141 }
              v28 = a3 + 29;
              break;
            case 32:
              __asm { BTI             j; jumptable 0000000000068830 case 142 }
              v28 = a3 + 30;
              break;
            case 36:
              __asm { BTI             j; jumptable 0000000000068830 case 146 }
              v28 = a3 + 33;
              break;
            default:
              __asm { BTI             j; jumptable 0000000000068830 default case, cases 112-140,145 }
              if ( v20 > 0x1C )
              {
                fprintf(
                  (FILE *)((char *)&_sF + 304),
                  "libunwind: %s - %s\n",
                  "getRegister",
                  "unsupported arm64 register");
                fflush((FILE *)((char *)&_sF + 304));
                abort();
              }
              v28 = &a3[v20];
              break;
          }
          __asm { BTI             j; jumptable 0000000000068830 cases 111,144 }
          v15 = *v28 + (v19 | v26);
          break;
        case 0x90u:
          __asm { BTI             j; jumptable 00000000000687A4 case 144 }
          v57 = sub_6850C(&v60, v8);
          v14 = a3 + 32;
          switch ( v57 )
          {
            case 0xFFFFFFFE:
            case 0x1Fu:
              __asm { BTI             j; jumptable 0000000000068D84 cases 0,33 }
              v14 = a3 + 31;
              break;
            case 0xFFFFFFFF:
            case 0x20u:
              break;
            case 0x1Du:
              __asm { BTI             j; jumptable 0000000000068D84 case 31 }
              v14 = a3 + 29;
              break;
            case 0x1Eu:
              __asm { BTI             j; jumptable 0000000000068D84 case 32 }
              v14 = a3 + 30;
              break;
            case 0x22u:
              __asm { BTI             j; jumptable 0000000000068D84 case 36 }
              v14 = a3 + 33;
              break;
            default:
              __asm { BTI             j; jumptable 0000000000068D84 default case, cases 2-30,35 }
              if ( v57 > 0x1C )
              {
                fprintf(
                  (FILE *)((char *)&_sF + 304),
                  "libunwind: %s - %s\n",
                  "getRegister",
                  "unsupported arm64 register");
                fflush((FILE *)((char *)&_sF + 304));
                abort();
              }
              v14 = &a3[v57];
              break;
          }
LABEL_4:
          __asm { BTI             j; jumptable 0000000000068D84 cases 1,34 }
          v15 = *v14;
          break;
        case 0x91u:
          __asm { BTI             j; jumptable 00000000000687A4 case 145 }
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: %s - %s\n",
            "evaluateExpression",
            "DW_OP_fbreg not implemented");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
        case 0x92u:
          __asm { BTI             j; jumptable 00000000000687A4 case 146 }
          v30 = sub_6850C(&v60, v8);
          v31 = v60;
          v32 = 0;
          v33 = 0;
          v34 = v60;
          do
          {
            if ( v34 == v8 )
            {
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "getSLEB128",
                "truncated sleb128 expression");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
            v36 = *v34++;
            v35 = v36;
            ++v31;
            v37 = (unsigned __int64)(v36 & 0x7F) << v32;
            v32 += 7;
            v33 |= v37;
          }
          while ( (v36 & 0x80) != 0 );
          v38 = v32 - 7;
          v39 = -1LL << v32;
          v60 = v31;
          if ( ((v38 < 0x39) & (v35 >> 6)) == 0 )
            v39 = 0;
          v40 = a3 + 32;
          switch ( v30 )
          {
            case 0xFFFFFFFE:
            case 0x1Fu:
              __asm { BTI             j; jumptable 0000000000068954 cases 0,33 }
              v40 = a3 + 31;
              break;
            case 0xFFFFFFFF:
            case 0x20u:
              break;
            case 0x1Du:
              __asm { BTI             j; jumptable 0000000000068954 case 31 }
              v40 = a3 + 29;
              break;
            case 0x1Eu:
              __asm { BTI             j; jumptable 0000000000068954 case 32 }
              v40 = a3 + 30;
              break;
            case 0x22u:
              __asm { BTI             j; jumptable 0000000000068954 case 36 }
              v40 = a3 + 33;
              break;
            default:
              __asm { BTI             j; jumptable 0000000000068954 default case, cases 2-30,35 }
              if ( v30 > 0x1C )
              {
                fprintf(
                  (FILE *)((char *)&_sF + 304),
                  "libunwind: %s - %s\n",
                  "getRegister",
                  "unsupported arm64 register");
                fflush((FILE *)((char *)&_sF + 304));
                abort();
              }
              v40 = &a3[v30];
              break;
          }
          __asm { BTI             j; jumptable 0000000000068954 cases 1,34 }
          v15 = *v40 + (v33 | v39);
          break;
        case 0x93u:
          __asm { BTI             j; jumptable 00000000000687A4 case 147 }
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: %s - %s\n",
            "evaluateExpression",
            "DW_OP_piece not implemented");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
        case 0x94u:
          __asm { BTI             j; jumptable 00000000000687A4 case 148 }
          v60 = v7 + 2;
          v43 = (__int64 *)*v9;
          switch ( v7[1] )
          {
            case 1u:
              __asm { BTI             j; jumptable 0000000000068D24 case 1 }
              *v9 = *(unsigned __int8 *)v43;
              goto LABEL_6;
            case 2u:
              __asm { BTI             j; jumptable 0000000000068D24 case 2 }
              *v9 = *(unsigned __int16 *)v43;
              goto LABEL_6;
            case 4u:
              __asm { BTI             j; jumptable 0000000000068D24 case 4 }
              *v9 = *(unsigned int *)v43;
              goto LABEL_6;
            case 8u:
              goto LABEL_36;
            default:
              __asm { BTI             j; jumptable 0000000000068D24 default case, cases 3,5-7 }
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "evaluateExpression",
                "DW_OP_deref_size with bad size");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
          }
        default:
          __asm { BTI             j; jumptable 00000000000687A4 default case, cases 4,5,7 }
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: %s - %s\n",
            "evaluateExpression",
            "DWARF opcode not implemented");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
      }
      v9[1] = v15;
      ++v9;
LABEL_6:
      v7 = v60;
    }
    while ( v60 < v8 );
    return *v9;
  }
  return a4;
}

//----- (00000000000690A0) ----------------------------------------------------
__int64 __fastcall sub_690A0(__int64 a1, unsigned __int64 a2, __int64 *a3, unsigned int a4)
{
  unsigned __int8 *v8; // x2
  char v9; // w24
  __int64 v10; // x23
  _QWORD *v11; // x8
  unsigned __int8 *v12; // x23
  char v13; // w8
  __int64 result; // x0
  __int64 v15; // x25
  __int64 v16; // d0
  __int64 v17; // x9
  __int64 v18; // x22
  __int64 v19; // x8
  int v20; // w9
  __int64 v21; // x23
  char v22; // w8
  __int64 v23; // x24
  char *v24; // x8
  void *v25; // x19
  size_t v26; // x21
  signed __int64 v27; // x28
  signed __int64 v28; // x27
  char *v29; // x20
  __int64 v30; // [xsp+0h] [xbp-6A0h]
  _BYTE v31[32]; // [xsp+18h] [xbp-688h] BYREF
  __int64 v32; // [xsp+38h] [xbp-668h]
  __int64 v33; // [xsp+50h] [xbp-650h] BYREF
  __int64 v34; // [xsp+58h] [xbp-648h]
  __int64 v35; // [xsp+68h] [xbp-638h]
  __int128 v36; // [xsp+70h] [xbp-630h]
  _BYTE s[16]; // [xsp+80h] [xbp-620h] BYREF
  unsigned int v38; // [xsp+90h] [xbp-610h]

  if ( a4
    && (sub_69528(*(_QWORD *)(a1 + 8), a2, (unsigned __int8 *)a3[2], a3[3], (unsigned __int8 *)(a3[2] + a4), &v33, v31)
      & 1) != 0
    || (v8 = (unsigned __int8 *)a3[4]) != 0
    && (sub_696F0(*(_QWORD *)(a1 + 8), a2, v8, *((_DWORD *)a3 + 10), &v33, (__int64)v31) & 1) != 0 )
  {
    v9 = 0;
    goto LABEL_22;
  }
  v10 = *a3;
  pthread_rwlock_rdlock(&stru_78D64);
  v11 = off_78930;
  if ( off_78930 >= off_78938 )
  {
LABEL_20:
    pthread_rwlock_unlock(&stru_78D64);
    goto LABEL_21;
  }
  if ( v10 == -1 )
  {
    while ( v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= (_QWORD *)off_78938 )
        goto LABEL_20;
    }
  }
  else
  {
    while ( *v11 != v10 || v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= (_QWORD *)off_78938 )
        goto LABEL_20;
    }
  }
  v12 = (unsigned __int8 *)v11[3];
  pthread_rwlock_unlock(&stru_78D64);
  if ( !v12 || (sub_69528(*(_QWORD *)(a1 + 8), a2, (unsigned __int8 *)a3[2], a3[3], v12, &v33, v31) & 1) == 0 )
  {
LABEL_21:
    v13 = sub_69528(*(_QWORD *)(a1 + 8), a2, (unsigned __int8 *)a3[2], a3[3], 0, &v33, v31);
    v9 = 0;
    result = 0;
    if ( (v13 & 1) == 0 )
      return result;
    goto LABEL_22;
  }
  v9 = 1;
LABEL_22:
  v15 = *a3;
  memset(s, 0, 0x618u);
  if ( (sub_673DC(*(_QWORD *)(a1 + 8), &v33, (__int64)v31, a2, 4, s) & 1) == 0 )
    return 0;
  v16 = v36;
  v17 = v32;
  v18 = v35;
  result = 1;
  *(_OWORD *)(a1 + 552) = v36;
  v19 = v38;
  *(_QWORD *)(a1 + 568) = v17;
  v21 = v33;
  v20 = v34;
  *(_QWORD *)(a1 + 576) = v19;
  *(_QWORD *)(a1 + 544) = v18;
  *(_QWORD *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 592) = 50331648;
  if ( a4 )
    v22 = 1;
  else
    v22 = v9;
  *(_QWORD *)(a1 + 600) = v21;
  *(_DWORD *)(a1 + 596) = v20;
  *(_QWORD *)(a1 + 608) = v15;
  if ( (v22 & 1) == 0 && !a3[4] )
  {
    v23 = *a3;
    v30 = v16;
    pthread_rwlock_wrlock(&stru_78D64);
    v24 = (char *)off_78938;
    if ( off_78938 >= off_78940 )
    {
      v25 = off_78930;
      v26 = off_78940 - off_78930;
      v27 = (off_78940 - off_78930) >> 5;
      v28 = (off_78940 - off_78930) >> 3;
      v29 = (char *)malloc(4 * (off_78940 - off_78930));
      memcpy(v29, v25, v26);
      if ( v25 != &unk_78DA0 )
        free(v25);
      v24 = &v29[32 * v27];
      off_78940 = &v29[32 * v28];
      off_78930 = v29;
    }
    *(_QWORD *)v24 = v23;
    *((_QWORD *)v24 + 1) = v18;
    *((_QWORD *)v24 + 2) = v30;
    *((_QWORD *)v24 + 3) = v21;
    off_78938 = v24 + 32;
    pthread_rwlock_unlock(&stru_78D64);
    return 1;
  }
  return result;
}
// 78930: using guessed type _UNKNOWN *off_78930;
// 78938: using guessed type _UNKNOWN *off_78938;
// 78940: using guessed type _UNKNOWN *off_78940;
// 78D64: using guessed type pthread_rwlock_t stru_78D64;

//----- (0000000000069388) ----------------------------------------------------
__int64 __fastcall sub_69388(unsigned __int64 *a1, __int64 a2, __int64 *a3)
{
  int v3; // w25
  unsigned __int64 v4; // x8
  unsigned __int64 v6; // x26
  __int64 result; // x0
  unsigned __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x11
  unsigned __int64 v12; // x12
  unsigned __int64 *v13; // x8
  unsigned int v14; // w27
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x8
  __int64 v17; // x10
  unsigned __int8 *v18; // x24
  unsigned __int8 *v19; // x23
  int v20; // w2
  __int64 v21; // x20
  unsigned __int8 v22; // w3
  __int64 v23; // x0
  int v24; // w21
  __int64 v25; // x22
  __int64 v26; // x8
  unsigned __int8 *v27; // [xsp+8h] [xbp-8h] BYREF

  v3 = *((unsigned __int16 *)a1 + 12);
  if ( !*((_WORD *)a1 + 12) )
    return 0;
  v4 = a3[2];
  v6 = *a1;
  if ( v4 < *a1 )
    return 0;
  v9 = a1[2];
  v10 = *((unsigned __int16 *)a1 + 12);
  while ( 1 )
  {
    if ( *(_DWORD *)v9 == 1 )
    {
      v11 = *(_QWORD *)(v9 + 16) + v6;
      if ( v4 >= v11 )
      {
        v12 = *(_QWORD *)(v9 + 40);
        if ( v4 < v12 + v11 )
          break;
      }
    }
    v9 += 56LL;
    if ( !--v10 )
      return 0;
  }
  v13 = (unsigned __int64 *)a3[1];
  v14 = v3 - 1;
  *v13 = v11;
  v13[1] = v12;
  while ( 1 )
  {
    v15 = a1[2];
    if ( *(_DWORD *)(v15 + 56LL * v14) == 1685382480 )
      break;
LABEL_11:
    --v3;
    --v14;
    if ( !(_WORD)v3 )
      return 0;
  }
  v16 = v15 + 56LL * v14;
  v17 = a3[1];
  v18 = *(unsigned __int8 **)(v16 + 40);
  v19 = (unsigned __int8 *)(*(_QWORD *)(v16 + 16) + v6);
  *(_QWORD *)(v17 + 32) = v19;
  *(_QWORD *)(v17 + 40) = v18;
  v20 = *v19;
  if ( v20 != 1 )
  {
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: unsupported .eh_frame_hdr version: %u at %lx\n", v20, v19);
    goto LABEL_11;
  }
  v21 = *a3;
  v22 = v19[1];
  v23 = *a3;
  v24 = v19[2];
  v27 = v19 + 4;
  v25 = sub_681E8(v23, &v27, v18, v22, (__int64)v19);
  if ( v24 != 255 )
    sub_681E8(v21, &v27, v18, v24, (__int64)v19);
  v26 = a3[1];
  result = 1;
  *(_QWORD *)(v26 + 16) = v25;
  *(_QWORD *)(v26 + 24) = -1;
  return result;
}

//----- (0000000000069528) ----------------------------------------------------
__int64 __fastcall sub_69528(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int8 *a3,
        __int64 a4,
        unsigned __int8 *a5,
        _QWORD *a6,
        _BYTE *a7)
{
  unsigned __int8 *v7; // x22
  unsigned __int64 v8; // x27
  unsigned __int8 *v14; // x26
  unsigned int *v15; // x8
  __int64 v16; // x9
  __int64 v17; // x10
  unsigned int *v18; // x1
  unsigned __int8 v19; // w3
  unsigned __int64 v20; // x25
  __int64 v21; // x0
  unsigned __int64 v22; // x28
  int v23; // w8
  __int64 v24; // x0
  unsigned __int8 *v25; // x24
  int v26; // w8
  unsigned __int8 *v27; // x23
  unsigned __int8 v28; // w3
  __int64 result; // x0
  unsigned __int8 *i; // [xsp+8h] [xbp-8h] BYREF

  if ( a5 )
    v7 = a5;
  else
    v7 = a3;
  if ( a4 == -1 )
    v8 = -1;
  else
    v8 = (unsigned __int64)&a3[a4];
  for ( i = v7; (unsigned __int64)v7 < v8; i = v7 )
  {
    v14 = v7;
    v15 = (unsigned int *)(v7 + 4);
    v16 = *(unsigned int *)v7;
    i = v7 + 4;
    if ( (_DWORD)v16 == -1 )
    {
      v15 = (unsigned int *)(v7 + 12);
      v16 = *(_QWORD *)(v7 + 4);
      i = v7 + 12;
    }
    if ( !v16 )
      break;
    v17 = *v15;
    v7 = (unsigned __int8 *)v15 + v16;
    if ( (_DWORD)v17 )
    {
      v18 = (unsigned int *)((char *)v15 - v17);
      if ( (char *)v15 - v17 >= (char *)a3 && (unsigned __int64)v18 < v8 && !sub_6648C(a1, v18, (__int64)a7) )
      {
        v19 = a7[24];
        i += 4;
        v20 = sub_681E8(a1, &i, v7, v19, 0);
        v21 = sub_681E8(a1, &i, v7, a7[24] & 0xF, 0);
        if ( v20 < a2 )
        {
          v22 = v21 + v20;
          if ( v21 + v20 >= a2 )
          {
            v23 = (unsigned __int8)a7[49];
            a6[5] = 0;
            if ( v23 )
            {
              v24 = sub_6850C(&i, v7);
              v25 = i;
              v26 = (unsigned __int8)a7[25];
              v27 = &i[v24];
              if ( v26 != 255 )
              {
                if ( sub_681E8(a1, &i, v7, v26 & 0xF, 0) )
                {
                  v28 = a7[25];
                  i = v25;
                  a6[5] = sub_681E8(a1, &i, v7, v28, 0);
                }
              }
            }
            else
            {
              v27 = i;
            }
            a6[2] = v27;
            a6[3] = v20;
            result = 1;
            a6[4] = v22;
            *a6 = v14;
            a6[1] = v7 - v14;
            return result;
          }
        }
      }
    }
  }
  return 0;
}

//----- (00000000000696F0) ----------------------------------------------------
__int64 __fastcall sub_696F0(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3, int a4, _QWORD *a5, __int64 a6)
{
  int v7; // w2
  unsigned __int8 v8; // w8
  int v9; // w26
  unsigned __int8 *v10; // x25
  __int64 result; // x0
  unsigned __int64 v15; // x26
  unsigned __int8 *v16; // x28
  __int64 v17; // x27
  __int64 v18; // x21
  unsigned __int8 *v19; // x19
  unsigned __int64 v20; // x0
  unsigned int *v21; // x0
  _QWORD *v22; // [xsp+10h] [xbp-20h]
  unsigned __int8 v23; // [xsp+1Ch] [xbp-14h]
  unsigned __int8 *v25; // [xsp+28h] [xbp-8h] BYREF

  v7 = *a3;
  if ( v7 == 1 )
  {
    v8 = a3[1];
    v9 = a3[2];
    v10 = &a3[a4];
    v25 = a3 + 4;
    v23 = a3[3];
    sub_681E8(a1, &v25, v10, v8, (__int64)a3);
    if ( v9 != 255 )
    {
      result = sub_681E8(a1, &v25, v10, v9, (__int64)a3);
      if ( !result )
        return result;
      v15 = result;
      v16 = v25;
      v22 = a5;
      v17 = sub_698BC(v23);
      v18 = 0;
      while ( v15 > 1 )
      {
        v19 = &v16[((v15 >> 1) + v18) * v17];
        v25 = v19;
        v20 = sub_681E8(a1, &v25, v10, v23, (__int64)a3);
        if ( v20 >= a2 )
        {
          v15 >>= 1;
        }
        else
        {
          v18 += v15 >> 1;
          v15 -= v15 >> 1;
        }
        if ( v20 == a2 )
          goto LABEL_15;
      }
      v19 = &v16[v18 * v17];
LABEL_15:
      v25 = v19;
      sub_681E8(a1, &v25, v10, v23, (__int64)a3);
      v21 = (unsigned int *)sub_681E8(a1, &v25, v10, v23, (__int64)a3);
      if ( !sub_662FC(a1, v21, v22, a6, 0) && v22[3] <= a2 && v22[4] > a2 )
        return 1;
    }
  }
  else
  {
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: unsupported .eh_frame_hdr version: %u at %lx\n", v7, a3);
  }
  return 0;
}

//----- (00000000000698BC) ----------------------------------------------------
__int64 __fastcall sub_698BC(char a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = (a1 & 0xF) - 1;
  result = 4;
  switch ( v1 )
  {
    case 0:
    case 8:
      __asm { BTI             j; jumptable 00000000000698F4 cases 1,9 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Can't binary search on variable length encoded data.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 1:
    case 9:
      goto LABEL_3;
    case 2:
    case 10:
      __asm { BTI             j; jumptable 00000000000698F4 cases 3,11 }
      result = 8;
LABEL_3:
      __asm { BTI             j; jumptable 00000000000698F4 cases 2,10 }
      break;
    case 3:
    case 11:
      __asm { BTI             j; jumptable 00000000000698F4 cases 4,12 }
      result = 16;
      break;
    default:
      __asm { BTI             j; jumptable 00000000000698F4 default case, cases 5-8 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Unknown DWARF encoding for search table.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  return result;
}

//----- (00000000000699A4) ----------------------------------------------------
const char *__fastcall sub_699A4(int a1)
{
  if ( (unsigned int)(a1 + 2) > 0x61 )
    return "unknown register";
  else
    return (char *)dword_23E2C + dword_23E2C[a1 + 2];
}
// 23E2C: using guessed type int dword_23E2C[98];

//----- (00000000000699D4) ----------------------------------------------------
__int64 __fastcall sub_699D4(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000069A64) ----------------------------------------------------
__int64 __usercall sub_69A64@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        __int64 a5@<X4>,
        __int64 a6@<X5>,
        __int64 a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        double a10@<D0>,
        double a11@<D1>,
        double a12@<D2>,
        double a13@<D3>,
        double a14@<D4>,
        double a15@<D5>,
        double a16@<D6>,
        double a17@<D7>,
        __int64 a18)
{
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x11
  __int64 v21; // x12
  __int64 v22; // x13
  __int64 v23; // x14
  __int64 v24; // x15
  __int64 v25; // x16
  __int64 v26; // x17
  __int64 v27; // x18
  __int64 v28; // x19
  __int64 v29; // x20
  __int64 v30; // x21
  __int64 v31; // x22
  __int64 v32; // x23
  __int64 v33; // x24
  __int64 v34; // x25
  __int64 v35; // x26
  __int64 v36; // x27
  __int64 v37; // x28
  __int64 v38; // x29
  __int64 v39; // x30
  __int64 v40; // d8
  __int64 v41; // d9
  __int64 v42; // d10
  __int64 v43; // d11
  __int64 v44; // d12
  __int64 v45; // d13
  __int64 v46; // d14
  __int64 v47; // d15
  __int64 v48; // d16
  __int64 v49; // d17
  __int64 v50; // d18
  __int64 v51; // d19
  __int64 v52; // d20
  __int64 v53; // d21
  __int64 v54; // d22
  __int64 v55; // d23
  __int64 v56; // d24
  __int64 v57; // d25
  __int64 v58; // d26
  __int64 v59; // d27
  __int64 v60; // d28
  __int64 v61; // d29
  __int64 v62; // d30
  __int64 v63; // d31

  *(_QWORD *)a1 = a1;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a6;
  *(_QWORD *)(a1 + 48) = a7;
  *(_QWORD *)(a1 + 56) = a8;
  *(_QWORD *)(a1 + 64) = a9;
  *(_QWORD *)(a1 + 72) = v18;
  *(_QWORD *)(a1 + 80) = v19;
  *(_QWORD *)(a1 + 88) = v20;
  *(_QWORD *)(a1 + 96) = v21;
  *(_QWORD *)(a1 + 104) = v22;
  *(_QWORD *)(a1 + 112) = v23;
  *(_QWORD *)(a1 + 120) = v24;
  *(_QWORD *)(a1 + 128) = v25;
  *(_QWORD *)(a1 + 136) = v26;
  *(_QWORD *)(a1 + 144) = v27;
  *(_QWORD *)(a1 + 152) = v28;
  *(_QWORD *)(a1 + 160) = v29;
  *(_QWORD *)(a1 + 168) = v30;
  *(_QWORD *)(a1 + 176) = v31;
  *(_QWORD *)(a1 + 184) = v32;
  *(_QWORD *)(a1 + 192) = v33;
  *(_QWORD *)(a1 + 200) = v34;
  *(_QWORD *)(a1 + 208) = v35;
  *(_QWORD *)(a1 + 216) = v36;
  *(_QWORD *)(a1 + 224) = v37;
  *(_QWORD *)(a1 + 232) = v38;
  *(_QWORD *)(a1 + 240) = v39;
  *(_QWORD *)(a1 + 248) = &a18;
  *(_QWORD *)(a1 + 256) = v39;
  *(double *)(a1 + 272) = a10;
  *(double *)(a1 + 280) = a11;
  *(double *)(a1 + 288) = a12;
  *(double *)(a1 + 296) = a13;
  *(double *)(a1 + 304) = a14;
  *(double *)(a1 + 312) = a15;
  *(double *)(a1 + 320) = a16;
  *(double *)(a1 + 328) = a17;
  *(_QWORD *)(a1 + 336) = v40;
  *(_QWORD *)(a1 + 344) = v41;
  *(_QWORD *)(a1 + 352) = v42;
  *(_QWORD *)(a1 + 360) = v43;
  *(_QWORD *)(a1 + 368) = v44;
  *(_QWORD *)(a1 + 376) = v45;
  *(_QWORD *)(a1 + 384) = v46;
  *(_QWORD *)(a1 + 392) = v47;
  *(_QWORD *)(a1 + 400) = v48;
  *(_QWORD *)(a1 + 408) = v49;
  *(_QWORD *)(a1 + 416) = v50;
  *(_QWORD *)(a1 + 424) = v51;
  *(_QWORD *)(a1 + 432) = v52;
  *(_QWORD *)(a1 + 440) = v53;
  *(_QWORD *)(a1 + 448) = v54;
  *(_QWORD *)(a1 + 456) = v55;
  *(_QWORD *)(a1 + 464) = v56;
  *(_QWORD *)(a1 + 472) = v57;
  *(_QWORD *)(a1 + 480) = v58;
  *(_QWORD *)(a1 + 488) = v59;
  *(_QWORD *)(a1 + 496) = v60;
  *(_QWORD *)(a1 + 504) = v61;
  *(_QWORD *)(a1 + 512) = v62;
  *(_QWORD *)(a1 + 520) = v63;
  return 0;
}
// 69A78: variable 'v18' is possibly undefined
// 69A7C: variable 'v19' is possibly undefined
// 69A7C: variable 'v20' is possibly undefined
// 69A80: variable 'v21' is possibly undefined
// 69A80: variable 'v22' is possibly undefined
// 69A84: variable 'v23' is possibly undefined
// 69A84: variable 'v24' is possibly undefined
// 69A88: variable 'v25' is possibly undefined
// 69A88: variable 'v26' is possibly undefined
// 69A8C: variable 'v27' is possibly undefined
// 69A8C: variable 'v28' is possibly undefined
// 69A90: variable 'v29' is possibly undefined
// 69A90: variable 'v30' is possibly undefined
// 69A94: variable 'v31' is possibly undefined
// 69A94: variable 'v32' is possibly undefined
// 69A98: variable 'v33' is possibly undefined
// 69A98: variable 'v34' is possibly undefined
// 69A9C: variable 'v35' is possibly undefined
// 69A9C: variable 'v36' is possibly undefined
// 69AA0: variable 'v37' is possibly undefined
// 69AA0: variable 'v38' is possibly undefined
// 69AA4: variable 'v39' is possibly undefined
// 69AC4: variable 'v40' is possibly undefined
// 69AC4: variable 'v41' is possibly undefined
// 69AC8: variable 'v42' is possibly undefined
// 69AC8: variable 'v43' is possibly undefined
// 69ACC: variable 'v44' is possibly undefined
// 69ACC: variable 'v45' is possibly undefined
// 69AD0: variable 'v46' is possibly undefined
// 69AD0: variable 'v47' is possibly undefined
// 69AD4: variable 'v48' is possibly undefined
// 69AD4: variable 'v49' is possibly undefined
// 69AD8: variable 'v50' is possibly undefined
// 69AD8: variable 'v51' is possibly undefined
// 69ADC: variable 'v52' is possibly undefined
// 69ADC: variable 'v53' is possibly undefined
// 69AE0: variable 'v54' is possibly undefined
// 69AE0: variable 'v55' is possibly undefined
// 69AE4: variable 'v56' is possibly undefined
// 69AE4: variable 'v57' is possibly undefined
// 69AE8: variable 'v58' is possibly undefined
// 69AE8: variable 'v59' is possibly undefined
// 69AEC: variable 'v60' is possibly undefined
// 69AEC: variable 'v61' is possibly undefined
// 69AF0: variable 'v62' is possibly undefined
// 69AF4: variable 'v63' is possibly undefined

//----- (0000000000069B00) ----------------------------------------------------
void sub_69B00()
{
  JUMPOUT(0);
}
// 69B10: control flows out of bounds to 0

//----- (0000000000069B50) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new(size_t a1)
{
  return _Znwm(a1);
}

//----- (0000000000069B60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_GET_VERSION(_QWORD *a1)
{
  return GSMO_GET_VERSION(a1);
}

//----- (0000000000069B70) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *a1)
{
  _ZdlPv(a1);
}

//----- (0000000000069B80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_CREATE(_QWORD *a1)
{
  return GSMO_CREATE(a1);
}

//----- (0000000000069BA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_DESTROY(void **a1)
{
  return GSMO_DESTROY(a1);
}

//----- (0000000000069BB0) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new[](size_t a1)
{
  return _Znam(a1);
}

//----- (0000000000069BC0) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete[](void *a1)
{
  _ZdaPv(a1);
}

//----- (0000000000069BD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_SETUP(unsigned int *a1, _DWORD *a2, __int64 a3)
{
  return GSMO_SETUP(a1, a2, a3);
}

//----- (0000000000069BE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_UPDATE(__int64 a1, __int64 a2)
{
  return GSMO_UPDATE(a1, a2);
}

//----- (0000000000069BF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_FLUSH(__int64 a1)
{
  return GSMO_FLUSH(a1);
}

//----- (0000000000069C00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_RESET(__int64 a1)
{
  return GSMO_RESET(a1);
}

//----- (0000000000069C10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_PROCESS(unsigned int *a1, __int64 a2, int16x4_t *s, unsigned int a4, unsigned int *a5)
{
  return GSMO_PROCESS(a1, a2, s, a4, a5);
}

//----- (0000000000069C20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_GET_PARAMETER(__int64 a1, char *s1, float *a3)
{
  return GSMO_GET_PARAMETER(a1, s1, a3);
}

//----- (0000000000069C30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_SET_PARAMETER(_BYTE *a1, char *s1, _DWORD *a3)
{
  return GSMO_SET_PARAMETER(a1, s1, a3);
}

//----- (0000000000069C40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_GET_LATENCY(__int64 a1, _DWORD *a2)
{
  return GSMO_GET_LATENCY(a1, a2);
}

//----- (0000000000069C50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_GET_CAPS(__int64 a1, _DWORD *a2)
{
  return GSMO_GET_CAPS(a1, a2);
}

//----- (0000000000069C60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GSMO_SET_PROFILE(__int64 a1, char *s)
{
  return GSMO_SET_PROFILE(a1, s);
}

//----- (0000000000069C70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall AES_ECB_decrypt(_BYTE *a1, unsigned __int8 *a2)
{
  return AES_ECB_decrypt(a1, a2);
}

//----- (0000000000069C80) ----------------------------------------------------
// attributes: thunk
__int64 AES_init_ctx()
{
  return AES_init_ctx();
}
// 33CF0: using guessed type __int64 AES_init_ctx(void);

//----- (0000000000069C90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _checkValidConfig(__int64 a1, _DWORD *a2)
{
  return checkValidConfig(a1, a2);
}

//----- (0000000000069CA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _checkValidParams(__int64 a1, _DWORD *a2, __int64 a3)
{
  return checkValidParams(a1, a2, a3);
}

//----- (0000000000069CB0) ----------------------------------------------------
// attributes: thunk
long double __fastcall _copy_params(__int64 a1, __int64 a2)
{
  return copy_params(a1, a2);
}

//----- (0000000000069CC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _update(__int64 a1, double a2)
{
  return update(a1, a2);
}

//----- (0000000000069CE0) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall base64_decode(unsigned __int8 *a1, __int64 a2, _QWORD *a3)
{
  return base64_decode(a1, a2, a3);
}

//----- (0000000000069CF0) ----------------------------------------------------
// attributes: thunk
long double __fastcall boost_gain_create(_QWORD *a1)
{
  return boost_gain_create(a1);
}

//----- (0000000000069D00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_destroy(void **a1)
{
  return boost_gain_destroy(a1);
}

//----- (0000000000069D10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_flush(__int64 a1)
{
  return boost_gain_flush(a1);
}

//----- (0000000000069D20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_process(int *a1, float32x4_t *src, float32x4_t *dest)
{
  return boost_gain_process(a1, src, dest);
}

//----- (0000000000069D30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_reset(__int64 a1)
{
  return boost_gain_reset(a1);
}

//----- (0000000000069D40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4)
{
  return boost_gain_setup(a1, a2, a3, a4);
}

//----- (0000000000069D50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall boost_gain_update(__int64 a1, char a2, float a3, float a4, float a5, float a6)
{
  return boost_gain_update(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000069D70) ----------------------------------------------------
// attributes: thunk
long double __fastcall channel_layout_converter_create(_QWORD *a1)
{
  return channel_layout_converter_create(a1);
}

//----- (0000000000069D80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall channel_layout_converter_destroy(void **a1)
{
  return channel_layout_converter_destroy(a1);
}

//----- (0000000000069D90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall channel_layout_converter_flush(__int64 a1)
{
  return channel_layout_converter_flush(a1);
}

//----- (0000000000069DA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall channel_layout_converter_process(
        unsigned int *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        double a4)
{
  return channel_layout_converter_process(a1, a2, a3, a4);
}

//----- (0000000000069DB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall channel_layout_converter_reset(__int64 a1)
{
  return channel_layout_converter_reset(a1);
}

//----- (0000000000069DC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall channel_layout_converter_setup(
        unsigned int *a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        unsigned int a5)
{
  return channel_layout_converter_setup(a1, a2, a3, a4, a5);
}

//----- (0000000000069DD0) ----------------------------------------------------
// attributes: thunk
long double __fastcall compressor_create(_QWORD *a1)
{
  return compressor_create(a1);
}

//----- (0000000000069DE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_destroy(__int64 *a1)
{
  return compressor_destroy(a1);
}

//----- (0000000000069DF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_flush(__int64 a1)
{
  return compressor_flush(a1);
}

//----- (0000000000069E00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_process(unsigned int *a1, float *a2, __int64 a3)
{
  return compressor_process(a1, a2, a3);
}

//----- (0000000000069E10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_reset(__int64 a1)
{
  return compressor_reset(a1);
}

//----- (0000000000069E20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_setup(unsigned int *a1, size_t n, unsigned int a3, unsigned int a4)
{
  return compressor_setup(a1, n, a3, a4);
}

//----- (0000000000069E30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compressor_update(__int64 a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  return compressor_update(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0000000000069E40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_bypass(__int64 a1, __int64 a2, __int64 a3)
{
  return drc_bypass(a1, a2, a3);
}

//----- (0000000000069E50) ----------------------------------------------------
// attributes: thunk
long double __fastcall drc_create(_QWORD *a1)
{
  return drc_create(a1);
}

//----- (0000000000069E60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_delay_sample_count(__int64 a1, _DWORD *a2)
{
  return drc_delay_sample_count(a1, a2);
}

//----- (0000000000069E70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_destroy(__int64 *a1)
{
  return drc_destroy(a1);
}

//----- (0000000000069E80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_flush(__int64 a1)
{
  return drc_flush(a1);
}

//----- (0000000000069E90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_process(__int64 a1, __int64 a2, __int64 a3)
{
  return drc_process(a1, a2, a3);
}

//----- (0000000000069EA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_reset(__int64 a1)
{
  return drc_reset(a1);
}

//----- (0000000000069EB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_setup(__int64 a1, int a2, unsigned int a3, unsigned int a4)
{
  return drc_setup(a1, a2, a3, a4);
}

//----- (0000000000069EC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall drc_update(
        __int64 a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        float a7,
        float a8,
        float a9)
{
  return drc_update(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (0000000000069ED0) ----------------------------------------------------
// attributes: thunk
long double __fastcall dynamic_queue_create(_QWORD *a1)
{
  return dynamic_queue_create(a1);
}

//----- (0000000000069EE0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_destroy(__int64 *a1)
{
  return dynamic_queue_destroy(a1);
}

//----- (0000000000069EF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_flush(__int64 a1)
{
  return dynamic_queue_flush(a1);
}

//----- (0000000000069F00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_get_latency(__int64 a1, _DWORD *a2)
{
  return dynamic_queue_get_latency(a1, a2);
}

//----- (0000000000069F10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_process(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return dynamic_queue_process(a1, a2, a3, a4);
}

//----- (0000000000069F20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_process_planar(unsigned int *a1, __int64 a2, __int64 a3, signed int a4)
{
  return dynamic_queue_process_planar(a1, a2, a3, a4);
}

//----- (0000000000069F30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_process_s16(unsigned int *a1, __int64 a2, int16x4_t *a3, unsigned int a4)
{
  return dynamic_queue_process_s16(a1, a2, a3, a4);
}

//----- (0000000000069F40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_process_s16_planar(unsigned int *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return dynamic_queue_process_s16_planar(a1, a2, a3, a4);
}

//----- (0000000000069F50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_reset(__int64 a1)
{
  return dynamic_queue_reset(a1);
}

//----- (0000000000069F60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall dynamic_queue_setup(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7, size_t n)
{
  return dynamic_queue_setup(a1, a2, a3, a4, a5, a6, a7, n);
}

//----- (0000000000069F70) ----------------------------------------------------
// attributes: thunk
long double __fastcall eleq_create(_QWORD *a1)
{
  return eleq_create(a1);
}

//----- (0000000000069F80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_destroy(__int64 *a1)
{
  return eleq_destroy(a1);
}

//----- (0000000000069F90) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_flush(__int64 a1)
{
  return eleq_flush(a1);
}

//----- (0000000000069FA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_process(int *a1, __int64 a2, __int64 a3)
{
  return eleq_process(a1, a2, a3);
}

//----- (0000000000069FB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_reset(__int64 a1)
{
  return eleq_reset(a1);
}

//----- (0000000000069FC0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_setup(unsigned int *a1, unsigned int a2, unsigned int a3, size_t n)
{
  return eleq_setup(a1, a2, a3, n);
}

//----- (0000000000069FD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall eleq_update(__int64 a1, char a2, double a3, float a4, float a5, float a6, float a7)
{
  return eleq_update(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0000000000069FF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_create(_QWORD *a1)
{
  return gain_create(a1);
}

//----- (000000000006A000) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_destroy(void **a1)
{
  return gain_destroy(a1);
}

//----- (000000000006A010) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_flush(__int64 a1)
{
  return gain_flush(a1);
}

//----- (000000000006A020) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_process(__int64 a1, float32x4_t *a2, float32x4_t *a3, double a4, double a5, double a6)
{
  return gain_process(a1, a2, a3, a4, a5, a6);
}

//----- (000000000006A030) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_reset(__int64 a1)
{
  return gain_reset(a1);
}

//----- (000000000006A040) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_setup(__int64 a1, int a2, int a3, int a4)
{
  return gain_setup(a1, a2, a3, a4);
}

//----- (000000000006A050) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall gain_update(__int64 a1, float a2)
{
  return gain_update(a1, a2);
}

//----- (000000000006A060) ----------------------------------------------------
// attributes: thunk
long double __fastcall graphic_equalizer_create(_QWORD *a1)
{
  return graphic_equalizer_create(a1);
}

//----- (000000000006A070) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_destroy(__int64 *a1)
{
  return graphic_equalizer_destroy(a1);
}

//----- (000000000006A080) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_flush(__int64 a1)
{
  return graphic_equalizer_flush(a1);
}

//----- (000000000006A090) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_process(__int64 a1, __int64 a2, __int64 a3)
{
  return graphic_equalizer_process(a1, a2, a3);
}

//----- (000000000006A0A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_reset(__int64 a1)
{
  return graphic_equalizer_reset(a1);
}

//----- (000000000006A0B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_setup(__int64 a1, int a2, int a3, int a4, size_t n)
{
  return graphic_equalizer_setup(a1, a2, a3, a4, n);
}

//----- (000000000006A0C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall graphic_equalizer_update(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  return graphic_equalizer_update(a1, a2, a3);
}

//----- (000000000006A0D0) ----------------------------------------------------
// attributes: thunk
long double __fastcall iir_create(_QWORD *a1)
{
  return iir_create(a1);
}

//----- (000000000006A0E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_destroy(__int64 *a1)
{
  return iir_destroy(a1);
}

//----- (000000000006A0F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_flush(__int64 a1)
{
  return iir_flush(a1);
}

//----- (000000000006A100) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_process(unsigned int *a1, __int64 a2, __int64 a3)
{
  return iir_process(a1, a2, a3);
}

//----- (000000000006A110) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_reset(__int64 a1)
{
  return iir_reset(a1);
}

//----- (000000000006A120) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_setup(__int64 a1, size_t n, int a3, int a4, float *a5, float *a6)
{
  return iir_setup(a1, n, a3, a4, a5, a6);
}

//----- (000000000006A130) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_bypass(__int64 a1, const void *a2, void *a3)
{
  return limiter_bypass(a1, a2, a3);
}

//----- (000000000006A140) ----------------------------------------------------
// attributes: thunk
long double __fastcall limiter_create(_QWORD *a1)
{
  return limiter_create(a1);
}

//----- (000000000006A150) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_delay_sample_count(__int64 a1, _DWORD *a2)
{
  return limiter_delay_sample_count(a1, a2);
}

//----- (000000000006A160) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_destroy(__int64 *a1)
{
  return limiter_destroy(a1);
}

//----- (000000000006A170) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_flush(__int64 a1)
{
  return limiter_flush(a1);
}

//----- (000000000006A180) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_process(
        float *a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  return limiter_process(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (000000000006A190) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_reset(__int64 a1)
{
  return limiter_reset(a1);
}

//----- (000000000006A1A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall limiter_setup(__int64 a1, size_t n, int a3, int a4, float a5)
{
  return limiter_setup(a1, n, a3, a4, a5);
}

//----- (000000000006A1B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall lm1_wrapper_decode(__int64 a1, unsigned int a2, __int64 a3)
{
  return lm1_wrapper_decode(a1, a2, a3);
}

//----- (000000000006A1D0) ----------------------------------------------------
// attributes: thunk
float __fastcall loudness_measure_getInstantLoudness(__int64 a1)
{
  return loudness_measure_getInstantLoudness(a1);
}

//----- (000000000006A1E0) ----------------------------------------------------
// attributes: thunk
void __fastcall loudness_measure_getIntegratedLoudness(__int64 a1)
{
  loudness_measure_getIntegratedLoudness(a1);
}

//----- (000000000006A230) ----------------------------------------------------
// attributes: thunk
long double __fastcall resampler_create(_QWORD *a1)
{
  return resampler_create(a1);
}

//----- (000000000006A240) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_destroy(__int64 *a1)
{
  return resampler_destroy(a1);
}

//----- (000000000006A250) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_get_external_samples(__int64 a1, _DWORD *a2)
{
  return resampler_get_external_samples(a1, a2);
}

//----- (000000000006A260) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_get_internal_samples(__int64 a1, _DWORD *a2)
{
  return resampler_get_internal_samples(a1, a2);
}

//----- (000000000006A270) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_get_latency(__int64 a1, int *a2)
{
  return resampler_get_latency(a1, a2);
}

//----- (000000000006A280) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_run_external_to_internal(unsigned int *a1, void *src, void *dest)
{
  return resampler_run_external_to_internal(a1, src, dest);
}

//----- (000000000006A290) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall resampler_run_internal_to_external(__int64 a1, const void *a2, char *dest)
{
  return resampler_run_internal_to_external(a1, a2, dest);
}

//----- (000000000006A2A0) ----------------------------------------------------
// attributes: thunk
void __fastcall resampler_setup(unsigned int *a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5)
{
  resampler_setup(a1, a2, a3, a4, a5);
}

//----- (000000000006A2C0) ----------------------------------------------------
// attributes: thunk
long double __fastcall sln_create(_QWORD *a1)
{
  return sln_create(a1);
}

//----- (000000000006A2D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sln_destroy(__int64 *a1)
{
  return sln_destroy(a1);
}

//----- (000000000006A2E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sln_flush(__int64 a1)
{
  return sln_flush(a1);
}

//----- (000000000006A2F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sln_reset(__int64 a1)
{
  return sln_reset(a1);
}

//----- (000000000006A300) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sln_setup(__int64 a1, int a2, int a3, unsigned int a4, unsigned __int64 a5)
{
  return sln_setup(a1, a2, a3, a4, a5);
}

//----- (000000000006A310) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sln_sol_process(__int64 a1, __int64 a2, __int64 a3)
{
  return sln_sol_process(a1, a2, a3);
}

//----- (000000000006A320) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_bypass(__int64 a1, _DWORD *a2, __int64 a3)
{
  return spatial_upmix_bypass(a1, a2, a3);
}

//----- (000000000006A330) ----------------------------------------------------
// attributes: thunk
long double __fastcall spatial_upmix_create(_QWORD *a1)
{
  return spatial_upmix_create(a1);
}

//----- (000000000006A340) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_delay_sample_count(__int64 a1, _DWORD *a2)
{
  return spatial_upmix_delay_sample_count(a1, a2);
}

//----- (000000000006A350) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_destroy(__int64 *a1)
{
  return spatial_upmix_destroy(a1);
}

//----- (000000000006A360) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_flush(__int64 a1)
{
  return spatial_upmix_flush(a1);
}

//----- (000000000006A370) ----------------------------------------------------
// attributes: thunk
float __fastcall spatial_upmix_process(__int64 a1, float *a2, unsigned __int64 a3)
{
  return spatial_upmix_process(a1, a2, a3);
}

//----- (000000000006A380) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_reset(__int64 a1)
{
  return spatial_upmix_reset(a1);
}

//----- (000000000006A390) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_setup(__int64 a1, int a2, int a3, int a4, size_t n, float a6)
{
  return spatial_upmix_setup(a1, a2, a3, a4, n, a6);
}

//----- (000000000006A3A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatial_upmix_update(__int64 a1, unsigned int a2, float a3)
{
  return spatial_upmix_update(a1, a2, a3);
}

//----- (000000000006A3B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall static_resampler_get_internal_sample_rate(int a1, int *a2)
{
  return static_resampler_get_internal_sample_rate(a1, a2);
}

//----- (000000000006A3F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall lm1_decode(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  return lm1_decode(a1, a2, a3);
}

//----- (000000000006A400) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall lm1_free(__int64 a1)
{
  return lm1_free(a1);
}

//----- (000000000006A420) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_clear(__int64 a1)
{
  return circular_buffer_clear(a1);
}

//----- (000000000006A430) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_create(_QWORD *a1)
{
  return circular_buffer_create(a1);
}

//----- (000000000006A440) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_dequeue_data(unsigned int *a1, _DWORD *a2)
{
  return circular_buffer_dequeue_data(a1, a2);
}

//----- (000000000006A450) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_destroy(void **a1)
{
  return circular_buffer_destroy(a1);
}

//----- (000000000006A460) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_enqueue(__int64 a1, float a2)
{
  return circular_buffer_enqueue(a1, a2);
}

//----- (000000000006A470) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_free(__int64 a1)
{
  return circular_buffer_free(a1);
}

//----- (000000000006A480) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_init(__int64 a1, unsigned int a2)
{
  return circular_buffer_init(a1, a2);
}

//----- (000000000006A490) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_size(__int64 a1)
{
  return circular_buffer_size(a1);
}

//----- (000000000006A4A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall greatest_common_divisor(int a1, int a2)
{
  return greatest_common_divisor(a1, a2);
}

//----- (000000000006A4B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_process_inplace(unsigned int *a1, __int64 a2)
{
  return iir_process_inplace(a1, a2);
}

//----- (000000000006A4C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall iir_update(__int64 a1, float *a2, float *a3, double a4)
{
  return iir_update(a1, a2, a3, a4);
}

//----- (000000000006A4D0) ----------------------------------------------------
// attributes: thunk
long double __fastcall loudness_measure_create(_QWORD *a1)
{
  return loudness_measure_create(a1);
}

//----- (000000000006A4E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall loudness_measure_destroy(void ***a1)
{
  return loudness_measure_destroy(a1);
}

//----- (000000000006A4F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall loudness_measure_getFramewiseGainArray(__int64 a1, float *a2, float a3)
{
  return loudness_measure_getFramewiseGainArray(a1, a2, a3);
}

//----- (000000000006A500) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall loudness_measure_get_frameLength(__int64 a1)
{
  return loudness_measure_get_frameLength(a1);
}

//----- (000000000006A510) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall loudness_measure_process(unsigned int *a1, __int64 a2)
{
  return loudness_measure_process(a1, a2);
}

//----- (000000000006A520) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall loudness_measure_setup(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        unsigned __int64 a5)
{
  return loudness_measure_setup(a1, a2, a3, a4, a5);
}

//----- (000000000006A530) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall peak_setup(__int64 a1, unsigned int a2, unsigned int a3, int a4, int a5)
{
  return peak_setup(a1, a2, a3, a4, a5);
}

//----- (000000000006A540) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall peak_update(__int64 a1, unsigned int a2, int a3, float a4, float a5, float a6)
{
  return peak_update(a1, a2, a3, a4, a5, a6);
}

//----- (000000000006A550) ----------------------------------------------------
// attributes: thunk
long double __fastcall reverb_create(_QWORD *a1)
{
  return reverb_create(a1);
}

//----- (000000000006A560) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall reverb_destroy(__int64 *a1)
{
  return reverb_destroy(a1);
}

//----- (000000000006A570) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall reverb_process(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  return reverb_process(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (000000000006A580) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall reverb_setup(__int64 a1, int a2, __int64 a3, int a4, int a5)
{
  return reverb_setup(a1, a2, a3, a4, a5);
}

//----- (000000000006A590) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall reverb_update(__int64 a1, __int64 a2, float a3)
{
  return reverb_update(a1, a2, a3);
}

//----- (000000000006A5A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_bypass(__int64 a1, _DWORD *a2, __int64 a3)
{
  return spatializer_bypass(a1, a2, a3);
}

//----- (000000000006A5B0) ----------------------------------------------------
// attributes: thunk
long double __fastcall spatializer_create(_QWORD *a1)
{
  return spatializer_create(a1);
}

//----- (000000000006A5C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_delay_sample_count(__int64 a1, _DWORD *a2)
{
  return spatializer_delay_sample_count(a1, a2);
}

//----- (000000000006A5D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_destroy(__int64 *a1)
{
  return spatializer_destroy(a1);
}

//----- (000000000006A5E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_offSetting(__int64 a1)
{
  return spatializer_offSetting(a1);
}

//----- (000000000006A5F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_process(__int64 a1, const float *a2, __int64 a3)
{
  return spatializer_process(a1, a2, a3);
}

//----- (000000000006A600) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_setup(__int64 a1, int a2, int a3, int a4)
{
  return spatializer_setup(a1, a2, a3, a4);
}

//----- (000000000006A610) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall spatializer_update(__int64 a1, unsigned int a2, unsigned int a3)
{
  return spatializer_update(a1, a2, a3);
}

//----- (000000000006A670) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_dequeue(int *a1)
{
  return circular_buffer_dequeue(a1);
}

//----- (000000000006A680) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_dequeue_data_count(int *a1, char *dest, unsigned int a3)
{
  return circular_buffer_dequeue_data_count(a1, dest, a3);
}

//----- (000000000006A690) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_enqueueForce(unsigned int *a1, float a2)
{
  return circular_buffer_enqueueForce(a1, a2);
}

//----- (000000000006A6A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_readAll(unsigned int *a1, char *dest, _DWORD *a3)
{
  return circular_buffer_readAll(a1, dest, a3);
}

//----- (000000000006A6B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall circular_buffer_readFront(unsigned int *a1, char *dest, unsigned int a3)
{
  return circular_buffer_readFront(a1, dest, a3);
}

//----- (000000000006A6C0) ----------------------------------------------------
// attributes: thunk
void __fastcall loudness_measure_getLRA(__int64 a1)
{
  loudness_measure_getLRA(a1);
}

//----- (000000000006A710) ----------------------------------------------------
// attributes: thunk
long double __fastcall comb_create(_QWORD *a1)
{
  return comb_create(a1);
}

//----- (000000000006A720) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_destroy(__int64 *a1)
{
  return comb_destroy(a1);
}

//----- (000000000006A730) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_flush(__int64 a1)
{
  return comb_flush(a1);
}

//----- (000000000006A740) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_process(__int64 a1, __int64 a2, __int64 a3)
{
  return comb_process(a1, a2, a3);
}

//----- (000000000006A750) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_process_acc(__int64 a1, __int64 a2, __int64 a3)
{
  return comb_process_acc(a1, a2, a3);
}

//----- (000000000006A760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_setup(__int64 a1, int a2, int a3, size_t n, float a5)
{
  return comb_setup(a1, a2, a3, n, a5);
}

//----- (000000000006A770) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall comb_update(__int64 a1, float a2)
{
  return comb_update(a1, a2);
}

//----- (000000000006A780) ----------------------------------------------------
// attributes: thunk
long double __fastcall allpass_create(_QWORD *a1)
{
  return allpass_create(a1);
}

//----- (000000000006A790) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall allpass_destroy(__int64 *a1)
{
  return allpass_destroy(a1);
}

//----- (000000000006A7A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall allpass_flush(__int64 a1)
{
  return allpass_flush(a1);
}

//----- (000000000006A7B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall allpass_process_inplace(unsigned int *a1, __int64 a2)
{
  return allpass_process_inplace(a1, a2);
}

//----- (000000000006A7C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall allpass_setup(__int64 a1, int a2, int a3, size_t n, float a5)
{
  return allpass_setup(a1, a2, a3, n, a5);
}

//----- (000000000006A7D0) ----------------------------------------------------
// attributes: thunk
float __fastcall fft_backward_ordered(__int64 a1, const void *a2, unsigned __int64 a3)
{
  return fft_backward_ordered(a1, a2, a3);
}

//----- (000000000006A7E0) ----------------------------------------------------
// attributes: thunk
long double __fastcall fft_create(_QWORD *a1)
{
  return fft_create(a1);
}

//----- (000000000006A7F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall fft_destroy(__int64 *a1)
{
  return fft_destroy(a1);
}

//----- (000000000006A800) ----------------------------------------------------
// attributes: thunk
void *__fastcall fft_forward_ordered(__int64 a1, const void *a2, void *a3)
{
  return fft_forward_ordered(a1, a2, a3);
}

//----- (000000000006A810) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall fft_setup(__int64 a1, unsigned int a2)
{
  return fft_setup(a1, a2);
}

//----- (000000000006A820) ----------------------------------------------------
// attributes: thunk
void __fastcall pffft_aligned_free(__int64 a1)
{
  pffft_aligned_free(a1);
}

//----- (000000000006A830) ----------------------------------------------------
// attributes: thunk
unsigned __int64 __fastcall pffft_aligned_malloc(__int64 a1)
{
  return pffft_aligned_malloc(a1);
}

//----- (000000000006A840) ----------------------------------------------------
// attributes: thunk
void __fastcall pffft_destroy_setup(_QWORD *ptr)
{
  pffft_destroy_setup(ptr);
}

//----- (000000000006A850) ----------------------------------------------------
// attributes: thunk
int32x4_t *__fastcall pffft_new_setup(int a1, unsigned __int32 a2)
{
  return pffft_new_setup(a1, a2);
}

//----- (000000000006A860) ----------------------------------------------------
// attributes: thunk
__int64 pffft_simd_size()
{
  return pffft_simd_size();
}

//----- (000000000006A870) ----------------------------------------------------
// attributes: thunk
int8x16_t __fastcall pffft_transform(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        long double a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10)
{
  return pffft_transform(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (000000000006A880) ----------------------------------------------------
// attributes: thunk
int8x16_t __fastcall pffft_transform_ordered(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        long double a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10)
{
  return pffft_transform_ordered(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (000000000006A890) ----------------------------------------------------
// attributes: thunk
float __fastcall pffft_zconvolve_accumulate(__int64 a1, float *a2, float *a3, float *a4, double a5)
{
  return pffft_zconvolve_accumulate(a1, a2, a3, a4, a5);
}

//----- (000000000006A8A0) ----------------------------------------------------
// attributes: thunk
int8x16_t __fastcall pffft_zreorder(int *a1, int32x4_t *a2, int8x16_t *a3, int a4, int8x16_t result)
{
  return pffft_zreorder(a1, a2, a3, a4, result);
}

//----- (000000000006A8B0) ----------------------------------------------------
// attributes: thunk
float32x4_t *__fastcall cfftf1_ps(
        int a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        __int64 a5,
        __int64 a6,
        int a7,
        double a8,
        double a9,
        double a10,
        double a11,
        long double a12)
{
  return cfftf1_ps(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

//----- (000000000006A8C0) ----------------------------------------------------
// attributes: thunk
void __fastcall cffti1_ps(int a1, __int64 a2, int *a3)
{
  cffti1_ps(a1, a2, a3);
}

//----- (000000000006A8D0) ----------------------------------------------------
// attributes: thunk
int8x16_t __fastcall pffft_transform_internal(
        __int64 a1,
        float32x4_t *a2,
        float32x4_t *a3,
        float32x4_t *a4,
        int a5,
        int a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10,
        long double a11)
{
  return pffft_transform_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (000000000006A8F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _readFlexibleAsUInt64(__int64 a1)
{
  return readFlexibleAsUInt64(a1);
}

//----- (000000000006A940) ----------------------------------------------------
// attributes: thunk
void *__cxa_begin_catch(void *a1)
{
  return _cxa_begin_catch(a1);
}

//----- (000000000006A950) ----------------------------------------------------
// attributes: thunk
void __noreturn std::terminate(void)
{
  _ZSt9terminatev();
}

//----- (000000000006A960) ----------------------------------------------------
// attributes: thunk
_QWORD *__cxa_get_globals()
{
  return _cxa_get_globals();
}

//----- (000000000006A970) ----------------------------------------------------
// attributes: thunk
_QWORD *__cxa_get_globals_fast()
{
  return _cxa_get_globals_fast();
}

//----- (000000000006A980) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_unexpected(void)
{
  return _ZSt14get_unexpectedv();
}

//----- (000000000006A990) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_terminate(void)
{
  return _ZSt13get_terminatev();
}

//----- (000000000006A9A0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 std::get_new_handler(void)
{
  return _ZSt15get_new_handlerv();
}

//----- (000000000006A9B0) ----------------------------------------------------
// attributes: thunk
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  return _cxa_demangle(lpmangled, lpout, lpoutlen, lpstatus);
}

//----- (000000000006A9C0) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall __emutls_get_address(size_t *a1)
{
  return _emutls_get_address(a1);
}

//----- (000000000006A9D0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000006A9E0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000006A9F0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000006AA00) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000006AA10) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000006AA20) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this)
{
  return _ZNSt9bad_allocC2Ev(this);
}

//----- (000000000006AA30) ----------------------------------------------------
// attributes: thunk
void __fastcall std::type_info::~type_info(std::type_info *this)
{
  _ZNSt9type_infoD2Ev(this);
}

//----- (000000000006AA40) ----------------------------------------------------
// attributes: thunk
void __fastcall std::type_info::~type_info(std::type_info *this)
{
  _ZNSt9type_infoD2Ev(this);
}

//----- (000000000006AA50) ----------------------------------------------------
// attributes: thunk
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  _ZNSt8bad_castD2Ev(this);
}

//----- (000000000006AA60) ----------------------------------------------------
// attributes: thunk
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  _ZNSt10bad_typeidD2Ev(this);
}

//----- (000000000006AB00) ----------------------------------------------------
// attributes: thunk
void *__dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  return _dynamic_cast(lpsrc, lpstype, lpdtype, s2d);
}

//----- (000000000006AB70) ----------------------------------------------------
// attributes: thunk
void *__cxa_allocate_exception(size_t thrown_size)
{
  return _cxa_allocate_exception(thrown_size);
}

//----- (000000000006AB80) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  _cxa_throw(a1, lptinfo, a3);
}

//----- (000000000006AB90) ----------------------------------------------------
// attributes: thunk
void __cxa_end_catch(void)
{
  _cxa_end_catch();
}

//----- (000000000006ABA0) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  return _ZnwmSt11align_val_t(a1, a2);
}

//----- (000000000006ABC0) ----------------------------------------------------
// attributes: thunk
void *__fastcall operator new[](size_t a1, unsigned __int64 a2)
{
  return _ZnamSt11align_val_t(a1, a2);
}

//----- (000000000006ABD0) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *ptr)
{
  _ZdlPvSt11align_val_t(ptr);
}

//----- (000000000006ABE0) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete[](void *ptr)
{
  _ZdaPvSt11align_val_t(ptr);
}

//----- (000000000006ABF0) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_rethrow(void)
{
  _cxa_rethrow();
}

// nfuncs=1175 queued=1046 decompiled=1046 lumina nreq=0 worse=0 better=0
// ALL OK, 1046 function(s) have been successfully decompiled
