/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_B6D8();
void sub_B6E8();
void sub_B6F0();
__int64 (*__fastcall sub_B6F8(__int64 (*result)(void)))(void);
__int64 __fastcall sub_B70C(void *obj); // idb
void printLogV();
void printLogI();
void printLogW();
void printLogF();
void printLogS();
void printLogE();
void printLogD();
void printLogUNK();
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3);
_BYTE *__fastcall GenerateTNA(_BYTE *result, _BYTE *a2);
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3);
__int64 Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMInit();
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMOpenPath(__int64 a1, __int64 a2, __int64 a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMOpenPfd(__int64 a1, __int64 a2, int a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMClose(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfOpen(__int64 a1, __int64 a2, int a3, __int64 a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfSetFileSize(__int64 a1, __int64 a2, __int16 a3, int a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfSetBuffer(__int64 a1, __int64 a2, __int16 a3, __int64 a4, int a5, int a6);
bool __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfIsReachedToEndOfFile(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfShouldUpdateBuffer(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMRead(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, signed int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMSeek(__int64 a1, __int64 a2, unsigned int a3, int a4, int a5);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetOriginalFileSize(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetFileSize(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetErrorCode(__int64 a1, __int64 a2, __int16 a3);
FILE *__fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentIDPfd(__int64 a1, __int64 a2, int a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentID(__int64 a1, __int64 a2, __int16 a3);
void *__fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetValidPeriod(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentDescription(__int64 *a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetUnsupportedValue(__int64 a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetMetaDataCharacterSet(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetUnsupportedValueUTF8(__int64 *a1, __int64 a2, __int16 a3, __int64 a4);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckDCFFromPfd(__int64 a1, __int64 a2, int a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckDCF(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckLyrics(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckLyricsFromPfd(__int64 a1, __int64 a2, int a3);
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMSetClientID(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3);
__int64 DRM_SetClientID();
__int64 DRM_Init();
void DRM_Destroy();
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3);
__int64 __fastcall sub_D950(__int64 a1);
__int64 __fastcall DRM_VF_Open(int a1, __int64 a2, int a3);
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall DRM_Close(__int16 a1);
__int64 __fastcall DRM_VF_SetFileSize(__int16 a1, int a2);
__int64 __fastcall DRM_VF_SetBuffer(__int16 a1, __int64 a2, int a3, int a4);
__int64 __fastcall DRM_VF_IsReachedToEndOfFile(__int16 a1, _WORD *a2);
__int64 __fastcall DRM_VF_ShouldUpdateBuffer(__int16 a1, _WORD *a2, _DWORD *a3);
size_t __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3);
__int64 __fastcall sub_E800(__int16 a1, int **a2);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 __fastcall DRM_GetContentInfo(__int16 a1, int **a2);
__int64 __fastcall sub_F6B8(__int16 a1);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3);
void __fastcall sub_F9BC(_QWORD *a1);
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3);
__int64 __fastcall DRM_GetFileSize(__int16 a1);
__int64 __fastcall DRM_GetOriginalFileSize(__int16 a1);
__int64 __fastcall DRM_CheckDCF(char *a1, __int64 a2);
__int64 __fastcall sub_FCF4(_BYTE *a1, __int64 a2);
__int64 __fastcall DRM_CheckDCFFromPfd(int a1, __int64 a2);
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
void *__fastcall DRM_GetFilePath(unsigned __int16 a1);
__int64 __fastcall sub_101D0(__int16 a1);
void __fastcall sub_10348(void **a1);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
void __fastcall sub_11D7C(__int64 a1);
__int64 __fastcall sub_11EB8(__int64 a1, __int64 *a2);
void __fastcall ClientIDDestroy(_QWORD *a1);
__int64 __fastcall sub_12000(__int64 a1, unsigned int a2, __int64 **a3);
void __fastcall DomainListDestroy(__int64 a1);
__int64 __fastcall sub_12128(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6);
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, char *a6, __int16 a7);
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5);
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
char *__fastcall sub_15D88(char *result, __int64 a2, int *a3, int *a4);
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
void *__fastcall DHmalloc(int a1);
void __fastcall DHfree(void *a1);
FILE *__fastcall DHfsOpen(char *filename, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 DHfsClose(void); // weak
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3);
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3);
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3);
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
__int64 __fastcall DHfsMetaTell(__int64 a1);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
__int64 DHfsTell(void); // weak
__int64 __fastcall DHfsMetaSize(const char *a1);
__int64 __fastcall DHfsSize(const char *a1);
void *__fastcall DHmemset(void *a1, int a2, int a3);
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3);
void *__fastcall DHmemchr(const void *a1, int a2, int a3);
void DHmemcount();
size_t __fastcall DHstrlen(const char *a1);
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 DHstrcat(void); // weak
char *__fastcall DHstrncat(char *a1, const char *a2, int a3);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
__int64 DHatoi(void); // weak
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
__int64 DHstrstr(void); // weak
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
const char *__fastcall DHstristr(const char *a1, const char *a2);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
_BYTE *__fastcall DHstrupr(_BYTE *result);
__int64 DHvsnprintf(char *a1, int a2, char *s, ...);
__int64 DHsprintf(char *a1, const char *a2, ...);
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
__int64 __fastcall DHGetStateInfo(void *a1);
__int64 DHcurrentTime_ByLib();
__int64 DHcurrentTime();
__int64 DHAuthTime_ByLib();
__int64 DHAuthTime_ByFile();
__int64 DHAuthTime();
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
void __fastcall DHFreeClientID(void *a1);
__int64 DHGetClientID_ByLib();
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3);
__int64 DHGetDeviceID_ByLib();
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
__int64 __fastcall sub_184C4(_DWORD *a1, __int64 a2, unsigned int a3);
int32x4_t __fastcall sub_185A0(_DWORD *a1, unsigned int *a2);
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3);
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2);
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5);
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3);
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4);
__int64 DA_DRA_SetClientID(void); // weak
__int64 __fastcall StrErrorReturn(int a1);
__int64 __fastcall StrErrorReturn_uch(int a1);
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5);
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3);
const char *AES_options();
__int64 AES_set_decrypt_key(void); // weak
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
void sub_1B250();
// int __cxa_finalize(void *);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
void printLogD();
// FILE *fopen(const char *filename, const char *modes);
size_t __fastcall DHstrlen(const char *a1);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fclose(FILE *stream);
__int64 DRM_Init();
void DRM_Destroy();
// void *memset(void *s, int c, size_t n);
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4);
// size_t __strlen_chk(const char *, size_t);
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3);
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3);
__int64 __fastcall DRM_Close(__int16 a1);
__int64 __fastcall DRM_VF_Open(int a1, __int64 a2, int a3);
__int64 __fastcall DRM_VF_SetFileSize(__int16 a1, int a2);
__int64 __fastcall DRM_VF_SetBuffer(__int16 a1, __int64 a2, int a3, int a4);
__int64 __fastcall DRM_VF_IsReachedToEndOfFile(__int16 a1, _WORD *a2);
__int64 __fastcall DRM_VF_ShouldUpdateBuffer(__int16 a1, _WORD *a2, _DWORD *a3);
// void *malloc(size_t size);
size_t __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3);
// void free(void *ptr);
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3);
__int64 __fastcall DRM_GetOriginalFileSize(__int16 a1);
__int64 __fastcall DRM_GetFileSize(__int16 a1);
__int64 __fastcall DRM_GetContentInfo(__int16 a1, int **a2);
FILE *__fastcall DHfsPfdOpen(int a1, int a2);
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3);
__int64 DHfsClose();
// size_t strlen(const char *s);
void *__fastcall DHmemset(void *a1, int a2, int a3);
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3);
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1);
// __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall DRM_CheckDCFFromPfd(int a1, __int64 a2);
__int64 __fastcall DRM_CheckDCF(char *a1, __int64 a2);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
__int64 __fastcall StrErrorReturn(int a1);
__int64 DRM_SetClientID();
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4);
void __fastcall DHFreeClientID(void *a1);
void *__fastcall DHmalloc(int a1);
__int64 DA_DRA_SetClientID();
void __fastcall DHfree(void *a1);
void DHmemcount();
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3);
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3);
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3);
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6);
__int64 DHfsTell();
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1);
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2);
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4);
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3);
void __fastcall ClientIDDestroy(_QWORD *a1);
void __fastcall DomainListDestroy(__int64 a1);
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2);
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3);
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3);
__int64 AES_set_decrypt_key();
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3);
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4);
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5);
__int64 __fastcall compute_eAuthCode(__int16 a1, const char *a2, char *a3, const char *a4, unsigned __int8 *a5, char *a6, __int16 a7);
const char *__fastcall DHstristr(const char *a1, const char *a2);
__int64 DHatoi();
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5);
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2);
__int64 DHAuthTime();
__int64 DHcurrentTime();
FILE *__fastcall DHfsOpen(char *filename, int a2);
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3);
// char *strstr(const char *haystack, const char *needle);
// int strcmp(const char *s1, const char *s2);
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3);
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5);
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s);
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1);
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4);
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2);
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3);
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3);
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3);
__int64 DHstrcat();
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9);
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3);
_BYTE *__fastcall DHstrlwr(_BYTE *result);
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2);
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4);
__int64 DHstrstr();
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2);
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2);
// int dup(int fd);
// FILE *fdopen(int fd, const char *modes);
// void rewind(FILE *stream);
void __fastcall DHfsMetaClose(_QWORD *a1);
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ftell(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// void *memchr(const void *s, int c, size_t n);
// char *strcpy(char *dest, const char *src);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// int atoi(const char *nptr);
// char *strchr(const char *s, int c);
// char *strerror(int errnum);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// time_t mktime(struct tm *tp);
__int64 __fastcall DHGetStateInfo(void *a1);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3);
// time_t time(time_t *timer);
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3);
// __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2);
long double __fastcall CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(_QWORD *, _QWORD *, __int64));
__int64 __fastcall CRYPTO_cbc128_decrypt(__int64 result, int8x16_t *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64));
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3);
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_4C68; // weak
_UNKNOWN unk_55D1; // weak
_BYTE byte_55D3[4] = { 71, 73, 68, 0 }; // weak
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
__int128 xmmword_6CE0 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
__int128 xmmword_6CF0 = 0x2065756C61562065646F436874754165LL; // weak
__int128 xmmword_6D50 = 0xFFFFFFF8FFFFFFF0FFFFFFE8LL; // weak
char a0123456789abcd[77] = "0123456789abcdefl Base Key Gener10574021eneratioue Generen GenerGeneratirati"; // weak
_UNKNOWN unk_6DD0; // weak
_DWORD dword_6DE0[3] = { 1, 2, 0 }; // weak
_UNKNOWN unk_6DEC; // weak
unsigned __int8 byte_6DF0[1024] =
{
  99u,
  198u,
  165u,
  99u,
  124u,
  248u,
  132u,
  124u,
  119u,
  238u,
  153u,
  119u,
  123u,
  246u,
  141u,
  123u,
  242u,
  255u,
  13u,
  242u,
  107u,
  214u,
  189u,
  107u,
  111u,
  222u,
  177u,
  111u,
  197u,
  145u,
  84u,
  197u,
  48u,
  96u,
  80u,
  48u,
  1u,
  2u,
  3u,
  1u,
  103u,
  206u,
  169u,
  103u,
  43u,
  86u,
  125u,
  43u,
  254u,
  231u,
  25u,
  254u,
  215u,
  181u,
  98u,
  215u,
  171u,
  77u,
  230u,
  171u,
  118u,
  236u,
  154u,
  118u,
  202u,
  143u,
  69u,
  202u,
  130u,
  31u,
  157u,
  130u,
  201u,
  137u,
  64u,
  201u,
  125u,
  250u,
  135u,
  125u,
  250u,
  239u,
  21u,
  250u,
  89u,
  178u,
  235u,
  89u,
  71u,
  142u,
  201u,
  71u,
  240u,
  251u,
  11u,
  240u,
  173u,
  65u,
  236u,
  173u,
  212u,
  179u,
  103u,
  212u,
  162u,
  95u,
  253u,
  162u,
  175u,
  69u,
  234u,
  175u,
  156u,
  35u,
  191u,
  156u,
  164u,
  83u,
  247u,
  164u,
  114u,
  228u,
  150u,
  114u,
  192u,
  155u,
  91u,
  192u,
  183u,
  117u,
  194u,
  183u,
  253u,
  225u,
  28u,
  253u,
  147u,
  61u,
  174u,
  147u,
  38u,
  76u,
  106u,
  38u,
  54u,
  108u,
  90u,
  54u,
  63u,
  126u,
  65u,
  63u,
  247u,
  245u,
  2u,
  247u,
  204u,
  131u,
  79u,
  204u,
  52u,
  104u,
  92u,
  52u,
  165u,
  81u,
  244u,
  165u,
  229u,
  209u,
  52u,
  229u,
  241u,
  249u,
  8u,
  241u,
  113u,
  226u,
  147u,
  113u,
  216u,
  171u,
  115u,
  216u,
  49u,
  98u,
  83u,
  49u,
  21u,
  42u,
  63u,
  21u,
  4u,
  8u,
  12u,
  4u,
  199u,
  149u,
  82u,
  199u,
  35u,
  70u,
  101u,
  35u,
  195u,
  157u,
  94u,
  195u,
  24u,
  48u,
  40u,
  24u,
  150u,
  55u,
  161u,
  150u,
  5u,
  10u,
  15u,
  5u,
  154u,
  47u,
  181u,
  154u,
  7u,
  14u,
  9u,
  7u,
  18u,
  36u,
  54u,
  18u,
  128u,
  27u,
  155u,
  128u,
  226u,
  223u,
  61u,
  226u,
  235u,
  205u,
  38u,
  235u,
  39u,
  78u,
  105u,
  39u,
  178u,
  127u,
  205u,
  178u,
  117u,
  234u,
  159u,
  117u,
  9u,
  18u,
  27u,
  9u,
  131u,
  29u,
  158u,
  131u,
  44u,
  88u,
  116u,
  44u,
  26u,
  52u,
  46u,
  26u,
  27u,
  54u,
  45u,
  27u,
  110u,
  220u,
  178u,
  110u,
  90u,
  180u,
  238u,
  90u,
  160u,
  91u,
  251u,
  160u,
  82u,
  164u,
  246u,
  82u,
  59u,
  118u,
  77u,
  59u,
  214u,
  183u,
  97u,
  214u,
  179u,
  125u,
  206u,
  179u,
  41u,
  82u,
  123u,
  41u,
  227u,
  221u,
  62u,
  227u,
  47u,
  94u,
  113u,
  47u,
  132u,
  19u,
  151u,
  132u,
  83u,
  166u,
  245u,
  83u,
  209u,
  185u,
  104u,
  209u,
  0u,
  0u,
  0u,
  0u,
  237u,
  193u,
  44u,
  237u,
  32u,
  64u,
  96u,
  32u,
  252u,
  227u,
  31u,
  252u,
  177u,
  121u,
  200u,
  177u,
  91u,
  182u,
  237u,
  91u,
  106u,
  212u,
  190u,
  106u,
  203u,
  141u,
  70u,
  203u,
  190u,
  103u,
  217u,
  190u,
  57u,
  114u,
  75u,
  57u,
  74u,
  148u,
  222u,
  74u,
  76u,
  152u,
  212u,
  76u,
  88u,
  176u,
  232u,
  88u,
  207u,
  133u,
  74u,
  207u,
  208u,
  187u,
  107u,
  208u,
  239u,
  197u,
  42u,
  239u,
  170u,
  79u,
  229u,
  170u,
  251u,
  237u,
  22u,
  251u,
  67u,
  134u,
  197u,
  67u,
  77u,
  154u,
  215u,
  77u,
  51u,
  102u,
  85u,
  51u,
  133u,
  17u,
  148u,
  133u,
  69u,
  138u,
  207u,
  69u,
  249u,
  233u,
  16u,
  249u,
  2u,
  4u,
  6u,
  2u,
  127u,
  254u,
  129u,
  127u,
  80u,
  160u,
  240u,
  80u,
  60u,
  120u,
  68u,
  60u,
  159u,
  37u,
  186u,
  159u,
  168u,
  75u,
  227u,
  168u,
  81u,
  162u,
  243u,
  81u,
  163u,
  93u,
  254u,
  163u,
  64u,
  128u,
  192u,
  64u,
  143u,
  5u,
  138u,
  143u,
  146u,
  63u,
  173u,
  146u,
  157u,
  33u,
  188u,
  157u,
  56u,
  112u,
  72u,
  56u,
  245u,
  241u,
  4u,
  245u,
  188u,
  99u,
  223u,
  188u,
  182u,
  119u,
  193u,
  182u,
  218u,
  175u,
  117u,
  218u,
  33u,
  66u,
  99u,
  33u,
  16u,
  32u,
  48u,
  16u,
  255u,
  229u,
  26u,
  255u,
  243u,
  253u,
  14u,
  243u,
  210u,
  191u,
  109u,
  210u,
  205u,
  129u,
  76u,
  205u,
  12u,
  24u,
  20u,
  12u,
  19u,
  38u,
  53u,
  19u,
  236u,
  195u,
  47u,
  236u,
  95u,
  190u,
  225u,
  95u,
  151u,
  53u,
  162u,
  151u,
  68u,
  136u,
  204u,
  68u,
  23u,
  46u,
  57u,
  23u,
  196u,
  147u,
  87u,
  196u,
  167u,
  85u,
  242u,
  167u,
  126u,
  252u,
  130u,
  126u,
  61u,
  122u,
  71u,
  61u,
  100u,
  200u,
  172u,
  100u,
  93u,
  186u,
  231u,
  93u,
  25u,
  50u,
  43u,
  25u,
  115u,
  230u,
  149u,
  115u,
  96u,
  192u,
  160u,
  96u,
  129u,
  25u,
  152u,
  129u,
  79u,
  158u,
  209u,
  79u,
  220u,
  163u,
  127u,
  220u,
  34u,
  68u,
  102u,
  34u,
  42u,
  84u,
  126u,
  42u,
  144u,
  59u,
  171u,
  144u,
  136u,
  11u,
  131u,
  136u,
  70u,
  140u,
  202u,
  70u,
  238u,
  199u,
  41u,
  238u,
  184u,
  107u,
  211u,
  184u,
  20u,
  40u,
  60u,
  20u,
  222u,
  167u,
  121u,
  222u,
  94u,
  188u,
  226u,
  94u,
  11u,
  22u,
  29u,
  11u,
  219u,
  173u,
  118u,
  219u,
  224u,
  219u,
  59u,
  224u,
  50u,
  100u,
  86u,
  50u,
  58u,
  116u,
  78u,
  58u,
  10u,
  20u,
  30u,
  10u,
  73u,
  146u,
  219u,
  73u,
  6u,
  12u,
  10u,
  6u,
  36u,
  72u,
  108u,
  36u,
  92u,
  184u,
  228u,
  92u,
  194u,
  159u,
  93u,
  194u,
  211u,
  189u,
  110u,
  211u,
  172u,
  67u,
  239u,
  172u,
  98u,
  196u,
  166u,
  98u,
  145u,
  57u,
  168u,
  145u,
  149u,
  49u,
  164u,
  149u,
  228u,
  211u,
  55u,
  228u,
  121u,
  242u,
  139u,
  121u,
  231u,
  213u,
  50u,
  231u,
  200u,
  139u,
  67u,
  200u,
  55u,
  110u,
  89u,
  55u,
  109u,
  218u,
  183u,
  109u,
  141u,
  1u,
  140u,
  141u,
  213u,
  177u,
  100u,
  213u,
  78u,
  156u,
  210u,
  78u,
  169u,
  73u,
  224u,
  169u,
  108u,
  216u,
  180u,
  108u,
  86u,
  172u,
  250u,
  86u,
  244u,
  243u,
  7u,
  244u,
  234u,
  207u,
  37u,
  234u,
  101u,
  202u,
  175u,
  101u,
  122u,
  244u,
  142u,
  122u,
  174u,
  71u,
  233u,
  174u,
  8u,
  16u,
  24u,
  8u,
  186u,
  111u,
  213u,
  186u,
  120u,
  240u,
  136u,
  120u,
  37u,
  74u,
  111u,
  37u,
  46u,
  92u,
  114u,
  46u,
  28u,
  56u,
  36u,
  28u,
  166u,
  87u,
  241u,
  166u,
  180u,
  115u,
  199u,
  180u,
  198u,
  151u,
  81u,
  198u,
  232u,
  203u,
  35u,
  232u,
  221u,
  161u,
  124u,
  221u,
  116u,
  232u,
  156u,
  116u,
  31u,
  62u,
  33u,
  31u,
  75u,
  150u,
  221u,
  75u,
  189u,
  97u,
  220u,
  189u,
  139u,
  13u,
  134u,
  139u,
  138u,
  15u,
  133u,
  138u,
  112u,
  224u,
  144u,
  112u,
  62u,
  124u,
  66u,
  62u,
  181u,
  113u,
  196u,
  181u,
  102u,
  204u,
  170u,
  102u,
  72u,
  144u,
  216u,
  72u,
  3u,
  6u,
  5u,
  3u,
  246u,
  247u,
  1u,
  246u,
  14u,
  28u,
  18u,
  14u,
  97u,
  194u,
  163u,
  97u,
  53u,
  106u,
  95u,
  53u,
  87u,
  174u,
  249u,
  87u,
  185u,
  105u,
  208u,
  185u,
  134u,
  23u,
  145u,
  134u,
  193u,
  153u,
  88u,
  193u,
  29u,
  58u,
  39u,
  29u,
  158u,
  39u,
  185u,
  158u,
  225u,
  217u,
  56u,
  225u,
  248u,
  235u,
  19u,
  248u,
  152u,
  43u,
  179u,
  152u,
  17u,
  34u,
  51u,
  17u,
  105u,
  210u,
  187u,
  105u,
  217u,
  169u,
  112u,
  217u,
  142u,
  7u,
  137u,
  142u,
  148u,
  51u,
  167u,
  148u,
  155u,
  45u,
  182u,
  155u,
  30u,
  60u,
  34u,
  30u,
  135u,
  21u,
  146u,
  135u,
  233u,
  201u,
  32u,
  233u,
  206u,
  135u,
  73u,
  206u,
  85u,
  170u,
  255u,
  85u,
  40u,
  80u,
  120u,
  40u,
  223u,
  165u,
  122u,
  223u,
  140u,
  3u,
  143u,
  140u,
  161u,
  89u,
  248u,
  161u,
  137u,
  9u,
  128u,
  137u,
  13u,
  26u,
  23u,
  13u,
  191u,
  101u,
  218u,
  191u,
  230u,
  215u,
  49u,
  230u,
  66u,
  132u,
  198u,
  66u,
  104u,
  208u,
  184u,
  104u,
  65u,
  130u,
  195u,
  65u,
  153u,
  41u,
  176u,
  153u,
  45u,
  90u,
  119u,
  45u,
  15u,
  30u,
  17u,
  15u,
  176u,
  123u,
  203u,
  176u,
  84u,
  168u,
  252u,
  84u,
  187u,
  109u,
  214u,
  187u,
  22u,
  44u,
  58u,
  22u
}; // weak
unsigned __int8 byte_71F0[1024] =
{
  198u,
  165u,
  99u,
  99u,
  248u,
  132u,
  124u,
  124u,
  238u,
  153u,
  119u,
  119u,
  246u,
  141u,
  123u,
  123u,
  255u,
  13u,
  242u,
  242u,
  214u,
  189u,
  107u,
  107u,
  222u,
  177u,
  111u,
  111u,
  145u,
  84u,
  197u,
  197u,
  96u,
  80u,
  48u,
  48u,
  2u,
  3u,
  1u,
  1u,
  206u,
  169u,
  103u,
  103u,
  86u,
  125u,
  43u,
  43u,
  231u,
  25u,
  254u,
  254u,
  181u,
  98u,
  215u,
  215u,
  77u,
  230u,
  171u,
  171u,
  236u,
  154u,
  118u,
  118u,
  143u,
  69u,
  202u,
  202u,
  31u,
  157u,
  130u,
  130u,
  137u,
  64u,
  201u,
  201u,
  250u,
  135u,
  125u,
  125u,
  239u,
  21u,
  250u,
  250u,
  178u,
  235u,
  89u,
  89u,
  142u,
  201u,
  71u,
  71u,
  251u,
  11u,
  240u,
  240u,
  65u,
  236u,
  173u,
  173u,
  179u,
  103u,
  212u,
  212u,
  95u,
  253u,
  162u,
  162u,
  69u,
  234u,
  175u,
  175u,
  35u,
  191u,
  156u,
  156u,
  83u,
  247u,
  164u,
  164u,
  228u,
  150u,
  114u,
  114u,
  155u,
  91u,
  192u,
  192u,
  117u,
  194u,
  183u,
  183u,
  225u,
  28u,
  253u,
  253u,
  61u,
  174u,
  147u,
  147u,
  76u,
  106u,
  38u,
  38u,
  108u,
  90u,
  54u,
  54u,
  126u,
  65u,
  63u,
  63u,
  245u,
  2u,
  247u,
  247u,
  131u,
  79u,
  204u,
  204u,
  104u,
  92u,
  52u,
  52u,
  81u,
  244u,
  165u,
  165u,
  209u,
  52u,
  229u,
  229u,
  249u,
  8u,
  241u,
  241u,
  226u,
  147u,
  113u,
  113u,
  171u,
  115u,
  216u,
  216u,
  98u,
  83u,
  49u,
  49u,
  42u,
  63u,
  21u,
  21u,
  8u,
  12u,
  4u,
  4u,
  149u,
  82u,
  199u,
  199u,
  70u,
  101u,
  35u,
  35u,
  157u,
  94u,
  195u,
  195u,
  48u,
  40u,
  24u,
  24u,
  55u,
  161u,
  150u,
  150u,
  10u,
  15u,
  5u,
  5u,
  47u,
  181u,
  154u,
  154u,
  14u,
  9u,
  7u,
  7u,
  36u,
  54u,
  18u,
  18u,
  27u,
  155u,
  128u,
  128u,
  223u,
  61u,
  226u,
  226u,
  205u,
  38u,
  235u,
  235u,
  78u,
  105u,
  39u,
  39u,
  127u,
  205u,
  178u,
  178u,
  234u,
  159u,
  117u,
  117u,
  18u,
  27u,
  9u,
  9u,
  29u,
  158u,
  131u,
  131u,
  88u,
  116u,
  44u,
  44u,
  52u,
  46u,
  26u,
  26u,
  54u,
  45u,
  27u,
  27u,
  220u,
  178u,
  110u,
  110u,
  180u,
  238u,
  90u,
  90u,
  91u,
  251u,
  160u,
  160u,
  164u,
  246u,
  82u,
  82u,
  118u,
  77u,
  59u,
  59u,
  183u,
  97u,
  214u,
  214u,
  125u,
  206u,
  179u,
  179u,
  82u,
  123u,
  41u,
  41u,
  221u,
  62u,
  227u,
  227u,
  94u,
  113u,
  47u,
  47u,
  19u,
  151u,
  132u,
  132u,
  166u,
  245u,
  83u,
  83u,
  185u,
  104u,
  209u,
  209u,
  0u,
  0u,
  0u,
  0u,
  193u,
  44u,
  237u,
  237u,
  64u,
  96u,
  32u,
  32u,
  227u,
  31u,
  252u,
  252u,
  121u,
  200u,
  177u,
  177u,
  182u,
  237u,
  91u,
  91u,
  212u,
  190u,
  106u,
  106u,
  141u,
  70u,
  203u,
  203u,
  103u,
  217u,
  190u,
  190u,
  114u,
  75u,
  57u,
  57u,
  148u,
  222u,
  74u,
  74u,
  152u,
  212u,
  76u,
  76u,
  176u,
  232u,
  88u,
  88u,
  133u,
  74u,
  207u,
  207u,
  187u,
  107u,
  208u,
  208u,
  197u,
  42u,
  239u,
  239u,
  79u,
  229u,
  170u,
  170u,
  237u,
  22u,
  251u,
  251u,
  134u,
  197u,
  67u,
  67u,
  154u,
  215u,
  77u,
  77u,
  102u,
  85u,
  51u,
  51u,
  17u,
  148u,
  133u,
  133u,
  138u,
  207u,
  69u,
  69u,
  233u,
  16u,
  249u,
  249u,
  4u,
  6u,
  2u,
  2u,
  254u,
  129u,
  127u,
  127u,
  160u,
  240u,
  80u,
  80u,
  120u,
  68u,
  60u,
  60u,
  37u,
  186u,
  159u,
  159u,
  75u,
  227u,
  168u,
  168u,
  162u,
  243u,
  81u,
  81u,
  93u,
  254u,
  163u,
  163u,
  128u,
  192u,
  64u,
  64u,
  5u,
  138u,
  143u,
  143u,
  63u,
  173u,
  146u,
  146u,
  33u,
  188u,
  157u,
  157u,
  112u,
  72u,
  56u,
  56u,
  241u,
  4u,
  245u,
  245u,
  99u,
  223u,
  188u,
  188u,
  119u,
  193u,
  182u,
  182u,
  175u,
  117u,
  218u,
  218u,
  66u,
  99u,
  33u,
  33u,
  32u,
  48u,
  16u,
  16u,
  229u,
  26u,
  255u,
  255u,
  253u,
  14u,
  243u,
  243u,
  191u,
  109u,
  210u,
  210u,
  129u,
  76u,
  205u,
  205u,
  24u,
  20u,
  12u,
  12u,
  38u,
  53u,
  19u,
  19u,
  195u,
  47u,
  236u,
  236u,
  190u,
  225u,
  95u,
  95u,
  53u,
  162u,
  151u,
  151u,
  136u,
  204u,
  68u,
  68u,
  46u,
  57u,
  23u,
  23u,
  147u,
  87u,
  196u,
  196u,
  85u,
  242u,
  167u,
  167u,
  252u,
  130u,
  126u,
  126u,
  122u,
  71u,
  61u,
  61u,
  200u,
  172u,
  100u,
  100u,
  186u,
  231u,
  93u,
  93u,
  50u,
  43u,
  25u,
  25u,
  230u,
  149u,
  115u,
  115u,
  192u,
  160u,
  96u,
  96u,
  25u,
  152u,
  129u,
  129u,
  158u,
  209u,
  79u,
  79u,
  163u,
  127u,
  220u,
  220u,
  68u,
  102u,
  34u,
  34u,
  84u,
  126u,
  42u,
  42u,
  59u,
  171u,
  144u,
  144u,
  11u,
  131u,
  136u,
  136u,
  140u,
  202u,
  70u,
  70u,
  199u,
  41u,
  238u,
  238u,
  107u,
  211u,
  184u,
  184u,
  40u,
  60u,
  20u,
  20u,
  167u,
  121u,
  222u,
  222u,
  188u,
  226u,
  94u,
  94u,
  22u,
  29u,
  11u,
  11u,
  173u,
  118u,
  219u,
  219u,
  219u,
  59u,
  224u,
  224u,
  100u,
  86u,
  50u,
  50u,
  116u,
  78u,
  58u,
  58u,
  20u,
  30u,
  10u,
  10u,
  146u,
  219u,
  73u,
  73u,
  12u,
  10u,
  6u,
  6u,
  72u,
  108u,
  36u,
  36u,
  184u,
  228u,
  92u,
  92u,
  159u,
  93u,
  194u,
  194u,
  189u,
  110u,
  211u,
  211u,
  67u,
  239u,
  172u,
  172u,
  196u,
  166u,
  98u,
  98u,
  57u,
  168u,
  145u,
  145u,
  49u,
  164u,
  149u,
  149u,
  211u,
  55u,
  228u,
  228u,
  242u,
  139u,
  121u,
  121u,
  213u,
  50u,
  231u,
  231u,
  139u,
  67u,
  200u,
  200u,
  110u,
  89u,
  55u,
  55u,
  218u,
  183u,
  109u,
  109u,
  1u,
  140u,
  141u,
  141u,
  177u,
  100u,
  213u,
  213u,
  156u,
  210u,
  78u,
  78u,
  73u,
  224u,
  169u,
  169u,
  216u,
  180u,
  108u,
  108u,
  172u,
  250u,
  86u,
  86u,
  243u,
  7u,
  244u,
  244u,
  207u,
  37u,
  234u,
  234u,
  202u,
  175u,
  101u,
  101u,
  244u,
  142u,
  122u,
  122u,
  71u,
  233u,
  174u,
  174u,
  16u,
  24u,
  8u,
  8u,
  111u,
  213u,
  186u,
  186u,
  240u,
  136u,
  120u,
  120u,
  74u,
  111u,
  37u,
  37u,
  92u,
  114u,
  46u,
  46u,
  56u,
  36u,
  28u,
  28u,
  87u,
  241u,
  166u,
  166u,
  115u,
  199u,
  180u,
  180u,
  151u,
  81u,
  198u,
  198u,
  203u,
  35u,
  232u,
  232u,
  161u,
  124u,
  221u,
  221u,
  232u,
  156u,
  116u,
  116u,
  62u,
  33u,
  31u,
  31u,
  150u,
  221u,
  75u,
  75u,
  97u,
  220u,
  189u,
  189u,
  13u,
  134u,
  139u,
  139u,
  15u,
  133u,
  138u,
  138u,
  224u,
  144u,
  112u,
  112u,
  124u,
  66u,
  62u,
  62u,
  113u,
  196u,
  181u,
  181u,
  204u,
  170u,
  102u,
  102u,
  144u,
  216u,
  72u,
  72u,
  6u,
  5u,
  3u,
  3u,
  247u,
  1u,
  246u,
  246u,
  28u,
  18u,
  14u,
  14u,
  194u,
  163u,
  97u,
  97u,
  106u,
  95u,
  53u,
  53u,
  174u,
  249u,
  87u,
  87u,
  105u,
  208u,
  185u,
  185u,
  23u,
  145u,
  134u,
  134u,
  153u,
  88u,
  193u,
  193u,
  58u,
  39u,
  29u,
  29u,
  39u,
  185u,
  158u,
  158u,
  217u,
  56u,
  225u,
  225u,
  235u,
  19u,
  248u,
  248u,
  43u,
  179u,
  152u,
  152u,
  34u,
  51u,
  17u,
  17u,
  210u,
  187u,
  105u,
  105u,
  169u,
  112u,
  217u,
  217u,
  7u,
  137u,
  142u,
  142u,
  51u,
  167u,
  148u,
  148u,
  45u,
  182u,
  155u,
  155u,
  60u,
  34u,
  30u,
  30u,
  21u,
  146u,
  135u,
  135u,
  201u,
  32u,
  233u,
  233u,
  135u,
  73u,
  206u,
  206u,
  170u,
  255u,
  85u,
  85u,
  80u,
  120u,
  40u,
  40u,
  165u,
  122u,
  223u,
  223u,
  3u,
  143u,
  140u,
  140u,
  89u,
  248u,
  161u,
  161u,
  9u,
  128u,
  137u,
  137u,
  26u,
  23u,
  13u,
  13u,
  101u,
  218u,
  191u,
  191u,
  215u,
  49u,
  230u,
  230u,
  132u,
  198u,
  66u,
  66u,
  208u,
  184u,
  104u,
  104u,
  130u,
  195u,
  65u,
  65u,
  41u,
  176u,
  153u,
  153u,
  90u,
  119u,
  45u,
  45u,
  30u,
  17u,
  15u,
  15u,
  123u,
  203u,
  176u,
  176u,
  168u,
  252u,
  84u,
  84u,
  109u,
  214u,
  187u,
  187u,
  44u,
  58u,
  22u,
  22u
}; // weak
unsigned __int8 byte_75F0[1024] =
{
  165u,
  99u,
  99u,
  198u,
  132u,
  124u,
  124u,
  248u,
  153u,
  119u,
  119u,
  238u,
  141u,
  123u,
  123u,
  246u,
  13u,
  242u,
  242u,
  255u,
  189u,
  107u,
  107u,
  214u,
  177u,
  111u,
  111u,
  222u,
  84u,
  197u,
  197u,
  145u,
  80u,
  48u,
  48u,
  96u,
  3u,
  1u,
  1u,
  2u,
  169u,
  103u,
  103u,
  206u,
  125u,
  43u,
  43u,
  86u,
  25u,
  254u,
  254u,
  231u,
  98u,
  215u,
  215u,
  181u,
  230u,
  171u,
  171u,
  77u,
  154u,
  118u,
  118u,
  236u,
  69u,
  202u,
  202u,
  143u,
  157u,
  130u,
  130u,
  31u,
  64u,
  201u,
  201u,
  137u,
  135u,
  125u,
  125u,
  250u,
  21u,
  250u,
  250u,
  239u,
  235u,
  89u,
  89u,
  178u,
  201u,
  71u,
  71u,
  142u,
  11u,
  240u,
  240u,
  251u,
  236u,
  173u,
  173u,
  65u,
  103u,
  212u,
  212u,
  179u,
  253u,
  162u,
  162u,
  95u,
  234u,
  175u,
  175u,
  69u,
  191u,
  156u,
  156u,
  35u,
  247u,
  164u,
  164u,
  83u,
  150u,
  114u,
  114u,
  228u,
  91u,
  192u,
  192u,
  155u,
  194u,
  183u,
  183u,
  117u,
  28u,
  253u,
  253u,
  225u,
  174u,
  147u,
  147u,
  61u,
  106u,
  38u,
  38u,
  76u,
  90u,
  54u,
  54u,
  108u,
  65u,
  63u,
  63u,
  126u,
  2u,
  247u,
  247u,
  245u,
  79u,
  204u,
  204u,
  131u,
  92u,
  52u,
  52u,
  104u,
  244u,
  165u,
  165u,
  81u,
  52u,
  229u,
  229u,
  209u,
  8u,
  241u,
  241u,
  249u,
  147u,
  113u,
  113u,
  226u,
  115u,
  216u,
  216u,
  171u,
  83u,
  49u,
  49u,
  98u,
  63u,
  21u,
  21u,
  42u,
  12u,
  4u,
  4u,
  8u,
  82u,
  199u,
  199u,
  149u,
  101u,
  35u,
  35u,
  70u,
  94u,
  195u,
  195u,
  157u,
  40u,
  24u,
  24u,
  48u,
  161u,
  150u,
  150u,
  55u,
  15u,
  5u,
  5u,
  10u,
  181u,
  154u,
  154u,
  47u,
  9u,
  7u,
  7u,
  14u,
  54u,
  18u,
  18u,
  36u,
  155u,
  128u,
  128u,
  27u,
  61u,
  226u,
  226u,
  223u,
  38u,
  235u,
  235u,
  205u,
  105u,
  39u,
  39u,
  78u,
  205u,
  178u,
  178u,
  127u,
  159u,
  117u,
  117u,
  234u,
  27u,
  9u,
  9u,
  18u,
  158u,
  131u,
  131u,
  29u,
  116u,
  44u,
  44u,
  88u,
  46u,
  26u,
  26u,
  52u,
  45u,
  27u,
  27u,
  54u,
  178u,
  110u,
  110u,
  220u,
  238u,
  90u,
  90u,
  180u,
  251u,
  160u,
  160u,
  91u,
  246u,
  82u,
  82u,
  164u,
  77u,
  59u,
  59u,
  118u,
  97u,
  214u,
  214u,
  183u,
  206u,
  179u,
  179u,
  125u,
  123u,
  41u,
  41u,
  82u,
  62u,
  227u,
  227u,
  221u,
  113u,
  47u,
  47u,
  94u,
  151u,
  132u,
  132u,
  19u,
  245u,
  83u,
  83u,
  166u,
  104u,
  209u,
  209u,
  185u,
  0u,
  0u,
  0u,
  0u,
  44u,
  237u,
  237u,
  193u,
  96u,
  32u,
  32u,
  64u,
  31u,
  252u,
  252u,
  227u,
  200u,
  177u,
  177u,
  121u,
  237u,
  91u,
  91u,
  182u,
  190u,
  106u,
  106u,
  212u,
  70u,
  203u,
  203u,
  141u,
  217u,
  190u,
  190u,
  103u,
  75u,
  57u,
  57u,
  114u,
  222u,
  74u,
  74u,
  148u,
  212u,
  76u,
  76u,
  152u,
  232u,
  88u,
  88u,
  176u,
  74u,
  207u,
  207u,
  133u,
  107u,
  208u,
  208u,
  187u,
  42u,
  239u,
  239u,
  197u,
  229u,
  170u,
  170u,
  79u,
  22u,
  251u,
  251u,
  237u,
  197u,
  67u,
  67u,
  134u,
  215u,
  77u,
  77u,
  154u,
  85u,
  51u,
  51u,
  102u,
  148u,
  133u,
  133u,
  17u,
  207u,
  69u,
  69u,
  138u,
  16u,
  249u,
  249u,
  233u,
  6u,
  2u,
  2u,
  4u,
  129u,
  127u,
  127u,
  254u,
  240u,
  80u,
  80u,
  160u,
  68u,
  60u,
  60u,
  120u,
  186u,
  159u,
  159u,
  37u,
  227u,
  168u,
  168u,
  75u,
  243u,
  81u,
  81u,
  162u,
  254u,
  163u,
  163u,
  93u,
  192u,
  64u,
  64u,
  128u,
  138u,
  143u,
  143u,
  5u,
  173u,
  146u,
  146u,
  63u,
  188u,
  157u,
  157u,
  33u,
  72u,
  56u,
  56u,
  112u,
  4u,
  245u,
  245u,
  241u,
  223u,
  188u,
  188u,
  99u,
  193u,
  182u,
  182u,
  119u,
  117u,
  218u,
  218u,
  175u,
  99u,
  33u,
  33u,
  66u,
  48u,
  16u,
  16u,
  32u,
  26u,
  255u,
  255u,
  229u,
  14u,
  243u,
  243u,
  253u,
  109u,
  210u,
  210u,
  191u,
  76u,
  205u,
  205u,
  129u,
  20u,
  12u,
  12u,
  24u,
  53u,
  19u,
  19u,
  38u,
  47u,
  236u,
  236u,
  195u,
  225u,
  95u,
  95u,
  190u,
  162u,
  151u,
  151u,
  53u,
  204u,
  68u,
  68u,
  136u,
  57u,
  23u,
  23u,
  46u,
  87u,
  196u,
  196u,
  147u,
  242u,
  167u,
  167u,
  85u,
  130u,
  126u,
  126u,
  252u,
  71u,
  61u,
  61u,
  122u,
  172u,
  100u,
  100u,
  200u,
  231u,
  93u,
  93u,
  186u,
  43u,
  25u,
  25u,
  50u,
  149u,
  115u,
  115u,
  230u,
  160u,
  96u,
  96u,
  192u,
  152u,
  129u,
  129u,
  25u,
  209u,
  79u,
  79u,
  158u,
  127u,
  220u,
  220u,
  163u,
  102u,
  34u,
  34u,
  68u,
  126u,
  42u,
  42u,
  84u,
  171u,
  144u,
  144u,
  59u,
  131u,
  136u,
  136u,
  11u,
  202u,
  70u,
  70u,
  140u,
  41u,
  238u,
  238u,
  199u,
  211u,
  184u,
  184u,
  107u,
  60u,
  20u,
  20u,
  40u,
  121u,
  222u,
  222u,
  167u,
  226u,
  94u,
  94u,
  188u,
  29u,
  11u,
  11u,
  22u,
  118u,
  219u,
  219u,
  173u,
  59u,
  224u,
  224u,
  219u,
  86u,
  50u,
  50u,
  100u,
  78u,
  58u,
  58u,
  116u,
  30u,
  10u,
  10u,
  20u,
  219u,
  73u,
  73u,
  146u,
  10u,
  6u,
  6u,
  12u,
  108u,
  36u,
  36u,
  72u,
  228u,
  92u,
  92u,
  184u,
  93u,
  194u,
  194u,
  159u,
  110u,
  211u,
  211u,
  189u,
  239u,
  172u,
  172u,
  67u,
  166u,
  98u,
  98u,
  196u,
  168u,
  145u,
  145u,
  57u,
  164u,
  149u,
  149u,
  49u,
  55u,
  228u,
  228u,
  211u,
  139u,
  121u,
  121u,
  242u,
  50u,
  231u,
  231u,
  213u,
  67u,
  200u,
  200u,
  139u,
  89u,
  55u,
  55u,
  110u,
  183u,
  109u,
  109u,
  218u,
  140u,
  141u,
  141u,
  1u,
  100u,
  213u,
  213u,
  177u,
  210u,
  78u,
  78u,
  156u,
  224u,
  169u,
  169u,
  73u,
  180u,
  108u,
  108u,
  216u,
  250u,
  86u,
  86u,
  172u,
  7u,
  244u,
  244u,
  243u,
  37u,
  234u,
  234u,
  207u,
  175u,
  101u,
  101u,
  202u,
  142u,
  122u,
  122u,
  244u,
  233u,
  174u,
  174u,
  71u,
  24u,
  8u,
  8u,
  16u,
  213u,
  186u,
  186u,
  111u,
  136u,
  120u,
  120u,
  240u,
  111u,
  37u,
  37u,
  74u,
  114u,
  46u,
  46u,
  92u,
  36u,
  28u,
  28u,
  56u,
  241u,
  166u,
  166u,
  87u,
  199u,
  180u,
  180u,
  115u,
  81u,
  198u,
  198u,
  151u,
  35u,
  232u,
  232u,
  203u,
  124u,
  221u,
  221u,
  161u,
  156u,
  116u,
  116u,
  232u,
  33u,
  31u,
  31u,
  62u,
  221u,
  75u,
  75u,
  150u,
  220u,
  189u,
  189u,
  97u,
  134u,
  139u,
  139u,
  13u,
  133u,
  138u,
  138u,
  15u,
  144u,
  112u,
  112u,
  224u,
  66u,
  62u,
  62u,
  124u,
  196u,
  181u,
  181u,
  113u,
  170u,
  102u,
  102u,
  204u,
  216u,
  72u,
  72u,
  144u,
  5u,
  3u,
  3u,
  6u,
  1u,
  246u,
  246u,
  247u,
  18u,
  14u,
  14u,
  28u,
  163u,
  97u,
  97u,
  194u,
  95u,
  53u,
  53u,
  106u,
  249u,
  87u,
  87u,
  174u,
  208u,
  185u,
  185u,
  105u,
  145u,
  134u,
  134u,
  23u,
  88u,
  193u,
  193u,
  153u,
  39u,
  29u,
  29u,
  58u,
  185u,
  158u,
  158u,
  39u,
  56u,
  225u,
  225u,
  217u,
  19u,
  248u,
  248u,
  235u,
  179u,
  152u,
  152u,
  43u,
  51u,
  17u,
  17u,
  34u,
  187u,
  105u,
  105u,
  210u,
  112u,
  217u,
  217u,
  169u,
  137u,
  142u,
  142u,
  7u,
  167u,
  148u,
  148u,
  51u,
  182u,
  155u,
  155u,
  45u,
  34u,
  30u,
  30u,
  60u,
  146u,
  135u,
  135u,
  21u,
  32u,
  233u,
  233u,
  201u,
  73u,
  206u,
  206u,
  135u,
  255u,
  85u,
  85u,
  170u,
  120u,
  40u,
  40u,
  80u,
  122u,
  223u,
  223u,
  165u,
  143u,
  140u,
  140u,
  3u,
  248u,
  161u,
  161u,
  89u,
  128u,
  137u,
  137u,
  9u,
  23u,
  13u,
  13u,
  26u,
  218u,
  191u,
  191u,
  101u,
  49u,
  230u,
  230u,
  215u,
  198u,
  66u,
  66u,
  132u,
  184u,
  104u,
  104u,
  208u,
  195u,
  65u,
  65u,
  130u,
  176u,
  153u,
  153u,
  41u,
  119u,
  45u,
  45u,
  90u,
  17u,
  15u,
  15u,
  30u,
  203u,
  176u,
  176u,
  123u,
  252u,
  84u,
  84u,
  168u,
  214u,
  187u,
  187u,
  109u,
  58u,
  22u,
  22u,
  44u
}; // weak
unsigned __int8 byte_79F0[1024] =
{
  99u,
  99u,
  198u,
  165u,
  124u,
  124u,
  248u,
  132u,
  119u,
  119u,
  238u,
  153u,
  123u,
  123u,
  246u,
  141u,
  242u,
  242u,
  255u,
  13u,
  107u,
  107u,
  214u,
  189u,
  111u,
  111u,
  222u,
  177u,
  197u,
  197u,
  145u,
  84u,
  48u,
  48u,
  96u,
  80u,
  1u,
  1u,
  2u,
  3u,
  103u,
  103u,
  206u,
  169u,
  43u,
  43u,
  86u,
  125u,
  254u,
  254u,
  231u,
  25u,
  215u,
  215u,
  181u,
  98u,
  171u,
  171u,
  77u,
  230u,
  118u,
  118u,
  236u,
  154u,
  202u,
  202u,
  143u,
  69u,
  130u,
  130u,
  31u,
  157u,
  201u,
  201u,
  137u,
  64u,
  125u,
  125u,
  250u,
  135u,
  250u,
  250u,
  239u,
  21u,
  89u,
  89u,
  178u,
  235u,
  71u,
  71u,
  142u,
  201u,
  240u,
  240u,
  251u,
  11u,
  173u,
  173u,
  65u,
  236u,
  212u,
  212u,
  179u,
  103u,
  162u,
  162u,
  95u,
  253u,
  175u,
  175u,
  69u,
  234u,
  156u,
  156u,
  35u,
  191u,
  164u,
  164u,
  83u,
  247u,
  114u,
  114u,
  228u,
  150u,
  192u,
  192u,
  155u,
  91u,
  183u,
  183u,
  117u,
  194u,
  253u,
  253u,
  225u,
  28u,
  147u,
  147u,
  61u,
  174u,
  38u,
  38u,
  76u,
  106u,
  54u,
  54u,
  108u,
  90u,
  63u,
  63u,
  126u,
  65u,
  247u,
  247u,
  245u,
  2u,
  204u,
  204u,
  131u,
  79u,
  52u,
  52u,
  104u,
  92u,
  165u,
  165u,
  81u,
  244u,
  229u,
  229u,
  209u,
  52u,
  241u,
  241u,
  249u,
  8u,
  113u,
  113u,
  226u,
  147u,
  216u,
  216u,
  171u,
  115u,
  49u,
  49u,
  98u,
  83u,
  21u,
  21u,
  42u,
  63u,
  4u,
  4u,
  8u,
  12u,
  199u,
  199u,
  149u,
  82u,
  35u,
  35u,
  70u,
  101u,
  195u,
  195u,
  157u,
  94u,
  24u,
  24u,
  48u,
  40u,
  150u,
  150u,
  55u,
  161u,
  5u,
  5u,
  10u,
  15u,
  154u,
  154u,
  47u,
  181u,
  7u,
  7u,
  14u,
  9u,
  18u,
  18u,
  36u,
  54u,
  128u,
  128u,
  27u,
  155u,
  226u,
  226u,
  223u,
  61u,
  235u,
  235u,
  205u,
  38u,
  39u,
  39u,
  78u,
  105u,
  178u,
  178u,
  127u,
  205u,
  117u,
  117u,
  234u,
  159u,
  9u,
  9u,
  18u,
  27u,
  131u,
  131u,
  29u,
  158u,
  44u,
  44u,
  88u,
  116u,
  26u,
  26u,
  52u,
  46u,
  27u,
  27u,
  54u,
  45u,
  110u,
  110u,
  220u,
  178u,
  90u,
  90u,
  180u,
  238u,
  160u,
  160u,
  91u,
  251u,
  82u,
  82u,
  164u,
  246u,
  59u,
  59u,
  118u,
  77u,
  214u,
  214u,
  183u,
  97u,
  179u,
  179u,
  125u,
  206u,
  41u,
  41u,
  82u,
  123u,
  227u,
  227u,
  221u,
  62u,
  47u,
  47u,
  94u,
  113u,
  132u,
  132u,
  19u,
  151u,
  83u,
  83u,
  166u,
  245u,
  209u,
  209u,
  185u,
  104u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  193u,
  44u,
  32u,
  32u,
  64u,
  96u,
  252u,
  252u,
  227u,
  31u,
  177u,
  177u,
  121u,
  200u,
  91u,
  91u,
  182u,
  237u,
  106u,
  106u,
  212u,
  190u,
  203u,
  203u,
  141u,
  70u,
  190u,
  190u,
  103u,
  217u,
  57u,
  57u,
  114u,
  75u,
  74u,
  74u,
  148u,
  222u,
  76u,
  76u,
  152u,
  212u,
  88u,
  88u,
  176u,
  232u,
  207u,
  207u,
  133u,
  74u,
  208u,
  208u,
  187u,
  107u,
  239u,
  239u,
  197u,
  42u,
  170u,
  170u,
  79u,
  229u,
  251u,
  251u,
  237u,
  22u,
  67u,
  67u,
  134u,
  197u,
  77u,
  77u,
  154u,
  215u,
  51u,
  51u,
  102u,
  85u,
  133u,
  133u,
  17u,
  148u,
  69u,
  69u,
  138u,
  207u,
  249u,
  249u,
  233u,
  16u,
  2u,
  2u,
  4u,
  6u,
  127u,
  127u,
  254u,
  129u,
  80u,
  80u,
  160u,
  240u,
  60u,
  60u,
  120u,
  68u,
  159u,
  159u,
  37u,
  186u,
  168u,
  168u,
  75u,
  227u,
  81u,
  81u,
  162u,
  243u,
  163u,
  163u,
  93u,
  254u,
  64u,
  64u,
  128u,
  192u,
  143u,
  143u,
  5u,
  138u,
  146u,
  146u,
  63u,
  173u,
  157u,
  157u,
  33u,
  188u,
  56u,
  56u,
  112u,
  72u,
  245u,
  245u,
  241u,
  4u,
  188u,
  188u,
  99u,
  223u,
  182u,
  182u,
  119u,
  193u,
  218u,
  218u,
  175u,
  117u,
  33u,
  33u,
  66u,
  99u,
  16u,
  16u,
  32u,
  48u,
  255u,
  255u,
  229u,
  26u,
  243u,
  243u,
  253u,
  14u,
  210u,
  210u,
  191u,
  109u,
  205u,
  205u,
  129u,
  76u,
  12u,
  12u,
  24u,
  20u,
  19u,
  19u,
  38u,
  53u,
  236u,
  236u,
  195u,
  47u,
  95u,
  95u,
  190u,
  225u,
  151u,
  151u,
  53u,
  162u,
  68u,
  68u,
  136u,
  204u,
  23u,
  23u,
  46u,
  57u,
  196u,
  196u,
  147u,
  87u,
  167u,
  167u,
  85u,
  242u,
  126u,
  126u,
  252u,
  130u,
  61u,
  61u,
  122u,
  71u,
  100u,
  100u,
  200u,
  172u,
  93u,
  93u,
  186u,
  231u,
  25u,
  25u,
  50u,
  43u,
  115u,
  115u,
  230u,
  149u,
  96u,
  96u,
  192u,
  160u,
  129u,
  129u,
  25u,
  152u,
  79u,
  79u,
  158u,
  209u,
  220u,
  220u,
  163u,
  127u,
  34u,
  34u,
  68u,
  102u,
  42u,
  42u,
  84u,
  126u,
  144u,
  144u,
  59u,
  171u,
  136u,
  136u,
  11u,
  131u,
  70u,
  70u,
  140u,
  202u,
  238u,
  238u,
  199u,
  41u,
  184u,
  184u,
  107u,
  211u,
  20u,
  20u,
  40u,
  60u,
  222u,
  222u,
  167u,
  121u,
  94u,
  94u,
  188u,
  226u,
  11u,
  11u,
  22u,
  29u,
  219u,
  219u,
  173u,
  118u,
  224u,
  224u,
  219u,
  59u,
  50u,
  50u,
  100u,
  86u,
  58u,
  58u,
  116u,
  78u,
  10u,
  10u,
  20u,
  30u,
  73u,
  73u,
  146u,
  219u,
  6u,
  6u,
  12u,
  10u,
  36u,
  36u,
  72u,
  108u,
  92u,
  92u,
  184u,
  228u,
  194u,
  194u,
  159u,
  93u,
  211u,
  211u,
  189u,
  110u,
  172u,
  172u,
  67u,
  239u,
  98u,
  98u,
  196u,
  166u,
  145u,
  145u,
  57u,
  168u,
  149u,
  149u,
  49u,
  164u,
  228u,
  228u,
  211u,
  55u,
  121u,
  121u,
  242u,
  139u,
  231u,
  231u,
  213u,
  50u,
  200u,
  200u,
  139u,
  67u,
  55u,
  55u,
  110u,
  89u,
  109u,
  109u,
  218u,
  183u,
  141u,
  141u,
  1u,
  140u,
  213u,
  213u,
  177u,
  100u,
  78u,
  78u,
  156u,
  210u,
  169u,
  169u,
  73u,
  224u,
  108u,
  108u,
  216u,
  180u,
  86u,
  86u,
  172u,
  250u,
  244u,
  244u,
  243u,
  7u,
  234u,
  234u,
  207u,
  37u,
  101u,
  101u,
  202u,
  175u,
  122u,
  122u,
  244u,
  142u,
  174u,
  174u,
  71u,
  233u,
  8u,
  8u,
  16u,
  24u,
  186u,
  186u,
  111u,
  213u,
  120u,
  120u,
  240u,
  136u,
  37u,
  37u,
  74u,
  111u,
  46u,
  46u,
  92u,
  114u,
  28u,
  28u,
  56u,
  36u,
  166u,
  166u,
  87u,
  241u,
  180u,
  180u,
  115u,
  199u,
  198u,
  198u,
  151u,
  81u,
  232u,
  232u,
  203u,
  35u,
  221u,
  221u,
  161u,
  124u,
  116u,
  116u,
  232u,
  156u,
  31u,
  31u,
  62u,
  33u,
  75u,
  75u,
  150u,
  221u,
  189u,
  189u,
  97u,
  220u,
  139u,
  139u,
  13u,
  134u,
  138u,
  138u,
  15u,
  133u,
  112u,
  112u,
  224u,
  144u,
  62u,
  62u,
  124u,
  66u,
  181u,
  181u,
  113u,
  196u,
  102u,
  102u,
  204u,
  170u,
  72u,
  72u,
  144u,
  216u,
  3u,
  3u,
  6u,
  5u,
  246u,
  246u,
  247u,
  1u,
  14u,
  14u,
  28u,
  18u,
  97u,
  97u,
  194u,
  163u,
  53u,
  53u,
  106u,
  95u,
  87u,
  87u,
  174u,
  249u,
  185u,
  185u,
  105u,
  208u,
  134u,
  134u,
  23u,
  145u,
  193u,
  193u,
  153u,
  88u,
  29u,
  29u,
  58u,
  39u,
  158u,
  158u,
  39u,
  185u,
  225u,
  225u,
  217u,
  56u,
  248u,
  248u,
  235u,
  19u,
  152u,
  152u,
  43u,
  179u,
  17u,
  17u,
  34u,
  51u,
  105u,
  105u,
  210u,
  187u,
  217u,
  217u,
  169u,
  112u,
  142u,
  142u,
  7u,
  137u,
  148u,
  148u,
  51u,
  167u,
  155u,
  155u,
  45u,
  182u,
  30u,
  30u,
  60u,
  34u,
  135u,
  135u,
  21u,
  146u,
  233u,
  233u,
  201u,
  32u,
  206u,
  206u,
  135u,
  73u,
  85u,
  85u,
  170u,
  255u,
  40u,
  40u,
  80u,
  120u,
  223u,
  223u,
  165u,
  122u,
  140u,
  140u,
  3u,
  143u,
  161u,
  161u,
  89u,
  248u,
  137u,
  137u,
  9u,
  128u,
  13u,
  13u,
  26u,
  23u,
  191u,
  191u,
  101u,
  218u,
  230u,
  230u,
  215u,
  49u,
  66u,
  66u,
  132u,
  198u,
  104u,
  104u,
  208u,
  184u,
  65u,
  65u,
  130u,
  195u,
  153u,
  153u,
  41u,
  176u,
  45u,
  45u,
  90u,
  119u,
  15u,
  15u,
  30u,
  17u,
  176u,
  176u,
  123u,
  203u,
  84u,
  84u,
  168u,
  252u,
  187u,
  187u,
  109u,
  214u,
  22u,
  22u,
  44u,
  58u
}; // weak
_UNKNOWN unk_7DF0; // weak
_DWORD dword_7E18[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
_DWORD dword_8218[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
_DWORD dword_8618[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
_DWORD dword_8A18[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
unsigned __int8 byte_8E18[256] =
{
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u
}; // weak
_UNKNOWN *off_1FA80 = &off_1FA80; // weak
char *off_1FA88[4] = { "w+b", "r+b", "rb", "ab" }; // weak
__int64 qword_24098; // weak
__int64 qword_240A0; // weak
__int64 qword_240A8; // weak
__int64 qword_240B0; // weak
int dword_240B8; // weak
__int16 word_240C0[]; // weak
__int128 xmmword_240D0; // weak
__int128 xmmword_240E0; // weak
__int128 xmmword_240F0; // weak
__int128 xmmword_24100; // weak
__int128 xmmword_24110; // weak
__int128 xmmword_24120; // weak
__int128 xmmword_24130; // weak
__int128 xmmword_24140; // weak
__int128 xmmword_24150; // weak
__int128 xmmword_24160; // weak
__int128 xmmword_24170; // weak
__int128 xmmword_24180; // weak
__int128 xmmword_24190; // weak
__int128 xmmword_241A0; // weak
__int128 xmmword_241B0; // weak
__int128 xmmword_241C0; // weak
__int128 xmmword_241D0; // weak
__int128 xmmword_241E0; // weak
__int128 xmmword_241F0; // weak
__int128 xmmword_24200; // weak
__int128 xmmword_24210; // weak
__int128 xmmword_24220; // weak
__int128 xmmword_24230; // weak
__int128 xmmword_24240; // weak
__int64 qword_24250; // weak
__int128 xmmword_2425A; // weak
__int128 xmmword_2426A; // weak
__int128 xmmword_2427A; // weak
__int128 xmmword_2428A; // weak
__int128 xmmword_2429A; // weak
__int128 xmmword_242AA; // weak
__int16 word_242BA; // weak
_QWORD qword_242F0[1]; // weak
__int128 xmmword_242F8; // weak
__int128 xmmword_24308; // weak
__int128 xmmword_24318; // weak
__int128 xmmword_24328; // weak
__int128 xmmword_24338; // weak
__int128 xmmword_24348; // weak
__int128 xmmword_24358; // weak
__int128 xmmword_24368; // weak
__int128 xmmword_24378; // weak
__int128 xmmword_24388; // weak
__int128 xmmword_24398; // weak
__int128 xmmword_243A8; // weak
__int128 xmmword_243B8; // weak
__int128 xmmword_243C8; // weak
__int128 xmmword_243D8; // weak
__int128 xmmword_243E8; // weak
__int128 xmmword_243F8; // weak
__int128 xmmword_24408; // weak
__int128 xmmword_24418; // weak
__int128 xmmword_24428; // weak
__int128 xmmword_24438; // weak
__int128 xmmword_24448; // weak
__int128 xmmword_24458; // weak
__int128 xmmword_24468; // weak
__int64 qword_24478; // weak
_UNKNOWN unk_24480; // weak
__int64 qword_244A0; // weak
__int64 qword_244A8; // weak


//----- (000000000000B6D8) ----------------------------------------------------
__int64 sub_B6D8()
{
  return __cxa_finalize(&off_1FA80);
}
// 1FA80: using guessed type _UNKNOWN *off_1FA80;

//----- (000000000000B6E8) ----------------------------------------------------
void sub_B6E8()
{
  ;
}

//----- (000000000000B6F0) ----------------------------------------------------
void sub_B6F0()
{
  sub_B6E8();
}

//----- (000000000000B6F8) ----------------------------------------------------
__int64 (*__fastcall sub_B6F8(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (000000000000B70C) ----------------------------------------------------
__int64 __fastcall sub_B70C(void *obj)
{
  return __cxa_atexit((void (*)(void *))sub_B6F8, obj, &off_1FA80);
}
// 1FA80: using guessed type _UNKNOWN *off_1FA80;

//----- (000000000000B728) ----------------------------------------------------
void printLogV()
{
  ;
}

//----- (000000000000B754) ----------------------------------------------------
void printLogI()
{
  ;
}

//----- (000000000000B780) ----------------------------------------------------
void printLogW()
{
  ;
}

//----- (000000000000B7AC) ----------------------------------------------------
void printLogF()
{
  ;
}

//----- (000000000000B7D8) ----------------------------------------------------
void printLogS()
{
  ;
}

//----- (000000000000B804) ----------------------------------------------------
void printLogE()
{
  ;
}

//----- (000000000000B830) ----------------------------------------------------
void printLogD()
{
  ;
}

//----- (000000000000B85C) ----------------------------------------------------
void printLogUNK()
{
  ;
}

//----- (000000000000B888) ----------------------------------------------------
FILE *__fastcall writeLog(const char *a1, const char *a2, const char *a3)
{
  FILE *result; // x0
  FILE *v7; // x19
  int v8; // w0
  int v9; // w0
  int v10; // w0
  int v11; // w0
  int v12; // w0
  int v13; // w0

  result = fopen("/drmInterface.log", "a");
  if ( result )
  {
    v7 = result;
    v8 = DHstrlen(a1);
    fwrite(a1, 1u, v8, v7);
    v9 = DHstrlen("\t");
    fwrite("\t", 1u, v9, v7);
    v10 = DHstrlen(a2);
    fwrite(a2, 1u, v10, v7);
    v11 = DHstrlen("\t");
    fwrite("\t", 1u, v11, v7);
    v12 = DHstrlen(a3);
    fwrite(a3, 1u, v12, v7);
    v13 = DHstrlen("\n");
    fwrite("\n", 1u, v13, v7);
    return (FILE *)fclose(v7);
  }
  return result;
}

//----- (000000000000B99C) ----------------------------------------------------
_BYTE *__fastcall GenerateTNA(_BYTE *result, _BYTE *a2)
{
  char v2; // w9
  char v3; // w9
  char v4; // w9
  char v5; // w9
  char v6; // w9

  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  v2 = a2[3];
  result[4] = 45;
  result[3] = v2;
  result[5] = a2[4];
  v3 = a2[5];
  result[7] = 45;
  result[6] = v3;
  result[8] = a2[6];
  v4 = a2[7];
  result[10] = 32;
  result[9] = v4;
  result[11] = a2[8];
  v5 = a2[9];
  result[13] = 58;
  result[12] = v5;
  result[14] = a2[10];
  v6 = a2[11];
  result[16] = 58;
  result[15] = v6;
  result[17] = a2[12];
  result[18] = a2[13];
  return result;
}

//----- (000000000000BA30) ----------------------------------------------------
__int64 __fastcall javaGetBytesEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x0
  __int64 v10; // x0
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64); // [xsp+18h] [xbp+18h]

  v5 = qword_24098;
  if ( !qword_24098 )
  {
    v7 = qword_240A0;
    if ( !qword_240A0 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v10 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v10);
      qword_240A0 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "getBytes",
           "(Ljava/lang/String;)[B");
    qword_24098 = v5;
    if ( !v5 )
      return 0;
  }
  v11 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v11(a1, a2, v5, v8);
}
// 24098: using guessed type __int64 qword_24098;
// 240A0: using guessed type __int64 qword_240A0;

//----- (000000000000BB2C) ----------------------------------------------------
__int64 __fastcall javaNewStringEncoding(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x22
  __int64 v7; // x1
  __int64 v8; // x23
  __int64 v9; // x0
  __int64 v11; // x0
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64, __int64); // [xsp+8h] [xbp-8h]

  v5 = qword_240A8;
  if ( !qword_240A8 )
  {
    v7 = qword_240A0;
    if ( !qword_240A0 )
    {
      v11 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
      if ( !v11 )
        return 0;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v11);
      qword_240A0 = v7;
      if ( !v7 )
        return 0;
    }
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
           a1,
           v7,
           "<init>",
           "([BLjava/lang/String;)V");
    qword_240A8 = v5;
    if ( !v5 )
      return 0;
  }
  v8 = qword_240A0;
  v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 224LL);
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL))(a1, a3);
  return v12(a1, v8, v5, a2, v9);
}
// 240A0: using guessed type __int64 qword_240A0;
// 240A8: using guessed type __int64 qword_240A8;

//----- (000000000000BC3C) ----------------------------------------------------
__int64 Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMInit()
{
  return (unsigned int)(__int16)DRM_Init();
}

//----- (000000000000BC58) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMOpenPath(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        int a5)
{
  __int64 v9; // x23
  int v10; // w0
  __int64 result; // x0
  int v12; // w24
  char v13; // [xsp+6h] [xbp-20Ah] BYREF
  char s[513]; // [xsp+7h] [xbp-209h] BYREF
  __int64 v15; // [xsp+208h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  if ( !a3 )
    return 4294957320LL;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1472LL))(a1, a3, &v13);
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a3);
  if ( v10 > 512 )
    return 4294957297LL;
  v12 = v10;
  DHmemcpy_s((__int64)s, 512, v9, v10);
  s[v12] = 0;
  __strlen_chk(s, 0x201u);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, a3, v9, 0);
  result = 4294957420LL;
  if ( (unsigned int)(a4 - 1) <= 3 && a5 == 1 )
    return (unsigned int)(__int16)DRM_Open_Path(s, a4, 1);
  return result;
}

//----- (000000000000BD98) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMOpenPfd(__int64 a1, __int64 a2, int a3, int a4, int a5)
{
  __int64 result; // x0

  if ( a3 < 1 )
    return 4294957320LL;
  result = 4294957420LL;
  if ( (unsigned int)(a4 - 1) <= 3 && a5 == 1 )
    return (unsigned int)(__int16)DRM_Open_Pfd(a3, a4, 1);
  return result;
}

//----- (000000000000BDE4) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMClose(__int64 a1, __int64 a2, __int16 a3)
{
  return (unsigned int)(__int16)DRM_Close(a3);
}

//----- (000000000000BE00) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfOpen(__int64 a1, __int64 a2, int a3, __int64 a4, int a5)
{
  __int64 v9; // x22
  __int16 v10; // w21
  char v12; // [xsp+7h] [xbp-9h] BYREF
  __int64 v13; // [xsp+8h] [xbp-8h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v9 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1472LL))(a1, a4, &v12);
  v10 = DRM_VF_Open(a3, v9, a5);
  if ( a4 )
    (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 1536LL))(a1, a4, v9, 2);
  return (unsigned int)v10;
}

//----- (000000000000BEB0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfSetFileSize(__int64 a1, __int64 a2, __int16 a3, int a4)
{
  return (unsigned int)(__int16)DRM_VF_SetFileSize(a3, a4);
}

//----- (000000000000BED0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfSetBuffer(
        __int64 a1,
        __int64 a2,
        __int16 a3,
        __int64 a4,
        int a5,
        int a6)
{
  __int64 v11; // x22
  __int16 v12; // w21
  char v14; // [xsp+7h] [xbp-9h] BYREF
  __int64 v15; // [xsp+8h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1472LL))(a1, a4, &v14);
  v12 = DRM_VF_SetBuffer(a3, v11, a5, a6);
  if ( a4 )
    (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 1536LL))(a1, a4, v11, 2);
  return (unsigned int)v12;
}

//----- (000000000000BF90) ----------------------------------------------------
bool __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfIsReachedToEndOfFile(__int64 a1, __int64 a2, __int16 a3)
{
  __int16 v5; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v6; // [xsp+8h] [xbp-8h]

  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v5 = 0;
  return (unsigned __int16)DRM_VF_IsReachedToEndOfFile(a3, &v5) == 1 && v5 == 1;
}

//----- (000000000000BFF4) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMVfShouldUpdateBuffer(__int64 a1, __int64 a2, __int16 a3)
{
  int ShouldUpdateBuffer; // w9
  _WORD v6[2]; // [xsp+0h] [xbp-10h] BYREF
  int v7; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v8; // [xsp+8h] [xbp-8h]

  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = 0;
  v6[0] = 0;
  ShouldUpdateBuffer = (unsigned __int16)DRM_VF_ShouldUpdateBuffer(a3, v6, &v7);
  if ( v6[0] == 1 && ShouldUpdateBuffer == 1 )
    return v7;
  else
    return -1;
}

//----- (000000000000C064) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMRead(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        signed int a5)
{
  char *v9; // x19
  int v10; // w20
  __int64 v11; // x23
  __int64 v12; // x0
  __int64 v13; // x0

  v9 = (char *)malloc(a5);
  v10 = DRM_Read(a3, v9, a5);
  if ( v10 >= 1 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(a1, (unsigned int)v10);
    (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, char *))(*(_QWORD *)a1 + 1664LL))(
      a1,
      v11,
      0,
      (unsigned int)v10,
      v9);
    v12 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 248LL))(a1, a4);
    v13 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
            a1,
            v12,
            "put",
            "([B)Ljava/nio/ByteBuffer;");
    if ( v13 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, a4, v13, v11);
      if ( !v11 )
        goto LABEL_5;
      goto LABEL_4;
    }
    v10 = -12;
    if ( v11 )
LABEL_4:
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 184LL))(a1, v11);
  }
LABEL_5:
  if ( v9 )
    free(v9);
  return v10;
}

//----- (000000000000C18C) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMSeek(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        int a4,
        int a5)
{
  int v6; // w2

  if ( (unsigned int)(a5 - 1) >= 3 )
    v6 = 0;
  else
    v6 = a5;
  return (int)DRM_Seek(a3, a4, v6);
}

//----- (000000000000C1B8) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetOriginalFileSize(__int64 a1, __int64 a2, __int16 a3)
{
  return (int)DRM_GetOriginalFileSize(a3);
}

//----- (000000000000C1D4) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetFileSize(__int64 a1, __int64 a2, __int16 a3)
{
  return (int)DRM_GetFileSize(a3);
}

//----- (000000000000C1F0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetErrorCode(__int64 a1, __int64 a2, __int16 a3)
{
  __int16 ContentInfo; // w8
  __int16 v4; // w20
  void *ptr[2]; // [xsp+0h] [xbp-10h] BYREF

  ptr[1] = *(void **)(_ReadStatusReg(TPIDR_EL0) + 40);
  ContentInfo = DRM_GetContentInfo(a3, (int **)ptr);
  if ( (ContentInfo & 0x8000) == 0 )
  {
    v4 = *((_WORD *)ptr[0] + 30);
LABEL_4:
    free(ptr[0]);
    return v4;
  }
  v4 = ContentInfo;
  if ( ptr[0] )
    goto LABEL_4;
  return v4;
}

//----- (000000000000C260) ----------------------------------------------------
FILE *__fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentIDPfd(__int64 a1, __int64 a2, int a3)
{
  FILE *result; // x0
  _BYTE *v5; // x2
  __int64 v6; // x2
  int v7; // t1
  _OWORD v8[2]; // [xsp+0h] [xbp-120h] BYREF
  __int64 v9; // [xsp+20h] [xbp-100h]
  _OWORD v10[6]; // [xsp+30h] [xbp-F0h] BYREF
  _BYTE ptr[128]; // [xsp+98h] [xbp-88h] BYREF
  __int64 v12; // [xsp+118h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v10, 0, sizeof(v10));
  result = DHfsPfdOpen(a3, 3);
  if ( result )
  {
    DHfsRead(result, ptr, 128);
    DHfsClose();
    v5 = &ptr[ptr[1]];
    v7 = *(_DWORD *)(v5 + 3);
    v6 = (__int64)(v5 + 3);
    if ( v7 == 979659107 )
    {
      DHmemcpy_s((__int64)v10, 96, v6, ptr[2]);
      return (FILE *)(*(__int64 (__fastcall **)(__int64, _OWORD *))(*(_QWORD *)a1 + 1336LL))(a1, v10);
    }
    else
    {
      v9 = 0;
      memset(v8, 0, sizeof(v8));
      DHmemcpy_s((__int64)v8, 5, v6, 4);
      return 0;
    }
  }
  return result;
}

//----- (000000000000C354) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentID(__int64 a1, __int64 a2, __int16 a3)
{
  int *v5; // [xsp+8h] [xbp-78h] BYREF
  _OWORD v6[6]; // [xsp+10h] [xbp-70h] BYREF
  __int64 v7; // [xsp+78h] [xbp-8h]

  v7 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v6, 0, sizeof(v6));
  if ( (DRM_GetContentInfo(a3, &v5) & 0x8000) != 0 )
    return 0;
  DHmemcpy_s((__int64)v6, v5[3] + 1, *((_QWORD *)v5 + 5), v5[3]);
  return (*(__int64 (__fastcall **)(__int64, _OWORD *))(*(_QWORD *)a1 + 1336LL))(a1, v6);
}

//----- (000000000000C3EC) ----------------------------------------------------
void *__fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetValidPeriod(__int64 a1, __int64 a2, __int16 a3)
{
  __int16 ContentInfo; // w8
  void *result; // x0
  int v6; // w20
  void *ptr; // [xsp+0h] [xbp-50h] BYREF
  char v8[4]; // [xsp+8h] [xbp-48h] BYREF
  char v9; // [xsp+Ch] [xbp-44h]
  __int16 v10; // [xsp+Dh] [xbp-43h]
  char v11; // [xsp+Fh] [xbp-41h]
  __int16 v12; // [xsp+10h] [xbp-40h]
  char v13; // [xsp+12h] [xbp-3Eh]
  __int16 v14; // [xsp+13h] [xbp-3Dh]
  char v15; // [xsp+15h] [xbp-3Bh]
  __int16 v16; // [xsp+16h] [xbp-3Ah]
  char v17; // [xsp+18h] [xbp-38h]
  __int16 v18; // [xsp+19h] [xbp-37h]
  int v19; // [xsp+28h] [xbp-28h] BYREF
  __int16 v20; // [xsp+2Ch] [xbp-24h]
  __int16 v21; // [xsp+2Eh] [xbp-22h]
  __int16 v22; // [xsp+30h] [xbp-20h]
  __int16 v23; // [xsp+32h] [xbp-1Eh]
  __int16 v24; // [xsp+34h] [xbp-1Ch]
  __int64 v25; // [xsp+48h] [xbp-8h]

  v25 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  ContentInfo = DRM_GetContentInfo(a3, (int **)&ptr);
  result = ptr;
  if ( ContentInfo < 0 )
  {
    if ( ptr )
    {
      free(ptr);
      return 0;
    }
  }
  else
  {
    v6 = strlen(*((const char **)ptr + 17));
    DHmemset(&v19, 0, 32);
    DHmemcpy_s((__int64)&v19, 32, *((_QWORD *)ptr + 17), v6);
    DHmemset(v8, 0, 32);
    v13 = 32;
    v10 = v20;
    *(_DWORD *)v8 = v19;
    v12 = v21;
    v9 = 45;
    v11 = 45;
    v16 = v23;
    v14 = v22;
    v15 = 58;
    v17 = 58;
    v18 = v24;
    __strlen_chk(v8, 0x20u);
    if ( ptr )
      free(ptr);
    return (void *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v8);
  }
  return result;
}

//----- (000000000000C520) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetContentDescription(__int64 *a1, __int64 a2, __int16 a3)
{
  __int64 v4; // x22
  int v5; // w9
  __int64 v6; // x9
  int *v8; // [xsp+0h] [xbp-110h] BYREF
  _BYTE v9[256]; // [xsp+8h] [xbp-108h] BYREF
  __int64 v10; // [xsp+108h] [xbp-8h]

  v10 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (DRM_GetContentInfo(a3, &v8) & 0x8000) != 0 )
    return 0;
  v4 = 0;
  do
    v5 = *(unsigned __int8 *)(*((_QWORD *)v8 + 11) + v4++);
  while ( (unsigned int)(v5 - 48) < 0xA );
  DHmemset(v9, 0, 256);
  DHmemcpy_s((__int64)v9, 256, *((_QWORD *)v8 + 11), v4 - 1);
  v6 = *a1;
  v9[v4 - 1] = 0;
  return (*(__int64 (__fastcall **)(__int64 *, _BYTE *))(v6 + 1336))(a1, v9);
}

//----- (000000000000C5F8) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetUnsupportedValue(
        __int64 a1,
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v7; // x23
  unsigned int v8; // w20
  int v9; // w0
  __int64 v10; // x20
  int DCFMetaDataEncodingType; // w8
  size_t v12; // x21
  __int64 v13; // x0
  _BYTE *v14; // x2
  __int64 v15; // x8
  __int64 v16; // x8
  __int64 v17; // x20
  __int64 v18; // x21
  __int64 v19; // x1
  __int64 (__fastcall *v20)(__int64, __int64, __int64, __int64); // x22
  __int64 v21; // x0
  __int64 v22; // x9
  _OWORD *v23; // x11
  _OWORD *v24; // x12
  __int128 v25; // q1
  __int64 v26; // x9
  __int64 v28; // x0
  _BYTE s[3]; // [xsp+8h] [xbp-1128h] BYREF
  unsigned __int16 v30; // [xsp+1008h] [xbp-128h] BYREF
  unsigned __int8 v31; // [xsp+100Ah] [xbp-126h]
  _BYTE v32[32]; // [xsp+1108h] [xbp-28h] BYREF
  __int64 v33; // [xsp+1128h] [xbp-8h]

  v33 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a4, 0);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a4);
  DHmemset(v32, 0, 32);
  v9 = DHstrncpy_s((__int64)v32, 32, v7, v8);
  v10 = 0;
  if ( !v9 )
  {
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, a4, v7);
    DHmemset(&v30, 0, 256);
    if ( (DRM_GetUnsupportedValue(a3, v32, &v30) & 0x8000) != 0 )
      goto LABEL_10;
    DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
    if ( DCFMetaDataEncodingType == 3 )
    {
      memset(s, 0, 0x1000u);
      v16 = 3;
      if ( v30 ^ 0xBBEF | v31 ^ 0xBF )
        v16 = 0;
      __strcpy_chk(s, (char *)&v30 + v16, 4096);
      v17 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 1336LL))(a1, s);
      v18 = qword_24098;
      if ( qword_24098
        || ((v19 = qword_240A0) != 0
         || (v28 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String")) != 0
         && (v19 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 168LL))(a1, v28),
             (qword_240A0 = v19) != 0))
        && (v18 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
                    a1,
                    v19,
                    "getBytes",
                    "(Ljava/lang/String;)[B"),
            (qword_24098 = v18) != 0) )
      {
        v20 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL);
        v21 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 1336LL))(a1, "ksc-5601");
        v10 = v20(a1, v17, v18, v21);
      }
      else
      {
        v10 = 0;
      }
      v14 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, v10, 0);
      goto LABEL_26;
    }
    if ( DCFMetaDataEncodingType )
    {
LABEL_10:
      v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1408LL))(a1, 1);
      v14 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, v10, 0);
      *v14 = 0;
    }
    else
    {
      v12 = __strlen_chk((const char *)&v30, 0x100u);
      v10 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 1408LL))(a1, (unsigned int)v12);
      v13 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, v10, 0);
      v14 = (_BYTE *)v13;
      if ( (__int64)v12 >= 1 )
      {
        v15 = 0;
        if ( v12 >= 8 && (unsigned __int64)(v13 - (_QWORD)&v30) >= 0x20 )
        {
          if ( v12 < 0x20 )
          {
            v15 = 0;
            goto LABEL_22;
          }
          v22 = 0;
          v15 = v12 & 0x7FFFFFFFFFFFFFE0LL;
          do
          {
            v23 = (_OWORD *)((char *)&v30 + v22);
            v24 = (_OWORD *)(v13 + v22);
            v22 += 32;
            v25 = v23[1];
            *v24 = *v23;
            v24[1] = v25;
          }
          while ( v15 != v22 );
          if ( v12 == v15 )
            goto LABEL_26;
          if ( (v12 & 0x18) != 0 )
          {
LABEL_22:
            v26 = v15;
            v15 = v12 & 0x7FFFFFFFFFFFFFF8LL;
            do
            {
              *(_QWORD *)(v13 + v26) = *(_QWORD *)((char *)&v30 + v26);
              v26 += 8;
            }
            while ( v15 != v26 );
            if ( v12 == v15 )
              goto LABEL_26;
            goto LABEL_25;
          }
        }
        do
        {
LABEL_25:
          *(_BYTE *)(v13 + v15) = *((_BYTE *)&v30 + v15);
          ++v15;
        }
        while ( v12 != v15 );
      }
    }
LABEL_26:
    (*(void (__fastcall **)(__int64, __int64, _BYTE *, _QWORD))(*(_QWORD *)a1 + 1536LL))(a1, v10, v14, 0);
  }
  return v10;
}
// 1B4B0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 24098: using guessed type __int64 qword_24098;
// 240A0: using guessed type __int64 qword_240A0;

//----- (000000000000C9C0) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetMetaDataCharacterSet(
        __int64 a1,
        __int64 a2,
        __int16 a3)
{
  return (unsigned int)(__int16)DRM_GetDCFMetaDataEncodingType(a3);
}

//----- (000000000000C9DC) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMGetUnsupportedValueUTF8(
        __int64 *a1,
        __int64 a2,
        __int16 a3,
        __int64 a4)
{
  __int64 v7; // x8
  __int64 v8; // x22
  signed int v9; // w0
  __int64 result; // x0
  int v11; // w0
  __int64 v12; // x8
  int DCFMetaDataEncodingType; // w8
  size_t v14; // x21
  __int64 v15; // x20
  __int64 v16; // x0
  __int64 v17; // x2
  __int64 v18; // x8
  _OWORD *v19; // x10
  __int128 *v20; // x9
  __int64 v21; // x11
  __int128 v22; // q0
  __int128 v23; // q1
  __int64 v24; // x11
  __int64 *v25; // x9
  _QWORD *v26; // x10
  size_t v27; // x11
  __int64 v28; // t1
  _BYTE *v29; // x9
  char *v30; // x10
  size_t v31; // x8
  char v32; // t1
  __int64 v33; // x21
  __int64 v34; // x1
  __int64 v35; // x22
  __int64 (__fastcall *v36)(__int64 *, __int64, __int64, __int64, __int64); // x24
  __int64 v37; // x0
  __int64 v38; // x21
  __int128 v39; // [xsp+0h] [xbp-130h] BYREF
  _OWORD v40[15]; // [xsp+10h] [xbp-120h] BYREF
  _OWORD v41[2]; // [xsp+100h] [xbp-30h] BYREF
  __int64 v42; // [xsp+128h] [xbp-8h]

  v42 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v7 = *a1;
  memset(v41, 0, sizeof(v41));
  v39 = 0u;
  memset(v40, 0, sizeof(v40));
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 1352))(a1, a4, 0);
  v9 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1312))(a1, a4);
  if ( v9 <= 0 || (unsigned int)v9 >= 0x21 )
    return (*(__int64 (__fastcall **)(__int64 *, void *))(*a1 + 1336))(a1, &unk_4C68);
  v11 = DHstrncpy_s((__int64)v41, 32, v8, v9);
  v12 = *a1;
  if ( v11 )
    return (*(__int64 (__fastcall **)(__int64 *, void *))(v12 + 1336))(a1, &unk_4C68);
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(v12 + 1360))(a1, a4, v8);
  if ( (DRM_GetUnsupportedValue(a3, v41, &v39) & 0x8000) != 0 )
    goto LABEL_13;
  DCFMetaDataEncodingType = (unsigned __int16)DRM_GetDCFMetaDataEncodingType(a3);
  if ( DCFMetaDataEncodingType == 3 )
    return (*(__int64 (__fastcall **)(__int64 *, __int128 *))(*a1 + 1336))(a1, &v39);
  if ( DCFMetaDataEncodingType )
  {
LABEL_13:
    v12 = *a1;
    return (*(__int64 (__fastcall **)(__int64 *, void *))(v12 + 1336))(a1, &unk_4C68);
  }
  v14 = __strlen_chk((const char *)&v39, 0x100u);
  v15 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*a1 + 1408))(a1, (unsigned int)v14);
  v16 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 1472))(a1, v15, 0);
  v17 = v16;
  if ( (__int64)v14 >= 1 )
  {
    v18 = 0;
    if ( v14 >= 8 && (unsigned __int64)(v16 - (_QWORD)&v39) >= 0x20 )
    {
      if ( v14 < 0x20 )
      {
        v18 = 0;
        goto LABEL_21;
      }
      v18 = v14 & 0x7FFFFFFFFFFFFFE0LL;
      v19 = (_OWORD *)(v16 + 16);
      v20 = v40;
      v21 = v14 & 0x7FFFFFFFFFFFFFE0LL;
      do
      {
        v22 = *(v20 - 1);
        v23 = *v20;
        v21 -= 32;
        v20 += 2;
        *(v19 - 1) = v22;
        *v19 = v23;
        v19 += 2;
      }
      while ( v21 );
      if ( v14 == v18 )
        goto LABEL_26;
      if ( (v14 & 0x18) != 0 )
      {
LABEL_21:
        v24 = v18;
        v18 = v14 & 0x7FFFFFFFFFFFFFF8LL;
        v25 = (__int64 *)((char *)&v40[-1] + v24);
        v26 = (_QWORD *)(v16 + v24);
        v27 = v24 - (v14 & 0x7FFFFFFFFFFFFFF8LL);
        do
        {
          v28 = *v25++;
          v27 += 8LL;
          *v26++ = v28;
        }
        while ( v27 );
        if ( v14 == v18 )
          goto LABEL_26;
      }
    }
    v29 = (_BYTE *)(v16 + v18);
    v30 = (char *)&v40[-1] + v18;
    v31 = v14 - v18;
    do
    {
      v32 = *v30++;
      --v31;
      *v29++ = v32;
    }
    while ( v31 );
  }
LABEL_26:
  if ( v15 )
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(*a1 + 1536))(a1, v15, v16, 0);
  v33 = qword_240A8;
  if ( qword_240A8 )
    goto LABEL_31;
  v34 = qword_240A0;
  if ( qword_240A0
    || (result = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 48))(a1, "java/lang/String", v17)) != 0
    && (result = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 168))(a1, result),
        v34 = result,
        (qword_240A0 = result) != 0) )
  {
    result = (*(__int64 (__fastcall **)(__int64 *, __int64, const char *, const char *))(*a1 + 264))(
               a1,
               v34,
               "<init>",
               "([BLjava/lang/String;)V");
    v33 = result;
    qword_240A8 = result;
    if ( result )
    {
LABEL_31:
      v35 = qword_240A0;
      v36 = *(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64, __int64))(*a1 + 224);
      v37 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(*a1 + 1336))(a1, "ksc-5601", v17);
      result = v36(a1, v35, v33, v15, v37);
    }
  }
  if ( v15 )
  {
    v38 = result;
    (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 184))(a1, v15);
    return v38;
  }
  return result;
}
// CCE4: variable 'v17' is possibly undefined
// 240A0: using guessed type __int64 qword_240A0;
// 240A8: using guessed type __int64 qword_240A8;

//----- (000000000000CD68) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckDCFFromPfd(__int64 a1, __int64 a2, int a3)
{
  const char *v5; // x0
  const char *v6; // x21

  v5 = (const char *)malloc(0x10u);
  if ( a3 < 1 )
    return 0;
  v6 = v5;
  *(_QWORD *)v5 = 0;
  *((_QWORD *)v5 + 1) = 0;
  DRM_CheckDCFFromPfd(a3, (__int64)v5);
  __strlen_chk(v6, 0x10u);
  return (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 1336LL))(a1, v6);
}

//----- (000000000000CDE4) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckDCF(__int64 *a1, __int64 a2, __int64 a3)
{
  void *v5; // x0
  __int64 v6; // x20
  __int64 v7; // x22
  int v8; // w23
  __int64 v9; // x8
  char v11; // [xsp+6h] [xbp-20Ah] BYREF
  char s[513]; // [xsp+7h] [xbp-209h] BYREF
  __int64 v13; // [xsp+208h] [xbp-8h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  v5 = malloc(0x10u);
  if ( !a3 )
    return 0;
  v6 = (__int64)v5;
  v7 = (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*a1 + 1472))(a1, a3, &v11);
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1368))(a1, a3);
  DHmemcpy_s((__int64)s, 512, v7, v8);
  v9 = *a1;
  s[v8] = 0;
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(v9 + 1536))(a1, a3, v7, 0);
  *(_QWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = 0;
  DRM_CheckDCF(s, v6);
  __strlen_chk((const char *)v6, 0x10u);
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1336))(a1, v6);
}

//----- (000000000000CF08) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckLyrics(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x21
  int v6; // w22
  __int64 v7; // x8
  FILE *v8; // x0
  FILE *v9; // x19
  size_t v10; // x19
  char v12; // [xsp+7h] [xbp-259h] BYREF
  char ptr; // [xsp+8h] [xbp-258h] BYREF
  unsigned __int8 v14; // [xsp+9h] [xbp-257h]
  _BYTE v15[5]; // [xsp+Bh] [xbp-255h] BYREF
  _BYTE s1[15]; // [xsp+48h] [xbp-218h] BYREF
  char s[513]; // [xsp+57h] [xbp-209h] BYREF
  __int64 v18; // [xsp+258h] [xbp-8h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  memset(s1, 0, sizeof(s1));
  if ( !a3 )
    return -9976;
  v5 = (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*a1 + 1472))(a1, a3, &v12);
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1368))(a1, a3);
  DHmemcpy_s((__int64)s, 512, v5, v6);
  v7 = *a1;
  s[v6] = 0;
  (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(v7 + 1536))(a1, a3, v5, 0);
  v8 = fopen(s, "r");
  if ( !v8 )
    return -3001;
  v9 = v8;
  fread(&ptr, 1u, 0x40u, v8);
  fclose(v9);
  v10 = v14;
  DHmemcpy_s((__int64)s1, 15, (__int64)v15, v14);
  if ( !memcmp(s1, "binary/x-lyric", v10) )
    return 0;
  else
    return -300;
}

//----- (000000000000D078) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMCheckLyricsFromPfd(__int64 a1, __int64 a2, int a3)
{
  FILE *v3; // x0
  size_t v4; // x19
  char ptr; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int8 v7; // [xsp+9h] [xbp-57h]
  _BYTE v8[5]; // [xsp+Bh] [xbp-55h] BYREF
  _QWORD s1[3]; // [xsp+48h] [xbp-18h] BYREF

  s1[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s1, 0, 15);
  if ( a3 < 1 )
    return -9976;
  v3 = DHfsPfdOpen(a3, 3);
  if ( (__int64)v3 < 1 )
    return -9976;
  DHfsRead(v3, &ptr, 64);
  DHfsClose();
  v4 = v7;
  DHmemcpy_s((__int64)s1, 15, (__int64)v8, v7);
  if ( !memcmp(s1, "binary/x-lyric", v4) )
    return 0;
  else
    return -300;
}

//----- (000000000000D140) ----------------------------------------------------
__int64 __fastcall Java_DigiCAP_SKT_DRM_MelonDRMInterface_DRMSetClientID(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v5; // w21
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x22
  int v9; // w0
  __int64 v10; // [xsp+8h] [xbp-18h] BYREF
  int v11; // [xsp+10h] [xbp-10h]
  __int64 v12; // [xsp+18h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11 = 0;
  v10 = 0;
  if ( !a3 )
    return -9976;
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  if ( v5 - 12 < 0xFFFFFFFE )
    return -9876;
  v8 = v6;
  v9 = DHstrncpy_s((__int64)&v10, 12, v6, v5);
  if ( v9 )
  {
    LODWORD(result) = StrErrorReturn(v9);
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, a3, v8);
    LODWORD(result) = DRM_SetClientID();
  }
  return (int)result;
}

//----- (000000000000D238) ----------------------------------------------------
__int64 __fastcall DRM_GetClientID(const char *a1, unsigned int *a2, __int64 a3)
{
  __int64 result; // x0
  unsigned int v4; // w19

  result = DHGetClientID_BySetVal(a1, a2, a3, (__int16 **)&qword_240B0);
  if ( (int)result <= 0 )
  {
    v4 = result;
    DHFreeClientID((void *)qword_240B0);
    result = v4;
    qword_240B0 = 0;
  }
  return result;
}
// 240B0: using guessed type __int64 qword_240B0;

//----- (000000000000D280) ----------------------------------------------------
__int64 DRM_SetClientID()
{
  int v0; // w19

  if ( !qword_240B0 )
    qword_240B0 = (__int64)DHmalloc(14);
  v0 = DA_DRA_SetClientID();
  if ( v0 <= 0 )
  {
    DHFreeClientID((void *)qword_240B0);
    return DRM_Init();
  }
  else
  {
    printLogD();
    return (unsigned int)v0;
  }
}
// 240B0: using guessed type __int64 qword_240B0;

//----- (000000000000D304) ----------------------------------------------------
__int64 DRM_Init()
{
  __int128 v1; // q0

  printLogD();
  if ( dword_240B8++ <= 0 )
  {
    DHmemset(&word_240C0, 0, 560);
    *(_QWORD *)&v1 = -1;
    *((_QWORD *)&v1 + 1) = -1;
    qword_24478 = 0;
    qword_24250 = -1;
    xmmword_240D0 = v1;
    xmmword_240E0 = v1;
    xmmword_240F0 = v1;
    xmmword_24100 = v1;
    xmmword_24110 = v1;
    xmmword_24120 = v1;
    xmmword_24130 = v1;
    xmmword_24140 = v1;
    xmmword_24150 = v1;
    xmmword_24160 = v1;
    xmmword_24170 = v1;
    xmmword_24180 = v1;
    xmmword_24190 = v1;
    xmmword_241A0 = v1;
    xmmword_241B0 = v1;
    xmmword_241C0 = v1;
    xmmword_241D0 = v1;
    xmmword_241E0 = v1;
    xmmword_241F0 = v1;
    xmmword_24200 = v1;
    xmmword_24210 = v1;
    xmmword_24220 = v1;
    xmmword_24230 = v1;
    xmmword_24240 = v1;
    *(_QWORD *)&v1 = 0x1000100010001LL;
    *((_QWORD *)&v1 + 1) = 0x1000100010001LL;
    xmmword_242F8 = 0u;
    xmmword_24308 = 0u;
    xmmword_24318 = 0u;
    xmmword_24328 = 0u;
    xmmword_24338 = 0u;
    xmmword_24348 = 0u;
    xmmword_24358 = 0u;
    xmmword_24368 = 0u;
    xmmword_24378 = 0u;
    xmmword_24388 = 0u;
    xmmword_24398 = 0u;
    xmmword_243A8 = 0u;
    xmmword_243B8 = 0u;
    xmmword_243C8 = 0u;
    xmmword_243D8 = 0u;
    xmmword_243E8 = 0u;
    xmmword_243F8 = 0u;
    xmmword_24408 = 0u;
    xmmword_24418 = 0u;
    xmmword_24428 = 0u;
    xmmword_24438 = 0u;
    xmmword_24448 = 0u;
    xmmword_24458 = 0u;
    xmmword_24468 = 0u;
    xmmword_2425A = v1;
    xmmword_2426A = v1;
    xmmword_2427A = v1;
    xmmword_2428A = v1;
    xmmword_2429A = v1;
    xmmword_242AA = v1;
    word_240C0 = 0;
    word_242BA = 1;
    printLogD();
  }
  return 0;
}
// 0: using guessed type int dword_0;
// 20: using guessed type __int64;
// 30: using guessed type int;
// 40: using guessed type int dword_40;
// 50: using guessed type int *[4];
// 1F8: using guessed type __int64;
// 240B8: using guessed type int dword_240B8;
// 240C0: using guessed type __int16 word_240C0;
// 240D0: using guessed type __int128 xmmword_240D0;
// 240E0: using guessed type __int128 xmmword_240E0;
// 240F0: using guessed type __int128 xmmword_240F0;
// 24100: using guessed type __int128 xmmword_24100;
// 24110: using guessed type __int128 xmmword_24110;
// 24120: using guessed type __int128 xmmword_24120;
// 24130: using guessed type __int128 xmmword_24130;
// 24140: using guessed type __int128 xmmword_24140;
// 24150: using guessed type __int128 xmmword_24150;
// 24160: using guessed type __int128 xmmword_24160;
// 24170: using guessed type __int128 xmmword_24170;
// 24180: using guessed type __int128 xmmword_24180;
// 24190: using guessed type __int128 xmmword_24190;
// 241A0: using guessed type __int128 xmmword_241A0;
// 241B0: using guessed type __int128 xmmword_241B0;
// 241C0: using guessed type __int128 xmmword_241C0;
// 241D0: using guessed type __int128 xmmword_241D0;
// 241E0: using guessed type __int128 xmmword_241E0;
// 241F0: using guessed type __int128 xmmword_241F0;
// 24200: using guessed type __int128 xmmword_24200;
// 24210: using guessed type __int128 xmmword_24210;
// 24220: using guessed type __int128 xmmword_24220;
// 24230: using guessed type __int128 xmmword_24230;
// 24240: using guessed type __int128 xmmword_24240;
// 24250: using guessed type __int64 qword_24250;
// 2425A: using guessed type __int128 xmmword_2425A;
// 2426A: using guessed type __int128 xmmword_2426A;
// 2427A: using guessed type __int128 xmmword_2427A;
// 2428A: using guessed type __int128 xmmword_2428A;
// 2429A: using guessed type __int128 xmmword_2429A;
// 242AA: using guessed type __int128 xmmword_242AA;
// 242BA: using guessed type __int16 word_242BA;
// 242F8: using guessed type __int128 xmmword_242F8;
// 24308: using guessed type __int128;
// 24318: using guessed type __int128 xmmword_24318;
// 24328: using guessed type __int128 xmmword_24328;
// 24338: using guessed type __int128 xmmword_24338;
// 24348: using guessed type __int128 xmmword_24348;
// 24358: using guessed type __int128 xmmword_24358;
// 24368: using guessed type __int128 xmmword_24368;
// 24378: using guessed type __int128 xmmword_24378;
// 24388: using guessed type __int128 xmmword_24388;
// 24398: using guessed type __int128 xmmword_24398;
// 243A8: using guessed type __int128 xmmword_243A8;
// 243B8: using guessed type __int128 xmmword_243B8;
// 243C8: using guessed type __int128 xmmword_243C8;
// 243D8: using guessed type __int128 xmmword_243D8;
// 243E8: using guessed type __int128 xmmword_243E8;
// 243F8: using guessed type __int128 xmmword_243F8;
// 24408: using guessed type __int128 xmmword_24408;
// 24418: using guessed type __int128 xmmword_24418;
// 24428: using guessed type __int128 xmmword_24428;
// 24438: using guessed type __int128 xmmword_24438;
// 24448: using guessed type __int128 xmmword_24448;
// 24458: using guessed type __int128 xmmword_24458;
// 24468: using guessed type __int128 xmmword_24468;
// 24478: using guessed type __int64 qword_24478;

//----- (000000000000D420) ----------------------------------------------------
void DRM_Destroy()
{
  __int64 i; // x19
  void **v2; // x0
  _QWORD *v3; // x24

  printLogD();
  word_240C0[0] = 0;
  if ( dword_240B8-- <= 1 )
  {
    for ( i = 0; i != 49; ++i )
    {
      *((_WORD *)&xmmword_2425A + i) = 32;
      v2 = (void **)qword_242F0[i + 1];
      *(_QWORD *)((char *)&xmmword_2425A + 8 * i - 394) = -1;
      if ( v2 )
      {
        v3 = &qword_242F0[i];
        if ( v2[66] )
        {
          DHfree(v2[66]);
          v2 = (void **)v3[1];
          v2[66] = 0;
        }
        DHfree(v2);
        v3[1] = 0;
      }
    }
    DHFreeClientID((void *)qword_240B0);
    qword_240B0 = 0;
    DHmemcount();
  }
}
// 240B0: using guessed type __int64 qword_240B0;
// 240B8: using guessed type int dword_240B8;
// 240C0: using guessed type __int16 word_240C0[];
// 2425A: using guessed type __int128 xmmword_2425A;
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000D514) ----------------------------------------------------
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3)
{
  unsigned int v6; // w19
  unsigned int v7; // w0
  __int16 *v8; // x27
  void *v9; // x0
  __int64 v10; // x20
  __int16 *v11; // x24
  _QWORD *v12; // x24
  __int64 v13; // t1
  int v14; // w0
  int v15; // w9
  void *v16; // x0
  __int16 v17; // w0
  _BYTE *v18; // x0
  __int16 v19; // w0
  int v20; // w21
  __int16 v21; // w0
  int v22; // w0
  __int64 v23; // x8
  int v24; // w10
  int v25; // w11
  int v26; // w9
  int v27; // w10
  int v28; // w3
  __int64 v29; // x2
  __int16 v30; // w8
  __int16 v31; // w8
  int v33; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v34; // [xsp+8h] [xbp-8h]

  v34 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  if ( word_240C0[0] == 50 )
  {
    return 65510;
  }
  else if ( a1 )
  {
    DHstrlen(a1);
    printLogD();
    v7 = DA_DRA_FileOpen(a1, a2, (__int64)word_240C0);
    if ( v7 << 16 )
    {
      v8 = &word_240C0[(__int16)v7];
      v6 = v7;
      printLogD();
      if ( (v8[204] & 1) != 0 )
      {
        printLogD();
        v9 = DHmalloc(880);
        if ( v9 )
        {
          v10 = (__int64)v9;
          DHmemset(v9, 0, 880);
          v11 = &word_240C0[4 * (__int16)v6];
          v13 = *((_QWORD *)v11 + 1);
          v12 = v11 + 4;
          *(_QWORD *)v10 = v13;
          DHmemset((void *)(v10 + 8), 0, 512);
          v14 = DHstrlen(a1);
          DHmemcpy_s(v10 + 8, 512, (__int64)a1, v14);
          v15 = *(_DWORD *)(v10 + 524);
          *(_DWORD *)(v10 + 520) = a2;
          *(_DWORD *)(v10 + 588) = 0;
          *(_DWORD *)(v10 + 524) = v15 | a3;
          *(_QWORD *)(v10 + 592) = 0;
          *(_QWORD *)(v10 + 664) = 0;
          *(_DWORD *)(v10 + 672) = 0;
          v16 = DHmalloc(256);
          *(_QWORD *)(v10 + 528) = v16;
          if ( v16 )
          {
            DHmemset(v16, 0, 256);
            DHmemset((void *)(v10 + 808), 0, 16);
            printLogD();
            v17 = DA_DRA_DCFParser(*(FILE **)v10, *(_QWORD *)(v10 + 528), &v33);
            if ( v17 < 0 )
            {
              v6 = v17;
              DA_DRA_DCFDestroy(*(_QWORD **)(v10 + 528));
              DHfree((void *)v10);
              DHfsClose();
              *v12 = -1;
              printLogD();
            }
            else
            {
              printLogD();
              v18 = *(_BYTE **)(*(_QWORD *)(v10 + 528) + 128LL);
              *(_DWORD *)(v10 + 832) = 0;
              *(_QWORD *)(v10 + 860) = 0;
              if ( !(unsigned int)DHstrnicmp(v18, byte_55D3, 4) || !*(_QWORD *)(*(_QWORD *)(v10 + 528) + 40LL) )
              {
                printLogD();
                v19 = sub_D950(v10);
                if ( v19 )
                {
                  v20 = v19;
                  printLogD();
                  *(_DWORD *)(v10 + 864) = v20;
                }
              }
              if ( *(_DWORD *)(v10 + 860) != 1 )
              {
                printLogD();
                v21 = ClusterAuthentication(
                        *(_BYTE **)(*(_QWORD *)(v10 + 528) + 40LL),
                        (__int64 *)(v10 + 824),
                        (__int64 *)(v10 + 840),
                        (__int64 **)(v10 + 848),
                        (_DWORD *)(v10 + 856),
                        (void **)&qword_240B0);
                if ( v21 )
                {
                  *(_DWORD *)(v10 + 864) = v21;
                  printLogD();
                }
              }
              v22 = DHfsTell();
              v23 = *(_QWORD *)(v10 + 528);
              *(_DWORD *)(v10 + 600) = v22;
              v24 = *(_DWORD *)(v23 + 80);
              v25 = *(_DWORD *)(v23 + 36);
              *(_QWORD *)(v10 + 628) = 0;
              *(_DWORD *)(v10 + 604) = 0;
              *(_QWORD *)(v10 + 608) = 0;
              if ( v24 )
                v26 = v24;
              else
                v26 = v25;
              *(_DWORD *)(v10 + 616) = v25;
              v27 = v33;
              *(_DWORD *)(v10 + 624) = v26;
              *(_DWORD *)(v10 + 620) = v26;
              v28 = *(_DWORD *)(v23 + 8);
              v29 = *(_QWORD *)(v23 + 24);
              *(_DWORD *)(v10 + 676) = v27;
              *(_DWORD *)(v10 + 636) = v28;
              DHmemcpy_s(v10 + 640, 21, v29, v28);
              v30 = word_240C0[0];
              qword_242F0[(__int16)v6] = v10;
              *(_QWORD *)(v10 + 872) = 0;
              word_240C0[0] = v30 + 1;
              v31 = v8[204];
              *(_DWORD *)(v10 + 868) = -1;
              v8[204] = v31 | 3;
            }
          }
          else
          {
            DHfree((void *)v10);
            DHfsClose();
            v6 = 65514;
            *v12 = -1;
          }
        }
        else
        {
          DHfsClose();
          *(_QWORD *)&word_240C0[4 * (__int16)v6 + 4] = -1;
          return 65514;
        }
      }
      else
      {
        DHfsClose();
        *(_QWORD *)&word_240C0[4 * (__int16)v6 + 4] = -1;
        return 65511;
      }
    }
    else
    {
      return 0xFFFF;
    }
  }
  else
  {
    printLogD();
    return 65523;
  }
  return v6;
}
// 55D3: using guessed type _BYTE byte_55D3[4];
// 240B0: using guessed type __int64 qword_240B0;
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000D950) ----------------------------------------------------
__int64 __fastcall sub_D950(__int64 a1)
{
  unsigned int v2; // w3
  int v3; // w0
  int v4; // w20
  unsigned int v6; // [xsp+Ch] [xbp-44h] BYREF
  _BYTE v7[51]; // [xsp+10h] [xbp-40h] BYREF
  __int64 v8; // [xsp+48h] [xbp-8h]

  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  *(_DWORD *)(a1 + 860) = 1;
  v6 = 50;
  memset(v7, 0, sizeof(v7));
  printLogD();
  if ( !qword_240B0 )
    qword_240B0 = (__int64)DHmalloc(8);
  if ( (int)DHGetClientID_BySetVal(
              *(const char **)(*(_QWORD *)(a1 + 528) + 128LL),
              &v6,
              (__int64)v7,
              (__int16 **)&qword_240B0) <= 0 )
  {
    DHFreeClientID((void *)qword_240B0);
    qword_240B0 = 0;
    printLogD();
    printLogD();
    return 65436;
  }
  else
  {
    printLogD();
    v2 = v6;
    *(_DWORD *)(a1 + 832) = 1;
    v3 = DHstrncpy_s(a1 + 536, 50, (__int64)v7, v2);
    if ( v3 )
    {
      v4 = v3;
      printLogD();
      return StrErrorReturn(v4);
    }
    else
    {
      *(_DWORD *)(a1 + 636) = v6;
      printLogD();
      printLogD();
      return 0;
    }
  }
}
// 240B0: using guessed type __int64 qword_240B0;

//----- (000000000000DAFC) ----------------------------------------------------
__int64 __fastcall DRM_VF_Open(int a1, __int64 a2, int a3)
{
  unsigned int v3; // w19
  unsigned int v7; // w0
  __int16 *v8; // x26
  __int64 *v9; // x26
  __int64 v10; // t1
  __int16 *v11; // x21
  void *v12; // x0
  __int64 v13; // x20
  __int64 v14; // x8
  void *v15; // x0
  __int16 v16; // w0
  _BYTE *v17; // x0
  __int16 v18; // w0
  __int16 v19; // w0
  int v20; // w0
  __int64 v21; // x8
  int v22; // w10
  int v23; // w11
  int v24; // w9
  int v25; // w10
  int v26; // w3
  __int64 v27; // x2
  __int16 v28; // w8
  __int16 v29; // w8
  int v31; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v32; // [xsp+8h] [xbp-8h]

  v32 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( word_240C0[0] == 50 )
    return 65510;
  v7 = DA_DRA_FileOpen("*", 3, (__int64)word_240C0);
  if ( !(_WORD)v7 )
    return 0xFFFF;
  v8 = &word_240C0[4 * (__int16)v7];
  v3 = v7;
  v10 = *((_QWORD *)v8 + 1);
  v9 = (__int64 *)(v8 + 4);
  if ( !(unsigned __int16)DHfs_VF_SetFileSize(v10, a1) )
    return 65498;
  if ( !(unsigned __int16)DHfs_VF_SetBuffer(*v9, a2, a3, 0) )
    return 65497;
  v11 = &word_240C0[(__int16)v3];
  if ( (v11[204] & 1) == 0 )
  {
    DHfsClose();
    v3 = 65511;
LABEL_27:
    *v9 = -1;
    return v3;
  }
  v12 = DHmalloc(880);
  if ( !v12 )
  {
LABEL_26:
    DHfsClose();
    v3 = 65514;
    goto LABEL_27;
  }
  v13 = (__int64)v12;
  DHmemset(v12, 0, 880);
  v14 = *v9;
  *(_DWORD *)(v13 + 588) = 0;
  *(_DWORD *)(v13 + 520) = 3;
  *(_QWORD *)v13 = v14;
  *(_QWORD *)(v13 + 592) = 0;
  *(_QWORD *)(v13 + 664) = 0;
  *(_DWORD *)(v13 + 672) = 0;
  v15 = DHmalloc(256);
  *(_QWORD *)(v13 + 528) = v15;
  if ( !v15 )
  {
    DHfree((void *)v13);
    goto LABEL_26;
  }
  DHmemset(v15, 0, 256);
  DHmemset((void *)(v13 + 808), 0, 16);
  v16 = DA_DRA_DCFParser(*(FILE **)v13, *(_QWORD *)(v13 + 528), &v31);
  if ( v16 < 0 )
  {
    v3 = v16;
    DA_DRA_DCFDestroy(*(_QWORD **)(v13 + 528));
    DHfree((void *)v13);
    DHfsClose();
    goto LABEL_27;
  }
  v17 = *(_BYTE **)(*(_QWORD *)(v13 + 528) + 128LL);
  *(_DWORD *)(v13 + 832) = 0;
  *(_QWORD *)(v13 + 860) = 0;
  if ( !(unsigned int)DHstrnicmp(v17, byte_55D3, 4) || !*(_QWORD *)(*(_QWORD *)(v13 + 528) + 40LL) )
  {
    v18 = sub_D950(v13);
    if ( v18 )
      *(_DWORD *)(v13 + 864) = v18;
  }
  if ( *(_DWORD *)(v13 + 860) != 1 )
  {
    v19 = ClusterAuthentication(
            *(_BYTE **)(*(_QWORD *)(v13 + 528) + 40LL),
            (__int64 *)(v13 + 824),
            (__int64 *)(v13 + 840),
            (__int64 **)(v13 + 848),
            (_DWORD *)(v13 + 856),
            (void **)&qword_240B0);
    if ( v19 )
      *(_DWORD *)(v13 + 864) = v19;
  }
  v20 = DHfsTell();
  v21 = *(_QWORD *)(v13 + 528);
  *(_DWORD *)(v13 + 600) = v20;
  v22 = *(_DWORD *)(v21 + 80);
  v23 = *(_DWORD *)(v21 + 36);
  *(_QWORD *)(v13 + 628) = 0;
  *(_DWORD *)(v13 + 604) = 0;
  *(_QWORD *)(v13 + 608) = 0;
  if ( v22 )
    v24 = v22;
  else
    v24 = v23;
  *(_DWORD *)(v13 + 616) = v23;
  v25 = v31;
  *(_DWORD *)(v13 + 624) = v24;
  *(_DWORD *)(v13 + 620) = v24;
  v26 = *(_DWORD *)(v21 + 8);
  v27 = *(_QWORD *)(v21 + 24);
  *(_DWORD *)(v13 + 676) = v25;
  *(_DWORD *)(v13 + 636) = v26;
  DHmemcpy_s(v13 + 640, 21, v27, v26);
  v28 = word_240C0[0];
  qword_242F0[(__int16)v3] = v13;
  *(_QWORD *)(v13 + 872) = 0;
  word_240C0[0] = v28 + 1;
  v29 = v11[204];
  *(_DWORD *)(v13 + 868) = -1;
  v11[204] = v29 | 3;
  return v3;
}
// 55D3: using guessed type _BYTE byte_55D3[4];
// 240B0: using guessed type __int64 qword_240B0;
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000DDF4) ----------------------------------------------------
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  unsigned int v6; // w19
  unsigned int v7; // w0
  __int16 *v8; // x26
  void *v9; // x0
  __int64 v10; // x20
  __int16 *v11; // x23
  _QWORD *v12; // x23
  __int64 v13; // t1
  int v14; // w9
  void *v15; // x0
  __int16 v16; // w0
  _BYTE *v17; // x0
  __int16 v18; // w0
  int v19; // w21
  __int16 v20; // w0
  int v21; // w0
  __int64 v22; // x8
  int v23; // w10
  int v24; // w11
  int v25; // w9
  int v26; // w10
  int v27; // w3
  __int64 v28; // x2
  __int16 v29; // w8
  __int16 v30; // w8
  int v32; // [xsp+4h] [xbp-Ch] BYREF
  __int64 v33; // [xsp+8h] [xbp-8h]

  v33 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  if ( word_240C0[0] == 50 )
  {
    return 65510;
  }
  else if ( a1 <= 0 )
  {
    printLogD();
    return 65523;
  }
  else
  {
    printLogD();
    v7 = DA_DRA_FilePfdOpen(a1, a2, (__int64)word_240C0);
    if ( (__int16)v7 < 1 )
    {
      return 0xFFFF;
    }
    else
    {
      v8 = &word_240C0[(__int16)v7];
      v6 = v7;
      printLogD();
      if ( (v8[204] & 1) != 0 )
      {
        printLogD();
        v9 = DHmalloc(880);
        if ( v9 )
        {
          v10 = (__int64)v9;
          DHmemset(v9, 0, 880);
          v11 = &word_240C0[4 * (__int16)v6];
          v13 = *((_QWORD *)v11 + 1);
          v12 = v11 + 4;
          *(_QWORD *)v10 = v13;
          DHmemset((void *)(v10 + 8), 0, 512);
          v14 = *(_DWORD *)(v10 + 524);
          *(_DWORD *)(v10 + 520) = a2;
          *(_DWORD *)(v10 + 588) = 0;
          *(_DWORD *)(v10 + 524) = v14 | a3;
          *(_QWORD *)(v10 + 592) = 0;
          *(_QWORD *)(v10 + 664) = 0;
          *(_DWORD *)(v10 + 672) = 0;
          v15 = DHmalloc(256);
          *(_QWORD *)(v10 + 528) = v15;
          if ( v15 )
          {
            DHmemset(v15, 0, 256);
            DHmemset((void *)(v10 + 808), 0, 16);
            printLogD();
            v16 = DA_DRA_DCFParser(*(FILE **)v10, *(_QWORD *)(v10 + 528), &v32);
            if ( v16 < 0 )
            {
              v6 = v16;
              DA_DRA_DCFDestroy(*(_QWORD **)(v10 + 528));
              DHfree((void *)v10);
              DHfsClose();
              *v12 = -1;
              printLogD();
            }
            else
            {
              printLogD();
              v17 = *(_BYTE **)(*(_QWORD *)(v10 + 528) + 128LL);
              *(_DWORD *)(v10 + 832) = 0;
              *(_QWORD *)(v10 + 860) = 0;
              if ( !(unsigned int)DHstrnicmp(v17, byte_55D3, 4) || !*(_QWORD *)(*(_QWORD *)(v10 + 528) + 40LL) )
              {
                printLogD();
                v18 = sub_D950(v10);
                if ( v18 )
                {
                  v19 = v18;
                  printLogD();
                  *(_DWORD *)(v10 + 864) = v19;
                }
              }
              if ( *(_DWORD *)(v10 + 860) != 1 )
              {
                printLogD();
                v20 = ClusterAuthentication(
                        *(_BYTE **)(*(_QWORD *)(v10 + 528) + 40LL),
                        (__int64 *)(v10 + 824),
                        (__int64 *)(v10 + 840),
                        (__int64 **)(v10 + 848),
                        (_DWORD *)(v10 + 856),
                        (void **)&qword_240B0);
                if ( v20 )
                {
                  *(_DWORD *)(v10 + 864) = v20;
                  printLogD();
                }
              }
              v21 = DHfsTell();
              v22 = *(_QWORD *)(v10 + 528);
              *(_DWORD *)(v10 + 600) = v21;
              v23 = *(_DWORD *)(v22 + 80);
              v24 = *(_DWORD *)(v22 + 36);
              *(_QWORD *)(v10 + 628) = 0;
              *(_DWORD *)(v10 + 604) = 0;
              *(_QWORD *)(v10 + 608) = 0;
              if ( v23 )
                v25 = v23;
              else
                v25 = v24;
              *(_DWORD *)(v10 + 616) = v24;
              v26 = v32;
              *(_DWORD *)(v10 + 624) = v25;
              *(_DWORD *)(v10 + 620) = v25;
              v27 = *(_DWORD *)(v22 + 8);
              v28 = *(_QWORD *)(v22 + 24);
              *(_DWORD *)(v10 + 676) = v26;
              *(_DWORD *)(v10 + 636) = v27;
              DHmemcpy_s(v10 + 640, 21, v28, v27);
              v29 = word_240C0[0];
              qword_242F0[(__int16)v6] = v10;
              *(_QWORD *)(v10 + 872) = 0;
              word_240C0[0] = v29 + 1;
              v30 = v8[204];
              *(_DWORD *)(v10 + 868) = -1;
              v8[204] = v30 | 3;
            }
          }
          else
          {
            DHfree((void *)v10);
            DHfsClose();
            v6 = 65514;
            *v12 = -1;
          }
        }
        else
        {
          DHfsClose();
          *(_QWORD *)&word_240C0[4 * (__int16)v6 + 4] = -1;
          return 65514;
        }
      }
      else
      {
        DHfsClose();
        *(_QWORD *)&word_240C0[4 * (__int16)v6 + 4] = -1;
        return 65511;
      }
    }
  }
  return v6;
}
// 55D3: using guessed type _BYTE byte_55D3[4];
// 240B0: using guessed type __int64 qword_240B0;
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000E204) ----------------------------------------------------
__int64 __fastcall DRM_Close(__int16 a1)
{
  __int16 *v1; // x20
  _QWORD *v2; // x20
  __int64 v3; // t1
  __int64 result; // x0
  __int64 v5; // x22
  __int64 v6; // x19
  void *v7; // x0
  void *v8; // x0
  __int64 v9; // x0
  __int16 v10; // w8

  if ( !a1 )
    return 65533;
  v1 = &word_240C0[4 * a1];
  v3 = *((_QWORD *)v1 + 1);
  v2 = v1 + 4;
  if ( (unsigned __int64)(v3 + 1) < 2 )
    return 65533;
  v5 = a1;
  v6 = qword_242F0[a1];
  DA_DRA_DCFDestroy(*(_QWORD **)(v6 + 528));
  v7 = *(void **)(v6 + 872);
  if ( v7 )
    DHfree(v7);
  ClientIDDestroy(*(_QWORD **)(v6 + 824));
  v8 = *(void **)(v6 + 840);
  if ( v8 )
    DHfree(v8);
  v9 = *(_QWORD *)(v6 + 848);
  if ( v9 )
    DomainListDestroy(v9);
  DHfree((void *)v6);
  qword_242F0[v5] = 0;
  DHfsClose();
  result = 0;
  v10 = word_240C0[0] - 1;
  *v2 = -1;
  word_240C0[0] = v10;
  word_240C0[v5 + 204] = word_240C0[v5 + 204] & 0xFFED | 0x10;
  return result;
}
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000E2E4) ----------------------------------------------------
__int64 __fastcall DRM_VF_SetFileSize(__int16 a1, int a2)
{
  return DHfs_VF_SetFileSize(*(_QWORD *)&word_240C0[4 * a1 + 4], a2);
}
// 240C0: using guessed type __int16 word_240C0[];

//----- (000000000000E2F8) ----------------------------------------------------
__int64 __fastcall DRM_VF_SetBuffer(__int16 a1, __int64 a2, int a3, int a4)
{
  return DHfs_VF_SetBuffer(*(_QWORD *)&word_240C0[4 * a1 + 4], a2, a3, a4);
}
// 240C0: using guessed type __int16 word_240C0[];

//----- (000000000000E30C) ----------------------------------------------------
__int64 __fastcall DRM_VF_IsReachedToEndOfFile(__int16 a1, _WORD *a2)
{
  return DHfs_VF_IsReachedToEndOfFile(*(_QWORD *)&word_240C0[4 * a1 + 4], a2);
}
// 240C0: using guessed type __int16 word_240C0[];

//----- (000000000000E320) ----------------------------------------------------
__int64 __fastcall DRM_VF_ShouldUpdateBuffer(__int16 a1, _WORD *a2, _DWORD *a3)
{
  return DHfs_VF_ShouldUpdateBuffer(*(_QWORD *)&word_240C0[4 * a1 + 4], a2, a3);
}
// 240C0: using guessed type __int16 word_240C0[];

//----- (000000000000E334) ----------------------------------------------------
size_t __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3)
{
  __int64 v4; // x27
  __int64 v5; // x8
  int v6; // w9
  __int64 v7; // x19
  int v8; // w8
  int v9; // w20
  int v10; // w21
  __int64 v11; // x22
  char *v12; // x26
  FILE **v13; // x23
  int v14; // w0
  int v15; // w11
  int v16; // w27
  int v17; // w24
  int v18; // w28
  int v19; // w9
  char *v20; // x1
  unsigned int v21; // w8
  int v22; // w2
  size_t result; // x0
  unsigned int v24; // w8
  int v25; // w10
  __int64 v26; // x11
  char *v27; // x12
  int v28; // w9
  _BYTE *v29; // x14
  char v30; // w13
  unsigned int v31; // w14
  char *v32; // x22
  signed int v33; // w20
  __int16 v34; // w0
  __int64 v35; // x8
  signed int v36; // w28
  FILE **v37; // x26
  int v38; // w0
  int v39; // w8
  int v40; // w19
  int v41; // w20
  int v42; // w22
  int8x16_t *v43; // x0
  int8x16_t *v44; // x21
  int v45; // w0
  int *v46; // x9
  int v47; // w26
  int v48; // w9
  int v49; // w10
  unsigned int v50; // w24
  char *v51; // x19
  int v52; // w10
  int v53; // w2
  int v54; // w0
  unsigned int v55; // w9
  int v56; // w11
  __int64 v57; // x12
  int v58; // w10
  _BYTE *v59; // x14
  char v60; // w13
  unsigned int v61; // w14
  unsigned int v62; // w19
  int v63; // w23
  int v64; // w8
  int v65; // w20
  __int64 v66; // x8
  int8x16_t *v67; // x24
  int v68; // w8
  int v69; // w8
  unsigned int v70; // w22
  int v71; // [xsp+0h] [xbp-140h]
  int v72; // [xsp+4h] [xbp-13Ch]
  unsigned int v73; // [xsp+4h] [xbp-13Ch]
  int v74; // [xsp+8h] [xbp-138h]
  __int64 v75; // [xsp+8h] [xbp-138h]
  int *v76; // [xsp+10h] [xbp-130h] BYREF
  char v77[16]; // [xsp+18h] [xbp-128h] BYREF
  _DWORD v78[61]; // [xsp+28h] [xbp-118h] BYREF
  __int128 v79; // [xsp+11Fh] [xbp-21h] BYREF
  char v80; // [xsp+12Fh] [xbp-11h]
  __int64 v81; // [xsp+130h] [xbp-10h]

  v81 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v76 = 0;
  if ( !(_WORD)a1 )
    return 4294967293LL;
  if ( (~(unsigned __int16)word_240C0[(__int16)a1 + 204] & 3) != 0 )
    return 4294967271LL;
  v4 = (__int16)a1;
  v5 = qword_242F0[(__int16)a1];
  v6 = *(_DWORD *)(v5 + 868);
  if ( v6 == -1 )
  {
    v32 = a2;
    v33 = a3;
    v34 = sub_E800(a1, &v76);
    v35 = qword_242F0[(__int16)a1];
    if ( v34 )
    {
      result = (unsigned int)v34;
      *(_QWORD *)(v35 + 872) = 0;
      *(_DWORD *)(v35 + 868) = 0;
      return result;
    }
    v46 = v76;
    *(_DWORD *)(v35 + 868) = 1;
    *(_QWORD *)(v35 + 872) = v46;
    DRM_Seek(a1, 0, 3);
    v5 = qword_242F0[(__int16)a1];
    a2 = v32;
    a3 = v33;
    if ( *(_DWORD *)(v5 + 868) != 1 )
      return 4294967288LL;
  }
  else if ( v6 != 1 )
  {
    return 4294967288LL;
  }
  v7 = *(_QWORD *)(v5 + 872);
  v8 = *(unsigned __int16 *)(v7 + 16);
  if ( (unsigned int)(v8 - 4096) >= 2 )
  {
    if ( v8 == 1 )
    {
      v36 = a3;
      v75 = (__int64)a2;
      v37 = (FILE **)&word_240C0[4 * v4 + 4];
      v38 = DHfsTell();
      v39 = *(_DWORD *)(v7 + 4);
      v40 = v38;
      v41 = (v40 - v39 - 16) & ~((v40 - v39 - 16) >> 31);
      if ( (DHfsSeek(*v37, (v41 & 0x7FFFFFF0u) + v39, 3) & 0x80000000) != 0 )
        return 0xFFFFFFFFLL;
      v42 = v36 + 49;
      v43 = (int8x16_t *)DHmalloc(v36 + 49);
      if ( !v43 )
        return 0xFFFFFFFFLL;
      v44 = v43;
      v45 = DHfsRead(*v37, v43, v42);
      if ( v45 > 15 )
      {
        v63 = v45;
        v64 = v41 & 0xF;
        if ( v45 >= v42 )
          v65 = v45 - 1;
        else
          v65 = v45;
        v71 = v45 - 1;
        v73 = v64;
        DHmemcpy_s((__int64)&v79, 17, (__int64)v44, 16);
        v66 = qword_242F0[v4];
        v80 = 0;
        v67 = v44 + 1;
        DHmemcpy_s((__int64)v77, 16, v66 + 680, 16);
        AES_set_decrypt_key();
        AES_cbc_encrypt((int8x16_t *)v44[1].n128_u64, v44 + 1, v65 - 16, (__int64)v78, &v79, 0);
        v68 = v71;
        if ( v63 < v42 )
          v68 = v63 - *((unsigned __int8 *)&v67[-1] + (unsigned int)v63 - 1);
        v69 = v68 - v73 - 16;
        if ( v69 >= v36 )
          v70 = v36;
        else
          v70 = v69;
        DHmemcpy_s(v75, v70, (__int64)v67 + v73, v70);
        DHfree(v44);
        DHfsSeek(*v37, v70 + v40, 3);
        return v70;
      }
      else
      {
        DHfree(v44);
        return 0xFFFFFFFFLL;
      }
    }
    return 4294967288LL;
  }
  v9 = *(_DWORD *)(v7 + 40);
  v10 = *(_DWORD *)(v7 + 32);
  v11 = *(_QWORD *)(v7 + 48);
  v74 = a3;
  v12 = a2;
  v13 = (FILE **)&word_240C0[4 * v4 + 4];
  v14 = DHfsTell();
  v15 = *(_DWORD *)(v7 + 8);
  v16 = *(_DWORD *)(v7 + 24);
  v17 = *(unsigned __int8 *)(v7 + 28);
  v18 = v14 - *(_DWORD *)(v7 + 4);
  if ( *(_WORD *)(v7 + 16) != 4097 )
  {
    v19 = v74;
    v21 = 0;
    v20 = v12;
LABEL_33:
    v47 = v18 - v16;
    v48 = v19 - v21;
    v49 = v17 - v16;
    v50 = v21;
    v51 = &v20[v21];
    v52 = v49 + v15;
    if ( v18 - v16 + v48 >= v52 )
      v53 = v52 - (v18 - v16);
    else
      v53 = v48;
    v54 = DHfsRead(*v13, v51, v53);
    v55 = v47 / v10;
    v78[0] = bswap32(v47 / v10);
    if ( v54 < 1 )
      return v50;
    v56 = v47 % v10;
    v57 = (unsigned int)v54;
    v58 = v55 % v9;
    do
    {
      v59 = (_BYTE *)((unsigned __int64)v78 | v56 & 3);
      v60 = *(_BYTE *)(v11 + v58 + v56++);
      *v51 ^= v60 ^ *v59;
      if ( v56 >= v10 )
      {
        ++v55;
        v56 = 0;
        v61 = bswap32(v55);
        if ( v58 + 1 < v9 )
          ++v58;
        else
          v58 = 0;
        v78[0] = v61;
      }
      --v57;
      ++v51;
    }
    while ( v57 );
    return v54 + v50;
  }
  v19 = v74;
  v20 = v12;
  v21 = 0;
  if ( *(_WORD *)(v7 + 18) != 1 || v16 - v17 <= v18 )
    goto LABEL_33;
  v72 = *(_DWORD *)(v7 + 8);
  if ( v16 - v17 - v18 >= v74 )
    v22 = v74;
  else
    v22 = v16 - v17 - v18;
  result = DHfsRead(*v13, v12, v22);
  v24 = v18 / v10;
  v78[0] = bswap32(v18 / v10);
  if ( (int)result >= 1 )
  {
    v25 = v18 % v10;
    v26 = (unsigned int)result;
    v27 = v12;
    v28 = v24 % v9;
    do
    {
      v29 = (_BYTE *)((unsigned __int64)v78 | v25 & 3);
      v30 = *(_BYTE *)(v11 + v28 + v25++);
      *v27 ^= v30 ^ *v29;
      if ( v25 >= v10 )
      {
        ++v24;
        v25 = 0;
        v31 = bswap32(v24);
        if ( v28 + 1 < v9 )
          ++v28;
        else
          v28 = 0;
        v78[0] = v31;
      }
      --v26;
      ++v27;
    }
    while ( v26 );
    v18 += result;
  }
  if ( v18 >= v16 - v17 )
  {
    v62 = result;
    if ( (DHfsSeek(*v13, v17, 1) & 0x80000000) != 0 )
      return v62;
    v15 = v72;
    v19 = v74;
    v18 += v17;
    v20 = v12;
    v21 = v62;
    goto LABEL_33;
  }
  return result;
}
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000E800) ----------------------------------------------------
__int64 __fastcall sub_E800(__int16 a1, int **a2)
{
  __int64 v3; // x20
  __int64 result; // x0
  __int16 ClientID; // w0
  __int64 v6; // x8
  __int16 v7; // w0
  __int64 v8; // x8
  int32x2_t *v9; // x0
  int32x2_t *v10; // x27
  int32x2_t *v11; // x20
  int32x2_t *v12; // x8
  int32x2_t *v13; // x24
  unsigned __int64 v14; // x28
  _BYTE *v15; // x0
  __int16 v16; // w8
  _BYTE *v17; // x0
  _BYTE *v18; // x0
  __int16 v19; // w0
  __int64 v20; // x8
  unsigned int v21; // w0
  unsigned int v22; // w19
  __int64 v23; // x8
  __int16 SSEBaseStream; // w0
  _BYTE *v25; // x0
  int v26; // w19
  int *v27; // x0
  int *v28; // x21
  unsigned __int32 v29; // w9
  unsigned __int32 v30; // w10
  unsigned __int32 v31; // w8
  __int64 v32; // x2
  const char *v33; // x0
  unsigned __int32 v34; // w8
  __int16 v35; // w9
  __int64 v36; // x21
  __int64 i; // x8
  int v38; // w9
  unsigned __int8 *v39; // x24
  int j; // w8
  __int64 *v41; // x21
  int k; // w8
  __int64 *v43; // x21
  int v44; // w8
  unsigned __int8 *v45; // x24
  int v46; // t1
  int v47; // t1
  unsigned __int32 v48; // w0
  int v49; // w8
  __int16 *v50; // x24
  unsigned int v51; // w21
  FILE **v52; // x24
  FILE *v53; // t1
  unsigned int v54; // w8
  unsigned int v55; // w10
  unsigned __int8 v56; // w9
  const char *v57; // x0
  int32x2_t *v58; // [xsp+0h] [xbp-70h]
  unsigned int v60; // [xsp+14h] [xbp-5Ch] BYREF
  unsigned __int8 ptr[4]; // [xsp+18h] [xbp-58h] BYREF
  unsigned int v62; // [xsp+1Ch] [xbp-54h] BYREF
  _BYTE v63[51]; // [xsp+20h] [xbp-50h] BYREF
  __int64 v64; // [xsp+58h] [xbp-18h] BYREF
  __int16 v65; // [xsp+60h] [xbp-10h]
  __int64 v66; // [xsp+68h] [xbp-8h]

  v66 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v62 = 0;
  v65 = 0;
  v64 = 0;
  memset(v63, 0, sizeof(v63));
  v60 = 0;
  if ( !a1 )
    return 65533;
  if ( (~(unsigned __int16)word_240C0[a1 + 204] & 3) != 0 )
    return 65511;
  v3 = qword_242F0[a1];
  result = *(unsigned int *)(v3 + 864);
  if ( !(_DWORD)result )
  {
    if ( *(_DWORD *)(v3 + 860) != 1
      && (unsigned __int16)checkDomain(
                             *(_BYTE **)(v3 + 840),
                             *(_QWORD *)(v3 + 848),
                             *(char **)(*(_QWORD *)(v3 + 528) + 24LL)) != 1 )
    {
      return 65502;
    }
    ClientID = GetClientID(a1, (__int64)v63, &v60);
    if ( ClientID )
    {
      result = (unsigned int)ClientID;
      if ( (result & 0x80000000) != 0 )
        return result;
    }
    else
    {
      v6 = *(_QWORD *)(qword_242F0[a1] + 528LL);
      v7 = compute_eTarget(*(const char **)(v6 + 128), v63, *(_BYTE **)(v6 + 136), *(const char **)(v6 + 24));
      if ( v7 < 0 )
        return (unsigned int)v7;
    }
    v8 = *(_QWORD *)(v3 + 528);
    if ( !*(_DWORD *)(v8 + 184) || *(_DWORD *)(v8 + 216) == 1 || (result = sub_F6B8(a1), !(_WORD)result) )
    {
      v9 = (int32x2_t *)DHmalloc(56);
      if ( !v9 )
        return 65514;
      v9->n64_u64[0] = 0;
      v9[1].n64_u64[0] = 0;
      v9[4].n64_u64[0] = 0;
      v10 = v9 + 4;
      v11 = v9;
      v9[2].n64_u32[0] = 0;
      v9[5].n64_u64[0] = 0;
      v9[6].n64_u64[0] = 0;
      v12 = (int32x2_t *)qword_242F0[a1];
      v9[3].n64_u32[0] = 0;
      v13 = v9 + 3;
      v9[3].n64_u8[4] = 0;
      v14 = v12[66].n64_u64[0];
      v9->n64_u32[1] = v12[75].n64_u32[0];
      v15 = *(_BYTE **)(v14 + 72);
      v11[1].n64_u64[0] = vrev64_s32(v12[77]).n64_u64[0];
      v16 = v15 && !(unsigned int)DHstrnicmp(v15, "RFC2630", 7);
      v17 = *(_BYTE **)(v14 + 64);
      v11[2].n64_u16[1] = v16;
      if ( v17 )
      {
        if ( (unsigned int)DHstrnicmp(v17, "aes128cbc", 9) )
        {
          v18 = *(_BYTE **)(v14 + 64);
          if ( !v18 || (unsigned int)DHstrnicmp(v18, "sse", 3) )
          {
            v11[2].n64_u16[0] = 0;
LABEL_29:
            sub_10348((void **)v11);
            return 65504;
          }
          v33 = *(const char **)(v14 + 64);
          if ( !v33 )
            goto LABEL_29;
          if ( DHstristr(v33, "Combined") )
          {
            v34 = 0;
            v35 = 4096;
          }
          else
          {
            v57 = *(const char **)(v14 + 64);
            if ( !v57 || !DHstristr(v57, "Separate") )
              goto LABEL_29;
            v34 = *(_DWORD *)(v14 + 84);
            v35 = 4097;
          }
          v36 = *(_QWORD *)(v14 + 64);
          v11[2].n64_u16[0] = v35;
          v58 = v13;
          v13->n64_u32[0] = v34;
          DHmemset(&v64, 0, 10);
          for ( i = 0; ; ++i )
          {
            v38 = *(unsigned __int8 *)(v36 + i + 3);
            if ( !*(_BYTE *)(v36 + i + 3) || v38 == 45 )
              break;
            *((_BYTE *)&v64 + i) = v38;
          }
          v39 = (unsigned __int8 *)(v36 + i + 5);
          v11[4].n64_u32[1] = DHatoi();
          for ( j = *(v39 - 2); *(v39 - 2); j = *(++v39 - 2) )
          {
            if ( j == 47 )
              break;
          }
          v41 = &v64;
          DHmemset(&v64, 0, 10);
          for ( k = *(v39 - 1); *(v39 - 1); k = *v39++ )
          {
            if ( k == 45 )
              break;
            *(_BYTE *)v41 = k;
            v41 = (__int64 *)((char *)v41 + 1);
          }
          v43 = &v64;
          v10->n64_u32[0] = DHatoi();
          DHmemset(&v64, 0, 10);
          v46 = *v39;
          v45 = v39 + 1;
          v44 = v46;
          if ( v46 )
          {
            do
            {
              if ( v44 == 59 )
                break;
              *(_BYTE *)v43 = v44;
              v43 = (__int64 *)((char *)v43 + 1);
              v47 = *v45++;
              v44 = v47;
            }
            while ( v47 );
          }
          v48 = DHatoi();
          v49 = v11[2].n64_u16[1];
          v11[5].n64_u32[0] = v48;
          if ( v49 == 1 && v10->n64_u32[0] >= 0x100 )
            goto LABEL_29;
          SSEBaseStream = get_SSEBaseStream(
                            a1,
                            *(const char **)(v14 + 24),
                            *(_DWORD *)(v14 + 8),
                            *(const char **)(v14 + 128),
                            (__int64)v58);
          if ( SSEBaseStream < 0 )
            goto LABEL_67;
          if ( v11[2].n64_u16[0] == 4097 && v11[2].n64_u16[1] == 1 )
          {
            v50 = &word_240C0[4 * a1];
            v51 = v58->n64_u32[0] - 1;
            v53 = (FILE *)*((_QWORD *)v50 + 1);
            v52 = (FILE **)(v50 + 4);
            if ( DHfsSeek(v53, *(_DWORD *)(qword_242F0[a1] + 600LL) + v51, 3) < 0
              || (int)DHfsRead(*v52, ptr, 1) <= 0
              || (v54 = v11[4].n64_u32[0],
                  v55 = v51 / v54 % v11[5].n64_u32[0],
                  v62 = bswap32(v51 / v54),
                  v56 = *(_BYTE *)(v11[6].n64_u64[0] + (int)(v55 + v51 % v54))
                      ^ ptr[0]
                      ^ *(_BYTE *)((unsigned __int64)&v62 | (v51 % v54) & 3LL),
                  ptr[0] = v56,
                  v11[3].n64_u8[4] = v56,
                  v54 < v56) )
            {
              sub_10348((void **)v11);
              return 65528;
            }
          }
        }
        else
        {
          v11[2].n64_u16[0] = 1;
          v19 = sub_101D0(a1);
          if ( v19 < 0 )
          {
            v22 = v19;
            v11[2].n64_u16[0] = 0;
            goto LABEL_68;
          }
        }
      }
      else
      {
        v11[2].n64_u16[0] = 0;
      }
      v20 = *(_QWORD *)(qword_242F0[a1] + 528LL);
      v21 = compute_eServiceCode(
              a1,
              *(const char **)(v20 + 24),
              *(_BYTE **)(v20 + 56),
              *(const char **)(v20 + 40),
              *(const char **)(v20 + 48));
      if ( (_WORD)v21 )
      {
        v22 = v21;
LABEL_68:
        sub_10348((void **)v11);
        return v22;
      }
      v23 = *(_QWORD *)(qword_242F0[a1] + 528LL);
      SSEBaseStream = compute_eAuthCode(
                        a1,
                        *(const char **)(v23 + 200),
                        *(char **)(v23 + 176),
                        *(const char **)(v23 + 192),
                        *(unsigned __int8 **)(v23 + 208),
                        *(char **)(v23 + 24),
                        v11[2].n64_i16[0]);
      if ( (SSEBaseStream & 0x8000) == 0 )
      {
        if ( !v11[6].n64_u64[0] )
        {
          v25 = DHmalloc(1);
          v11[6].n64_u64[0] = (unsigned __int64)v25;
          if ( !v25 )
          {
LABEL_48:
            sub_10348((void **)v11);
            return 65514;
          }
          *v25 = 0;
        }
        v26 = v11[4].n64_u32[1] + v11[4].n64_u32[0] + 57;
        v27 = (int *)DHmalloc(v26);
        if ( v27 )
        {
          v28 = v27;
          DHmemcpy_s((__int64)v27, v26, (__int64)v11, 56);
          v30 = v11[4].n64_u32[0];
          v29 = v11[4].n64_u32[1];
          v31 = v11[3].n64_u32[0];
          v32 = v11[6].n64_i64[0];
          *v28 = v26;
          v28[6] = v31;
          DHmemcpy_s((__int64)(v28 + 14), v26, v32, v29 + v30 + 1);
          *((_QWORD *)v28 + 6) = (char *)v28 + (unsigned int)v28[11] + 56;
          sub_10348((void **)v11);
          result = 0;
          *a2 = v28;
          return result;
        }
        goto LABEL_48;
      }
LABEL_67:
      v22 = SSEBaseStream;
      goto LABEL_68;
    }
  }
  return result;
}
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000EDA8) ----------------------------------------------------
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  __int64 v4; // x22
  __int64 v5; // x8
  int v6; // w9
  __int64 v7; // x23
  int v8; // w8
  __int16 *v9; // x26
  int v10; // w27
  int v11; // w19
  FILE **v12; // x26
  int v13; // w0
  int v14; // w24
  int v15; // w10
  int v16; // w9
  bool v17; // zf
  int v18; // w19
  int v19; // w25
  int v20; // w9
  FILE *v21; // x0
  int v22; // w2
  int v23; // w10
  int v24; // w9
  bool v25; // cc
  int v26; // w9
  int v27; // w10
  _BOOL4 v28; // w9
  int v29; // w11
  int v30; // w9
  int v31; // w9
  int v32; // w1
  __int64 result; // x0
  int v34; // w25
  int v35; // w23
  __int16 v36; // w0
  __int64 v37; // x8
  __int16 *v38; // x24
  int v39; // w25
  int v40; // w19
  FILE **v41; // x24
  int v42; // w0
  int v43; // w8
  int v44; // w9
  int v45; // w1
  FILE *v46; // x0
  int v47; // w2
  int *v48; // x9
  int v49; // w10
  int v50; // w8
  int v51; // w9
  int v52; // w9
  int v53; // w8
  int v54; // w8
  int v55; // w9
  int v56; // w8
  int *v57[2]; // [xsp+0h] [xbp-10h] BYREF

  v57[1] = *(int **)(_ReadStatusReg(TPIDR_EL0) + 40);
  v57[0] = 0;
  if ( !(_WORD)a1 )
    return 4294967293LL;
  if ( (~(unsigned __int16)word_240C0[(__int16)a1 + 204] & 3) != 0 )
    return 4294967271LL;
  v4 = (__int16)a1;
  v5 = qword_242F0[(__int16)a1];
  v6 = *(_DWORD *)(v5 + 868);
  if ( v6 != -1 )
  {
    if ( v6 == 1 )
      goto LABEL_5;
    return 4294967271LL;
  }
  v34 = a2;
  v35 = a3;
  v36 = sub_E800(a1, v57);
  v37 = qword_242F0[(__int16)a1];
  if ( v36 )
  {
    result = (unsigned int)v36;
    *(_QWORD *)(v37 + 872) = 0;
    *(_DWORD *)(v37 + 868) = 0;
    return result;
  }
  v48 = v57[0];
  *(_DWORD *)(v37 + 868) = 1;
  *(_QWORD *)(v37 + 872) = v48;
  DRM_Seek(a1, 0, 3);
  v5 = qword_242F0[(__int16)a1];
  a2 = v34;
  a3 = v35;
  if ( *(_DWORD *)(v5 + 868) != 1 )
    return 4294967271LL;
LABEL_5:
  v7 = *(_QWORD *)(v5 + 872);
  v8 = *(unsigned __int16 *)(v7 + 16);
  if ( (unsigned int)(v8 - 4096) >= 2 )
  {
    if ( v8 != 1 )
      return 4294967281LL;
    v38 = &word_240C0[4 * (__int16)a1];
    v39 = a2;
    v40 = a3;
    v41 = (FILE **)(v38 + 4);
    v42 = DHfsTell();
    v43 = *(_DWORD *)(v7 + 4);
    v44 = v40;
    v17 = v40 == 3;
    v18 = v42;
    if ( v17 )
    {
      v46 = *v41;
      v56 = v39 + v43;
    }
    else
    {
      v45 = v39;
      if ( v44 != 2 )
      {
        if ( v44 != 1 )
          return 4294967281LL;
        v46 = *v41;
        v47 = 1;
LABEL_52:
        result = (unsigned int)DHfsSeek(v46, v45, v47) - *(_DWORD *)(v7 + 4) - 16;
        goto LABEL_53;
      }
      v46 = *v41;
      v56 = v39 + v43 + *(_DWORD *)(v7 + 8);
    }
    v45 = v56 + 16;
    v47 = 3;
    goto LABEL_52;
  }
  v9 = &word_240C0[4 * (__int16)a1];
  v10 = a2;
  v11 = a3;
  v12 = (FILE **)(v9 + 4);
  v13 = DHfsTell();
  v14 = *(unsigned __int8 *)(v7 + 28);
  v15 = v11;
  v16 = *(_DWORD *)(v7 + 4);
  v17 = v11 == 3;
  v18 = v13;
  v19 = *(_DWORD *)(v7 + 24) - v14;
  if ( v17 )
  {
    v21 = *v12;
    v52 = v16 + v10;
    if ( v19 <= v10 )
      v53 = *(unsigned __int8 *)(v7 + 28);
    else
      v53 = 0;
    v32 = v52 + v53;
  }
  else
  {
    if ( v15 != 2 )
    {
      if ( v15 == 1 )
      {
        v20 = v13 - v16;
        v21 = *v12;
        v22 = 1;
        if ( v20 >= v19 )
          v23 = *(unsigned __int8 *)(v7 + 28);
        else
          v23 = 0;
        v24 = v20 - v23;
        v25 = v24 < v19;
        v26 = v24 + v10;
        v27 = !v25;
        v25 = v26 < v19;
        v28 = v26 < v19;
        if ( v25 )
          v29 = 1;
        else
          v29 = v27;
        if ( (v27 & v28) != 0 )
          v30 = *(unsigned __int8 *)(v7 + 28);
        else
          v30 = 0;
        if ( v29 )
          v31 = -v30;
        else
          v31 = *(unsigned __int8 *)(v7 + 28);
        v32 = v31 + v10;
        goto LABEL_45;
      }
      return 4294967281LL;
    }
    v49 = *(_DWORD *)(v7 + 8);
    v21 = *v12;
    v50 = v16 + v10 + v49;
    if ( v49 + v10 >= v19 )
      v51 = *(unsigned __int8 *)(v7 + 28);
    else
      v51 = 0;
    v32 = v50 + v51;
  }
  v22 = 3;
LABEL_45:
  v54 = DHfsSeek(v21, v32, v22) - *(_DWORD *)(v7 + 4);
  if ( v54 >= v19 )
    v55 = v14;
  else
    v55 = 0;
  result = (unsigned int)(v54 - v55);
LABEL_53:
  if ( (int)result > *(_DWORD *)(v7 + 8) || (result & 0x80000000) != 0 )
  {
    DHfsSeek(*(FILE **)&word_240C0[4 * v4 + 4], v18, 3);
    return 4294967281LL;
  }
  return result;
}
// 1B3F0: using guessed type __int64 __fastcall DRM_Seek(_QWORD, _QWORD, _QWORD);
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000F078) ----------------------------------------------------
__int64 __fastcall DRM_GetContentInfo(__int16 a1, int **a2)
{
  __int64 v3; // x21
  _QWORD *v4; // x0
  __int64 v5; // x19
  __int64 v6; // x1
  __int16 DCFHeader; // w0
  int v8; // w9
  __int16 v9; // w8
  int v10; // w0
  __int16 v11; // w25
  int v12; // w8
  int v13; // w9
  int v14; // w21
  int v15; // w28
  int v16; // w25
  int v17; // w20
  int v18; // w24
  int v19; // w23
  int v20; // w22
  int v21; // w26
  int v22; // w27
  int v23; // w0
  int v24; // w8
  int v25; // w21
  int v26; // w26
  int *v27; // x0
  int *v28; // x20
  __int64 v29; // x2
  __int64 v30; // x2
  __int64 v31; // x8
  __int64 v32; // x2
  __int64 v33; // x8
  __int64 v34; // x2
  __int64 v35; // x8
  __int64 v36; // x2
  __int64 v37; // x8
  __int64 v38; // x2
  __int64 v39; // x8
  __int64 v40; // x2
  __int64 v41; // x8
  __int64 v42; // x2
  __int64 v43; // x8
  __int64 v44; // x2
  __int64 v45; // x8
  __int64 v46; // x2
  __int64 v47; // x8
  __int64 v48; // x2
  __int64 v49; // x8
  __int64 v50; // x10
  __int64 v51; // x9
  __int64 v52; // x8
  __int64 v53; // x9
  __int64 v54; // x10
  char *v55; // x8
  __int64 v56; // x9
  char *v57; // x8
  __int64 v58; // x10
  char *v59; // x8
  __int64 v60; // x9
  char *v61; // x8
  __int64 v62; // x10
  char *v63; // x8
  __int64 v64; // x9
  __int64 result; // x0
  __int64 v66; // x8
  __int16 ClientID; // w21
  __int64 v68; // x8
  __int16 v69; // w0
  __int64 v70; // x8
  _BYTE *v71; // x0
  __int16 v72; // w21
  __int64 v73; // x8
  __int16 v74; // w20
  int v75; // [xsp+Ch] [xbp-74h]
  int v76; // [xsp+18h] [xbp-68h]
  int v77; // [xsp+24h] [xbp-5Ch]
  int v79; // [xsp+38h] [xbp-48h]
  unsigned int v80; // [xsp+3Ch] [xbp-44h] BYREF
  _BYTE v81[51]; // [xsp+40h] [xbp-40h] BYREF
  __int64 v82; // [xsp+78h] [xbp-8h]

  v82 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v81, 0, sizeof(v81));
  v80 = 0;
  if ( !a1 )
    return 65533;
  if ( (~(unsigned __int16)word_240C0[a1 + 204] & 3) != 0 )
    return 65511;
  v3 = qword_242F0[a1];
  v4 = DHmalloc(224);
  if ( !v4 )
    return 65514;
  v4[1] = 0;
  v5 = (__int64)v4;
  v4[3] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v4[9] = 0;
  v4[11] = 0;
  v4[13] = 0;
  v4[15] = 0;
  v4[17] = 0;
  v4[19] = 0;
  v4[23] = 0;
  v4[25] = 0;
  v4[27] = 0;
  *(_QWORD *)((char *)v4 + 172) = 0;
  *(_QWORD *)((char *)v4 + 164) = 0;
  *((_WORD *)v4 + 30) = 1;
  v6 = *(_QWORD *)(qword_242F0[a1] + 528LL);
  *(_DWORD *)v4 = 0;
  *((_WORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 4) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 16) = 0;
  *((_DWORD *)v4 + 20) = 0;
  *((_DWORD *)v4 + 24) = 0;
  *((_DWORD *)v4 + 28) = 0;
  *((_DWORD *)v4 + 32) = 0;
  *((_DWORD *)v4 + 36) = 0;
  *((_WORD *)v4 + 80) = 0;
  *((_DWORD *)v4 + 48) = 0;
  *((_DWORD *)v4 + 52) = 0;
  DCFHeader = DA_DRA_GetDCFHeader((__int64)v4, v6);
  v8 = DCFHeader;
  v9 = DCFHeader;
  v10 = *(_DWORD *)(v3 + 864);
  if ( v8 >= 0 )
    v11 = 1;
  else
    v11 = v9;
  if ( !v10 )
  {
    if ( *(_DWORD *)(v3 + 860) != 1
      && (unsigned __int16)checkDomain(
                             *(_BYTE **)(v3 + 840),
                             *(_QWORD *)(v3 + 848),
                             *(char **)(*(_QWORD *)(v3 + 528) + 24LL)) != 1 )
    {
      LOWORD(v10) = -34;
      goto LABEL_8;
    }
    v66 = *(_QWORD *)(v3 + 528);
    if ( *(_DWORD *)(v66 + 184) )
    {
      if ( *(_DWORD *)(v66 + 216) != 1 )
      {
        LOWORD(v10) = sub_F6B8(a1);
        if ( (_WORD)v10 )
          goto LABEL_8;
      }
    }
    ClientID = GetClientID(a1, (__int64)v81, &v80);
    printLogD();
    printLogD();
    if ( ClientID )
    {
      LOWORD(v10) = ClientID;
      if ( ClientID < 0 )
        goto LABEL_8;
    }
    else
    {
      v68 = *(_QWORD *)(qword_242F0[a1] + 528LL);
      v69 = compute_eTarget(*(const char **)(v68 + 128), v81, *(_BYTE **)(v68 + 136), *(const char **)(v68 + 24));
      if ( v69 < 0 )
      {
        v74 = v69;
        printLogD();
        LOWORD(v10) = v74;
        goto LABEL_8;
      }
    }
    v70 = *(_QWORD *)(qword_242F0[a1] + 528LL);
    v71 = *(_BYTE **)(v70 + 64);
    if ( v71 )
    {
      v72 = ((unsigned int)DHstrnicmp(v71, "sse", 3) == 0) << 12;
      v70 = *(_QWORD *)(qword_242F0[a1] + 528LL);
    }
    else
    {
      v72 = 0;
    }
    LOWORD(v10) = compute_eServiceCode(
                    a1,
                    *(const char **)(v70 + 24),
                    *(_BYTE **)(v70 + 56),
                    *(const char **)(v70 + 40),
                    *(const char **)(v70 + 48));
    if ( !(_WORD)v10 )
    {
      v73 = *(_QWORD *)(qword_242F0[a1] + 528LL);
      LOWORD(v10) = compute_eAuthCode(
                      a1,
                      *(const char **)(v73 + 200),
                      *(char **)(v73 + 176),
                      *(const char **)(v73 + 192),
                      *(unsigned __int8 **)(v73 + 208),
                      *(char **)(v73 + 24),
                      v72);
      if ( (v10 & 0x8000u) == 0 )
        LOWORD(v10) = v11;
    }
  }
LABEL_8:
  v12 = *(_DWORD *)(v5 + 8);
  v13 = *(_DWORD *)(v5 + 12);
  *(_WORD *)(v5 + 60) = v10;
  v79 = v12;
  v14 = v13 + 1;
  v15 = DHstrlen(*(const char **)(v5 + 72)) + 1;
  v16 = DHstrlen(*(const char **)(v5 + 88)) + 1;
  v17 = DHstrlen(*(const char **)(v5 + 104)) + 1;
  v18 = DHstrlen(*(const char **)(v5 + 120)) + 1;
  v19 = DHstrlen(*(const char **)(v5 + 136)) + 1;
  v20 = DHstrlen(*(const char **)(v5 + 152)) + 1;
  v21 = DHstrlen(*(const char **)(v5 + 184)) + 1;
  v22 = DHstrlen(*(const char **)(v5 + 200)) + 1;
  v23 = DHstrlen(*(const char **)(v5 + 216));
  v75 = v14;
  v24 = v79 + v14;
  v25 = v23 + 1;
  v77 = v21;
  v76 = v17;
  v26 = v24 + v15 + v16 + v17 + v18 + v19 + v20 + v21 + v22 + v23 + 1 + 225;
  v27 = (int *)DHmalloc(v26);
  if ( v27 )
  {
    v28 = v27;
    DHmemcpy_s((__int64)v27, v26, v5, 224);
    v29 = *(_QWORD *)(v5 + 24);
    *v28 = v26;
    v28[4] = 0;
    DHmemcpy_s((__int64)(v28 + 56), v26, v29, v79 + 1);
    v30 = *(_QWORD *)(v5 + 40);
    v31 = (unsigned int)(v28[4] + v79 + 1);
    v28[8] = v31;
    DHmemcpy_s((__int64)v28 + v31 + 224, v26, v30, v75);
    v32 = *(_QWORD *)(v5 + 72);
    v33 = (unsigned int)(v28[8] + v75);
    v28[16] = v33;
    DHmemcpy_s((__int64)v28 + v33 + 224, v26, v32, v15);
    v34 = *(_QWORD *)(v5 + 88);
    v35 = (unsigned int)(v28[16] + v15);
    v28[20] = v35;
    DHmemcpy_s((__int64)v28 + v35 + 224, v26, v34, v16);
    v36 = *(_QWORD *)(v5 + 104);
    v37 = (unsigned int)(v28[20] + v16);
    v28[24] = v37;
    DHmemcpy_s((__int64)v28 + v37 + 224, v26, v36, v76);
    v38 = *(_QWORD *)(v5 + 120);
    v39 = (unsigned int)(v28[24] + v76);
    v28[28] = v39;
    DHmemcpy_s((__int64)v28 + v39 + 224, v26, v38, v18);
    v40 = *(_QWORD *)(v5 + 136);
    v41 = (unsigned int)(v28[28] + v18);
    v28[32] = v41;
    DHmemcpy_s((__int64)v28 + v41 + 224, v26, v40, v19);
    v42 = *(_QWORD *)(v5 + 152);
    v43 = (unsigned int)(v28[32] + v19);
    v28[36] = v43;
    DHmemcpy_s((__int64)v28 + v43 + 224, v26, v42, v20);
    v44 = *(_QWORD *)(v5 + 184);
    v45 = (unsigned int)(v28[36] + v20);
    v28[44] = v45;
    DHmemcpy_s((__int64)v28 + v45 + 224, v26, v44, v77);
    v46 = *(_QWORD *)(v5 + 200);
    v47 = (unsigned int)(v28[44] + v77);
    v28[48] = v47;
    DHmemcpy_s((__int64)v28 + v47 + 224, v26, v46, v22);
    v48 = *(_QWORD *)(v5 + 216);
    v49 = (unsigned int)(v28[48] + v22);
    v28[52] = v49;
    DHmemcpy_s((__int64)v28 + v49 + 224, v26, v48, v25);
    v50 = (unsigned int)v28[16];
    v51 = (__int64)v28 + (unsigned int)v28[8] + 224;
    *((_QWORD *)v28 + 3) = (char *)v28 + (unsigned int)v28[4] + 224;
    v52 = (unsigned int)v28[20];
    *((_QWORD *)v28 + 5) = v51;
    v53 = (unsigned int)v28[24];
    *((_QWORD *)v28 + 9) = (char *)v28 + v50 + 224;
    v54 = (unsigned int)v28[28];
    *((_QWORD *)v28 + 11) = (char *)v28 + v52 + 224;
    v55 = (char *)v28 + v53 + 224;
    v56 = (unsigned int)v28[32];
    *((_QWORD *)v28 + 13) = v55;
    v57 = (char *)v28 + v54 + 224;
    v58 = (unsigned int)v28[36];
    *((_QWORD *)v28 + 15) = v57;
    v59 = (char *)v28 + v56 + 224;
    v60 = (unsigned int)v28[44];
    *((_QWORD *)v28 + 17) = v59;
    v61 = (char *)v28 + v58 + 224;
    v62 = (unsigned int)v28[48];
    *((_QWORD *)v28 + 19) = v61;
    v63 = (char *)v28 + v60 + 224;
    v64 = (unsigned int)v28[52];
    *((_QWORD *)v28 + 23) = v63;
    *((_QWORD *)v28 + 25) = (char *)v28 + v62 + 224;
    *((_QWORD *)v28 + 27) = (char *)v28 + v64 + 224;
    sub_F9BC((_QWORD *)v5);
    result = 0;
    *a2 = v28;
  }
  else
  {
    sub_F9BC((_QWORD *)v5);
    return 65514;
  }
  return result;
}
// 240C0: using guessed type __int16 word_240C0[];
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000F6B8) ----------------------------------------------------
__int64 __fastcall sub_F6B8(__int16 a1)
{
  __int64 v1; // x20
  int v2; // w19
  unsigned int v4; // w0
  __int64 v5; // x8
  __int64 v6; // x9
  unsigned int v7; // w8

  if ( !a1 )
    return 65533;
  v1 = a1;
  if ( *(_DWORD *)(qword_242F0[a1] + 860LL) == 1 )
  {
    v2 = 0;
  }
  else
  {
    v2 = DHAuthTime();
    if ( !v2 )
      return 65431;
  }
  v4 = DHcurrentTime();
  if ( !v4 )
    return 65433;
  v5 = qword_242F0[v1];
  if ( *(_DWORD *)(v5 + 860) != 1 && v4 - v2 >= *(_DWORD *)(v5 + 856) )
    return 65430;
  v6 = *(_QWORD *)(v5 + 528);
  v7 = *(_DWORD *)(v6 + 184);
  if ( !v7 || *(_DWORD *)(v6 + 216) == 1 )
    return 0;
  if ( v4 <= v7 )
    return 0;
  return 4294967195LL;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000F784) ----------------------------------------------------
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3)
{
  __int64 v6; // x26
  unsigned int v7; // w21
  int v8; // w0
  int v9; // w20
  __int64 result; // x0
  int v11; // w0
  __int64 v12; // x21
  int v13; // w22
  unsigned int v14; // w22
  int v15; // w0
  int v16; // w0
  int v17; // w19

  printLogD();
  v6 = qword_242F0[a1];
  if ( *(_DWORD *)(v6 + 832) )
  {
    if ( *(_BYTE *)(v6 + 536) )
    {
      v7 = DHstrlen((const char *)(v6 + 536));
      v8 = DHstrncpy_s(a2, 50, v6 + 536, v7);
      if ( v8 )
      {
        v9 = v8;
LABEL_5:
        printLogD();
        return StrErrorReturn(v9);
      }
      *a3 = v7;
      printLogD();
      return 0;
    }
    else
    {
      return 65436;
    }
  }
  else
  {
    v11 = DHstrlen(*(const char **)(*(_QWORD *)(v6 + 528) + 128LL));
    v12 = *(_QWORD *)(v6 + 824);
    if ( v12 )
    {
      v13 = v11;
      while ( 1 )
      {
        if ( !(unsigned int)DHstrnicmp(*(_BYTE **)(*(_QWORD *)(v6 + 528) + 128LL), (_BYTE *)v12, v13) )
        {
          printLogD();
          printLogD();
          result = compute_eTarget(
                     *(const char **)(*(_QWORD *)(v6 + 528) + 128LL),
                     (const char *)(v12 + 16),
                     *(_BYTE **)(*(_QWORD *)(v6 + 528) + 136LL),
                     *(const char **)(*(_QWORD *)(v6 + 528) + 24LL));
          if ( (unsigned __int16)result != 65434 )
            break;
        }
        v12 = *(_QWORD *)(v12 + 72);
        if ( !v12 )
          goto LABEL_14;
      }
      if ( !(_WORD)result )
      {
        v14 = DHstrlen((const char *)(v12 + 16));
        v15 = DHstrncpy_s(a2, 50, v12 + 16, v14);
        if ( v15 )
        {
          v9 = v15;
          goto LABEL_5;
        }
        *a3 = v14;
        v16 = DHstrncpy_s(v6 + 536, 50, v12 + 16, v14);
        if ( v16 )
        {
          v17 = v16;
          printLogD();
          return StrErrorReturn(v17);
        }
        else
        {
          result = 1;
          *(_DWORD *)(v6 + 832) = 1;
        }
      }
    }
    else
    {
LABEL_14:
      printLogD();
      return 65434;
    }
  }
  return result;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000F9BC) ----------------------------------------------------
void __fastcall sub_F9BC(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0

  v2 = (void *)a1[3];
  if ( v2 )
    DHfree(v2);
  v3 = (void *)a1[5];
  if ( v3 )
    DHfree(v3);
  v4 = (void *)a1[9];
  if ( v4 )
    DHfree(v4);
  v5 = (void *)a1[11];
  if ( v5 )
    DHfree(v5);
  v6 = (void *)a1[13];
  if ( v6 )
    DHfree(v6);
  v7 = (void *)a1[15];
  if ( v7 )
    DHfree(v7);
  v8 = (void *)a1[17];
  if ( v8 )
    DHfree(v8);
  v9 = (void *)a1[19];
  if ( v9 )
    DHfree(v9);
  v10 = (void *)a1[23];
  if ( v10 )
    DHfree(v10);
  v11 = (void *)a1[25];
  if ( v11 )
    DHfree(v11);
  v12 = (void *)a1[27];
  if ( v12 )
    DHfree(v12);
  DHfree(a1);
}

//----- (000000000000FA60) ----------------------------------------------------
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3)
{
  __int64 v4; // x20
  __int64 result; // x0
  int v7; // w0
  unsigned int v8; // w3
  int v9; // w19

  if ( !a2 )
    return 65501;
  v4 = *(_QWORD *)(*(_QWORD *)(qword_242F0[a1] + 528LL) + 248LL);
  if ( v4 )
  {
    while ( (unsigned int)DHstrnicmp((_BYTE *)v4, a2, 20) )
    {
      v4 = *(_QWORD *)(v4 + 640);
      if ( !v4 )
        goto LABEL_5;
    }
    v7 = DHstrlen((const char *)(v4 + 128));
    if ( v7 >= 255 )
      v8 = 255;
    else
      v8 = v7;
    result = DHstrncpy_s((__int64)a3, 256, v4 + 128, v8);
    if ( (_DWORD)result )
    {
      v9 = result;
      printLogD();
      return StrErrorReturn(v9);
    }
  }
  else
  {
LABEL_5:
    result = 65500;
    *a3 = 0;
  }
  return result;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000FB24) ----------------------------------------------------
__int64 __fastcall DRM_GetFileSize(__int16 a1)
{
  if ( a1 )
    return (unsigned int)(*(_DWORD *)(qword_242F0[a1] + 600LL) + *(_DWORD *)(qword_242F0[a1] + 616LL));
  else
    return 4294967293LL;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000FB54) ----------------------------------------------------
__int64 __fastcall DRM_GetOriginalFileSize(__int16 a1)
{
  if ( a1 )
    return *(unsigned int *)(*(_QWORD *)(qword_242F0[a1] + 528LL) + 80LL);
  else
    return 4294967293LL;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000000FB80) ----------------------------------------------------
__int64 __fastcall DRM_CheckDCF(char *a1, __int64 a2)
{
  FILE *v4; // x0
  unsigned int v5; // w0
  unsigned int v6; // w22
  unsigned int v7; // w0
  int v8; // w0
  int v9; // w20
  _QWORD v11[2]; // [xsp+0h] [xbp-A0h] BYREF
  _OWORD ptr[8]; // [xsp+10h] [xbp-90h] BYREF
  __int16 v13; // [xsp+90h] [xbp-10h]
  __int64 v14; // [xsp+98h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v11[0] = 0;
  v11[1] = 0;
  printLogD();
  v4 = DHfsOpen(a1, 3);
  if ( v4 )
  {
    v13 = 0;
    memset(ptr, 0, sizeof(ptr));
    DHfsRead(v4, ptr, 128);
    DHfsClose();
    v5 = sub_FCF4(ptr, (__int64)v11);
    if ( (_WORD)v5 )
    {
      v6 = v5;
      v7 = __strlen_chk((const char *)v11, 0x10u);
      v8 = DHstrncpy_s(a2, 16, (__int64)v11, v7);
      if ( v8 )
      {
        v9 = v8;
        printLogD();
        return StrErrorReturn(v9);
      }
      else
      {
        printLogD();
        printLogD();
        return v6;
      }
    }
    else
    {
      printLogD();
      return 65236;
    }
  }
  else
  {
    printLogD();
    return 0xFFFF;
  }
}

//----- (000000000000FCF4) ----------------------------------------------------
__int64 __fastcall sub_FCF4(_BYTE *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v5; // x8
  __int64 v7; // x21
  const char *v8; // x20
  unsigned int v9; // w21
  int v10; // w0
  int v11; // [xsp+0h] [xbp-10h] BYREF
  char v12; // [xsp+4h] [xbp-Ch]
  __int64 v13; // [xsp+8h] [xbp-8h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( *a1 != 1 )
    goto LABEL_4;
  v2 = (__int64)(a1 + 3);
  if ( (unsigned int)DHmemcmp(&a1[(unsigned __int8)a1[1] + 3], "cid:", 4) )
  {
    v5 = (unsigned __int8)a1[1];
    v12 = 0;
    v11 = 0;
    DHmemcpy_s((__int64)&v11, 5, v2 + v5, 4);
    printLogD();
    return 0;
  }
  v7 = (unsigned __int8)a1[1];
  if ( !strstr((const char *)(v2 + v7 + 4), "melon.com") )
  {
LABEL_4:
    printLogD();
    return 0;
  }
  DHmemcpy_s((__int64)&unk_24480, 32, v2, v7);
  printLogD();
  v8 = "unknown";
  if ( (unsigned int)DHmemcmp(&unk_24480, "unknown", v7) )
  {
    v8 = "audio/x-mp3";
    if ( (unsigned int)DHmemcmp(&unk_24480, "audio/x-mp3", v7) )
    {
      v8 = "audio/skm";
      if ( (unsigned int)DHmemcmp(&unk_24480, "audio/skm", v7) )
      {
        v8 = "video/skm";
        if ( (unsigned int)DHmemcmp(&unk_24480, "video/skm", v7) )
          return 0;
        v9 = 3;
      }
      else
      {
        v9 = 2;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    v9 = 0;
  }
  v10 = DHstrlen(v8);
  DHmemcpy_s(a2, 16, (__int64)v8, v10);
  return v9;
}

//----- (000000000000FEF0) ----------------------------------------------------
__int64 __fastcall DRM_CheckDCFFromPfd(int a1, __int64 a2)
{
  FILE *v4; // x0
  unsigned int v5; // w22
  unsigned int v6; // w0
  int v7; // w0
  int v8; // w20
  _QWORD v10[2]; // [xsp+0h] [xbp-A0h] BYREF
  _OWORD ptr[8]; // [xsp+10h] [xbp-90h] BYREF
  __int16 v12; // [xsp+90h] [xbp-10h]
  __int64 v13; // [xsp+98h] [xbp-8h]

  v13 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v10[0] = 0;
  v10[1] = 0;
  printLogD();
  v4 = DHfsPfdOpen(a1, 3);
  if ( v4 )
  {
    v12 = 0;
    memset(ptr, 0, sizeof(ptr));
    DHfsRead(v4, ptr, 128);
    v5 = sub_FCF4(ptr, (__int64)v10);
    DHfsClose();
    if ( (_WORD)v5 )
    {
      v6 = __strlen_chk((const char *)v10, 0x10u);
      v7 = DHstrncpy_s(a2, 16, (__int64)v10, v6);
      if ( v7 )
      {
        v8 = v7;
        printLogD();
        return StrErrorReturn(v8);
      }
      else
      {
        printLogD();
        printLogD();
        return v5;
      }
    }
    else
    {
      printLogD();
      return 65236;
    }
  }
  else
  {
    printLogD();
    return 0xFFFF;
  }
}

//----- (000000000001006C) ----------------------------------------------------
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  const char *v2; // x19

  printLogD();
  if ( !*(_QWORD *)(*(_QWORD *)(qword_242F0[a1] + 528LL) + 224LL) )
    return 65500;
  printLogD();
  v2 = *(const char **)(*(_QWORD *)(qword_242F0[a1] + 528LL) + 224LL);
  if ( strstr(v2, "KS_C_5601") )
    return 0;
  if ( !strcmp(v2, "UTF-8") )
    return 3;
  return 4294967260LL;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (000000000001011C) ----------------------------------------------------
void *__fastcall DRM_GetFilePath(unsigned __int16 a1)
{
  __int64 v1; // x21
  int v2; // w20
  void *v3; // x19

  if ( (__int16)a1 <= 0 )
  {
    printLogD();
    return 0;
  }
  else
  {
    v1 = a1;
    printLogD();
    v2 = DHstrlen((const char *)(qword_242F0[v1] + 8LL));
    v3 = DHmalloc(v2 + 1);
    DHmemset(v3, 0, v2 + 1);
    DHmemcpy(v3, (const void *)(qword_242F0[v1] + 8LL), v2);
  }
  return v3;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (00000000000101D0) ----------------------------------------------------
__int64 __fastcall sub_101D0(__int16 a1)
{
  __int64 v1; // x20
  __int64 v2; // x8
  __int16 v3; // w0
  __int64 v4; // x8
  __int64 v5; // x9
  _BYTE *v6; // x10
  unsigned __int8 *v7; // x10
  unsigned int v8; // w13
  unsigned int v9; // w12
  _QWORD v11[4]; // [xsp+4h] [xbp-13Ch] BYREF
  _BYTE v12[244]; // [xsp+24h] [xbp-11Ch] BYREF
  __int128 v13; // [xsp+118h] [xbp-28h] BYREF
  _BYTE v14[16]; // [xsp+128h] [xbp-18h] BYREF
  __int64 v15; // [xsp+138h] [xbp-8h]

  v1 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = *(_QWORD *)(qword_242F0[a1] + 528LL);
  v3 = compute_SSKey(a1, *(const char **)(v2 + 152), *(char **)(v2 + 24), v14, 16);
  if ( v3 < 0 )
    return (unsigned int)v3;
  DHmemset(&v13, 0, 16);
  AES_set_decrypt_key();
  v4 = qword_242F0[v1];
  v5 = 0;
  v6 = *(_BYTE **)(*(_QWORD *)(v4 + 528) + 168LL);
  if ( *v6 == 34 )
    ++v6;
  v7 = v6 + 1;
  do
  {
    v9 = *(v7 - 1);
    if ( v9 - 65 > 5 )
    {
      if ( v9 - 97 > 5 )
      {
        v9 -= 48;
        if ( v9 > 9 )
          return 65513;
      }
      else
      {
        LOBYTE(v9) = v9 - 87;
      }
    }
    else
    {
      LOBYTE(v9) = v9 - 55;
    }
    v8 = *v7;
    if ( v8 - 65 <= 5 )
    {
      LOBYTE(v8) = v8 - 55;
    }
    else if ( v8 - 97 > 5 )
    {
      v8 -= 48;
      if ( v8 > 9 )
        return 65513;
    }
    else
    {
      LOBYTE(v8) = v8 - 87;
    }
    v7 += 2;
    *((_BYTE *)v11 + v5++) = v8 | (16 * v9);
  }
  while ( v5 != 32 );
  AES_cbc_encrypt(v11, (int8x16_t *)(v4 + 680), 0x10u, (__int64)v12, &v13, 0);
  return 0;
}
// 242F0: using guessed type _QWORD qword_242F0[1];

//----- (0000000000010348) ----------------------------------------------------
void __fastcall sub_10348(void **a1)
{
  void **v1; // x19

  if ( a1[6] )
  {
    v1 = a1;
    DHfree(a1[6]);
    a1 = v1;
  }
  DHfree(a1);
}

//----- (0000000000010378) ----------------------------------------------------
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  int v10; // w26
  int v11; // w24
  char *v12; // x24
  unsigned int v13; // w27
  char v14; // w19
  int v15; // w0
  int v16; // w25
  void *v17; // x0
  int v18; // w22
  char *v19; // x19
  int v20; // w23
  __int64 v21; // x20
  int v22; // w8
  int v23; // w28
  int v24; // w19
  int v25; // w19
  void *v26; // x0
  void *v27; // x0
  int v28; // w19
  void *v29; // x0
  int v30; // w19
  void *v31; // x0
  unsigned int v32; // w0
  void *v33; // x0
  int v34; // w19
  int v35; // w19
  void *v36; // x0
  int v37; // w27
  void *v38; // x0
  int v39; // w19
  unsigned int v40; // w27
  __int64 v41; // x28
  void *v42; // x0
  __int64 v43; // x19
  unsigned int v44; // w27
  void *v45; // x0
  __int64 v46; // x8
  __int64 v47; // x9
  unsigned __int16 v48; // w19
  __int64 v49; // x19
  __int64 v50; // x28
  unsigned __int64 v51; // x19
  __int64 v52; // x8
  int v53; // w19
  void *v54; // x0
  unsigned int v55; // w19
  void *v56; // x0
  __int64 v57; // x8
  void *v58; // x0
  int v59; // w8
  __int16 **v60; // x3
  int v61; // w19
  int v62; // w25
  unsigned int v63; // w0
  int v64; // w0
  int v65; // w0
  int v66; // w0
  int v67; // w0
  int v68; // w0
  int v69; // w0
  int v70; // w0
  int v71; // w0
  int v72; // w0
  unsigned int v73; // w19
  __int64 v74; // x8
  __int64 v75; // x23
  unsigned int v76; // w26
  int8x16_t *v77; // x19
  char *v78; // x27
  __int64 i; // x23
  unsigned int v80; // w0
  int v81; // w0
  int v83; // w0
  int v84; // w19
  char *v85; // x0
  unsigned int v86; // w0
  unsigned int v87; // w19
  _BYTE *v88; // x0
  _BYTE *v89; // x19
  unsigned int v90; // w23
  int v91; // w23
  int8x16_t *v92; // x0
  int8x16_t *v93; // x23
  int v94; // w19
  void *v95; // x0
  __int64 v96; // x24
  int v97; // w20
  int v98; // w19
  int v99; // w19
  int v100; // w19
  __int64 v101; // x19
  unsigned int v102; // w0
  void *v103; // x0
  __int64 v104; // x19
  unsigned int v105; // w0
  unsigned __int64 v106; // [xsp+28h] [xbp-408h]
  unsigned __int64 v107; // [xsp+30h] [xbp-400h]
  _DWORD *v108; // [xsp+58h] [xbp-3D8h]
  __int64 *v109; // [xsp+60h] [xbp-3D0h]
  __int64 *v110; // [xsp+60h] [xbp-3D0h]
  _BYTE *v113; // [xsp+80h] [xbp-3B0h]
  int v114; // [xsp+8Ch] [xbp-3A4h] BYREF
  char v115[8]; // [xsp+90h] [xbp-3A0h] BYREF
  __int64 v116; // [xsp+98h] [xbp-398h] BYREF
  _QWORD v117[2]; // [xsp+A0h] [xbp-390h]
  char v118[8]; // [xsp+B0h] [xbp-380h] BYREF
  _QWORD v119[2]; // [xsp+B8h] [xbp-378h]
  __int64 v120; // [xsp+C8h] [xbp-368h] BYREF
  _QWORD v121[2]; // [xsp+D0h] [xbp-360h]
  char v122[32]; // [xsp+E0h] [xbp-350h] BYREF
  char s[16]; // [xsp+100h] [xbp-330h] BYREF
  __int128 v124; // [xsp+110h] [xbp-320h]
  const void *v125[4]; // [xsp+120h] [xbp-310h] BYREF
  __int128 v126; // [xsp+140h] [xbp-2F0h] BYREF
  __int128 v127; // [xsp+150h] [xbp-2E0h]
  __int128 v128; // [xsp+160h] [xbp-2D0h]
  __int128 v129; // [xsp+170h] [xbp-2C0h]
  _DWORD v130[8]; // [xsp+180h] [xbp-2B0h] BYREF
  __int128 v131; // [xsp+1A0h] [xbp-290h]
  __int128 v132; // [xsp+1B0h] [xbp-280h]
  __int128 v133; // [xsp+1C0h] [xbp-270h]
  __int128 v134; // [xsp+1D0h] [xbp-260h]
  __int128 v135; // [xsp+1E0h] [xbp-250h]
  __int128 v136; // [xsp+1F0h] [xbp-240h]
  __int128 v137; // [xsp+200h] [xbp-230h]
  __int128 v138; // [xsp+210h] [xbp-220h]
  __int128 v139; // [xsp+220h] [xbp-210h]
  __int128 v140; // [xsp+230h] [xbp-200h]
  __int128 v141; // [xsp+240h] [xbp-1F0h]
  __int128 v142; // [xsp+250h] [xbp-1E0h]
  __int128 v143; // [xsp+260h] [xbp-1D0h]
  __int128 v144; // [xsp+270h] [xbp-1C0h]
  __int128 v145; // [xsp+280h] [xbp-1B0h]
  __int128 v146; // [xsp+290h] [xbp-1A0h]
  __int128 v147; // [xsp+2A0h] [xbp-190h]
  __int128 v148; // [xsp+2B0h] [xbp-180h]
  __int128 v149; // [xsp+2C0h] [xbp-170h]
  __int128 v150; // [xsp+2D0h] [xbp-160h]
  __int128 v151; // [xsp+2E0h] [xbp-150h]
  __int128 v152; // [xsp+2F0h] [xbp-140h]
  __int64 v153; // [xsp+300h] [xbp-130h] BYREF
  _QWORD v154[2]; // [xsp+308h] [xbp-128h]
  __int64 v155; // [xsp+318h] [xbp-118h] BYREF
  _QWORD v156[2]; // [xsp+320h] [xbp-110h]
  __int128 v157; // [xsp+330h] [xbp-100h] BYREF
  __int128 v158; // [xsp+340h] [xbp-F0h]
  char v159[32]; // [xsp+350h] [xbp-E0h] BYREF
  __int128 v160; // [xsp+370h] [xbp-C0h] BYREF
  __int128 v161; // [xsp+380h] [xbp-B0h]
  _OWORD v162[3]; // [xsp+390h] [xbp-A0h] BYREF
  char v163; // [xsp+3C0h] [xbp-70h]
  int8x16_t v164; // [xsp+3D0h] [xbp-60h] BYREF
  __int128 v165; // [xsp+3E0h] [xbp-50h]
  _BYTE v166[33]; // [xsp+3F0h] [xbp-40h] BYREF
  __int64 v167; // [xsp+418h] [xbp-18h]

  v167 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v122, 0, 26);
  v120 = 0;
  v121[0] = 0;
  *(_QWORD *)((char *)v121 + 5) = 0;
  *(_QWORD *)v118 = 0;
  v119[0] = 0;
  *(_QWORD *)((char *)v119 + 5) = 0;
  v116 = 0;
  v117[0] = 0;
  *(_QWORD *)((char *)v117 + 5) = 0;
  memset(v159, 0, 26);
  v157 = 0u;
  v158 = 0u;
  v161 = 0u;
  memset(v162, 0, 19);
  v160 = 0u;
  v165 = 0u;
  memset(v166, 0, 19);
  v164 = 0u;
  v114 = 50;
  v155 = 0;
  v156[0] = 0;
  *(_QWORD *)((char *)v156 + 5) = 0;
  v154[0] = 0;
  v153 = 0;
  *(_QWORD *)((char *)v154 + 5) = 0;
  memset(v125, 0, sizeof(v125));
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  memset(v130, 0, sizeof(v130));
  v131 = 0u;
  v132 = 0u;
  v133 = 0u;
  v134 = 0u;
  v135 = 0u;
  v136 = 0u;
  v137 = 0u;
  v138 = 0u;
  v139 = 0u;
  v140 = 0u;
  v141 = 0u;
  v142 = 0u;
  v143 = 0u;
  v144 = 0u;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v152 = 0u;
  v124 = 0u;
  *(_OWORD *)s = 0u;
  *(_QWORD *)v115 = 0;
  printLogD();
  DHstrcpy_s((char *)&v157, 32, "melon");
  DHmemset(&v164, 0, 50);
  printLogD();
  v10 = DHGetDeviceID_ConstVal((char *)&v164);
  v11 = DHstrlen((const char *)&v164);
  printLogD();
  v113 = a1;
  if ( v10 )
  {
    v12 = 0;
    v13 = 65333;
    v14 = 1;
  }
  else
  {
    printLogD();
    v60 = (__int16 **)*a6;
    if ( !*a6 )
    {
      v60 = (__int16 **)DHmalloc(14);
      *a6 = v60;
    }
    v61 = DHGetClientID_BySetVal("min", (unsigned int *)&v114, (__int64)&v160, v60);
    printLogD();
    if ( v61 <= 0 )
    {
      DHFreeClientID(*a6);
      v12 = 0;
      *a6 = 0;
      v13 = 65436;
      v14 = 1;
    }
    else
    {
      strcpy(v159, "SS MAC-1 Token Generation");
      v62 = DHstrlen(v159);
      v63 = DHstrlen("ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=");
      DHstrncpy_s((__int64)s, 512, (__int64)"ve=1.1.0\nci=DC-LK04-SKMP-1400-P100\nsn=", v63);
      v64 = DHstrlen((const char *)&v157);
      DHstrncat_s(s, 512, (__int64)&v157, v64);
      v65 = DHstrlen("\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:");
      DHstrncat_s(s, 512, (__int64)"\nam=all\ndl=melon.com\ndl=sktelecom.com\nrd=DEV_SERIAL:", v65);
      v66 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v66);
      v67 = DHstrlen("\ntt=120\nmc=6\nce=MIN:");
      DHstrncat_s(s, 512, (__int64)"\ntt=120\nmc=6\nce=MIN:", v67);
      printLogD();
      v68 = DHstrlen((const char *)&v160);
      DHstrncat_s(s, 512, (__int64)&v160, v68);
      v69 = DHstrlen("\nce=HID:");
      DHstrncat_s(s, 512, (__int64)"\nce=HID:", v69);
      v70 = DHstrlen((const char *)&v164);
      DHstrncat_s(s, 512, (__int64)&v164, v70);
      v71 = DHstrlen("\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n");
      DHstrncat_s(s, 512, (__int64)"\nvp=20071015000000Z+09\nvp=20351231235959Z+09\n", v71);
      v72 = DHstrlen(s);
      if ( v72 < 1 )
      {
        v12 = 0;
        v14 = 0;
        v13 = 0;
      }
      else
      {
        v73 = v72;
        v110 = a3;
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)s, (uint32x4_t *)&v155, v73);
        v74 = 2LL * v11;
        v75 = v74 + 37;
        v76 = v62 + v74 + 37;
        v77 = (int8x16_t *)DHmalloc(v11 + 1);
        DHmemset(v77, 0, v11 + 1);
        inverse(&v164, v77, v11);
        v78 = (char *)DHmalloc(v76 + 1);
        DHmemset(v78, 0, v76 + 1);
        DHmemcpy(v78, &v155, 20);
        DHmemcpy(v78 + 20, "SSMAC-1", 7);
        DHmemcpy(v78 + 27, "DEV_SERIAL", 10);
        DHmemcpy(v78 + 37, &v164, v11);
        DHmemcpy(&v78[v11 + 37], v77, v11);
        DHmemcpy(&v78[v75], v159, v62);
        DHmemset(&v155, 0, 21);
        DA_DRM_HASH_SHA1Digest((__int64)v78, (uint32x4_t *)&v155, v76);
        DHfree(v78);
        DHfree(v77);
        DHmemset(&v153, 0, 21);
        DHmemset(&v115[4], 0, 4);
        for ( i = 0; i != 10; ++i )
        {
          if ( !DHultoa(*((unsigned __int8 *)&v156[-1] + i), (int8x16_t *)&v115[4], 0x10u) )
            return 0xFFFF;
          if ( (unsigned int)DHstrlen(&v115[4]) == 1 )
          {
            v80 = DHstrlen(&v115[4]);
            DHstrncpy_s((__int64)v115, 4, (__int64)&v115[4], v80);
            DHstrncpy_s((__int64)&v115[4], 4, (__int64)"0", 1u);
            v81 = DHstrlen(v115);
            DHstrncat_s(&v115[4], 4, (__int64)v115, v81);
          }
          DHstrncat_s((char *)&v153, 21, (__int64)&v115[4], 2);
          DHmemset(&v115[4], 0, 4);
        }
        DHfree(&v115[4]);
        DHstrcat();
        DHstrcat();
        DHstrcat();
        v83 = DHstrlen(s);
        a3 = v110;
        if ( v83 < 1 )
        {
          v12 = 0;
          v13 = 65332;
          v14 = 1;
        }
        else
        {
          v84 = v83;
          v85 = (char *)DHmalloc(v83 + 1);
          v12 = v85;
          if ( v85 )
          {
            DHmemset(v85, 0, v84 + 1);
            DHmemcpy(v12, s, v84);
            DHstrlen(v12);
            printLogD();
            v14 = 0;
            v13 = 0;
          }
          else
          {
            v13 = 65514;
            v14 = 1;
          }
        }
      }
    }
  }
  printLogD();
  if ( !v12 || (v14 & 1) != 0 )
    return v13;
  v15 = DHstrlen(v12);
  if ( v15 <= 0 )
  {
    DHfree(v12);
    printLogD();
    return 65336;
  }
  v16 = v15;
  printLogD();
  LOWORD(v130[0]) = 0;
  *(_QWORD *)&v130[3] = 0;
  *(_QWORD *)&v130[1] = 0;
  v124 = 0u;
  memset(v125, 0, 28);
  *(_OWORD *)s = 0u;
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  printLogD();
  v17 = DHmalloc(v16 + 1);
  *(_QWORD *)&v127 = v17;
  if ( !v17 )
  {
    DHfree(v12);
    return 65514;
  }
  v109 = a3;
  DHmemset(v17, 0, v16 + 1);
  printLogD();
  memset(v159, 0, 17);
  v161 = 0u;
  memset(v162, 0, sizeof(v162));
  v164 = 0u;
  v165 = 0u;
  memset(v166, 0, sizeof(v166));
  v163 = 0;
  v160 = 0u;
  v157 = 0u;
  LODWORD(v158) = 0;
  LOWORD(v156[0]) = 0;
  v155 = 0;
  LODWORD(v153) = 0;
  v114 = 0;
  printLogD();
  printLogD();
  v18 = 0;
  v19 = v12;
  v20 = v16;
  v108 = a5;
  do
  {
    DHmemset(&v160, 0, 80);
    printLogD();
    v21 = 0;
    v22 = (unsigned __int8)*v19;
    if ( *v19 )
    {
      do
      {
        if ( v22 == 10 )
          break;
        if ( v21 == 81 )
          goto LABEL_77;
        *((_BYTE *)&v160 + v21++) = v22;
        v22 = (unsigned __int8)v19[v21];
      }
      while ( v19[v21] );
    }
    v23 = v21 + 1;
    *((_BYTE *)&v160 + v21) = 0;
    printLogD();
    v13 = sub_12128((unsigned __int8 *)&v160, (int)v21 + 1, v159, (int *)&v153, &v164, &v114);
    if ( (_WORD)v13 || (v24 = v153, (int)v153 < 2) )
    {
      if ( !(_WORD)v13 )
        goto LABEL_90;
      goto LABEL_78;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ve", v153) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v26 = DHmalloc(v114 + 1);
      *(_QWORD *)s = v26;
      if ( !v26 )
        goto LABEL_97;
      DHmemset(v26, 0, v25 + 1);
      v27 = *(void **)s;
LABEL_29:
      DHmemcpy(v27, &v164, v25);
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "sn", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v28 = v114;
      v29 = DHmalloc(v114 + 1);
      *(_QWORD *)&s[8] = v29;
      if ( !v29 )
        goto LABEL_97;
      DHmemset(v29, 0, v28 + 1);
      DHmemcpy(*(void **)&s[8], &v164, v28);
      HIDWORD(v127) = v28;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "am", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v30 = v114;
      v31 = DHmalloc(v114 + 1);
      *(_QWORD *)&v126 = v31;
      if ( !v31 )
        goto LABEL_97;
      DHmemset(v31, 0, v30 + 1);
      DHmemcpy((void *)v126, &v164, v30);
      DWORD2(v127) = v30;
      goto LABEL_65;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "dl", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v32 = sub_12000((__int64)&v164, v114, (__int64 **)&v126 + 1);
      if ( !(_WORD)v32 )
        goto LABEL_65;
      v13 = v32;
LABEL_78:
      DHfree(v12);
      sub_11D7C((__int64)s);
      printLogD();
      return v13;
    }
    if ( !(unsigned int)DHstrnicmp(v159, "ci", v24) )
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      v25 = v114;
      v33 = DHmalloc(v114 + 1);
      *(_QWORD *)&v124 = v33;
      if ( !v33 )
        goto LABEL_97;
      DHmemset(v33, 0, v25 + 1);
      v27 = (void *)v124;
      goto LABEL_29;
    }
    if ( (unsigned int)DHstrnicmp(v159, "rd", v24) )
    {
      if ( !(unsigned int)DHstrnicmp(v159, "tt", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        LODWORD(v125[3]) = 3600 * DHatoi();
        goto LABEL_65;
      }
      if ( !(unsigned int)DHstrnicmp(v159, "mc", v24) )
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        DWORD2(v128) = DHatoi();
        goto LABEL_65;
      }
      if ( (unsigned int)DHstrnicmp(v159, "ce", v24) )
      {
        if ( (unsigned int)DHstrnicmp(v159, "vp", v24) )
        {
          if ( (unsigned int)DHstrnicmp(v159, "sa", v24) )
          {
            if ( (unsigned int)DHstrnicmp(v159, "sv", v24) )
            {
              v130[4] += v21 + 1;
              DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
              *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
              goto LABEL_65;
            }
            v25 = v114;
            v58 = DHmalloc(v114 + 1);
            v125[2] = v58;
            if ( !v58 )
              goto LABEL_97;
            DHmemset(v58, 0, v25 + 1);
            v27 = (void *)v125[2];
            goto LABEL_29;
          }
          v53 = v114;
          v54 = DHmalloc(v114 + 1);
          v125[1] = v54;
          if ( !v54 )
            goto LABEL_97;
          DHmemset(v54, 0, v53 + 1);
          DHmemcpy((void *)v125[1], &v164, v53);
          v130[3] = v53;
        }
        else
        {
          v130[4] += v21 + 1;
          DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
          *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164, 4);
          v48 = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_u8[4], 2);
          v49 = v48 | ((unsigned __int16)DHatoi() << 16);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (char *)&v164.n128_i32[1] + 2, 2);
          v50 = (unsigned __int16)DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, &v164.n128_i8[8], 2);
          v51 = v49 | (DHatoi() << 48) | (v50 << 32);
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xA), 2);
          LOWORD(v50) = DHatoi();
          DHmemset(&v155, 0, 10);
          DHmemcpy(&v155, (const void *)((unsigned __int64)&v164 | 0xC), 2);
          v52 = (unsigned __int16)v50 | ((unsigned __int16)DHatoi() << 16);
          if ( LOWORD(v130[0]) )
          {
            v107 = v107 & 0xFFFFFFFF00000000LL | v52;
            v130[2] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 2;
          }
          else
          {
            v106 = v106 & 0xFFFFFFFF00000000LL | v52;
            v130[1] = DHmktime(v51, v52);
            LOWORD(v130[0]) = 1;
          }
          printLogD();
          printLogD();
        }
      }
      else
      {
        v130[4] += v21 + 1;
        DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
        *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
        if ( ++HIDWORD(v128) > DWORD2(v128) )
        {
LABEL_77:
          printLogD();
          v13 = 65335;
          goto LABEL_78;
        }
        DHmemset(&v160, 0, 80);
        v39 = v114;
        DHmemcpy(&v160, &v164, v114);
        sub_12128((unsigned __int8 *)&v160, v39 + 1, v159, (int *)&v153, &v164, &v114);
        v40 = v153;
        if ( !(unsigned int)DHstrnicmp(v159, "min", v153) )
        {
          LODWORD(v129) = v129 + 1;
          if ( v164.n128_u8[0] == 48 && v114 == 11 )
          {
            DHmemset(&v157, 0, 20);
            DHstrncpy_s((__int64)&v157, 20, (__int64)v164.n128_i64 + 1, 0xAu);
            DHmemset(&v164, 0, 11);
            DHstrncpy_s((__int64)&v164, 65, (__int64)&v157, 0xAu);
            v114 = 10;
          }
        }
        v41 = *((_QWORD *)&v129 + 1);
        v42 = DHmalloc(40);
        v43 = (__int64)v42;
        if ( v41 )
        {
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, v40 + 1);
          DHstrncpy_s(v43, 16, (__int64)v159, v40);
          v44 = v114;
          v45 = DHmalloc(v114 + 1);
          *(_QWORD *)(v43 + 16) = v45;
          if ( !v45 )
            goto LABEL_97;
          DHmemset(v45, 0, v44 + 1);
          DHstrncpy_s(*(_QWORD *)(v43 + 16), v44 + 1, (__int64)&v164, v44);
          *(_DWORD *)(v43 + 24) = v44;
          *(_QWORD *)(v43 + 32) = 0;
          v46 = *((_QWORD *)&v129 + 1);
          do
          {
            v47 = v46;
            v46 = *(_QWORD *)(v46 + 32);
          }
          while ( v46 );
          *(_QWORD *)(v47 + 32) = v43;
        }
        else
        {
          *((_QWORD *)&v129 + 1) = v42;
          if ( !v42 )
            goto LABEL_97;
          DHmemset(v42, 0, 16);
          DHstrncpy_s(*((__int64 *)&v129 + 1), 16, (__int64)v159, v40);
          v55 = v114;
          v56 = DHmalloc(v114 + 1);
          *(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL) = v56;
          if ( !v56 )
            goto LABEL_97;
          DHmemset(v56, 0, v55 + 1);
          DHstrncpy_s(*(_QWORD *)(*((_QWORD *)&v129 + 1) + 16LL), v40 + 1, (__int64)&v164, v55);
          v57 = *((_QWORD *)&v129 + 1);
          *(_DWORD *)(*((_QWORD *)&v129 + 1) + 24LL) = v55;
          *(_QWORD *)(v57 + 32) = 0;
        }
      }
    }
    else
    {
      v130[4] += v21 + 1;
      DHstrncat_s((char *)v127, v16, (__int64)&v160, v23);
      *(_BYTE *)(v127 + (unsigned int)(v130[4] - 1)) = 10;
      DHmemset(&v160, 0, 80);
      v34 = v114;
      DHmemcpy(&v160, &v164, v114);
      sub_12128((unsigned __int8 *)&v160, v34 + 1, v159, (int *)&v153, &v164, &v114);
      v35 = v153;
      v36 = DHmalloc((int)v153 + 1);
      *((_QWORD *)&v124 + 1) = v36;
      if ( !v36
        || (DHmemset(v36, 0, v35 + 1),
            DHmemcpy(*((void **)&v124 + 1), v159, v35),
            v37 = v114,
            LODWORD(v128) = v35,
            v38 = DHmalloc(v114 + 1),
            (v125[0] = v38) == 0) )
      {
LABEL_97:
        v13 = 65514;
        goto LABEL_78;
      }
      DHmemset(v38, 0, v37 + 1);
      DHmemcpy((void *)v125[0], &v164, v37);
      DWORD1(v128) = v37;
    }
LABEL_65:
    v59 = v20 - 1;
    v18 += 1 + v21;
    v20 = v20 - 1 - v21;
    v19 = &v12[v18];
  }
  while ( v59 - (int)v21 > 0 );
  printLogD();
LABEL_90:
  printLogD();
  DHfree(v12);
  if ( !v125[0] || !v125[1] || !*(_QWORD *)&s[8] || !(_QWORD)v126 )
  {
    sub_11D7C((__int64)s);
    printLogD();
    return 65335;
  }
  printLogD();
  if ( v113 )
  {
    if ( (unsigned int)DHstrnicmp(v113, *(_BYTE **)&s[8], SHIDWORD(v127)) )
    {
LABEL_100:
      sub_11D7C((__int64)s);
      goto LABEL_101;
    }
  }
  else if ( (unsigned int)DHstrnicmp("MELON", *(_BYTE **)&s[8], SHIDWORD(v127)) )
  {
    goto LABEL_100;
  }
  printLogD();
  v86 = DHcurrentTime();
  if ( !v86 )
  {
    sub_11D7C((__int64)s);
    return 65433;
  }
  v87 = v86;
  printLogD();
  if ( LOWORD(v130[0]) == 1 )
  {
    if ( v87 > v130[1] )
      goto LABEL_105;
LABEL_109:
    printLogD();
    v88 = DHmalloc(50);
    if ( v88 )
    {
      v89 = v88;
      DHmemset(v88, 0, 50);
      if ( (unsigned int)DHGetDeviceID_ConstVal(v89) )
      {
        DHfree(v89);
        sub_11D7C((__int64)s);
        DHstrlen(v89);
        printLogD();
        return 65333;
      }
      v90 = DHstrlen(v89);
      if ( v90 > 0x32 || v90 != DWORD1(v128) )
      {
        DHfree(v89);
        sub_11D7C((__int64)s);
        printLogD();
        return 65333;
      }
      printLogD();
      printLogD();
      v91 = DHstrnicmp(v89, (_BYTE *)v125[0], SDWORD1(v128));
      DHfree(v89);
      if ( v91 )
      {
        sub_11D7C((__int64)s);
        printLogD();
LABEL_101:
        printLogD();
        return 65335;
      }
      printLogD();
      strcpy(v122, "SS MAC-1 Token Generation");
      printLogD();
      DA_DRM_HASH_SHA1Digest(v127, (uint32x4_t *)&v120, v130[4]);
      printLogD();
      v92 = (int8x16_t *)DHmalloc(DWORD1(v128) + 1);
      if ( v92 )
      {
        v93 = v92;
        DHmemset(v92, 0, DWORD1(v128) + 1);
        inverse((int8x16_t *)v125[0], v93, SDWORD1(v128));
        v94 = v130[3] + v128 + 2 * DWORD1(v128);
        v95 = DHmalloc(v94 + 46);
        if ( v95 )
        {
          v96 = (__int64)v95;
          v97 = v94 + 20;
          DHmemset(v95, 0, v94 + 46);
          DHmemcpy((void *)v96, &v120, 20);
          DHmemcpy((void *)(v96 + 20), v125[1], v130[3]);
          v98 = v130[3] + 20;
          DHmemcpy((void *)(v96 + v130[3] + 20), *((const void **)&v124 + 1), v128);
          v99 = v128 + v98;
          DHmemcpy((void *)(v96 + v99), v125[0], SDWORD1(v128));
          v100 = DWORD1(v128) + v99;
          DHmemcpy((void *)(v96 + v100), v93, SDWORD1(v128));
          DHmemcpy((void *)(v96 + DWORD1(v128) + v100), v122, 25);
          printLogD();
          printLogD();
          DA_DRM_HASH_SHA1Digest(v96, (uint32x4_t *)v118, v97 + 25);
          printLogD();
          DHsprintf_s(
            (char *)&v116,
            21,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            (unsigned __int8)v118[0],
            (unsigned __int8)v118[1],
            (unsigned __int8)v118[2],
            (unsigned __int8)v118[3],
            (unsigned __int8)v118[4],
            v118[5]);
          printLogD();
          DHfree(v93);
          DHfree((void *)v96);
          if ( (unsigned int)DHstrncmp((const char *)v125[2], (const char *)&v116, 20) )
          {
            printLogD();
            sub_11D7C((__int64)s);
            return 65335;
          }
          printLogD();
          v101 = *((_QWORD *)&v129 + 1);
          if ( *((_QWORD *)&v129 + 1) )
          {
            while ( 1 )
            {
              v102 = sub_11EB8(v101, a2);
              if ( (_WORD)v102 )
                break;
              v101 = *(_QWORD *)(v101 + 32);
              if ( !v101 )
                goto LABEL_129;
            }
            v13 = v102;
          }
          else
          {
LABEL_129:
            v103 = DHmalloc(DWORD2(v127) + 1);
            *v109 = (__int64)v103;
            if ( !v103 )
            {
              if ( *a2 )
                ClientIDDestroy((_QWORD *)*a2);
              sub_11D7C((__int64)s);
              return 65514;
            }
            DHmemset(v103, 0, DWORD2(v127) + 1);
            DHstrncpy_s(*v109, DWORD2(v127) + 1, v126, DWORD2(v127));
            v104 = *((_QWORD *)&v126 + 1);
            if ( !*((_QWORD *)&v126 + 1) )
            {
LABEL_133:
              *v108 = v125[3];
              sub_11D7C((__int64)s);
              return 0;
            }
            while ( 1 )
            {
              v105 = sub_12000(*(_QWORD *)v104, *(_DWORD *)(v104 + 8), a4);
              if ( (_WORD)v105 )
                break;
              v104 = *(_QWORD *)(v104 + 16);
              if ( !v104 )
                goto LABEL_133;
            }
            v13 = v105;
            if ( *a2 )
              ClientIDDestroy((_QWORD *)*a2);
            DHfree(v109);
          }
          sub_11D7C((__int64)s);
          return v13;
        }
        DHfree(v93);
      }
    }
    sub_11D7C((__int64)s);
    printLogD();
    return 65514;
  }
  if ( v87 <= v130[2] && v87 >= v130[1] )
    goto LABEL_109;
LABEL_105:
  sub_11D7C((__int64)s);
  printLogD();
  return 65334;
}
// 10ED8: variable 'v107' is possibly undefined
// 1100C: variable 'v106' is possibly undefined

//----- (0000000000011D7C) ----------------------------------------------------
void __fastcall sub_11D7C(__int64 a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x19
  __int64 v15; // x8
  __int64 v16; // x20

  v2 = *(void **)a1;
  if ( v2 )
    DHfree(v2);
  v3 = *(void **)(a1 + 8);
  if ( v3 )
    DHfree(v3);
  v4 = *(void **)(a1 + 16);
  if ( v4 )
    DHfree(v4);
  v5 = *(void **)(a1 + 24);
  if ( v5 )
    DHfree(v5);
  v6 = *(void **)(a1 + 32);
  if ( v6 )
    DHfree(v6);
  v7 = *(void **)(a1 + 40);
  if ( v7 )
    DHfree(v7);
  v8 = *(void **)(a1 + 48);
  if ( v8 )
    DHfree(v8);
  v9 = *(void **)(a1 + 80);
  if ( v9 )
    DHfree(v9);
  v10 = *(void **)(a1 + 64);
  if ( v10 )
    DHfree(v10);
  v11 = *(_QWORD *)(a1 + 72);
  if ( v11 )
  {
    v12 = *(_QWORD *)(v11 + 16);
    if ( v12 )
    {
      do
      {
        v13 = v12;
        if ( *(_QWORD *)v11 )
          DHfree(*(void **)v11);
        *(_QWORD *)v11 = 0;
        DHfree((void *)v11);
        v12 = *(_QWORD *)(v13 + 16);
        v11 = v13;
      }
      while ( v12 );
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 72);
    }
    if ( *(_QWORD *)v13 )
      DHfree(*(void **)v13);
    *(_QWORD *)v13 = 0;
    DHfree((void *)v13);
  }
  v14 = *(_QWORD *)(a1 + 120);
  if ( v14 )
  {
    v15 = *(_QWORD *)(v14 + 32);
    if ( v15 )
    {
      do
      {
        v16 = v15;
        DHfree(*(void **)(v14 + 16));
        DHfree((void *)v14);
        v15 = *(_QWORD *)(v16 + 32);
        v14 = v16;
      }
      while ( v15 );
    }
    else
    {
      v16 = v14;
    }
    DHfree(*(void **)(v16 + 16));
    DHfree((void *)v16);
  }
}

//----- (0000000000011EB8) ----------------------------------------------------
__int64 __fastcall sub_11EB8(__int64 a1, __int64 *a2)
{
  void *v4; // x0
  __int64 v5; // x19
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 result; // x0

  v4 = DHmalloc(81);
  if ( !v4 )
    return 65514;
  v5 = (__int64)v4;
  DHmemset(v4, 0, 16);
  DHmemset((void *)(v5 + 16), 0, 51);
  *(_QWORD *)(v5 + 72) = 0;
  DHstrncpy_s(v5, 16, a1, 0x10u);
  DHmemset((void *)(v5 + 16), 0, 51);
  DHstrncpy_s(v5 + 16, 51, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
  v6 = *a2;
  if ( *a2 )
  {
    do
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 72);
    }
    while ( v6 );
    a2 = (__int64 *)(v7 + 72);
  }
  result = 0;
  *a2 = v5;
  return result;
}

//----- (0000000000011F70) ----------------------------------------------------
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  _QWORD *v1; // x8
  _QWORD *v2; // x20
  _QWORD *v3; // x19

  if ( a1 )
  {
    v1 = (_QWORD *)a1[9];
    v2 = a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        DHmemset(v2, 0, 16);
        DHmemset(v2 + 2, 0, 51);
        DHfree(v2);
        v1 = (_QWORD *)v3[9];
        v2 = v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    DHmemset(v3, 0, 16);
    DHmemset(v3 + 2, 0, 51);
    DHfree(v3);
  }
}

//----- (0000000000012000) ----------------------------------------------------
__int64 __fastcall sub_12000(__int64 a1, unsigned int a2, __int64 **a3)
{
  __int64 *v6; // x0
  __int64 *v7; // x19
  void *v8; // x0
  __int64 *v9; // x8
  __int64 *v10; // x9
  __int64 result; // x0

  v6 = (__int64 *)DHmalloc(25);
  if ( !v6 )
    return 65514;
  v7 = v6;
  *v6 = 0;
  v6[2] = 0;
  *((_DWORD *)v6 + 2) = a2;
  v8 = DHmalloc(a2 + 1);
  *v7 = (__int64)v8;
  if ( v8 )
  {
    DHmemset(v8, 0, a2 + 1);
    DHstrncpy_s(*v7, a2 + 1, a1, a2);
    v9 = *a3;
    if ( *a3 )
    {
      do
      {
        v10 = v9;
        v9 = (__int64 *)v9[2];
      }
      while ( v9 );
      result = 0;
      v10[2] = (__int64)v7;
    }
    else
    {
      result = 0;
      *a3 = v7;
    }
  }
  else
  {
    DHfree(v7);
    return 65514;
  }
  return result;
}

//----- (00000000000120B8) ----------------------------------------------------
void __fastcall DomainListDestroy(__int64 a1)
{
  __int64 v1; // x8
  void **v2; // x20
  __int64 v3; // x19

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 16);
    v2 = (void **)a1;
    if ( v1 )
    {
      do
      {
        v3 = v1;
        if ( *v2 )
          DHfree(*v2);
        *v2 = 0;
        DHfree(v2);
        v1 = *(_QWORD *)(v3 + 16);
        v2 = (void **)v3;
      }
      while ( v1 );
    }
    else
    {
      v3 = a1;
    }
    if ( *(_QWORD *)v3 )
      DHfree(*(void **)v3);
    *(_QWORD *)v3 = 0;
    DHfree((void *)v3);
  }
}

//----- (0000000000012128) ----------------------------------------------------
__int64 __fastcall sub_12128(unsigned __int8 *a1, int a2, void *a3, int *a4, void *a5, int *a6)
{
  int v12; // w9
  __int64 v13; // x10
  __int64 v14; // x8
  int v15; // w10
  int v16; // w9
  unsigned __int8 *v17; // x10
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // w10
  __int64 v21; // x11

  *a4 = 0;
  *a6 = 0;
  DHmemset(a3, 0, 16);
  DHmemset(a5, 0, 64);
  printLogD();
  while ( 1 )
  {
    v12 = *a1++;
    if ( v12 == 61 || v12 == 58 )
      break;
    if ( v12 == 32 )
    {
      --a2;
    }
    else
    {
      v13 = *a4;
      if ( (int)v13 >= 17 )
      {
LABEL_16:
        printLogD();
        return 65335;
      }
      *a4 = v13 + 1;
      *((_BYTE *)a3 + v13) = v12;
    }
  }
  *((_BYTE *)a3 + *a4) = 0;
  v14 = 0;
  do
    v15 = a1[v14++];
  while ( v15 == 32 );
  v16 = a2 - *a4;
  if ( ~(_DWORD)v14 + v16 >= 1 )
  {
    v17 = &a1[v14];
    v18 = v16 - v14;
    v19 = v17 - 1;
    do
    {
      v20 = *v19;
      if ( v20 == 32 )
        break;
      v21 = *a6;
      if ( (int)v21 >= 65 )
        goto LABEL_16;
      --v18;
      ++v19;
      *a6 = v21 + 1;
      *((_BYTE *)a5 + v21) = v20;
    }
    while ( v18 > 1 );
  }
  *((_BYTE *)a5 + *a6) = 0;
  printLogD();
  return 0;
}

//----- (00000000000122BC) ----------------------------------------------------
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3)
{
  unsigned int v6; // w20
  int v7; // w3
  int v8; // w4
  void *v9; // x0
  int v10; // w8
  void *v12; // x0
  int v13; // w8
  int v14; // w21
  int v15; // w8
  int v16; // w21
  int v17; // w3
  int v18; // w22
  unsigned __int8 *v19; // x0
  unsigned __int8 *v20; // x21
  int v21; // w24
  unsigned __int8 *v22; // x13
  int v23; // w9
  unsigned __int8 *v24; // x8
  int v25; // w23
  int v26; // w10
  __int64 v27; // x9
  char *v28; // x8
  int v29; // w8
  __int64 v30; // x12
  char *v31; // x8
  char *v32; // x11
  __int64 v33; // x21
  int v34; // w10
  unsigned __int8 *v35; // x13
  unsigned __int8 *v36; // x9
  int v37; // w11
  int v38; // t1
  int v39; // w26
  int v40; // w24
  void *v41; // x0
  int v42; // w24
  void *v43; // x0
  int v44; // w23
  char *v45; // x10
  int v46; // w9
  __int64 v47; // x8
  unsigned __int8 *v48; // x9
  int v49; // w11
  unsigned __int8 *v50; // x10
  int v51; // w12
  int v52; // t1
  int v53; // w26
  int v54; // w21
  int v55; // w24
  void *v56; // x0
  int v57; // w24
  void *v58; // x0
  int v59; // w23
  char *v60; // x10
  int v61; // w9
  __int64 v62; // x8
  unsigned __int8 *v63; // x9
  int v64; // w11
  unsigned __int8 *v65; // x10
  int v66; // w12
  int v67; // t1
  int v68; // w24
  int v69; // w26
  int v70; // w21
  void *v71; // x0
  int v72; // w21
  void *v73; // x0
  int v74; // w24
  void *v75; // x0
  int v76; // w24
  void *v77; // x0
  int v78; // w24
  int v79; // w24
  void *v80; // x0
  int v81; // w21
  void *v82; // x0
  int v83; // w24
  void *v84; // x0
  char *v85; // x10
  int v86; // w9
  __int64 v87; // x8
  unsigned __int8 *v88; // x9
  int v89; // w11
  unsigned __int8 *v90; // x10
  int v91; // w12
  int v92; // t1
  int v93; // w26
  int v94; // w23
  __int64 v95; // x21
  void *v96; // x0
  __int64 v97; // x24
  __int64 v98; // x8
  __int64 v99; // x9
  __int64 v100; // x24
  int i; // w8
  void *v102; // x0
  int v103; // w21
  void *v104; // x0
  int v105; // w24
  void *v106; // x0
  int v107; // w21
  char *v108; // x10
  int v109; // w9
  __int64 v110; // x8
  unsigned __int8 *v111; // x9
  int v112; // w11
  unsigned __int8 *v113; // x10
  int v114; // w12
  int v115; // t1
  int v116; // w26
  int v117; // w23
  int v118; // w24
  void *v119; // x0
  void *v120; // x0
  int v121; // w24
  void *v122; // x0
  void *v123; // x0
  int v124; // w24
  void *v125; // x0
  void *v126; // x21
  const char *v127; // x0
  const char *v128; // x24
  void *v129; // x0
  char *v130; // x0
  __int64 v131; // x24
  int v132; // w21
  __int64 v133; // x21
  unsigned __int64 v134; // x21
  __int64 v135; // x21
  unsigned __int16 v136; // w24
  __int64 v137; // x24
  unsigned __int64 v138; // x21
  const char *v139; // x0
  const char *v140; // x24
  void *v141; // x0
  char *v142; // x0
  char *v143; // x10
  int v144; // w9
  __int64 v145; // x8
  unsigned __int8 *v146; // x9
  int v147; // w11
  unsigned __int8 *v148; // x10
  int v149; // w12
  int v150; // t1
  int v151; // w26
  int v152; // w23
  int v153; // w24
  void *v154; // x0
  int v155; // w24
  void *v156; // x0
  __int64 v157; // x23
  int v158; // w22
  int v159; // w24
  int v160; // w0
  void *v161; // x0
  __int64 j; // x23
  char *v163; // x26
  int v164; // w0
  char *v165; // x26
  int v166; // w0
  char *v167; // x24
  int v168; // w0
  char *v169; // x24
  int v170; // w0
  _BYTE *v171; // x0
  int v172; // w8
  char *v173; // x0
  unsigned __int64 v174; // [xsp+8h] [xbp-C78h]
  unsigned __int64 v175; // [xsp+10h] [xbp-C70h]
  int v176; // [xsp+18h] [xbp-C68h]
  char *v177; // [xsp+18h] [xbp-C68h]
  int v178; // [xsp+18h] [xbp-C68h]
  void **v179; // [xsp+20h] [xbp-C60h]
  void **v180; // [xsp+28h] [xbp-C58h]
  void **v181; // [xsp+30h] [xbp-C50h]
  void **v182; // [xsp+38h] [xbp-C48h]
  void *v183; // [xsp+40h] [xbp-C40h]
  unsigned __int8 *v184; // [xsp+50h] [xbp-C30h]
  int v185; // [xsp+5Ch] [xbp-C24h] BYREF
  int v186; // [xsp+60h] [xbp-C20h] BYREF
  _BYTE ptr[514]; // [xsp+64h] [xbp-C1Ch] BYREF
  _BYTE v188[10]; // [xsp+266h] [xbp-A1Ah] BYREF
  _BYTE v189[256]; // [xsp+270h] [xbp-A10h] BYREF
  _BYTE v190[256]; // [xsp+370h] [xbp-910h] BYREF
  char v191[2048]; // [xsp+470h] [xbp-810h] BYREF
  __int64 v192; // [xsp+C70h] [xbp-10h]

  v192 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  printLogD();
  DHmemset(ptr, 0, 512);
  if ( (int)DHfsRead(a1, ptr, 3) < 3 )
  {
    v6 = 65523;
    goto LABEL_7;
  }
  v7 = ptr[1];
  v8 = ptr[2];
  *(_WORD *)a2 = ptr[0];
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  printLogD();
  if ( *(_WORD *)a2 != 1 )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  v9 = DHmalloc(*(_DWORD *)(a2 + 4) + 1);
  v10 = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a2 + 16) = v9;
  DHmemset(v9, 0, v10 + 1);
  if ( (int)DHfsRead(a1, *(void **)(a2 + 16), *(_DWORD *)(a2 + 4)) < *(_DWORD *)(a2 + 4) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v12 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  v13 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 24) = v12;
  DHmemset(v12, 0, v13 + 1);
  if ( (int)DHfsRead(a1, *(void **)(a2 + 24), *(_DWORD *)(a2 + 8)) < *(_DWORD *)(a2 + 8) )
  {
    v6 = 65528;
    goto LABEL_7;
  }
  printLogD();
  v14 = 0;
  while ( (int)DHfsRead(a1, v191, 1) >= 1 )
  {
    v15 = v191[0] & 0x7F | (v14 << 7);
    v14 = v15;
    if ( (v191[0] & 0x80) == 0 )
      goto LABEL_15;
  }
  v15 = -1;
LABEL_15:
  v16 = 0;
  *(_DWORD *)(a2 + 32) = v15;
  while ( (int)DHfsRead(a1, v191, 1) >= 1 )
  {
    v17 = v191[0] & 0x7F | (v16 << 7);
    v16 = v17;
    if ( (v191[0] & 0x80) == 0 )
      goto LABEL_20;
  }
  v17 = -1;
LABEL_20:
  *(_DWORD *)(a2 + 36) = v17;
  printLogD();
  v18 = *(_DWORD *)(a2 + 32);
  if ( !v18 )
  {
    *a3 = 0;
    v6 = 65528;
    goto LABEL_7;
  }
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 68) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  v182 = (void **)(a2 + 88);
  *(_QWORD *)(a2 + 192) = 0;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_QWORD *)(a2 + 200) = 0;
  *(_QWORD *)(a2 + 208) = 0;
  *(_DWORD *)(a2 + 216) = 0;
  *(_OWORD *)(a2 + 240) = 0u;
  printLogD();
  v19 = (unsigned __int8 *)DHmalloc(v18 + 1);
  if ( !v19 )
    goto LABEL_242;
  v20 = v19;
  v179 = (void **)(a2 + 192);
  v180 = (void **)(a2 + 224);
  v181 = (void **)(a2 + 40);
  v21 = DHfsRead(a1, v19, v18);
  printLogD();
  printLogD();
  v183 = v20;
  v20[v21] = 0;
  if ( v18 >= 1 )
  {
    v22 = v20;
    while ( 1 )
    {
      v23 = 0;
      v24 = v22;
      while ( 1 )
      {
        v26 = *v24;
        if ( v26 == 13 )
          break;
        ++v24;
LABEL_29:
        v25 = v23 + 1;
        v191[v23] = v26;
        v23 = v25;
        if ( v18 <= v25 )
          goto LABEL_33;
      }
      v191[v23] = 13;
      v25 = v23 + 1;
      v26 = v24[1];
      if ( v26 != 10 )
      {
        v24 += 2;
        ++v23;
        goto LABEL_29;
      }
LABEL_33:
      v27 = v25;
      v28 = &v191[v25];
      if ( v18 <= v25 )
      {
        *v28 = 0;
      }
      else
      {
        ++v25;
        *(v28 - 1) = 0;
        v27 = v25;
      }
      v29 = (unsigned __int8)v191[0];
      v185 = 0;
      if ( v191[0] == 32 )
      {
        v30 = 0;
        do
        {
          v31 = &v191[v30++];
          v29 = (unsigned __int8)v31[1];
        }
        while ( v29 == 32 );
        v185 = v30;
        v32 = &v191[v30];
      }
      else
      {
        LODWORD(v30) = 0;
        v32 = v191;
      }
      v33 = (int)v30;
      v34 = 0;
      v35 = &v22[v27];
      v18 -= v25;
      v36 = (unsigned __int8 *)(v32 + 1);
      while ( 2 )
      {
        if ( v29 > 58 )
        {
          if ( v29 == 59 )
          {
            v37 = 0;
          }
          else
          {
            if ( v29 == 61 )
              goto LABEL_51;
LABEL_50:
            v37 = v34 + 1;
            v190[v34] = v29;
          }
          ++v33;
          v38 = *v36++;
          v29 = v38;
          v185 = v33;
          v34 = v37;
          continue;
        }
        break;
      }
      if ( v29 && v29 != 58 )
        goto LABEL_50;
LABEL_51:
      v184 = v35;
      v190[v34] = 0;
      sub_15D88(&v191[v33 + 1], (__int64)v189, &v186, &v185);
      v39 = v185 + v33 + 2;
      if ( !(unsigned int)DHstrnicmp("encryption-method", v190, 17) )
        break;
      if ( !(unsigned int)DHstrnicmp("Service-Name", v190, 12) )
      {
        printLogD();
        v57 = v186;
        v58 = DHmalloc(v186 + 1);
        *v181 = v58;
        if ( !v58 )
          goto LABEL_248;
        DHmemset(v58, 0, v57 + 1);
        DHmemcpy(*v181, v189, v57);
        v59 = v25 - 1;
        while ( 1 )
        {
          v60 = &v191[v39];
          v185 = 0;
          v61 = (unsigned __int8)*v60;
          if ( v61 == 32 )
          {
            v62 = 0;
            do
            {
              v63 = (unsigned __int8 *)&v60[v62++];
              v61 = v63[1];
            }
            while ( v61 == 32 );
            v185 = v62;
            v60 += v62;
          }
          else
          {
            LODWORD(v62) = 0;
          }
          v64 = 0;
          v65 = (unsigned __int8 *)(v60 + 1);
          while ( v61 > 58 )
          {
            if ( v61 == 59 )
            {
              v66 = 0;
              goto LABEL_99;
            }
            if ( v61 == 61 )
              goto LABEL_107;
LABEL_106:
            v66 = v64 + 1;
            v190[v64] = v61;
LABEL_99:
            LODWORD(v62) = v62 + 1;
            v67 = *v65++;
            v61 = v67;
            v185 = v62;
            v64 = v66;
          }
          if ( v61 && v61 != 58 )
            goto LABEL_106;
LABEL_107:
          v68 = v39 + v62;
          v190[v64] = 0;
          sub_15D88(&v191[v39 + 1 + (int)v62], (__int64)v189, &v186, &v185);
          v69 = v185;
          if ( !(unsigned int)DHstrnicmp("cidType", v190, 7) )
          {
            v70 = v186;
            v71 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 48) = v71;
            if ( !v71 )
              goto LABEL_248;
            DHmemset(v71, 0, v70 + 1);
            DHmemcpy(*(void **)(a2 + 48), v189, v70 + 1);
          }
          if ( !(unsigned int)DHstrnicmp("eServiceCode", v190, 12) )
          {
            v72 = v186;
            v73 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 56) = v73;
            if ( !v73 )
              goto LABEL_248;
            DHmemset(v73, 0, v72 + 1);
            DHmemcpy(*(void **)(a2 + 56), v189, v72 + 1);
          }
          v39 = v68 + v69 + 2;
          if ( v39 >= v59 )
            goto LABEL_25;
        }
      }
      if ( !(unsigned int)DHstrnicmp("rights-issuer", v190, 13) )
      {
        printLogD();
        v74 = v186;
        v75 = DHmalloc(v186 + 1);
        *v182 = v75;
        if ( !v75 )
          goto LABEL_248;
        DHmemset(v75, 0, v74 + 1);
        DHmemcpy(*v182, v189, v74);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-name", v190, 12) )
      {
        printLogD();
        v76 = v186;
        v77 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 96) = v77;
        if ( !v77 )
          goto LABEL_248;
        DHmemset(v77, 0, v76 + 1);
        DHmemcpy(*(void **)(a2 + 96), v189, v76);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-description", v190, 19) )
      {
        printLogD();
        v78 = v186;
        *(_QWORD *)(a2 + 104) = DHmalloc(v186 + 1);
        printLogD();
        if ( !*(_QWORD *)(a2 + 104) )
        {
          printLogD();
          DHfree(v183);
          goto LABEL_241;
        }
        printLogD();
        printLogD();
        DHmemset(*(void **)(a2 + 104), 0, v78 + 1);
        DHmemcpy(*(void **)(a2 + 104), v189, v78);
        printLogD();
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("content-vendor", v190, 14) )
      {
        printLogD();
        v79 = v186;
        v80 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 112) = v80;
        if ( !v80 )
          goto LABEL_248;
        DHmemset(v80, 0, v79 + 1);
        DHmemcpy(*(void **)(a2 + 112), v189, v79);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("icon-uri", v190, 8) )
      {
        printLogD();
        v81 = v186;
        v82 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 120) = v82;
        if ( !v82 )
          goto LABEL_248;
        DHmemset(v82, 0, v81 + 1);
        DHmemcpy(*(void **)(a2 + 120), v189, v81 + 1);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("eTarget", v190, 7) )
      {
        printLogD();
        v100 = 0;
        for ( i = v189[0]; v189[v100]; i = (unsigned __int8)v189[v100] )
        {
          if ( i == 44 )
            break;
          ++v100;
        }
        v102 = DHmalloc((int)v100 + 1);
        *(_QWORD *)(a2 + 128) = v102;
        if ( !v102 )
          goto LABEL_248;
        DHmemset(v102, 0, v100 + 1);
        DHmemcpy(*(void **)(a2 + 128), v189, v100);
        DHstrlwr(*(_BYTE **)(a2 + 128));
        v103 = v186;
        v104 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 136) = v104;
        if ( !v104 )
          goto LABEL_248;
        DHmemset(v104, 0, v103 + 1);
        DHmemcpy(*(void **)(a2 + 136), &v189[v100 + 1], ~(_DWORD)v100 + v103);
        printLogD();
        goto LABEL_26;
      }
      if ( !(unsigned int)DHstrnicmp("eCEK", v190, 4) )
      {
        printLogD();
        v105 = v186;
        v106 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 144) = v106;
        if ( !v106 )
          goto LABEL_248;
        DHmemset(v106, 0, v105 + 1);
        DHmemcpy(*(void **)(a2 + 144), v189, v105);
        v107 = v25 - 1;
        while ( 1 )
        {
          v108 = &v191[v39];
          v185 = 0;
          v109 = (unsigned __int8)*v108;
          if ( v109 == 32 )
          {
            v110 = 0;
            do
            {
              v111 = (unsigned __int8 *)&v108[v110++];
              v109 = v111[1];
            }
            while ( v109 == 32 );
            v185 = v110;
            v108 += v110;
          }
          else
          {
            LODWORD(v110) = 0;
          }
          v112 = 0;
          v113 = (unsigned __int8 *)(v108 + 1);
          while ( v109 > 58 )
          {
            if ( v109 == 59 )
            {
              v114 = 0;
              goto LABEL_167;
            }
            if ( v109 == 61 )
              goto LABEL_175;
LABEL_174:
            v114 = v112 + 1;
            v190[v112] = v109;
LABEL_167:
            LODWORD(v110) = v110 + 1;
            v115 = *v113++;
            v109 = v115;
            v185 = v110;
            v112 = v114;
          }
          if ( v109 && v109 != 58 )
            goto LABEL_174;
LABEL_175:
          v116 = v39 + v110;
          v190[v112] = 0;
          sub_15D88(&v191[v116 + 1], (__int64)v189, &v186, &v185);
          v117 = v185;
          if ( (unsigned int)DHstrnicmp("cidType", v190, 7) )
          {
            if ( (unsigned int)DHstrnicmp("dMethod", v190, 7) )
            {
              if ( !(unsigned int)DHstrnicmp("eValue", v190, 6) )
              {
                v118 = v186;
                v119 = DHmalloc(v186 + 1);
                *(_QWORD *)(a2 + 168) = v119;
                if ( !v119 )
                  goto LABEL_248;
                DHmemset(v119, 0, v118 + 1);
                v120 = *(void **)(a2 + 168);
                goto LABEL_158;
              }
            }
            else
            {
              v118 = v186;
              v123 = DHmalloc(v186 + 1);
              *(_QWORD *)(a2 + 160) = v123;
              if ( !v123 )
                goto LABEL_248;
              DHmemset(v123, 0, v118 + 1);
              v120 = *(void **)(a2 + 160);
LABEL_158:
              DHmemcpy(v120, v189, v118);
            }
          }
          else
          {
            v121 = v186;
            v122 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 152) = v122;
            if ( !v122 )
              goto LABEL_248;
            DHmemset(v122, 0, v121 + 1);
            DHmemcpy(*(void **)(a2 + 152), v189, v121);
            DHstrlwr(*(_BYTE **)(a2 + 152));
          }
          v39 = v116 + v117 + 2;
          if ( v39 >= v107 )
            goto LABEL_25;
        }
      }
      if ( (unsigned int)DHstrnicmp("Usage-Control", v190, 13) )
      {
        if ( (unsigned int)DHstrnicmp("Meta-Container", v190, 14) )
          goto LABEL_26;
        printLogD();
        v40 = v186;
        v41 = DHmalloc(v186 + 1);
        *v180 = v41;
        if ( !v41 )
          goto LABEL_248;
        DHmemset(v41, 0, v40 + 1);
        DHmemcpy(*v180, v189, v40);
        v176 = v25 - 1;
        while ( 2 )
        {
          v85 = &v191[v39];
          v185 = 0;
          v86 = (unsigned __int8)*v85;
          if ( v86 == 32 )
          {
            v87 = 0;
            do
            {
              v88 = (unsigned __int8 *)&v85[v87++];
              v86 = v88[1];
            }
            while ( v86 == 32 );
            v185 = v87;
            v85 += v87;
          }
          else
          {
            LODWORD(v87) = 0;
          }
          v89 = 0;
          v90 = (unsigned __int8 *)(v85 + 1);
LABEL_135:
          if ( v86 <= 58 )
          {
            if ( !v86 || v86 == 58 )
            {
LABEL_142:
              v93 = v39 + v87;
              v190[v89] = 0;
              sub_15D88(&v191[v93 + 1], (__int64)v189, &v186, &v185);
              v94 = v185;
              if ( (unsigned int)DHstrnicmp("encoding", v190, 8) )
              {
                v95 = *(_QWORD *)(a2 + 248);
                v96 = DHmalloc(648);
                v97 = (__int64)v96;
                if ( v95 )
                {
                  if ( !v96 )
                    goto LABEL_248;
                  DHmemset(v96, 0, 648);
                  DHstrncpy_s(v97, 128, (__int64)v190, 0x14u);
                  DHstrncpy_s(v97 + 128, 512, (__int64)v189, 0xFFu);
                  *(_QWORD *)(v97 + 640) = 0;
                  v98 = *(_QWORD *)(a2 + 248);
                  do
                  {
                    v99 = v98;
                    v98 = *(_QWORD *)(v98 + 640);
                  }
                  while ( v98 );
                  *(_QWORD *)(v99 + 640) = v97;
LABEL_126:
                  v39 = v93 + v94 + 2;
                  if ( v39 >= v176 )
                    goto LABEL_26;
                  continue;
                }
                *(_QWORD *)(a2 + 248) = v96;
                if ( v96 )
                {
                  DHmemset(v96, 0, 648);
                  DHstrncpy_s(*(_QWORD *)(a2 + 248), 128, (__int64)v190, 0x14u);
                  DHstrncpy_s(*(_QWORD *)(a2 + 248) + 128LL, 512, (__int64)v189, 0xFFu);
                  *(_QWORD *)(*(_QWORD *)(a2 + 248) + 640LL) = 0;
                  goto LABEL_126;
                }
              }
              else
              {
                v83 = v186;
                v84 = DHmalloc(v186 + 1);
                *(_QWORD *)(a2 + 232) = v84;
                if ( v84 )
                {
                  DHmemset(v84, 0, v83 + 1);
                  DHmemcpy(*(void **)(a2 + 232), v189, v83);
                  goto LABEL_126;
                }
              }
LABEL_248:
              DHfree(v183);
LABEL_241:
              printLogD();
LABEL_242:
              v6 = 65528;
              goto LABEL_7;
            }
LABEL_141:
            v91 = v89 + 1;
            v190[v89] = v86;
          }
          else
          {
            if ( v86 != 59 )
            {
              if ( v86 == 61 )
                goto LABEL_142;
              goto LABEL_141;
            }
            v91 = 0;
          }
          break;
        }
        LODWORD(v87) = v87 + 1;
        v92 = *v90++;
        v86 = v92;
        v185 = v87;
        v89 = v91;
        goto LABEL_135;
      }
      printLogD();
      v124 = v186;
      v125 = DHmalloc(v186 + 1);
      if ( !v125 )
        goto LABEL_249;
      v126 = v125;
      DHmemset(v125, 0, v124 + 1);
      DHmemcpy(v126, v189, v124);
      v127 = DHstristr((const char *)v126, "Time-Not-After");
      v177 = (char *)v126;
      if ( v127 )
      {
        v128 = v127;
        v129 = DHmalloc(19);
        *(_QWORD *)(a2 + 176) = v129;
        if ( !v129 )
        {
          DHfree(v183);
          v173 = (char *)v126;
          goto LABEL_250;
        }
        DHmemset(v129, 0, 19);
        DHmemcpy(*(void **)(a2 + 176), v128 + 15, 18);
        v130 = DHstrchr(*(const char **)(a2 + 176), 0x2Cu);
        if ( v130 )
          *v130 = 0;
        v131 = *(_QWORD *)(a2 + 176);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)v131, 4);
        v132 = (unsigned __int16)DHatoi();
        if ( v132 == 2099 )
          *(_DWORD *)(a2 + 216) = 1;
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 4), 2);
        v133 = v132 | ((unsigned int)DHatoi() << 16);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 6), 2);
        v134 = v133 | ((unsigned __int64)(unsigned __int16)DHatoi() << 32);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 8), 2);
        v174 = v134 | (DHatoi() << 48);
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v131 + 10), 2);
        v135 = v131;
        v136 = DHatoi();
        DHmemset(v188, 0, 10);
        DHmemcpy(v188, (const void *)(v135 + 12), 2);
        v137 = v136 | ((unsigned __int16)DHatoi() << 16);
        v138 = v175 & 0xFFFFFFFF00000000LL | v137;
        *(_DWORD *)(a2 + 184) = DHmktime(v174, v137);
        printLogD();
      }
      else
      {
        v138 = v175;
      }
      v139 = DHstristr(v177, "Allowable-Services");
      v175 = v138;
      if ( v139 )
      {
        v140 = v139;
        v141 = DHmalloc(9);
        *v179 = v141;
        if ( !v141 )
        {
          DHfree(v183);
          v173 = v177;
          goto LABEL_250;
        }
        DHmemset(v141, 0, 9);
        DHmemcpy(*v179, v140 + 19, 8);
        v142 = DHstrchr((const char *)*v179, 0x2Cu);
        if ( v142 )
          *v142 = 0;
      }
      DHfree(v177);
      v178 = v25 - 1;
      while ( 2 )
      {
        v143 = &v191[v39];
        v185 = 0;
        v144 = (unsigned __int8)*v143;
        if ( v144 == 32 )
        {
          v145 = 0;
          do
          {
            v146 = (unsigned __int8 *)&v143[v145++];
            v144 = v146[1];
          }
          while ( v144 == 32 );
          v185 = v145;
          v143 += v145;
        }
        else
        {
          LODWORD(v145) = 0;
        }
        v147 = 0;
        v148 = (unsigned __int8 *)(v143 + 1);
        while ( 2 )
        {
          if ( v144 > 58 )
          {
            if ( v144 == 59 )
            {
              v149 = 0;
            }
            else
            {
              if ( v144 == 61 )
                goto LABEL_215;
LABEL_214:
              v149 = v147 + 1;
              v190[v147] = v144;
            }
            LODWORD(v145) = v145 + 1;
            v150 = *v148++;
            v144 = v150;
            v185 = v145;
            v147 = v149;
            continue;
          }
          break;
        }
        if ( v144 && v144 != 58 )
          goto LABEL_214;
LABEL_215:
        v151 = v39 + v145;
        v190[v147] = 0;
        sub_15D88(&v191[v151 + 1], (__int64)v189, &v186, &v185);
        v152 = v185;
        if ( (unsigned int)DHstrnicmp("cidType", v190, 7) )
        {
          if ( (unsigned int)DHstrnicmp("eAuthCode", v190, 9) )
            goto LABEL_199;
          v153 = v186;
          v154 = DHmalloc(v186 + 1);
          *(_QWORD *)(a2 + 208) = v154;
          if ( v154 )
          {
            DHmemset(v154, 0, v153 + 1);
            DHmemcpy(*(void **)(a2 + 208), v189, v153);
            goto LABEL_199;
          }
LABEL_249:
          v173 = (char *)v183;
LABEL_250:
          DHfree(v173);
          goto LABEL_241;
        }
        v155 = v186;
        v156 = DHmalloc(v186 + 1);
        *(_QWORD *)(a2 + 200) = v156;
        if ( !v156 )
          goto LABEL_249;
        DHmemset(v156, 0, v155 + 1);
        DHmemcpy(*(void **)(a2 + 200), v189, v155);
        DHstrlwr(*(_BYTE **)(a2 + 200));
LABEL_199:
        v39 = v151 + v152 + 2;
        if ( v39 < v178 )
          continue;
        break;
      }
LABEL_25:
      printLogD();
      printLogD();
LABEL_26:
      v22 = v184;
      if ( v18 <= 0 )
        goto LABEL_222;
    }
    printLogD();
    v42 = v186;
    v43 = DHmalloc(v186 + 1);
    *(_QWORD *)(a2 + 64) = v43;
    if ( !v43 )
      goto LABEL_248;
    DHmemset(v43, 0, v42 + 1);
    DHmemcpy(*(void **)(a2 + 64), v189, v42);
    v44 = v25 - 1;
LABEL_68:
    v45 = &v191[v39];
    v185 = 0;
    v46 = (unsigned __int8)*v45;
    if ( v46 == 32 )
    {
      v47 = 0;
      do
      {
        v48 = (unsigned __int8 *)&v45[v47++];
        v46 = v48[1];
      }
      while ( v46 == 32 );
      v185 = v47;
      v45 += v47;
    }
    else
    {
      LODWORD(v47) = 0;
    }
    v49 = 0;
    v50 = (unsigned __int8 *)(v45 + 1);
    while ( 1 )
    {
      if ( v46 <= 58 )
      {
        if ( !v46 || v46 == 58 )
        {
LABEL_83:
          v53 = v39 + v47;
          v190[v49] = 0;
          sub_15D88(&v191[v53 + 1], (__int64)v189, &v186, &v185);
          v54 = v185;
          if ( (unsigned int)DHstrnicmp("padding", v190, 7) )
          {
            if ( (unsigned int)DHstrnicmp("plaintextlen", v190, 12) )
            {
              if ( !(unsigned int)DHstrnicmp("hlen", v190, 4) )
                *(_DWORD *)(a2 + 84) = DHatoi();
            }
            else
            {
              *(_DWORD *)(a2 + 80) = DHatoi();
            }
          }
          else
          {
            v55 = v186;
            v56 = DHmalloc(v186 + 1);
            *(_QWORD *)(a2 + 72) = v56;
            if ( !v56 )
              goto LABEL_248;
            DHmemset(v56, 0, v55 + 1);
            DHmemcpy(*(void **)(a2 + 72), v189, v55);
          }
          v39 = v53 + v54 + 2;
          if ( v39 >= v44 )
            goto LABEL_25;
          goto LABEL_68;
        }
      }
      else
      {
        if ( v46 == 59 )
        {
          v51 = 0;
          goto LABEL_75;
        }
        if ( v46 == 61 )
          goto LABEL_83;
      }
      v51 = v49 + 1;
      v190[v49] = v46;
LABEL_75:
      LODWORD(v47) = v47 + 1;
      v52 = *v50++;
      v46 = v52;
      v185 = v47;
      v49 = v51;
    }
  }
LABEL_222:
  if ( *(_QWORD *)(a2 + 248) )
  {
    printLogD();
    v157 = *(_QWORD *)(a2 + 248);
    if ( v157 )
    {
      v158 = 1;
      do
      {
        v159 = DHstrlen((const char *)v157);
        v160 = DHstrlen((const char *)(v157 + 128));
        v157 = *(_QWORD *)(v157 + 640);
        v158 += v159 + v160 + 2;
      }
      while ( v157 );
    }
    else
    {
      v158 = 1;
    }
    v161 = DHmalloc(v158);
    *(_QWORD *)(a2 + 240) = v161;
    if ( !v161 )
    {
      DHfree(v183);
      goto LABEL_242;
    }
    DHmemset(v161, 0, v158);
    for ( j = *(_QWORD *)(a2 + 248); *(_QWORD *)(j + 640); j = *(_QWORD *)(j + 640) )
    {
      v163 = *(char **)(a2 + 240);
      v164 = DHstrlen((const char *)j);
      DHstrncat_s(v163, v158, j, v164);
      DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)"=", 1);
      v165 = *(char **)(a2 + 240);
      v166 = DHstrlen((const char *)(j + 128));
      DHstrncat_s(v165, v158, j + 128, v166);
      DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)";", 1);
    }
    v167 = *(char **)(a2 + 240);
    v168 = DHstrlen((const char *)j);
    DHstrncat_s(v167, v158, j, v168);
    DHstrncat_s(*(char **)(a2 + 240), v158, (__int64)"=", 1);
    v169 = *(char **)(a2 + 240);
    v170 = DHstrlen((const char *)(j + 128));
    DHstrncat_s(v169, v158, j + 128, v170);
  }
  DHfree(v183);
  if ( !*(_QWORD *)(a2 + 128) )
    goto LABEL_241;
  printLogD();
  v171 = *(_BYTE **)(a2 + 64);
  if ( v171 )
  {
    if ( (unsigned int)DHstrnicmp(v171, "aes128ecb", 255) )
    {
      if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cbc", 255) )
      {
        if ( (unsigned int)DHstrnicmp(*(_BYTE **)(a2 + 64), "aes128cfb1", 255) )
          v172 = 0;
        else
          v172 = 3;
      }
      else
      {
        v172 = 2;
      }
    }
    else
    {
      v172 = 1;
    }
  }
  else
  {
    v172 = 0;
  }
  v6 = 0;
  *a3 = v172;
LABEL_7:
  printLogD();
  return v6;
}
// 13508: variable 'v175' is possibly undefined

//----- (0000000000013B40) ----------------------------------------------------
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  __int64 v4; // d0
  void *v5; // x0
  void *v6; // x0
  int v7; // w8
  int v8; // w9
  const char *v9; // x0
  int v10; // w0
  void *v11; // x0
  void *v12; // x21
  int v13; // w0
  const char *v14; // x22
  void *v15; // x21
  int v16; // w0
  const char *v17; // x0
  int v18; // w0
  void *v19; // x0
  void *v20; // x21
  int v21; // w0
  const char *v22; // x22
  void *v23; // x21
  int v24; // w0
  const char *v25; // x0
  int v26; // w0
  void *v27; // x0
  void *v28; // x21
  int v29; // w0
  const char *v30; // x22
  void *v31; // x21
  int v32; // w0
  const char *v33; // x0
  int v34; // w0
  void *v35; // x0
  void *v36; // x21
  int v37; // w0
  const char *v38; // x22
  void *v39; // x21
  int v40; // w0
  __int64 result; // x0
  _BYTE *v42; // x0
  _BYTE *v43; // x0
  _BYTE *v44; // x0
  _BYTE *v45; // x0
  const char *v46; // x0
  int v47; // w0
  void *v48; // x0
  void *v49; // x21
  int v50; // w0
  const char *v51; // x22
  void *v52; // x21
  int v53; // w0
  _BYTE *v54; // x0
  const char *v55; // x0
  int v56; // w0
  void *v57; // x0
  void *v58; // x21
  int v59; // w0
  const char *v60; // x22
  void *v61; // x21
  int v62; // w0
  _BYTE *v63; // x0
  const char *v64; // x0
  int v65; // w0
  void *v66; // x0
  void *v67; // x21
  int v68; // w0
  const char *v69; // x22
  void *v70; // x21
  int v71; // w0
  _BYTE *v72; // x0
  const char *v73; // x0
  int v74; // w0
  void *v75; // x0
  void *v76; // x21
  int v77; // w0
  const char *v78; // x22
  void *v79; // x21
  int v80; // w0
  _BYTE *v81; // x0
  const char *v82; // x0
  int v83; // w0
  void *v84; // x0
  void *v85; // x21
  int v86; // w0
  const char *v87; // x20
  void *v88; // x19
  int v89; // w0
  _BYTE *v90; // x0
  _BYTE *v91; // x8

  printLogD();
  v4 = *(_QWORD *)(a2 + 4);
  *(_WORD *)(a1 + 4) = *(_WORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  v5 = DHmalloc((int)v4 + 1);
  *(_QWORD *)(a1 + 24) = v5;
  if ( !v5 )
    return 65514;
  DHmemset(v5, 0, *(_DWORD *)(a1 + 8) + 1);
  DHmemcpy(*(void **)(a1 + 24), *(const void **)(a2 + 16), *(_DWORD *)(a2 + 4));
  v6 = DHmalloc(*(_DWORD *)(a2 + 8) + 1);
  *(_QWORD *)(a1 + 40) = v6;
  if ( !v6 )
    return 65514;
  DHmemset(v6, 0, *(_DWORD *)(a1 + 12) + 1);
  DHmemcpy(*(void **)(a1 + 40), *(const void **)(a2 + 24), *(_DWORD *)(a2 + 8));
  v8 = *(_DWORD *)(a2 + 32);
  v7 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 48) = v8;
  *(_DWORD *)(a1 + 52) = v7;
  if ( !v8 )
    return 0;
  if ( *(_DWORD *)(a2 + 80) )
    v7 = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 56) = v7;
  v9 = *(const char **)(a2 + 96);
  if ( !v9 )
  {
    v42 = DHmalloc(1);
    *(_QWORD *)(a1 + 72) = v42;
    if ( !v42 )
      return 65514;
    *v42 = 0;
    v17 = *(const char **)(a2 + 104);
    if ( v17 )
      goto LABEL_9;
LABEL_18:
    v43 = DHmalloc(1);
    *(_QWORD *)(a1 + 88) = v43;
    if ( !v43 )
      return 65514;
    *v43 = 0;
    v25 = *(const char **)(a2 + 112);
    if ( v25 )
      goto LABEL_11;
    goto LABEL_20;
  }
  v10 = DHstrlen(v9);
  v11 = DHmalloc(v10 + 1);
  *(_QWORD *)(a1 + 72) = v11;
  if ( !v11 )
    return 65514;
  v12 = v11;
  v13 = DHstrlen(*(const char **)(a2 + 96));
  DHmemset(v12, 0, v13 + 1);
  v14 = *(const char **)(a2 + 96);
  v15 = *(void **)(a1 + 72);
  v16 = DHstrlen(v14);
  DHmemcpy(v15, v14, v16 + 1);
  v17 = *(const char **)(a2 + 104);
  if ( !v17 )
    goto LABEL_18;
LABEL_9:
  v18 = DHstrlen(v17);
  v19 = DHmalloc(v18 + 1);
  *(_QWORD *)(a1 + 88) = v19;
  if ( !v19 )
    return 65514;
  v20 = v19;
  v21 = DHstrlen(*(const char **)(a2 + 104));
  DHmemset(v20, 0, v21 + 1);
  v22 = *(const char **)(a2 + 104);
  v23 = *(void **)(a1 + 88);
  v24 = DHstrlen(v22);
  DHmemcpy(v23, v22, v24 + 1);
  v25 = *(const char **)(a2 + 112);
  if ( v25 )
  {
LABEL_11:
    v26 = DHstrlen(v25);
    v27 = DHmalloc(v26 + 1);
    *(_QWORD *)(a1 + 104) = v27;
    if ( !v27 )
      return 65514;
    v28 = v27;
    v29 = DHstrlen(*(const char **)(a2 + 112));
    DHmemset(v28, 0, v29 + 1);
    v30 = *(const char **)(a2 + 112);
    v31 = *(void **)(a1 + 104);
    v32 = DHstrlen(v30);
    DHmemcpy(v31, v30, v32 + 1);
    v33 = *(const char **)(a2 + 120);
    if ( v33 )
      goto LABEL_13;
    goto LABEL_22;
  }
LABEL_20:
  v44 = DHmalloc(1);
  *(_QWORD *)(a1 + 104) = v44;
  if ( !v44 )
    return 65514;
  *v44 = 0;
  v33 = *(const char **)(a2 + 120);
  if ( v33 )
  {
LABEL_13:
    v34 = DHstrlen(v33);
    v35 = DHmalloc(v34 + 1);
    *(_QWORD *)(a1 + 120) = v35;
    if ( !v35 )
      return 65514;
    v36 = v35;
    v37 = DHstrlen(*(const char **)(a2 + 120));
    DHmemset(v36, 0, v37 + 1);
    v38 = *(const char **)(a2 + 120);
    v39 = *(void **)(a1 + 120);
    v40 = DHstrlen(v38);
    DHmemcpy(v39, v38, v40 + 1);
    goto LABEL_24;
  }
LABEL_22:
  v45 = DHmalloc(1);
  *(_QWORD *)(a1 + 120) = v45;
  if ( !v45 )
    return 65514;
  *v45 = 0;
LABEL_24:
  v46 = *(const char **)(a2 + 176);
  if ( v46 )
  {
    v47 = DHstrlen(v46);
    v48 = DHmalloc(v47 + 1);
    *(_QWORD *)(a1 + 136) = v48;
    if ( !v48 )
      return 65514;
    v49 = v48;
    v50 = DHstrlen(*(const char **)(a2 + 176));
    DHmemset(v49, 0, v50 + 1);
    v51 = *(const char **)(a2 + 176);
    v52 = *(void **)(a1 + 136);
    v53 = DHstrlen(v51);
    DHmemcpy(v52, v51, v53 + 1);
  }
  else
  {
    v54 = DHmalloc(1);
    *(_QWORD *)(a1 + 136) = v54;
    if ( !v54 )
      return 65514;
    *v54 = 0;
  }
  v55 = *(const char **)(a2 + 192);
  if ( v55 )
  {
    v56 = DHstrlen(v55);
    v57 = DHmalloc(v56 + 1);
    *(_QWORD *)(a1 + 152) = v57;
    if ( !v57 )
      return 65514;
    v58 = v57;
    v59 = DHstrlen(*(const char **)(a2 + 192));
    DHmemset(v58, 0, v59 + 1);
    v60 = *(const char **)(a2 + 192);
    v61 = *(void **)(a1 + 152);
    v62 = DHstrlen(v60);
    DHmemcpy(v61, v60, v62 + 1);
  }
  else
  {
    v63 = DHmalloc(1);
    *(_QWORD *)(a1 + 152) = v63;
    if ( !v63 )
      return 65514;
    *v63 = 0;
  }
  v64 = *(const char **)(a2 + 224);
  if ( v64 )
  {
    v65 = DHstrlen(v64);
    v66 = DHmalloc(v65 + 1);
    *(_QWORD *)(a1 + 184) = v66;
    if ( !v66 )
      return 65514;
    v67 = v66;
    v68 = DHstrlen(*(const char **)(a2 + 224));
    DHmemset(v67, 0, v68 + 1);
    v69 = *(const char **)(a2 + 224);
    v70 = *(void **)(a1 + 184);
    v71 = DHstrlen(v69);
    DHmemcpy(v70, v69, v71 + 1);
  }
  else
  {
    v72 = DHmalloc(1);
    *(_QWORD *)(a1 + 184) = v72;
    if ( !v72 )
      return 65514;
    *v72 = 0;
  }
  v73 = *(const char **)(a2 + 232);
  if ( v73 )
  {
    v74 = DHstrlen(v73);
    v75 = DHmalloc(v74 + 1);
    *(_QWORD *)(a1 + 200) = v75;
    if ( !v75 )
      return 65514;
    v76 = v75;
    v77 = DHstrlen(*(const char **)(a2 + 232));
    DHmemset(v76, 0, v77 + 1);
    v78 = *(const char **)(a2 + 232);
    v79 = *(void **)(a1 + 200);
    v80 = DHstrlen(v78);
    DHmemcpy(v79, v78, v80 + 1);
  }
  else
  {
    v81 = DHmalloc(1);
    *(_QWORD *)(a1 + 200) = v81;
    if ( !v81 )
      return 65514;
    *v81 = 0;
  }
  v82 = *(const char **)(a2 + 240);
  if ( v82 )
  {
    v83 = DHstrlen(v82);
    v84 = DHmalloc(v83 + 1);
    *(_QWORD *)(a1 + 216) = v84;
    if ( v84 )
    {
      v85 = v84;
      v86 = DHstrlen(*(const char **)(a2 + 240));
      DHmemset(v85, 0, v86 + 1);
      v87 = *(const char **)(a2 + 240);
      v88 = *(void **)(a1 + 216);
      v89 = DHstrlen(v87);
      DHmemcpy(v88, v87, v89 + 1);
      return 0;
    }
  }
  else
  {
    v90 = DHmalloc(1);
    *(_QWORD *)(a1 + 216) = v90;
    if ( v90 )
    {
      v91 = v90;
      result = 0;
      *v91 = 0;
      return result;
    }
  }
  return 65514;
}

//----- (0000000000014028) ----------------------------------------------------
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0
  void *v8; // x0
  void *v9; // x0
  void *v10; // x0
  void *v11; // x0
  void *v12; // x0
  void *v13; // x0
  void *v14; // x0
  void *v15; // x0
  void *v16; // x0
  void *v17; // x0
  void *v18; // x0
  void *v19; // x0
  void *v20; // x0
  void *v21; // x0
  void *v22; // x0
  void *v23; // x0
  void *v24; // x0
  void *v25; // x0
  void *v26; // x0
  _QWORD *v27; // x0
  _QWORD *v28; // x8
  _QWORD *v29; // x20

  if ( a1 )
  {
    v2 = (void *)a1[2];
    if ( v2 )
      DHfree(v2);
    v3 = (void *)a1[3];
    if ( v3 )
      DHfree(v3);
    v4 = (void *)a1[8];
    if ( v4 )
      DHfree(v4);
    v5 = (void *)a1[9];
    if ( v5 )
      DHfree(v5);
    v6 = (void *)a1[11];
    if ( v6 )
      DHfree(v6);
    v7 = (void *)a1[12];
    if ( v7 )
      DHfree(v7);
    v8 = (void *)a1[13];
    if ( v8 )
      DHfree(v8);
    v9 = (void *)a1[14];
    if ( v9 )
      DHfree(v9);
    v10 = (void *)a1[15];
    if ( v10 )
      DHfree(v10);
    v11 = (void *)a1[17];
    if ( v11 )
      DHfree(v11);
    v12 = (void *)a1[16];
    if ( v12 )
      DHfree(v12);
    v13 = (void *)a1[5];
    if ( v13 )
      DHfree(v13);
    v14 = (void *)a1[6];
    if ( v14 )
      DHfree(v14);
    v15 = (void *)a1[7];
    if ( v15 )
      DHfree(v15);
    v16 = (void *)a1[18];
    if ( v16 )
      DHfree(v16);
    v17 = (void *)a1[20];
    if ( v17 )
      DHfree(v17);
    v18 = (void *)a1[21];
    if ( v18 )
      DHfree(v18);
    v19 = (void *)a1[19];
    if ( v19 )
      DHfree(v19);
    v20 = (void *)a1[22];
    if ( v20 )
      DHfree(v20);
    v21 = (void *)a1[24];
    if ( v21 )
      DHfree(v21);
    v22 = (void *)a1[26];
    if ( v22 )
      DHfree(v22);
    v23 = (void *)a1[25];
    if ( v23 )
      DHfree(v23);
    v24 = (void *)a1[28];
    if ( v24 )
      DHfree(v24);
    v25 = (void *)a1[29];
    if ( v25 )
      DHfree(v25);
    v26 = (void *)a1[30];
    if ( v26 )
      DHfree(v26);
    v27 = (_QWORD *)a1[31];
    if ( v27 )
    {
      v28 = (_QWORD *)v27[80];
      if ( v28 )
      {
        do
        {
          v29 = v28;
          DHfree(v27);
          v28 = (_QWORD *)v29[80];
          v27 = v29;
        }
        while ( v28 );
      }
      else
      {
        v29 = (_QWORD *)a1[31];
      }
      DHfree(v29);
    }
    DHfree(a1);
  }
}

//----- (00000000000141B0) ----------------------------------------------------
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  __int64 v3; // x12
  __int64 v4; // x11
  int8x16_t *v5; // x9
  int8x16_t *v6; // x10
  int8x16_t *v7; // x9
  int8x16_t *v8; // x10
  __int64 v9; // x12
  int8x16_t v10; // q0
  int8x16_t v11; // q1
  int8x8_t *v12; // x13
  int8x8_t *v13; // x14
  __int64 v14; // x11
  int8x8_t v15; // t1
  int v16; // w8
  unsigned __int8 v17; // t1

  if ( a3 >= 1 )
  {
    LODWORD(v3) = 0;
    if ( (unsigned int)a3 < 8 || (unsigned __int64)((char *)a2 - (char *)result) < 0x20 )
    {
      v5 = result;
      v6 = a2;
      goto LABEL_16;
    }
    if ( (unsigned int)a3 < 0x20 )
    {
      v4 = 0;
      goto LABEL_11;
    }
    v4 = a3 & 0x7FFFFFE0;
    v7 = a2 + 1;
    v8 = result + 1;
    v9 = v4;
    do
    {
      v10 = v8[-1];
      v11 = *v8;
      v9 -= 32;
      v8 += 2;
      v7[-1] = vmvnq_s8(v10);
      *v7 = vmvnq_s8(v11);
      v7 += 2;
    }
    while ( v9 );
    if ( v4 != a3 )
    {
      if ( (a3 & 0x18) == 0 )
      {
        v6 = (int8x16_t *)((char *)a2 + v4);
        v5 = (int8x16_t *)((char *)result + v4);
        LODWORD(v3) = a3 & 0x7FFFFFE0;
        goto LABEL_16;
      }
LABEL_11:
      v3 = a3 & 0x7FFFFFF8;
      v12 = (int8x8_t *)((char *)a2 + v4);
      v13 = (int8x8_t *)((char *)result + v4);
      v5 = (int8x16_t *)((char *)result + v3);
      v6 = (int8x16_t *)((char *)a2 + v3);
      v14 = v4 - v3;
      do
      {
        v15.n64_u64[0] = v13->n64_u64[0];
        ++v13;
        v14 += 8;
        v12->n64_u64[0] = vmvn_s8(v15).n64_u64[0];
        ++v12;
      }
      while ( v14 );
      if ( v3 == a3 )
        return result;
LABEL_16:
      v16 = a3 - v3;
      do
      {
        v17 = v5->n128_u8[0];
        v5 = (int8x16_t *)((char *)v5 + 1);
        --v16;
        v6->n128_u8[0] = ~v17;
        v6 = (int8x16_t *)((char *)v6 + 1);
      }
      while ( v16 );
    }
  }
  return result;
}

//----- (0000000000014290) ----------------------------------------------------
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5)
{
  int v10; // w8
  int v11; // w9
  char *v12; // x0
  char *v13; // x21
  unsigned __int64 v14; // x27
  __int64 result; // x0
  int v16; // w8
  int v17; // w26
  __int16 ClientID; // w0
  __int64 v19; // x8
  __int64 v20; // x12
  char *v21; // x9
  int8x16_t *v22; // x10
  __int64 v23; // x11
  int8x16_t *v24; // x10
  __int64 v25; // x12
  int8x16_t *v26; // x9
  int8x16_t v27; // q0
  int8x16_t v28; // q1
  int8x8_t *v29; // x14
  int8x8_t *v30; // x13
  __int64 v31; // x11
  int8x8_t v32; // t1
  int v33; // w8
  char v34; // t1
  unsigned int v35; // w22
  int v36; // w23
  char *v37; // x0
  int v38; // w2
  int v39; // w23
  char *v40; // x26
  char *v41; // x24
  char *v42; // x24
  int v43; // w4
  int v44; // w5
  int v45; // w6
  int v46; // w7
  __int64 v47; // x22
  __int64 v48; // x24
  int v49; // w25
  int v50; // w26
  int v51; // w25
  void *v52; // x0
  int v53; // w2
  __int64 v54; // x25
  char *v55; // x27
  char v56[8]; // [xsp+0h] [xbp-110h]
  int v57; // [xsp+Ch] [xbp-104h]
  int8x16_t *v58; // [xsp+20h] [xbp-F0h]
  int v59; // [xsp+2Ch] [xbp-E4h] BYREF
  __int64 v60; // [xsp+30h] [xbp-E0h] BYREF
  _QWORD v61[2]; // [xsp+38h] [xbp-D8h]
  __int64 v62; // [xsp+48h] [xbp-C8h] BYREF
  _QWORD v63[2]; // [xsp+50h] [xbp-C0h]
  __int64 v64; // [xsp+60h] [xbp-B0h] BYREF
  __int16 v65; // [xsp+68h] [xbp-A8h]
  char v66[32]; // [xsp+70h] [xbp-A0h] BYREF
  char v67[48]; // [xsp+90h] [xbp-80h] BYREF
  __int128 v68; // [xsp+C0h] [xbp-50h] BYREF
  _BYTE v69[35]; // [xsp+D0h] [xbp-40h] BYREF
  __int64 v70; // [xsp+F8h] [xbp-18h]

  v70 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v69, 0, sizeof(v69));
  v68 = 0u;
  *(_QWORD *)&v67[30] = 0;
  v11 = *(_DWORD *)(a5 + 8);
  v10 = *(_DWORD *)(a5 + 12);
  *(_QWORD *)&v67[25] = 0;
  memset(v66, 0, sizeof(v66));
  v65 = 0;
  v64 = 0;
  v62 = 0;
  v63[0] = 0;
  *(_QWORD *)((char *)v63 + 5) = 0;
  v60 = 0;
  v61[0] = 0;
  *(_QWORD *)((char *)v61 + 5) = 0;
  v12 = (char *)DHmalloc(v10 + v11 + 1);
  *(_QWORD *)(a5 + 24) = v12;
  if ( !v12 )
    return 65514;
  v13 = v12;
  DHmemset(v12, 0, *(_DWORD *)(a5 + 12) + *(_DWORD *)(a5 + 8) + 1);
  v14 = *(unsigned int *)(a5 + 12);
  result = 65501;
  if ( (_DWORD)v14 )
  {
    if ( !((unsigned int)v14 % 0x14) )
    {
      strcpy(v67, "SSE Primary-Level Base Key Generation");
      strcpy(v66, "SSE 2-Level Base Key Generation");
      DHmemset(&v60, 0, 21);
      DHmemset(&v64, 0, 10);
      v16 = DHstrlen(a2);
      result = 65509;
      if ( a3 )
      {
        if ( v16 >= 1 )
        {
          v17 = DHstrlen(a4);
          DHmemset(&v68, 0, 51);
          v59 = 51;
          ClientID = GetClientID(a1, (__int64)&v68, (unsigned int *)&v59);
          if ( ClientID < 0 )
            return (unsigned int)ClientID;
          DHstrlwr(&v68);
          v58 = (int8x16_t *)DHmalloc(v59);
          if ( v58 )
          {
            v19 = (unsigned int)v59;
            if ( v59 < 1 )
              goto LABEL_27;
            LODWORD(v20) = 0;
            v21 = (char *)&v68;
            if ( (unsigned int)v59 < 8 )
            {
              v22 = v58;
            }
            else
            {
              v22 = v58;
              if ( (unsigned __int64)((char *)v58 - (char *)&v68) >= 0x20 )
              {
                if ( (unsigned int)v59 < 0x20 )
                {
                  v23 = 0;
                  goto LABEL_19;
                }
                v23 = v59 & 0x7FFFFFE0;
                v24 = (int8x16_t *)v69;
                v25 = v23;
                v26 = v58 + 1;
                do
                {
                  v27 = v24[-1];
                  v28 = *v24;
                  v25 -= 32;
                  v24 += 2;
                  v26[-1] = vmvnq_s8(v27);
                  *v26 = vmvnq_s8(v28);
                  v26 += 2;
                }
                while ( v25 );
                if ( v23 == v19 )
                  goto LABEL_26;
                if ( (v19 & 0x18) != 0 )
                {
LABEL_19:
                  v20 = v19 & 0x7FFFFFF8;
                  v21 = &v69[v20 - 16];
                  v29 = (int8x8_t *)&v69[v23 - 16];
                  v22 = (int8x16_t *)((char *)v58 + v20);
                  v30 = (int8x8_t *)((char *)v58 + v23);
                  v31 = v23 - v20;
                  do
                  {
                    v32.n64_u64[0] = v29->n64_u64[0];
                    ++v29;
                    v31 += 8;
                    v30->n64_u64[0] = vmvn_s8(v32).n64_u64[0];
                    ++v30;
                  }
                  while ( v31 );
                  if ( v20 == v19 )
                    goto LABEL_26;
                  goto LABEL_24;
                }
                LODWORD(v20) = v19 & 0x7FFFFFE0;
                v21 = &v69[v23 - 16];
                v22 = (int8x16_t *)((char *)v58 + v23);
              }
            }
LABEL_24:
            v33 = v19 - v20;
            do
            {
              v34 = *v21++;
              --v33;
              v22->n128_u8[0] = ~v34;
              v22 = (int8x16_t *)((char *)v22 + 1);
            }
            while ( v33 );
LABEL_26:
            LODWORD(v19) = v59;
LABEL_27:
            v35 = v17 + a3;
            v36 = v17 + a3 + 2 * v19;
            v37 = (char *)DHmalloc(v36 + 38);
            if ( v37 )
            {
              v38 = v36 + 38;
              v39 = v17;
              v40 = v37;
              DHmemset(v37, 0, v38);
              DHmemcpy(v40, a2, a3);
              DHstrlwr(v40);
              v41 = &v40[a3];
              DHmemcpy(v41, a4, v39);
              v42 = &v41[v39];
              DHmemcpy(v42, &v68, v59);
              DHmemcpy(&v42[v59], v58, v59);
              DHmemcpy(&v42[2 * v59], v67, 37);
              DA_DRM_HASH_SHA1Digest((__int64)v40, (uint32x4_t *)&v62, v35 + 2 * v59 + 37);
              DHmemcpy(v13, &v62, 20);
              DHfree(v40);
              if ( (unsigned int)v14 < 0x28 )
              {
LABEL_32:
                DHmemcpy(&v13[*(unsigned int *)(a5 + 12)], v13, *(_DWORD *)(a5 + 8));
                DHfree(v58);
                return 0;
              }
              v47 = 1;
              v48 = 0x1400000000LL;
              *(_QWORD *)v56 = (v14 * (unsigned __int128)0xCCCCCCCCCCCCCCDuLL) >> 64;
              v57 = v39 + 20;
              while ( 1 )
              {
                v49 = v59;
                DHsprintf_s((char *)&v64, 10, "%d", v47 + 1, v43, v44, v45, v46, v56[0]);
                v50 = DHstrlen((const char *)&v64);
                v51 = v50 + v57 + 2 * v49;
                v52 = DHmalloc(v51 + 31);
                if ( !v52 )
                  break;
                v53 = v51 + 31;
                v54 = (__int64)v52;
                DHmemset(v52, 0, v53);
                DHmemcpy((void *)v54, &v62, 20);
                DHmemcpy((void *)(v54 + 20), a4, v39);
                v55 = (char *)(v54 + 20 + v39);
                DHmemcpy(v55, &v68, v59);
                DHmemcpy(&v55[v59], v58, v59);
                DHmemcpy(&v55[2 * v59], v66, 4);
                DHmemcpy(&v55[2 * v59 + 4], &v64, v50);
                DHmemcpy(&v55[2 * v59 + 4 + v50], &v66[5], 26);
                DA_DRM_HASH_SHA1Digest(v54, (uint32x4_t *)&v62, v50 + v57 + 2 * v59 + 30);
                DHmemcpy(&v13[v48 >> 32], &v62, 20);
                DHfree((void *)v54);
                ++v47;
                v48 += 0x1400000000LL;
                if ( *(_QWORD *)v56 == v47 )
                  goto LABEL_32;
              }
            }
          }
          return 65514;
        }
      }
    }
  }
  return result;
}
// 14638: variable 'v43' is possibly undefined
// 14638: variable 'v44' is possibly undefined
// 14638: variable 'v45' is possibly undefined
// 14638: variable 'v46' is possibly undefined
// 14638: variable 'v56' is possibly undefined

//----- (00000000000147AC) ----------------------------------------------------
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  __int64 result; // x0
  signed int v9; // w25
  int8x16_t *v10; // x0
  int v11; // w21
  int8x16_t *v12; // x20
  __int64 v13; // x27
  __int64 v14; // x22
  int v15; // w8
  __int64 i; // x8
  int v17; // w10
  int v18; // w26
  int v19; // w25
  int8x16_t *v20; // x0
  __int64 v21; // x24
  __int64 v22; // x10
  char *v23; // x8
  int8x16_t *v24; // x9
  __int64 v25; // x11
  int8x16_t *v26; // x0
  int8x16_t *v27; // x8
  int8x16_t *v28; // x9
  __int64 v29; // x10
  int8x16_t v30; // q0
  int8x16_t v31; // q1
  int8x8_t *v32; // x12
  int8x8_t *v33; // x13
  __int64 v34; // x11
  int8x8_t v35; // t1
  int v36; // w10
  char v37; // t1
  int v38; // w25
  __int64 v39; // x23
  int v40; // w26
  int v41; // w27
  char *v42; // x0
  int v43; // w8
  char *v44; // x26
  char *v45; // x19
  int v46; // [xsp+Ch] [xbp-F4h]
  int8x16_t *v47; // [xsp+18h] [xbp-E8h]
  int v48; // [xsp+24h] [xbp-DCh] BYREF
  __int64 v49; // [xsp+28h] [xbp-D8h] BYREF
  _QWORD v50[2]; // [xsp+30h] [xbp-D0h]
  __int64 v51; // [xsp+40h] [xbp-C0h] BYREF
  __int16 v52; // [xsp+48h] [xbp-B8h]
  char v53[48]; // [xsp+50h] [xbp-B0h] BYREF
  __int64 v54; // [xsp+80h] [xbp-80h] BYREF
  _QWORD v55[2]; // [xsp+88h] [xbp-78h]
  __int64 v56; // [xsp+98h] [xbp-68h] BYREF
  _QWORD v57[2]; // [xsp+A0h] [xbp-60h]
  __int128 v58; // [xsp+B0h] [xbp-50h] BYREF
  _BYTE v59[35]; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v60; // [xsp+E8h] [xbp-18h]

  v60 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v59, 0, sizeof(v59));
  v58 = 0u;
  v56 = 0;
  v57[0] = 0;
  *(_QWORD *)((char *)v57 + 5) = 0;
  strcpy(v53, "Encrypted Target Identifying Token Generation");
  v54 = 0;
  v55[0] = 0;
  *(_QWORD *)((char *)v55 + 5) = 0;
  v52 = 0;
  v51 = 0;
  v49 = 0;
  v50[0] = 0;
  *(_QWORD *)((char *)v50 + 5) = 0;
  printLogD();
  printLogD();
  result = 65501;
  if ( a1 && a2 && a3 && a4 )
  {
    v9 = DHstrlen(a4);
    v10 = (int8x16_t *)DHmalloc(v9 + 1);
    if ( !v10 )
      return 65514;
    v11 = v9;
    v12 = v10;
    v13 = v9;
    DHstrncpy_s((__int64)v10, v9 + 1, (__int64)a4, v9);
    DHstrlwr(v12);
    DHmemset(&v51, 0, 10);
    DHmemset(&v49, 0, 21);
    DHmemset(&v56, 0, 21);
    DHmemset(&v54, 0, 21);
    v14 = 0;
    if ( *a3 == 34 )
      ++a3;
    v15 = (unsigned __int8)*a3;
    if ( !*a3 )
      goto LABEL_25;
    while ( v15 != 47 )
    {
      *((_BYTE *)&v51 + v14++) = v15;
      v15 = (unsigned __int8)a3[v14];
      if ( !a3[v14] )
        goto LABEL_25;
    }
    DHstrlwr(&v51);
    for ( i = 0; ; *((_BYTE *)&v50[-1] + i++) = v17 )
    {
      v17 = (unsigned __int8)a3[i + 1 + v14];
      if ( !a3[i + 1 + v14] || v17 == 34 )
        break;
    }
    if ( v17 != 34 || (unsigned int)i != 20 )
    {
LABEL_25:
      DHfree(v12);
      printLogD();
      return 65434;
    }
    v18 = DHstrlen(a1);
    v19 = DHstrlen(a2);
    DHstrncpy_s((__int64)&v58, 50, (__int64)a2, v19);
    DHstrlwr(&v58);
    v20 = (int8x16_t *)DHmalloc(v19);
    if ( !v20 )
    {
      v26 = v12;
      goto LABEL_45;
    }
    v21 = v19;
    if ( v19 < 1 )
    {
LABEL_41:
      v47 = v20;
      DHmemset(&v56, 0, 21);
      DHmemset(&v54, 0, 21);
      v38 = v18;
      v39 = v13;
      v40 = v18 + 2 * v21;
      v41 = v40 + v13 + v14 + 46;
      v42 = (char *)DHmalloc(v41);
      if ( v42 )
      {
        v43 = v11 + v14 + v40;
        v44 = v42;
        v46 = v43;
        DHmemset(v42, 0, v41);
        DHmemcpy(v44, v12, v11);
        DHmemcpy(&v44[v39], &v51, v14);
        DHmemcpy(&v44[v39 + (unsigned int)v14], a1, v38);
        v45 = &v44[v39 + (unsigned int)v14 + v38];
        DHmemcpy(v45, &v58, v21);
        DHmemcpy(&v45[v21], v47, v21);
        DHmemcpy(&v45[2 * v21], v53, 45);
        DA_DRM_HASH_SHA1Digest((__int64)v44, (uint32x4_t *)&v54, v46 + 45);
        PP_HexEncode_A((unsigned __int8 *)&v54, 0xAu, &v56, &v48);
        DHfree(v47);
        DHfree(v44);
        DHfree(v12);
        printLogD();
        printLogD();
        if ( !(unsigned int)DHstrnicmp(&v49, &v56, 255) )
        {
          printLogD();
          return 0;
        }
        printLogD();
        printLogD();
        return 65434;
      }
      DHfree(v12);
      v26 = v47;
LABEL_45:
      DHfree(v26);
      return 65514;
    }
    LODWORD(v22) = 0;
    v23 = (char *)&v58;
    if ( (unsigned int)v19 < 8 )
    {
      v24 = v20;
    }
    else
    {
      v24 = v20;
      if ( (unsigned __int64)((char *)v20 - (char *)&v58) >= 0x20 )
      {
        if ( (unsigned int)v19 < 0x20 )
        {
          v25 = 0;
          goto LABEL_34;
        }
        v25 = v19 & 0x7FFFFFE0LL;
        v27 = v20 + 1;
        v28 = (int8x16_t *)v59;
        v29 = v25;
        do
        {
          v30 = v28[-1];
          v31 = *v28;
          v29 -= 32;
          v28 += 2;
          v27[-1] = vmvnq_s8(v30);
          *v27 = vmvnq_s8(v31);
          v27 += 2;
        }
        while ( v29 );
        if ( v25 == v19 )
          goto LABEL_41;
        if ( (v19 & 0x18LL) != 0 )
        {
LABEL_34:
          v22 = v19 & 0x7FFFFFF8LL;
          v32 = (int8x8_t *)((char *)v20 + v25);
          v23 = &v59[v22 - 16];
          v24 = (int8x16_t *)((char *)v20 + v22);
          v33 = (int8x8_t *)&v59[v25 - 16];
          v34 = v25 - v22;
          do
          {
            v35.n64_u64[0] = v33->n64_u64[0];
            ++v33;
            v34 += 8;
            v32->n64_u64[0] = vmvn_s8(v35).n64_u64[0];
            ++v32;
          }
          while ( v34 );
          if ( v22 == v19 )
            goto LABEL_41;
          goto LABEL_39;
        }
        v24 = (int8x16_t *)((char *)v20 + v25);
        LODWORD(v22) = v19 & 0x7FFFFFE0;
        v23 = &v59[v25 - 16];
      }
    }
LABEL_39:
    v36 = v19 - v22;
    do
    {
      v37 = *v23++;
      --v36;
      v24->n128_u8[0] = ~v37;
      v24 = (int8x16_t *)((char *)v24 + 1);
    }
    while ( v36 );
    goto LABEL_41;
  }
  return result;
}

//----- (0000000000014D0C) ----------------------------------------------------
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        char *a6,
        __int16 a7)
{
  int v14; // w0
  int v15; // w23
  int v17; // w26
  char *v18; // x0
  char *v19; // x19
  int v20; // w26
  int v21; // w8
  unsigned __int8 *v22; // x8
  _BYTE *v23; // x23
  int v24; // w8
  __int64 v25; // x8
  int v26; // w9
  __int16 ClientID; // w0
  int8x16_t *v28; // x0
  __int64 v29; // x9
  int8x16_t *v30; // x27
  int v31; // w23
  __int64 v32; // x13
  char *v33; // x10
  int8x16_t *v34; // x11
  __int64 v35; // x12
  unsigned int v36; // w20
  int8x16_t *v37; // x10
  int8x16_t *v38; // x11
  __int64 v39; // x13
  int8x16_t v40; // q0
  int8x16_t v41; // q1
  int8x8_t *v42; // x14
  int8x8_t *v43; // x15
  __int64 v44; // x12
  int8x8_t v45; // t1
  int v46; // w9
  char v47; // t1
  int v48; // w25
  char *v49; // x0
  char *v50; // x28
  int v51; // w10
  __int64 v52; // x11
  char *v53; // x21
  char *v54; // x20
  int v55; // [xsp+2Ch] [xbp-D4h]
  __int64 v56; // [xsp+30h] [xbp-D0h]
  int v57; // [xsp+38h] [xbp-C8h]
  unsigned int v58; // [xsp+44h] [xbp-BCh]
  unsigned int v59; // [xsp+48h] [xbp-B8h]
  int v60; // [xsp+4Ch] [xbp-B4h]
  int v61; // [xsp+50h] [xbp-B0h] BYREF
  uint32x4_t v62; // [xsp+54h] [xbp-ACh] BYREF
  char v63[21]; // [xsp+6Bh] [xbp-95h] BYREF
  __int128 v64; // [xsp+80h] [xbp-80h] BYREF
  _OWORD v65[3]; // [xsp+90h] [xbp-70h] BYREF
  __int128 v66; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v67; // [xsp+D0h] [xbp-30h]
  __int16 v68; // [xsp+D8h] [xbp-28h]
  char v69; // [xsp+DAh] [xbp-26h]
  _BYTE v70[21]; // [xsp+DBh] [xbp-25h] BYREF
  __int64 v71; // [xsp+F0h] [xbp-10h]

  v71 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v65, 0, 35);
  v64 = 0u;
  printLogD();
  printLogD();
  if ( !a5 )
  {
    if ( (a7 & 0xFFFE) == 0x1000 )
      return 4294967271LL;
    else
      return 0;
  }
  if ( a3 )
  {
    v14 = DHstrlen(a3);
    v15 = v14 + 14;
    v57 = v14;
    v59 = 14;
    if ( a4 )
    {
LABEL_4:
      v60 = DHstrlen(a4);
      v58 = 18;
      v15 += v60 + 18;
      goto LABEL_10;
    }
  }
  else
  {
    v57 = 0;
    v15 = 0;
    v59 = 0;
    if ( a4 )
      goto LABEL_4;
  }
  v60 = 0;
  v58 = 0;
LABEL_10:
  v17 = DHstrlen(a6);
  v18 = (char *)DHmalloc(v17 + 1);
  if ( !v18 )
    return 65514;
  v19 = v18;
  v56 = v17;
  DHmemset(v18, 0, v17 + 1);
  DHstrcpy_s(v19, v17 + 1, a6);
  DHstrlwr(v19);
  if ( a3 )
    DHstrlwr(a3);
  v20 = v17 + v15;
  printLogD();
  v21 = *a5;
  v69 = 0;
  v66 = xmmword_6CF0;
  if ( v21 == 34 )
    v22 = a5 + 1;
  else
    v22 = a5;
  v67 = *(_QWORD *)"Generatirati";
  v23 = v22 + 1;
  v68 = 28271;
  v24 = *v22;
  if ( !v24 )
    goto LABEL_32;
  while ( v24 != 47 )
  {
    v24 = (unsigned __int8)*v23++;
    if ( !*(v23 - 1) )
      goto LABEL_32;
  }
  printLogD();
  DHmemset(v70, 0, 21);
  v25 = 0;
  v26 = (unsigned __int8)*v23;
  if ( *v23 )
  {
    do
    {
      if ( v26 == 34 )
        break;
      v70[v25++] = v26;
      v26 = (unsigned __int8)v23[v25];
    }
    while ( v23[v25] );
  }
  if ( (_DWORD)v25 != 20 )
  {
LABEL_32:
    DHfree(v19);
    return 65511;
  }
  printLogD();
  v55 = DHstrlen(a2);
  DHmemset(&v64, 0, 51);
  v61 = 51;
  ClientID = GetClientID(a1, (__int64)&v64, (unsigned int *)&v61);
  if ( ClientID < 0 )
  {
    v36 = ClientID;
    DHfree(v19);
    return v36;
  }
  DHstrlwr(&v64);
  printLogD();
  DHstrlwr(&v64);
  printLogD();
  v28 = (int8x16_t *)DHmalloc(v61);
  if ( !v28 )
    goto LABEL_59;
  v29 = (unsigned int)v61;
  v30 = v28;
  if ( v61 < 1 )
  {
    v31 = v57;
    goto LABEL_49;
  }
  v31 = v57;
  LODWORD(v32) = 0;
  v33 = (char *)&v64;
  if ( (unsigned int)v61 < 8 )
  {
    v34 = v28;
  }
  else
  {
    v34 = v28;
    if ( (unsigned __int64)((char *)v28 - (char *)&v64) >= 0x20 )
    {
      if ( (unsigned int)v61 < 0x20 )
      {
        v35 = 0;
        goto LABEL_41;
      }
      v35 = v61 & 0x7FFFFFE0;
      v37 = v28 + 1;
      v38 = (int8x16_t *)v65;
      v39 = v35;
      do
      {
        v40 = v38[-1];
        v41 = *v38;
        v39 -= 32;
        v38 += 2;
        v37[-1] = vmvnq_s8(v40);
        *v37 = vmvnq_s8(v41);
        v37 += 2;
      }
      while ( v39 );
      if ( v35 == v29 )
        goto LABEL_48;
      if ( (v29 & 0x18) != 0 )
      {
LABEL_41:
        v32 = v29 & 0x7FFFFFF8;
        v42 = (int8x8_t *)((char *)v28 + v35);
        v33 = (char *)&v65[-1] + v32;
        v34 = (int8x16_t *)((char *)v28 + v32);
        v43 = (int8x8_t *)((char *)&v65[-1] + v35);
        v44 = v35 - v32;
        do
        {
          v45.n64_u64[0] = v43->n64_u64[0];
          ++v43;
          v44 += 8;
          v42->n64_u64[0] = vmvn_s8(v45).n64_u64[0];
          ++v42;
        }
        while ( v44 );
        if ( v32 == v29 )
          goto LABEL_48;
        goto LABEL_46;
      }
      v34 = (int8x16_t *)((char *)v28 + v35);
      LODWORD(v32) = v29 & 0x7FFFFFE0;
      v33 = (char *)&v65[-1] + v35;
    }
  }
LABEL_46:
  v46 = v29 - v32;
  do
  {
    v47 = *v33++;
    --v46;
    v34->n128_u8[0] = ~v47;
    v34 = (int8x16_t *)((char *)v34 + 1);
  }
  while ( v46 );
LABEL_48:
  LODWORD(v29) = v61;
LABEL_49:
  v48 = v20 + v55 + 2 * v29;
  v49 = (char *)DHmalloc(v48 + 27);
  if ( !v49 )
  {
    DHfree(v30);
LABEL_59:
    DHfree(v19);
    return 65514;
  }
  v50 = v49;
  DHmemset(v49, 0, v48 + 27);
  DHmemcpy(v50, v19, v56);
  if ( v31 )
    DHmemcpy(&v50[v56], "time-not-after", v59);
  v51 = v60;
  if ( v60 )
  {
    DHmemcpy(&v50[v56 + v59], "allowable-services", v58);
    v51 = v60;
  }
  v52 = v56;
  if ( v31 )
  {
    DHmemcpy(&v50[v56 + v59 + v58], a3, v31);
    v52 = v56;
    v51 = v60;
  }
  if ( v51 )
  {
    DHmemcpy(&v50[v52 + v59 + v58 + v31], a4, v60);
    v52 = v56;
    v51 = v60;
  }
  v53 = &v50[v52 + v59 + v58 + v31 + v51];
  DHmemcpy(v53, a2, v55);
  v54 = &v53[v55];
  DHmemcpy(v54, &v64, v61);
  DHmemcpy(&v54[v61], v30, v61);
  DHmemcpy(&v54[2 * v61], &v66, 26);
  printLogD();
  DA_DRM_HASH_SHA1Digest((__int64)v50, &v62, v48 + 26);
  DHsprintf_s(
    v63,
    21,
    "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
    v62.n128_u8[0],
    v62.n128_u8[1],
    v62.n128_u8[2],
    v62.n128_u8[3],
    v62.n128_u8[4],
    v62.n128_i8[5]);
  DHfree(v30);
  DHfree(v50);
  DHfree(v19);
  printLogD();
  if ( (unsigned int)DHstrnicmp(v70, v63, 20) )
  {
    printLogD();
    return 65511;
  }
  printLogD();
  return 0;
}
// 6CF0: using guessed type __int128 xmmword_6CF0;

//----- (0000000000015394) ----------------------------------------------------
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5)
{
  bool v6; // zf
  __int64 result; // x0
  signed int v12; // w20
  int8x16_t *v13; // x0
  int8x16_t *v14; // x19
  _BYTE *v15; // x8
  _BYTE *v16; // x8
  int v17; // w9
  __int64 v18; // x9
  int v19; // w11
  signed int v20; // w23
  int8x16_t *v21; // x0
  int8x16_t *v22; // x21
  unsigned int v23; // w0
  int v24; // w27
  unsigned int v25; // w25
  int8x16_t *v26; // x0
  int8x16_t *v27; // x22
  __int16 ClientID; // w0
  __int64 v29; // x8
  __int64 v30; // x12
  char *v31; // x9
  int8x16_t *v32; // x10
  __int64 v33; // x11
  int8x16_t *v34; // x0
  unsigned int v35; // w20
  int8x16_t *v36; // x10
  __int64 v37; // x12
  int8x16_t *v38; // x9
  int8x16_t v39; // q0
  int8x16_t v40; // q1
  int8x8_t *v41; // x14
  int8x8_t *v42; // x13
  __int64 v43; // x11
  int8x8_t v44; // t1
  int v45; // w8
  char v46; // t1
  signed int v47; // w24
  int v48; // w26
  char *v49; // x0
  int v50; // w2
  char *v51; // x26
  __int64 v52; // x20
  int v53; // [xsp+2Ch] [xbp-D4h]
  int8x16_t *v54; // [xsp+38h] [xbp-C8h]
  int v55; // [xsp+44h] [xbp-BCh] BYREF
  __int64 v56; // [xsp+48h] [xbp-B8h] BYREF
  _QWORD v57[2]; // [xsp+50h] [xbp-B0h]
  char v58[8]; // [xsp+60h] [xbp-A0h] BYREF
  _QWORD v59[2]; // [xsp+68h] [xbp-98h]
  __int64 v60; // [xsp+78h] [xbp-88h] BYREF
  _QWORD v61[2]; // [xsp+80h] [xbp-80h]
  char v62[32]; // [xsp+90h] [xbp-70h] BYREF
  __int128 v63; // [xsp+B0h] [xbp-50h] BYREF
  _BYTE v64[35]; // [xsp+C0h] [xbp-40h] BYREF
  __int64 v65; // [xsp+E8h] [xbp-18h]

  v6 = a1 == 0;
  result = 65501;
  v65 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v63 = 0u;
  memset(v64, 0, sizeof(v64));
  v60 = 0;
  v61[0] = 0;
  *(_QWORD *)((char *)v61 + 5) = 0;
  *(_QWORD *)v58 = 0;
  v59[0] = 0;
  *(_QWORD *)((char *)v59 + 5) = 0;
  v56 = 0;
  v57[0] = 0;
  *(_QWORD *)((char *)v57 + 5) = 0;
  if ( !v6 && a2 )
  {
    if ( !a3 && !a4 && !a5 )
      return 0;
    strcpy(v62, "eServiceCode Value Generation");
    v12 = DHstrlen(a2);
    v13 = (int8x16_t *)DHmalloc(v12 + 1);
    if ( !v13 )
      return 65514;
    v14 = v13;
    DHmemset(v13, 0, v12 + 1);
    DHstrncpy_s((__int64)v14, v12 + 1, (__int64)a2, v12);
    DHstrlwr(v14);
    v15 = a3 + 1;
    if ( *a3 != 34 )
      v15 = a3;
    v16 = v15 + 1;
    v17 = (unsigned __int8)*(v16 - 1);
    if ( !*(v16 - 1) )
      goto LABEL_27;
    while ( v17 != 47 )
    {
      v17 = (unsigned __int8)*v16++;
      if ( !*(v16 - 1) )
        goto LABEL_27;
    }
    v18 = 0;
    v19 = (unsigned __int8)*v16;
    if ( *v16 )
    {
      do
      {
        if ( v19 == 47 )
          break;
        *((_BYTE *)&v61[-1] + v18++) = v19;
        v19 = (unsigned __int8)v16[v18];
      }
      while ( v16[v18] );
    }
    if ( (_DWORD)v18 != 20 )
    {
LABEL_27:
      DHfree(v14);
      return 65432;
    }
    v20 = DHstrlen(a4);
    v21 = (int8x16_t *)DHmalloc(v20 + 1);
    if ( v21 )
    {
      v22 = v21;
      DHmemset(v21, 0, v20 + 1);
      DHstrncpy_s((__int64)v22, v20 + 1, (__int64)a4, v20);
      DHstrlwr(v22);
      v23 = DHstrlen(a5);
      v24 = v23 + 1;
      v25 = v23;
      v26 = (int8x16_t *)DHmalloc(v23 + 1);
      if ( v26 )
      {
        v27 = v26;
        DHmemset(v26, 0, v24);
        DHstrncpy_s((__int64)v27, v24, (__int64)a5, v25);
        DHstrlwr(v27);
        v55 = v24;
        ClientID = GetClientID(a1, (__int64)&v63, (unsigned int *)&v55);
        if ( ClientID < 0 )
        {
          v35 = ClientID;
          DHfree(v14);
          DHfree(v22);
          DHfree(v27);
          return v35;
        }
        DHstrlwr(&v63);
        v54 = (int8x16_t *)DHmalloc(v55 + 1);
        if ( v54 )
        {
          v29 = (unsigned int)v55;
          if ( v55 < 1 )
          {
LABEL_45:
            v47 = v25 + v12 + v20;
            v48 = v47 + 2 * v29;
            v49 = (char *)DHmalloc(v48 + 30);
            if ( v49 )
            {
              v50 = v48 + 30;
              v53 = v48;
              v51 = v49;
              DHmemset(v49, 0, v50);
              DHmemcpy(v51, v14, v12);
              DHmemcpy(&v51[v12], v22, v20);
              DHmemcpy(&v51[v12 + (__int64)v20], v27, v25);
              DHmemcpy(&v51[v47], &v63, v55);
              v52 = v55 + v47;
              DHmemcpy(&v51[v52], v54, v55);
              DHmemcpy(&v51[v55 + v52], v62, 29);
              DHfree(v14);
              DHfree(v22);
              DHfree(v27);
              DHfree(v54);
              DA_DRM_HASH_SHA1Digest((__int64)v51, (uint32x4_t *)v58, v53 + 29);
              DHsprintf_s(
                (char *)&v56,
                21,
                "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                (unsigned __int8)v58[0],
                (unsigned __int8)v58[1],
                (unsigned __int8)v58[2],
                (unsigned __int8)v58[3],
                (unsigned __int8)v58[4],
                v58[5]);
              DHfree(v51);
              if ( (unsigned int)DHstrnicmp(&v60, &v56, 20) )
                return 4294967192LL;
              else
                return 0;
            }
            DHfree(v14);
            DHfree(v22);
            DHfree(v27);
            v34 = v54;
            goto LABEL_50;
          }
          LODWORD(v30) = 0;
          v31 = (char *)&v63;
          if ( (unsigned int)v55 < 8 )
          {
            v32 = v54;
          }
          else
          {
            v32 = v54;
            if ( (unsigned __int64)((char *)v54 - (char *)&v63) >= 0x20 )
            {
              if ( (unsigned int)v55 < 0x20 )
              {
                v33 = 0;
                goto LABEL_37;
              }
              v33 = v55 & 0x7FFFFFE0;
              v36 = (int8x16_t *)v64;
              v37 = v33;
              v38 = v54 + 1;
              do
              {
                v39 = v36[-1];
                v40 = *v36;
                v37 -= 32;
                v36 += 2;
                v38[-1] = vmvnq_s8(v39);
                *v38 = vmvnq_s8(v40);
                v38 += 2;
              }
              while ( v37 );
              if ( v33 == v29 )
                goto LABEL_44;
              if ( (v29 & 0x18) != 0 )
              {
LABEL_37:
                v30 = v29 & 0x7FFFFFF8;
                v31 = &v64[v30 - 16];
                v41 = (int8x8_t *)&v64[v33 - 16];
                v32 = (int8x16_t *)((char *)v54 + v30);
                v42 = (int8x8_t *)((char *)v54 + v33);
                v43 = v33 - v30;
                do
                {
                  v44.n64_u64[0] = v41->n64_u64[0];
                  ++v41;
                  v43 += 8;
                  v42->n64_u64[0] = vmvn_s8(v44).n64_u64[0];
                  ++v42;
                }
                while ( v43 );
                if ( v30 == v29 )
                  goto LABEL_44;
                goto LABEL_42;
              }
              LODWORD(v30) = v29 & 0x7FFFFFE0;
              v31 = &v64[v33 - 16];
              v32 = (int8x16_t *)((char *)v54 + v33);
            }
          }
LABEL_42:
          v45 = v29 - v30;
          do
          {
            v46 = *v31++;
            --v45;
            v32->n128_u8[0] = ~v46;
            v32 = (int8x16_t *)((char *)v32 + 1);
          }
          while ( v45 );
LABEL_44:
          LODWORD(v29) = v55;
          goto LABEL_45;
        }
        DHfree(v14);
        DHfree(v22);
        v34 = v27;
      }
      else
      {
        DHfree(v14);
        v34 = v22;
      }
    }
    else
    {
      v34 = v14;
    }
LABEL_50:
    DHfree(v34);
    return 65514;
  }
  return result;
}

//----- (00000000000158D4) ----------------------------------------------------
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5)
{
  int v10; // w25
  char *v11; // x0
  char *v12; // x21
  int v13; // w24
  __int16 ClientID; // w0
  int8x16_t *v15; // x0
  __int64 v16; // x8
  int8x16_t *v17; // x23
  __int64 v18; // x12
  char *v19; // x9
  int8x16_t *v20; // x10
  __int64 v21; // x11
  unsigned int v22; // w19
  int8x16_t *v23; // x9
  int8x16_t *v24; // x10
  __int64 v25; // x12
  int8x16_t v26; // q0
  int8x16_t v27; // q1
  int8x8_t *v28; // x13
  int8x8_t *v29; // x14
  __int64 v30; // x11
  int8x8_t v31; // t1
  int v32; // w8
  char v33; // t1
  int v34; // w28
  char *v35; // x0
  char *v36; // x26
  char *v37; // x25
  char *v38; // x22
  int v40; // [xsp+Ch] [xbp-84h] BYREF
  __int128 v41; // [xsp+10h] [xbp-80h] BYREF
  _OWORD v42[3]; // [xsp+20h] [xbp-70h] BYREF
  _OWORD v43[2]; // [xsp+50h] [xbp-40h] BYREF
  __int64 v44; // [xsp+70h] [xbp-20h] BYREF
  _QWORD v45[3]; // [xsp+78h] [xbp-18h]

  v45[2] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v44 = 0;
  v45[0] = 0;
  *(_QWORD *)((char *)v45 + 5) = 0;
  memset(v42, 0, 35);
  v41 = 0u;
  v10 = DHstrlen(a3);
  v11 = (char *)DHmalloc(v10 + 1);
  if ( v11 )
  {
    v12 = v11;
    DHstrcpy_s(v11, v10 + 1, a3);
    DHstrlwr(v12);
    v13 = DHstrlen(a2);
    DHmemset(&v41, 0, 51);
    v40 = 51;
    ClientID = GetClientID(a1, (__int64)&v41, (unsigned int *)&v40);
    if ( ClientID < 0 )
    {
      v22 = ClientID;
      v17 = (int8x16_t *)v12;
    }
    else
    {
      DHstrlwr(&v41);
      v15 = (int8x16_t *)DHmalloc(v40);
      if ( v15 )
      {
        v16 = (unsigned int)v40;
        v17 = v15;
        if ( v40 < 1 )
        {
LABEL_25:
          v34 = v13 + v10 + 2 * v16;
          strcpy((char *)v43, "SSKEY-1 Key Generation");
          v35 = (char *)DHmalloc(v34 + 23);
          if ( v35 )
          {
            v36 = v35;
            DHmemset(v35, 0, v34 + 23);
            DHmemcpy(v36, v12, v10);
            v37 = &v36[v10];
            DHmemcpy(v37, a2, v13);
            v38 = &v37[v13];
            DHmemcpy(v38, &v41, v40);
            DHmemcpy(&v38[v40], v17, v40);
            DHmemcpy(&v38[2 * v40], v43, 22);
            DA_DRM_HASH_SHA1Digest((__int64)v36, (uint32x4_t *)&v44, v34 + 22);
            DHmemcpy(a4, &v44, a5);
            DHfree(v36);
            v22 = 0;
          }
          else
          {
            v22 = 65514;
          }
          DHfree(v12);
          goto LABEL_29;
        }
        LODWORD(v18) = 0;
        v19 = (char *)&v41;
        if ( (unsigned int)v40 < 8 )
        {
          v20 = v15;
        }
        else
        {
          v20 = v15;
          if ( (unsigned __int64)((char *)v15 - (char *)&v41) >= 0x20 )
          {
            if ( (unsigned int)v40 < 0x20 )
            {
              v21 = 0;
              goto LABEL_17;
            }
            v21 = v40 & 0x7FFFFFE0;
            v23 = v15 + 1;
            v24 = (int8x16_t *)v42;
            v25 = v21;
            do
            {
              v26 = v24[-1];
              v27 = *v24;
              v25 -= 32;
              v24 += 2;
              v23[-1] = vmvnq_s8(v26);
              *v23 = vmvnq_s8(v27);
              v23 += 2;
            }
            while ( v25 );
            if ( v21 == v16 )
              goto LABEL_24;
            if ( (v16 & 0x18) != 0 )
            {
LABEL_17:
              v18 = v16 & 0x7FFFFFF8;
              v28 = (int8x8_t *)((char *)v15 + v21);
              v19 = (char *)&v42[-1] + v18;
              v20 = (int8x16_t *)((char *)v15 + v18);
              v29 = (int8x8_t *)((char *)&v42[-1] + v21);
              v30 = v21 - v18;
              do
              {
                v31.n64_u64[0] = v29->n64_u64[0];
                ++v29;
                v30 += 8;
                v28->n64_u64[0] = vmvn_s8(v31).n64_u64[0];
                ++v28;
              }
              while ( v30 );
              if ( v18 == v16 )
                goto LABEL_24;
              goto LABEL_22;
            }
            v20 = (int8x16_t *)((char *)v15 + v21);
            LODWORD(v18) = v16 & 0x7FFFFFE0;
            v19 = (char *)&v42[-1] + v21;
          }
        }
LABEL_22:
        v32 = v16 - v18;
        do
        {
          v33 = *v19++;
          --v32;
          v20->n128_u8[0] = ~v33;
          v20 = (int8x16_t *)((char *)v20 + 1);
        }
        while ( v32 );
LABEL_24:
        LODWORD(v16) = v40;
        goto LABEL_25;
      }
      v22 = 65514;
      v17 = (int8x16_t *)v12;
    }
LABEL_29:
    DHfree(v17);
    return v22;
  }
  return 65514;
}

//----- (0000000000015BE0) ----------------------------------------------------
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  __int64 v6; // x0
  char *v7; // x23
  unsigned int v8; // w22
  char *v9; // x0
  char *v10; // x21
  char *v12; // x0

  v6 = DHstrstr();
  if ( v6 )
    v7 = (char *)(v6 + 1);
  else
    v7 = a3;
  if ( !(unsigned int)DHstrnicmp(a1, "ALL", 4) )
    return 1;
  if ( !(unsigned int)DHstrnicmp(a1, "LOCAL", 6) )
    return (unsigned int)DHstrnicmp(v7, "local", 5) != 0;
  if ( (unsigned int)DHstrnicmp(v7, "p-cluster", 9) )
  {
    v8 = DHstrlen(v7);
    v9 = (char *)DHmalloc(v8 + 1);
    if ( v9 )
    {
      v10 = v9;
      DHmemset(v9, 0, v8 + 1);
      DHstrcpy_s(v10, v8 + 1, v7);
      DHstrlwr(v10);
      goto LABEL_13;
    }
    return 65514;
  }
  v8 = DHstrlen("p-cluster");
  v12 = (char *)DHmalloc(v8 + 1);
  if ( !v12 )
    return 65514;
  v10 = v12;
  DHmemset(v12, 0, v8 + 1);
  DHstrncpy_s((__int64)v10, v8 + 1, (__int64)"p-cluster", v8);
LABEL_13:
  if ( (unsigned int)DHstrnicmp(a1, "domain", 7) )
  {
    DHfree(v10);
    return 0;
  }
  else
  {
    if ( a2 )
    {
      while ( (unsigned int)DHstrnicmp(v10, *(_BYTE **)a2, v8) )
      {
        a2 = *(_QWORD *)(a2 + 16);
        if ( !a2 )
          goto LABEL_21;
      }
      LODWORD(a2) = 1;
    }
LABEL_21:
    DHfree(v10);
    return (unsigned int)a2;
  }
}

//----- (0000000000015D88) ----------------------------------------------------
char *__fastcall sub_15D88(char *result, __int64 a2, int *a3, int *a4)
{
  int v4; // w8
  int v5; // w9
  int v6; // t1
  int v7; // w10
  int v8; // t1
  int v9; // w9
  int v10; // w11
  int v11; // w10
  int v12; // w10
  char v13; // w9
  __int64 v14; // x9
  char v15; // t1
  int v16; // w9
  int v17; // w9
  int v18; // w11
  int v19; // w12
  unsigned int v20; // w9
  char v21; // w10
  int v22; // w10
  char v23; // w9
  char v24; // w10
  __int64 v25; // x10
  int i; // w8

  *a4 = 0;
  *a3 = 0;
  v4 = (unsigned __int8)*result;
  if ( v4 == 32 )
  {
    v5 = *a4 + 1;
    do
    {
      *a4 = v5++;
      v6 = (unsigned __int8)*++result;
      v4 = v6;
    }
    while ( v6 == 32 );
  }
  if ( v4 == 34 )
  {
    ++*a4;
    v8 = (unsigned __int8)*++result;
    v7 = v8;
  }
  else
  {
    v7 = v4;
  }
  v9 = v4 != 34;
  v10 = v7 == 59 && v4 != 34;
  if ( !v7 )
    v10 = 1;
  if ( v7 != 34 )
    v9 = 1;
  if ( v9 != v10 )
  {
    while ( 1 )
    {
      if ( v7 != 92 )
        goto LABEL_24;
      v11 = (unsigned __int8)result[1];
      if ( v11 == 34 || v11 == 92 )
      {
        ++result;
        ++*a4;
LABEL_24:
        v14 = *a3;
        v15 = *result++;
        *a3 = v14 + 1;
        *(_BYTE *)(a2 + v14) = v15;
        v16 = *a4 + 1;
        goto LABEL_25;
      }
      if ( v11 != 48 || ((unsigned __int8)result[2] | 0x20) != 0x78 )
        goto LABEL_24;
      v12 = (unsigned __int8)result[3];
      v13 = v12 - 48;
      if ( (unsigned int)(v12 - 48) >= 0xA )
      {
        if ( (unsigned int)(v12 - 65) > 5 )
        {
          v20 = v12 - 97;
          v21 = v12 - 87;
          if ( v20 >= 6 )
            v13 = 0;
          else
            v13 = v21;
        }
        else
        {
          v13 = v12 - 55;
        }
      }
      v22 = (unsigned __int8)result[4];
      v23 = 16 * v13;
      if ( (unsigned int)(v22 - 48) > 9 )
      {
        if ( (unsigned int)(v22 - 65) <= 5 )
        {
          v24 = v22 - 55;
LABEL_44:
          v23 |= v24;
          goto LABEL_45;
        }
        if ( (unsigned int)(v22 - 97) <= 5 )
        {
          v24 = v22 - 87;
          goto LABEL_44;
        }
      }
      else
      {
        v23 |= v22 - 48;
      }
LABEL_45:
      v25 = *a3;
      result += 5;
      *a3 = v25 + 1;
      *(_BYTE *)(a2 + v25) = v23;
      v16 = *a4 + 5;
LABEL_25:
      *a4 = v16;
      v17 = *a3;
      if ( *a3 <= 254 )
      {
        v7 = (unsigned __int8)*result;
        v18 = v4 != 34;
        v19 = v7 == 59 && v4 != 34;
        if ( !*result )
          v19 = 1;
        if ( v7 != 34 )
          v18 = 1;
        if ( v18 != v19 )
          continue;
      }
      goto LABEL_47;
    }
  }
  v17 = *a3;
LABEL_47:
  *(_BYTE *)(a2 + v17) = 0;
  for ( i = (unsigned __int8)*result; *result; i = (unsigned __int8)*result )
  {
    if ( i == 59 )
      break;
    ++result;
    ++*a4;
  }
  return result;
}

//----- (0000000000015F70) ----------------------------------------------------
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x1
  FILE *v6; // x0
  FILE *v7; // x22

  ++qword_244A0;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( !strcmp(a1, "*") )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4C68;
      else
        v5 = off_1FA88[a2 - 1];
      v6 = fopen(a1, v5);
      if ( v6 )
      {
        v7 = v6;
        printLogD();
        v4[1] = v7;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        ++qword_244A8;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 1FA88: using guessed type char *off_1FA88[4];
// 244A0: using guessed type __int64 qword_244A0;
// 244A8: using guessed type __int64 qword_244A8;

//----- (0000000000016094) ----------------------------------------------------
void *__fastcall DHmalloc(int a1)
{
  void *v1; // x19

  if ( a1 )
  {
    ++qword_244A0;
    v1 = malloc(a1);
    printLogD();
  }
  else
  {
    printLogD();
    return 0;
  }
  return v1;
}
// 244A0: using guessed type __int64 qword_244A0;

//----- (0000000000016104) ----------------------------------------------------
void __fastcall DHfree(void *a1)
{
  printLogD();
  if ( a1 )
  {
    ++qword_244A8;
    free(a1);
  }
}
// 244A8: using guessed type __int64 qword_244A8;

//----- (000000000001615C) ----------------------------------------------------
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  FILE *v2; // x21

  if ( (unsigned int)(a2 - 1) > 3 )
    v2 = 0;
  else
    v2 = fopen(filename, off_1FA88[a2 - 1]);
  printLogD();
  return v2;
}
// 1FA88: using guessed type char *off_1FA88[4];

//----- (00000000000161D4) ----------------------------------------------------
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  _QWORD *v4; // x19
  const char *v5; // x22
  int v6; // w0
  FILE *v7; // x0
  FILE *v8; // x22

  printLogD();
  ++qword_244A0;
  v4 = malloc(0x28u);
  printLogD();
  if ( v4 )
  {
    if ( a1 < 1 )
    {
      *(_WORD *)v4 = 0;
      v4[2] = 0;
      v4[3] = 0;
      v4[1] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
    else
    {
      if ( (unsigned int)(a2 - 1) > 3 )
        v5 = (const char *)&unk_4C68;
      else
        v5 = off_1FA88[a2 - 1];
      printLogD();
      v6 = dup(a1);
      v7 = fdopen(v6, v5);
      if ( v7 )
      {
        v8 = v7;
        rewind(v7);
        printLogD();
        v4[1] = v8;
        *(_WORD *)v4 = 1;
      }
      else
      {
        printLogD();
        printLogD();
        ++qword_244A8;
        free(v4);
        return 0;
      }
    }
  }
  return v4;
}
// 1FA88: using guessed type char *off_1FA88[4];
// 244A0: using guessed type __int64 qword_244A0;
// 244A8: using guessed type __int64 qword_244A8;

//----- (0000000000016340) ----------------------------------------------------
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  __int64 v4; // x22
  int v5; // w0
  FILE *v6; // x0
  FILE *v7; // x21

  printLogD();
  if ( (unsigned int)(a2 - 1) <= 3
    && (v4 = *((int *)&unk_6DD0 + (unsigned int)(a2 - 1)),
        v5 = dup(a1),
        (v6 = fdopen(v5, (const char *)&unk_6DD0 + v4)) != 0) )
  {
    v7 = v6;
    rewind(v6);
    printLogD();
    return v7;
  }
  else
  {
    printLogD();
    return 0;
  }
}

//----- (00000000000163F8) ----------------------------------------------------
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  int v2; // w8
  FILE *v3; // x0
  FILE *v4; // x20

  if ( a1 )
  {
    v2 = *(unsigned __int16 *)a1;
    v3 = (FILE *)a1[1];
    if ( v2 )
    {
      fclose(v3);
    }
    else if ( v3 )
    {
      v4 = v3;
      printLogD();
      ++qword_244A8;
      free(v4);
    }
    printLogD();
    ++qword_244A8;
    free(a1);
  }
}
// 244A8: using guessed type __int64 qword_244A8;

//----- (00000000000164A0) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(result + 28) = a2;
      return 1;
    }
  }
  return result;
}

//----- (00000000000164C0) ----------------------------------------------------
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  _OWORD *v5; // x20
  _QWORD *v6; // x21
  __int64 v7; // x22
  __int64 v8; // x23
  int v9; // w24
  __int64 v10; // x24
  __int64 v11; // x22
  int v12; // w23
  __int64 v13; // x8
  __int128 *v14; // x10
  _OWORD *v15; // x11
  __int64 v16; // x12
  __int128 v17; // q0
  __int128 v18; // q1
  __int64 v19; // x12
  __int64 *v20; // x10
  _QWORD *v21; // x11
  __int64 v22; // x12
  __int64 v23; // t1
  __int64 v24; // x9
  _BYTE *v25; // x10
  char *v26; // x8
  char v27; // t1

  if ( result )
  {
    if ( *(_WORD *)result )
      return 0;
    v6 = (_QWORD *)(result + 8);
    v5 = *(_OWORD **)(result + 8);
    if ( *(_DWORD *)(result + 16) < a3 )
    {
      if ( v5 )
      {
        v7 = result;
        v8 = a2;
        v9 = a4;
        printLogD();
        ++qword_244A8;
        free(v5);
        a2 = v8;
        result = v7;
        a4 = v9;
        *v6 = 0;
        v6[1] = 0;
      }
      if ( !a3 )
      {
        printLogD();
        result = 0;
        *v6 = 0;
        return result;
      }
      v10 = result;
      v11 = a2;
      v12 = a4;
      ++qword_244A0;
      v5 = malloc(a3);
      printLogD();
      *v6 = v5;
      if ( !v5 )
        return 0;
      result = v10;
      a4 = v12;
      a2 = v11;
      *(_DWORD *)(v10 + 16) = a3;
    }
    if ( a3 < 1 || !a2 || !v5 )
      goto LABEL_27;
    v13 = 0;
    if ( (unsigned int)a3 >= 8 && (unsigned __int64)v5 - a2 >= 0x20 )
    {
      if ( (unsigned int)a3 < 0x20 )
      {
        v13 = 0;
        goto LABEL_22;
      }
      v13 = a3 & 0x7FFFFFE0;
      v14 = (__int128 *)(a2 + 16);
      v15 = v5 + 1;
      v16 = v13;
      do
      {
        v17 = *(v14 - 1);
        v18 = *v14;
        v16 -= 32;
        v14 += 2;
        *(v15 - 1) = v17;
        *v15 = v18;
        v15 += 2;
      }
      while ( v16 );
      if ( v13 == a3 )
        goto LABEL_27;
      if ( (a3 & 0x18) != 0 )
      {
LABEL_22:
        v19 = v13;
        v13 = a3 & 0x7FFFFFF8;
        v20 = (__int64 *)(a2 + v19);
        v21 = (_QWORD *)((char *)v5 + v19);
        v22 = v19 - v13;
        do
        {
          v23 = *v20++;
          v22 += 8;
          *v21++ = v23;
        }
        while ( v22 );
        if ( v13 == a3 )
          goto LABEL_27;
      }
    }
    v24 = (unsigned int)a3 - v13;
    v25 = (char *)v5 + v13;
    v26 = (char *)(a2 + v13);
    do
    {
      v27 = *v26++;
      --v24;
      *v25++ = v27;
    }
    while ( v24 );
LABEL_27:
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
    return 1;
  }
  return result;
}
// 20: using guessed type __int64;
// 244A0: using guessed type __int64 qword_244A0;
// 244A8: using guessed type __int64 qword_244A8;

//----- (00000000000166AC) ----------------------------------------------------
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v4; // x4
  __int64 v5; // x9
  __int64 v6; // x10
  _OWORD *v7; // x11
  _OWORD *v8; // x12
  __int128 v9; // q1
  __int64 v10; // x10

  v4 = 0;
  if ( a1 && a3 && a2 >= a4 )
  {
    if ( a4 < 1 )
      return a1;
    v5 = 0;
    if ( (unsigned int)a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( (unsigned int)a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_13;
      }
      v6 = 0;
      v5 = a4 & 0x7FFFFFE0;
      do
      {
        v7 = (_OWORD *)(a3 + v6);
        v8 = (_OWORD *)(a1 + v6);
        v6 += 32;
        v9 = v7[1];
        *v8 = *v7;
        v8[1] = v9;
      }
      while ( v5 != v6 );
      if ( v5 == a4 )
        return a1;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_13:
        v10 = v5;
        v5 = a4 & 0x7FFFFFF8;
        do
        {
          *(_QWORD *)(a1 + v10) = *(_QWORD *)(a3 + v10);
          v10 += 8;
        }
        while ( v5 != v10 );
        if ( v5 == a4 )
          return a1;
        goto LABEL_16;
      }
    }
    do
    {
LABEL_16:
      *(_BYTE *)(a1 + v5) = *(_BYTE *)(a3 + v5);
      ++v5;
    }
    while ( a4 != v5 );
    return a1;
  }
  return v4;
}

//----- (000000000001676C) ----------------------------------------------------
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  int v2; // w8
  int v3; // w9

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 28);
      v2 = *(_DWORD *)(result + 32);
      result = 1;
      if ( v2 == v3 )
        *a2 = 1;
    }
  }
  return result;
}

//----- (000000000001679C) ----------------------------------------------------
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  int v3; // w8
  int v4; // w9
  int v5; // w8

  *a2 = 0;
  if ( result )
  {
    if ( *(_WORD *)result )
    {
      return 0;
    }
    else
    {
      v3 = *(_DWORD *)(result + 32);
      v4 = *(_DWORD *)(result + 24);
      if ( v3 < v4 || *(_DWORD *)(result + 20) + v4 <= v3 )
      {
        *a2 = 1;
        v5 = *(_DWORD *)(result + 32);
        result = 1;
        *a3 = v5;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

//----- (00000000000167F4) ----------------------------------------------------
__int64 __fastcall DHfsMetaRead(__int64 a1, char *ptr, unsigned int a3)
{
  __int64 v3; // x8
  int v5; // w11
  int v6; // w8
  __int64 v7; // x9
  int v8; // w8
  __int64 v9; // x10
  __int64 v10; // x11
  __int64 v11; // x12
  __int64 v12; // x9
  char *v13; // x11
  char *v14; // x10
  char v15; // t1
  bool v16; // cf
  _OWORD *v17; // x13
  __int128 *v18; // x12
  __int64 v19; // x14
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x14
  __int64 v23; // x12
  char *v24; // x13
  __int64 v25; // x14
  __int64 *v26; // x12
  __int64 v27; // t1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !*(_WORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_DWORD *)(a1 + 24);
    v7 = (unsigned int)(v5 - v6);
    if ( v5 - v6 < 0 || (v8 = *(_DWORD *)(a1 + 20), v8 <= (int)v7) )
    {
      LODWORD(v3) = 0;
      return (unsigned int)v3;
    }
    if ( (int)(v7 + a3) <= v8 )
      v3 = a3;
    else
      v3 = (unsigned int)(v8 - v7);
    if ( !ptr )
      goto LABEL_20;
    v9 = *(_QWORD *)(a1 + 8);
    if ( !v9 || (int)v3 < 1 )
      goto LABEL_20;
    if ( (unsigned int)v3 < 8 || (unsigned __int64)&ptr[-v9 - v7] < 0x20 )
    {
      v10 = 0;
LABEL_16:
      v11 = v10 + v7;
      v12 = v10 - v3;
      v13 = &ptr[v10];
      v14 = (char *)(v9 + v11);
      do
      {
        v15 = *v14++;
        v16 = __CFADD__(v12++, 1);
        *v13++ = v15;
      }
      while ( !v16 );
LABEL_19:
      v5 = *(_DWORD *)(a1 + 32);
LABEL_20:
      *(_DWORD *)(a1 + 32) = v5 + v3;
      return (unsigned int)v3;
    }
    if ( (unsigned int)v3 >= 0x20 )
    {
      v10 = v3 & 0x7FFFFFE0;
      v17 = ptr + 16;
      v18 = (__int128 *)(v7 + v9 + 16);
      v19 = v10;
      do
      {
        v20 = *(v18 - 1);
        v21 = *v18;
        v19 -= 32;
        v18 += 2;
        *(v17 - 1) = v20;
        *v17 = v21;
        v17 += 2;
      }
      while ( v19 );
      if ( v10 == v3 )
        goto LABEL_19;
      if ( (v3 & 0x18) == 0 )
        goto LABEL_16;
    }
    else
    {
      v10 = 0;
    }
    v22 = v10;
    v10 = v3 & 0x7FFFFFF8;
    v23 = v22 + v7;
    v24 = &ptr[v22];
    v25 = v22 - v10;
    v26 = (__int64 *)(v9 + v23);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *(_QWORD *)v24 = v27;
      v24 += 8;
    }
    while ( v25 );
    if ( v10 == v3 )
      goto LABEL_19;
    goto LABEL_16;
  }
  LODWORD(v3) = fread(ptr, 1u, (int)a3, *(FILE **)(a1 + 8));
  return (unsigned int)v3;
}

//----- (0000000000016948) ----------------------------------------------------
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3)
{
  return fread(ptr, 1u, a3, stream);
}

//----- (000000000001696C) ----------------------------------------------------
size_t __fastcall DHfsMetaWrite(__int64 a1, void *ptr, int a3)
{
  if ( a1 && *(_WORD *)a1 )
    return fwrite(ptr, 1u, a3, *(FILE **)(a1 + 8));
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000169A4) ----------------------------------------------------
size_t __fastcall DHfsWrite(FILE *s, void *ptr, int a3)
{
  return fwrite(ptr, 1u, a3, s);
}

//----- (00000000000169C8) ----------------------------------------------------
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  __int64 v3; // x19
  FILE *v4; // x0
  int v5; // w2
  int v7; // w8

  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
  {
    v3 = a1;
    v4 = *(FILE **)(a1 + 8);
    if ( a3 == 1 )
      v5 = 1;
    else
      v5 = 2 * (a3 == 2);
    if ( (fseek(v4, a2, v5) & 0x80000000) == 0 )
    {
      a1 = v3;
      if ( *(_WORD *)v3 )
        return ftell(*(FILE **)(v3 + 8));
      return *(int *)(a1 + 32);
    }
    return -1;
  }
  switch ( a3 )
  {
    case 3:
      *(_DWORD *)(a1 + 32) = a2;
      return *(int *)(a1 + 32);
    case 2:
      v7 = *(_DWORD *)(a1 + 28);
      goto LABEL_15;
    case 1:
      v7 = *(_DWORD *)(a1 + 32);
LABEL_15:
      *(_DWORD *)(a1 + 32) = v7 + a2;
      break;
  }
  return *(int *)(a1 + 32);
}

//----- (0000000000016A70) ----------------------------------------------------
__int64 __fastcall DHfsMetaTell(__int64 a1)
{
  if ( !a1 )
    return -1;
  if ( *(_WORD *)a1 )
    return ftell(*(FILE **)(a1 + 8));
  return *(int *)(a1 + 32);
}

//----- (0000000000016A94) ----------------------------------------------------
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  if ( (unsigned int)(a3 - 1) > 2 || fseek(a1, a2, dword_6DE0[a3 - 1]) < 0 )
    return -1;
  else
    return ftell(a1);
}
// 6DE0: using guessed type _DWORD dword_6DE0[3];

//----- (0000000000016AEC) ----------------------------------------------------
__int64 __fastcall DHfsMetaSize(const char *a1)
{
  FILE *v2; // x0
  FILE *v3; // x20
  unsigned int v4; // w19

  if ( !strcmp(a1, "*") )
    return (unsigned int)-1;
  v2 = fopen(a1, "rb");
  if ( !v2 )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = v2;
    fseek(v2, 0, 2);
    v4 = ftell(v3);
    fclose(v3);
  }
  return v4;
}

//----- (0000000000016B5C) ----------------------------------------------------
__int64 __fastcall DHfsSize(const char *a1)
{
  FILE *v1; // x19
  unsigned int v2; // w20

  v1 = fopen(a1, "rb");
  fseek(v1, 0, 2);
  v2 = ftell(v1);
  fseek(v1, 0, 0);
  fclose(v1);
  return v2;
}

//----- (0000000000016BB8) ----------------------------------------------------
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return memset(a1, a2, a3);
}

//----- (0000000000016BC0) ----------------------------------------------------
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return memcpy(a1, a2, a3);
}

//----- (0000000000016BC8) ----------------------------------------------------
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3)
{
  return memcmp(a1, a2, a3);
}

//----- (0000000000016BD0) ----------------------------------------------------
void *__fastcall DHmemchr(const void *a1, int a2, int a3)
{
  return memchr(a1, a2, a3);
}

//----- (0000000000016BD8) ----------------------------------------------------
void DHmemcount()
{
  printLogD();
  printLogD();
}
// 244A0: using guessed type __int64 qword_244A0;
// 244A8: using guessed type __int64 qword_244A8;

//----- (0000000000016C24) ----------------------------------------------------
size_t __fastcall DHstrlen(const char *a1)
{
  return strlen(a1);
}

//----- (0000000000016C38) ----------------------------------------------------
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  if ( strlen(s) >= a2 )
    return 0xFFFFFFFFLL;
  strcpy(a1, s);
  return 0;
}

//----- (0000000000016C90) ----------------------------------------------------
char *__fastcall DHstrncpy(char *a1, const char *a2, int a3)
{
  return strncpy(a1, a2, a3);
}

//----- (0000000000016C98) ----------------------------------------------------
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w8
  __int64 v5; // x8
  __int64 v6; // x9
  __int128 *v8; // x10
  _OWORD *v9; // x11
  __int64 v10; // x12
  __int128 v11; // q0
  __int128 v12; // q1
  __int64 v13; // x12
  __int64 *v14; // x10
  _QWORD *v15; // x11
  __int64 v16; // x12
  __int64 v17; // t1
  _BYTE *v18; // x10
  char *v19; // x11
  __int64 v20; // x8
  char v21; // t1

  v4 = 22;
  if ( !a1 || !a3 )
    return v4;
  if ( a2 < 1 )
    return 34;
  if ( (int)a4 >= 1 )
  {
    v5 = 0;
    v6 = a4;
    if ( a4 >= 8 && (unsigned __int64)(a1 - a3) >= 0x20 )
    {
      if ( a4 < 0x20 )
      {
        v5 = 0;
        goto LABEL_15;
      }
      v5 = a4 & 0x7FFFFFE0;
      v8 = (__int128 *)(a3 + 16);
      v9 = (_OWORD *)(a1 + 16);
      v10 = v5;
      do
      {
        v11 = *(v8 - 1);
        v12 = *v8;
        v10 -= 32;
        v8 += 2;
        *(v9 - 1) = v11;
        *v9 = v12;
        v9 += 2;
      }
      while ( v10 );
      if ( v5 == a4 )
        goto LABEL_20;
      if ( (a4 & 0x18) != 0 )
      {
LABEL_15:
        v13 = v5;
        v5 = a4 & 0x7FFFFFF8;
        v14 = (__int64 *)(a3 + v13);
        v15 = (_QWORD *)(a1 + v13);
        v16 = v13 - v5;
        do
        {
          v17 = *v14++;
          v16 += 8;
          *v15++ = v17;
        }
        while ( v16 );
        if ( v5 == a4 )
          goto LABEL_20;
      }
    }
    v18 = (_BYTE *)(a1 + v5);
    v19 = (char *)(a3 + v5);
    v20 = a4 - v5;
    do
    {
      v21 = *v19++;
      --v20;
      *v18++ = v21;
    }
    while ( v20 );
    goto LABEL_20;
  }
  v6 = 0;
LABEL_20:
  v4 = 0;
  *(_BYTE *)(a1 + v6) = 0;
  return v4;
}

//----- (0000000000016D84) ----------------------------------------------------
__int64 __fastcall DHstrcmp_s(const char *a1, int a2, char *s2, int *a4)
{
  int v5; // w8
  __int64 result; // x0

  v5 = strcmp(a1, s2);
  result = 0;
  *a4 = v5;
  return result;
}

//----- (0000000000016DB4) ----------------------------------------------------
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return strncmp(a1, a2, a3);
}

//----- (0000000000016DBC) ----------------------------------------------------
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // w8
  int v4; // w10
  int v5; // w9

  if ( a3 < 1 )
    return 0;
  v3 = a3 + 1;
  while ( 1 )
  {
    v4 = (unsigned __int8)*a2;
    v5 = (unsigned __int8)*a1;
    if ( !*a2 || !*a1 )
      break;
    if ( (unsigned int)(v4 - 97) < 0x1A )
      LOBYTE(v4) = v4 - 32;
    if ( (unsigned int)(v5 - 97) < 0x1A )
      LOBYTE(v5) = v5 - 32;
    if ( (unsigned __int8)v5 != (unsigned __int8)v4 )
      break;
    --v3;
    ++a1;
    ++a2;
    if ( v3 <= 1 )
      return 0;
  }
  return (unsigned __int8)(v5 - v4);
}

//----- (0000000000016E30) ----------------------------------------------------
char *__fastcall DHstrncat(char *a1, const char *a2, int a3)
{
  return strncat(a1, a2, a3);
}

//----- (0000000000016E38) ----------------------------------------------------
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  __int64 result; // x0
  char *v7; // x20
  signed __int64 v9; // x0
  __int64 v10; // x8
  __int64 v11; // x9
  unsigned __int64 v12; // x12
  unsigned __int64 v13; // x11
  char *v14; // x9
  __int64 v15; // x10
  char *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x15
  __int128 v19; // q0
  __int128 v20; // q1
  char *v21; // x10
  char v22; // t1

  result = 22;
  if ( s && a3 )
  {
    if ( a2 < 1 )
      return 34;
    v7 = s;
    LODWORD(v9) = strlen(s);
    if ( a4 < 1 )
    {
      v14 = v7;
    }
    else
    {
      v9 = (int)v9;
      v10 = (int)v9 + a4;
      if ( (int)v9 + 1LL > v10 )
        v11 = (int)v9 + 1LL;
      else
        v11 = (int)v9 + a4;
      v12 = v11 - (int)v9;
      if ( v12 >= 0x20 )
      {
        v14 = v7;
        v15 = a3;
        if ( (unsigned __int64)&v7[(int)v9 - a3] >= 0x20 )
        {
          v13 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = &v7[(int)v9 + 16];
          v17 = (__int128 *)(a3 + 16);
          v9 = (int)v9 + (v12 & 0xFFFFFFFFFFFFFFE0LL);
          v18 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v18 -= 32LL;
            v17 += 2;
            *((_OWORD *)v16 - 1) = v19;
            *(_OWORD *)v16 = v20;
            v16 += 32;
          }
          while ( v18 );
          if ( v12 == v13 )
            goto LABEL_19;
        }
        else
        {
          v13 = 0;
        }
      }
      else
      {
        v13 = 0;
        v14 = v7;
        v15 = a3;
      }
      v21 = (char *)(v15 + v13);
      do
      {
        v22 = *v21++;
        v14[v9++] = v22;
      }
      while ( v9 < v10 );
    }
LABEL_19:
    v14[(int)v9] = 0;
    return 0;
  }
  return result;
}

//----- (0000000000016F50) ----------------------------------------------------
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  int8x16_t *v3; // x19
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x9
  unsigned __int8 v6; // w12
  bool v7; // cf
  int8x16_t *v8; // x22
  int8x16_t *v9; // x8
  __int64 v10; // x10
  int8x16_t *v11; // x13
  int8x16_t *v12; // x14
  int8x16_t v13; // q0
  int8x16_t v14; // q1
  __int8 v15; // t1
  int8x16_t v17; // [xsp+7h] [xbp-29h] BYREF
  __int64 v18; // [xsp+28h] [xbp-8h]

  v18 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a3 - 37 >= 0xFFFFFFDD )
  {
    v3 = a2;
    v4 = 0;
    v5 = a1;
    do
    {
      if ( v5 % a3 >= 0xA )
        v6 = v5 % a3 + 87;
      else
        v6 = (v5 % a3) | 0x30;
      v7 = v5 >= a3;
      v17.n128_u8[v4++] = v6;
      v5 /= a3;
    }
    while ( v7 );
    v8 = (int8x16_t *)((char *)&v17 + v4);
    if ( !a2 )
    {
      if ( (_DWORD)v4 == -1 )
      {
        printLogD();
        v3 = 0;
      }
      else
      {
        ++qword_244A0;
        v3 = (int8x16_t *)malloc((int)v4 + 1);
        printLogD();
      }
    }
    v9 = v3;
    if ( v8 <= &v17 )
      goto LABEL_21;
    if ( v4 >= 0x20 )
    {
      if ( v3 >= v8 || (v9 = v3, &v17 >= (int8x16_t *)((char *)v3 + v4)) )
      {
        v10 = 0;
        v9 = (int8x16_t *)((char *)v3 + (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v8 = (int8x16_t *)((char *)&v17 + v4 - (v4 & 0xFFFFFFFFFFFFFFE0LL));
        v11 = v3 + 1;
        do
        {
          v12 = (int8x16_t *)((char *)&v17 + v4 + v10);
          v10 -= 32;
          v13 = vrev64q_s8(v12[-1]);
          v14 = vrev64q_s8(v12[-2]);
          v11[-1] = vextq_s8(v13, v13, 8u);
          *v11 = vextq_s8(v14, v14, 8u);
          v11 += 2;
        }
        while ( -(__int64)(v4 & 0xFFFFFFFFFFFFFFE0LL) != v10 );
        if ( v4 == (v4 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_21;
      }
    }
    else
    {
      v9 = v3;
    }
    do
    {
      v15 = v8[-1].n128_i8[15];
      v8 = (int8x16_t *)((char *)v8 - 1);
      v9->n128_u8[0] = v15;
      v9 = (int8x16_t *)((char *)v9 + 1);
    }
    while ( v8 > &v17 );
LABEL_21:
    v9->n128_u8[0] = 0;
    return v3;
  }
  return 0;
}
// 244A0: using guessed type __int64 qword_244A0;

//----- (0000000000017108) ----------------------------------------------------
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return strchr(a1, a2);
}

//----- (0000000000017110) ----------------------------------------------------
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  int v4; // w0
  unsigned __int8 *v5; // x19
  int v6; // w0
  unsigned __int8 *v7; // x21
  int v8; // w23
  int v9; // w0
  int v10; // w24
  size_t v11; // x23
  size_t v12; // x23
  int v13; // w0
  int v15; // w8
  unsigned __int8 *v16; // x9
  int v17; // t1
  int v18; // w8
  unsigned __int8 *v19; // x9
  int v20; // t1
  char *v21; // x0
  const char *v22; // x23

  v4 = strlen(a1);
  if ( v4 == -1 )
  {
    printLogD();
    v5 = 0;
  }
  else
  {
    ++qword_244A0;
    v5 = (unsigned __int8 *)malloc(v4 + 1);
    printLogD();
  }
  v6 = strlen(a2);
  if ( v6 == -1 )
  {
    printLogD();
    if ( !v5 )
      return 0;
    goto LABEL_16;
  }
  ++qword_244A0;
  v7 = (unsigned __int8 *)malloc(v6 + 1);
  printLogD();
  if ( !v5 )
    return 0;
  if ( !v7 )
  {
LABEL_16:
    printLogD();
    ++qword_244A8;
    free(v5);
    return 0;
  }
  v8 = strlen(a1);
  v9 = strlen(a2);
  if ( !a1 )
  {
    v13 = 22;
LABEL_22:
    strerror(v13);
    printLogD();
    return 0;
  }
  v10 = v9;
  if ( (strlen(a1) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v8 >= 1 )
  {
    v11 = v8 & 0x7FFFFFFF;
    memcpy(v5, a1, v11);
    v5[v11] = 0;
    if ( a2 )
      goto LABEL_13;
    goto LABEL_20;
  }
  *v5 = 0;
  if ( !a2 )
  {
LABEL_20:
    v13 = 22;
    goto LABEL_22;
  }
LABEL_13:
  if ( (strlen(a2) & 0x80000000) != 0 )
  {
    v13 = 34;
    goto LABEL_22;
  }
  if ( v10 < 1 )
  {
    v12 = 0;
  }
  else
  {
    v12 = v10 & 0x7FFFFFFF;
    memcpy(v7, a2, v12);
  }
  v15 = *v5;
  v7[v12] = 0;
  if ( v15 )
  {
    v16 = v5 + 1;
    do
    {
      if ( (unsigned int)(v15 - 65) <= 0x19 )
        *(v16 - 1) = v15 | 0x20;
      v17 = *v16++;
      v15 = v17;
    }
    while ( v17 );
  }
  v18 = *v7;
  if ( *v7 )
  {
    v19 = v7 + 1;
    do
    {
      if ( (unsigned int)(v18 - 65) <= 0x19 )
        *(v19 - 1) = v18 | 0x20;
      v20 = *v19++;
      v18 = v20;
    }
    while ( v20 );
  }
  v21 = strstr((const char *)v5, (const char *)v7);
  if ( v21 )
    v22 = &a1[v21 - (char *)v5];
  else
    v22 = 0;
  printLogD();
  ++qword_244A8;
  free(v5);
  printLogD();
  ++qword_244A8;
  free(v7);
  return v22;
}
// 244A0: using guessed type __int64 qword_244A0;
// 244A8: using guessed type __int64 qword_244A8;

//----- (000000000001741C) ----------------------------------------------------
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  int v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = (unsigned __int8)*result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned int)(v1 - 65) <= 0x19 )
        *(v2 - 1) = v1 | 0x20;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (0000000000017450) ----------------------------------------------------
_BYTE *__fastcall DHstrupr(_BYTE *result)
{
  char v1; // w8
  unsigned __int8 *v2; // x9
  int v3; // t1

  v1 = *result;
  if ( *result )
  {
    v2 = result + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (0000000000017488) ----------------------------------------------------
__int64 DHvsnprintf(char *a1, int a2, char *s, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v9; // [xsp+F8h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( a1 && a2 >= 1 && s && (int)strlen(s) < a2 )
  {
    va_start(va, s);
    va_copy(arg, va);
    vsnprintf(a1, (unsigned int)a2, s, arg);
  }
  return 0;
}

//----- (0000000000017564) ----------------------------------------------------
__int64 DHsprintf(char *a1, const char *a2, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v5; // [xsp+F8h] [xbp-8h]

  va_start(va, a2);
  v5 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, a2, arg);
  return 0;
}

//----- (00000000000175F8) ----------------------------------------------------
__int64 DHsprintf_s(char *a1, __int64 a2, char *format, ...)
{
  gcc_va_list va; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-30h] BYREF
  __int64 v6; // [xsp+F8h] [xbp-8h]

  va_start(va, format);
  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(arg, va);
  vsprintf(a1, format, arg);
  return 0;
}

//----- (0000000000017690) ----------------------------------------------------
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  unsigned int v2; // w19
  unsigned int v3; // w8
  int v4; // w8
  int v5; // w9
  struct tm v7; // [xsp+0h] [xbp-40h] BYREF
  __int64 v8; // [xsp+38h] [xbp-8h]

  v2 = 0;
  v8 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (a1 & 0xFFFE) <= 0x7F5 )
    v3 = (unsigned __int16)a1;
  else
    v3 = 2037;
  v7.tm_isdst = 0;
  *(_QWORD *)&v7.tm_wday = 0;
  if ( v3 >= 0x7B2 )
  {
    v4 = v3 - 1900;
    v7.tm_hour = HIWORD(a1);
    v7.tm_mday = WORD2(a1);
    v5 = WORD1(a1) - 1;
    if ( (a1 & 0xFFFF0000) == 0 )
      v5 = 0;
    v7.tm_mon = v5;
    v7.tm_year = v4;
    v7.tm_sec = HIWORD(a2);
    v7.tm_min = (unsigned __int16)a2;
    v2 = mktime(&v7);
    printLogD();
  }
  return v2;
}

//----- (0000000000017750) ----------------------------------------------------
__int64 __fastcall DHGetStateInfo(void *a1)
{
  FILE *v2; // x0
  FILE *v3; // x21
  int v4; // w0
  unsigned int v6; // [xsp+4h] [xbp-D5Ch] BYREF
  int v7; // [xsp+8h] [xbp-D58h] BYREF
  _BYTE v8[244]; // [xsp+Ch] [xbp-D54h] BYREF
  __int128 v9; // [xsp+100h] [xbp-C60h] BYREF
  _BYTE v10[32]; // [xsp+110h] [xbp-C50h] BYREF
  int8x16_t src[2]; // [xsp+130h] [xbp-C30h] BYREF
  _QWORD v12[128]; // [xsp+158h] [xbp-C08h] BYREF
  char v13[1024]; // [xsp+558h] [xbp-808h] BYREF
  _BYTE s[1024]; // [xsp+958h] [xbp-408h] BYREF
  __int64 v15; // [xsp+D58h] [xbp-8h]

  v15 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(s, 0, sizeof(s));
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  v6 = 0;
  v7 = 0;
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  memset(src, 0, sizeof(src));
  v2 = fopen("/data/data/com.skt.skaf.Z000HDRMDS/files/stateInfo.dat", "r");
  if ( v2 )
  {
    v3 = v2;
    printLogD();
    LODWORD(v3) = fread(s, 1u, 0x400u, v3);
    printLogD();
    __memcpy_chk(v13, s, (int)v3, 1024);
    printLogD();
    base64_decode(v13, (__int64)v12, (unsigned int *)&v7);
    printLogD();
    base64_decode("uLZ7EW2RgRj3xG7upVkEUg==", (__int64)v10, &v6);
    printLogD();
    AES_set_decrypt_key();
    AES_cbc_encrypt(v12, src, v7, (__int64)v8, &v9, 0);
    __strlen_chk((const char *)src, 0x20u);
    printLogD();
    v4 = __strlen_chk((const char *)src, 0x20u);
    memcpy(a1, src, v4);
    printLogD();
    return 0;
  }
  else
  {
    printLogD();
    return 0xFFFFFFFFLL;
  }
}
// 1B9E0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001797C) ----------------------------------------------------
__int64 DHcurrentTime_ByLib()
{
  return 0;
}

//----- (0000000000017984) ----------------------------------------------------
__int64 DHcurrentTime()
{
  unsigned int v0; // w19
  time_t v2; // [xsp+0h] [xbp-10h] BYREF
  __int64 v3; // [xsp+8h] [xbp-8h]

  v3 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v2 = 0;
  v0 = time(&v2);
  printLogD();
  return v0;
}

//----- (00000000000179F4) ----------------------------------------------------
__int64 DHAuthTime_ByLib()
{
  return 0;
}

//----- (00000000000179FC) ----------------------------------------------------
__int64 DHAuthTime_ByFile()
{
  unsigned int v2; // w19
  __int64 v3; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v4; // [xsp+8h] [xbp-98h]
  char v5; // [xsp+Ah] [xbp-96h]
  __int128 v6; // [xsp+10h] [xbp-90h] BYREF
  __int128 v7; // [xsp+20h] [xbp-80h]
  __int128 v8; // [xsp+30h] [xbp-70h]
  __int128 v9; // [xsp+40h] [xbp-60h]
  __int128 v10; // [xsp+50h] [xbp-50h]
  __int128 v11; // [xsp+60h] [xbp-40h]
  __int128 v12; // [xsp+70h] [xbp-30h]
  __int128 v13; // [xsp+80h] [xbp-20h]
  __int64 v14; // [xsp+98h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v5 = 0;
  if ( (DHGetStateInfo(&v6) & 0x80000000) != 0 )
    return 0;
  if ( (unsigned __int16)v7 != 21582 || BYTE2(v7) != 58 )
  {
    fclose(0);
    return 0;
  }
  v3 = *(_QWORD *)((char *)&v7 + 3);
  v4 = *(_WORD *)((char *)&v7 + 11);
  __strlen_chk((const char *)&v3, 0xBu);
  v2 = atoi((const char *)&v3);
  printLogD();
  return v2;
}

//----- (0000000000017AD0) ----------------------------------------------------
__int64 DHAuthTime()
{
  time_t v1; // [xsp+0h] [xbp-10h] BYREF
  __int64 v2; // [xsp+8h] [xbp-8h]

  v2 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  return (unsigned int)time(&v1) - 1600;
}

//----- (0000000000017B1C) ----------------------------------------------------
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  int v5; // w21
  __int64 v6; // x8
  int v7; // w9
  __int64 v8; // x9
  __int64 v9; // x10
  char *v10; // x12
  __int64 v11; // x11
  char *v12; // x10
  _BYTE *v13; // x12
  char v14; // t1
  __int128 *v16; // x11
  _OWORD *v17; // x12
  __int64 v18; // x13
  __int128 v19; // q0
  __int128 v20; // q1
  __int64 v21; // x13
  char *v22; // x12
  __int64 *v23; // x11
  __int64 v24; // x13
  _QWORD *v25; // x12
  __int64 v26; // t1
  __int128 v27; // [xsp+8h] [xbp-18h]

  _ReadStatusReg(TPIDR_EL0);
  printLogD();
  if ( !a3 )
  {
    ++qword_244A0;
    a3 = (__int16 *)malloc(0xEu);
    printLogD();
    if ( !a3 )
      return 0xFFFFFFFFLL;
  }
  v5 = strlen((const char *)a1);
  printLogD();
  if ( v5 != 11 )
  {
    *a3 = v5;
    if ( !a1 )
      return StrErrorReturn(22);
    v8 = (unsigned int)(__int16)v5;
    if ( (int)v8 < 1 )
    {
      v8 = 0;
LABEL_18:
      *((_BYTE *)a3 + v8 + 2) = 0;
      goto LABEL_19;
    }
    if ( (unsigned int)v8 < 8 || (unsigned __int64)((char *)a3 - (char *)a1 + 2) < 0x20 )
    {
      v9 = 0;
LABEL_11:
      v10 = (char *)a3 + v9;
      v11 = v8 - v9;
      v12 = (char *)a1 + v9;
      v13 = v10 + 2;
      do
      {
        v14 = *v12++;
        --v11;
        *v13++ = v14;
      }
      while ( v11 );
      goto LABEL_18;
    }
    if ( (unsigned int)v8 >= 0x20 )
    {
      v9 = v8 & 0x7FFFFFE0;
      v16 = (__int128 *)(a1 + 2);
      v17 = a3 + 9;
      v18 = v9;
      do
      {
        v19 = *(v16 - 1);
        v20 = *v16;
        v18 -= 32;
        v16 += 2;
        *(v17 - 1) = v19;
        *v17 = v20;
        v17 += 2;
      }
      while ( v18 );
      if ( v9 == v8 )
        goto LABEL_18;
      if ( (v5 & 0x18) == 0 )
        goto LABEL_11;
    }
    else
    {
      v9 = 0;
    }
    v21 = v9;
    v9 = v8 & 0x7FFFFFF8;
    v22 = (char *)a3 + v21;
    v23 = (__int64 *)((char *)a1 + v21);
    v24 = v21 - v9;
    v25 = v22 + 2;
    do
    {
      v26 = *v23++;
      v24 += 8;
      *v25++ = v26;
    }
    while ( v24 );
    if ( v9 == v8 )
      goto LABEL_18;
    goto LABEL_11;
  }
  if ( !a1 )
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  v6 = *a1;
  v7 = *(_DWORD *)((char *)a1 + 7);
  *a3 = 10;
  *(_QWORD *)&v27 = v6;
  *(_WORD *)((char *)&v27 + 7) = v7;
  *((_BYTE *)a3 + 12) = 0;
  a3[5] = HIWORD(v7);
  *(_QWORD *)(a3 + 1) = *(_QWORD *)((char *)&v27 + 1);
LABEL_19:
  printLogD();
  return (unsigned int)*a3;
}
// 244A0: using guessed type __int64 qword_244A0;

//----- (0000000000017D98) ----------------------------------------------------
void __fastcall DHFreeClientID(void *a1)
{
  if ( a1 )
  {
    printLogD();
    printLogD();
    ++qword_244A8;
    free(a1);
  }
}
// 244A8: using guessed type __int64 qword_244A8;

//----- (0000000000017DFC) ----------------------------------------------------
__int64 DHGetClientID_ByLib()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000017E04) ----------------------------------------------------
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  __int16 *v8; // x24
  __int64 v9; // x22
  __int64 v11; // x8
  char *v12; // x10
  __int64 v13; // x9
  _BYTE *v14; // x8
  char *v15; // x10
  char v16; // t1
  __int128 *v17; // x9
  _OWORD *v18; // x10
  __int64 v19; // x11
  __int128 v20; // q0
  __int128 v21; // q1
  __int64 v22; // x11
  char *v23; // x9
  _QWORD *v24; // x10
  __int64 v25; // x11
  __int64 *v26; // x9
  __int64 v27; // t1

  printLogD();
  if ( !a4 || (v8 = *a4) == 0 || (v9 = (unsigned int)*v8, !*v8) )
  {
    *a2 = 0;
    return 0xFFFFFFFFLL;
  }
  if ( !strcmp(a1, "min") )
  {
    *a2 = v9;
    if ( !a3 )
    {
      strerror(22);
      printLogD();
      return StrErrorReturn(22);
    }
    if ( (int)v9 < 1 )
    {
      v9 = 0;
LABEL_17:
      *(_BYTE *)(a3 + v9) = 0;
      goto LABEL_18;
    }
    if ( (unsigned int)v9 < 8 || (unsigned __int64)(a3 - (_QWORD)v8 - 2) < 0x20 )
    {
      v11 = 0;
LABEL_12:
      v12 = (char *)v8 + v11;
      v13 = v9 - v11;
      v14 = (_BYTE *)(a3 + v11);
      v15 = v12 + 2;
      do
      {
        v16 = *v15++;
        --v13;
        *v14++ = v16;
      }
      while ( v13 );
      goto LABEL_17;
    }
    if ( (unsigned int)v9 >= 0x20 )
    {
      v11 = v9 & 0x7FE0;
      v17 = (__int128 *)(v8 + 9);
      v18 = (_OWORD *)(a3 + 16);
      v19 = v11;
      do
      {
        v20 = *(v17 - 1);
        v21 = *v17;
        v19 -= 32;
        v17 += 2;
        *(v18 - 1) = v20;
        *v18 = v21;
        v18 += 2;
      }
      while ( v19 );
      if ( v11 == v9 )
        goto LABEL_17;
      if ( (v9 & 0x18) == 0 )
        goto LABEL_12;
    }
    else
    {
      v11 = 0;
    }
    v22 = v11;
    v11 = v9 & 0x7FF8;
    v23 = (char *)v8 + v22;
    v24 = (_QWORD *)(a3 + v22);
    v25 = v22 - v11;
    v26 = (__int64 *)(v23 + 2);
    do
    {
      v27 = *v26++;
      v25 += 8;
      *v24++ = v27;
    }
    while ( v25 );
    if ( v11 == v9 )
      goto LABEL_17;
    goto LABEL_12;
  }
  *a2 = 0;
LABEL_18:
  printLogD();
  return *a2;
}

//----- (0000000000017FDC) ----------------------------------------------------
__int64 __fastcall DHGetClientID_ByFile(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned int v5; // w21
  __int64 v7; // [xsp+0h] [xbp-A0h] BYREF
  __int16 v8; // [xsp+8h] [xbp-98h]
  char v9; // [xsp+Ah] [xbp-96h]
  _OWORD v10[8]; // [xsp+10h] [xbp-90h] BYREF
  __int64 v11; // [xsp+98h] [xbp-8h]

  v11 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  if ( (DHGetStateInfo(v10) & 0x80000000) != 0 )
  {
    return 0;
  }
  else if ( *(_DWORD *)((char *)v10 + 1) == 978209101 )
  {
    v7 = *(_QWORD *)((char *)v10 + 5);
    v8 = *(_WORD *)((char *)v10 + 13);
    v5 = __strlen_chk((const char *)&v7, 0xBu);
    *a2 = v5;
    __strncpy_chk2(a3, &v7, (int)v5, -1, 11);
    printLogD();
  }
  else
  {
    printLogD();
    v5 = 0;
    *a2 = 0;
  }
  return v5;
}
// 1BA20: using guessed type __int64 __fastcall __strncpy_chk2(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000180F8) ----------------------------------------------------
__int64 __fastcall DHGetClientID(const char *a1, unsigned int *a2, char *a3)
{
  __int64 v7; // x8
  const char *v8; // x9
  char *v9; // x10
  __int64 v10; // x11
  char v11; // t1

  printLogD();
  if ( strcmp(a1, "min") )
  {
    *a2 = 0;
    return *a2;
  }
  v7 = *a2;
  if ( (int)v7 > 9 )
  {
    if ( a3 )
    {
      strcpy(a3, "1057402191");
      return *a2;
    }
  }
  else if ( a3 )
  {
    if ( (int)v7 < 1 )
    {
      *a3 = 0;
    }
    else
    {
      v8 = "1057402191";
      v9 = a3;
      v10 = *a2;
      do
      {
        v11 = *v8++;
        --v10;
        *v9++ = v11;
      }
      while ( v10 );
      a3[v7] = 0;
    }
    return *a2;
  }
  strerror(22);
  printLogD();
  return StrErrorReturn(22);
}

//----- (000000000001823C) ----------------------------------------------------
__int64 DHGetDeviceID_ByLib()
{
  return 4294967286LL;
}

//----- (0000000000018244) ----------------------------------------------------
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  __int64 result; // x0

  if ( a1 )
  {
    result = 0;
    strcpy(a1, "DIGICAPS1234567890");
  }
  else
  {
    strerror(22);
    printLogD();
    return StrErrorReturn(22);
  }
  return result;
}

//----- (00000000000182B4) ----------------------------------------------------
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  void *v6; // x21
  uint32x4_t v7; // q0
  const float *v8; // x8
  uint32x4_t v9; // q1
  const float *v10; // x8
  uint32x4_t v11; // q3
  const float *v12; // x8
  uint32x4_t v13; // q4
  unsigned int v14; // w9
  __int128 v15; // [xsp+0h] [xbp-70h] BYREF
  __int64 v16; // [xsp+10h] [xbp-60h] BYREF
  unsigned int v17; // [xsp+18h] [xbp-58h]
  int v18; // [xsp+1Ch] [xbp-54h] BYREF
  _DWORD v19[2]; // [xsp+60h] [xbp-10h] BYREF
  __int64 v20; // [xsp+68h] [xbp-8h]

  v20 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v6 = DHmalloc(a3 + 1);
  DHmemset(v6, 0, a3 + 1);
  DHmemcpy_s((__int64)v6, a3 + 1, a1, a3);
  v17 = 0;
  v15 = xmmword_6CE0;
  v16 = 3285377520LL;
  sub_184C4(&v15, a1, a3);
  v19[0] = bswap32(v17);
  v19[1] = bswap32(HIDWORD(v16));
  sub_184C4(&v15, (__int64)&unk_55D1, 1u);
  while ( (WORD2(v16) & 0x1F8) != 0x1C0 )
    sub_184C4(&v15, (__int64)&unk_6DEC, 1u);
  sub_184C4(&v15, (__int64)v19, 8u);
  v7 = vld1q_dup_f32((const float *)&v15);
  v8 = (const float *)&v15 + 1;
  v9 = vld1q_dup_f32(v8);
  v10 = (const float *)&v15 + 2;
  v11 = vld1q_dup_f32(v10);
  v12 = (const float *)((unsigned __int64)&v15 | 0xC);
  v13 = vld1q_dup_f32(v12);
  LODWORD(v12) = WORD1(v16);
  v7.n128_u64[0] = vmovn_s32(vshlq_u32(v7, (uint32x4_t)xmmword_6D50)).n64_u64[0];
  v14 = bswap32((unsigned __int16)v16) >> 16;
  a2[1].n128_u8[0] = BYTE3(v16);
  a2[1].n128_u8[1] = (unsigned __int8)v12;
  v7.n128_u64[0] = vuzp1_s8((int8x8_t)v7.n128_u64[0], (int8x8_t)v7.n128_u64[0]).n64_u64[0];
  a2[1].n128_u16[1] = v14;
  v7.n128_u32[1] = vuzp1_s8(vmovn_s32(vshlq_u32(v9, (uint32x4_t)xmmword_6D50)), (int8x8_t)v7.n128_u64[0]).n64_u32[0];
  v7.n128_u64[1] = __PAIR64__(
                     vuzp1_s8(vmovn_s32(vshlq_u32(v13, (uint32x4_t)xmmword_6D50)), (int8x8_t)v7.n128_u64[0]).n64_u32[0],
                     vuzp1_s8(vmovn_s32(vshlq_u32(v11, (uint32x4_t)xmmword_6D50)), (int8x8_t)v7.n128_u64[0]).n64_u32[0]);
  *a2 = v7;
  DHmemset(&v18, 0, 64);
  DHmemset(&v15, 0, 20);
  DHmemset((char *)&v16 + 4, 0, 8);
  DHmemset(v19, 0, 8);
  DHmemcpy_s(a1, a3 + 1, (__int64)v6, a3);
  DHfree(v6);
}
// 6CE0: using guessed type __int128 xmmword_6CE0;
// 6D50: using guessed type __int128 xmmword_6D50;

//----- (00000000000184C4) ----------------------------------------------------
__int64 __fastcall sub_184C4(_DWORD *a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // x8
  __int64 v7; // x24
  int v8; // w9
  unsigned int v9; // w22
  unsigned int v10; // w23
  __int64 v11; // x8

  v3 = (unsigned int)a1[5];
  v7 = (v3 >> 3) & 0x3F;
  v8 = a1[6] + __CFADD__((_DWORD)v3, 8 * a3) + (a3 >> 29);
  a1[5] = v3 + 8 * a3;
  a1[6] = v8;
  if ( (unsigned int)v7 + a3 < 0x40 )
  {
    v9 = 0;
    v11 = (v3 >> 3) & 0x3F;
  }
  else
  {
    v9 = 64 - v7;
    DHmemcpy_s((__int64)a1 + v7 + 28, 64, a2, 64 - v7);
    sub_185A0(a1, a1 + 7);
    v10 = v7 ^ 0x7F;
    if ( ((unsigned int)v7 ^ 0x7F) >= a3 )
    {
      v11 = 0;
    }
    else
    {
      do
      {
        sub_185A0(a1, (unsigned int *)(a2 + v10 - 63));
        v10 += 64;
      }
      while ( v10 < a3 );
      v11 = 0;
      v9 = v10 - 63;
    }
  }
  return DHmemcpy_s((__int64)a1 + v11 + 28, 64, a2 + v9, a3 - v9);
}

//----- (00000000000185A0) ----------------------------------------------------
int32x4_t __fastcall sub_185A0(_DWORD *a1, unsigned int *a2)
{
  int v2; // w9
  int v3; // w12
  int v4; // w14
  int v5; // w2
  unsigned __int64 v6; // t2
  int v7; // w16
  int v8; // w17
  int v9; // w9
  unsigned int v10; // w10
  unsigned int v11; // w11
  int v12; // w15
  int v13; // w17
  int v14; // w13
  int v15; // w12
  unsigned int v16; // w4
  int v17; // w2
  int v18; // w14
  unsigned int v19; // w15
  int v20; // w17
  int v21; // w9
  int v22; // w3
  int v23; // w16
  int v24; // w5
  int v25; // w6
  int v26; // w14
  int v27; // w11
  unsigned int v28; // w17
  int v29; // w12
  unsigned int v30; // w16
  int v31; // w13
  int v32; // w2
  int v33; // w5
  int v34; // w12
  int v35; // w15
  int v36; // w2
  unsigned int v37; // w20
  int v38; // w5
  int v39; // w21
  int v40; // w9
  unsigned int v41; // w13
  int v42; // w16
  unsigned int v43; // w19
  int v44; // w14
  int v45; // w2
  int v46; // w6
  unsigned int v47; // w12
  int v48; // w3
  int v49; // w6
  int v50; // w7
  int v51; // w14
  int v52; // w21
  int v53; // w5
  int v54; // w7
  int v55; // w3
  unsigned int v56; // w6
  int v57; // w21
  unsigned int v58; // w9
  int v59; // w22
  int v60; // w2
  int v61; // w23
  int v62; // w7
  int v63; // w22
  int v64; // w21
  unsigned int v65; // w5
  int v66; // w7
  int v67; // w23
  unsigned int v68; // w14
  int v69; // w22
  int v70; // w23
  int v71; // w26
  int v72; // w27
  int v73; // w24
  int v74; // w22
  unsigned int v75; // w3
  int v76; // w25
  int v77; // w7
  int v78; // w10
  int v79; // w2
  int v80; // w25
  int v81; // w24
  int v82; // w25
  unsigned int v83; // w7
  int v84; // w13
  int v85; // w21
  int v86; // w26
  int v87; // w23
  int v88; // w25
  int v89; // w2
  int v90; // w27
  int v91; // w23
  int v92; // w25
  int v93; // w21
  int v94; // w11
  int v95; // w25
  int v96; // w22
  int v97; // w11
  int v98; // w4
  int v99; // w22
  int v100; // w25
  int v101; // w23
  int v102; // w4
  int v103; // w24
  int v104; // w25
  int v105; // w4
  int v106; // w15
  int v107; // w24
  int v108; // w22
  int v109; // w25
  int v110; // w8
  int v111; // w15
  int v112; // w25
  int v113; // w8
  int v114; // w24
  int v115; // w26
  int v116; // w17
  int v117; // w16
  int v118; // w21
  int v119; // w25
  int v120; // w26
  int v121; // w23
  int v122; // w21
  int v123; // w20
  int v124; // w23
  int v125; // w16
  int v126; // w26
  int v127; // w12
  int v128; // w23
  int v129; // w22
  int v130; // w13
  int v131; // w26
  int v132; // w27
  int v133; // w23
  int v134; // w20
  int v135; // w19
  int v136; // w23
  int v137; // w24
  int v138; // w25
  int v139; // w13
  int v140; // w9
  int v141; // w23
  int v142; // w13
  int v143; // w19
  int v144; // w13
  int v145; // w16
  int v146; // w24
  int v147; // w6
  int v148; // w13
  int v149; // w16
  int v150; // w6
  int v151; // w23
  int v152; // w24
  int v153; // w26
  int v154; // w6
  int v155; // w24
  int v156; // w14
  int v157; // w6
  int v158; // w26
  int v159; // w16
  int v160; // w5
  int v161; // w16
  int v162; // w5
  int v163; // w24
  int v164; // w6
  int v165; // w19
  int v166; // w25
  int v167; // w23
  int v168; // w5
  int v169; // w24
  int v170; // w23
  int v171; // w26
  int v172; // w3
  int v173; // w19
  int v174; // w24
  int v175; // w3
  int v176; // w7
  int v177; // w19
  int v178; // w23
  int v179; // w24
  int v180; // w6
  int v181; // w19
  int v182; // w10
  int v183; // w24
  int v184; // w25
  int v185; // w27
  int v186; // w6
  int v187; // w7
  int v188; // w2
  int v189; // w6
  int v190; // w10
  int v191; // w6
  int v192; // w26
  int v193; // w24
  int v194; // w6
  int v195; // w11
  int v196; // w24
  int v197; // w26
  int v198; // w27
  int v199; // w4
  int v200; // w2
  int v201; // w23
  int v202; // w11
  int v203; // w24
  int v204; // w25
  int v205; // w24
  int v206; // w2
  int v207; // w15
  int v208; // w24
  int v209; // w23
  int v210; // w25
  int v211; // w10
  int v212; // w17
  int v213; // w24
  int v214; // w10
  int v215; // w25
  int v216; // w26
  int v217; // w15
  int v218; // w21
  int v219; // w15
  int v220; // w21
  int v221; // w25
  int v222; // w11
  int v223; // w24
  int v224; // w10
  int v225; // w25
  int v226; // w27
  int v227; // w22
  int v228; // w12
  int v229; // w21
  int v230; // w11
  int v231; // w20
  int v232; // w23
  int v233; // w25
  int v234; // w26
  int v235; // w27
  int v236; // w21
  int v237; // w23
  int v238; // w13
  int v239; // w24
  int v240; // w26
  int v241; // w22
  int v242; // w25
  int v243; // w23
  int v244; // w9
  int v245; // w23
  int v246; // w25
  int v247; // w26
  int v248; // w20
  int v249; // w24
  int v250; // w16
  int v251; // w24
  int v252; // w25
  int v253; // w26
  int v254; // w21
  int v255; // w23
  int v256; // w14
  int v257; // w23
  int v258; // w25
  int v259; // w26
  int v260; // w22
  int v261; // w24
  int v262; // w5
  int v263; // w24
  int v264; // w25
  int v265; // w26
  int v266; // w20
  int v267; // w23
  int v268; // w3
  int v269; // w23
  int v270; // w25
  int v271; // w26
  int v272; // w21
  int v273; // w24
  int v274; // w19
  int v275; // w24
  int v276; // w25
  int v277; // w26
  int v278; // w22
  int v279; // w23
  int v280; // w7
  int v281; // w23
  int v282; // w25
  int v283; // w26
  int v284; // w20
  int v285; // w24
  int v286; // w6
  int v287; // w24
  int v288; // w25
  int v289; // w26
  int v290; // w21
  int v291; // w23
  int v292; // w4
  int v293; // w23
  int v294; // w25
  int v295; // w26
  int v296; // w22
  int v297; // w24
  int v298; // w2
  int v299; // w24
  int v300; // w25
  int v301; // w26
  int v302; // w20
  int v303; // w23
  int v304; // w17
  int v305; // w23
  int v306; // w25
  int v307; // w26
  int v308; // w21
  int v309; // w24
  int v310; // w15
  int v311; // w25
  int v312; // w24
  int v313; // w26
  int v314; // w23
  int v315; // w10
  int v316; // w22
  int v317; // w23
  int v318; // w20
  int v319; // w25
  int v320; // w26
  int v321; // w20
  int v322; // w11
  int v323; // w22
  int v324; // w25
  int v325; // w26
  int v326; // w21
  int v327; // w11
  int v328; // w12
  int v329; // w21
  int v330; // w26
  int v331; // w24
  int v332; // w25
  int v333; // w26
  int v334; // w28
  int v335; // w27
  int v336; // w21
  int v337; // w12
  int v338; // w25
  int v339; // w26
  int v340; // w13
  int v341; // w9
  int v342; // w26
  int v343; // w16
  int v344; // w23
  int v345; // w25
  int v346; // w22
  int v347; // w16
  int v348; // w22
  int v349; // w25
  int v350; // w9
  int v351; // w24
  int v352; // w14
  int v353; // w9
  int v354; // w26
  int v355; // w9
  int v356; // w24
  int v357; // w12
  int v358; // w5
  int v359; // w22
  int v360; // w23
  int v361; // w24
  int v362; // w9
  int v363; // w3
  int v364; // w9
  int v365; // w19
  int v366; // w23
  int v367; // w22
  unsigned int v368; // w5
  int v369; // w22
  int v370; // w3
  int v371; // w26
  int v372; // w25
  int v373; // w7
  int v374; // w19
  int v375; // w26
  int v376; // w25
  unsigned int v377; // w3
  unsigned int v378; // w6
  int v379; // w24
  int v380; // w22
  int v381; // w23
  int v382; // w19
  int v383; // w25
  unsigned int v384; // w4
  int v385; // w22
  unsigned int v386; // w2
  int v387; // w24
  int v388; // w23
  int v389; // w7
  unsigned int v390; // w17
  int v391; // w22
  int v392; // w26
  unsigned int v393; // w15
  int v394; // w24
  int v395; // w23
  int v396; // w19
  unsigned int v397; // w10
  int v398; // w22
  int v399; // w25
  int v400; // w23
  int v401; // w24
  unsigned int v402; // w7
  int v403; // w23
  int v404; // w24
  int v405; // w20
  unsigned int v406; // w11
  int v407; // w22
  int v408; // w26
  int v409; // w24
  unsigned int v410; // w19
  int v411; // w21
  int v412; // w23
  int v413; // w24
  int v414; // w22
  unsigned int v415; // w13
  int v416; // w23
  int v417; // w25
  unsigned int v418; // w16
  int v419; // w24
  int v420; // w20
  int v421; // w26
  int v422; // w21
  int v423; // w14
  int v424; // w12
  int v425; // w21
  unsigned int v426; // w20
  int v427; // w5
  unsigned int v428; // w24
  int v429; // w23
  unsigned int v430; // w12
  unsigned int v431; // w11
  int v432; // w4
  int v433; // w22
  unsigned __int32 v434; // w2
  int32x4_t v435; // q0
  unsigned int v436; // w9
  int32x4_t v437; // q1
  int32x4_t result; // q0

  v2 = a1[1];
  v4 = a1[2];
  v3 = a1[3];
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v5 = v6 >> 27;
  v7 = v3 & ~v2;
  v8 = v4 & v2;
  HIDWORD(v6) = v2;
  LODWORD(v6) = v2;
  v9 = v6 >> 2;
  v10 = bswap32(*a2);
  v11 = bswap32(a2[1]);
  v12 = v5 + a1[4] + v10 + (v8 | v7) + 1518500249;
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v13 = v6 >> 27;
  HIDWORD(v6) = *a1;
  LODWORD(v6) = *a1;
  v14 = v6 >> 2;
  v15 = v3 + v11 + (v9 & *a1 | v4 & ~*a1) + 1518500249 + v13;
  v16 = bswap32(a2[2]);
  HIDWORD(v6) = v12;
  LODWORD(v6) = v12;
  v17 = v6 >> 2;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v18 = v4 + v16 + (v14 & v12 | v9 & ~v12) + 1518500249 + (v6 >> 27);
  v19 = bswap32(a2[3]);
  v20 = v9 + v19;
  HIDWORD(v6) = v15;
  LODWORD(v6) = v15;
  v21 = v6 >> 2;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v22 = v6 >> 27;
  v23 = v20 + (v17 & v15 | v14 & ~v15);
  v24 = v17 & ~v18;
  v25 = v21 & v18;
  HIDWORD(v6) = v18;
  LODWORD(v6) = v18;
  v26 = v6 >> 2;
  v27 = v19 ^ v11;
  v28 = bswap32(a2[4]);
  v29 = v23 + 1518500249 + v22;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v30 = bswap32(a2[5]);
  v31 = v14 + v28 + (v25 | v24) + 1518500249 + (v6 >> 27);
  v32 = v17 + v30 + (v26 & v29 | v21 & ~v29);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v33 = v6 >> 27;
  HIDWORD(v6) = v29;
  LODWORD(v6) = v29;
  v34 = v6 >> 2;
  v35 = v30 ^ v19;
  v36 = v32 + 1518500249 + v33;
  v37 = bswap32(a2[6]);
  HIDWORD(v6) = v31;
  LODWORD(v6) = v31;
  v38 = v6 >> 2;
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v39 = v21 + v37 + (v34 & v31 | v26 & ~v31) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v36;
  LODWORD(v6) = v36;
  v40 = v6 >> 2;
  v41 = bswap32(a2[7]);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v42 = v41 ^ v30;
  v43 = bswap32(a2[8]);
  v44 = v26 + v41 + (v38 & v36 | v34 & ~v36) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v39;
  LODWORD(v6) = v39;
  v45 = v6 >> 2;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v46 = v34 + v43 + (v40 & v39 | v38 & ~v39) + 1518500249;
  v47 = bswap32(a2[9]);
  v48 = v46 + (v6 >> 27);
  v49 = v45 & v44 | v40 & ~v44;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v50 = v6 >> 27;
  HIDWORD(v6) = v44;
  LODWORD(v6) = v44;
  v51 = v6 >> 2;
  v52 = v51 & v48;
  v53 = v38 + v47 + v49 + 1518500249 + v50;
  v54 = v45 & ~v48;
  HIDWORD(v6) = v48;
  LODWORD(v6) = v48;
  v55 = v6 >> 2;
  v56 = bswap32(a2[10]);
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v57 = v56 + v40 + (v52 | v54) + 1518500249 + (v6 >> 27);
  v58 = bswap32(a2[11]);
  v59 = v58 + v45;
  HIDWORD(v6) = v53;
  LODWORD(v6) = v53;
  v60 = v6 >> 2;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v61 = v6 >> 27;
  v62 = v59 + (v55 & v53 | v51 & ~v53);
  v63 = v60 & v57 | v55 & ~v57;
  HIDWORD(v6) = v57;
  LODWORD(v6) = v57;
  v64 = v6 >> 2;
  v65 = bswap32(a2[12]);
  v66 = v62 + 1518500249 + v61;
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v67 = v65 + v51 + v63 + 1518500249;
  v68 = bswap32(a2[13]);
  v69 = v67 + (v6 >> 27);
  HIDWORD(v6) = v66;
  LODWORD(v6) = v66;
  v70 = v6 >> 2;
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v71 = v64 & ~v69;
  v72 = v70 & v69;
  v73 = v68 + v55 + (v64 & v66 | v60 & ~v66) + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v69;
  LODWORD(v6) = v69;
  v74 = v6 >> 2;
  v75 = bswap32(a2[14]);
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v76 = v6 >> 27;
  v77 = v70 & ~v73;
  HIDWORD(v6) = v16 ^ v10 ^ v43 ^ v68;
  LODWORD(v6) = HIDWORD(v6);
  v78 = v6 >> 31;
  v79 = v75 + v60 + (v72 | v71) + 1518500249 + v76;
  v80 = v74 & v73;
  HIDWORD(v6) = v73;
  LODWORD(v6) = v73;
  v81 = v6 >> 2;
  v82 = v80 | v77;
  v83 = bswap32(a2[15]);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v84 = v47 ^ v41 ^ v83;
  v85 = v83 + v64 + v82 + 1518500249 + (v6 >> 27);
  HIDWORD(v6) = v79;
  LODWORD(v6) = v79;
  v86 = v6 >> 2;
  v87 = v78 + v70 + (v81 & v79 | v74 & ~v79);
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v88 = v6 >> 27;
  HIDWORD(v6) = v27 ^ v47 ^ v75;
  LODWORD(v6) = HIDWORD(v6);
  v89 = v6 >> 31;
  v90 = v86 & v85;
  v91 = v87 + 1518500249 + v88;
  v92 = v81 & ~v85;
  HIDWORD(v6) = v85;
  LODWORD(v6) = v85;
  v93 = v6 >> 2;
  v94 = v90 | v92;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v95 = v6 >> 27;
  v96 = v89 + v74 + v94 + 1518500249;
  HIDWORD(v6) = v28 ^ v16 ^ v56 ^ v83;
  LODWORD(v6) = HIDWORD(v6);
  v97 = v6 >> 31;
  v98 = v86 & ~v91;
  v99 = v96 + v95;
  v100 = v93 & v91;
  HIDWORD(v6) = v91;
  LODWORD(v6) = v91;
  v101 = v6 >> 2;
  v102 = v97 + v81 + (v100 | v98);
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v103 = v6 >> 27;
  v104 = v102 + 1518500249;
  HIDWORD(v6) = v35 ^ v58 ^ v78;
  LODWORD(v6) = HIDWORD(v6);
  v105 = v6 >> 31;
  v106 = v101 & v99 | v93 & ~v99;
  v107 = v104 + v103;
  HIDWORD(v6) = v99;
  LODWORD(v6) = v99;
  v108 = v6 >> 2;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v109 = v6 >> 27;
  v110 = v105 + v86 + v106 + 1518500249;
  HIDWORD(v6) = v37 ^ v28 ^ v65 ^ v89;
  LODWORD(v6) = HIDWORD(v6);
  v111 = v6 >> 31;
  v112 = v110 + v109;
  v113 = v108 ^ v101 ^ v107;
  HIDWORD(v6) = v107;
  LODWORD(v6) = v107;
  v114 = v6 >> 2;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v115 = v6 >> 27;
  HIDWORD(v6) = v42 ^ v68 ^ v97;
  LODWORD(v6) = HIDWORD(v6);
  v116 = v6 >> 31;
  v117 = v111 + v93 + v113 + 1859775393 + v115;
  v118 = v114 ^ v108 ^ v112;
  HIDWORD(v6) = v112;
  LODWORD(v6) = v112;
  v119 = v6 >> 2;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v120 = v6 >> 27;
  v121 = v116 + v101 + v118 + 1859775393;
  HIDWORD(v6) = v43 ^ v37 ^ v75 ^ v105;
  LODWORD(v6) = HIDWORD(v6);
  v122 = v6 >> 31;
  v123 = v121 + v120;
  v124 = v119 ^ v114 ^ v117;
  HIDWORD(v6) = v117;
  LODWORD(v6) = v117;
  v125 = v6 >> 2;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v126 = v6 >> 27;
  HIDWORD(v6) = v58 ^ v47 ^ v89 ^ v122;
  LODWORD(v6) = HIDWORD(v6);
  v127 = v6 >> 31;
  v128 = v122 + v108 + v124 + 1859775393;
  HIDWORD(v6) = v84 ^ v111;
  LODWORD(v6) = v84 ^ v111;
  v129 = v6 >> 31;
  v130 = v128 + v126;
  HIDWORD(v6) = v123;
  LODWORD(v6) = v123;
  v131 = v6 >> 2;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v132 = v6 >> 27;
  v133 = v129 + v114 + (v125 ^ v119 ^ v123) + 1859775393;
  HIDWORD(v6) = v56 ^ v43 ^ v78 ^ v116;
  LODWORD(v6) = HIDWORD(v6);
  v134 = v6 >> 31;
  v135 = v133 + v132;
  v136 = v131 ^ v125 ^ v130;
  v137 = v134 + v119;
  HIDWORD(v6) = v130;
  LODWORD(v6) = v130;
  v138 = v6 >> 2;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v139 = v6 >> 27;
  HIDWORD(v6) = v68 ^ v58 ^ v105 ^ v134;
  LODWORD(v6) = HIDWORD(v6);
  v140 = v6 >> 31;
  v141 = v137 + v136 + 1859775393 + v139;
  v142 = v138 ^ v131 ^ v135;
  HIDWORD(v6) = v135;
  LODWORD(v6) = v135;
  v143 = v6 >> 2;
  v144 = v127 + v125 + v142;
  v145 = v65 ^ v56 ^ v97 ^ v129;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v146 = v6 >> 27;
  v147 = v144 + 1859775393;
  HIDWORD(v6) = v145;
  LODWORD(v6) = v145;
  v148 = v6 >> 31;
  v149 = v147 + v146;
  v150 = v143 ^ v138 ^ v141;
  HIDWORD(v6) = v141;
  LODWORD(v6) = v141;
  v151 = v6 >> 2;
  v152 = v148 + v131;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v153 = v6 >> 27;
  v154 = v152 + v150;
  v155 = v151 ^ v143 ^ v149;
  HIDWORD(v6) = v83 ^ v68 ^ v116 ^ v148;
  LODWORD(v6) = HIDWORD(v6);
  v156 = v6 >> 31;
  v157 = v154 + 1859775393 + v153;
  HIDWORD(v6) = v149;
  LODWORD(v6) = v149;
  v158 = v6 >> 2;
  v159 = v75 ^ v65 ^ v111;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v160 = v6 >> 27;
  HIDWORD(v6) = v159 ^ v127;
  LODWORD(v6) = v159 ^ v127;
  v161 = v6 >> 31;
  v162 = v140 + v138 + v155 + 1859775393 + v160;
  v163 = v158 ^ v151 ^ v157;
  HIDWORD(v6) = v157;
  LODWORD(v6) = v157;
  v164 = v6 >> 2;
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v165 = v161 + v143 + v163 + 1859775393 + (v6 >> 27);
  HIDWORD(v6) = v162;
  LODWORD(v6) = v162;
  v166 = v6 >> 2;
  v167 = v156 + v151 + (v164 ^ v158 ^ v162) + 1859775393;
  HIDWORD(v6) = v78 ^ v75 ^ v122 ^ v140;
  LODWORD(v6) = HIDWORD(v6);
  v168 = v6 >> 31;
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v169 = v168 + v158;
  v170 = v167 + (v6 >> 27);
  HIDWORD(v6) = v165;
  LODWORD(v6) = v165;
  v171 = v6 >> 2;
  v172 = v169 + (v166 ^ v164 ^ v165);
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v173 = v6 >> 27;
  v174 = v172 + 1859775393;
  HIDWORD(v6) = v89 ^ v83 ^ v129 ^ v161;
  LODWORD(v6) = HIDWORD(v6);
  v175 = v6 >> 31;
  v176 = v174 + v173;
  v177 = v171 ^ v166 ^ v170;
  HIDWORD(v6) = v170;
  LODWORD(v6) = v170;
  v178 = v6 >> 2;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v179 = v6 >> 27;
  v180 = v175 + v164 + v177;
  HIDWORD(v6) = v97 ^ v78 ^ v134 ^ v156;
  LODWORD(v6) = HIDWORD(v6);
  v181 = v6 >> 31;
  v182 = v180 + 1859775393 + v179;
  v183 = v181 + v166;
  HIDWORD(v6) = v176;
  LODWORD(v6) = v176;
  v184 = v6 >> 2;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v185 = v6 >> 27;
  v186 = v183 + (v178 ^ v171 ^ v176);
  HIDWORD(v6) = v105 ^ v89 ^ v127 ^ v168;
  LODWORD(v6) = HIDWORD(v6);
  v187 = v6 >> 31;
  v188 = v186 + 1859775393 + v185;
  v189 = v184 ^ v178 ^ v182;
  HIDWORD(v6) = v182;
  LODWORD(v6) = v182;
  v190 = v6 >> 2;
  v191 = v187 + v171 + v189;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v192 = v6 >> 27;
  v193 = v191 + 1859775393;
  HIDWORD(v6) = v111 ^ v97 ^ v148 ^ v175;
  LODWORD(v6) = HIDWORD(v6);
  v194 = v6 >> 31;
  v195 = v193 + v192;
  v196 = v190 ^ v184 ^ v188;
  HIDWORD(v6) = v188;
  LODWORD(v6) = v188;
  v197 = v6 >> 2;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v198 = v6 >> 27;
  HIDWORD(v6) = v116 ^ v105 ^ v140 ^ v181;
  LODWORD(v6) = HIDWORD(v6);
  v199 = v6 >> 31;
  v200 = v197 ^ v190 ^ v195;
  v201 = v194 + v178 + v196 + 1859775393 + v198;
  HIDWORD(v6) = v195;
  LODWORD(v6) = v195;
  v202 = v6 >> 2;
  v203 = v199 + v184;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v204 = v6 >> 27;
  v205 = v203 + v200 + 1859775393;
  HIDWORD(v6) = v122 ^ v111 ^ v161 ^ v187;
  LODWORD(v6) = HIDWORD(v6);
  v206 = v6 >> 31;
  v207 = v205 + v204;
  v208 = v202 ^ v197 ^ v201;
  HIDWORD(v6) = v201;
  LODWORD(v6) = v201;
  v209 = v6 >> 2;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v210 = v6 >> 27;
  v211 = v206 + v190 + v208;
  HIDWORD(v6) = v129 ^ v116 ^ v156 ^ v194;
  LODWORD(v6) = HIDWORD(v6);
  v212 = v6 >> 31;
  v213 = v209 ^ v202 ^ v207;
  v214 = v211 + 1859775393 + v210;
  v215 = v212 + v197;
  HIDWORD(v6) = v207;
  LODWORD(v6) = v207;
  v216 = v6 >> 2;
  v217 = v134 ^ v122 ^ v168;
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v218 = v6 >> 27;
  HIDWORD(v6) = v217 ^ v199;
  LODWORD(v6) = v217 ^ v199;
  v219 = v6 >> 31;
  v220 = v215 + v213 + 1859775393 + v218;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v221 = v6 >> 27;
  v222 = v219 + v202 + (v216 ^ v209 ^ v214);
  HIDWORD(v6) = v214;
  LODWORD(v6) = v214;
  v223 = v6 >> 2;
  HIDWORD(v6) = v127 ^ v129 ^ v175 ^ v206;
  LODWORD(v6) = HIDWORD(v6);
  v224 = v6 >> 31;
  v225 = v222 + 1859775393 + v221;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v226 = v6 >> 27;
  HIDWORD(v6) = v220;
  LODWORD(v6) = v220;
  v227 = v6 >> 2;
  HIDWORD(v6) = v140 ^ v127 ^ v187 ^ v219;
  LODWORD(v6) = HIDWORD(v6);
  v228 = v6 >> 31;
  v229 = v224 + v209 + (v223 ^ v216 ^ v220) + 1859775393 + v226;
  HIDWORD(v6) = v148 ^ v134 ^ v181 ^ v212;
  LODWORD(v6) = HIDWORD(v6);
  v230 = v6 >> 31;
  HIDWORD(v6) = v225;
  LODWORD(v6) = v225;
  v231 = v6 >> 2;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v232 = v6 >> 27;
  v233 = v230 + v216 + ((v225 | v227) & v223 | v225 & v227);
  v234 = (v229 | v231) & v227;
  v235 = v229 & v231;
  HIDWORD(v6) = v229;
  LODWORD(v6) = v229;
  v236 = v6 >> 2;
  v237 = v233 - 1894007588 + v232;
  HIDWORD(v6) = v161 ^ v148 ^ v194 ^ v224;
  LODWORD(v6) = HIDWORD(v6);
  v238 = v6 >> 31;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v239 = v228 + v223 + (v234 | v235) - 1894007588 + (v6 >> 27);
  v240 = v238 + v227;
  HIDWORD(v6) = v237;
  LODWORD(v6) = v237;
  v241 = v6 >> 2;
  v242 = (v237 | v236) & v231 | v237 & v236;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v243 = v6 >> 27;
  HIDWORD(v6) = v156 ^ v140 ^ v199 ^ v230;
  LODWORD(v6) = HIDWORD(v6);
  v244 = v6 >> 31;
  v245 = v240 + v242 - 1894007588 + v243;
  v246 = (v239 | v241) & v236 | v239 & v241;
  v247 = v244 + v231;
  HIDWORD(v6) = v239;
  LODWORD(v6) = v239;
  v248 = v6 >> 2;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v249 = v6 >> 27;
  HIDWORD(v6) = v168 ^ v161 ^ v206 ^ v228;
  LODWORD(v6) = HIDWORD(v6);
  v250 = v6 >> 31;
  v251 = v247 + v246 - 1894007588 + v249;
  v252 = (v245 | v248) & v241 | v245 & v248;
  v253 = v250 + v236;
  HIDWORD(v6) = v245;
  LODWORD(v6) = v245;
  v254 = v6 >> 2;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v255 = v6 >> 27;
  HIDWORD(v6) = v175 ^ v156 ^ v212 ^ v238;
  LODWORD(v6) = HIDWORD(v6);
  v256 = v6 >> 31;
  v257 = v253 + v252 - 1894007588 + v255;
  v258 = (v251 | v254) & v248 | v251 & v254;
  v259 = v256 + v241;
  HIDWORD(v6) = v251;
  LODWORD(v6) = v251;
  v260 = v6 >> 2;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v261 = v6 >> 27;
  HIDWORD(v6) = v181 ^ v168 ^ v219 ^ v244;
  LODWORD(v6) = HIDWORD(v6);
  v262 = v6 >> 31;
  v263 = v259 + v258 - 1894007588 + v261;
  v264 = (v257 | v260) & v254 | v257 & v260;
  v265 = v262 + v248;
  HIDWORD(v6) = v257;
  LODWORD(v6) = v257;
  v266 = v6 >> 2;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v267 = v6 >> 27;
  HIDWORD(v6) = v187 ^ v175 ^ v224 ^ v250;
  LODWORD(v6) = HIDWORD(v6);
  v268 = v6 >> 31;
  v269 = v265 + v264 - 1894007588 + v267;
  v270 = (v263 | v266) & v260 | v263 & v266;
  v271 = v268 + v254;
  HIDWORD(v6) = v263;
  LODWORD(v6) = v263;
  v272 = v6 >> 2;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v273 = v6 >> 27;
  HIDWORD(v6) = v194 ^ v181 ^ v230 ^ v256;
  LODWORD(v6) = HIDWORD(v6);
  v274 = v6 >> 31;
  v275 = v271 + v270 - 1894007588 + v273;
  v276 = (v269 | v272) & v266 | v269 & v272;
  v277 = v274 + v260;
  HIDWORD(v6) = v269;
  LODWORD(v6) = v269;
  v278 = v6 >> 2;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v279 = v6 >> 27;
  HIDWORD(v6) = v199 ^ v187 ^ v228 ^ v262;
  LODWORD(v6) = HIDWORD(v6);
  v280 = v6 >> 31;
  v281 = v277 + v276 - 1894007588 + v279;
  v282 = (v275 | v278) & v272 | v275 & v278;
  v283 = v280 + v266;
  HIDWORD(v6) = v275;
  LODWORD(v6) = v275;
  v284 = v6 >> 2;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v285 = v6 >> 27;
  HIDWORD(v6) = v206 ^ v194 ^ v238 ^ v268;
  LODWORD(v6) = HIDWORD(v6);
  v286 = v6 >> 31;
  v287 = v283 + v282 - 1894007588 + v285;
  v288 = (v281 | v284) & v278 | v281 & v284;
  v289 = v286 + v272;
  HIDWORD(v6) = v281;
  LODWORD(v6) = v281;
  v290 = v6 >> 2;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v291 = v6 >> 27;
  HIDWORD(v6) = v212 ^ v199 ^ v244 ^ v274;
  LODWORD(v6) = HIDWORD(v6);
  v292 = v6 >> 31;
  v293 = v289 + v288 - 1894007588 + v291;
  v294 = (v287 | v290) & v284 | v287 & v290;
  v295 = v292 + v278;
  HIDWORD(v6) = v287;
  LODWORD(v6) = v287;
  v296 = v6 >> 2;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v297 = v6 >> 27;
  HIDWORD(v6) = v219 ^ v206 ^ v250 ^ v280;
  LODWORD(v6) = HIDWORD(v6);
  v298 = v6 >> 31;
  v299 = v295 + v294 - 1894007588 + v297;
  v300 = (v293 | v296) & v290 | v293 & v296;
  v301 = v298 + v284;
  HIDWORD(v6) = v293;
  LODWORD(v6) = v293;
  v302 = v6 >> 2;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v303 = v6 >> 27;
  HIDWORD(v6) = v224 ^ v212 ^ v256 ^ v286;
  LODWORD(v6) = HIDWORD(v6);
  v304 = v6 >> 31;
  v305 = v301 + v300 - 1894007588 + v303;
  v306 = (v299 | v302) & v296 | v299 & v302;
  v307 = v304 + v290;
  HIDWORD(v6) = v299;
  LODWORD(v6) = v299;
  v308 = v6 >> 2;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v309 = v6 >> 27;
  HIDWORD(v6) = v230 ^ v219 ^ v262 ^ v292;
  LODWORD(v6) = HIDWORD(v6);
  v310 = v6 >> 31;
  v311 = v307 + v306 - 1894007588 + v309;
  HIDWORD(v6) = v305;
  LODWORD(v6) = v305;
  v312 = v6 >> 2;
  v313 = (v305 | v308) & v302 | v305 & v308;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v314 = v6 >> 27;
  HIDWORD(v6) = v228 ^ v224 ^ v268 ^ v298;
  LODWORD(v6) = HIDWORD(v6);
  v315 = v6 >> 31;
  v316 = v310 + v296 + v313 - 1894007588 + v314;
  HIDWORD(v6) = v311;
  LODWORD(v6) = v311;
  v317 = v6 >> 2;
  v318 = v315 + v302 + ((v311 | v312) & v308 | v311 & v312);
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v319 = v6 >> 27;
  v320 = v318 - 1894007588;
  HIDWORD(v6) = v238 ^ v230 ^ v274 ^ v304;
  LODWORD(v6) = HIDWORD(v6);
  v321 = v6 >> 31;
  v322 = (v316 | v317) & v312 | v316 & v317;
  HIDWORD(v6) = v316;
  LODWORD(v6) = v316;
  v323 = v6 >> 2;
  v324 = v320 + v319;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v325 = v6 >> 27;
  v326 = v321 + v308 + v322 - 1894007588;
  HIDWORD(v6) = v244 ^ v228 ^ v280 ^ v310;
  LODWORD(v6) = HIDWORD(v6);
  v327 = v6 >> 31;
  v328 = v326 + v325;
  v329 = (v324 | v323) & v317 | v324 & v323;
  v330 = v327 + v312;
  HIDWORD(v6) = v324;
  LODWORD(v6) = v324;
  v331 = v6 >> 2;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v332 = v6 >> 27;
  v333 = v330 + v329 - 1894007588;
  v334 = v328 & v331;
  v335 = (v328 | v331) & v323;
  HIDWORD(v6) = v250 ^ v238 ^ v286 ^ v315;
  LODWORD(v6) = HIDWORD(v6);
  v336 = v6 >> 31;
  HIDWORD(v6) = v328;
  LODWORD(v6) = v328;
  v337 = v6 >> 2;
  v338 = v333 + v332;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v339 = v6 >> 27;
  HIDWORD(v6) = v256 ^ v244 ^ v292 ^ v321;
  LODWORD(v6) = HIDWORD(v6);
  v340 = v6 >> 31;
  v341 = v262 ^ v250 ^ v298;
  v342 = v336 + v317 + (v335 | v334) - 1894007588 + v339;
  v343 = (v338 | v337) & v331 | v338 & v337;
  HIDWORD(v6) = v338;
  LODWORD(v6) = v338;
  v344 = v6 >> 2;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v345 = v6 >> 27;
  v346 = v340 + v323 + v343;
  HIDWORD(v6) = v341 ^ v327;
  LODWORD(v6) = v341 ^ v327;
  v347 = v6 >> 31;
  v348 = v346 - 1894007588 + v345;
  HIDWORD(v6) = v342;
  LODWORD(v6) = v342;
  v349 = v6 >> 2;
  v350 = v347 + v331;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v351 = v6 >> 27;
  HIDWORD(v6) = v268 ^ v256 ^ v304 ^ v336;
  LODWORD(v6) = HIDWORD(v6);
  v352 = v6 >> 31;
  v353 = v350 + (v344 ^ v337 ^ v342) - 899497514;
  HIDWORD(v6) = v348;
  LODWORD(v6) = v348;
  v354 = v6 >> 2;
  v355 = v353 + v351;
  v356 = v352 + v337;
  HIDWORD(v6) = v274 ^ v262 ^ v310 ^ v340;
  LODWORD(v6) = HIDWORD(v6);
  v357 = v6 >> 31;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v358 = v356 + (v349 ^ v344 ^ v348) - 899497514 + (v6 >> 27);
  v359 = v357 + v344 + (v354 ^ v349 ^ v355);
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v360 = v6 >> 27;
  HIDWORD(v6) = v355;
  LODWORD(v6) = v355;
  v361 = v6 >> 2;
  v362 = v280 ^ v268 ^ v315 ^ v347;
  v363 = v286 ^ v274;
  HIDWORD(v6) = v362;
  LODWORD(v6) = v362;
  v364 = v6 >> 31;
  v365 = v359 - 899497514 + v360;
  HIDWORD(v6) = v358;
  LODWORD(v6) = v358;
  v366 = v6 >> 2;
  v367 = v361 ^ v354 ^ v358;
  HIDWORD(v6) = v363 ^ v321 ^ v352;
  LODWORD(v6) = HIDWORD(v6);
  v368 = v6 >> 31;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v369 = v364 + v349 + v367 - 899497514 + (v6 >> 27);
  v370 = v368 + v354 + (v366 ^ v361 ^ v365);
  v371 = v292 ^ v280 ^ v327;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v372 = v6 >> 27;
  HIDWORD(v6) = v365;
  LODWORD(v6) = v365;
  v373 = v6 >> 2;
  v374 = v371 ^ v357;
  HIDWORD(v6) = v369;
  LODWORD(v6) = v369;
  v375 = v6 >> 2;
  v376 = v370 - 899497514 + v372;
  HIDWORD(v6) = v374;
  LODWORD(v6) = v374;
  v377 = v6 >> 31;
  HIDWORD(v6) = v298 ^ v286 ^ v336 ^ v364;
  LODWORD(v6) = HIDWORD(v6);
  v378 = v6 >> 31;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v379 = v377 + v361 + (v373 ^ v366 ^ v369) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v380 = v6 >> 27;
  v381 = v378 + v366 + (v375 ^ v373 ^ v376) - 899497514;
  HIDWORD(v6) = v376;
  LODWORD(v6) = v376;
  v382 = v6 >> 2;
  HIDWORD(v6) = v379;
  LODWORD(v6) = v379;
  v383 = v6 >> 2;
  HIDWORD(v6) = v304 ^ v292 ^ v340 ^ v368;
  LODWORD(v6) = HIDWORD(v6);
  v384 = v6 >> 31;
  v385 = v381 + v380;
  HIDWORD(v6) = v310 ^ v298 ^ v347 ^ v377;
  LODWORD(v6) = HIDWORD(v6);
  v386 = v6 >> 31;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v387 = v384 + v373 + (v382 ^ v375 ^ v379) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v388 = v6 >> 27;
  HIDWORD(v6) = v385;
  LODWORD(v6) = v385;
  v389 = v6 >> 2;
  HIDWORD(v6) = v315 ^ v304 ^ v352 ^ v378;
  LODWORD(v6) = HIDWORD(v6);
  v390 = v6 >> 31;
  v391 = v386 + v375 + (v383 ^ v382 ^ v385) - 899497514 + v388;
  HIDWORD(v6) = v387;
  LODWORD(v6) = v387;
  v392 = v6 >> 2;
  HIDWORD(v6) = v321 ^ v310 ^ v357 ^ v384;
  LODWORD(v6) = HIDWORD(v6);
  v393 = v6 >> 31;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v394 = v390 + v382 + (v389 ^ v383 ^ v387) - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v395 = v6 >> 27;
  HIDWORD(v6) = v391;
  LODWORD(v6) = v391;
  v396 = v6 >> 2;
  HIDWORD(v6) = v327 ^ v315 ^ v364 ^ v386;
  LODWORD(v6) = HIDWORD(v6);
  v397 = v6 >> 31;
  v398 = v393 + v383 + (v392 ^ v389 ^ v391) - 899497514 + v395;
  HIDWORD(v6) = v394;
  LODWORD(v6) = v394;
  v399 = v6 >> 2;
  v400 = v396 ^ v392 ^ v394;
  v401 = v397 + v389;
  HIDWORD(v6) = v336 ^ v321 ^ v368 ^ v390;
  LODWORD(v6) = HIDWORD(v6);
  v402 = v6 >> 31;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v403 = v401 + v400 - 899497514 + (v6 >> 27);
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v404 = v6 >> 27;
  HIDWORD(v6) = v398;
  LODWORD(v6) = v398;
  v405 = v6 >> 2;
  HIDWORD(v6) = v340 ^ v327 ^ v377 ^ v393;
  LODWORD(v6) = HIDWORD(v6);
  v406 = v6 >> 31;
  v407 = v402 + v392 + (v399 ^ v396 ^ v398) - 899497514 + v404;
  HIDWORD(v6) = v403;
  LODWORD(v6) = v403;
  v408 = v6 >> 2;
  v409 = v406 + v396;
  HIDWORD(v6) = v347 ^ v336 ^ v378 ^ v397;
  LODWORD(v6) = HIDWORD(v6);
  v410 = v6 >> 31;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v411 = v409 + (v405 ^ v399 ^ v403) - 899497514 + (v6 >> 27);
  v412 = v410 + v399 + (v408 ^ v405 ^ v407);
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v413 = v6 >> 27;
  HIDWORD(v6) = v407;
  LODWORD(v6) = v407;
  v414 = v6 >> 2;
  HIDWORD(v6) = v352 ^ v340 ^ v384 ^ v402;
  LODWORD(v6) = HIDWORD(v6);
  v415 = v6 >> 31;
  v416 = v412 - 899497514 + v413;
  HIDWORD(v6) = v411;
  LODWORD(v6) = v411;
  v417 = v6 >> 2;
  HIDWORD(v6) = v357 ^ v347 ^ v386 ^ v406;
  LODWORD(v6) = HIDWORD(v6);
  v418 = v6 >> 31;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v419 = v415 + v405 + (v414 ^ v408 ^ v411) - 899497514 + (v6 >> 27);
  v420 = v418 + v408 + (v417 ^ v414 ^ v416);
  v421 = v364 ^ v352;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v422 = v6 >> 27;
  HIDWORD(v6) = v416;
  LODWORD(v6) = v416;
  v423 = v6 >> 2;
  v424 = v368 ^ v357 ^ v393;
  *a2 = v368;
  a2[1] = v377;
  v425 = v420 - 899497514 + v422;
  HIDWORD(v6) = v421 ^ v390 ^ v410;
  LODWORD(v6) = HIDWORD(v6);
  v426 = v6 >> 31;
  v427 = v423 ^ v417 ^ v419;
  HIDWORD(v6) = v419;
  LODWORD(v6) = v419;
  v428 = v6 >> 2;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v429 = v6 >> 27;
  a2[2] = v378;
  a2[3] = v384;
  HIDWORD(v6) = v424 ^ v415;
  LODWORD(v6) = v424 ^ v415;
  v430 = v6 >> 31;
  a2[4] = v386;
  a2[5] = v390;
  a2[8] = v402;
  a2[9] = v406;
  HIDWORD(v6) = v425;
  LODWORD(v6) = v425;
  v431 = v6 >> 2;
  v432 = v426 + v414 + v427 - 899497514 + v429;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v433 = v6 >> 27;
  HIDWORD(v6) = v432;
  LODWORD(v6) = v432;
  v434 = v6 >> 2;
  a2[6] = v393;
  a2[7] = v397;
  a2[10] = v410;
  a2[11] = v415;
  v435.n128_u32[0] = v430 + v417 + (v428 ^ v423 ^ v425) - 899497514 + v433;
  HIDWORD(v6) = v377 ^ v364 ^ v397 ^ v418;
  LODWORD(v6) = HIDWORD(v6);
  v436 = v6 >> 31;
  a2[12] = v418;
  a2[13] = v426;
  a2[14] = v430;
  a2[15] = v436;
  v435.n128_u32[1] = v434;
  v437 = *(int32x4_t *)(a1 + 1);
  v435.n128_u64[1] = __PAIR64__(v428, v431);
  HIDWORD(v6) = v435.n128_u32[0];
  LODWORD(v6) = v435.n128_u32[0];
  *a1 = *a1 + v436 + v423 + (v431 ^ v428 ^ v432) - 899497514 + (v6 >> 27);
  result = vaddq_s32(v435, v437);
  *(int32x4_t *)(a1 + 1) = result;
  return result;
}

//----- (0000000000019590) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (00000000000196B0) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFileOpen(const char *a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      goto LABEL_8;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsMetaSeek((__int64)v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
LABEL_8:
  printLogD();
  return 0;
}

//----- (00000000000197D0) ----------------------------------------------------
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w19
  FILE *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 && (DHfsSeek(v8, 0, 3) & 0x8000000000000000LL) == 0 )
  {
    printLogD();
    return v7;
  }
  return 0;
}

//----- (00000000000198B0) ----------------------------------------------------
__int64 __fastcall DA_DRA_MetaFilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x24
  unsigned int v7; // w19
  _QWORD *v8; // x0

  printLogD();
  v6 = 2;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 51 )
    {
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 1;
  printLogD();
  printLogD();
  v8 = DHfsPfdMetaOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    printLogD();
    if ( (DHfsMetaSeek(*(_QWORD *)(a3 + 8 * v6), 0, 3) & 0x8000000000000000LL) == 0 )
    {
      printLogD();
      return v7;
    }
  }
  return 0;
}

//----- (00000000000199C4) ----------------------------------------------------
void __fastcall DA_DRA_MetaFileClose(int a1, __int64 a2)
{
  __int64 v2; // x19

  v2 = a2 + 8LL * a1;
  DHfsMetaClose(*(_QWORD **)(v2 + 8));
  *(_QWORD *)(v2 + 8) = -1;
}

//----- (00000000000199F0) ----------------------------------------------------
__int64 __fastcall DA_DRA_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  result = DHfsClose();
  *(_QWORD *)(v2 + 8) = -1;
  return result;
}

//----- (0000000000019A1C) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (0000000000019B4C) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FilePfdOpen(int a1, int a2, __int64 a3)
{
  __int64 v6; // x23
  unsigned int v7; // w20
  FILE *v8; // x0

  printLogD();
  v6 = 7;
  while ( *(_QWORD *)(a3 + 8 * v6) != -1 )
  {
    if ( ++v6 == 56 )
    {
      printLogD();
      printLogD();
      return 0;
    }
  }
  v7 = v6 - 6;
  printLogD();
  v8 = DHfsPfdOpen(a1, a2);
  *(_QWORD *)(a3 + 8 * v6) = v8;
  if ( v8 )
  {
    if ( DHfsSeek(v8, 0, 3) < 0 )
    {
      DHfsClose();
      *(_QWORD *)(a3 + 8 * v6) = -1;
      return (unsigned int)-15;
    }
    else
    {
      printLogD();
    }
  }
  else
  {
    printLogD();
    return 0;
  }
  return v7;
}

//----- (0000000000019C7C) ----------------------------------------------------
__int64 __fastcall DA_DRA_Multi_FileClose(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 result; // x0

  v2 = a2 + 8LL * a1;
  DHfsClose();
  result = 0;
  *(_QWORD *)(v2 + 48) = -1;
  return result;
}

//----- (0000000000019CAC) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetFileSize(int a1, int a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_SetFileSize(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (0000000000019CCC) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_SetBuffer(int a1, __int64 a2, int a3, int a4, __int64 a5)
{
  return (unsigned int)(__int16)DHfs_VF_SetBuffer(*(_QWORD *)(a5 + 8LL * a1 + 8), a2, a3, a4);
}

//----- (0000000000019CEC) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_IsReachedToEndOfFile(int a1, _WORD *a2, __int64 a3)
{
  return (unsigned int)(__int16)DHfs_VF_IsReachedToEndOfFile(*(_QWORD *)(a3 + 8LL * a1 + 8), a2);
}

//----- (0000000000019D0C) ----------------------------------------------------
__int64 __fastcall DA_DRA_VF_ShouldUpdateBuffer(int a1, _WORD *a2, _DWORD *a3, __int64 a4)
{
  return (unsigned int)(__int16)DHfs_VF_ShouldUpdateBuffer(*(_QWORD *)(a4 + 8LL * a1 + 8), a2, a3);
}

//----- (0000000000019D30) ----------------------------------------------------
__int64 __fastcall StrErrorReturn(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -37;
  else
    v1 = -23;
  if ( a1 == 22 )
    return 4294967260LL;
  else
    return v1;
}

//----- (0000000000019D50) ----------------------------------------------------
__int64 __fastcall StrErrorReturn_uch(int a1)
{
  unsigned int v1; // w8

  if ( a1 == 34 )
    v1 = -28;
  else
    v1 = -1;
  if ( a1 == 22 )
    return 4294967269LL;
  else
    return v1;
}

//----- (0000000000019D6C) ----------------------------------------------------
unsigned __int8 *__fastcall base64_encode(unsigned __int8 *result, __int64 a2, int a3, _DWORD *a4)
{
  int v4; // w10
  char v5; // w14
  unsigned __int64 v6; // x15
  bool v7; // vf
  char v8; // w12
  _BYTE *v9; // x16
  unsigned int v10; // w11
  unsigned __int64 v11; // x12
  int v12; // w14
  char v13; // w13

  if ( a3 >= 1 )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( (unsigned int)a3 >= 3 )
        v10 = 3;
      else
        v10 = a3;
      v11 = *result << 16;
      if ( a3 == 1 || (v11 = (unsigned int)v11 | (result[1] << 8), a3 == 2) )
      {
        v12 = 0;
        if ( a3 == 1 )
        {
          v13 = 61;
LABEL_14:
          v5 = 61;
          goto LABEL_4;
        }
      }
      else
      {
        v12 = 1;
        v11 = (unsigned int)v11 | result[2];
      }
      v13 = aAbcdefghijklmn[((unsigned __int64)(unsigned int)v11 >> 6) & 0x3F];
      if ( !v12 )
        goto LABEL_14;
      v5 = aAbcdefghijklmn[v11 & 0x3F];
LABEL_4:
      v6 = (unsigned int)v11;
      result += v10;
      v7 = __OFSUB__(a3, v10);
      a3 -= v10;
      v8 = aAbcdefghijklmn[(v11 >> 12) & 0x3F];
      v9 = (_BYTE *)(a2 + v4);
      v4 += 4;
      LOBYTE(v6) = aAbcdefghijklmn[v6 >> 18];
      v9[2] = v13;
      v9[1] = v8;
      *v9 = v6;
      v9[3] = v5;
      if ( (a3 < 0) ^ v7 | (a3 == 0) )
      {
        *a4 = v4;
        return result;
      }
    }
  }
  *a4 = 0;
  return result;
}
// 19E08: conditional instruction was optimized away because w14.4==0
// 19E20: conditional instruction was optimized away because w2.4 is in (==0|>=3u)

//----- (0000000000019E50) ----------------------------------------------------
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  int v2; // w9
  int v3; // w8
  int v4; // w10
  int v5; // w9
  int v6; // w11
  int v7; // w10
  int v8; // w12
  int v9; // w11
  __int64 result; // x0
  int v11; // w9
  unsigned int v12; // w13
  unsigned int v13; // w8
  __int16 v14; // w10

  v2 = *a1;
  v3 = v2 - 65;
  if ( (unsigned int)(v2 - 65) > 0x19 )
  {
    if ( (unsigned int)(v2 - 97) > 0x19 )
    {
      if ( (unsigned int)(v2 - 48) > 9 )
      {
        switch ( v2 )
        {
          case '+':
            v3 = 62;
            break;
          case '=':
            v3 = -1;
            break;
          case '/':
            v3 = 63;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v3 = v2 + 4;
      }
    }
    else
    {
      v3 = v2 - 71;
    }
  }
  v4 = a1[1];
  v5 = v4 - 65;
  if ( (unsigned int)(v4 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v4 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v4 - 48) >= 0xA )
      {
        switch ( v4 )
        {
          case '+':
            v5 = 62;
            break;
          case '/':
            v5 = 63;
            break;
          case '=':
            v5 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v5 = v4 + 4;
      }
    }
    else
    {
      v5 = v4 - 71;
    }
  }
  v6 = a1[2];
  v7 = v6 - 65;
  if ( (unsigned int)(v6 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v6 - 97) >= 0x1A )
    {
      if ( (unsigned int)(v6 - 48) >= 0xA )
      {
        switch ( v6 )
        {
          case '+':
            v7 = 62;
            break;
          case '/':
            v7 = 63;
            break;
          case '=':
            v7 = -1;
            break;
          default:
            return 0;
        }
      }
      else
      {
        v7 = v6 + 4;
      }
    }
    else
    {
      v7 = v6 - 71;
    }
  }
  v8 = a1[3];
  v9 = v8 - 65;
  if ( (unsigned int)(v8 - 65) >= 0x1A )
  {
    if ( (unsigned int)(v8 - 97) < 0x1A )
    {
      v9 = v8 - 71;
      goto LABEL_21;
    }
    if ( (unsigned int)(v8 - 48) < 0xA )
    {
      v9 = v8 + 4;
      goto LABEL_21;
    }
    switch ( v8 )
    {
      case '+':
        v9 = 62;
        goto LABEL_21;
      case '/':
        v9 = 63;
        goto LABEL_21;
      case '=':
        v9 = -1;
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  result = 0;
  if ( v3 != -1 && v5 != -1 )
  {
    if ( v7 == -1 && v9 != -1 )
      return 0;
    v11 = v5 << 12;
    v12 = (v11 | (unsigned int)(v3 << 18)) >> 16;
    if ( v7 == -1 )
      v13 = 1;
    else
      v13 = 2;
    if ( v9 == -1 )
      result = v13;
    else
      result = 3;
    *a2 = v12;
    if ( v9 != -1 || v7 != -1 )
    {
      v14 = (_WORD)v7 << 6;
      a2[1] = (unsigned __int16)(v14 & 0xF00 | v11) >> 8;
      if ( v9 == -1 )
      {
        return v13;
      }
      else
      {
        result = 3;
        a2[2] = v9 & 0x3F | v14;
      }
    }
  }
  return result;
}

//----- (000000000001A07C) ----------------------------------------------------
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  size_t result; // x0
  int v7; // w22
  __int64 v8; // x24
  unsigned int v9; // w23

  result = DHstrlen(a1);
  if ( (int)result < 1 )
  {
    v9 = 0;
LABEL_7:
    *a3 = v9;
  }
  else
  {
    v7 = result;
    v8 = 0;
    v9 = 0;
    while ( 1 )
    {
      result = base64_decode_atom((unsigned __int8 *)&a1[v8], (_BYTE *)(a2 + v9));
      if ( !(_DWORD)result )
        break;
      v8 += 4;
      v9 += result;
      if ( v7 <= (int)v8 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (000000000001A0F8) ----------------------------------------------------
void __fastcall PP_HexEncode_Update_A(__int64 a1, unsigned __int8 *a2, unsigned int a3, _BYTE *a4, _DWORD *a5)
{
  int v5; // w11
  __int64 v6; // x8
  _BYTE *v7; // x10
  unsigned int v8; // t1

  v5 = (int)a4;
  *a5 = 0;
  if ( a3 )
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *a2++;
      --v6;
      *v7 = a0123456789abcd[(unsigned __int64)v8 >> 4];
      v5 = (_DWORD)v7 + 2;
      v7[1] = a0123456789abcd[v8 & 0xF];
      v7 += 2;
    }
    while ( v6 );
  }
  *a5 = v5 - (_DWORD)a4;
}

//----- (000000000001A14C) ----------------------------------------------------
void __fastcall PP_HexEncode_Finish_A(__int64 a1, __int64 a2, _DWORD *a3)
{
  *a3 = 0;
}

//----- (000000000001A154) ----------------------------------------------------
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  int v4; // w11
  __int64 v5; // x8
  _BYTE *v6; // x10
  unsigned int v7; // t1

  v4 = (int)a3;
  *a4 = 0;
  if ( a2 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      v7 = *result++;
      --v5;
      *v6 = a0123456789abcd[(unsigned __int64)v7 >> 4];
      v4 = (_DWORD)v6 + 2;
      v6[1] = a0123456789abcd[v7 & 0xF];
      v6 += 2;
    }
    while ( v5 );
  }
  *a4 = v4 - (_DWORD)a3;
  return result;
}

//----- (000000000001A1A8) ----------------------------------------------------
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  if ( a6 )
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (__fastcall *)(_QWORD *, _QWORD *, __int64))AES_encrypt);
  else
    CRYPTO_cbc128_decrypt(
      (__int64)a1,
      a2,
      a3,
      a4,
      (unsigned __int64)a5,
      (__int64 (__fastcall *)(int8x16_t *, int8x16_t *, __int64))AES_decrypt);
}

//----- (000000000001A1C4) ----------------------------------------------------
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w8
  int v4; // w8
  unsigned int v6; // w8
  unsigned int v7; // w9
  unsigned int v8; // w10
  unsigned int v9; // w11
  __int64 v10; // x9
  unsigned int *v11; // x14
  unsigned __int64 v12; // x16
  int v13; // w1
  int v14; // w0
  int v15; // w17
  unsigned int v16; // w12
  __int64 v17; // x13
  unsigned int *i; // x0
  int v19; // w2
  unsigned int v20; // w12
  __int64 v21; // x13
  unsigned int *j; // x0
  int v23; // w2
  int v24; // w3
  int v25; // w4

  v3 = -1;
  if ( a1 && a3 )
  {
    if ( a2 != 128 && a2 != 256 && a2 != 192 )
      return 4294967294LL;
    if ( a2 == 128 )
    {
      v4 = 10;
    }
    else if ( a2 == 192 )
    {
      v4 = 12;
    }
    else
    {
      v4 = 14;
    }
    a3[60] = v4;
    v6 = bswap32(*a1);
    *a3 = v6;
    v7 = bswap32(a1[1]);
    a3[1] = v7;
    v8 = bswap32(a1[2]);
    a3[2] = v8;
    v9 = bswap32(a1[3]);
    a3[3] = v9;
    if ( a2 == 128 )
    {
      v10 = 0;
      v11 = a3 + 4;
      do
      {
        v12 = *(v11 - 1);
        v13 = *(_DWORD *)((char *)&unk_7DF0 + v10);
        v10 += 4;
        v6 ^= (byte_6DF0[4 * BYTE2(v12) + 3] << 24)
            ^ (byte_71F0[4 * BYTE1(v12) + 2] << 16)
            ^ (byte_75F0[4 * (unsigned __int8)v12 + 1] << 8)
            ^ byte_79F0[(v12 >> 22) & 0x3FC]
            ^ v13;
        v14 = *(v11 - 3) ^ v6;
        v15 = *(v11 - 2) ^ v14;
        *v11 = v6;
        v11[1] = v14;
        v11[2] = v15;
        v11[3] = v15 ^ v12;
        v11 += 4;
      }
      while ( v10 != 40 );
    }
    else
    {
      a3[4] = bswap32(a1[4]);
      v16 = bswap32(a1[5]);
      a3[5] = v16;
      if ( a2 == 192 )
      {
        v17 = 0;
        for ( i = a3 + 11; ; i += 6 )
        {
          v6 ^= (byte_6DF0[4 * BYTE2(v16) + 3] << 24)
              ^ (byte_71F0[4 * BYTE1(v16) + 2] << 16)
              ^ (byte_75F0[4 * (unsigned __int8)v16 + 1] << 8)
              ^ byte_79F0[4 * HIBYTE(v16)]
              ^ *(_DWORD *)((char *)&unk_7DF0 + v17);
          v7 ^= v6;
          v8 ^= v7;
          *(i - 5) = v6;
          *(i - 4) = v7;
          v9 ^= v8;
          *(i - 3) = v8;
          *(i - 2) = v9;
          if ( v17 == 28 )
            break;
          v17 += 4;
          v19 = *(i - 7) ^ v9;
          v16 ^= v19;
          *(i - 1) = v19;
          *i = v16;
        }
      }
      else
      {
        a3[6] = bswap32(a1[6]);
        v20 = bswap32(a1[7]);
        a3[7] = v20;
        v21 = 0;
        for ( j = a3 + 8; ; j += 8 )
        {
          v6 ^= (byte_6DF0[4 * BYTE2(v20) + 3] << 24)
              ^ (byte_71F0[4 * BYTE1(v20) + 2] << 16)
              ^ (byte_75F0[4 * (unsigned __int8)v20 + 1] << 8)
              ^ byte_79F0[4 * HIBYTE(v20)]
              ^ *(_DWORD *)((char *)&unk_7DF0 + v21);
          v7 ^= v6;
          v8 ^= v7;
          *j = v6;
          j[1] = v7;
          v9 ^= v8;
          j[2] = v8;
          j[3] = v9;
          if ( v21 == 24 )
            break;
          v21 += 4;
          v23 = *(j - 4)
              ^ (byte_6DF0[4 * HIBYTE(v9) + 3] << 24)
              ^ (byte_71F0[4 * BYTE2(v9) + 2] << 16)
              ^ (byte_75F0[4 * BYTE1(v9) + 1] << 8)
              ^ byte_79F0[4 * (unsigned __int8)v9];
          v24 = *(j - 2);
          v25 = *(j - 3) ^ v23;
          j[4] = v23;
          j[5] = v25;
          v20 ^= v24 ^ v25;
          j[6] = v24 ^ v25;
          j[7] = v20;
        }
      }
    }
    return 0;
  }
  return v3;
}
// 1A3E8: conditional instruction was optimized away because w1.4==100
// 6DF0: using guessed type unsigned __int8 byte_6DF0[1024];
// 71F0: using guessed type unsigned __int8 byte_71F0[1024];
// 75F0: using guessed type unsigned __int8 byte_75F0[1024];
// 79F0: using guessed type unsigned __int8 byte_79F0[1024];

//----- (000000000001A4E8) ----------------------------------------------------
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  __int64 result; // x0
  int v5; // w9
  int v6; // w10
  unsigned int *v7; // x9
  __int64 v8; // x8
  __int64 v9; // x11
  unsigned int *v10; // x10
  __int64 v11; // x11
  unsigned int v12; // w13
  bool v13; // cc
  unsigned int v14; // w13
  unsigned int v15; // w13
  unsigned int v16; // w13
  int *v17; // x11
  int v18; // w13
  unsigned __int64 v19; // x15
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x2
  __int64 v22; // x0
  __int64 v23; // x1
  __int64 v24; // x16
  __int64 v25; // x17
  __int64 v26; // x0
  unsigned __int64 v27; // x1
  __int64 v28; // x16
  __int64 v29; // x15
  __int64 v30; // x17
  __int64 v31; // x0
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x17
  __int64 v34; // x0
  __int64 v35; // x16
  __int64 v36; // x1

  result = private_AES_set_encrypt_key(a1, a2, a3);
  if ( (result & 0x80000000) == 0 )
  {
    v5 = a3[60];
    if ( v5 >= 1 )
    {
      v6 = 4 * v5;
      v7 = a3 + 2;
      v8 = 0;
      v9 = v6;
      v10 = &a3[v6 + 2];
      v11 = v9 - 4;
      do
      {
        v12 = *(v7 - 2);
        v8 += 4;
        v13 = v8 < v11;
        v11 -= 4;
        *(v7 - 2) = *(v10 - 2);
        *(v10 - 2) = v12;
        v14 = *(v7 - 1);
        *(v7 - 1) = *(v10 - 1);
        *(v10 - 1) = v14;
        v15 = *v7;
        *v7 = *v10;
        *v10 = v15;
        v16 = v7[1];
        v7[1] = v10[1];
        v7 += 4;
        v10[1] = v16;
        v10 -= 4;
      }
      while ( v13 );
      if ( (int)a3[60] >= 2 )
      {
        v17 = (int *)(a3 + 7);
        v18 = 1;
        do
        {
          v19 = (unsigned int)*(v17 - 3);
          v20 = (unsigned int)*(v17 - 2);
          ++v18;
          v21 = v20 >> 22;
          v22 = BYTE2(v20);
          v23 = BYTE1(v20);
          v24 = 4LL * (unsigned __int8)*(v17 - 2);
          *(v17 - 3) = dword_8218[byte_79F0[4 * BYTE2(v19)]]
                     ^ dword_7E18[byte_79F0[(v19 >> 22) & 0x3FC]]
                     ^ dword_8618[byte_79F0[4 * BYTE1(v19)]]
                     ^ dword_8A18[byte_79F0[4 * (unsigned __int8)*(v17 - 3)]];
          v25 = byte_79F0[4 * v22];
          v26 = byte_79F0[4 * v23];
          v27 = (unsigned int)*(v17 - 1);
          LODWORD(v19) = dword_8218[v25]
                       ^ dword_7E18[byte_79F0[v21 & 0x3FC]]
                       ^ dword_8618[v26]
                       ^ dword_8A18[byte_79F0[v24]];
          v28 = 4LL * (unsigned __int8)*(v17 - 1);
          *(v17 - 2) = v19;
          v29 = byte_79F0[(v27 >> 22) & 0x3FC];
          v30 = byte_79F0[4 * BYTE2(v27)];
          v31 = byte_79F0[4 * BYTE1(v27)];
          v32 = (unsigned int)*v17;
          LODWORD(v29) = dword_8218[v30] ^ dword_7E18[v29];
          v33 = v32 >> 22;
          LODWORD(v28) = dword_8618[v31] ^ dword_8A18[byte_79F0[v28]];
          v34 = BYTE2(v32);
          LODWORD(v29) = v29 ^ v28;
          v35 = BYTE1(v32);
          v36 = (unsigned __int8)*v17;
          *(v17 - 1) = v29;
          *v17 = dword_8218[byte_79F0[4 * v34]]
               ^ dword_7E18[byte_79F0[v33 & 0x3FC]]
               ^ dword_8618[byte_79F0[4 * v35]]
               ^ dword_8A18[byte_79F0[4 * v36]];
          v17 += 4;
        }
        while ( v18 < (int)a3[60] );
      }
    }
    return 0;
  }
  return result;
}
// 79F0: using guessed type unsigned __int8 byte_79F0[1024];
// 7E18: using guessed type _DWORD dword_7E18[256];
// 8218: using guessed type _DWORD dword_8218[256];
// 8618: using guessed type _DWORD dword_8618[256];
// 8A18: using guessed type _DWORD dword_8A18[256];

//----- (000000000001A724) ----------------------------------------------------
__int64 __fastcall AES_encrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w5
  unsigned int v4; // w16
  _DWORD *v5; // x14
  unsigned int v6; // w15
  unsigned int v7; // w17
  int i; // w13
  unsigned int v9; // w7
  int v10; // w0
  unsigned int v11; // w3
  int v12; // w17
  unsigned int v13; // w25
  unsigned int v14; // w21
  unsigned int v15; // w15
  unsigned int v16; // w22
  unsigned int v17; // w19
  int v18; // w6
  __int64 result; // x0
  int v20; // w24
  int v21; // w25
  int v22; // w5
  int v23; // w22
  int v24; // w23
  int v25; // w24
  int v26; // w26
  int v27; // w17
  int v28; // w0
  _DWORD *v29; // x12

  v3 = bswap32(*a1) ^ *a3;
  v4 = bswap32(a1[1]) ^ a3[1];
  v5 = a3 + 6;
  v6 = bswap32(a1[2]) ^ a3[2];
  v7 = bswap32(a1[3]) ^ a3[3];
  for ( i = ((int)a3[60] >> 1) - 1; ; --i )
  {
    v9 = *(_DWORD *)&byte_79F0[4 * BYTE2(v4)]
       ^ *(_DWORD *)&byte_75F0[4 * HIBYTE(v3)]
       ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v6)]
       ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v7]
       ^ *(v5 - 2);
    v10 = BYTE2(v7);
    v11 = *(_DWORD *)&byte_79F0[4 * BYTE2(v6)]
        ^ *(_DWORD *)&byte_75F0[4 * HIBYTE(v4)]
        ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v7)]
        ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v3]
        ^ *(v5 - 1);
    v12 = *(_DWORD *)&byte_79F0[4 * BYTE2(v3)]
        ^ *(_DWORD *)&byte_75F0[4 * HIBYTE(v7)]
        ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v4)]
        ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v6];
    v13 = HIBYTE(v9);
    v14 = HIBYTE(v11);
    v15 = *(_DWORD *)&byte_79F0[4 * v10]
        ^ *(_DWORD *)&byte_75F0[4 * HIBYTE(v6)]
        ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v3)]
        ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v4]
        ^ *v5;
    v16 = v12 ^ v5[1];
    v17 = HIBYTE(v15);
    v18 = BYTE2(v16);
    result = HIBYTE(v16);
    if ( !i )
      break;
    v20 = *(_DWORD *)&byte_79F0[4 * BYTE2(v11)] ^ *(_DWORD *)&byte_75F0[4 * v13];
    v21 = *(_DWORD *)&byte_6DF0[4 * BYTE1(v16)];
    v22 = v20
        ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v15)]
        ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))];
    v23 = v5[2];
    v24 = v5[3];
    v25 = v5[4];
    v26 = v5[5];
    v27 = *(_DWORD *)&byte_79F0[4 * BYTE2(v9)] ^ *(_DWORD *)&byte_75F0[4 * (unsigned int)result];
    v28 = *(_DWORD *)&byte_6DF0[4 * BYTE1(v11)] ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v15];
    v5 += 8;
    v3 = v22 ^ v23;
    v4 = *(_DWORD *)&byte_79F0[4 * BYTE2(v15)]
       ^ *(_DWORD *)&byte_75F0[4 * v14]
       ^ v21
       ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v9]
       ^ v24;
    v6 = *(_DWORD *)&byte_79F0[4 * v18]
       ^ *(_DWORD *)&byte_75F0[4 * v17]
       ^ *(_DWORD *)&byte_6DF0[4 * BYTE1(v9)]
       ^ *(_DWORD *)&byte_71F0[4 * (unsigned __int8)v11]
       ^ v25;
    v7 = v27 ^ v28 ^ v26;
  }
  v29 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_6DF0[4 * v13 + 3] << 24)
         | (byte_71F0[4 * BYTE2(v11) + 2] << 16)
         | (byte_75F0[4 * BYTE1(v15) + 1] << 8)
         | byte_79F0[4 * (unsigned __int8)(v12 ^ *((_BYTE *)v5 + 4))])
        ^ v29[8]);
  a2[1] = bswap32(
            ((byte_6DF0[4 * v14 + 3] << 24)
           | (byte_71F0[4 * BYTE2(v15) + 2] << 16)
           | (byte_75F0[4 * BYTE1(v16) + 1] << 8)
           | byte_79F0[4 * (unsigned __int8)v9])
          ^ v29[9]);
  a2[2] = bswap32(
            ((byte_6DF0[4 * v17 + 3] << 24)
           | (byte_71F0[4 * BYTE2(v16) + 2] << 16)
           | (byte_75F0[4 * BYTE1(v9) + 1] << 8)
           | byte_79F0[4 * (unsigned __int8)v11])
          ^ v29[10]);
  a2[3] = bswap32(
            ((byte_6DF0[4 * (unsigned int)result + 3] << 24)
           | (byte_71F0[4 * BYTE2(v9) + 2] << 16)
           | (byte_75F0[4 * BYTE1(v11) + 1] << 8)
           | byte_79F0[4 * (unsigned __int8)v15])
          ^ v29[11]);
  return result;
}
// 6DF0: using guessed type unsigned __int8 byte_6DF0[1024];
// 71F0: using guessed type unsigned __int8 byte_71F0[1024];
// 75F0: using guessed type unsigned __int8 byte_75F0[1024];
// 79F0: using guessed type unsigned __int8 byte_79F0[1024];

//----- (000000000001AA60) ----------------------------------------------------
unsigned __int64 __fastcall AES_decrypt(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // w13
  unsigned int v4; // w17
  unsigned int v5; // w16
  _DWORD *v6; // x15
  unsigned int v7; // w0
  unsigned int v8; // w3
  int v9; // w14
  unsigned int v10; // w4
  unsigned __int64 v11; // x9
  int v12; // w5
  int v13; // w6
  int v14; // w7
  unsigned __int64 v15; // x16
  unsigned __int64 result; // x0
  unsigned __int64 v17; // x3
  int v18; // w7
  int v19; // w4
  int v20; // w5
  int v21; // w6
  int v22; // w19
  int v23; // w9
  _DWORD *v24; // x8

  v3 = a1[3];
  v4 = bswap32(*a1) ^ *a3;
  v5 = bswap32(a1[1]) ^ a3[1];
  v6 = a3 + 6;
  v7 = bswap32(a1[2]) ^ a3[2];
  v8 = bswap32(v3) ^ a3[3];
  v9 = ((int)a3[60] >> 1) - 1;
  while ( 1 )
  {
    v10 = *(v6 - 1);
    v11 = dword_8218[BYTE2(v8)]
        ^ dword_7E18[HIBYTE(v4)]
        ^ (unsigned int)(dword_8618[BYTE1(v7)] ^ dword_8A18[(unsigned __int8)v5])
        ^ *(v6 - 2);
    v12 = BYTE2(v5);
    v13 = dword_8218[BYTE2(v4)] ^ dword_7E18[HIBYTE(v5)] ^ dword_8618[BYTE1(v8)] ^ dword_8A18[(unsigned __int8)v7];
    v14 = dword_8218[BYTE2(v7)] ^ dword_7E18[HIBYTE(v8)] ^ dword_8618[BYTE1(v5)] ^ dword_8A18[(unsigned __int8)v4];
    v15 = v13 ^ v10;
    result = dword_8218[v12]
           ^ dword_7E18[HIBYTE(v7)]
           ^ (unsigned int)(dword_8618[BYTE1(v4)] ^ dword_8A18[(unsigned __int8)v8])
           ^ *v6;
    v17 = (unsigned int)v14 ^ v6[1];
    if ( !v9 )
      break;
    --v9;
    v18 = v6[3];
    v19 = dword_8218[BYTE2(v11)] ^ dword_7E18[BYTE3(v15)] ^ dword_8618[BYTE1(v17)] ^ dword_8A18[(unsigned __int8)result];
    v4 = dword_8218[BYTE2(v17)]
       ^ dword_7E18[BYTE3(v11)]
       ^ dword_8618[BYTE1(result)]
       ^ dword_8A18[(unsigned __int8)v15]
       ^ v6[2];
    v20 = dword_8218[BYTE2(v15)] ^ dword_7E18[BYTE3(result)] ^ dword_8618[BYTE1(v11)] ^ dword_8A18[(unsigned __int8)v17];
    v21 = v6[4];
    v22 = v6[5];
    v23 = dword_8218[BYTE2(result)] ^ dword_7E18[BYTE3(v17)] ^ dword_8618[BYTE1(v15)] ^ dword_8A18[(unsigned __int8)v11];
    v6 += 8;
    v5 = v19 ^ v18;
    v7 = v20 ^ v21;
    v8 = v23 ^ v22;
  }
  v24 = &a3[8 * (((int)a3[60] >> 1) - 1)];
  *a2 = bswap32(
          ((byte_8E18[v11 >> 24] << 24)
         | (byte_8E18[BYTE2(v17)] << 16)
         | (byte_8E18[BYTE1(result)] << 8)
         | byte_8E18[(unsigned __int8)(v13 ^ v10)])
        ^ v24[8]);
  a2[1] = bswap32(
            ((byte_8E18[v15 >> 24] << 24)
           | (byte_8E18[BYTE2(v11)] << 16)
           | (byte_8E18[BYTE1(v17)] << 8)
           | byte_8E18[(unsigned __int8)result])
          ^ v24[9]);
  a2[2] = bswap32(
            ((byte_8E18[result >> 24] << 24)
           | (byte_8E18[BYTE2(v15)] << 16)
           | (byte_8E18[BYTE1(v11)] << 8)
           | byte_8E18[(unsigned __int8)v17])
          ^ v24[10]);
  a2[3] = bswap32(
            ((byte_8E18[v17 >> 24] << 24)
           | (byte_8E18[BYTE2(result)] << 16)
           | (byte_8E18[BYTE1(v15)] << 8)
           | byte_8E18[(unsigned __int8)v11])
          ^ v24[11]);
  return result;
}
// 7E18: using guessed type _DWORD dword_7E18[256];
// 8218: using guessed type _DWORD dword_8218[256];
// 8618: using guessed type _DWORD dword_8618[256];
// 8A18: using guessed type _DWORD dword_8A18[256];
// 8E18: using guessed type unsigned __int8 byte_8E18[256];

//----- (000000000001AD84) ----------------------------------------------------
const char *AES_options()
{
  return "aes(partial)";
}

//----- (000000000001AD98) ----------------------------------------------------
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  unsigned __int64 v9; // x22
  _QWORD *v12; // x8
  _QWORD *v13; // x25
  __int64 i; // x9
  unsigned __int64 v15; // x9
  __int64 v16; // x10
  long double result; // q0

  v9 = a3;
  v12 = a5;
  if ( a3 >= 0x10 )
  {
    do
    {
      v13 = a2;
      *a2 = *v12 ^ *a1;
      a2[1] = v12[1] ^ a1[1];
      a6(a2, a2, a4);
      v9 -= 16LL;
      a1 += 2;
      a2 += 2;
      v12 = v13;
    }
    while ( v9 > 0xF );
    v12 = a2 - 2;
  }
  if ( v9 )
  {
    for ( i = 0; i != v9; ++i )
      *((_BYTE *)a2 + i) = *((_BYTE *)v12 + i) ^ *((_BYTE *)a1 + i);
    if ( (unsigned __int64)(i - 1) <= 0xE )
    {
      if ( v9 > 8 || (unsigned __int64)((char *)a2 - (char *)v12) < 0x20 )
        goto LABEL_19;
      v15 = 16 - v9;
      *(_QWORD *)((char *)a2 + v9) = *(_QWORD *)((char *)v12 + v9);
      v16 = (16 - v9) & 0x18;
      if ( v16 != 8 )
        *(_QWORD *)((char *)a2 + v9 + 8) = *(_QWORD *)((char *)v12 + v9 + 8);
      v9 += v16;
      if ( v15 != v16 )
      {
LABEL_19:
        do
        {
          *((_BYTE *)a2 + v9) = *((_BYTE *)v12 + v9);
          ++v9;
        }
        while ( v9 != 16 );
      }
    }
    a6(a2, a2, a4);
  }
  else
  {
    a2 = v12;
  }
  result = *(long double *)a2;
  *a5 = *(_OWORD *)a2;
  return result;
}

//----- (000000000001AEEC) ----------------------------------------------------
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  int8x16_t *v9; // x22
  unsigned __int64 v10; // x20
  int8x16_t *v11; // x25
  _QWORD *n128_u64; // x27
  int8x16_t *v13; // x21
  __int64 v14; // x10
  __int64 v15; // x8
  _OWORD *v16; // x8
  __int64 v17; // x10
  unsigned __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x9
  int8x16_t *v21; // x21
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x10
  unsigned __int64 v25; // x13
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x14
  int8x16_t *v30; // x12
  unsigned __int64 v31; // x15
  bool v33; // w10
  bool v35; // w11
  bool v37; // w13
  bool v39; // w12
  int8x16_t *v41; // x10
  int8x16_t *v42; // x11
  int8x16_t *v43; // x12
  int8x16_t *v44; // x13
  unsigned __int64 v45; // x14
  int8x16_t v46; // q1
  int8x16_t v47; // q2
  int8x16_t v48; // q4
  int8x16_t v49; // q5
  int8x16_t v50; // q0
  int8x16_t v51; // q1
  __int128 *v52; // x11
  _OWORD *v53; // x12
  unsigned __int64 v54; // x13
  __int128 v55; // q0
  __int128 v56; // q1
  unsigned __int64 v57; // x13
  unsigned __int64 v58; // x10
  __int64 *v59; // x12
  _QWORD *v60; // x13
  __int64 v61; // t1
  unsigned __int64 v62; // x8
  _BYTE *v63; // x9
  char *v64; // x10
  char v65; // t1
  _QWORD v66[2]; // [xsp+8h] [xbp-18h] BYREF
  __int64 v67; // [xsp+18h] [xbp-8h] BYREF

  v9 = (int8x16_t *)result;
  v10 = a3;
  v67 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( (int8x16_t *)result != a2 )
  {
    v11 = a2;
    if ( a3 < 0x10 )
    {
      v16 = (_OWORD *)a5;
    }
    else
    {
      n128_u64 = (_QWORD *)a5;
      do
      {
        v13 = v9;
        result = a6(v9, v11, a4);
        v14 = v11->n128_i64[1];
        v10 -= 16LL;
        ++v9;
        v11->n128_u64[0] ^= *n128_u64;
        v15 = n128_u64[1];
        n128_u64 = v13->n128_u64;
        v11->n128_u64[1] = v14 ^ v15;
        ++v11;
      }
      while ( v10 > 0xF );
      v16 = v9[-1].n128_u64;
    }
    v21 = v9;
    v9 = v11;
    *(_OWORD *)a5 = *v16;
LABEL_11:
    if ( !v10 )
      return result;
    goto LABEL_12;
  }
  if ( a3 >= 0x10 )
  {
    do
    {
      result = a6(v9, (int8x16_t *)v66, a4);
      v17 = v66[1];
      v10 -= 16LL;
      v18 = v9->n128_u64[0];
      v9->n128_u64[0] = *(_QWORD *)a5 ^ v66[0];
      v19 = *(_QWORD *)(a5 + 8);
      *(_QWORD *)a5 = v18;
      v20 = v9->n128_i64[1];
      v9->n128_u64[1] = v19 ^ v17;
      v21 = ++v9;
      *(_QWORD *)(a5 + 8) = v20;
    }
    while ( v10 > 0xF );
    goto LABEL_11;
  }
  v21 = (int8x16_t *)result;
  if ( !a3 )
    return result;
LABEL_12:
  result = a6(v21, (int8x16_t *)v66, a4);
  v22 = 17 - v10;
  if ( v10 < 0x20 )
  {
    v23 = 0;
    goto LABEL_14;
  }
  v29 = (unsigned __int64)v9->n128_u64 + v10;
  v30 = (int8x16_t *)((char *)v66 + v10);
  v31 = a5 + v10;
  v33 = v9 < (int8x16_t *)((char *)v21 + v10) && (unsigned __int64)v21 < v29;
  v35 = v9 < v30 && (unsigned __int64)v66 < v29;
  v23 = 0;
  v37 = (unsigned __int64)v21->n128_u64 + v10 > a5 && (unsigned __int64)v21 < v31;
  v39 = (unsigned __int64)v30 > a5 && (unsigned __int64)v66 < v31;
  if ( v29 > a5 && (unsigned __int64)v9 < v31 )
    goto LABEL_14;
  if ( v33 )
    goto LABEL_14;
  if ( v35 )
    goto LABEL_14;
  if ( v37 )
    goto LABEL_14;
  if ( v39 )
    goto LABEL_14;
  v23 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  v41 = v21 + 1;
  v22 |= v10 & 0xFFFFFFFFFFFFFFE0LL;
  v42 = (int8x16_t *)&v67;
  v43 = v9 + 1;
  v44 = (int8x16_t *)(a5 + 16);
  v45 = v10 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v45 -= 32LL;
    v46 = v42[-1];
    v47 = *v42;
    v42 += 2;
    v48 = v41[-1];
    v49 = *v41;
    v41 += 2;
    v50 = veorq_s8(v44[-1], v46);
    v51 = veorq_s8(*v44, v47);
    v44[-1] = v48;
    *v44 = v49;
    v44 += 2;
    v43[-1] = v50;
    *v43 = v51;
    v43 += 2;
  }
  while ( v45 );
  if ( v23 != v10 )
  {
LABEL_14:
    v24 = 0;
    v25 = a5 + v23;
    do
    {
      result = v21->n128_u8[v23 + v24];
      v9->n128_u8[v23 + v24] = *(_BYTE *)(v25 + v24) ^ *((_BYTE *)v66 + v23 + v24);
      *(_BYTE *)(v25 + v24++) = result;
    }
    while ( v23 - v10 + v24 );
    v26 = v22 + v24 - 1;
    if ( v23 + v24 - 1 > 0xE )
      return result;
    goto LABEL_17;
  }
  v26 = v23 - v10 + 16;
  if ( v23 - 1 > 0xE )
    return result;
LABEL_17:
  v27 = 16 - v10;
  if ( 16 - v10 < 8 || a5 - (unsigned __int64)v21 < 0x20 )
    goto LABEL_70;
  if ( v27 < 0x20 )
  {
    v28 = 0;
    goto LABEL_65;
  }
  v28 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  v52 = (__int128 *)((char *)&v21[1] + v10);
  v53 = (_OWORD *)(a5 + v10 + 16);
  v54 = v27 & 0xFFFFFFFFFFFFFFE0LL;
  do
  {
    v55 = *(v52 - 1);
    v56 = *v52;
    v54 -= 32LL;
    v52 += 2;
    *(v53 - 1) = v55;
    *v53 = v56;
    v53 += 2;
  }
  while ( v54 );
  if ( v27 != v28 )
  {
    if ( (v27 & 0x18) == 0 )
    {
      v10 += v28;
      goto LABEL_70;
    }
LABEL_65:
    v57 = v10 + v28;
    v10 += v27 & 0xFFFFFFFFFFFFFFF8LL;
    v58 = v28 - (v27 & 0xFFFFFFFFFFFFFFF8LL);
    v59 = (__int64 *)((char *)v21 + v57);
    v60 = (_QWORD *)(a5 + v57);
    do
    {
      v61 = *v59++;
      v58 += 8LL;
      *v60++ = v61;
    }
    while ( v58 );
    if ( v27 == (v27 & 0xFFFFFFFFFFFFFFF8LL) )
      return result;
LABEL_70:
    v62 = v26 - v10;
    v63 = (_BYTE *)(a5 + v10);
    v64 = (char *)v21 + v10;
    do
    {
      v65 = *v64++;
      --v62;
      *v63++ = v65;
    }
    while ( v62 );
  }
  return result;
}

//----- (000000000001B250) ----------------------------------------------------
void sub_1B250()
{
  JUMPOUT(0);
}
// 1B260: control flows out of bounds to 0

//----- (000000000001B290) ----------------------------------------------------
// attributes: thunk
void printLogD()
{
  printLogD();
}

//----- (000000000001B2B0) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DHstrlen(const char *a1)
{
  return DHstrlen(a1);
}

//----- (000000000001B2E0) ----------------------------------------------------
// attributes: thunk
__int64 DRM_Init()
{
  return DRM_Init();
}

//----- (000000000001B2F0) ----------------------------------------------------
// attributes: thunk
void DRM_Destroy()
{
  DRM_Destroy();
}

//----- (000000000001B310) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmemcpy_s(__int64 a1, int a2, __int64 a3, int a4)
{
  return DHmemcpy_s(a1, a2, a3, a4);
}

//----- (000000000001B330) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Path(char *a1, int a2, __int16 a3)
{
  return DRM_Open_Path(a1, a2, a3);
}

//----- (000000000001B350) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Open_Pfd(int a1, int a2, __int16 a3)
{
  return DRM_Open_Pfd(a1, a2, a3);
}

//----- (000000000001B360) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Close(__int16 a1)
{
  return DRM_Close(a1);
}

//----- (000000000001B370) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_VF_Open(int a1, __int64 a2, int a3)
{
  return DRM_VF_Open(a1, a2, a3);
}

//----- (000000000001B380) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_VF_SetFileSize(__int16 a1, int a2)
{
  return DRM_VF_SetFileSize(a1, a2);
}

//----- (000000000001B390) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_VF_SetBuffer(__int16 a1, __int64 a2, int a3, int a4)
{
  return DRM_VF_SetBuffer(a1, a2, a3, a4);
}

//----- (000000000001B3A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_VF_IsReachedToEndOfFile(__int16 a1, _WORD *a2)
{
  return DRM_VF_IsReachedToEndOfFile(a1, a2);
}

//----- (000000000001B3B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_VF_ShouldUpdateBuffer(__int16 a1, _WORD *a2, _DWORD *a3)
{
  return DRM_VF_ShouldUpdateBuffer(a1, a2, a3);
}

//----- (000000000001B3D0) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DRM_Read(unsigned int a1, char *a2, signed int a3)
{
  return DRM_Read(a1, a2, a3);
}

//----- (000000000001B3F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_Seek(unsigned int a1, int a2, int a3)
{
  return DRM_Seek(a1, a2, a3);
}

//----- (000000000001B400) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetOriginalFileSize(__int16 a1)
{
  return DRM_GetOriginalFileSize(a1);
}

//----- (000000000001B410) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetFileSize(__int16 a1)
{
  return DRM_GetFileSize(a1);
}

//----- (000000000001B420) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetContentInfo(__int16 a1, int **a2)
{
  return DRM_GetContentInfo(a1, a2);
}

//----- (000000000001B430) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsPfdOpen(int a1, int a2)
{
  return DHfsPfdOpen(a1, a2);
}

//----- (000000000001B440) ----------------------------------------------------
// attributes: thunk
size_t __fastcall DHfsRead(FILE *stream, void *ptr, int a3)
{
  return DHfsRead(stream, ptr, a3);
}

//----- (000000000001B450) ----------------------------------------------------
// attributes: thunk
__int64 DHfsClose()
{
  return DHfsClose();
}
// 1649C: using guessed type __int64 DHfsClose(void);

//----- (000000000001B470) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemset(void *a1, int a2, int a3)
{
  return DHmemset(a1, a2, a3);
}

//----- (000000000001B480) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncpy_s(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  return DHstrncpy_s(a1, a2, a3, a4);
}

//----- (000000000001B490) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetUnsupportedValue(__int16 a1, _BYTE *a2, _BYTE *a3)
{
  return DRM_GetUnsupportedValue(a1, a2, a3);
}

//----- (000000000001B4A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_GetDCFMetaDataEncodingType(__int16 a1)
{
  return DRM_GetDCFMetaDataEncodingType(a1);
}

//----- (000000000001B4C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_CheckDCFFromPfd(int a1, __int64 a2)
{
  return DRM_CheckDCFFromPfd(a1, a2);
}

//----- (000000000001B4D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DRM_CheckDCF(char *a1, __int64 a2)
{
  return DRM_CheckDCF(a1, a2);
}

//----- (000000000001B500) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall StrErrorReturn(int a1)
{
  return StrErrorReturn(a1);
}

//----- (000000000001B510) ----------------------------------------------------
// attributes: thunk
__int64 DRM_SetClientID()
{
  return DRM_SetClientID();
}

//----- (000000000001B520) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetClientID_BySetVal(const char *a1, unsigned int *a2, __int64 a3, __int16 **a4)
{
  return DHGetClientID_BySetVal(a1, a2, a3, a4);
}

//----- (000000000001B530) ----------------------------------------------------
// attributes: thunk
void __fastcall DHFreeClientID(void *a1)
{
  DHFreeClientID(a1);
}

//----- (000000000001B540) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmalloc(int a1)
{
  return DHmalloc(a1);
}

//----- (000000000001B550) ----------------------------------------------------
// attributes: thunk
__int64 DA_DRA_SetClientID()
{
  return DA_DRA_SetClientID();
}
// 19D2C: using guessed type __int64 DA_DRA_SetClientID(void);

//----- (000000000001B560) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfree(void *a1)
{
  DHfree(a1);
}

//----- (000000000001B570) ----------------------------------------------------
// attributes: thunk
void DHmemcount()
{
  DHmemcount();
}

//----- (000000000001B580) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_FileOpen(char *a1, int a2, __int64 a3)
{
  return DA_DRA_FileOpen(a1, a2, a3);
}

//----- (000000000001B590) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_DCFParser(FILE *a1, __int64 a2, int *a3)
{
  return DA_DRA_DCFParser(a1, a2, a3);
}

//----- (000000000001B5A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrnicmp(_BYTE *a1, _BYTE *a2, int a3)
{
  return DHstrnicmp(a1, a2, a3);
}

//----- (000000000001B5B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall ClusterAuthentication(_BYTE *a1, __int64 *a2, __int64 *a3, __int64 **a4, _DWORD *a5, void **a6)
{
  return ClusterAuthentication(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001B5C0) ----------------------------------------------------
// attributes: thunk
__int64 DHfsTell()
{
  return DHfsTell();
}
// 16AE8: using guessed type __int64 DHfsTell(void);

//----- (000000000001B5D0) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRA_DCFDestroy(_QWORD *a1)
{
  DA_DRA_DCFDestroy(a1);
}

//----- (000000000001B5E0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetFileSize(__int64 result, int a2)
{
  return DHfs_VF_SetFileSize(result, a2);
}

//----- (000000000001B5F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_SetBuffer(__int64 result, __int64 a2, int a3, int a4)
{
  return DHfs_VF_SetBuffer(result, a2, a3, a4);
}

//----- (000000000001B600) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_FilePfdOpen(int a1, int a2, __int64 a3)
{
  return DA_DRA_FilePfdOpen(a1, a2, a3);
}

//----- (000000000001B610) ----------------------------------------------------
// attributes: thunk
void __fastcall ClientIDDestroy(_QWORD *a1)
{
  ClientIDDestroy(a1);
}

//----- (000000000001B620) ----------------------------------------------------
// attributes: thunk
void __fastcall DomainListDestroy(__int64 a1)
{
  DomainListDestroy(a1);
}

//----- (000000000001B630) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_IsReachedToEndOfFile(__int64 result, _WORD *a2)
{
  return DHfs_VF_IsReachedToEndOfFile(result, a2);
}

//----- (000000000001B640) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfs_VF_ShouldUpdateBuffer(__int64 result, _WORD *a2, _DWORD *a3)
{
  return DHfs_VF_ShouldUpdateBuffer(result, a2, a3);
}

//----- (000000000001B650) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsSeek(FILE *a1, int a2, int a3)
{
  return DHfsSeek(a1, a2, a3);
}

//----- (000000000001B660) ----------------------------------------------------
// attributes: thunk
__int64 AES_set_decrypt_key()
{
  return AES_set_decrypt_key();
}
// 1AD94: using guessed type __int64 AES_set_decrypt_key(void);

//----- (000000000001B670) ----------------------------------------------------
// attributes: thunk
void __fastcall AES_cbc_encrypt(_QWORD *a1, int8x16_t *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  AES_cbc_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001B680) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall checkDomain(_BYTE *a1, __int64 a2, char *a3)
{
  return checkDomain(a1, a2, a3);
}

//----- (000000000001B690) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall GetClientID(__int16 a1, __int64 a2, unsigned int *a3)
{
  return GetClientID(a1, a2, a3);
}

//----- (000000000001B6A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eTarget(const char *a1, const char *a2, _BYTE *a3, const char *a4)
{
  return compute_eTarget(a1, a2, a3, a4);
}

//----- (000000000001B6B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eServiceCode(__int16 a1, const char *a2, _BYTE *a3, const char *a4, const char *a5)
{
  return compute_eServiceCode(a1, a2, a3, a4, a5);
}

//----- (000000000001B6C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_eAuthCode(
        __int16 a1,
        const char *a2,
        char *a3,
        const char *a4,
        unsigned __int8 *a5,
        char *a6,
        __int16 a7)
{
  return compute_eAuthCode(a1, a2, a3, a4, a5, a6, a7);
}

//----- (000000000001B6D0) ----------------------------------------------------
// attributes: thunk
const char *__fastcall DHstristr(const char *a1, const char *a2)
{
  return DHstristr(a1, a2);
}

//----- (000000000001B6E0) ----------------------------------------------------
// attributes: thunk
__int64 DHatoi()
{
  return DHatoi();
}
// 16F4C: using guessed type __int64 DHatoi(void);

//----- (000000000001B6F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall get_SSEBaseStream(__int16 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5)
{
  return get_SSEBaseStream(a1, a2, a3, a4, a5);
}

//----- (000000000001B700) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DA_DRA_GetDCFHeader(__int64 a1, __int64 a2)
{
  return DA_DRA_GetDCFHeader(a1, a2);
}

//----- (000000000001B710) ----------------------------------------------------
// attributes: thunk
__int64 DHAuthTime()
{
  return DHAuthTime();
}

//----- (000000000001B720) ----------------------------------------------------
// attributes: thunk
__int64 DHcurrentTime()
{
  return DHcurrentTime();
}

//----- (000000000001B730) ----------------------------------------------------
// attributes: thunk
FILE *__fastcall DHfsOpen(char *filename, int a2)
{
  return DHfsOpen(filename, a2);
}

//----- (000000000001B740) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmemcmp(const void *a1, const void *a2, int a3)
{
  return DHmemcmp(a1, a2, a3);
}

//----- (000000000001B770) ----------------------------------------------------
// attributes: thunk
void *__fastcall DHmemcpy(void *a1, const void *a2, int a3)
{
  return DHmemcpy(a1, a2, a3);
}

//----- (000000000001B780) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall compute_SSKey(__int16 a1, const char *a2, char *a3, void *a4, __int16 a5)
{
  return compute_SSKey(a1, a2, a3, a4, a5);
}

//----- (000000000001B790) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrcpy_s(char *a1, int a2, char *s)
{
  return DHstrcpy_s(a1, a2, s);
}

//----- (000000000001B7A0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetDeviceID_ConstVal(char *a1)
{
  return DHGetDeviceID_ConstVal(a1);
}

//----- (000000000001B7B0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncat_s(char *s, int a2, __int64 a3, int a4)
{
  return DHstrncat_s(s, a2, a3, a4);
}

//----- (000000000001B7C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHmktime(unsigned __int64 a1, int a2)
{
  return DHmktime(a1, a2);
}

//----- (000000000001B7D0) ----------------------------------------------------
// attributes: thunk
void __fastcall DA_DRM_HASH_SHA1Digest(__int64 a1, uint32x4_t *a2, unsigned int a3)
{
  DA_DRM_HASH_SHA1Digest(a1, a2, a3);
}

//----- (000000000001B7E0) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall inverse(int8x16_t *result, int8x16_t *a2, int a3)
{
  return inverse(result, a2, a3);
}

//----- (000000000001B7F0) ----------------------------------------------------
// attributes: thunk
int8x16_t *__fastcall DHultoa(unsigned int a1, int8x16_t *a2, unsigned int a3)
{
  return DHultoa(a1, a2, a3);
}

//----- (000000000001B800) ----------------------------------------------------
// attributes: thunk
__int64 DHstrcat()
{
  return DHstrcat();
}
// 16E2C: using guessed type __int64 DHstrcat(void);

//----- (000000000001B810) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHsprintf_s(char *a1, __int64 a2, char *format, int a4, int a5, int a6, int a7, int a8, char a9)
{
  return DHsprintf_s(a1, a2, format);
}

//----- (000000000001B820) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHstrncmp(const char *a1, const char *a2, int a3)
{
  return DHstrncmp(a1, a2, a3);
}

//----- (000000000001B830) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall DHstrlwr(_BYTE *result)
{
  return DHstrlwr(result);
}

//----- (000000000001B840) ----------------------------------------------------
// attributes: thunk
char *__fastcall DHstrchr(const char *a1, unsigned __int8 a2)
{
  return DHstrchr(a1, a2);
}

//----- (000000000001B850) ----------------------------------------------------
// attributes: thunk
unsigned __int8 *__fastcall PP_HexEncode_A(unsigned __int8 *result, unsigned int a2, _BYTE *a3, _DWORD *a4)
{
  return PP_HexEncode_A(result, a2, a3, a4);
}

//----- (000000000001B860) ----------------------------------------------------
// attributes: thunk
__int64 DHstrstr()
{
  return DHstrstr();
}
// 17104: using guessed type __int64 DHstrstr(void);

//----- (000000000001B870) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsMetaOpen(const char *a1, int a2)
{
  return DHfsMetaOpen(a1, a2);
}

//----- (000000000001B880) ----------------------------------------------------
// attributes: thunk
_QWORD *__fastcall DHfsPfdMetaOpen(int a1, int a2)
{
  return DHfsPfdMetaOpen(a1, a2);
}

//----- (000000000001B8C0) ----------------------------------------------------
// attributes: thunk
void __fastcall DHfsMetaClose(_QWORD *a1)
{
  DHfsMetaClose(a1);
}

//----- (000000000001B8D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHfsMetaSeek(__int64 a1, int a2, int a3)
{
  return DHfsMetaSeek(a1, a2, a3);
}

//----- (000000000001B9D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHGetStateInfo(void *a1)
{
  return DHGetStateInfo(a1);
}

//----- (000000000001B9F0) ----------------------------------------------------
// attributes: thunk
size_t __fastcall base64_decode(const char *a1, __int64 a2, unsigned int *a3)
{
  return base64_decode(a1, a2, a3);
}

//----- (000000000001BA10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall DHSetClientID(__int64 *a1, __int64 a2, __int16 *a3)
{
  return DHSetClientID(a1, a2, a3);
}

//----- (000000000001BA30) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall base64_decode_atom(unsigned __int8 *a1, _BYTE *a2)
{
  return base64_decode_atom(a1, a2);
}

//----- (000000000001BA40) ----------------------------------------------------
// attributes: thunk
long double __fastcall CRYPTO_cbc128_encrypt(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        _OWORD *a5,
        void (__fastcall *a6)(_QWORD *, _QWORD *, __int64))
{
  return CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, a6);
}

//----- (000000000001BA50) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall CRYPTO_cbc128_decrypt(
        __int64 result,
        int8x16_t *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 (__fastcall *a6)(int8x16_t *, int8x16_t *, __int64))
{
  return CRYPTO_cbc128_decrypt(result, a2, a3, a4, a5, a6);
}

//----- (000000000001BA60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_encrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_encrypt_key(a1, a2, a3);
}

//----- (000000000001BA70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall private_AES_set_decrypt_key(unsigned int *a1, int a2, unsigned int *a3)
{
  return private_AES_set_decrypt_key(a1, a2, a3);
}

// nfuncs=361 queued=274 decompiled=274 lumina nreq=0 worse=0 better=0
// ALL OK, 274 function(s) have been successfully decompiled
