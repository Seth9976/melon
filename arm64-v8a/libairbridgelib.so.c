/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_EE0();
__int64 __fastcall getHmacRef(__int64 a1, __int64 *a2, __int64 *a3);
// int __cxa_finalize(void *);
__int64 __fastcall _JNIEnv::CallStaticObjectMethod(__int64 a1, __int64 a2, __int64 a3);
// char *strcat(char *dest, const char *src);
__int64 __fastcall generateKey(__int64 a1, __int64 a2, __int64 a3, int a4);
_DWORD *__fastcall SHA256Transform(_DWORD *result, __int64 a2);
__int64 __fastcall callTotpMethod(__int64 a1, __int64 a2, __int64 a3);
// char *strncpy(char *dest, const char *src, size_t n);
// int __android_log_print(int prio, const char *tag, const char *fmt, ...);
__int64 __fastcall generate(__int64 a1, char *s, __int64 a3, __int64 a4);
_BYTE *__fastcall SHA256(char *a1);
// __int64 __vsprintf_chk(_QWORD, _QWORD, _QWORD, const char *, ...); weak
// size_t strlen(const char *s);
// __int64 __fastcall __strcat_chk(_QWORD, _QWORD, _QWORD); weak
// void *malloc(size_t size);
__int64 __fastcall getTotpRef(__int64 a1, __int64 *a2, __int64 *a3);
// void *memset(void *s, int c, size_t n);
_DWORD *__fastcall SHA256Final(__int64 a1, _BYTE *a2);
__int64 __fastcall callHmacMethod(__int64 a1, __int64 a2, __int64 a3);
// char *strcpy(char *dest, const char *src);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
__int64 start();
__int64 (*__fastcall sub_1074(__int64 (*result)(void)))(void);
__int64 __fastcall sub_1080(void *a1);
char *__fastcall Java_co_ab180_airbridge_internal_signature_NativeLib_generate(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall getCharFromString(__int64 a1, __int64 a2);
__int64 __fastcall generateKey(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall generate(__int64 a1, char *s, __int64 a3, __int64 a4);
jclass __fastcall getTotpClass(_JNIEnv *a1);
__int64 __fastcall getTotpMethod(__int64 a1, __int64 a2);
__int64 __fastcall getTotpRef(__int64 a1, __int64 *a2, __int64 *a3);
jclass __fastcall getHmacClass(_JNIEnv *a1);
__int64 __fastcall getHmacMethod(__int64 a1, __int64 a2);
__int64 __fastcall getHmacRef(__int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall callTotpMethod(__int64 a1, __int64 a2, __int64 a3);
__int64 _JNIEnv::CallStaticObjectMethod(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall callHmacMethod(__int64 a1, __int64 a2, __int64 a3);
_DWORD *__fastcall SHA256Transform(_DWORD *result, __int64 a2);
long double __fastcall SHA256Init(__int64 a1);
_DWORD *__fastcall SHA256Update(_DWORD *result, _BYTE *a2, unsigned int a3);
_DWORD *__fastcall SHA256Final(__int64 a1, _BYTE *a2);
_BYTE *__fastcall SHA256(char *a1);
__int64 sub_1F7C(__int64 a1, __int64 a2, __int64 a3, ...);

//-------------------------------------------------------------------------
// Data declarations

__int128 xmmword_21D0 = 0x6A09E667000000000000000000000000LL; // weak
__int128 xmmword_21E0 = 0x510E527FA54FF53A3C6EF372BB67AE85LL; // weak
_UNKNOWN *off_6D30 = &off_6D30; // weak
_UNKNOWN k; // weak


//----- (0000000000000EE0) ----------------------------------------------------
void sub_EE0()
{
  JUMPOUT(0);
}
// EF0: control flows out of bounds to 0

//----- (0000000000000F00) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall getHmacRef(__int64 a1, __int64 *a2, __int64 *a3)
{
  return _Z10getHmacRefP7_JNIEnvRP7_jclassRP10_jmethodID(a1, a2, a3);
}

//----- (0000000000000F20) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall _JNIEnv::CallStaticObjectMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _ZN7_JNIEnv22CallStaticObjectMethodEP7_jclassP10_jmethodIDz(a1, a2, a3);
}

//----- (0000000000000F40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall generateKey(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  return _Z11generateKeyP7_JNIEnvPKcliiP8_jstring(a1, a2, a3, a4);
}

//----- (0000000000000F50) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall SHA256Transform(_DWORD *result, __int64 a2)
{
  return _Z15SHA256TransformP10SHA256_CTXPh(result, a2);
}

//----- (0000000000000F70) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall callTotpMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _Z14callTotpMethodP7_JNIEnvP7_jclassP10_jmethodIDP8_jstringliiS6_(a1, a2, a3);
}

//----- (0000000000000FA0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall generate(__int64 a1, char *s, __int64 a3, __int64 a4)
{
  return _Z8generateP7_JNIEnvPKcP8_jstringl(a1, s, a3, a4);
}

//----- (0000000000000FB0) ----------------------------------------------------
// attributes: thunk
_BYTE *__fastcall SHA256(char *a1)
{
  return _Z6SHA256Pc(a1);
}

//----- (0000000000001000) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall getTotpRef(__int64 a1, __int64 *a2, __int64 *a3)
{
  return _Z10getTotpRefP7_JNIEnvRP7_jclassRP10_jmethodID(a1, a2, a3);
}

//----- (0000000000001020) ----------------------------------------------------
// attributes: thunk
_DWORD *__fastcall SHA256Final(__int64 a1, _BYTE *a2)
{
  return _Z11SHA256FinalP10SHA256_CTXPh(a1, a2);
}

//----- (0000000000001030) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall callHmacMethod(__int64 a1, __int64 a2, __int64 a3)
{
  return _Z14callHmacMethodP7_JNIEnvP7_jclassP10_jmethodIDP8_jstringS6_S6_(a1, a2, a3);
}

//----- (0000000000001060) ----------------------------------------------------
__int64 start()
{
  return __cxa_finalize(&off_6D30);
}
// 6D30: using guessed type _UNKNOWN *off_6D30;

//----- (0000000000001074) ----------------------------------------------------
__int64 (*__fastcall sub_1074(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (0000000000001080) ----------------------------------------------------
__int64 __fastcall sub_1080(void *a1)
{
  return __cxa_atexit((void (*)(void *))sub_1074, a1, &off_6D30);
}
// 6D30: using guessed type _UNKNOWN *off_6D30;

//----- (000000000000109C) ----------------------------------------------------
char *__fastcall Java_co_ab180_airbridge_internal_signature_NativeLib_generate(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5)
{
  char *result; // x0
  char *v10; // x23
  __int64 v11; // x21

  result = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0);
  if ( result )
  {
    v10 = result;
    v11 = generate(a1, result, a4, a5);
    (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, a3, v10);
    return (char *)v11;
  }
  return result;
}

//----- (0000000000001124) ----------------------------------------------------
__int64 __fastcall getCharFromString(__int64 a1, __int64 a2)
{
  if ( a2 )
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a2, 0);
  else
    return 0;
}

//----- (0000000000001140) ----------------------------------------------------
__int64 __fastcall generateKey(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned __int64 StatusReg; // x25
  char *v8; // x25
  __int64 i; // x28
  __int64 v10; // x26
  __int64 v11; // x27
  __int64 v12; // x0
  __int64 v13; // x26
  const char *v14; // x0
  const char *v15; // x27
  _BYTE *v17; // x0
  _QWORD v18[2]; // [xsp+0h] [xbp-90h] BYREF
  __int64 v19; // [xsp+10h] [xbp-80h] BYREF
  __int64 v20; // [xsp+18h] [xbp-78h] BYREF
  char dest[20]; // [xsp+24h] [xbp-6Ch] BYREF
  __int64 v22; // [xsp+38h] [xbp-58h]

  StatusReg = _ReadStatusReg(TPIDR_EL0);
  v22 = *(_QWORD *)(StatusReg + 40);
  if ( (getTotpRef(a1, &v20, &v19) & 1) == 0 )
    return 0;
  v18[0] = v18;
  v18[1] = StatusReg;
  v8 = (char *)v18 - ((((4 * a4) | 1u) + 15LL) & 0x1FFFFFFF0LL);
  for ( i = 0; i != 64; i += 16 )
  {
    strncpy(dest, (const char *)(a2 + i), 0x10u);
    dest[16] = 0;
    v11 = v19;
    v10 = v20;
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, dest);
    v12 = callTotpMethod(a1, v10, v11);
    if ( !v12
      || (v13 = v12,
          (v14 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(
                                 a1,
                                 v12,
                                 0)) == 0) )
    {
      __android_log_print(3, "Airbridge", "cTOTP may not be null");
      return 0;
    }
    v15 = v14;
    if ( i )
      strcat(v8, v14);
    else
      strcpy(v8, v14);
    (*(void (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)a1 + 1360LL))(a1, v13, v15);
  }
  v17 = SHA256(v8);
  return (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 1336LL))(a1, v17);
}

//----- (00000000000012F4) ----------------------------------------------------
__int64 __fastcall generate(__int64 a1, char *s, __int64 a3, __int64 a4)
{
  __int64 v8; // [xsp+8h] [xbp-48h] BYREF
  __int64 v9[2]; // [xsp+10h] [xbp-40h] BYREF

  v9[1] = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  if ( strlen(s) == 64 )
  {
    if ( (getHmacRef(a1, v9, &v8) & 1) != 0 )
    {
      (*(void (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 1336LL))(a1, "HmacSHA256");
      if ( generateKey(a1, (__int64)s, a4, 8) )
        return callHmacMethod(a1, v9[0], v8);
      __android_log_print(3, "Airbridge", "Cannot find key");
    }
  }
  else
  {
    __android_log_print(3, "Airbridge", "SecretKey is invalid");
  }
  return 0;
}

//----- (0000000000001400) ----------------------------------------------------
jclass __fastcall getTotpClass(_JNIEnv *a1)
{
  return a1->functions->FindClass(a1, "co/ab180/airbridge/internal/signature/Totp");
}

//----- (0000000000001414) ----------------------------------------------------
__int64 __fastcall getTotpMethod(__int64 a1, __int64 a2)
{
  if ( a2 )
    return (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 904LL))(
             a1,
             a2,
             "generate",
             "(Ljava/lang/String;JIILjava/lang/String;)Ljava/lang/String;");
  else
    return 0;
}

//----- (000000000000143C) ----------------------------------------------------
__int64 __fastcall getTotpRef(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 v6; // x0
  __int64 v7; // x21
  __int64 v8; // x0

  v6 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
         a1,
         "co/ab180/airbridge/internal/signature/Totp");
  if ( v6 )
  {
    v7 = v6;
    v8 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 904LL))(
           a1,
           v6,
           "generate",
           "(Ljava/lang/String;JIILjava/lang/String;)Ljava/lang/String;");
    if ( v8 )
    {
      *a2 = v7;
      *a3 = v8;
      return 1;
    }
    __android_log_print(3, "Airbridge", "Cannot find Totp#generate method");
  }
  else
  {
    __android_log_print(3, "Airbridge", "Cannot find Totp class");
  }
  return 0;
}

//----- (00000000000014EC) ----------------------------------------------------
jclass __fastcall getHmacClass(_JNIEnv *a1)
{
  return a1->functions->FindClass(a1, "co/ab180/airbridge/internal/signature/Hmac");
}

//----- (0000000000001500) ----------------------------------------------------
__int64 __fastcall getHmacMethod(__int64 a1, __int64 a2)
{
  if ( a2 )
    return (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 904LL))(
             a1,
             a2,
             "generate",
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
  else
    return 0;
}

//----- (0000000000001528) ----------------------------------------------------
__int64 __fastcall getHmacRef(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 v6; // x0
  __int64 v7; // x21
  __int64 v8; // x0

  v6 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
         a1,
         "co/ab180/airbridge/internal/signature/Hmac");
  if ( v6 )
  {
    v7 = v6;
    v8 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 904LL))(
           a1,
           v6,
           "generate",
           "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
    if ( v8 )
    {
      *a2 = v7;
      *a3 = v8;
      return 1;
    }
    __android_log_print(3, "Airbridge", "Cannot find Hmac#generate method");
  }
  else
  {
    __android_log_print(3, "Airbridge", "Cannot find Hmac class");
  }
  return 0;
}

//----- (00000000000015D8) ----------------------------------------------------
__int64 __fastcall callTotpMethod(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a2 && a3 )
    return _JNIEnv::CallStaticObjectMethod(a1, a2, a3);
  else
    return 0;
}

//----- (00000000000015EC) ----------------------------------------------------
__int64 _JNIEnv::CallStaticObjectMethod(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __va_list_tag *); // x8
  gcc_va_list va1; // [xsp+B0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-38h] BYREF
  __int64 v7; // [xsp+F8h] [xbp-18h]

  va_start(va, a3);
  v7 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v3 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __va_list_tag *))(*(_QWORD *)a1 + 920LL);
  va_copy(va1, va);
  return v3(a1, a2, a3, va1);
}

//----- (0000000000001688) ----------------------------------------------------
__int64 __fastcall callHmacMethod(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a2 && a3 )
    return _JNIEnv::CallStaticObjectMethod(a1, a2, a3);
  else
    return 0;
}

//----- (000000000000169C) ----------------------------------------------------
_DWORD *__fastcall SHA256Transform(_DWORD *result, __int64 a2)
{
  int8x16_t v2; // q0
  __int64 v3; // x9
  uint16x4_t v4; // d3
  uint16x4_t v5; // d2
  uint16x4_t v6; // d5
  uint16x4_t v7; // d4
  __int128 v8; // q1
  __int128 v9; // q1
  __int128 v10; // q1
  char *v11; // x12
  int v12; // w13
  int v13; // w14
  unsigned int v14; // w15
  unsigned int v15; // w16
  int v16; // w13
  unsigned __int64 v17; // t2
  int v18; // w14
  int v19; // w14
  unsigned __int64 v20; // t2
  unsigned int v21; // w15
  unsigned int v22; // w13
  unsigned int v23; // w14
  int v24; // w11
  int v25; // w12
  int v26; // w9
  int v27; // w10
  __int64 v28; // x17
  unsigned int v29; // w22
  unsigned int v30; // w3
  int v31; // w21
  int v32; // w24
  int v33; // w25
  int v34; // w23
  unsigned int v35; // w20
  unsigned int v36; // w19
  unsigned int v37; // w7
  int v38; // w5
  unsigned __int64 v39; // t2
  int v40; // w22
  unsigned __int64 v41; // t2
  int v42; // w2
  int v43; // w1
  int v44; // w21
  int v45; // w23
  int v46; // w24
  int v47; // w21
  int v48; // w21
  _OWORD v49[2]; // [xsp+0h] [xbp-150h]
  _OWORD v50[14]; // [xsp+20h] [xbp-130h] BYREF
  __int64 v51; // [xsp+108h] [xbp-48h]

  v2.n128_u64[0] = 0xFF000000FFLL;
  v2.n128_u64[1] = 0xFF000000FFLL;
  v3 = 0;
  v51 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  v4.n64_u16[0] = (unsigned __int8)BYTE1(*(_OWORD *)a2);
  v5.n64_u16[0] = (unsigned __int8)*(_OWORD *)a2;
  v6.n64_u16[0] = BYTE3(*(_OWORD *)a2);
  v7.n64_u16[0] = (unsigned __int8)BYTE2(*(_OWORD *)a2);
  v4.n64_u16[1] = (unsigned __int8)((unsigned __int16)WORD2(*(_QWORD *)a2) >> 8);
  v5.n64_u16[1] = (unsigned __int8)BYTE4(*(_QWORD *)a2);
  v7.n64_u16[1] = (unsigned __int8)BYTE6(*(_QWORD *)a2);
  v6.n64_u16[1] = (unsigned __int8)HIBYTE(*(_QWORD *)a2);
  v5.n64_u16[2] = (unsigned __int8)*(_QWORD *)(a2 + 8);
  v4.n64_u16[2] = (unsigned __int8)BYTE1(*(_QWORD *)(a2 + 8));
  v7.n64_u16[2] = (unsigned __int8)BYTE2(*(_QWORD *)(a2 + 8));
  v5.n64_u16[3] = (unsigned __int8)BYTE12(*(_OWORD *)a2);
  v4.n64_u16[3] = (unsigned __int8)((unsigned __int16)WORD6(*(_OWORD *)a2) >> 8);
  v6.n64_u16[2] = BYTE3(*(_QWORD *)(a2 + 8));
  v7.n64_u16[3] = (unsigned __int8)BYTE14(*(_OWORD *)a2);
  v6.n64_u16[3] = (unsigned __int8)HIBYTE(*(_OWORD *)a2);
  v49[0] = vorrq_s8(
             vorrq_s8(
               vorrq_s8(vshlq_n_s32(vandq_s8(vmovl_u16(v4), v2), 0x10u), vshlq_n_s32(vmovl_u16(v5), 0x18u)),
               vshlq_n_s32(vandq_s8(vmovl_u16(v7), v2), 8u)),
             vandq_s8(vmovl_u16(v6), v2));
  v8 = *(_OWORD *)(a2 + 16);
  v4.n64_u16[0] = BYTE1(v8);
  v5.n64_u16[0] = (unsigned __int8)v8;
  v6.n64_u16[0] = BYTE3(v8);
  v7.n64_u16[0] = BYTE2(v8);
  v4.n64_u16[1] = BYTE5(v8);
  v5.n64_u16[1] = BYTE4(v8);
  v7.n64_u16[1] = BYTE6(v8);
  v6.n64_u16[1] = BYTE7(v8);
  v5.n64_u16[2] = BYTE8(v8);
  v4.n64_u16[2] = BYTE9(v8);
  v7.n64_u16[2] = BYTE10(v8);
  v5.n64_u16[3] = BYTE12(v8);
  v4.n64_u16[3] = BYTE13(v8);
  v6.n64_u16[2] = BYTE11(v8);
  v7.n64_u16[3] = BYTE14(v8);
  v6.n64_u16[3] = HIBYTE(v8);
  v49[1] = vorrq_s8(
             vorrq_s8(
               vorrq_s8(vshlq_n_s32(vandq_s8(vmovl_u16(v4), v2), 0x10u), vshlq_n_s32(vmovl_u16(v5), 0x18u)),
               vshlq_n_s32(vandq_s8(vmovl_u16(v7), v2), 8u)),
             vandq_s8(vmovl_u16(v6), v2));
  v9 = *(_OWORD *)(a2 + 32);
  v5.n64_u16[0] = (unsigned __int8)v9;
  v4.n64_u16[0] = BYTE1(v9);
  v5.n64_u16[1] = BYTE4(v9);
  v7.n64_u16[0] = BYTE2(v9);
  v4.n64_u16[1] = BYTE5(v9);
  v6.n64_u16[0] = BYTE3(v9);
  v7.n64_u16[1] = BYTE6(v9);
  v6.n64_u16[1] = BYTE7(v9);
  v5.n64_u16[2] = BYTE8(v9);
  v4.n64_u16[2] = BYTE9(v9);
  v7.n64_u16[2] = BYTE10(v9);
  v6.n64_u16[2] = BYTE11(v9);
  v5.n64_u16[3] = BYTE12(v9);
  v4.n64_u16[3] = BYTE13(v9);
  v7.n64_u16[3] = BYTE14(v9);
  v6.n64_u16[3] = HIBYTE(v9);
  v50[0] = vorrq_s8(
             vorrq_s8(
               vorrq_s8(vshlq_n_s32(vandq_s8(vmovl_u16(v4), v2), 0x10u), vshlq_n_s32(vmovl_u16(v5), 0x18u)),
               vshlq_n_s32(vandq_s8(vmovl_u16(v7), v2), 8u)),
             vandq_s8(vmovl_u16(v6), v2));
  v10 = *(_OWORD *)(a2 + 48);
  v4.n64_u16[0] = BYTE1(v10);
  v5.n64_u16[0] = (unsigned __int8)v10;
  v6.n64_u16[0] = BYTE3(v10);
  v5.n64_u16[1] = BYTE4(v10);
  v7.n64_u16[0] = BYTE2(v10);
  v4.n64_u16[1] = BYTE5(v10);
  v7.n64_u16[1] = BYTE6(v10);
  v6.n64_u16[1] = BYTE7(v10);
  v5.n64_u16[2] = BYTE8(v10);
  v4.n64_u16[2] = BYTE9(v10);
  v7.n64_u16[2] = BYTE10(v10);
  v6.n64_u16[2] = BYTE11(v10);
  v5.n64_u16[3] = BYTE12(v10);
  v4.n64_u16[3] = BYTE13(v10);
  v7.n64_u16[3] = BYTE14(v10);
  v6.n64_u16[3] = HIBYTE(v10);
  v50[1] = vorrq_s8(
             vorrq_s8(
               vorrq_s8(vshlq_n_s32(vandq_s8(vmovl_u16(v4), v2), 0x10u), vshlq_n_s32(vmovl_u16(v5), 0x18u)),
               vshlq_n_s32(vandq_s8(vmovl_u16(v7), v2), 8u)),
             vandq_s8(vmovl_u16(v6), v2));
  do
  {
    v11 = (char *)v50 + v3 + 4;
    v12 = *(_DWORD *)((char *)v49 + v3);
    v13 = *(_DWORD *)((char *)v50 + v3 + 4);
    v14 = *(_DWORD *)((char *)&v50[1] + v3 + 8);
    v15 = *(_DWORD *)((char *)v49 + v3 + 4);
    v3 += 4;
    v16 = v12 + v13;
    HIDWORD(v17) = v14;
    LODWORD(v17) = v14;
    v18 = (v17 >> 19) ^ (v14 >> 10);
    v20 = __PAIR64__(v15, __ROR4__(v14, 17));
    v19 = v18 ^ v20;
    LODWORD(v20) = v15;
    *((_DWORD *)v11 + 7) = v16 + v19 + ((v20 >> 18) ^ (v15 >> 3) ^ __ROR4__(v15, 7));
  }
  while ( v3 != 192 );
  v21 = result[20];
  v23 = result[21];
  v22 = result[22];
  v25 = result[23];
  v24 = result[24];
  v27 = result[25];
  v26 = result[26];
  v28 = 0;
  v29 = result[19];
  v30 = v21;
  v31 = v26;
  v32 = v27;
  v33 = v24;
  v34 = v25;
  v35 = v22;
  v36 = v23;
  do
  {
    v37 = v36;
    v38 = v34;
    v36 = v30;
    v30 = v29;
    HIDWORD(v39) = v34;
    LODWORD(v39) = v34;
    v40 = (v39 >> 6) ^ __ROR4__(v34, 11);
    v41 = __PAIR64__(v30, __ROR4__(v34, 25));
    v42 = v33;
    v43 = v32;
    v44 = (v40 ^ v41) + v31;
    LODWORD(v41) = v30;
    v45 = v32 & ~v34 | v33 & v34;
    v46 = *(_DWORD *)((char *)v49 + v28);
    v47 = v44 + v45 + *(_DWORD *)((char *)&k + v28);
    v28 += 4;
    v48 = v47 + v46;
    v34 = v48 + v35;
    v29 = ((v41 >> 2) ^ __ROR4__(v30, 13) ^ __ROR4__(v30, 22)) + (v30 & (v36 ^ v37) ^ v36 & v37) + v48;
    v31 = v43;
    v32 = v33;
    v33 = v38;
    v35 = v37;
  }
  while ( v28 != 256 );
  result[19] += v29;
  result[20] = v30 + v21;
  result[21] = v36 + v23;
  result[22] = v37 + v22;
  result[23] = v34 + v25;
  result[24] = v38 + v24;
  result[25] = v42 + v27;
  result[26] = v43 + v26;
  return result;
}

//----- (0000000000001B38) ----------------------------------------------------
long double __fastcall SHA256Init(__int64 a1)
{
  long double result; // q0

  result = *(long double *)&xmmword_21D0;
  *(_QWORD *)(a1 + 96) = 0x1F83D9AB9B05688CLL;
  *(_OWORD *)(a1 + 64) = xmmword_21D0;
  *(_OWORD *)(a1 + 80) = xmmword_21E0;
  *(_DWORD *)(a1 + 104) = 1541459225;
  return result;
}
// 21D0: using guessed type __int128 xmmword_21D0;
// 21E0: using guessed type __int128 xmmword_21E0;

//----- (0000000000001B70) ----------------------------------------------------
_DWORD *__fastcall SHA256Update(_DWORD *result, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // w8
  _DWORD *v5; // x20
  __int64 v6; // x21
  unsigned int v7; // w9

  if ( a3 )
  {
    v3 = result[16];
    v5 = result;
    v6 = a3;
    do
    {
      *((_BYTE *)v5 + v3) = *a2;
      v3 = v5[16] + 1;
      v5[16] = v3;
      if ( v3 == 64 )
      {
        result = SHA256Transform(v5, (__int64)v5);
        v7 = v5[17];
        if ( v7 >= 0xFFFFFE00 )
          ++v5[18];
        v3 = 0;
        v5[16] = 0;
        v5[17] = v7 + 512;
      }
      --v6;
      ++a2;
    }
    while ( v6 );
  }
  return result;
}

//----- (0000000000001C04) ----------------------------------------------------
_DWORD *__fastcall SHA256Final(__int64 a1, _BYTE *a2)
{
  __int64 v2; // x8
  unsigned int v5; // w9
  unsigned int v6; // w9
  int v7; // w10
  int v8; // w8
  unsigned int v9; // w9
  _DWORD *result; // x0

  v2 = *(unsigned int *)(a1 + 64);
  v5 = v2 + 1;
  *(_BYTE *)(a1 + v2) = 0x80;
  if ( (unsigned int)v2 >= 0x38 )
  {
    if ( v5 <= 0x3F )
      memset((void *)(a1 + v5), 0, (unsigned int)(62 - v2) + 1LL);
    SHA256Transform((_DWORD *)a1, a1);
    *(_QWORD *)(a1 + 48) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  else if ( v5 <= 0x37 )
  {
    memset((void *)(v2 + a1 + 1), 0, 55 - v2);
  }
  v6 = *(_DWORD *)(a1 + 68);
  v7 = 8 * *(_DWORD *)(a1 + 64);
  v8 = *(_DWORD *)(a1 + 72);
  if ( v6 > ~v7 )
    *(_DWORD *)(a1 + 72) = ++v8;
  v9 = v7 + v6;
  *(_BYTE *)(a1 + 58) = BYTE1(v8);
  *(_BYTE *)(a1 + 57) = BYTE2(v8);
  *(_BYTE *)(a1 + 59) = v8;
  *(_DWORD *)(a1 + 68) = v9;
  *(_BYTE *)(a1 + 63) = v9;
  *(_BYTE *)(a1 + 62) = BYTE1(v9);
  *(_BYTE *)(a1 + 61) = BYTE2(v9);
  *(_BYTE *)(a1 + 60) = HIBYTE(v9);
  *(_BYTE *)(a1 + 56) = HIBYTE(v8);
  result = SHA256Transform((_DWORD *)a1, a1);
  *a2 = *(_BYTE *)(a1 + 79);
  a2[4] = *(_BYTE *)(a1 + 83);
  a2[8] = *(_BYTE *)(a1 + 87);
  a2[12] = *(_BYTE *)(a1 + 91);
  a2[16] = *(_BYTE *)(a1 + 95);
  a2[20] = *(_BYTE *)(a1 + 99);
  a2[24] = *(_BYTE *)(a1 + 103);
  a2[28] = *(_BYTE *)(a1 + 107);
  a2[1] = *(_WORD *)(a1 + 78);
  a2[5] = *(_WORD *)(a1 + 82);
  a2[9] = *(_WORD *)(a1 + 86);
  a2[13] = *(_WORD *)(a1 + 90);
  a2[17] = *(_WORD *)(a1 + 94);
  a2[21] = *(_WORD *)(a1 + 98);
  a2[25] = *(_WORD *)(a1 + 102);
  a2[29] = *(_WORD *)(a1 + 106);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 76));
  a2[6] = BYTE1(*(_DWORD *)(a1 + 80));
  a2[10] = BYTE1(*(_DWORD *)(a1 + 84));
  a2[14] = BYTE1(*(_DWORD *)(a1 + 88));
  a2[18] = BYTE1(*(_DWORD *)(a1 + 92));
  a2[22] = BYTE1(*(_DWORD *)(a1 + 96));
  a2[26] = BYTE1(*(_DWORD *)(a1 + 100));
  a2[30] = BYTE1(*(_DWORD *)(a1 + 104));
  a2[3] = *(_DWORD *)(a1 + 76);
  a2[7] = *(_DWORD *)(a1 + 80);
  a2[11] = *(_DWORD *)(a1 + 84);
  a2[15] = *(_DWORD *)(a1 + 88);
  a2[19] = *(_DWORD *)(a1 + 92);
  a2[23] = *(_DWORD *)(a1 + 96);
  a2[27] = *(_DWORD *)(a1 + 100);
  a2[31] = *(_DWORD *)(a1 + 104);
  return result;
}

//----- (0000000000001E28) ----------------------------------------------------
_BYTE *__fastcall SHA256(char *a1)
{
  char *v1; // x20
  __int64 v2; // x21
  _BYTE *v3; // x19
  unsigned int v4; // w8
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 i; // x21
  _BYTE v9[4]; // [xsp+4h] [xbp-CCh] BYREF
  _BYTE v10[32]; // [xsp+8h] [xbp-C8h] BYREF
  _DWORD v11[16]; // [xsp+28h] [xbp-A8h] BYREF
  __int128 v12; // [xsp+68h] [xbp-68h]
  __int128 v13; // [xsp+78h] [xbp-58h]
  __int64 v14; // [xsp+88h] [xbp-48h]
  int v15; // [xsp+90h] [xbp-40h]
  __int64 v16; // [xsp+98h] [xbp-38h]

  v1 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  LODWORD(v2) = strlen(a1);
  v3 = malloc(0x41u);
  *v3 = 0;
  v13 = xmmword_21E0;
  v12 = xmmword_21D0;
  v14 = 0x1F83D9AB9B05688CLL;
  v15 = 1541459225;
  if ( (_DWORD)v2 )
  {
    v4 = 0;
    v2 = (unsigned int)v2;
    do
    {
      *((_BYTE *)v11 + v4) = *v1;
      LODWORD(v12) = v12 + 1;
      v4 = v12;
      if ( (_DWORD)v12 == 64 )
      {
        SHA256Transform(v11, (__int64)v11);
        if ( DWORD1(v12) >= 0xFFFFFE00 )
          ++DWORD2(v12);
        v4 = 0;
        LODWORD(v12) = 0;
        DWORD1(v12) += 512;
      }
      --v2;
      ++v1;
    }
    while ( v2 );
  }
  SHA256Final((__int64)v11, v10);
  for ( i = 0; i != 32; ++i )
  {
    sub_1F7C((__int64)v9, v5, v6, (unsigned __int8)v10[i]);
    __strcat_chk(v3, v9, 65);
  }
  return v3;
}
// 1F2C: variable 'v5' is possibly undefined
// 1F2C: variable 'v6' is possibly undefined
// FE0: using guessed type __int64 __fastcall __strcat_chk(_QWORD, _QWORD, _QWORD);
// 21D0: using guessed type __int128 xmmword_21D0;
// 21E0: using guessed type __int128 xmmword_21E0;

//----- (0000000000001F7C) ----------------------------------------------------
__int64 sub_1F7C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-38h] BYREF
  __int64 v6; // [xsp+F8h] [xbp-18h]

  va_start(va, a3);
  v6 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);
  va_copy(va1, va);
  return __vsprintf_chk(a1, 0, 3, "%02x", (unsigned int)va1);
}
// FC0: using guessed type __int64 __vsprintf_chk(_QWORD, _QWORD, _QWORD, const char *, ...);

// nfuncs=59 queued=33 decompiled=33 lumina nreq=0 worse=0 better=0
// ALL OK, 33 function(s) have been successfully decompiled
